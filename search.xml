<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《太聪明》学习笔记]]></title>
    <url>%2F2024%2F04%2F09%2F%E3%80%8A%E5%A4%AA%E8%81%AA%E6%98%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[这段时间把《太聪明》这首歌好好的学习了下，记一点自己的笔记~ （插一张陈老师的专辑封面😉） 前奏首先是前奏部分，主要有两点： 从 E 大三和弦开始，后面跟了两个双音，分别是 #G+E 和 #F+A，这两组双音可以理解为 E 和弦和 #Fm 和弦，也就是 Ⅰ和 Ⅱm。后面又跟网上的谱子比对了下，发现网上的谱子把这两个双音都是记成了 #G+B 和 #F+A，也就是 #Gm 和弦和 #Fm 和弦，对应 Ⅲm 和 Ⅱm，自己又仔细听了下，感觉好像也说的过去，不知道是不是我的耳朵只能听到 #G 这个音的缘故😂。 整个前奏部分中，不断重复着低音 E 弦（6 弦空弦）的演奏，这里其实可以理解成 Bass，更能凸显出双音的旋律。 主歌主歌部分，拆开来理解。 第一部分第一个部分的和声进行是 E -&gt; Eaug -&gt; E6 -&gt; E7，这四个和弦的组成音分别是： 和弦 组成音（首调） 组成音（固定调） E 1、3、5 E、#G、B Eaug 1、3、#5 E、#G、#B(C) E6 1、3、5、6 E、#G、B、#C E7 1、3、5、b7 E、#G、B、D 观察这些和弦的组成音，对比一下所弹奏的音符，其实在这段进行中隐藏着一条旋律线：5 -&gt; #5 -&gt; 6 -&gt; b7（也即：B -&gt; #B(C) -&gt; #C -&gt; D），仔细观察下，可以发现这些音呈半音的关系向高递进。同时换个角度，可以理解成这四个小节在不断的改变 E 这个主和弦的 5 音。这种技巧有点类似 BASS LINE 的编写技巧，但这里并不是 BASS 音，实际上，在《民谣吉他考级教程》这本书的第七章提到过，这是一种叫做“Cliches”的技巧，即在一个和弦的根音或五音上以半音或级进的方式作上行或下行。 另外，还有一个要注意的地方：在演奏 E6 和弦时，并没有弹该和弦的 5 音，实际弹奏的其实是 #Cm/E 这个和弦，但这里理解成 E6 和弦更贴切，也更便于理解。 第二部分第二部分的和声进行是：A -&gt; Am -&gt; #Gm7 -&gt; #C7 -&gt; #Fm7 -&gt; #Fm7b5 -&gt; #Gm7 -&gt; #C7 -&gt; #Fm7 -&gt; B7sus4add9，从和弦级数理解，也就是：Ⅰ -&gt; Ⅰm -&gt; Ⅲm7 -&gt; Ⅵ7 -&gt; Ⅱm7 -&gt; Ⅱm7b5 -&gt; Ⅲm7 -&gt; Ⅵ7 -&gt; Ⅱm7 -&gt; Ⅴ7sus4add9。主歌部分的细节很多，展开几点： 首先是 A -&gt; Am 的进行，这里可以理解为借用了同名 e 小调的四级和弦 Am，这种和弦混合或调式的内转现象我们可以称其为平行大小调互转或平行调内互换。那为什么可以借用呢？从组成音上分析，这两个和弦其实只差了一个音。同时，在实际演奏中，2 弦上演奏的音符构成一个短暂的半音下行，这与前面提到的“Cliches”技巧有点异曲同工的感觉😂。 #Gm7 是 Ⅲm7 和弦，而前面提到的 Am 其实在歌曲中应属于 Ⅳ 级和声。所以，这里 Ⅳ 级和声与 Ⅲm 的衔接并不是很和谐，但由于前面的 A -&gt; Am 调式内转，此时正好需要这样一个把歌曲的调快速并强力的扭转到 E 大调上来的和弦，那么 #Gm7 则完美的完成了这个任务。 大多数的流行歌曲中会使用 Ⅲm -&gt; Ⅵm -&gt; Ⅱm -&gt; V 的和声走向来使歌曲进入一种更婉转的表达，实际是利用了 Ⅲ 级和声的特点，这首歌所使用的 #Gm7 和弦也是如此。 #Fm7(Ⅱ) 可以作为 A(Ⅳ) 的代替和弦，因为 Ⅱ 和 Ⅳ 其实只差了一个音：Ⅱ(2, 4, 6) 和 Ⅳ(4, 6, 1)。 #Fm7 -&gt; #Fm7b5，也可以理解为“Cliches”技巧。 #C7 是 #F 大调的属 7 和弦，在这里作为“次属和弦”（次属和弦也属于一种离调和弦，它经常被使用在大调（或小调）歌曲的 Ⅰ、Ⅱ、Ⅲ、Ⅳ、Ⅴ 级和弦中）出现，目的是为了衔接 #Fm7 这个 E 大调的 Ⅱm7 和弦。 —— 持续更新ing😪 ——]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024_3_月总结]]></title>
    <url>%2F2024%2F04%2F01%2F2024-3-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[好消息，这周清明节要放假了😉 太聪明 - 陈绮贞Your browser does not support the audio tag. 这段时间一直在练习这首歌~ 天气逐渐回暖了，又到了万物复苏、阳光明媚、春暖花开的季节了~😂 还是老规矩，先说说工作上的事情。这个月有一个比较重要的单子，属于是领导直接发话要做的事情了，据说还是带有 ZZ 色彩的任务（我：😶...）。虽然心里略无语，但该干的事情咱还是按部就班的好好干😋。不过，好在代码本身不需要做太多的修改，原先代码的功能就已经很完善了，基本上满足了业务需求，而我只是修复了其中某些 bug，以确保能更好的达到业务需求。 老实讲，拿现在的自己与去年的自己相比，确实有很大的进步，这一点是自己能切身体会到的，也许这就是一年的进步吧。 具体来讲，个人认为主要体现在三个方面： 对项目的熟悉程度 个人编码能力的提升 分析、解决问题的能力 另外，个人认为以上三个方面相辅相成，同等重要，共同构成了我个人的综合能力。 好了，关于工作方面的事情就说这些。 第二个是学习，这个月看了一些艺术和心理相关的课程，对技术知识的学习少了些热忱。尽管这些都是计划内的事情，但是还是觉得有点心理不适（因为没时间学习计算机啦~），并且觉得时间不够用啊。 另外，《罪与罚》 已经读完，并且也写了一点书评。本来打算连着继续开坑，读黑塞的《德米安》和《悉达多》，但目前进度只到了《德米安》的一半，争取四月份两本读完吧。值得一提的是，《德米安》这本小说的语言真如诗歌一般，优美而又富有哲理，有些地方让人不求甚解，也许是需要一定的阅历吧。 最后就是练琴了，其实也就是上面提到的《太聪明》，这个月是盘过来盘过去，弹了很多遍了😂。伴奏已经用带过来的声卡录好了，自己仔细听了下，虽有一点瑕疵，但基本还算满意，不过最好还是重录下。 细细算来，这首歌已经练了很久了。如果只是把谱子学会，其实很快就能练好。 那为啥还要停留这么久呢？ 一是弹唱配合还没练好，hah~😁;二是这首歌的吉他编配很值得学习。 以上两方面的功夫都没做到位，真不能说算是把这首歌“学会”了。 好了，就这些吧。 最后，整体来讲，三月份是过的比较慵懒、闲散的一个月😂，可能是自己懈怠了吧。为了改变这样的现状，四月份开始之前，自己会先列一个清单，看看有哪些拖了很久没有干的事情，赶紧去干一把😤。 就酱，下个月见~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024_1-2月总结]]></title>
    <url>%2F2024%2F02%2F25%2F2024-1-2%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天 SH 竟然下了一会小雪，可惜没过多久就化完了... 月半弯 - 张学友Your browser does not support the audio tag. 这首歌的旋律真好，但我最喜欢的还是伴奏中的弦乐（包括玉置浩二的版本），千言万语绘成一缕缕的情丝，沿着颤动的琴弦不断倾诉... 好了，回到正题来，这次一下子将两个月的总结放在一起了，主要原因是觉得自己每次写的跟流水账一样，没什么营养，不如不写了，hah~。不过，转头一想，也许只是因为懒...好吧😂 一、二月的工作其实没什么说头，都是按部就班的工作，本身到了年末，就不应该有太多的事情了，家家户户都忙着过年呢。 再把目光放到学习上，一月份看了一些 Java 的课程，可惜没看完，目前准备接着看，尽快看完吧。同时，二月过完年来了之后，又在 MOOC 上给自己选了好几门课，当然了，这次不仅仅只有计算机类的课程。所以，接下来的计划，就是把这些课程学完。 另外，这俩月一直在看陀思妥耶夫斯基的《罪与罚》，这是一本长篇小说。到目前为止，已经读了大约百分之六十。老实讲，长篇小说读的有点累 + 无聊，如果是杂文跟短篇，我估计这俩月我能看完好几本了。陀氏这本书写的不错，但有些地方是真的废话，而且俄式人名很长，不太好记，甚至还会有昵称。总之，得尽快把这本书读完，去年一共才读完九本书，得赶赶进度。😠 还有练琴计划，这俩月练的比较多，一共扒了三张谱，做了一张原来扒过的谱，一共是四张。目前在练习的歌曲是陈老师的《太聪明》，为什么要练这首歌呢？哈哈，一是这首歌老是出现在我的 B 站首页，天天看见，本来不想练也变得想练了；二是，这首歌有点难，正好可以用来当作练习曲。实际上，《太聪明》这首歌练到现在，已经快完了，整体感觉细节很多，部分小节的衔接还需要再多练练，这里就不展开了，尽快练完吧。 最后回到生活上，一、二月天气冷了许多，但好在自己有做好保暖，到目前位置还没有过感冒、流涕等症状。过年期间，老老实实的在家休息，啥也没干，吃席没有去，走亲戚也基本没有去。但是，时间还是过的很快，好像上一秒还在回家的火车上，下一秒就已经回来上班了。不过，没事，往后见面的时间多着呢。可惜的是，原本打算回家好好做几顿饭的，结果一顿没做，惭愧啊，哈哈，得找时间把母亲的味道学到手里，不然以后自己想吃的时候，没得吃了。 好了，就说这么多吧。 PS：一月底公司吃年饭的时候，我竟然中奖了，这是人生第一次中奖！🤣PPS：换了个新头像~]]></content>
  </entry>
  <entry>
    <title><![CDATA[2023_年末小结]]></title>
    <url>%2F2024%2F01%2F07%2F2023-%E5%B9%B4%E6%9C%AB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[现在是 2024 了哦🎉~ 我想要的感觉 - 张震岳Your browser does not support the audio tag. 现在是 2024 年第一周的周日，本来，这篇文章应该出现在元旦那天的，但是那天忙着弹琴去了，就搁浅了，现在重新完成。 闲话少说，赶紧回头看看 2023 一年又干了那些傻事😂。 1 - 2 月去年的这时候，刚刚阳康，就回到公司上班了。尽管对工作还不是很熟悉，但也在慢慢的推进中。春节假期，就是回家了。到家后，又在家短暂的停留了几天，又吃到了家里的味道，很怀念。 回到 SH 后，就继续上班，还有找房子，这之间又发生了一系列的事情，但好在都平稳度过了。 3 - 4 月这俩月，稍微有点忙，工作地点也搬到了另外一个园区，此时正好赶上了早樱开放，新园区的樱花🌸随着春风飞舞在空中，十分美丽。 也是在这个时间段，对工作上项目的了解更加深入了一些。同时，这俩月还看完了 Tinyhttpd 这个古老而又经典的小项目，重新温故了下 C 语言，并且重新开始了 Nand2tetris 这个课程。 5 - 6 月这俩月，也比较忙，但好在工作都有惊无险的完成了。 唯一让自己介怀的事情就是身体不舒服☹，尽管后面有所恢复，但是心里很烦。身体健康真的很重要啊，哪怕只有一点点不舒服的感觉，都很烦人，让人心神不宁的。 好消息是，Nand2tetris 上半部分的项目已经是全部完成了，对应的 blog 也都写完了，甚至到六月结束，这个课程已经进行到第十章了，越学越觉得有趣👀。 同时，还把原来看过的 C++ 课程又看了一遍，又有了一些不一样的收获。 7 - 8 月暑期不算很忙，但是没有长假期，还是会觉得上班比较累。 这俩月看了很多 Linux/C 相关的视频，学到了很多东西，特别是对指针的理解。 另外，因为天气热起来了，这俩月游泳🏊‍的次数很多，游的还挺开下的，哈哈。不过，这俩月好像比较少练琴... 9 - 10 月这俩月工作上也不算忙，还是按部就班的完成日常任务，另外还有中秋和国庆的两个长假，哈哈，一共放了 8 天，很舒服，就是时候调休很难受😂。 这俩月开始一项新的运动——台球🎱，还挺有意思的，哈哈。前面几个月的锻炼，已经有了一定的收获，体重增加了大概 3 - 4 公斤，虽然还是瘦，哈哈。 值得一提的是，九月读完了《The C Programming Language》这本书，收获很多。另外，还开始了《组成原理》的学习。 练琴也在继续... 11 月工作不忙，哈哈，我好像全部都是不忙...只能说我挣得太少🤣 这个月把 HIT 组成原理的上册已经学完了。 趁着双十一，还给自己买了一些衣服和一双鞋子，穿起来自我感觉还不错。 12 月工作还是不忙，哈哈哈哈😂（我真怕我失业，卧槽...） 这个月有点霉，本来月初还自我提醒不要被支原体感染了，结果还是被甲流感染了...而且这次的症状和去年的新冠很像（对本人而言），刚开始嗓子还特别痛，话都说不出来，哎😔。 不过现在已经是好了，就是感觉嗓子还没完全恢复，唱歌感觉怪怪的，而且很容易起痰。 不过这个月，最开心的是月底元旦假期跟朋友小 z 一起去泡澡，泡的很舒服，事后又打了一个小时乒乓球和两个小时台球。这一个小时的乒乓球，最让我开心，看着面前的朋友小 z 挥舞乒乓球拍的身影，脑海中沉睡的记忆一下子就被唤醒了。曾经，初中校园乒乓球台是我们几个小伙伴最爱的玩乐场所。而脑海中的身影也开始与现在面前的朋友小 z 开始重合在一起，我甚至不假思索的将二者的动作都重叠在了一起。十五年啊，十五年过去了，他的动作竟然还跟原来一致。 这一个小时我真的过的很开心...😌 —————————————————————— 这是一条分割线 —————————————————————— 下面再统计一下 2023 读过的书和练过的曲子或歌吧 书 📕 《局外人》，第一本加缪的书。 《沉默的大多数》 《乡土中国》，好像解答了心中的一些疑惑，但又有了新的问题😂。 《黑铁时代》 《一只特立独行的猪》 《白银时代》 《黄金时代》 《The C Programming Language》，不愧是 C 语言之父的书，感觉是今年喜欢的书了🤔。 《我与地坛》，读的有点疼痛... 没到十本，有点少了...🤐 歌 Or 曲 🎵 《One more time, One more chance》（能找到的，今年最先开始练习的曲目记录，就是这个了😂），A 调，山崎大叔的歌（也是《月亮与高丽菜》和《秒速五厘米》的插曲），按原曲的编配练习，主、副歌的和弦进行都练完了，结尾之前还有一个 bridge 没练。另外，还练习了一下主、副歌的唱法，自我感觉还行，突然发现日文歌的咬字好像比英文歌好掌握一点？😐话说，不知道是不是因为三四月份樱花🌸盛开了，所以那时想练习这个🙈。 《Wind song》，D 调，用的是押尾《Dramatic》专辑版本的谱子（据说专门为极光写的曲子），到目前为止，已经是纯纯的肌肉记忆了，基本忘不掉了，就是还有些细节处理的不好，得再练练。 《我要你》，A 调，任素汐的歌，简单但很动听，坏消息：指法扒了没记谱（已经忘的差不多了😑），好消息：和弦进行扒了，记下了😋。 《Tycho》，G 调，用的是押尾《STARTING POINT》专辑的谱子，没练完，原因是练的时候总觉得没劲😂。 《Romance》，古典吉他的入门曲（虽然入门，但是也是首名气很大的古典吉他曲子），e 小调转 E 大调，钢弦的声音确实没有尼龙弦听起来柔和。 《她来听我的演唱会》，#F 调，歌神的歌，听了很多遍原曲伴奏，很感动。练习的谱子是王鹰书上的，和弦走向大致是忠实原曲，前奏很像，原曲间奏是两把吉他完成的，这里改编成一把了，听起来也能接受。 《Flightless Bird, American Mouth》，bE 调，《暮光之城》的插曲，扒完了原曲中吉他的和弦进行和一些指法细节（太简单，没记谱），没想到就是简单的 1645。 《风吹麦浪》，D 调，李健的歌，用的是老姚的简易版谱子，作为刚开始练习拨片弹奏的练习曲（因为觉得旋律好听），已经交作业了。 《前向きな乙女心》，C 调，是首日系风格明显的简单小曲子（也是《士兵突击》的插曲，一听就容易想起成才...），纯纯的自己扒谱，扒完了与网上的其他版本比对了下，发现自己耳朵还是不太行😂（有些细节还是听不出来）。后面又分析了下和声进行，增进了一下自己薄弱的乐理知识，目前已经练的差不多了，可以录录看了。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_11_月总结]]></title>
    <url>%2F2023%2F12%2F04%2F2023-11-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[今天已经是 12 月 4 日了... Wedding Bell - DEPAPEPEYour browser does not support the audio tag. 最近很迷这首曲子，虽然原来已经听过很多遍了，真想找个人一起录一下这个曲子...😶 天气越来越冷了，要注意保暖，不要生病，最近是支原体感染的多发期，还是要戴好口罩。不过话说回来，今年冬天确实要比去年暖和不少，难怪之前看到热搜上说今年冬天是最暖和的，整挺好😂。 好了，回到正题。 就工作的情况而言，十一月很常规，不忙也不闲，本月也是正常常规投产了一次。本来是有几个单子的，结果搞来搞去，能正常投的就一个了，其他要么延期到十二月了，要么延期到明年一月了😂。啥时候投，显然不是我能决定的事情，所以听安排吧~仔细想想，十一月结束了，就意味着自己重新参加工作整整一年了，时间真的很快（不得不再次感慨）。这一年里，有得有失，但不可否认的是，自身的成长又增多了一份，具体会在年终的总结谈到，这里先不写了。 接着，个人学习方面，MOOC 上 HIT 的组成原理的上半部分已经是结束了，但是下部分还有六章，按照自己之前的进度，估计是难以结束了。所有的作业提交日期是在这个月的 18 号，不行了，只能想办法爆肝一下了。试试看，自己能不能挑战成功。 生活方面的话，因为天气变冷了，锻炼💪也减少了，但也姑且算是正常水平吧，唯一减少的就是五公里慢跑有氧减少了几次。其实锻炼是否减少无所谓，主要是不能长胖，不能长多余的肉，哈哈😁。吃吃喝喝方面也还行，秋冬季节比较干燥，平均每周要消耗掉五个梨🍐（平均五块一个，略贵🤨），用于补充身体的水分。这么做之后，这个秋天和冬天，嘴唇没有干裂过，按以往的情况，必须是要涂唇膏才行的😂。另外，上个月给自己买的一堆衣服，效果还算不错😎。 最后就是，我心爱的“土琵琶”🎸了。《她来听我的演唱会》的伴奏算是练完了，弹唱结合还差很多。实际上，自我感觉光是唱就已经差很多了，哈哈🤣，慢慢练吧。另外，这个月想着自己至少要扒三十首儿歌谱子（只是简谱），并在吉他上弹熟，当作自己的“闭关修炼”吧，之所以想这么做的原因是自己认识到要靠耳朵而不是眼睛来学习音乐了。总之，加油吧。 好了，差不多了，加油干吧。 PS：得给自己再买点衣服才行。😏]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_7]]></title>
    <url>%2F2023%2F11%2F13%2FHIT-CO-Week-7%2F</url>
    <content type="text"><![CDATA[继续学习下册... 这一章重点在于理解，而想要加深理解可以从两个方面入手：总结和练习。 本章的主要内容是：计算机中数的表示、计算机的运算方法和运算器的设计，学习这一章需要有点耐心。 无符号数和有符号数无符号数无符号数比较简单，寄存器的位数直接反映了无符号数的表示范围。实际上，有 C 语言基础的话，这是不言而喻的，就不再赘述了。 可能会有人有疑问：为什么没有无符号小数？就笔者的个人理解而言，一是因为没有必要去专门使用无符号小数，二是因为小数在计算机中的表示本身就很麻烦了，在加上无符号号小数就更麻烦了。当然，具体的原因只能去问当初发明计算机的那帮老头子了。 有符号数有符号数就比较复杂了，分为整数和小数，下面要介绍的各种表示法都是从这两个方面展开的。 机器数与真值首先要明确的两个概念是：机器数与真值。所谓机器数，简单理解就是计算机内存储的数，这个数跟现实中的数是存在差异的；而这里的真值不是true和false，只是现实中的有大小和正负的数，它可以是十进制的也可以是二进制的。 以下数学定义部分，$x$ 都为真值，$n$ 为整数或小数的位数。 原码表示法包含两个部分：整数和小数。 整数首先是定义：$$[x]_原 =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\2^n-x &amp; 0 \geqslant x &gt; -2^n \\\end{cases}$$ 比如：$x = +1110$，$[x]_原 = 0,1110$；$x = -1110$，$[x]_原 = 2^4 + 1110 = 1,1110$。实际上，$2^4$其实就是$10000$，写成指数形式更贴近定义中的公式，可千万别以为是新东西。 注意：上述默认机器字长是 5 位（后面的内容也都默认机器字长在合理范围内），逗号用来隔开符号位和数值部分。 小数定义：$$[x]_原 =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\1-x &amp; 0 \geqslant x &gt; -1 \\\end{cases}$$ 比如：$x = +0.1101$，$[x]_原 = 0.1101$；$x = -0.1101$，$[x]_原 = 1 - (-0.1101) = 1.1101$。 与上述一样，机器字长默认为 5 位，小数点用来隔开符号位和数值部分。 最后，还要把特殊的 0 单独拿出来讨论下，按照原码小数的定义，有：+0：$x = +0.0000，[+0.0000]_原 = 0.0000$-0：$x = -0.0000，[-0.0000]_原 = 1.0000$同理，对于整数，就有：+0：$[+0]_原 = 0,0000$-0：$[-0]_原 = 1,0000$综上，+0和-0的原码不同。 补码表示法补码的概念有点类似于模运算中的补数，不复杂，但是日常生活中用的不多。 整数定义：$$[x]_补 =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\2^{n+1}+x &amp; 0 &gt; x \geqslant -2^n (mod\ 2^{n+1})\\\end{cases}$$ 比如：$x = +1010$，$[x]_补 = 0,1010$；$x = -1011000$，$[x]_补 = 2^{7+1} + (-1011000) = 1,0101000$。 小数定义：$$[x]_补 =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\2+x &amp; 0 &gt; x \geqslant -1 (mod\ 2)\\\end{cases}$$ 比如：$x = +0.1110$，$[x]_补 = 0.1110$；$x = -0.1100000$，$[x]_补 = 2 + (-0.1100000) = 1.0100000$。 实际上，关于补码有一些规律： 正数的补码就是其本身 负数的补码可用其原码除符号位，每位取反，末位加 1 求得 同样，补码也存在 0 这个特殊情况，按照补码小数的定义：+0：$x = +0.0000，[+0.0000]_补 = 0.0000$-0：$x = -0.0000，[-0.0000]_补 = 1.0000$同理，对于整数，就有：+0：$[+0]_补 = 0,0000$-0：$[-0]_补 = 1,0000$综上，+0和-0的补码相同。 反码表示法整数定义：$$[x]_反 =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\(2^{n+1}-1)+x &amp; 0 &gt; x \geqslant -2^n (mod\ 2^{n+1}-1)\\\end{cases}$$ 比如：$x = +1101$，$[x]_反 = 0,1101$；$x = -1101$，$[x]_反 = (2^{4+1}-1) - 1101 = 1,0010$。 小数定义：$$[x]_反 =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\(2-2^{-n})+x &amp; 0 \geqslant x &gt; -1 (mod\ 2-2^{-n})\\\end{cases}$$ 比如：$x = +0.1101$，$[x]_反 = 0.1101$；$x = -0.1010$，$[x]_反 = (2-2^{-4} - 0.1010) = 1.0101$。 同样，反码也存在 0 这个特殊情况，按照反码小数的定义：+0：$x = +0.0000，[+0.0000]_补 = 0.0000$-0：$x = -0.0000，[-0.0000]_补 = 1.1111$同理，对于整数，就有：+0：$[+0]_补 = 0,0000$-0：$[-0]_补 = 1,1111$综上，+0和-0的反码不同。 小结总结一下三种机器数的规律： 对于正数，原码 = 补码 = 反码 对于负数，符号位为 1，其原码除符号位外每位取反，末位加 1 可得补码；其原码除符号位每位取反，可得反码 移码表示法补码无法直接判断两个符号不同的整数的大小关系，由此产生的就是移码。移码定义：$$[x]_移 =\begin{cases}2^n+x &amp; 2^n &gt; x \geqslant -2^n \\\end{cases}$$ 比如：$x = 10100$，$[x]_移 = 2^5 + 10100 = 1,10100$；$x = -10100$，$[x]_移 = 2^5 - 10100 = 0,01100$。实际上，移码与补码只差了一个符号位：正数的移码的符号位为 1，负数的移码的符号位为 0。最小真值的移码为全 0，同时+0和-0的移码也是相等的（与补码一致）。移码的用途就是用来表示浮点数的阶码，这样可以很方便的判断浮点数阶码大小。 数的定点表示和浮点表示定点表示按照小数点的位置有两种表示方法，一种是小数点在数符之后（小数定点机），另一种是小数点在数值之后（整数定点机），具体如下图： 浮点表示引入浮点数的目的是为了方便科学计算，其一般形式为：$$N = S \times r^j$$ 其中，$S$ 为尾数，是数的小数部分，可正可负；$j$ 为阶码，是基值的指数部分，可正可负；$r$ 尾数的基值，也就是进制数。 具体来讲，在计算机存储的浮点数包含了五个部分，如下图： 最后需要指出的是浮点数的表示范围，如下图： 注意上图中的范围，发生下溢时，按照机器零处理；发生上溢时，按照计算出错处理。 总结总体来说，这章的内容不难，但是很繁琐，只是需要做好区分和总结。 然后是这一章的思维导图： PS：光看图的话，内容确实不多...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_6]]></title>
    <url>%2F2023%2F11%2F04%2FHIT-CO-Week-6%2F</url>
    <content type="text"><![CDATA[十月底在“打渔”😂，没怎么学习，要赶紧把上部分搞定，开始下部分。 这周的内容是输入输出系统，内部不算多，加把劲。 概述早期采用分散连接，CPU 和 I/O 设备串行工作，信息传送控制方式采用程序查询方式；然后是接口模块和 DMA 阶段，此时信息传送控制方式采用总线连接，CPU 和 I/O 设备并行工作，采用中断方式和 DMA 方式；往后依次是具有通道的阶段和具有 I/O 处理机的阶段。 I/O 系统由两部分组成：I/O 软件和 I/O 硬件，其中软件包括 I/O 指令（CPU 指令的一部分）和通道指令（通道自身的指令），硬件包括 I/O 接口和设备控制器。 I/O 设备与主机的联系方式主要考虑以下问题： I/O 设备的编址方式：分为统一编址（用取数、存数指令）和不统一编址（有专门的 I/O 指令） 设备选址：用设备选择电路识别是否被选中 传送方式：串行或并行 联络方式：立即响应、异步工作采用应答信号或同步工作采用同步时标 I/O 设备与主机的三种种连接方式：辐射式连接（不便于增删设备）和总线连接（便于增删设备）。 最后是 I/O 设备与主机信息传送的三种控制方式： 程序查询方式 程序中断方式 DMA 方式 下面再深入一下。 I/O 设备I/O 设备也叫外部设备，也就是输入输出设备，大致分为三类：人机交互设备（键盘、鼠标、显示器）、计算机信息存储设备（磁盘、光盘）和机-机通信设备（调制解调器，也就是原来说的光猫），剩下的具体设备就不说了，不是重点。 I/O 接口首先应该明确的是设置接口的目的（功能）： 实现设备的选择 实现数据缓冲达到速度匹配 实现数据串-并格式转换 实现电平转换 传送控制命令 反映设备的状态（“忙”、“就绪”、“中断请求”） 总线连接方式的 I/O 接口电路包括：设备选择线、数据线、命令线和状态线，各个组成部分也有相对应的功能： 功能 组成 选址功能 设备选择电路 传送命令 命令寄存器、命令译码器 传送数据 数据缓冲寄存器 反映设备状态的功能 设备状态标记（完成触发器 D、工作触发器 B、中断请求触发器 INTR、屏蔽触发器 MASK） I/O 接口大致的基本组成如下图： I/O 接口分类方式比较多，这里不赘述了，非重点。 程序查询方式程序查询方式的流程主要分两个部分：查询流程和程序流程，这里不详细描述了，总之记住这种方式最大的特点：串行工作。 程序中断方式中断的概念，可以参考百科——中断。实际上，简单理解起来就是打断 CPU 的工作，执行完成其他的指令后，继续执行原指令。从宏观上看，CPU 和其他设备是在并行工作。 程序中断方式的接口电路主要由中断请求触发器、中断屏蔽触发器、排队器、中断向量地址形成部件等组成，如下图所示： 上图中，完成触发器 D 受设备本身控制；中断屏蔽触发器 MASK 为 1 时，屏蔽中断信号；中断请求触发器 INTR 为 1 时，表示有中断请求。另外，排队器分为软件和硬件，其内部的中断请求优先级按降序排列。中断向量地址可由硬件产生，也可由软件产生，这个地址可以理解为要执行的程序的地址的地址？ I/O 中断处理过程，如下图： 中断服务程序的流程： 保护现场：包括程序断电的保护（中断隐指令完成）和寄存器内容的保护（进栈指令） 中断服务：对不同的 I/O 设备具有不同内容的设备服务 恢复现场：出栈指令 中断返回：中断返回指令 中断还分为单重中断（不允许中断现行的中断服务程序）和多重中断（允许级别更高的中断源中断现行的服务程序），二者的区别如下图： 最后，需要再次强调的是，在宏观上 CPU 和 I/O 并行工作，但在微观上，CPU 中断现行程序为 I/O 服务。 DMA 方式DMA 方式的特点程序中断方式的数据传送通路需要经过 CPU，但 DMA 方式的数据传送通路不需要经过 CPU，外部设备与主存直接通过 DMA 接口即可进行数据交换。 DMA 与主存交换数据的方式有三种： 停止 CPU 访问主存，这种方式控制简单，但在数据传送的过程中，CPU 处于不工作状态或保持状态，不能充分发挥 CPU 对主存的利用率。 周期挪用（也叫周期窃取），这里提到的周期就是指访存周期（存取周期）。所谓周期挪用，其实就是指在 DMA 接口开始进行数据传送时，CPU 放弃对主存的占用，待 DMA 接口完成数据传送后，CPU 再进行对主存访问。此时存在三种可能：CPU 此时不访存、CPU 正在访存、CPU 和 DMA 同时请求访存（此时 CPU 将总线控制权让给 DMA）。 DMA 与 CPU 交替访问，将 CPU 工作周期分为 $C_1$（专供 DMA 访存）和 $C_2$（专供 CPU 访存）。 DMA 接口的功能主要是以下五点： 向 CPU 申请 DMA 传送 处理总线控制权的转交 管理系统总线、控制数据传送 确定数据传送的首地址和长度，修正传送过程中的数据地址和长度 DMA 传送结束时，给出操作完成信号 DMA 接口组成参考下图： DMA 工作过程DMA 传送过程DMA 传送过程依次是预处理、数据传送和后处理。 预处理通过几条输入输出指令预置如下信息： 通知 DMA 控制逻辑传送方向（入/出） 设备地址 DMA 的 DAR 主存地址 DMA 的 AR 传送字数 DMA 的 WC 数据传送 后处理后处理主要完成以下三个任务： 校验送入主存的数是否正确 是否继续用 DMA 测试传送过程是否正确，错则转诊断程序 注意，后处理过程都是由中断服务程序完成。 DMA 接口与系统的连接方式主要是两种方式：具有公共请求线的 DMA 请求和独立的 DMA 请求，这有点像是并联和串联的差异？😦 DMA 方式与程序中断方式的比较 类别 中断方式 DMA方式、 数据传送 程序 硬件 响应时间 指令执行结束 存取周期结束 处理异常情况 能 不能 中断请求 传送数据 后处理 优先级 低 高 DMA 接口的类型也就是下面两种： 选择型： 在物理上连接多个设备，在逻辑上只允许连接一个设备。 多路型：在物理上连接多个设备，在逻辑上允许连接多个设备。 总结这章的内容听起来真的是枯燥无味啊...基本上 30s 过后，绝对会走神。哎，自己的注意力已经变得这么难以集中了么（手动狗头）... 回到正题，输入输出系统这一块的内容应该在信息传送的三种控制方式上，容易与其他章节的知识点结合起来出综合题。所以针对应试的话，需要找一找这方面的题目进行练习。另外，在学习这章的过程中，有一个很深刻的感受：如果学习这门课之前先学习了微机原理，那这门课学起来应该恒容易😂，原因是因为这门课介绍了很多与电路相关的东西。 PS：在 MOOC 上的课程中，这是两周的内容，这里只算一周的内容。 PPS：最后补上最后一章的思维导图...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_10_月总结]]></title>
    <url>%2F2023%2F10%2F29%2F2023-10-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知不觉，来上海一年了... 对很多事情又有了新的认识啊... Dust in the wind - KansasYour browser does not support the audio tag. 时间过得真快，又是一年过去了。在写这篇 blog 之前，我专门看了下去年这个月的 blog，看看自己在干嘛，看看自己在想啥。把原来的生活记录下来，现在回想一下当时自己的心境，再转头看看现在的自己，心中难免会升起一种异样的情绪。 实际上，在这篇 blog 里，我并不想写自己这一年来的感受，所以这部分就留到年末总结了。 好了，回到十月本身来。 十月份的工作不忙也不闲，也基本都是正常的工作节奏。但是这个月得到的消息是，这个项目快要下线了，当时心里只有一个想法：妈呀，这样我不就失业了吗？哈哈😂 显然，这个事情不是我能决定的，所以一分钟之后，就不去想了，先做好眼前的工作吧。不过，内心的危机感已经浮现了，消除这股感觉的最好方法就是忙起来，所以要加紧自己的学习计划啊。 学习方面的话，这个月懈怠了很多，不过还有时间可以补回来，可以预见接下来的日子会忙碌起来🥱。 生活方面的话，与往常一样，没有太大的变化，该吃吃，该喝喝，该睡睡，就是身体好像又有一点不舒服的感觉（哎，这也是导致自己学习计划会中断的原因）。锻炼计划还是正常的在进行中，目前体重大概在 64KG 左右，杜绝长胖😁。另外，马上双十一要到了，正琢磨着，要不要给自己买点东西，挺想买点衣服啥的，但是自己又嫌麻烦懒得去挑选，哈哈。上个月说的《Romance》已经是练完了，现在练习的是《她来听我的演唱会》，这首歌的伴奏还需要好好练习下。话说，新的琴弦又上锈了。 最后，想告诉自己的是：身体会慢慢恢复的，不要担心，加强锻炼，慢慢来，把注意力放在自己应该做且感兴趣的事情上，珍惜时间😌。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_5]]></title>
    <url>%2F2023%2F10%2F07%2FHIT-CO-Week-5%2F</url>
    <content type="text"><![CDATA[假期结束，学习继续🤓 这周是存储器的最后一部分了，余下的内容不算多，重点在高速缓冲存储器（Cache）这一部分。 Cache概述 首先回答第一个问题：为什么使用 Cache？ 答案很简单，目的是为了避免 CPU “空等”现象，弥补 CPU 和主存（DRAM）的速度差异，使计算机能以更高的效率进行工作。 另外，还得提一下程序的局部性原理，具体点击参考百度，这里不赘述了。 Cache 的工作原理主存和缓存的编址见下图： 主存和缓存的块内地址完全一样，假设缓存共分为 C 块，主存共分为 M 块，那么 M 是远大于 C 的。此时，主存块会调入缓存中（这样主存块就与缓存块建立了对应关系），同时利用标记记录与某缓存块建立对应关系的主存块号，这样就称缓存块命中了主存块。相反，如果主存块未调入缓存中，那么主存块与缓存块就不存在对应关系，也就是未命中了。 由此，Cache 会产生一个叫做命中率($h$)的参数，也即：$$h = \frac {N_c} {N_c + N_m}$$上述式子中，$N_c$ 表示 Cache 完成存取的总次数，$N_m$ 表示主存完成存取的总次数。 对应的，Cache-主存系统的效率见下图： 再看一下 Cache 的基本结构： Cache 的读操作只有一种： Cache 的写操作要复杂一些（因为需要考虑 Cache 和主存的一致性问题），有两种： 写直达法（Write-through）：写操作时数据既写入 Cache 又写入主存，这样能保证 Cache 和主存一致，但可能造成 CPU 对同一内存单元重复写的问题。写操作时间就是访问主存的时间，Cache 块退出时，不需要对主存执行写操作，更新策略比较容易实现。 写回法（Write-back）：写操作时只把数据写入 Cache 而不写入主存，当 Cache 数据被替换出去时才写回主存。此法不能保证 Cache 和主存实时一致，同时因为多核 CPU 的存在，不同核心对应的 Cache 可能不同，由此会导致不同 Cache 中同时存在主存的某一个副本，而且这些副本还不能确定是否一致。另外，写操作时间就是访问 Cache 的时间，Cache 块退出时，被替换的块需写回主存，增加了 Cache 的复杂性。 为了提高 Cache 的效率，针对 Cache 还有一些改进措施： 增加 Cache 的技术，如片载（片内）Cache，片外 Cache。 统一缓存和分立缓存，如指令 Cache 和数据 Cache，具体与指令执行的控制方式有关。 Cache-主存的地址映射三种映射方法： 直接映射：每个缓存块可以与若干个主存块对应；每个主存块只能与一个缓存块对应。 全相联映射：主存中的任一块可以映射到缓存中的任一块。 组相联映射：某一主存块按模 Q 映射到缓存中的第 i 组中的任一块，算是直接映射和全相联映射的结合版（也可以理解为将主存和缓存分组，组之间为直接映射，组内内全相联映射）。 替换算法替换算法介绍了两种： 先进先出（FIFO，类似队列）算法 近期最少使用（LRU）算法 辅助存储器辅助存储器最直接的特点就是不直接与 CPU 交换 信息，只是作为主存的“辅助”而存在，常见的辅助存储器又有磁表面存储器（又可分为硬磁和软磁）、光盘存储器。 磁表面存储器的技术指标： 记录密度 存储容量 平均寻址时间 数据传输率 误码率 磁记录原理就不深入探究了。 硬磁盘存储器的类型： 固定磁头和移动磁头 可换盘和固定盘 硬磁盘存储器由磁盘控制器、磁盘驱动器和盘片组成，软盘主要由聚酯薄膜制成。 光盘存储器采用光存储技术，利用激光写入和读出。第一代光存储技术采用非磁性介质，不可擦写；第二代光存储技术，采用磁性介质，可擦写。只读型和只写一次型光盘的存储原理为热作用（也即物理或化学变化），可擦写光盘的存储原理为热磁效应。 总结这一周课程的重难点部分在 Cache 这一块，从应试的角度来讲，这部分内容容易与其他章节内容结合，然后组合在一起作为一道大题出现，建议着重理解这块知识点。 补齐存储器整个章节的思维导图： PS：存储器算是完结了，这个思维导图好大啊~说明零零散散的知识点真的多...🥴]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_09_月总结]]></title>
    <url>%2F2023%2F10%2F04%2F2023-09-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[国庆假期只有 2 天了啊...😐 哈哈，放假前几天都在自己玩自己的，完全没把写 blog 的事情放在心上...😂 不要告别 - 高旗&amp;超载乐队Your browser does not support the audio tag. 最近在听这首歌，感慨良多...总是会让自己回忆到大学时代，后悔没有玩乐队啊，但仔细想想自己也没有条件玩，哈哈。好了，回到本文的主题。 九月总体不忙，相比之前的几个月，算是比较闲的了。导致这个结果的直接原因，就是之前延期的需求继续延期到十月底了。尽管不忙，但是月初的时候差点惹上大麻烦😑，原因就是因为这个需求延期太久了，老大要亲自抓一下。不过好在跟我关系不大，影响不到我这里。实际上，现在回想起这件事，心中不免会冒出一个想法：幸好当时听 Y 老师的话，严格按照需求文档上执行，需求有修改一定要及时同步更新到需求文档上。不过仔细想想，这本质上是一种严谨的工作态度，自己一开始是没有想到“口说无凭”这个问题的，还是自己处理事情不够成熟啊😤。总而言之，这个事情目前已经确定要在十月底结束掉了，按部就班完成就行了。 然后是学习方面，这个月主要从两个方面来开展： 因为工作不忙的缘故，仔细读了《The C Programming Language》这本书前七章（关于本书的评价，请移步右侧 Book List），有一定的收获，读起来也觉得很享受。 开始《组成原理》的学习，课程选择是 MOOC 上哈工大课程，相关 blog 也已经更新，话说目前还欠一篇呢，太懒了🤣 对应的，这个月 Linux 系统开发的视频看的就少了。不过回过头看，视频的内容其实就是《The C Programming Language》和《Unix 环境高级编程》这两本书的结合体，要下功夫理解知识，还是得仔细看看这两本书的部分内容。好了，趁着假期还有几天，最好把没有完成的学习任务完成了。 最后就是生活了，哈哈，每次把生活放在最后，生活都要有意见了（主要是自己一个人的生活其实也没什么好提的🤣）。生活还是按部就班的生活，不过自己开始接触桌球了，感觉还挺好玩的，就是觉得有点难，打球的时候经常会感慨怎么把一个球打进洞，那么难呀...锻炼方面依然在进行，不过坚果和鸡胸肉都要吃完了，得买一点了。秋天已经来了，翻翻自己的衣服，都是好几年之前的衣服了，得给自己买点新衣服和鞋子了，看来得多找找穿搭方面的攻略了，哈哈😄。老实讲，如果是以前的自己，会认为做这样的事情是很没意义的😂，不过现在的我认为，在个人形象上的投资也是合理的，任何事情最好都要认真对待，这才是知行合一。 对了，还要说的一件事是最近在练《Romance》这个古典吉他曲子，每次练都要感慨这曲子为甚么会这么好听，简直是好听的哭了😭。对对了，趁这次放假，换了新的琴弦，两个字，舒服。 以上，就这样，要去把自己的脏衣服处理一下了。😑]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_4]]></title>
    <url>%2F2023%2F09%2F23%2FHIT-CO-Week-4%2F</url>
    <content type="text"><![CDATA[这一周延续上周没讲完的主存储器的下半部分🤐... 接着上周的内容，首先介绍的只读存储器（ROM）。 ROM只读存储器（Read-Only Memory），顾名思义，就是只能读不能写的存储器，但现在的 ROM，基本都是可读可写的，只是速度比 RAM 慢而已。实际上，早期的 ROM 设备确实是只能读，后来随着市场需求的改变，才诞生了可读可写的 ROM，并且 ROM 也不是一下子就可以写了，而是慢慢发展成目前的样子的。 按照书上的介绍，ROM 具体分为以下几种： 掩膜 ROM（MROM）：行列选择线交叉处有 MOS 管为 1，无 MOS 管则为 0 PROM（一次性编程）：以行、列线间的熔丝是否熔断区分 1 和 0，熔断为 0，反之为 0 EPROM（多次性编程） EEPROM（也叫 $E^2PROM$，多次性编程）：电可擦写，支持局部擦写和全部擦写 Flash Memory（闪速型存储器，也叫闪存）：读写速度很快、功耗低，但价格较高 存储器与 CPU 的连接这一块内容算是重点与难点内容了🤐。 存储器容量的扩展首先是存储器容量的扩展，主要是三种方式：位扩展、字扩展和字位扩展。 位扩展位扩展其实就是增加存储字长，比如用 2 片 $1K \times 4$ 位存储芯片组成 $1K \times 8$ 位存储芯片，就只是把存储字长扩大了一倍。但不论是 2 片 $1K \times 4$ 位存储芯片还是 1 片 $1K \times 8$ 位存储芯片，总体的存储容量都是 $8K$ 位（这个说法可能不严谨，懂意思即可）。 字扩展字扩展就是增加存储字的数量，比如用 2 片 $1K \times 8$ 位存储芯片组成 $2K \times 8$ 位存储芯片，本质上相当于是把存储单元的数目扩大了一倍。但不论是 2 片 $1K \times 8$ 位存储芯片还是 1 片$2K \times 8$ 位存储芯片，总体的存储容量都是 $16K$ 位。 字、位扩展字、位扩展就是字扩展与位扩展结合使用的方式，比如用 8 片 $1K \times 4$ 位存储芯片组成 $4K \times 8$ 位存储芯片。 与 CPU 的连接存储器与 CPU 的连接主要包括六个部分： 地址线的连接 数据线的连接 读/写命令线的连接 片选线的连接 合理选择存储芯片 其他芯片或控制电路，如时序、负载 以书上的例题 4.1 和 4.2 作为例子，老师讲的很清楚，书上写的也很清楚，这里不再赘述了，只记录下主要的解题步骤是： 写出相应的二进制地址码 确定芯片的数量及类型 分配地址线 确定片选信号 存储器的校验存储器的校验是通过一系列的编码方法来完成的，这一章主要介绍汉明码。首先要明确汉明码中码距的概念，也即两个合法代码对应位上编码不同的位数称为码距。编码的纠错、检错能力与编码的最小距离有关，而汉明码是具有一位纠错能力的编码。 需要注意以下汉明码组成的三要素，如下图： 汉明码的配置、检错过程，这里就不再赘述了，老师讲解的很清晰，书上也解释很清楚。 提高访存速度的措施按照老师的讲解，提高访存速度的思路就是三个方面： 采用高速器件 采用层次结构，比如 Cache-主存 调整主存结构 前两点已经在前面提到过了，这里在提一下第三个思路，主要有两个方式： 单体多字系统，本质是增加存储器带宽 多体并行系统，分为两种方式：高位交叉、顺序编址（各个体并行工作）和低位交叉、各个体轮流编址（在不改变存取周期的前提下，增加存储器的带宽）。 最后的内容就是几种高性能存储芯片： SDRAM（同步 DRAM），在系统时钟的控制下进行读出和写入，CPU 无须等待，也就是现代计算机的内存条 RDRAM，由 Rambus 开发，主要解决存储器带宽问题 带 Cache 的 DRAM，在 DRAM 的芯片内集成了一个由 SRAM 组成的 Cache，有利于猝发式读取 总结在上周基础上添加本周内容后的思维导图： 本周的重点内容在存储器与 CPU 的连接部分，从应试的角度来讲，这块内容应该很容易出综合大题，因为这里可以把 CPU 和总线的内容结合起来，所以最好把书上的几个例题吃透。还有一个考点，应该是汉明码，这块知识点，要是不理解，做题估计还是错，建议找题目做做看。好消息是，我不用考试了，只要理解大部分知识点就可以了😂。]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_3]]></title>
    <url>%2F2023%2F09%2F15%2FHIT-CO-Week-3%2F</url>
    <content type="text"><![CDATA[这周存储器，不知道会不会有趣一点...😴听完了，才知道也不是很有趣...😂 有关存储器的内容一共分了三周的课程，这周的主要内容是有关主存储器的部分。 存储器首先要介绍的是存储器的分类和现代存储器的层次结构。 分类1. 按照存储介质分类 半导体存储器 磁表面存储器 磁芯存储器 光盘存储器 注意：半导体存储器存储的信息是易失的，而其他三种存储器是非易失的。 2. 按照存取方式分类 当存取时间与物理地址无关（随机访问），可分为随机存储器（在程序的执行过程可读可写）和只读存储器（在程序的执行过程中只读）。 当存取时间与物理地址有关（串行访问），可分为顺序存取存储器（如磁带）和直接存取存储器（磁盘） 3. 按在计算机中的作用分类 层次结构不多说了，主要看下面两张图： 上面这张图主要是在说明：越贴近 CPU 的存储介质的速度越快、容量越小、价格越贵，所以如何把计算机的结构设计的经济合理就是一个很重要的问题了。 这张图实际上就是上述问题的答案，对于用户体验而言，并不需要每一块存储芯片都有很快的读写速度（对用户而言，性价比才是王道，哈哈~），而且从功能上而言，速度依次递减也不会对整个计算机构成影响。 主存储器 第一张提到的有关存储器的知识这里依然用得到，之前是大概了解，现在是深入了解。 概述首先要了解的是主存储器的基本组成，见下图（还是电路之类的东西）： 对应的是，CPU 和主存的联系，见下图： 这里又提到了大端存储和小端存储的概念： 大端存储：数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。小段模式：数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中。 举个简单的例子，0x12345678，如果是大端模式，对应内存中保存的值就是12 34 56 78；如果是小端模式，对应内存中保存的值就是78 56 34 12。 最后是主存的技术指标，主要是是存储容量、存取速度、存储带宽（位/秒）这些概念。 存取速度相关的概念有两个：存取时间：存储器的访问时间，可分为读出时间和写入时间。存取周期：连续两次独立的存储器操作（读或写）所需的最小间隔时间，可分为读周期和写周期。 半导体存储芯片首先要学习的是半导体存储芯片的相关知识，主要分两块：基本结构和译码驱动方式。 基本结构半导体存储芯片的基本结构见下图： 相比前面介绍的主存的基本组成，多了片选线（确定那块存储芯片被选中）和读写控制线（确定芯片进行读/写操作）。实际上，个人认为这两部分组合在一起就是存储器的“控制器”，由它来决定存储器的一些行为。另外，片选线中存在两个信号：$\overline {CE}$ 和 $\overline {CS}$；读/写控制线中存在三个信号：$\overline {WE}$（低电平写，高电平读）、$\overline {OE}$（允许读）和 $\overline {OE}$（允许写）。 关于片选信号的作用，老师举了一个例子：组成一个$64K \times 8$位的存储芯片需要使用 4 组$16K \times 1$位的存储芯片，且每组 8 个，一共 64 个，此时由两个片选信号就可以唯一确定是对那一块$16K \times 1$的芯片进行操作，实际上这个过程类似于通过矩阵的行列坐标来确定其中的特定元素。 译码驱动半导体芯片的译码驱动方式这里介绍了两种：线选法和重合法。 线选法如下图所示： $A_0 - A_3$作为地址码会被地址译码器解析为对应的字线，4 个 bit 正好对应 16 根线，还有 8 根位线连接在读/写控制电路上。 重合法如下图所示： 重合法感觉要简单一点，$A_0 - A_4$作为 X 地址码，5 个 bit 位对应 32 根线，$A_5 - A_9$作为 Y 地址码，也是 5 个 bit 位，对应 32 根线，X、Y 实际上就可以当作是横纵坐标了。 RAM随机存取存储器（RAM）分为两种：静态随机存取存储器（SRAM）和动态随机存取存储器（DRAM）。 SRAM静态随机存取存储器是由双稳态触发器组成，断电后会丢失信息，存取速度快，基本电路如下： 这里不深究电路的设计思路和原理了...🤐 读操作： 写操作： 最后提到了一个实际用重合法组成的芯片——Intel 2114，本质上是一个$64 \times 64$的矩阵，这里不做深究了。 DRAM动态随机存取存储器是由电容组成，同样断电后会丢失信息，速度比 SRAM 慢，基本电路如下： 在上图中，左边是三管式存储电路，右边是单管式存储电路。 三管动态 RAM 芯片的读写操作过程是类似的，这里简单分析一下 Intel 1103 芯片的写操作，如下图： 实际上就是下面两个要点： 与重合法类似，三管动态 RAM 芯片的译码过程也是需要分别使用行列地址译码器来完成，不同的地方在于三管式区分开了读/写选择线，所以行地址译码的过程实际上有读写控制电路的参与。 每一列都需要有一个刷新放大器来形成再生信息，原因是电容会漏电（老师的原话😐）。 然后是单管动态 RAM 芯片，这里以 Intel 4116 芯片为例，首先是 Intel 4116 的外特性，如下图： 这个结构有两个要点： 整个芯片只有 7 位地址线，输入的行列地址会先存放在行列地址缓存器中，然后在进行后续的译码过程。 这个芯片内部还有一个小控制器：时序与控制控制器，这个控制器利用行选中信号（$\overline {RAS}$）、列选中信号（$\overline {CAS}$）和读写控制信号（$\overline {WE}$）作为输入，产生行时钟、列时钟和写时钟，来控制芯片内部的读写操作。 Intel 4116 的读/写操作也是类似的，这里以读操作为例，如下图： 同样，Intel 4116 也需要放大器来形成再生信息，同时这个放大器两端产生的信号是相反的。而寻找存储单元的思路依然是重合法那一套，行列信号当作坐标即可。 DRAM 最后一个问题是关于刷新的问题，也就是上面提到的因电容漏电而需要放大器形成再生信息。刷新的整个过程是针对一行而言，对应的刷新方法有三种：集中刷新、分散刷新和异步刷新（二者结合）。 集中刷新集中刷新其实就是集中一个时间段进行刷新，以 $128 \times 128$ 矩阵为例，需要 128 个周期进行刷新，假设芯片的存取周期是 $0.5\mu s$，刷新时间间隔是 $2 ms$，所以刷新时间就是 $0.5 \mu s \times 128 = 64 \mu s$，在这个时间段中，CPU 与 I/O 都无法与 DRAM 交互，故这个时间段也叫“死区”，对应的“死时间率”为 $128 / 4000 \times 100\% = 3.2\%$ 。 分散刷新分散刷新是在每一个存取周期进行刷新，也就是读写操作完成后直接进行刷新。以上面提到的例子为例，在分散刷新的条件下，整个存取周期就从 $0.5 \mu s$ 变成了 $1 \mu s$，这种方法虽然消除了“死区”，但 DRAM 根本不需要这么频繁的刷新。 异步刷新所谓异步刷新，其实就是集中刷新和分散刷新结合。还是上面的例子，若每 $15.6 \mu s$ 刷新一行，只需要把这一次刷新操作安排在最后集中刷新即可，这样对整个刷新时间间隔就是分散刷新了。同样，由集中刷新带来的“死区”是 $0.5 \mu s$，但如果将刷新安排在指令译码阶段，就不会产生“死区”了。 SRAM 和 DRAM 的比较SRAM 一般用来做 CPU 的缓存（Cache），DRAM 一般用来做主存（RAM），二者差别见下表： 类别 DRAM SRAM 存储原理 电容 触发器 集成度 高 低 芯片引脚 少 多 功耗 小 大 价格 低 高 速度 慢 快 刷新 有 无 总结这周的内容依然是偏理论性质的，实在是谈不上有趣，只能耐着性子听下去😂。总体听下来，出现了很多和电路相关的术语，不得不说，与《组成原理》结合紧密的课程还得是《数字电路》。不过，单从原理的角度来讲，倒也可以用死记硬背来解决。好了，这周的内容的思维导图如下： 剩下的事情就是把题目解决了...😴]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_2]]></title>
    <url>%2F2023%2F09%2F08%2FHIT-CO-Week-2%2F</url>
    <content type="text"><![CDATA[看了眼第二周的标题，好像还是概念性的内容啊...😐 计算机的发展及应用老师的第一句话：这部分内容不是主要学习内容，只进行简单讲述🤣。懂了，就是不重要的内容，直接二倍速了。 听的人打瞌睡，略无聊...快速过了。 系统总线总线（Bus）这个概念算是组成原理中比较重要的基础概念了吧？🤔 基本概念 为什么要用总线？其实就是为了减少硬件设备与 CPU 之间的物理连接数。 总线（Bus）是连接各个部件的信息传输线，是各个部件共享的传输介质。按照数据传送方式的不同，总线可分为串行传输总线和并行传输总线。 总线分类按照总线的功能划分，总线可以划分为以下三类：片内总线系统总线通信总线片内总线是芯片内部的总线，它是 CPU 芯片内部寄存器与寄存器之间、寄存器和 ALU 之间的公共连接线。系统总线是计算机系统内各功能部件（CPU、主存、I/O 接口）之间相互连接的总线。按照传输信息内容的不同，系统总线又可以分为： 数据总线，与机器字长、存储字长有关，是双向传输总线 地址总线，与存储地址、I/O 地址有关，是单向传输总线 控制总线，传输的是控制信息，传输方向有出有入 通信总线用于计算机系统之间或计算机系统与其它系统（如控制仪表、移动通信等）之间的通信，按照传输方式可分为：串行通信总线和并行通信总线。 总线特性及性能指标特性性能指标 机械特性：尺寸、形状、管脚数及排列顺序 电气特性：传输方向和有效的电平范围 功能特性：每根传输线的功能（地址、数据、控制） 时间特性：信号的时序关系 总线宽度：数据线的根数 标准传输率：每秒传输的最大字节数（MBps） 时钟同步/异步 总线复用（地址线与数据线复用） 信号线数：地址线、数据线和控制线的总和 总线控制方式：突发、自动、仲裁、逻辑、计数 其他指标：负载能力等 总线结构单总线结构双总线结构三总线结构四总线结构只有一条系统总线，可细分为数据总线、地址总线和控制总线。包括主存总线、I/O 总线，由通道（具有特殊功能的处理器）对 I/O 统一管理。两种不同的三总线结构： 主存总线、I/O 总线、DMA 总线 局部总线、系统总线、扩展总线 包括局部总线、系统总线、高速总线、扩展总线。 总线控制两个基本概念：主设备（模块）：获得总线控制权的设备从设备（模块）：被主设备访问的设备，只能响应从主设备发来的各种总线命令。 总线判优总线判优控制的方式分为：集中式分布式可细分为三种：链式查询、计数器定时查询和独立请求方式分布式仲裁不需要中央仲裁器，每个潜在的主模块都有自己的仲裁号和仲裁器。 总线通信控制目的：解决通信双方协调配合问题。总线传输周期分为四个过程： 申请分配阶段：主模块申请，总线仲裁决定 寻址阶段：主模块向从模块给出地址和命令 传数阶段：主模块和从模块交换数据 结束阶段：主模块撤销有关信息 通信方式可分为四种： 同步通信：由统一时标控制数据传送 异步通信：采用应答方式，没有公共时钟标准 半同步通信：同步、异步结合 分离式通信：充分挖掘系统总线每个瞬间的潜力 前三种通信方式的共同点：（在一个总线传输周期内，以输入数据为例） 主模块发地址、命令（占用总线） 从模块准备数据（不占用总线，总线空闲） 从模块向主模块发数据（占用总线） 相比之下，分离式通信的过程是： 子周期 1，主模块申请占用总线，使用完后，即放弃总线的使用权 子周期 2，从模块申请占用总线，将各种信息送至总线上 其对应的特点（充分提高了总线的有效占用）： 各模块有权申请占用总线 采用同步方式通信，不等对方回答 各模块准备数据时，不占用总线 总线被占用时，无空闲 总结这是这周的思维导图： 这周是先做的思维导图，后写的 blog，导致写 blog 的时候直接抄的思维导图的内容，写完之后，自己都觉得很水😂，但又不想再重新写了，哎，还是懒啊。 不过话说回来，这周的内容依然是概念性的知识，略无聊。单凭老师视频将的内容，作业题大概率不能拿满分，一是有些概念题老师根本没提过，二是还出现了一些计算题，所以还是需要找点练习题做做，也许看看唐老师编的那本教材的课后题可以解决？🤔但我手边上没有，只能找找资源了。 好了，接下来三周都是与存储器打交道了，希望会有趣一点。😶]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_1]]></title>
    <url>%2F2023%2F09%2F05%2FHIT-CO-Week-1%2F</url>
    <content type="text"><![CDATA[从今天开始更新笔者在 MOOC 上自学哈工大计算机组成原理时的笔记，按照每一周的课程进行记录，每周对应一篇 Blog，算上上下两门课程，这个系列大概有个十来篇吧。🧐 课程概貌这门课主要讲解三个方面的内容：计算机、组成和原理，主要从三个角度入手： 基本部件的结构和组织方法 基本运算的操作原理 基本部件和单元的设计思想 这门课程对应的交材是唐朔飞老师编的那本《计算机组成原理》（第二版），由高等教育出版社出版。另外，老师推荐了两本参考教材： Computer Organization & Design: A Hardware/Software Interface, David A.Patterson. John L.Hennessy Digital Design and Computer Architecture. Morgan Kaufmann, 2007, David Harris, Sarah Harris 这门课总共有十章内容，上半部分课程会讲解前五章，主要内容为计算机组成原理中与机器相关的部分；下半部分课程会讲解后五章，主要内容为计算机组成原理中数据的存储、表示和运算以及 CPU 的设计思想。 第一周的课程有点 boring🥱，主要讲解计算机系统概论，算是基本概念知识。 计算机系统概论计算机的软硬件概念这个地方其实没什么好说的，算是常识性的内容。 计算机系统的层次结构这里要提到了两个系统复杂性管理方法：抽象和3Y（Hierachy、Modularity 和 Regularity）。如果熟悉一门 OOP 语言的话，这些概念也都是基本常识了。 另外，下面这张图可以注意一下： 计算机体系结构和计算机组成注意区分这两个概念： 计算机体系结构：程序员所见到的计算机系统的属性，概念性的结构和功能特性（指令系统、数据类型、寻址技术、I/O 原理等） 计算机组成：实现计算机体系结构所体现的属性（具体指令的实现） 计算机的基本组成冯·诺依曼计算机的特点 计算机由五大部件组成 指令和数据以同等地位存于存储器，可按地址寻访 指令和数据用二进制表示 指令由操作码和地址码组成 存储程序 以运算器为中心 冯·诺依曼计算机存在一个缺陷，那就是运算器承担了很多工作，大部分事情都是亲力亲为，这就导致了运算器的速度直接成了整台电脑的速度（实际上就是木桶效应）。 计算机硬件框图针对冯·诺依曼计算机的改良措施就是将整个体系的中心从运算器换成了存储器。 现代计算机也是按照上图中的结构搭建起来的，此时各部分硬件设备都有了自己的名字，从这里体现的设计思想就是前面提到的 3Y——层次化（Hierachy）、模块化（Modularity）和规则性（Regularity）。 存储器的基本组成存储器由主存储器（主存，内存条）和辅存储器（辅存，硬盘）。主存储器由许多存储单元组成，每个存储单元包含若干个存储元件（也就是在 Nand2tetris 这门课中接触到的 Bit 芯片，可以用来存储一位二进制信息）。这里还有一个存储字长的概念，也就是指存储单元中二进制代码的位数。 除了存储单元外，主存储器还包括了地址寄存器（MAR）、数据寄存器（MDR）和一些逻辑电路。地址寄存器（MAR）存放访存地址，经过地址译码后找到所选的存储单元，从而拿到数据（类比一下指针的概念）。MAR 用于寻址，故其位数对应着存储单元的个数数据寄存器（MDR）是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息（类比临时变量）。MDR 的位数和存储字长相等。 现代 CPU 中的缓存（Cache）在概念上也是主存。 运算器的基本组成运算器的基本组成包括：算术逻辑单元（ALU）、累加器（ACC）、乘商寄存器（MQ）和操作数寄存器（X），各寄存器运算后存储的内容见下图： 控制器的基本组成控制器的基本组成包括：控制单元（CU）、程序计数器（IR）和指令寄存器（PC），各部分功能见下图： 计算机的性能指标这一部分又是一堆概念性的内容🤐： 机器字长：CPU 一次能处理数据的位数与 CPU 中的寄存器位数有关 CPU 主频、核心数、CPI（执行一条指令所需时钟周期数）、MIPS（每秒执行百万条指令）、FLOPS（每秒浮点运算次数） 存储容量，包括主存容量和辅存容量 总结做了张思维导图： 之前一直在听 Nand2tetris 的课，现在一时换回国内老师的课，听的还有点不习惯。哎，听完一周，这种为了应试而听课、学习的感觉又回来了。相比之下，感觉国外课程往往把复杂的理论讲的很简单，在你理解的差不多了之后，会给你一个任务，让你通过实践来继续加深理解。但国内课程为了应试，在理论上的讲解往往就比较复杂...😓仔细想了一下，国内的课程真的很容易打消学生的兴趣，当然如果能坚持下来，确实能获得不错的理论能力，但是没有实践还是不行啊，哎，原本之前在自学 Nand2tetris 时，就已经感慨过国外学生的实践能力很强，现在这种体会又加深了。 不扯这些闲篇了...回过头来谈一谈这门课的感受，在学习《组成原理》之前一定要把 C 语言的指针、地址这两个概念玩明白个大概，不然，这些硬件的设计思想会非常难以理解。只要能理解硬件中地址的设计思想理解透彻，应该就不会有太大的问题了。 另外，从国内应试（期末考、408 之类）的角度来讲，哈工大开的这门课讲的还是很清晰的，推荐学习，如果你听的过程中感觉很吃力，那说明可能对一些基础概念还不熟悉，还是先把基础打扎实。 好了，这周还有一件事情，那就是把书上的题做完😑，卧槽，突然想起来，好久没写过作业了...🤣]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_08_月总结]]></title>
    <url>%2F2023%2F08%2F27%2F2023-08-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[周末正好是八月底呀~😎 Kiss Goodbye - 王力宏Your browser does not support the audio tag. 这几天一直在听这首歌...感觉不是那种很难唱的歌，但也不是那么容易就可以唱好。另外，这首歌的钢琴间奏真的很好听，好像把分开后一个人形单影只又渴望再见的感情全表达出来:-( 好啦，进入正题... 本来以为这个月新版本会上线的，结果又延期了，导致月初很忙，月末又不是很忙了。而所忙的事情呢，还是跟上个月一样😂，还是测试新版本，找找有没有隐藏的 Bug🐞。结果还真的就找出来一个，不过好在不是重大的 Bug，修复好就行了。除了这个主要的事情外，就没有其他紧急的事情了。另外，自己通过 Java 写的报文解析工具也算是基本开发好了。其实也不用在修修改改了，因为也只有自己一个人用，不过本着把代码写精炼、简洁的原则，还是看看能不能在改改。实际上，通过这个小项目，自己对前端给后端的数据有了一个更深入的理解。同时，对 Java 的了解也更深入了一点，看看还有没有能让自己学习的地方。 回到学习上，这个月看了大概 30 - 40 个视频，所学习的内容更多的是 Linux 的系统 I/O 函数。老实讲，自己对这部分的函数不太熟悉。尽管已经听老师讲过一遍了，但也只是讲的时候听的很清楚，课后就忘了，或者说不会用，所以个人的看法还是要从实际项目中出发。等到学的差不多了，就重新看看 tinyhttpd 这个小项目，重点是搞清楚里面一些函数的使用。 这个月写了三篇 Blog，一是总结了一下课程的学习内容，二是搞清楚了一些细节性的问题。但不管怎么说，还是需要再接再厉呀😏！不过不要有太大的压力，一步一个脚印做下去就好。算下来，七月份的小目标算是完成了。 生活上就是按部就班了，花在吃喝玩乐上的花销与上个月差不多。不过，上周自己开始尝试买鸡胸肉和坚果来改善自己的营养摄入，不知道能不能多长点肌肉啊，可千万不要长肥肉🤣，哈哈，先吃一段时间再说吧，明天去称一称看看自己现在体重多少，上次是 62.8 公斤来着，加油锻炼，加油吃，哈哈💪。另外，与上个月的问题一样，自己的睡眠质量真的不高，总之就是一句话，戒掉手机吧，骚年。上个月说自己是在说屁话，结果还谁对乐😅...还是要认真的对待生活呀，突然又想到了《士兵突击》里面老马的台词：你们天天混日子，小心将来让日子混了。对，没错，下个月最主要的任务是多睡觉，多休息！！！😠 对了，前几天拿到了文心一言的内测资格，让别人申请了一下，也申请到了，是不是现在很容易申请了呢？不管了，反正能对自己提供一定量的帮助就行了。 还有一件事，这个月开始读史铁生的《我与地坛》了，是一本散文集，从目前读过的内容来看，写的很真诚，有些地方的描写也很有诗意，但目前觉得最闪光的地方是对平淡而又真挚的感情的描写，特别是母爱，写的真的很感人，读着读着，有时候都会想到两年前自己的样子。回到过去不现实，好好把握现在才是正途，不需要带着昨日的包袱，也不需要带着未来的压力，认真做好眼前的事情就好😌。 BTW，这个月其实没怎么好好练琴，好像一时间找不到方向了一样。从上次自己录音，到现在已经快一年的时间了，虽然自己今年也练习了一些歌和曲子，但也要自己录一下，记录下来啊，下个月得谋划一下这个事情。 好了，就这样，祝自己天天开心~PS：你好土啊😆]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言与缓冲区]]></title>
    <url>%2F2023%2F08%2F24%2FC-%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[有关缓冲区的概念和 C 语言中相关的内容...在了解二者联系之前，先要明白缓冲区的概念。 缓冲区所谓缓冲区（Buffer），就是指暂时存放输入或输出内容的一个内存空间，并且这个空间的大小是一定的。那为什么要设置缓冲区呢？目的是为了将高速读写设备与低速读写设备同步起来。举个简单的例子，打印机的打印速度比较慢，而电脑操作指令的响应速度比较块，但在打印机打印的同时，可以操作电脑不断把要打印的内容发送到打印机（电脑操作不用等待），对应打印机就会依次执行打印任务。 另外，需要注意区分缓冲区（Buffer）和缓存（Cache）的概念，这里不做深究。 C在 C 语言中也有用到缓冲区这个“设计模式”，之所以称之为设计模式，一是笔者不确定其他语言是否也是如此（只能确定大部分语言是如此）；二是就笔者的个人理解，将缓冲区称呼为一种（计算机领域的）设计模式更恰当，因为不止程序语言的设计如此，部分硬件的设计也是有这个模式的存在。不过，这里不深究其他的内容，只专注 C 语言中与缓冲区相关的内容。 C 语言中存在三种缓冲模式：全缓冲（fully buffered）、行缓冲（line buffered）和无缓冲（unbuffered）。在探讨各种缓冲模式之前，先得明确一下 C 语言中流的概念，可以参考一下百度百科——流。实际上，可以把 C 语言中通过fopen函数打开文件得到的文件指针看作流的入口，当通过这个文件指针向文件读写数据时，这些数据就是流，这个过程就是“流动”。对应的，C 语言中提供了三个标准流：标准输入流（stdin）、标准输出流（stdout）和标准错误流（stderr），其中stdin和stdout一般是行缓冲，stderr一般是无缓冲的（为的是能第一时间输出错误信息）。写到这里，会有一个疑问，使用fopen函数打开的文件流，默认的缓冲模式是什么呢？一般是行缓冲，可能是全缓冲，这取决于编译器具体的实现，但可以通过setvbuf函数来修改流的缓冲模式。 好了，其他的问题暂时不谈了，下面来探究一下各种缓冲模式。PS：以下测试均在 Ubuntu 16.04 环境下进行。 全缓冲全缓冲就是在缓冲区填满了之后，才执行 I/O 操作。测试代码：test112345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOFBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; 在上面的代码中，首先使用fopen函数在w+（读，若文件不存在则创建）的模式下打开文件，接着使用setvbuf函数设置缓冲模式为_IOFBF（全缓冲）。运行程序，在另一个终端中可以确认tmp文件已创建，然后键入1$ cat tmp 显示文件无内容。 行缓冲行缓冲就是在遇到换行符（\n）时，执行 I/O 操作，典型代表就是标准输入的scanf函数，每次输入完数据和回车后，才能看到效果。测试代码：test2123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG\n";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOLBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; 相比 test1，上面的代码有两个改动： const char *string = &quot;ABCDEFG\n&quot;;，加入\n后，程序才会进行 I/O 操作 ret = setvbuf(fp, buff, _IOLBF, 1024);，修改为行缓冲模式 同样的思路，运行程序，在另一个终端中可以确认tmp文件已创建，然后键入1$ cat tmp 显示：1ABCDEFG 无缓冲无缓冲就是不进行缓冲，直接执行 I/O 操作。测试代码：test3123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IONBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; 相比 test2，上面的代码有两个改动： const char *string = &quot;ABCDEFG;，与 test1 保持一致 ret = setvbuf(fp, buff, _IONBF, 1024);，修改为无缓冲模式 同样的思路，运行程序，在另一个终端中可以确认tmp文件已创建，然后键入1$ cat tmp 显示：1ABCDEFG(account)$xxx 上面的(account)$xxx是终端显示的用户名，因为没有\n，所以会与终端的用户名显示在一行。 如何刷新缓冲区明确各种缓冲模式的特点后，也要明白如何刷新缓冲区。其实上面已经提到一种刷新缓冲区的方法了，在行缓冲模式下，只需要在向流输入一个\n，就会刷新缓冲区。而 C 标准库也提供了fflush函数用来刷新缓冲区。使用 test1 中的代码：test41234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOFBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); fflush(fp); while(1)&#123; &#125; return 0;&#125; 相比 test1，上面的代码有个改动： fflush(fp);，手动刷新缓冲区 同样的思路，运行程序，在另一个终端中可以确认tmp文件已创建，然后键入1$ cat tmp 显示：1ABCDEFG(account)$xxx 显示结果与 test3 一致。 调用fflush函数后就会刷新缓冲区，任何一种缓冲模式下，都可以使用该函数来刷新缓冲区。 结语C 语言中有关缓冲区的知识暂时就记录到这里了，如前所说，“缓冲”更多是一种思想，从这个角度去理解，应该能收获更多东西。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typedef 关键字一些理解]]></title>
    <url>%2F2023%2F08%2F22%2Ftypedef-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[巩固一下typedef关键字的用法... 用法typedef是 C 语言的关键字之一，人尽皆知的用法就是“为一个类型取别名”，比如：test112typedef unsigned int size_t;typedef char bool; 或者：test212345typedef struct Student student;typedef struct Teacher &#123; char name[NAMESIZE]; int age;&#125; teacher; 还有：test312345typedef struct Node* PtrtoNode;typedef struct Node &#123; PtrtoNode next; int data;&#125; node; 类似的例子有很多，但实际上“为一个类型取别名”这种说法是不严谨的。私认为typedef关键字不仅仅是“取别名”，还要从语义的角度上去理解typedef的行为。比如：test4123typedef int Arr[5];Arr *a;int (*parr)[5]; 从语义的角度而言，在上述代码中，Arr是一种“新类型”（这里的新类型其实并不是真正意义上新类型），表示元素个数为 5 的int数组，对应的a是一个指向元素个数为 5 的int数组的数组指针。对比类型一样、用基本类型声明的数组指针parr，也可以看出使用typedef带来的便利性。实际上，熟悉 C++ 的同学，可能会发现typedef和using的功能有点类似。 类似的用法，还有定义函数指针的用法，如下：test51typedef void (*pfun)(int); 上述代码中，定义了一个返回值为void，参数为一个int的函数指针类型pfun。 陷阱这里，还需要提一下typedef和const关键字一起使用时的陷阱——千万不要把typedef和#define的文本替换混为一谈。比如：test51234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;typedef char *pchar;int main() &#123; char s1[10] = "hello"; char s2[10] = "world"; const pchar str = s1;// str = s2; // error *str = 'g'; puts(s1); const char *pc = s1; pc = s2;// *pc = 'g'; // error puts(pc); int i = 0, j = 2; const int *pi = &amp;j; pi = &amp;i;// *pi = 2; // error int * const ppi = &amp;i; *ppi = 3; // correct printf("%d\n", *pi); return 0;&#125;/*out:gelloworld3*/ 在阅读下面的讨论之前，需要理解const typename *和typename * const的区别。 如果认为typedef是文本替换，那么const pchar str与const char *str一致，对应语句*str = &#39;g&#39;;就会出错，而str = s2;就会正常执行（可以对比下面const char *和const int相关的代码）。但事实上，结果正好相反，编译器认为*str = &#39;g&#39;;正确、str = s2;错误，这说明，编译器并不认为str是一个const char *。 从语义的角度来理解，pchar的类型是char型的指针，在其前面加上一个const，表示这个指针是一个常量，所以const pchar的实际类型是char * const，而不是const char *，这点从后面的代码也可以对比出来。 最后需要说明的是，typedef的用法是 C 的标准规定的，本文只是验证如何使用，而不是证明这是编译器的黑魔法😂。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言中的回调函数]]></title>
    <url>%2F2023%2F08%2F12%2FC-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[很久没有写 blog 了，这次写一点与回调函数相关的内容...🧐 此文算是之前学习过程中，记录的笔记吧。 概念首先了解一下回调的概念： 回调函数就是一个被作为参数传递的函数。在C语言中，回调函数只能使用函数指针实现，在C++、Python、ECMAScript等更现代的编程语言中还可以使用仿函数或匿名函数。 以上解释来自百度百科 - 回调函数。仅从简单理解的角度来讲，个人认为以这样的方式说明回调函数是什么，很直观明了。所以，这篇文章中所提到的回调函数就是指被作为参数传递的函数。下面，再研究一下 C 中回调函数的使用。 应用如上所述，C 中的回调函数只能用函数指针实现，具体如何，直接看下面的示例：test11234567891011121314151617#include &lt;stdio.h&gt;typedef void (*pfunc)();void ppfunc() &#123; printf("Here is ppfunc!\n");&#125;void func(pfunc p) &#123; p(); printf("Here is func!\n");&#125;int main() &#123; func(&amp;ppfunc); return 0;&#125; 在上面的代码中，利用typedef关键字定义了一个叫做pfunc的函数指针，这个函数指针指向的函数有两个“特点”： 没有参数 返回值为void 另外，上述代码还定义了一个叫做func的函数，这个函数以pfunc类型的函数指针p作为参数，返回值为void，且在其函数体内还调用了p指向的函数，并打印输出了Here is func!。最终，这个程序的输出结果是：12Here is ppfunc!Here is func! 可以发现，在main函数中通过传递函数指针ppfunc（实际上，这里把函数的入口地址叫做函数指针不是很严谨的说法，仅仅是为了方便说明&gt;），在func函数中成功调用了ppfunc函数。此时，ppfunc就叫做回调函数，func就叫做主调函数。整个执行过程，也可以简单的概括为：在调用func函数的过程中，通过传递过来的函数指针p来调用ppfunc函数。 现在可以发现，要想掌握 C 中回调函数的用法，必须要具备： 理解函数指针概念 理解typedef关键字定义函数指针用法 理解函数的本质：内存中的代码段 同时，也会产生这样的疑问：如果只是为了调用ppfunc函数，为什么不直接在func函数里调用ppfunc函数呢？用回调函数的方式来调用，不是多此一举吗？ 其实上面的代码仅仅是为了用作说明而写出来的，实际情况当然不会这么多此一举。在 C 语言中比较常见使用回调函数的例子，就是标准库的qsort函数，比如下面的示例代码：test212345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp_int(const void *p, const void *q) &#123; return *(int *)p &gt; *(int *)q;&#125;int cmp_double(const void *p, const void *q) &#123; return *(double *)p &lt; *(double *)q;&#125;int main() &#123; int arr1[5] = &#123;3, 2, 5, 1, 4&#125;; qsort(arr1, 5, sizeof(*arr1), cmp_int); puts("arr1:"); for(int i = 0; i &lt; sizeof(arr1) / sizeof(*arr1); i++) printf("%d ", arr1[i]); putchar('\n'); double arr2[5] = &#123;1.2, 2.3, 3.4, 4.5, 5.6&#125;; qsort(arr2, 5, sizeof(*arr2), cmp_double); puts("arr2:"); for(int i = 0; i &lt; sizeof(arr2) / sizeof(*arr2); i++) printf("%.1lf ", arr2[i]); putchar('\n'); return 0;&#125;/*out:arr1:1 2 3 4 5arr2:5.6 4.5 3.4 2.3 1.2*/ 在上面的代码中，使用qsort函数对arr1和arr2分别进行升序排序和降序排序，而arr1和arr2分别是两个不同类型的数组。此时，可以发现，如果不使用回调函数，就需要写出两个参数类型和排序方式都不同的排序函数，尽管这两个排序函数的算法是一样。所以，为了避免写重复的代码（如果从工程的角度来讲，原因更多），就可以借助回调函数的方式。 结语在 C 语言中，回调函数的应用场景还是比较多的，但想要用好这个工具，必须要明白指针的概念。归根结底，回调函数还是在指针上玩花样。另外，C++ 中的回调函数也很常见，比如 C++11 的 lambda 提供的匿名函数或者仿函数。总而言之，回调函数是一种编程思想，是工程中的一种实践方法。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>callback_function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_07_月总结]]></title>
    <url>%2F2023%2F07%2F30%2F2023-07-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[暑假已经过去一半，然而我已经没有了暑假... ティコ - 押尾コータローYour browser does not support the audio tag. 这几天在练习这首曲子，不是很难，但有些地方有点麻烦，还得强化训练一下左手的能力...另外，虽然这是首悲伤、孤独的曲子，但我现在的心情并不悲伤、孤独，倒是有些许 sabishiyi，哈哈😁~ 这个月的月初比较忙，原因是单子要投产了，忙于测试代码，而且下个版本又改了好多次😂。结果，后面单子延期了，瞬间就不忙了，但是又有其他的测试任务来了。而这个测试任务很恶心，明确要完成的目标，不是我一个人能解决的，需要多个系统来配合完成，但是就是让我测试...有时候，我真的在怀疑，处于某些位置的人，知道干活的人具体在干什么样的事情吗？哈哈，我真是咸吃萝卜淡操心~😆不去想这些事情了，把自己要投产的任务做好就行了，毕竟这是自己的分内之事。目前还有几个样例没跑过，可能还需要在修改下代码，所以有些地方还要在深究一下。以上，是大致工作的内容，具体也不想展开的太细了，就这样吧。 回到学习上，这个月继续在看四月份停下来的网课。涉及到的内容，就是 C 和数据结构相关的部分，也算是一种复习吧，毕竟数据结构很多都忘了🤐...但是在实际听课和打码的过程中，还是见到了很多新的内容，比如：C 中回调函数的实现和使用、C 中如何应用 OO 的思想和指针偏移量的使用等，都是让我见到觉得很新奇的东西，不得不感叹 C 语言真的太精炼和简洁了。另外，关于上面这些新奇（对我而言）内容的笔记，计划是后面慢慢补起来，总而言之，加油吧。所以，八月最好是把跟数据结构相关的内容做完，并且把与 C 相关的内容好好整理一下，为重新开始基础理论的学习打一点基础。 生活上值得一提的是，这个月在吃、玩上的花销明显多了一些，至少自己边自我锻炼、边提升伙食，还是让自己长了 3 公斤啊，太不容易啦~😘。话说，今天下午才去游泳回来，哈哈，真累~计划，下周再去游泳，嘿嘿。对了，这个月自己去唱了一次歌，一个人酣唱了 4 小时，无人打扰，是真的太爽啦。虽然嗓子最后感觉有点不舒服了，但是明显还不够尽兴，哈哈，唱歌真的是一个很解压的活动啊🎤~唯一觉得自己还做的不好的地方就是，睡眠时间不太够，原因是工作日的时间太短暂了，感觉大脑好像还没得到休息，就又要上班了，就看点别的视频分散一下自己的注意力，结果每次都到十二点。从健康出发，自己还是要注意呀，要注意自我约束，哈哈，感觉自己在说屁话😆。 就这样吧，就记录这些了，剩下要完成的任务就丢给八月的自己吧，不要忘记自己的目标就好。 PS：我又捡了一张门禁卡😑]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_06_月总结]]></title>
    <url>%2F2023%2F07%2F03%2F2023-06-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2023 已经过去一半~✈ 她来听我的演唱会 - 张学友Your browser does not support the audio tag. 突然很想听这首准备开始练习但还没开始练习的歌😁，转眼间，半年已逝... 目光回到这个月来，还是老规矩，先说说工作的事情。这个月的工作较为忙碌，忙碌的点在于需求没有理解清楚，导致开发过程中，改过来，改过去，做了不少重复性的工作，有一种平白无故做了很多无用功的感觉，但这样做的好处（安慰自己一下）就是代码写起来更加顺手了~🤣仔细想一想，相比自己刚来这里的时候，真的进步了很多呀。不管是从开发流程、编码能力，还是业务理解、沟通能力等，自己各方面的能力都有所提高，但是最主要的还是自己分析问题和解决问题的能力。实际上，这两方面的能力还得继续锻炼，还是要多动脑子思考，谋定而后动。最后，再插一句的是，上文提到的需求，今天才把代码审查完😂 再回到学习上，这个月重看了翁恺老师的 C++ 课程，又有了一些不一样的收获，但是没有做下笔记，原因是没有实际的工程环境，不知道怎么写笔记了，又不想写太水的文档...所以，很尴尬。然后，本来计划重写 Nand2tetris 项目的一些代码，结果也搁浅了，还有打算读下其他项目的代码，也都搁浅了...看来自己还是偷懒了啊（其实是忙着打游戏，哈哈），得继续加油啊~那这个月就不给自己定学习计划了，免得自己又完不成😑，全凭自律了。 最后再回到生活上，身体已经没有不适的地方了，锻炼计划也一直在坚持，熬夜也减少了，要继续努力，加强锻炼。看着夏天到了，天天上下班汗如雨下，想着啥时候去游泳了🏊‍，抽时间一定要跟朋友去一次，哈哈。上个月借的书没怎么看，实属惭愧，突然想起了，胡适曾经写的打牌日记，哈哈，不过，iPad 上的书算是看的差不多了。所以，还是要有一定的阅读量，但不多，哈哈，还是不行啊，还得加大阅读量。另外，这个月把驴得水的主题曲《我要你》算是弹下来了，具体的细节因为没有记谱，不是特别熟，但和弦的走向已经心里有谱了，按照计划可以开始《太聪明》了，但是又想弹《她来听我的演唱会》，哎呀，有点难以取舍。 好了，这次的总结就到这里了吧，七月份继续加油吧，骚年~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_05_月总结]]></title>
    <url>%2F2023%2F06%2F04%2F2023-05-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[忙碌的五月~😑 Highway To Hell - AC/DCYour browser does not support the audio tag. 不管是从工作还是学习来讲，这个月很忙碌...还是老规矩，先说说工作的事情。这个月工作上的事情很多，一是这个月的投产，还有下个月的投产，一口气好几个单子，真是让人吃不消啊~顺带的还有很多配合测试的杂事要做，真的挺忙的😪。即便是在我写这篇总结的时候，还有一些工作的事情上没有解决。但是，这是下周需要解决的问题了，周末就让自己轻松一点吧。😁 再说说学习，嘿嘿，这个月花了很多时间在 Nand2tetris 上，总体学到了大概第十章的样子，还剩下一点编译原理和操作系统的内容。目前打算暂时停止一下进度，回过头总结一下，把一些逻辑重新梳理清楚，再重写一些原来的代码。其实，主要还是想六月份过的轻松点，哈哈~而且也想写点其他的项目代码，毕竟回头看的时候，好像又欠了很多东西。 最后回到生活（生活才是最重要的东西啊，却被我排到了最后🤐），这个月因为熬夜太多，身体出了一点小问题😞，难受了快两周，虽然不是很严重的问题，但是心里很介怀...实际上，身体的问题说不定很早就产生了，只是原来年轻，这个定时炸弹没有爆炸而已，但不管怎么说，现在的自己应该认真对待这个问题了（一直自我标榜认真，到这个时候了不能再当作玩笑话了）。不过好在，写这篇文章的时候，身体已经不难受了，锻炼计划也开始逐步进行了，不好的习惯也得改一改了，剩下的就交给时间吧。 另外，看了眼上个月的总结，这个月是打算看完《黄金时代》的，好在自己没有忘记，昨天下午抽了两个小时时间，一口气读完了，不过没有收获特别多的乐趣，看来需要看点其他作家的作品了🙂。所以，上上周抽空去图书馆借了两本书：《西西弗神话》和《毛泽东选集1》，接触一下其他的思考。 还有，上个月在练习的风之诗，已经很熟了，但连续三下滑弦的地方还是没练好，还需要进一步练习呢，其他地方都没有什么太大的问题了，谱子也很熟悉了，可以开始练习其他的东西了，想着是不是该练习一些歌曲，研究一下弹唱谱中的和弦、乐理了呢？毕竟，感觉最近练琴的时间真的很少，而且没有怎么思考，都是简单的练手上功夫。 PS：上个月丢掉的门禁卡，又被我捡了一张🤣 PPS：一听到 AC/DC 就想到了去年在马路上溜冰的时候😆]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf 函数的一些细节]]></title>
    <url>%2F2023%2F05%2F18%2Fprintf-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[一道容易犯思维惯性错误的 C 语言题目... 大概一个月之前，看见一道有趣的 C 语言题目，题目的形式很简单，代码部分也比较容易理解，大致如下：test11234567#include &lt;stdio.h&gt;int main() &#123; unsigned int a = 16; printf("%d %d %d\n", a &gt;&gt; 2, a = a &gt;&gt; 2, a); return 0;&#125; 现在，问输出的值各是多少。当时，简单思考了一下，就给出了4 1 1的答案。后来，自己模拟了一下，得到的结果竟然是1 4 4。脑子中立马反应过来，这是 C 语言中的未定义行为（Undefined behavior，简称 UB 行为😂），但是一是半会搞不明白为啥会得到这样的结果。查阅了一些资料后，发现printf函数的执行过程有一个入栈出栈的过程，具体而言： printf函数的参数是从后往前依次入栈的，这样出栈时就是从前往后依次输出的了 在入栈的过程中，表达式已经执行了，最后栈内存储的“东西”大概率是某个变量的地址（注意，这里没有深究） 按照上面的规则，可以分析出为何上面的代码会得出1 4 4的结果：1234561. 压 a 的地址入栈2. a = a &gt;&gt; 2，表达式的值为 a 此时的值，即 4，入栈3. 表达式的值为 a &gt;&gt; 2 的值 1，入栈4. 出栈，解析为 15. 出栈，解析为 46. 出栈，解析为 4 有了上面的分析，对结果的由来就不再陌生了。但这里需要注意的是，最后输出结果中第二个参数的值4并不能佐证栈内存储的“东西”大概率是某个变量的地址这个观点。实际上，可以通过另外一个简单的例子来验证一下猜想：test212345678#include &lt;stdio.h&gt;int main() &#123; int b; printf("%d %d %d\n", b = 3, b = 2, b = 1); printf("%d\n", b); return 0;&#125; 如果栈内存储的是表达式的值，那么最后输出的结果应该是：123 2 13 但实际上却是：123 3 33 按照从后往前入栈并执行的规则，变量b一共被赋值了 3 次，但结果以最后一次为准，也即b = 3。但此时又会有一个新的问题产生，那就是究竟是printf函数的参数列表入栈后保存的是变量的地址，还是赋值表达式本身的返回结果是一个地址呢？ 哈哈，想要解决这个问题，应该有三个方法： 仔细看看printf函数的源码，研究一下具体是如何实现的 直接编译成汇编，看看汇编代码是怎么写的（这需要一定的汇编基础） 借助一些调试工具，看看栈上的地址是如何变化的 在这里就不再深究了，为啥？因为深究这些 UB 行为没有太大的意义😄，之所以这么说，是因为不同编译器的具体实现不同，这就导致相同形式的未定义行为在不同编译器下编译后产生的结果可能也不相同😂。当然了，阅读一下源码，学习一下汇编或者研究一下如何使用调试工具都是很好的，这些就留到下次再说吧...PS：主要是下次又可以水文了，嘻嘻~😁]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_06]]></title>
    <url>%2F2023%2F05%2F05%2FNand2Tetris-Part1-06%2F</url>
    <content type="text"><![CDATA[好几年了，上册终于要学完了🤣...最后一周的内容与汇编解释器有关。因为这一周在课堂上用 iPad 做了笔记，所以每一节的内容直接用课堂上的笔记，然后看情况再增加或修改一点内容吧。 Unit 6.1 Assembly Languages and AssemblersWeek Target: use a Assembler translate Assembly Language to binary code.Basic Concept: The “Assembler” is software First software layer above the hardware Basic Logic: Read the next Assembly language command Break it into the different fields it is composed of Lookup the binary code for each field Combine these codes into a single machine language command Output this machine language command example1234567891011121314151. Load R1, 18 &lt;- char array == strings 👇2. load R1 18 v s t &lt;- 3 strings 👇3. Command Table &lt;- use a table to translate the command into machine language directly Load 11001 R1 01 18 000010010 ... ... 👇4. Combination, sometime need to add other bits to it. Load + R1 + 18 = 1100101000010010 👇5. Output About Symbols: Assembler must replace names with address by using a Symbols-Address Table like Command Table. Unit 6.2 The Hack Assembly Language: A Translator’s PerspectiveHack language specification: A-instructionSymbolic syntax: @valueBinary syntax: 0valueInBinaryExample: @21 == 0000000000010101 C-instructionSymbolic syntax: dest=comp;jumpBinary syntax: 111 ac1c2c3c4c5c6 d1d2d3 j1j2j3 Pre-defined symbolsR0, R1, R2...(refer to the book for more information) Assembly program elements: White space(Ignore it, we don’t need to care ✅) Empty lines / indentation Line comments In-line comments Instructions A-instructions C-instructions Symbols (⭐⭐⭐ Challenges) References Label declaration The plan ahead: Develop a basic assembler that translate symbol-less Hack programs(next unit) Develop an ability to handle symbols(nexxt unit) Morph the basic assembler into an assembler that translate any Hack program(nexxxt unit) Unit 6.3 The Assembly Process: Handling Instructions Translating A-instructions 2 situations121. If value is a decimal constant, generate the equivalent 15-bit binary constant2. If value is a symbol, later Translating C-instructions example12345678MD=D+1 👇dst = MD, comp = D+1, jmp = null 👇dst = 011, comp = 1011111, jmp = 000, C-flag = 111 👇C-flag + comp + dst + jmp111 1011111 011 000 The overall assembly logic Unit 6.4 The Assembly Process: Handling SymbolsSymbols: Pre-defined symbols, Label symbols, Variable symbols. Pre-defined symbolsPre-defined symbols represent special memory locations. @pre-defined symbols = @value, it’s A-instructions. Label symbolsLabel symbols represent destinations of goto instructions.3 steps: Used to label destinations of goto commands Declared by the pseudo-command: (xxx), and no need to translate, just ignore it. This directive defines the symbols xxx to refer to the memory location holding the next instruction in the program, like that:example1234Symbol Value LOOP 4 STOP 18 END 22 So, translate the label symbol:@lableSymbol = @value, and here the value is just a line number. Variable symbolsVariable symbols represent memory location where the programmer wants to maintain values. There’s a little hard to translate it. First of all, any symbol xxx appearing in an assembly program which isnot pre-defined and is not defined elsewhere using the (xxx) directive is treated as a variable. Secondly, each variable is assigned a unique memory address, starting at 16(not a arbitrary number 👀). So, translate variable symbols by 2 steps: If you see it for the first time, assign a unique memory address. Replace variable symbols with it’s value. And in order to get this value, we search the value by a Symbol Table. Now, how do we get the Symbol Table?3 steps: Initialization: Add the pre-defined symbols First pass: Add the label symbols Second pass: Add the variable symbols Unit 6.5 Developing a Hack Assembler: Proposed Software ArchitectureSub-tasks that need to be done:Task 1Task 2Task 3Reading and parsing commandsSteps:a. Start reading a file with a given nameb. Move to the next command in the filec. Get the fields of current commandTips: No need to understand the meaning of anything.Converting mnemonics -&gt; codeUse the API provided by Java/C++/Python string class to parse the instructions.Tips: No need to worry about the mnemonic fields were obtained.Handling symbolsUse the Use the Symbol Table that we have mentioned eariler translate symbols.Tips: No need to worry about what these symbols mean.Over logic: Initialization: Parser and Symbol Table First Pass: Read all commands, only paying attention to labels and updating the symbol table Second Pass: Restart reading and translating commands Main Loop: Get the next Assembly Language Command and parse it For A-Commands: Translate symbols to binary addresses For C-Commands: get code for each part and put them together Output the resulting machine language command Unit 6.6 Project 6 Overview(Programming Option)Proposed design: Parser Code Symbol Table Main Proposed Implementation: Staged development Develop a basic assembler that translate assembly programs without symbols Develop an ability to handle symbols Morph the basic assembler into an assembler that can translate any assembly program Supplied 2 types of test programs1234Add.asmMax.asm MaxL.asmRectangle.asm RectangleL.asmPong.asm PongL.asm Unit 6.6 Project 6 Overview(without Programming)Translating *.asm program manually✍, and it will be a boring process.So, it would be better to solve this problem by programming. Unit 6.7 ProjectAs mentioned earlier, we can use Java, C++ or Python implement assembler. And here I use C++ to complete the project. I also get some template files about this project, so I just need to complete the methods that implement these classes.🎈 Here are the files that have been implemented(can handle A/C instructions and symbols):Assembler.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#ifndef ASSEMBLER_H#define ASSEMBLER_H#include &lt;string&gt;#include "SymbolTable.h"using namespace std;class Assembler &#123; public: /** Instruction types */ enum InstructionType &#123; A_INSTRUCTION, C_INSTRUCTION, L_INSTRUCTION, NULL_INSTRUCTION &#125;; /** C-instruction destinations */ enum InstructionDest &#123; A, D, M, AM, AD, MD, AMD, NULL_DEST &#125;; /** C-instruction jump conditions */ enum InstructionJump &#123; JLT, JGT, JEQ, JLE, JGE, JNE, JMP, NULL_JUMP &#125;; /** C-instruction computations/op-codes */ enum InstructionComp &#123; CONST_0, CONST_1, CONST_NEG_1, VAL_A, VAL_M, VAL_D, NOT_A, NOT_M, NOT_D, NEG_A, NEG_M, NEG_D, A_ADD_1, M_ADD_1, D_ADD_1, A_SUB_1, M_SUB_1, D_SUB_1, D_ADD_A, D_ADD_M, D_SUB_A, D_SUB_M, A_SUB_D, M_SUB_D, D_AND_A, D_AND_M, D_OR_A, D_OR_M, NULL_COMP &#125;; static uint16_t variableSymbolCount; /** Practical Assignment 5 methods */ Assembler(); ~Assembler(); void buildSymbolTable(SymbolTable* symbolTable, string instructions[], int numOfInst); string generateMachineCode(SymbolTable* symbolTable, string instructions[], int numOfInst); InstructionType parseInstructionType(string instruction); InstructionDest parseInstructionDest(string instruction); InstructionJump parseInstructionJump(string instruction); InstructionComp parseInstructionComp(string instruction); string parseSymbol(string instruction); string translateDest(InstructionDest dest); string translateJump(InstructionJump jump); string translateComp(InstructionComp comp); string translateSymbol(string symbol, SymbolTable* symbolTable);&#125;;#endif /* ASSEMBLER_H */ Assembler.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include "Assembler.h"#include "SymbolTable.h"#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;uint16_t Assembler::variableSymbolCount = 16;/** * Assembler constructor */Assembler::Assembler() &#123; // Your code here&#125;/** * Assembler destructor */Assembler::~Assembler() &#123; // Your code here&#125;/** * Assembler first pass; populates symbol table with label locations. * @param instructions An array of the assembly language instructions. * @param symbolTable The symbol table to populate. */void Assembler::buildSymbolTable(SymbolTable* symbolTable, string instructions[], int numOfInst) &#123; // Your code here uint16_t lineNumber = 0; for(int i = 0; i &lt; numOfInst; i++) &#123; if(instructions[i][0] == '(') &#123; string t = instructions[i].substr(1, instructions[i].size() - 2); symbolTable-&gt;addSymbol(t, lineNumber); &#125; else &#123; lineNumber++; &#125; &#125;&#125;/** * Assembler second pass; Translates a set of instructions to machine code. * @param instructions An array of the assembly language instructions to be converted to machine code. * @param symbolTable The symbol table to reference/update. * @return A string containing the generated machine code as lines of 16-bit binary instructions. */string Assembler::generateMachineCode(SymbolTable* symbolTable, string instructions[], int numOfInst) &#123; // Your code here // Only process A and C instructions string ret = ""; for(int i = 0; i &lt; numOfInst; i++) &#123; InstructionType t = parseInstructionType(instructions[i]); if(t == A_INSTRUCTION || t == L_INSTRUCTION) &#123; ret = ret + '0' + translateSymbol(parseSymbol(instructions[i]), symbolTable); &#125; else if(t == C_INSTRUCTION) &#123; ret += "111"; // C instructions prefix ret = ret + translateComp(parseInstructionComp(instructions[i])); ret = ret + translateDest(parseInstructionDest(instructions[i])); ret = ret + translateJump(parseInstructionJump(instructions[i])); &#125; &#125; return ret;&#125;/** * Parses the type of the provided instruction * @param instruction The assembly language representation of an instruction. * @return The type of the instruction (A_INSTRUCTION, C_INSTRUCTION, L_INSTRUCTION, NULL) */Assembler::InstructionType Assembler::parseInstructionType(string instruction) &#123; // Your code here: if(instruction[0] == '@' &amp;&amp; ('0' &lt;= instruction[1] &amp;&amp; instruction[1] &lt;= '9')) return A_INSTRUCTION; else if(instruction[0] == '@' &amp;&amp; !('0' &lt;= instruction[1] &amp;&amp; instruction[1] &lt;= '9')) return L_INSTRUCTION; else if(instruction[0] =='(') return NULL_INSTRUCTION; else return C_INSTRUCTION;&#125;/** * Parses the destination of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The destination of the instruction (A, D, M, AM, AD, MD, AMD, NULL) */Assembler::InstructionDest Assembler::parseInstructionDest(string instruction) &#123; // Your code here: InstructionDest ret = NULL_DEST; string::size_type idx = instruction.find("="); if(idx == string::npos) return ret; string dest = instruction.substr(0, idx); if(dest == "A") ret = A; else if(dest == "D") ret = D; else if(dest == "M") ret = M; else if(dest == "AM") ret = AM; else if(dest == "AD") ret = AD; else if(dest == "MD") ret = MD; else if(dest == "AMD") ret = AMD; return ret;&#125;/** * Parses the jump condition of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The jump condition for the instruction (JLT, JGT, JEQ, JLE, JGE, JNE, JMP, NULL) */Assembler::InstructionJump Assembler::parseInstructionJump(string instruction) &#123; // Your code here: // for example if "JLT" appear at the comp field return enum label JLT if (instruction.find("JLT") != string::npos) &#123; return JLT; &#125; else if(instruction.find("JGT") != string::npos) &#123; return JGT; &#125; else if(instruction.find("JEQ") != string::npos) &#123; return JEQ; &#125; else if(instruction.find("JLE") != string::npos) &#123; return JLE; &#125; else if(instruction.find("JGE") != string::npos) &#123; return JGE; &#125; else if(instruction.find("JNE") != string::npos) &#123; return JNE; &#125; else if(instruction.find("JMP") != string::npos) &#123; return JMP; &#125; return NULL_JUMP;&#125;/** * Parses the computation/op-code of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The computation/op-code of the instruction (CONST_0, ... ,D_ADD_A , ... , NULL) */Assembler::InstructionComp Assembler::parseInstructionComp(string instruction) &#123; // Your code here: // for example if "0" appear at the comp field return CONST_0 InstructionComp ret; string::size_type idx1 = instruction.find("="); string::size_type idx2 = instruction.find(";"); string comp; if(idx1 != string::npos &amp;&amp; idx2 != string::npos) &#123; comp = instruction.substr(idx1 + 1, idx2); &#125; else if(idx1 == string::npos &amp;&amp; idx2 != string::npos) &#123; comp = instruction.substr(0, idx2); &#125; else if(idx1 != string::npos &amp;&amp; idx2 == string::npos) &#123; comp = instruction.substr(idx1 + 1, instruction.length()); &#125; else &#123; comp = instruction; &#125; if ("0" == comp) &#123; ret = CONST_0; &#125; else if("1" == comp) &#123; ret = CONST_1; &#125; else if("-1" == comp) &#123; ret = CONST_NEG_1; &#125; else if("A" == comp) &#123; ret = VAL_A; &#125; else if("M" == comp) &#123; ret = VAL_M; &#125; else if("D" == comp) &#123; ret = VAL_D; &#125; else if("!A" == comp) &#123; ret = NOT_A; &#125; else if("!M" == comp) &#123; ret = NOT_M; &#125; else if("!D" == comp) &#123; ret = NOT_D; &#125; else if("-A" == comp) &#123; ret = NEG_A; &#125; else if("-M" == comp) &#123; ret = NEG_M; &#125; else if("-D" == comp) &#123; ret = NEG_D; &#125; else if("A+1" == comp) &#123; ret = A_ADD_1; &#125; else if("M+1" == comp) &#123; ret = M_ADD_1; &#125; else if("D+1" == comp) &#123; ret = D_ADD_1; &#125; else if("A-1" == comp) &#123; ret = A_SUB_1; &#125; else if("M-1" == comp) &#123; ret = M_SUB_1; &#125; else if("D-1" == comp) &#123; ret = D_SUB_1; &#125; else if("D+A" == comp) &#123; ret = D_ADD_A; &#125; else if("D+M" == comp) &#123; ret = D_ADD_M; &#125; else if("D-A" == comp) &#123; ret = D_SUB_A; &#125; else if("D-M" == comp) &#123; ret = D_SUB_M; &#125; else if("A-D" == comp) &#123; ret = A_SUB_D; &#125; else if("M-D" == comp) &#123; ret = M_SUB_D; &#125; else if("D&amp;A" == comp) &#123; ret = D_AND_A; &#125; else if("D&amp;M" == comp) &#123; ret = D_AND_M; &#125; else if("D|A" == comp) &#123; ret = D_OR_A; &#125; else if("D|M" == comp) &#123; ret = D_OR_M; &#125; return ret;&#125;/** * Parses the symbol of the provided A/L-instruction * @param instruction The assembly language representation of a A/L-instruction. * @return A string containing either a label name (L-instruction), * a variable name (A-instruction), or a constant integer value (A-instruction) */string Assembler::parseSymbol(string instruction) &#123; // Your code here: return instruction.substr(1);&#125;/** * Generates the binary bits of the dest part of a C-instruction * @param dest The destination of the instruction * @return A string containing the 3 binary dest bits that correspond to the given dest value. */string Assembler::translateDest(InstructionDest dest) &#123; // Your code here: string ret; switch(dest) &#123; case A: ret = "100"; break; case D: ret = "010"; break; case M: ret = "001"; break; case AM: ret = "101"; break; case AD: ret = "110"; break; case MD: ret = "011"; break; case AMD: ret = "111"; break; case NULL_DEST: ret = "000"; break; default: break; &#125; return ret;&#125;/** * Generates the binary bits of the jump part of a C-instruction * @param jump The jump condition for the instruction * @return A string containing the 3 binary jump bits that correspond to the given jump value. */string Assembler::translateJump(InstructionJump jump) &#123; // Your code here: string ret; switch(jump) &#123; case JLT: ret = "100"; break; case JGT: ret = "001"; break; case JEQ: ret = "010"; break; case JLE: ret = "110"; break; case JGE: ret = "011"; break; case JNE: ret = "101"; break; case JMP: ret = "111"; break; case NULL_JUMP: ret = "000"; break; default: break; &#125; return ret;&#125;/** * Generates the binary bits of the computation/op-code part of a C-instruction * @param comp The computation/op-code for the instruction * @return A string containing the 7 binary computation/op-code bits that correspond to the given comp value. */string Assembler::translateComp(InstructionComp comp) &#123; // Your code here: string ret; if (CONST_0 == comp) &#123; ret = "0101010"; &#125; else if(CONST_1 == comp) &#123; ret = "0111111"; &#125; else if(CONST_NEG_1 == comp) &#123; ret = "0111010"; &#125; else if(VAL_A == comp) &#123; ret = "0110000"; &#125; else if(VAL_M == comp) &#123; ret = "1110000"; &#125; else if(VAL_D == comp) &#123; ret = "0001100"; &#125; else if(NOT_A == comp) &#123; ret = "0110001"; &#125; else if(NOT_M == comp) &#123; ret = "1110001"; &#125; else if(NOT_D == comp) &#123; ret = "0001101"; &#125; else if(NEG_A == comp) &#123; ret = "0110011"; &#125; else if(NEG_M == comp) &#123; ret = "1110011"; &#125; else if(NEG_D == comp) &#123; ret = "0001111"; &#125; else if(A_ADD_1 == comp) &#123; ret = "0110111"; &#125; else if(M_ADD_1 == comp) &#123; ret = "1110111"; &#125; else if(D_ADD_1 == comp) &#123; ret = "0011111"; &#125; else if(A_SUB_1 == comp) &#123; ret = "0110010"; &#125; else if(M_SUB_1 == comp) &#123; ret = "1110010"; &#125; else if(D_SUB_1 == comp) &#123; ret = "0001110"; &#125; else if(D_ADD_A == comp) &#123; ret = "0000010"; &#125; else if(D_ADD_M == comp) &#123; ret = "1000010"; &#125; else if(D_SUB_A == comp) &#123; ret = "0010011"; &#125; else if(D_SUB_M == comp) &#123; ret = "1010011"; &#125; else if(A_SUB_D == comp) &#123; ret = "0000111"; &#125; else if(M_SUB_D == comp) &#123; ret = "1000111"; &#125; else if(D_AND_A == comp) &#123; ret = "0000000"; &#125; else if(D_AND_M == comp) &#123; ret = "1000000"; &#125; else if(D_OR_A == comp) &#123; ret = "0010101"; &#125; else if(D_OR_M == comp) &#123; ret = "1010101"; &#125; return ret;&#125;/** * Generates the binary bits for an A-instruction, parsing the value, or looking up the symbol name. * @param symbol A string containing either a label name, a variable name, or a constant integer value * @param symbolTable The symbol table for looking up label/variable names * @return A string containing the 15 binary bits that correspond to the given sybmol. */string Assembler::translateSymbol(string symbol, SymbolTable* symbolTable) &#123; // Your code here: uint16_t n; if(!('0' &lt;= symbol[0] &amp;&amp; symbol[0] &lt;= '9')) &#123; if(symbolTable-&gt;getSymbol(symbol) == -1) &#123; n = variableSymbolCount; symbolTable-&gt;addSymbol(symbol, variableSymbolCount); variableSymbolCount++; &#125; else &#123; n = symbolTable-&gt;getSymbol(symbol); &#125; &#125; else &#123; n = stoi(symbol); &#125; string binNum = ""; for(int i = 0; i &lt; 15; i++) &#123; if(n &amp; 1) binNum += '1'; else binNum += '0'; n &gt;&gt;= 1; &#125; reverse(binNum.begin(), binNum.end()); return binNum;&#125; SymbolTable.h1234567891011121314151617181920#ifndef SYMBOL_TABLE_H#define SYMBOL_TABLE_H#include &lt;cstdint&gt; // this contains uint16_t#include &lt;map&gt; // indexable dictionary#include &lt;string&gt; // process c++ stringusing namespace std;class SymbolTable &#123; public: map&lt;string, uint16_t&gt; hashMap; SymbolTable(); ~SymbolTable(); void addSymbol(string symbol, uint16_t value); int getSymbol(string symbol);&#125;;#endif /* SYMBOL_TABLE_H */ SymbolTable.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "SymbolTable.h"#include &lt;string&gt;/** * Symbol Table constructor */SymbolTable::SymbolTable() &#123; // add pre-defined symbols hashMap["R0"] = 0; hashMap["R1"] = 1; hashMap["R2"] = 2; hashMap["R3"] = 3; hashMap["R4"] = 4; hashMap["R5"] = 5; hashMap["R6"] = 6; hashMap["R7"] = 7; hashMap["R8"] = 8; hashMap["R9"] = 9; hashMap["R10"] = 10; hashMap["R11"] = 11; hashMap["R12"] = 12; hashMap["R13"] = 13; hashMap["R14"] = 14; hashMap["R15"] = 15; hashMap["SCREEN"] = 16384; hashMap["KBD"] = 24576; hashMap["SP"] = 0; hashMap["LCL"] = 1; hashMap["ARG"] = 2; hashMap["THIS"] = 3; hashMap["THAT"] = 4;&#125;/** * Symbol Table destructor */SymbolTable::~SymbolTable() &#123;&#125;/** * Adds a symbol to the symbol table * @param symbol The name of the symbol * @param value The address for the symbol */void SymbolTable::addSymbol(string symbol, uint16_t value) &#123; // Your code here hashMap[symbol] = value;&#125;/** * Gets a symbol from the symbol table * @param symbol The name of the symbol * @return The address for the symbol or -1 if the symbol isn't in the table */int SymbolTable::getSymbol(string symbol) &#123; // Your code here if(hashMap.find(symbol) != hashMap.end()) return hashMap[symbol]; return -1;&#125; Main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;regex&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include "Assembler.h"#include "SymbolTable.h"using namespace std;int main(int argc, char** argv) &#123; if (argc &gt; 1) &#123; SymbolTable symbolTable; Assembler assembler; vector&lt;string&gt; instructionList; // Open file fstream file; string fname = argv[1]; file.open(argv[1], ios::in); if (file.is_open()) &#123; // Read line-by-line string line; while (getline(file, line)) &#123; /* remove comments */ string::size_type idx = line.find("//"); // find start of "//" string lineRmComm = line.substr(0, idx); if (lineRmComm.size() == 0) continue; // skip empty line /* remove spaces */ string::iterator str_iter = remove(lineRmComm.begin(), lineRmComm.end(), ' '); lineRmComm.erase(str_iter, lineRmComm.end()); instructionList.push_back(lineRmComm); &#125; file.close(); &#125; // Get array of instructions string instructions[instructionList.size()]; copy(instructionList.begin(), instructionList.end(), instructions); // First pass assembler.buildSymbolTable(&amp;symbolTable, instructions, instructionList.size()); // Second pass string code = assembler.generateMachineCode(&amp;symbolTable, instructions, instructionList.size()); // Print output cout &lt;&lt; code &lt;&lt; endl; &#125;&#125; Unit 6.8 PerspectivesThree questions in this week: Can you possibly improve the symbolic Hack language without changing the binary code or the machine language which is underlying the symbolic level? We have 2 layers of expression here: symbolic level and binary code. We can take symbolic level, and make it more user-friendly or more programmer-friendly. For example, D=M[100] can be translated to @100 and D=M. Will I ever have to use an assembler outside school? Vvvvvery rarely. How was the first assembler actually written? First, simply had to complie something by hand. You write an assembler in a high-level language and translate it by hand for the first time only into a machine language of your computer. Once you’ll finish this translation, which is extremely time-consuming, extremely annoying to do, but only needs to be done once conceptually.Then you already have a machine language that runs your compiler or your assembler or any high-level help that you want.]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_04_月总结]]></title>
    <url>%2F2023%2F05%2F04%2F2023-04-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[五一假期过的真快啊😪~ 風の詩 - 押尾コータローYour browser does not support the audio tag. 本来这篇总结应该在五一假期期间（也就是四月的最后几天）写好的，但是五一期间，因为在爆肝 Nand2tetris 和几道算法填空题，所以耽搁了。先说说工作的事情，四月份没有投产，很舒服~但这个月配合测试的单子太多了，各种配合测试的任务，还有一些让人很烦躁的工单...不过总的说来，还算是度过的比较平稳，尽管自己还是有很多不足的地方。四月底做了一个单子，是与前端相关的单子，这个单子也耗费了自己很多功夫，实际的改动却少的很。在开发这个任务的过程中，只有一个感觉：前端真的好无聊啊...🤣另外，到了月底的时候，突然一下子又来了两个其他的开发任务，可以预料到节后很忙。结果今天去上班，竟然又来了一个开发任务，这样算下来，节后的前几天需要解决三个开发任务了🙃，真忙啊...不过好在，今天已经解决完一个了，这两天依次解决剩下的即可。所以，给自己加个油吧！ 本来打算在四月继续学习 Linux/C 下的嵌入式开发课程的，结果学完了与 C 的相关内容后，就重新开始完成 Nand2tetris 课程去了，不得不说，Week 5 的任务真的太难了，花了自己很长的时间才完成，Week 6 的任务相对简单一些了，完成后也有很多收获。目前，想的是再回来看看这两个章节的内容，完善一下 blog 的内容。 这个月选了一首原来常听的指弹曲子作为 BGM，原因是自己最近在练习这首曲子，哈哈。实际上，这个月已经把 One more time，One more chance 练熟了，歌词也记了大概一半左右，想着等先学会唱整首歌再继续练习，所以先开始练习风之诗了。突然想到，应该先练习太聪明的，哈哈。 可惜的是，这个月没有把《黄金时代》读完，不知道自己天天在忙啥，哎，五月份一定要看完，最好是能再多读一本，嘻嘻。 实际上，还有一件事情要提一下，那就是入手了一个 Apple pencil 一代，上课的时候用来记下笔记真的挺不错的，确实能让自己的课堂效率提高，至于生产力的提高，暂时还体会不到，可能自己还不太会用。 对了，因为四月为了完成 Nand2tetris week 5 的 project，耗费了大量时间，导致这个月的文档产出，都是集中在月初，学习和 C 相关内容的时候写的...😓这个月，得想办法增加一点文档的产出了😤。 暂定的计划是完成 Nand2tetris week 6 的 project，至于要不要继续下册，看情况了，可能会回头继续去玩 Linux/C 的内容，感觉玩内核才有意思。另外，希望自己不要忘记的是，组成原理和操作系统这两门课程，一定也要想办法完成。还有，五一节期间做的几道算法题，涉及了一些 DFS、DP 的思想，真的是很好的入门题。不得不感慨，好学校还是不一样啊，老师教的东西都要好一些，哎，其实说这话挺没意思的。 继续加油吧，骚年~ PS：我的门卡好像掉了，得花 30 块补办😭]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于 C 语言内存对齐的思考]]></title>
    <url>%2F2023%2F04%2F05%2F%E5%85%B3%E4%BA%8E-C-%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[内存对齐又是 C 语言的经典问题了... intro首先应该明确的是内存对齐（Memory alignment）是一个概念，不能把它仅仅局限在 C 语言中（尽管总是会出现在 C 语言面试题中😂），它其实是一种和硬件相关的计算机系统结构设计思想，本质就是空间换时间。其次，与其说内存对齐是一个很难理解的概念，不如说是一个很麻烦的概念。换句话说，只要对齐的过程理清楚了，就不难了。当然了，本篇文章不会深入的讨论这些理论，还是重点介绍 C 语言中和内存对齐相关的知识。 struct结构体（struct）是一种构造类型，其对齐规则如下： 结构体中，第一个数据成员放在 offset 为 0 的地方，以后每个数据成员按其类型大小和默认对齐参数（32 位系统默认按照 4 字节对齐，64 位系统默认按照 8 字节对齐）中较小的一个对齐，且需要满足addr % size == 0，其中addr是当前数据成员的起始地址，size是当前数据成员的对齐值，否则补空直至满足条件。 结构体本身也需要对齐，最终sizeof的结果必须是系统默认的对齐长度和成员中最长类型二者之中最小值的整数倍。 如果存在结构体嵌套，则内层的结构体成员默认按照规则 1 进行对齐。 接下来，通过一些的例子来理解这些规则。eg1123456789101112131415161718192021#include &lt;stdio.h&gt;struct A &#123; char c1; short s;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); struct A a; printf("&amp;a.c1 = %p\n", &amp;a.c1); printf("&amp;a.s = %p\n", &amp;a.s); return 0;&#125;/*out:sizeof(struct A) = 4&amp;a.c1 = 000000834ddffbcc&amp;a.s = 000000834ddffbce*/ 这个例子按照规则 1 理解即可。eg21234567891011121314151617181920212223#include &lt;stdio.h&gt;struct A &#123; char c1; short s; char c2;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); struct A a; printf("&amp;a.c1 = %p\n", &amp;a.c1); printf("&amp;a.s = %p\n", &amp;a.s); printf("&amp;a.c2 = %p\n", &amp;a.c2); return 0;&#125;/*out:sizeof(struct A) = 6&amp;a.c1 = 000000016c7ffb3a&amp;a.s = 000000016c7ffb3c&amp;a.c2 = 000000016c7ffb3e*/ 这个例子需要用规则 1 和规则 2 来理解，c1只需要一个字节，但s需要 2 个字节，而000000016c7ffb3b % 2 != 0，所以补 1 个字节，故s从000000016c7ffb3c开始存；对应的，c2按照顺序存储在000000016c7ffb3e，但由于此时结构体的总大小是 5，整个结构体的大小必须要是 2（这个结构体的对齐值）的倍数，所以又补齐了 1 个字节，最终的大小就是 6。eg312345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;struct A &#123; char c1; int i; double d; char c2;&#125;;struct B &#123; int a; char c1; struct A sa; char c2;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); printf("sizeof(struct B) = %d\n", sizeof(struct B)); struct B b; printf("&amp;b.a = %p\n", &amp;b.a); printf("&amp;b.c1 = %p\n", &amp;b.c1); printf("&amp;b.sa = %p\n", &amp;b.sa); printf("&amp;b.sa.c1 = %p\n", &amp;b.sa.c1); printf("&amp;b.sa.i = %p\n", &amp;b.sa.i); printf("&amp;b.sa.d = %p\n", &amp;b.sa.d); printf("&amp;b.sa.c2 = %p\n", &amp;b.sa.c2); printf("&amp;b.c2 = %p\n", &amp;b.c2); return 0;&#125;/*out:sizeof(struct A) = 24sizeof(struct B) = 40&amp;b.a = 0000003dd87ff6a0&amp;b.c1 = 0000003dd87ff6a4&amp;b.sa = 0000003dd87ff6a8&amp;b.sa.c1 = 0000003dd87ff6a8&amp;b.sa.i = 0000003dd87ff6ac&amp;b.sa.d = 0000003dd87ff6b0&amp;b.sa.c2 = 0000003dd87ff6b8&amp;b.c2 = 0000003dd87ff6c0*/ 这个例子需要用规则 1、规则 2 和规则 3 来理解。首先在struct A中，b.sa.c2放在第 17 个地址处，为了满足规则 3，又补了 7 个字节，所以sizeof(struct A)最终结果是 24；而b.sa.c1和b.sa.i只需要满足addr % size == 0（规则 1）即可；最后在struct B中，b.c2放在第 33 个地址处，为了满足规则 2，又补了 7 个字节。 union在union关键字中，其实没有“对齐”这个概念，但是有“内存”的概念（实际上，C 语言总是与内存联系紧密），相比于struct而言，union关键字的内存规则要简单上许多。另外，之所以会把union的内容放在内存对齐这里，也是为了与struct进行对比，更容易熟悉二者的联系与差别。 union的规则如下： union中能够定义多个成员，整个union的大小由最大的成员的大小决定。 union成员共享同一块大小的内存，一次仅仅能使用当中的一个成员。 对某一个成员赋值，会覆盖掉其它成员的值。这是由于这些变量共享一块内存，但当成员所占字节数不一致时，仅仅会覆盖对应字节上的值，比如对char成员赋值并不会把整个int成员覆盖掉，因为char只占一个字节，而int占四个字节。 union的存放顺序是全部成员都从低地址开始存放的。 还是直接看代码来理解：eg41234567891011121314151617181920212223#include &lt;stdio.h&gt;union A &#123; char c; short i;&#125;;union B &#123; int i; float f; double d;&#125;;int main() &#123; printf("sizeof(union A) = %d\n", sizeof(union A)); printf("sizeof(union B) = %d\n", sizeof(union B)); return 0;&#125;/*out:sizeof(union A) = 2sizeof(union B) = 8*/ 从输出结果看，union的规则很容易理解，这里不再赘述。 bit field写到这里，不得不再提一下位域（也叫位字段，bit field）。位域其实就是人为划分好的二进制位区域，并且每个区域都有域名和具体的位数，比如下面这种形式：eg5123456struct &#123; unsigned int a: 1; char b: 2; char c: 1; int i: 1;&#125; b; 以上是用struct关键字声明位域，需要指出的是位域中无法使用浮点型关键字声明位域名，如float f: 1;和double d: 2;等。如果需要某些位（bit）在特定位置，可以用未命名的字段进行分隔，比如：eg712345struct &#123; unsigned int a: 32; char : 2; char c: 1;&#125; b; 当然了，未命名的位域字段是无法使用的。最后，在举一个位域的实际例子，计算 16 进制数相加：eg81234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;union &#123; struct &#123; uint16_t i; uint16_t j; &#125; x; uint32_t y;&#125; a;int main() &#123; a.y = 0x11223344; printf("%x\n", a.x.i + a.x.j); return 0;&#125;/*out:4466*/ 在上面的代码中，x和y共用一块 4 字节内存，对y赋值也相当于对x的成员i、j赋值，所以后面直接相加，就可以将两个十六进制数相加。 Summary有关 C 语言内存对齐的一些思考，到这里就暂时结束了。实际上，个人认为在 C 语言中，掌握对应规则，知道有这个“特性”存在，并能善于利用即可。真碰到了笔试题时，一个一个算，其实没有太大意义😶。因为本身 C 语言就提供了自定义内存对齐值的功能，比如：1#pragma pack(n) 这个编译指令可以指定有效对齐值为 n。也可以指定某个结构体不进行内存对齐，如：eg91234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct A &#123; int a; double d; char c;&#125;__attribute__((packed));int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); return 0;&#125;/*out:sizeof(struct A) = 13*/ 此时结构体的大小，就是其成员大小之和。另外，还有一个原因是 C11 提供了查看对齐值的宏_Alignof（需要包含头文件stdalign.h，且在 C++ 中是alignof运算符），以上面的代码为例，可以得到：eg1012345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdalign.h&gt;struct A &#123; int a; double d; char c;&#125;__attribute__((packed));int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); printf("%d\n", _Alignof(struct A)); return 0;&#125;/*out:sizeof(struct A) = 131*/ 从输出结果也可以看出，指定结构不对齐其实就是按 1 字节进行对齐😂。总而言之，对于内存对齐，只要掌握分析的方法，再掌握分析的思路，并熟练灵活运用就可以了，死记硬背过考试题、面试题，真的不是好事情...好了，又扯了这么多，关于内存对齐，暂时就到这里了。PS：写了好几天，终于勉强算是完成了，累😴。 参考内容：1. C/C++内存对齐详解2. 基础（一）结构体内存对齐3. alignof 运算符(C++11 起)4. alignof 运算符]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Memory alignment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅析快速幂算法]]></title>
    <url>%2F2023%2F04%2F03%2F%E6%B5%85%E6%9E%90%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[上周做了一道简单 C 语言练习题，做完了才反应过来是快速幂...😶记得上一次看到快速幂相关的内容已经是好几年前的事情了？当时看的一知半解，也没太在意，现在又做到了，竟然莫名觉得很清晰，是我变强了吗？哈哈~不管怎么说，这次得把这个简单实用的算法搞清楚了！ Intro快速幂算法，也叫二进制求幂（Binary Exponentiation），算法的名字就是算法的用途。算法的思路也比较简单，就是通过减少乘法操作的次数来达成快速求幂。在常规求幂的过程中，$a^n=\underbrace{a \times a \cdots \times a}_n$，而快速幂则是将每次得到的幂作为下一次的乘数和被乘数进行相乘，这样无形之中减少了乘法的次数。 Sample以计算 7 的 10 次方为例，说明一下常规思路和快速幂思路。常规思路：那就是 $7 \times 7 = 49$，$49 \times 7 = 343$，... 一步一步算，一共要进行 9 次乘法。 快速幂：先算 $7 \times 7 = 49$，然后算 $49 \times 49 = 343$，再算 $7^4$ 的平方，最后在乘以一个 $7$ 就可以得出结果了，一共是 4 次乘法。 从这里也可以看出，常规思路的时间复杂度是 $O(n)$，快速幂的时间复杂度是 $O(log n)$。 ImplementationRecursion快速幂也是基于二分的，可以考虑从递归的角度来实现，这里直接借用上周题目中所给的递归函数：$$fun(a, b) =\begin{cases}{1} &amp; \text{if b = 0;} \\{fun(a \times a, b / 2)} &amp; \text{else if b mod 2 = 0;} \\{fun(a \times a, b / 2) \times a} &amp; \text{else.} \\\end{cases}$$ 这是当时的实现：ver1123456#define MOD 1000007int fun(int a, int b) &#123; if(b == 0) return 1; else if(b % 2 == 0) return (fun(a * a, b / 2) % MOD); else return ((fun(a * a, b / 2) % MOD) * (a % MOD));&#125; 因为在计算过程中，结果可能会非常大，为了保证最后结果的正确性需要进行取余操作，另外还建议改用long long来避免溢出，所以可以得到下面的版本：ver2123456#define MOD 1000007long long fun(long long a, long long b) &#123; if(b == 0) return 1; else if(b % 2 == 0) return (fun(a * a, b / 2) % MOD); else return ((fun(a * a, b / 2) % MOD) * (a % MOD));&#125; Non-Recursion想要将上述递归算法改为非递归，就需要从二进制的角度来思考问题。比如，要计算 $7^{10}$，就有 $7^{(1010)} = 7^{(1000)} \times 7^{(0010)}$，所以非递归算法的关键在于利用位运算计算乘数，最后可以得到下面的版本：ver312345678910long long fun(long long a, long long b) &#123; long long ans = 1; while(n) &#123; if(n &amp; 1) ans = ((ans % MOD) * (a % MOD)) % MOD; a *= a; n &gt;&gt;= 1; &#125; return ans;&#125; 这里，借用他人文章中的一张图来说明整个计算过程。 回头来看，递归快速幂的思路其实也是二进制，也即对指数不断进行取余和除 2 操作，这个过程其实就是除二取余法。 Extension扩展部分主要引用他人文章中的内容，包括一些自己的理解和应用。首先是这类思路的模板：123456789101112// 泛型的非递归快速幂template &lt;typename T&gt;T qpow(T a, ll n) &#123; T ans = 1; // 赋值为乘法单位元，可能要根据构造函数修改 while (n) &#123; if (n &amp; 1) ans = ans * a; // 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。 n &gt;&gt;= 1; a = a * a; &#125; return ans;&#125; 还有一个矩阵快速幂的例子：洛谷 P1962 斐波那契数列 以及对应的代码：P1962123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#define MOD 1000000007typedef long long ll;struct matrix&#123; ll a1, a2, b1, b2; // constructor with initialize list matrix(ll a1, ll a2, ll b1, ll b2) : a1(a1), a2(a2), b1(b1), b2(b2) &#123;&#125; // operator * overloading matrix operator*(const matrix &amp;y) &#123; matrix ans((a1 * y.a1 + a2 * y.b1) % MOD, (a1 * y.a2 + a2 * y.b2) % MOD, (b1 * y.a1 + b2 * y.b1) % MOD, (b1 * y.a2 + b2 * y.b2) % MOD); return ans; &#125;&#125;;matrix qpow(matrix a, ll n)&#123; matrix ans(1, 0, 0, 1); //单位矩阵 while (n) &#123; if (n &amp; 1) ans = ans * a; a = a * a; n &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; ll x; matrix M(0, 1, 1, 1); scanf("%lld", &amp;x); matrix ans = qpow(M, x - 1); printf("%lld\n", (ans.a1 + ans.a2) % MOD); return 0;&#125; 这个小题用到了三个重要的知识点： 矩阵快速幂 构造函数初始化列表 运算符重载 真要用纯用 C 语言的东西，估计代码量是两倍了...🤔 参考内容：1. 算法学习笔记(4)：快速幂]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Binary Exponentiation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile_简单入门]]></title>
    <url>%2F2023%2F04%2F02%2FMakefile-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[简单学一下 Makefile 的编写规则~🧐 前言首先应该知道 Makefile 是用来给 Linux（Unit）平台下 Make 工具描述源程序之间的相互关系并自动维护编译工作的文件。Makefile 文件需要按照某种特定语法编写，文件中需要说明如何编译各个源文件并链接生成可执行文件，并要求定义源文件之间的依赖关系。总而言之，Make 是工具，用户通过编写 Makefile 来告诉 Make 工具如何执行编译工作。最后，需要指出的是，Windows 下也可以通过 MingW 来安装 Make 工具。 下面，以一个例子来说明如何编写 Makefile，此例子来源于李慧芹 - Makefile 工程文件的编写规则。 工程结构这个例子的工程结构比较简单，直接看源码就可以知道对应的依赖关系：main.c123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// 在 main.c 中引入两个头文件，编译 main.c 时，需要提前编译好这两个文件#include "tool1.h"#include "tool2.h"int main() &#123; mytool1(); mytool2(); exit(0);&#125; 在.c文件中写好函数的定义。tool1.c123456#include &lt;stdio.h&gt;#include "tool1.h"void mytool1() &#123; printf("tool1 print\n\n");&#125; 在.h文件中写好函数的声明和条件编译规则，以免重复编译。tool1.h123456#ifndef TOOL1_H__#define TOOL1_H__void mytool1();#endif tool2如法炮制。tool2.c123456#include &lt;stdio.h&gt;#include "tool2.h"void mytool2() &#123; printf("tool2 print\n");&#125; tool2.h123456#ifndef TOOL2_H__#define TOOL2_H__void mytool2();#endif 编写现在，开始编写 Makefile，需要说明的是，工程的目录下可以存在多个名称为Makefile的文件，但 Make 工具认为小写的优先级更高。Makefile 的编写规则比较简单，跟脚本有点类似，语法如下：12target: prerequisites command 其中，target是要生成的文件，prerequisites就是编译target所需要的依赖文件，而command就是在终端输入的编译命令了。有一点需要注意的是，command前需要有一个tab符号，且不能用空格代替，不然 Make 识别不出来。有了上面的知识，就可以写出下面的 Makefile 了：m1123456789mytool: main.o tool1.o tool2.o gcc main.o tool1.o tool2.o -o mytoolmain.o: main.c gcc main.c -c -Wall -g -o main.otool1.o: tool1.c gcc tool1.c -c -Wall -g -o tool1.otool2.o: tool2.c gcc tool2.c -c -Wall -g -o tool2.o 此时，在终端输入$ make后，Make 工具就会按照 Makefile 进行编译。编译完成后，可以发现目录下，出现了很多.o的临时文件，需要删除，手动删除太麻烦，同样借助 Makefile，只需要在下面再加上：m2123456789101112mytool: main.o tool1.o tool2.o gcc main.o tool1.o tool2.o -o mytoolmain.o: main.c gcc main.c -c -Wall -g -o main.otool1.o: tool1.c gcc tool1.c -c -Wall -g -o tool1.otool2.o: tool2.c gcc tool2.c -c -Wall -g -o tool2.oclean: rm *.o mytool -rf 此时，使用 Make 命令编译时就会自动删除多余的.o文件，并生成一个mytool的可执行文件。当然，也可以直接在终端输入$ make clean来清除.o文件。 简化观察 m2，可以发现有很多重复的部分，而 Makefile 允许我们定义变量来取代重复且冗长的部分，而变量的引用需要使用$和()来完成。此时，我们可以下面的 Makefile 了：m3123456789101112131415OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $(OBJS) -o mytoolmain.o: main.c $(CC) main.c $(CFLAGS) -o main.otool1.o: tool1.c $(CC) tool1.c $(CFLAGS) -o tool1.otool2.o: tool2.c $(CC) tool2.c $(CFLAGS) -o tool2.oclean: $(RM) *.o mytool -r 注意，最下面使用RM变量代替了rm -f。 继续简化实际上，Makefile 提供了一些自动变量运行我们进一步简化 Makefile。比如，在当前某一行的实现上，我们可以用$^来代替所有的依赖文件，用$@来代替目标文件。此时 Makefile 就可以写成：m4123456789101112131415OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $^ -o $@main.o: main.c $(CC) $^ $(CFLAGS) -o $@tool1.o: tool1.c $(CC) $^ $(CFLAGS) -o $@tool2.o: tool2.c $(CC) $^ $(CFLAGS) -o $@clean: $(RM) *.o mytool -r 写到这里，你会发现，简化后的文件中，好像有几行都是一样的，是不是还可以简化呢？答案是肯定的...😂在 Makefile 中%是一个通配符，可以用来表示当前某行实现上的相同文件名。此时，Makefile 就可以写成：m51234567891011OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $^ -o $@%.o:%.c $(CC) $^ $(CFLAGS) -o $@clean: $(RM) *.o mytool -r 这样写，就更简单了。 结语这么一通通简化下来，看起来好像是越写越简单了，可读性是越来越差了...😅不过 Makefile 作为一个工具而言，学会这些也差不多了，剩下的，等遇到了再查书~]]></content>
      <categories>
        <category>Tools</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_03_月总结]]></title>
    <url>%2F2023%2F04%2F01%2F2023-03-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[三月，是樱花🌸飞舞的季节... Nocturne No. 2 in E Flat Major, Op. 9, No. 2 - Arthur RubinsteinYour browser does not support the audio tag. 还是古典音乐让人沉静~ 先说说工作的事情，三月份（也就是上周）投产了一个单子，实际改动并不大，只是做测试的时候花了很多时间...现在想来，还觉得十分麻烦...究其原因，还是对项目不熟悉，对功能代码不了解。回头来看，这个“年老的”工程需要我懂得东西还挺多，包括 C++、WSAP、HTML、MFC 和一点点硬件知识，幸好系统还原这些运维操作，我本来就会😂，也许能接手这份工作也是偶然中的必然导致的...好了，不去想这些了。实际上而言，虽然测试费了很多功夫，但是至少让我对功能代码熟悉了很多。刚才回头看了下上个月的总结，上个月困扰自己不熟悉整体架构的问题，这个月得到了大约百分之四十的解决（哈哈，这么说话感觉不太精确，也不像书面语）。一方面是因为，这周跟 y 老师一起探讨了一些问题，有些问题得到了他的解答；另一方面是自己又看了一些其他的文档，自己做了一些总结性的笔记。 好了，工作上其实也没有其他的问题了。 回到自己的学习上，上个月自己承诺要写完的 Nand2tetris 项目，这个月还是搁浅了...不过 Tinyhttpd 项目笔记算是写完了，当然了，里面还有一些内容可以深挖一下。这个项目的笔记写完后，看到 PAT 乙级题库更新了五道题，抽了一个周末的时间，做完了，感觉还有点收获，就是太久没写 C++ 代码，有点手生。然后就是又开始看一门新的视频课了，主讲就是 Linux/C 下的嵌入式开发。就当是复习巩固 C 语言了，并学习一下 Linux 环境下的编程，看看四月能不能看完吧。 园区的樱花树🌸一开始被我当作了桃树，结果查证了一下才知道，是樱花树😓，原谅我的无知，哈哈。由于今年润了一个二月，导致现在气温不高不低，但偶尔会有春风吹过园区，连带着樱花的花瓣🌸在空中飞舞，十分漂亮。走在路上，也会时不时的踩到这些花瓣，人也会不知不觉的感慨起时间的流逝...]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言数组与指针的深入理解]]></title>
    <url>%2F2023%2F03%2F28%2FC-%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[来深入理解一下数组与指针吧~ 在C 语言函数指针的一些理解中已经梳理过了函数指针、指针数组以及二者结合的使用情形，现在继续深入理解一下数组与指针之间的差异与联系。 回顾首先，看一段代码回顾一下数组与指针的常规使用：test1123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", *pa++); return 0;&#125; 类似的，还有下面这样的用法：test2123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", pa[i]); return 0;&#125; 以及，这样的用法：test3123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", *(pa + i)); return 0;&#125; 以上这些用法，都是比较容易理解的指针在数组上的简单应用。下面，再来仔细研究一下数组与指针的关系。 一维数组在之前的文章里面，已经提到过了数组名与指针指的不是同一种东西，用来区分二者不同的工具是sizeof关键字，也就是下面这段代码：test412345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; printf("arr = %p, pa = %p\n", arr, pa); printf("sizeof(arr) = %d\n", sizeof(arr)); printf("sizeof(pa) = %d\n", sizeof(pa)); return 0;&#125;/*out:arr = 0061FF10, pa = 0061FF10sizeof(arr) = 12sizeof(pa) = 4*/ 显然，从上面的输出结果中可以知道arr这个数组名占了 12 个字节，也就是它总元素个数乘以单位元素的大小；同时，我们也知道了一个普通int *指针所占大小是 4。尽管它们值都是地址且相同，但二者是完全不一样的。 实际上，按照 C 语言的规定，数组名是一个常量，并且其值是一个地址，但并不能将数组名与指针等价。在前面的代码中，使用了一个int *指针来访问数组的元素，实际上这个指针指向的是数组的元素。如果，需要有一个指针指向数组，那么需要按照如下的方式声明指针：test5123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3] = &#123;1, 2, 3&#125;; int (*parr)[3] = &amp;arr; printf("arr = %p\n", arr); printf("parr = %p\n", parr); return 0;&#125;/*out:arr = 0061FF10parr = 0061FF10*/ 这与之前讨论函数指针的用法时是一致的，也就是需要使用()将指针名与*括起来，从而告诉编译器，这是一个指针，而不是指针数组。但此时需要注意的是，parr是一个数组指针，并不能像使用pa一样遍历数组。而pa之所以能遍历数组的原因是因为 C 语言中存在一个叫做偏移量的概念，在声明了pa是一个int *后，每次执行pa + 1，那么pa执行的地址就会移动 4 个字节，这就是偏移量（offset）。 二维数组现在，再回头看二维数组。我们先声明一个二维数组，并输出对应的地址：test612345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; printf("arr = %p\n", arr); printf("*arr = %p\n", *arr); printf("**arr = %d\n", **arr); return 0;&#125;/*out:arr = 0061FEFC*arr = 0061FEFC**arr = 1*/ 可以发现，arr和*arr表示的值都是一样的地址，也即数组首元素的地址；并且arr这个数组名需要进行两次解引用操作，才可以表示数组的元素。实际上，arr就是在 test5 中声明的数组指针，我们可以用下面的代码来验证：test7123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; printf("arr = %p\n", arr); printf("arr + 1 = %p\n", arr + 1); printf("**arr = %d\n", **arr); printf("**(arr + 1) = %d\n", **(arr + 1)); return 0;&#125;/*out:arr = 0061FEFCarr + 1 = 0061FF08**arr = 1**(arr + 1) = 4*/ 在上面的代码中，借用了一维数组与指针的技巧，将arr指针移动了一个偏移量，得到了两个不同的地址。。而两个地址的差值：$0061FEFC_{16} - 0061FF08_{(16)} = C_{(16)} = 12_{(10)}$，这个 12 正好就是 3 个int的大小，所以**(arr + 1) = 4。 现在，我们就可以写出下面的代码了：test812345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int (*parr)[3] = arr; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", parr[i][j]); putchar('\n'); &#125; return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ 或者是：test912345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int (*parr)[3] = arr; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", *(*(parr + i) + j)); putchar('\n'); &#125; return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ 类似的用法，其实都是差不多的。 数组传参接下来，我们在考虑如何在函数中传入数组的问题。就一维数组而言，直接利用一个指针即可，比如：test10123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int *a, int size) &#123; for(int i = 0; i &lt; size; i++) printf("%d ", *(a + i)); putchar('\n');&#125;int main() &#123; int arr[3] = &#123;1, 2, 3&#125;; fun(arr, 3); return 0;&#125;/*out:1 2 3 */ 函数的声明也可以写成void fun(int a[], int size);，这样写其实更新醒目。同样，二维数组也类似，但是需要指定第二维的大小，也就是：test1112345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int (*arr)[3]) &#123; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", *(*(arr + i) + j)); putchar('\n'); &#125;&#125;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; fun(arr); return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ 同样，函数的声明也可以写成void fun(int arr[][3]);。 下面，我们来做一件有趣的事情，先看代码：test12123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int *arr) &#123; for(int i = 0; i &lt; 9; i++) printf("%d ", *(arr + i)); putchar('\n');&#125;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; fun(arr); return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ 在上面的代码中，我们把二维数组的首地址，当作一维数组的首地址传给函数，尽管编译有 warnings，但是程序运行的结果是符合预期的。为什么会出现这种现象呢？实际上，二维数组在内存中的存储方式与一维数组别无二致，都是一个接一个顺序排列的，这也就意味着我们可以利用前面提到的“偏移量”这个概念来直接读取内存，达到我们的目的。这就是 C 语言区别于 Java 这类语言的地方，它允许程序员自己操作内存，但前提是你要知道自己在干什么，会得到什么样的效果，是否符合预期。同时，上面这个例子，也告诉我们，程序中的 warnings，不可忽略，稍不注意就会产生错误。 字符数组下面，再单独看看字符指针数组，先看下面的代码：test1312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *str1 = "How"; char str2[5] = "How"; printf("str1 = %s\n", str1); printf("str2 = %s\n", str2); str1 = "are"; // str2 = "are"; // error assignment printf("str1 = %s\n", str1); return 0;&#125;/*out:str1 = Howstr2 = Howstr1 = are*/ 前面已经提到过数组名是一个常量，所以这里的str2就不能直接被赋值，但是str1仅仅只是一个指针，它是可以被赋值的。实际上，这个过程也很容易想明白，重新赋值str1无非是要让这个指针再指向另外一块内存即可，但重新赋值str2意味着要在内存中找一块一样大小的空间，并写入与原先相同的值，这是很复杂的事情。 尽管字符数组无法直接赋值，但字符指针数组是可以直接赋值的，比如：test1412345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *str[4] = &#123;"I", "am", "a", "cat."&#125;; for(int i = 0; i &lt; 4; i++) printf("%s ", str[i]); putchar('\n'); str[3] = "mouse."; for(int i = 0; i &lt; 4; i++) printf("%s ", str[i]); putchar('\n'); return 0;&#125;/*out:I am a cat. I am a mouse.*/ 总结起来，也就是一句话：数组名无法直接被赋值，但指针可以直接被赋值。在进行赋值操作时，注意区分数组名和指针即可。 结尾到这里，有关函数、指针和数组之间的基本理解，基本上已经说完了。其他与指针、函数和数组组合一起使用的东西本质上也就是多层概念的嵌套使用，如果基本概念扎实，仔细分析之后也能得出结果。比如下面两种：test1512345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int *(*funcp[3])(int); printf("sizeof(funcp) = %d\n", sizeof(funcp)); int (*(*funcp2)[3])(int); printf("sizeof(funcp2) = %d\n", sizeof(funcp2)); exit(0);&#125;/*out:sizeof(funcp) = 12sizeof(funcp2) = 4*/ 根据sizeof关键字，我们可以知道，funcp是指向指针函数的函数指针数组，funcp2是指向函数指针数组的指针。不得不说，指针真的是个强大的东西。尽管如此，真正写代码的时候这样写，大概率会被打的很惨🤣~尽量保持简单、可读性高的代码才是比起炫技更应该值得考虑的事情。 OK，到此结束，后续想到了再补充~]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_乙级题库_1111-1115]]></title>
    <url>%2F2023%2F03%2F19%2FPAT-%E4%B9%99%E7%BA%A7%E9%A2%98%E5%BA%93-1111-1115%2F</url>
    <content type="text"><![CDATA[很久没来 PAT 了，没想到乙级题库新增了 5 道题😁~百度了一下，发现这是 2020 年春考 PAT 的原题，正好是周末的时间，做一下。 1111 对称日Analysis题意很清晰，把字母转换为数字，然后判断是否是回文串即可，所以需要解决的问题有两个： 字母转换为数字，这个问题题库有类似的题 判断回文串，这是 C 语言的课后习题😂 注意这个题有个细节，默认的格式是YYYYMMDD，年、月、日的位数已经定死了，如果遇到某一项位数不够的情况，需要补前导零，不如 1 月，在整个字符串内是01。当然，也可以不从字符串的角度来思考这个问题，直接从数字的角度来思考也是一样的。 Codemethod 112345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; mon2num = &#123; &#123;"Jan", 1&#125;, &#123;"Feb", 2&#125;, &#123;"Mar", 3&#125;, &#123;"Apr", 4&#125;, &#123;"May", 5&#125;, &#123;"Jun", 6&#125;, &#123;"Jul", 7&#125;, &#123;"Aug", 8&#125;, &#123;"Sep", 9&#125;, &#123;"Oct", 10&#125;, &#123;"Nov", 11&#125;, &#123;"Dec", 12&#125;,&#125;;int main(int argc, char const *argv[]) &#123; char month[5]; int day, year, N; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d, %d", month, &amp;day, &amp;year); string str_mon = month; int mon = mon2num[month]; int n = year * 10000 + mon * 100 + day; string ans = to_string(n), rans; if(ans.length() == 7) ans = "0" + ans; if(ans.length() == 6) ans = "00" + ans; if(ans.length() == 5) ans = "000" + ans; rans = ans; reverse(rans.begin(), rans.end()); if(ans == rans) printf("Y "); else printf("N "); printf("%s\n", ans.c_str()); &#125; return 0;&#125; 从数字的角度思考，最后还是要回归到字符串上，因为最后还要判断回文串。 method 212345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, string&gt; mon2num = &#123; &#123;"Jan", "01"&#125;, &#123;"Feb", "02"&#125;, &#123;"Mar", "03"&#125;, &#123;"Apr", "04"&#125;, &#123;"May", "05"&#125;, &#123;"Jun", "06"&#125;, &#123;"Jul", "07"&#125;, &#123;"Aug", "08"&#125;, &#123;"Sep", "09"&#125;, &#123;"Oct", "10"&#125;, &#123;"Nov", "11"&#125;, &#123;"Dec", "12"&#125;, &#125;;int main(int argc, char const *argv[]) &#123; char month[5]; int day, year, N; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d, %d", month, &amp;day, &amp;year); string str_mon = month, str_day = to_string(day), str_year = to_string(year); if(str_day.length() == 1) str_day = "0" + str_day; if(str_year.length() == 1) str_year = "000" + str_year; else if(str_year.length() == 2) str_year = "00" + str_year; else if(str_year.length() == 3) str_year = "0" + str_year; string date = str_year + mon2num[str_mon] + str_day; string tmp = date; reverse(tmp.begin(), tmp.end()); if(date == tmp) printf("Y "); else printf("N "); printf("%s\n", date.c_str()); &#125; return 0;&#125; 1112 超标区间Analysis这个题是个简单的滑动窗口（或者说双指针）题目，利用类似的思想即可。设置两个指针A和B，从A指针进入循环，每次遇到一个符合条件的数字时，利用B指针从当前的横坐标开始遍历数组，找出连续符合的所有数字，这样就可以利用A、B指针求出当前区间了，然后再更新循环变量的值。唯一需要多思考一下的边界是当数组最后一个元素符合条件时，B的值是数组的长度，所以循环条件使用B &lt; N和A &lt; N即可，实际上这个题也规定了横坐标的值是$[0, N - 1]$。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[]) &#123; int N, T; vector&lt;int&gt; v; cin &gt;&gt; N &gt;&gt; T; v.resize(N); for(int i = 0; i &lt; N; i++) cin &gt;&gt; v[i]; int A = 0; bool flag = false; while(A &lt; N) &#123; int B = A; while(B &lt; N &amp;&amp; v[B] &gt; T) B++; if(B &gt; A) &#123; cout &lt;&lt; "[" &lt;&lt; A &lt;&lt; ", " &lt;&lt; B - 1 &lt;&lt; "]" &lt;&lt; endl; A = B; flag = true; &#125; else A++; &#125; if(!flag) cout &lt;&lt; *max_element(v.begin(), v.end()); return 0;&#125; 1113 钱串子的加法Analysis不多说了，一个常规的进制转换题型，从 16 进制换成了 30 进制而已。需要注意的一个测试点是输入多个0的情况，比如输入000和000，最后结果不是000，而是0，所以需要删除最后结果中的前导 0。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, char&gt; num2char = &#123; &#123;0, '0'&#125;, &#123;1, '1'&#125;, &#123;2, '2'&#125;, &#123;3, '3'&#125;, &#123;4, '4'&#125;, &#123;5, '5'&#125;, &#123;6, '6'&#125;, &#123;7, '7'&#125;, &#123;8, '8'&#125;, &#123;9, '9'&#125;, &#123;10, 'a'&#125;, &#123;11, 'b'&#125;, &#123;12, 'c'&#125;, &#123;13, 'd'&#125;, &#123;14, 'e'&#125;, &#123;15, 'f'&#125;, &#123;16, 'g'&#125;, &#123;17, 'h'&#125;, &#123;18, 'i'&#125;, &#123;19, 'j'&#125;, &#123;20, 'k'&#125;, &#123;21, 'l'&#125;, &#123;22, 'm'&#125;, &#123;23, 'n'&#125;, &#123;24, 'o'&#125;, &#123;25, 'p'&#125;, &#123;26, 'q'&#125;, &#123;27, 'r'&#125;, &#123;28, 's'&#125;, &#123;29, 't'&#125;,&#125;;unordered_map&lt;char, int&gt; char2num = &#123; &#123;'0', 0&#125;, &#123;'1', 1&#125;, &#123;'2', 2&#125;, &#123;'3', 3&#125;, &#123;'4', 4&#125;, &#123;'5', 5&#125;, &#123;'6', 6&#125;, &#123;'7', 7&#125;, &#123;'8', 8&#125;, &#123;'9', 9&#125;, &#123;'a', 10&#125;, &#123;'b', 11&#125;, &#123;'c', 12&#125;, &#123;'d', 13&#125;, &#123;'e', 14&#125;, &#123;'f', 15&#125;, &#123;'g', 16&#125;, &#123;'h', 17&#125;, &#123;'i', 18&#125;, &#123;'j', 19&#125;, &#123;'k', 20&#125;, &#123;'l', 21&#125;, &#123;'m', 22&#125;, &#123;'n', 23&#125;, &#123;'o', 24&#125;, &#123;'p', 25&#125;, &#123;'q', 26&#125;, &#123;'r', 27&#125;, &#123;'s', 28&#125;, &#123;'t', 29&#125;,&#125;;void trimRightZero(string &amp;num) &#123; for(auto it = num.rbegin(); it != num.rend(); it++) if(*it == '0') num.pop_back(); else break;&#125;int main() &#123; string num1, num2, sum; cin &gt;&gt; num1 &gt;&gt; num2; reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); int index = 0, carry = 0; while(index &lt; num1.length() || index &lt; num2.length()) &#123; int tmp1 = index &lt; num1.length() ? char2num[num1[index]] : 0; int tmp2 = index &lt; num2.length() ? char2num[num2[index]] : 0; int s = tmp1 + tmp2 + carry; carry = s / 30; s %= 30; sum.push_back(num2char[s]); index++; &#125; if(carry) sum.push_back(num2char[carry]); trimRightZero(sum); reverse(sum.begin(), sum.end()); if(sum == "") sum = "0"; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; 代码中的 map 可以使用简单的int数组和char数组来完成。 1114 全素日Analysis题意很明确了，需要解决两个问题： 逐个拆分出所有的数字情况 判断是否是素数 针对第一个问题，直接用 string 容器来完成即可。而第二个问题，最大的数也不过 99991231，直接判断也是不会超时的。 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;using namespace std;bool isPrime(int num) &#123; if(num &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(num); i++) if(num % i == 0) return false; return true;&#125;int main(int argc, char const *argv[]) &#123; string date; cin &gt;&gt; date; int index = 0, len = date.length(); bool flag = true; while(index &lt; len) &#123; string num = date.substr(index); int n = stoi(num); if(isPrime(n)) cout &lt;&lt; num &lt;&lt; " Yes" &lt;&lt; endl; else &#123; cout &lt;&lt; num &lt;&lt; " No" &lt;&lt; endl; flag = false; &#125; index++; &#125; if(flag) cout &lt;&lt; "All Prime!" &lt;&lt; endl; return 0;&#125; 1115 裁判机Analysis题目略长，实际上是写一个类似数字接龙的游戏，要求就是题目的要求了。一开始以为是个模拟题，所以直接模拟了，但是有个 4 分测试点过不去。仔细一想，应该还得有点哈希的思路，换了后，结果内存超限了。好吧，看来是明确禁止使用比较大的容器了，只好利用int数组代替 unordered_map 了，再次提交，AC。 Codeversion 1这是第一版代码了，写的臭长臭长的，思路不够简洁，就是纯纯的模拟，最后是测试点 5 超时了。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;unordered_map&lt;int, set&lt;int&gt;&gt; number2diff;bool player[15] = &#123;false&#125;;int main(int argc, char const *argv[]) &#123; int init1, init2; scanf("%d %d", &amp;init1, &amp;init2); set&lt;int&gt; st1, st2; if(init1 &gt; init2) st1.insert(init1 - init2); else st2.insert(init2 - init1); number2diff.insert(&#123;init1, st1&#125;); number2diff.insert(&#123;init2, st2&#125;); scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= M; j++) scanf("%d", &amp;matrix[i][j]); for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(number2diff.find(tmp) != number2diff.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; for(auto &amp;p: number2diff) &#123; auto it = p.second.lower_bound(tmp); if(it != p.second.end() &amp;&amp; *it == tmp) &#123; flag = true; break; &#125; &#125; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; set&lt;int&gt; st; for(auto &amp;p: number2diff) &#123; if(p.first &lt; tmp) st.insert(tmp - p.first); &#125; number2diff.insert(&#123;tmp, st&#125;); for(auto &amp;p: number2diff) &#123; if(p.first &gt; tmp) &#123; p.second.insert(p.first - tmp); &#125; &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 2第二版代码，使用了一点哈希的思路。这个思路的来源是突然发现题目只要求每个人给出数字不能重复出现，并未要求数字之间的差值不能重复出现。那么，只需要记录每个人每回合给出数字之前的所有差值是否出现，然后再满足： 当前给出的数字与之前给出的数字不重复 当前给出的数字与之前给出的数字的差值存在 为了方便起见，使用 unordered_set 来当作 hashmap，但是下面这段代码还是超时了。估计姥姥是铁了心不让用容器了...🤣123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;set&lt;int&gt; num;unordered_set&lt;int&gt; diff;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); num.insert(N); num.insert(M); diff.insert(abs(N - M)); scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num.find(tmp) != num.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff.find(tmp) != diff.end()) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: num) diff.insert(abs(i - tmp)); num.insert(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 3注意到题目给定数字的范围在$[1, 10^5]$，所以可以用一个int数组来当作 hashmap。不过，这段代码也是 320ms 左右通过测试点 5 的，是不是还可以优化下？最容易想到的优化方式就是将 set 替换为 unordered_set，哈哈，试了下，测试点 5 的时间成了 170ms 了😂。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;set&lt;int&gt; num;const int MAXN = 100000 + 5;int diff[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); num.insert(N); num.insert(M); diff[abs(N - M)] = true; scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num.find(tmp) != num.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff[tmp] == true) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: num) diff[abs(i - tmp)] = true; num.insert(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 4仔细想了下，前面提到了每个人提出的数字不能与之前的数字重复，那这个问题不还是 hashmap 的问题吗😂？所以，使用两个 hashmap 来记录数字和差值是否出现，再用一个 vector 来保存出现过的数字即可。提交了下，测试点 5 耗时才 50ms ，还是 C 语言好使😆。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;const int MAXN = 100000 + 5;vector&lt;int&gt; nums;bool num[MAXN] = &#123;false&#125;, diff[MAXN] = &#123;false&#125;;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); nums.push_back(N), nums.push_back(M); num[N] = 1, num[M] = 1; diff[abs(N - M)] = true; scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num[tmp] == true) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff[tmp] == true) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: nums) diff[abs(i - tmp)] = true; num[tmp] = true; nums.push_back(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; 回过头来再看，按照上面代码的逻辑，在 nums 中根本不可能出现重复元素，所以前面使用 set 白白浪费了自动去重的功能，还浪费了时间。而且，这个题应该算作一道考察散列的题目，只要能想到散列这个知识点，基本就可以 AC 了。]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 语言函数指针的一些理解]]></title>
    <url>%2F2023%2F03%2F13%2FC-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数指针属于 C 语言的进阶内容之一，前两天研究 tinyhttpd 时，碰到了函数指针，产生了一些疑问... 普通指针在研究函数指针之前，先回顾一下普通指针，先看下面的代码：123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;struct point &#123; int x, y;&#125;; int main(int argc, char const *argv[]) &#123; int a = 10, *pa = &amp;a; printf("*pa = %d, a = %d\n", *pa, a); float f = 1.0, *pf = &amp;f; printf("*pf = %f, f = %f\n", *pf, f); struct point A, *pA = &amp;A; A.x = 3, A.y = 3; printf("A.x = %d, A.y = %d\n", A.x, A.y); printf("pA-&gt;x = %d, pA-&gt;y = %d\n", pA-&gt;x, pA-&gt;y); printf("*pA.x = %d, *pA.y = %d\n", (*pA).x, (*pA).y); return 0;&#125;/*output:*pa = 10, a = 10*pf = 1.000000, f = 1.000000A.x = 3, A.y = 3pA-&gt;x = 3, pA-&gt;y = 3*pA.x = 3, *pA.y = 3sizeof(pa) = 4sizeof(pf) = 4sizeof(pA) = 4*/ 从输出结果可以看出，不管是普通变量的指针，还是结构体的指针，都是普通的指针变量，而指针的本质就是保存地址的变量，通过这个地址可以找到对应的变量。利用&amp;符号，可以得到变量的地址从而赋值给指针变量，这样这个指针变量就指向了使用&amp;运算符的变量。 函数指针现在，回到对函数指针的思考上，首先应该要认识的是：函数指针的本质还是指针，它与普通指针没有什么差别，还是指针变量，只不过这个指针变量指向的是函数，就跟不同类型的指针变量指向对应类型的变量一样。通过上面的代码，我们知道&amp;符号可以取出一个变量的地址，那函数的地址是不是也可以这样取出呢？写个程序测试一下：test11234567891011121314#include &lt;stdio.h&gt;void fun() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("&amp;fun = %p\n", &amp;fun); printf("sizeof(&amp;fun) = %d\n", sizeof(&amp;fun)); return 0;&#125;/*output:&amp;fun = 00401460sizeof(&amp;fun) = 4*/ 可以发现使用&amp;符号的确可以输出函数的地址，同时使用sizeof关键字得到了“取出的地址”的大小。按照前面的思路，我们知道这是一个指针，但这是个什么类型的指针，不知道，为什么是 4，也不知道，但我们可以再多写点代码验证一下思路：test2123456789101112131415161718#include &lt;stdio.h&gt;void fun() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("&amp;fun = %p\n", &amp;fun); printf("sizeof(&amp;fun) = %d\n", sizeof(&amp;fun)); int i = 10, *pi = &amp;i; printf("sizeof(&amp;i) = %d\n", sizeof(&amp;i)); printf("*pi = %d, sizeof(pi) = %d\n", *pi, sizeof(pi)); return 0;&#125;/*&amp;fun = 00401460sizeof(&amp;fun) = 4sizeof(&amp;i) = 4*pi = 10, sizeof(pi) = 4*/ 现在，可以很清楚的确定，利用&amp;取出的函数的地址与指针变量是一样，它们都是 4 个字节的大小，那么也就是说函数指针也是一种指针变量，这与前面的思路是一致的。 了解函数指针大概是什么样子的后，肯定会冒出这样的问题：怎么使用函数指针变量指向某个函数呢？换句话说，就是如何像使用int i, *a = &amp;i;这样，声明某个指针变量并指向某个函数呢？ 显然，这个问题 C 语言肯定是有规定的，函数指针的声明方式与函数声明是类似的，只是需要加上*和()。同样，我们用代码说话：test31234567891011121314151617#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;int main(int argc, char const *argv[]) &#123; int (*pf)(int) = &amp;fun, a = 10; pf(a); return 0;&#125;/*output:In fun, a = 10*/ 在上面的代码中，声明了一个函数指针变量pf指向函数fun，然后通过pf指针，调用了函数fun，输出a的值。相比函数的声明而言，有两个特点： 省略了参数名，但不能省略参数类型，且必须与被指向的函数参数类型、数量一致 需要用*和()讲指针名括起来 按照上面的思路，可以知道函数指针的声明方式是[return-type] (*pointer-name)(parameter-list)。 现在，我们在上面的代码中尝试将函数指针作为函数的参数使用：test41234567891011121314151617181920#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;void func(int (*pf)(int)) &#123; int a = 10; pf(a);&#125;int main(int argc, char const *argv[]) &#123; func(&amp;fun); return 0;&#125;/*output:In fun, a = 10*/ test3 和 test4 两段代码的输出结果是完全一致的，不同的是在 test4 中，直接使用函数指针作为另一函数的参数，然后在另一函数中通过函数指针调用这个函数。可以发现，函数指针作为函数参数的写法与其声明没有太大差异。 数组指针现在我们再回顾一下数组指针的用法，先看下面的代码：test512345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;void fun(int *pa) &#123; printf("*pa = %d\n", *pa); printf("sizeof(pa) = %d\n", sizeof(pa));&#125;int main(int argc, char const *argv[]) &#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; fun(a); printf("sizeof(a) = %d\n", sizeof(a)); int (*parr)[5] = &amp;a; printf("a = %p, &amp;a = %p\n", a, &amp;a); printf("parr = %p\n", parr); printf("*parr = %d\n", *parr); printf("sizeof(&amp;a) = %d\n", sizeof(&amp;a)); printf("sizeof(parr) = %d\n", sizeof(parr)); return 0;&#125;/**pa = 1sizeof(pa) = 4sizeof(a) = 20a = 0061FF08, &amp;a = 0061FF08parr = 0061FF08*parr = 6422280sizeof(&amp;a) = 4sizeof(parr) = 4 我们知道数组名就表示数组的首地址，所以可以将数组名直接作为函数的参数，从而传入数组的地址，但数组名和指向数组的指针是两个完全不同的东西，这一点可以通过sizeof关键字看出，也就是说parr跟&amp;a是同一类事物——二者都是数组指针，对应的它的类型声明才是数组指针的声明，而sizeof则认为a是一个数组，所以sizeof(a) = 20。从这里也可以看出，数组指针的声明与函数指针类似，有两个条件需要指定： 数组的类型 数组的维度 不过，实际上，C 语言存在隐式类型转换（还有兼容老版本写法之类的历史遗留原因等），所以有时候写法不严格，编译也可以通过，但会产生 warnings，总之尽量保持类型一致，不要出现 warnings。但这里有意思的是，数组名作为地址可以直接作为指针传给函数使用，那函数名呢？当然也可以了~那么，test4 的代码可以改成：test4_112345678910111213141516171819202122#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;// void func(int (*pf)(int)) &#123;void func(int pf(int)) &#123; int a = 10; pf(a);&#125;int main(int argc, char const *argv[]) &#123; // func(&amp;fun); func(fun); return 0;&#125;/*output:In fun, a = 10*/ 在上面的代码中，有两个改动的地方： 函数指针做参数的函数声明中，去掉了* 直接将函数名作为参数传入另一个函数中，去掉了&amp; 虽然这两处改动都不影响使用，但是读起来容易引起混淆，语义不明确，这应该是某种“历史遗留写法”，最好不要这样写。实际上，我们可以通过sizeof来观察一下函数名与函数指针的差异，再添几行代码：test612345678910111213#include &lt;stdio.h&gt;void func() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("sizeof(func) = %d, sizeof(&amp;func) = %d\n", sizeof(func), sizeof(&amp;func)); return 0;&#125;/*output:sizeof(func) = 1, sizeof(&amp;func) = 4*/ 显然，与数组类似，函数名与函数指针也是两个不同的东西。 指针数组接下来，在看看指针数组（反着叫又是另外一种东西了😂）的用法，直接看下面的代码：test712345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int a = 10, b = 20; int *parr[2] = &#123;&amp;a, &amp;b&#125;; printf("%d, %d\n", *parr[0], *parr[1]); return 0;&#125; 其实就是在指针后面加上了[]符号，对于其他类型也是一样的用法。 函数指针数组说完了函数指针也数组指针的区别，见到了指针数组的用法，接下来，再来看看如何使用函数指针数组。假设我们要计算两个整数的四则运算结果，为了使用到函数指针数组，先定义四个函数，然后放到函数指针数组中，再利用函数指针数组逐个调用函数完成计算。按照这样的思路，可以写出以下代码：test81234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int add(int a, int b) &#123; return a + b;&#125;int minus(int a, int b) &#123; return a - b;&#125;int mult(int a, int b) &#123; return a * b;&#125;int div(int a, int b) &#123; return a / b;&#125;int main(int argc, char const *argv[]) &#123; int a = 10, b = 10; int (*pfun[4])(int, int) = &#123;add, minus, mult, div&#125;; for(int i = 0; i &lt; 4; i++) printf("pfun[%d](a, b) = %d\n", i, pfun[i](a, b)); return 0;&#125;/*output:pfun[0](a, b) = 20pfun[1](a, b) = 0pfun[2](a, b) = 100pfun[3](a, b) = 1*/ 实际上，函数指针数组也就是在函数指针中间加上[]，这与指针数组是类似的。但是要注意的是，函数指针数组只能保存“同一类”函数指针，而“同一类”在这里是指返回类型和参数列表需要一致。 总结虽然这篇文章题目叫做函数指针，但是目前我们一共学习了五种不同的与指针相关的概念和用法，分别是： 普通指针 数组指针 函数指针 指针数组 函数指针数组 同时，还认识到了数组名与数组指针、函数名与函数指针的区别。这些都只是指针用法的冰山一角，指针还有很多其他的用法，比如通过指针在函数中修改实参的值，或者是在 C++ 中用父类指针指向子类对象，调用子类方法，从而实现动态多态等等。所以，学习之路还很漫长啊~😪]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_02_月总结]]></title>
    <url>%2F2023%2F03%2F05%2F2023-02-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[现在是 2023 年 3 月 5 日了...😑 Dreams - The CranberriesYour browser does not support the audio tag. 本来打算二月底就写好这篇 blog 的，但是二月的最后几天还是工作日，计划就搁浅了（哈哈，总是为自己找借口）。 等等，突然发现一月的总结也是二月中旬才写的...废了，已经是拖延症晚期了🤐 哈哈，但是现在记录的是二月的事情，其他的就不去想了。 这个月工作方面不是很忙，只有投产的那个周格外忙一些，但是投产之后就没有什么其他的事情了。这次投产的版本，算是自己做的第二个版本了。目前对整个项目大致上有了一定的思路，至少观察 debug 日志的时候，知道什么样子是正常的，什么样子是异常了。但是，对项目的整体结构还是缺乏认识，对各个部分的作用和通信，还是很迷糊。但是，自己还是想吐槽这个从零几年一直维护到现在的 MFC 应用，还是用 VC++6.0 开发的（每次进入这个 IDE 都有一种心累的感觉😂），从这一点上看，这个项目其实也快没有维护的价值了（现在就我一个人在维护这个项目，心累啊~）。客观来讲，在那个 STL 都没有的年代，MFC 能构造出这么多的数据结构实在是很不容易了，而当时 windows 平台下的 C/C++ 项目不用 MFC 可能就没别的可以用了😂。但是，时代也在发展，现在得向前看了，不管怎么样，自己对这个东西一定要认识清醒，要学习自己应该学习的东西，保持自身的竞争力。 好了，以上是工作方面，一切都按部就班的进行着。 下面是生活方面的事情，这个月末，找到了一个小单间（合租的），虽然跟朋友分开住了，有些许不舍，但是自己现在离工作的地方很近，这点真的很香（虽然整个租房的过程也是一言难尽了，详情见找房记）。现在下班的时间很充足了，五点下班，吃完晚饭，到住的地方才六点，就有很多时间可以干自己的事情了，感觉现在弹琴都有大把时间了，哈哈。而且早上也不用起的那么早了，不过早睡早起的好习惯还是要保持，嘿嘿。 至于学习方面，Nand2tetris 还有两篇 blog 没有写，自己真的是一拖再拖了...不过自己现在正在看 TinyHttpd 整个二十年前的服务器项目。没想到，这个二十世纪初的项目所使用的语法，竟然让我觉得毫无违和感，C 语言果然是最好的语言，哈哈~这个月最好能把 Nand2tetris 这个课程完结了，然后把 TinyHttpd 这个项目的源码也读完，这样我就有时间去读原来没读完的 Linux 内核源码（为什么自己欠了这个多账啊😂）。总而言之，赶紧动起来吧，现在一个人住了，可没人打扰了，而且三月份的工作应该也不忙（两会期间，变更操作很少）。 值得一提的是，幸好提前搬过来了，不然周六来打开那真的是很难受啊。另外，朋友小 y，也搬离了原来的房子，换了一个便宜点的合租房子，就在他上班的对面，真近啊！ BTW，在三月开初，春天到来的日子，我好像得了流感...而且就是这两天的事情，真蛋疼啊，希望自己快点好。 最后，自己在提醒自己一下，别忘了按时完成任务~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[找房记]]></title>
    <url>%2F2023%2F02%2F28%2F%E6%89%BE%E6%88%BF%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[不知不觉来到上海已经五个月了，与朋友小 y 也一起度过了五个月... 经过了四个月每天长达三个多小时的通勤，终于在工作转正之后，决定搬到一个离上班地点近一点的地方了。于是乎，周五下班之后就去之前联系好的中介那里看房了。 第一个出场的是一个公寓中介，小区房，面积不大，商用电，1900 一个月，水网另算。总而言之，一句话，不管用不用都要交钱。看着不大的房间和超标的水电网费，直接否决。结果事后，这位公寓中介还发消息说这个价格都差不多，答曰谢谢，再考虑考虑。 第一个看完了，走在小区内，看到放在植物上的广告牌——大业主直租，遂电话之。三分钟后，出现在眼前的是一位上海阿姨，然后就领我到了她家自己的房子中。说是自家的，其实一样是合租房，与其他中介的房子别无二致，唯一的优点是燃气做饭，可在这一点上，我一件做饭的家伙都没有。不过值得称道的是，这间合租房另外两个室友看着比较讲干净，这对我来说是个好消息。而且，这个房子的缺点很明显——朝北，很暗，没有阳光。不过对于上班族来讲，这倒不是很大的问题。仔细询价之后，才知道得要 1600，感觉还是难以接受，然后就走了。 回到小区门口后，又看到地上的广告，看着上面写的单间、独卫，燃气做饭，只要 1800 左右，又打电话询问。结果在电话里面，不管问什么都是有，然后就是问你在哪里，带你去看。五分钟之后，站在眼前的是两位中年妇女，我问是不是中介，说不是，是二房东。领着我到了一个老小区，先看了一个单间，破的不像样子了，要 1500，被我直接否决。然后又带我看了一件稍好一点的房子，是单间、独卫，合租做饭，要价 2000，我直接走，结果被拉回来，商量价格，还到 1800，未果。走出来，看了眼时间已经八点了，准备告别这两位“二房东”回去了，结果又被叫回来，说你要啥样的房子，我们给你找，然后就看到她俩快速翻动着手机的微信群，其中一个找到了，直接把价格函数来了，被另外一个止住了，大概意思是价格说错了。我寻思着，能不能专业一点，哈哈。🤣 最终，还是先回家了。 以上是发生在 2 月 24 日周五下班之后的事情。 等到第二天又去找房子了，首先找到的是一个曾经开货车现在是中介的大叔，这大叔是江苏人，先领我看了一个 1300 的小房子，只有一扇窗户，特别暗，虽然是独卫，但是独卫在楼梯下面，上厕所还得俯身进去（我容易么我😂）。看着我不满意的样子，大叔又领我去了一个稍微大点，亮很多的房子，可惜要价 2000，问题是，我用这 2000 租个小区楼不香吗？还挤在民房里干啥？😅转身谢离大叔了~ 本来今天的目标就是民房，直接扫了个黄车，继续民房之旅。左拐右拐，门上的墙上的广告确实多，仔细一看这房子是个公寓型的，毫无疑问，墙上的电话是二房东的...后来问了一位正在干活的大爷，在大爷的告知下，这附近有房子，还是 900 一个月的，本想让大爷带我过去，但是大爷在清理自家院子，能告诉我这些信息已经很不错了（大爷说的话多半是正常的价格），就道谢走人了。找了一圈没找到， 又换了个村子转，结果在这里碰到了一个租住民房十几年的二房东，接待我的是房东儿子，97 年生人，仔细一聊，上班的地方还都一样，问问是不是打算就待在上海了，结果告诉女朋友怀孕了，准备今年回去了，心中不由得感慨，还是留不下来... 下午，昨天的大业主阿姨，又打电话来了，问我租不租，还想让其他中介带我看看别的房子。实际上，她是想让其他中介为她造势，好让我租她的房子，所以电话里，我直接把价格给她还到了 1400，结果她不答应，只说让我过去。实际上，我是想租这个房子的，但是价格方面我认为还有回旋的余地，就去了。去了之后，果然如我所料，中介要带我去看房子，但是我直接婉拒了，一口咬定这是我与这位大业主的事情🤣，结果废了很多口舌，终于又从 1400 回到 1480（原价是 1600），这位阿姨才肯租给我，真难。实际上，通过前面的聊天已知了这位阿姨在这有三套房子，这个小区的房子均价在 500 - 600 万之间。也就是说，这位阿姨也是拥有千万资产的人了，怎么就这么难还价呢😂。 实际上，我很理解她的心境，按照“市场价”，又是年轻人，这价格不是很容易接受吗？但她越是这样，我越是要还价，因为我实在不明白为什么年轻人就不能还价，尽管我也知道，实际上我完全没有必要浪费时间在这些事情上。在还价的过程中，阿姨也说我不爽快，哈哈，我承认，可越这样我越是要还价（我可能有大病，哈哈😁）。后来，敲定价格之后，阿姨又说我蛮成熟🤣。 实际上当初在这个小区找房碰到了一上海大爷，正在与一群上海大妈侃大山，问了问小区房租一般多少钱，直接告诉我 3000，顿时，我的黑人问号脸都出来了😅，心里不由得想，这就是上海吗？哈哈 不管怎么说，出门在外打工的人还是很不容易的。 最后，不管是租还是买，希望大家都能有心仪的住所，正是安得广厦千万间，大庇天下寒士俱欢颜呐~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TinyHttpd_Reading_Notes]]></title>
    <url>%2F2023%2F02%2F20%2FTinyHttpd-Reading-Notes%2F</url>
    <content type="text"><![CDATA[TinyHttpd 是 J. David Blackstone 于 1999 年写的一个 500 行左右的超轻量级 http server，用来学习服务器的工作原理十分不错。 intro本篇 blog 为自己学习 tinyhttpd 这个服务器小项目所写的学习笔记，内容不多，但很细致。另外，本文所使用的源码来自于Tiny HTTPd’s tiny homepage，按照源码中的注释，修改掉对应的部分就可以在 Linux 上运行了。实际上，按照注释修改的版本是个无线程版的 tinyhttpd，而现在 Linux 也有了pthread.h这个头文件，也就可以使用pthread_create函数（这个函数可以创建线程）了，但在源码基础上，仍然需要做一些小修改才可以运行。 如果要在 Linux 上使用线程函数pthread_create，在进行下面的改动之前，忽略掉源码本来的提示修改注释。 首先是accept_request函数，需要修改函数的声明和定义的局部内容（具体可以参考后面贴出来的源码）：accept_request12345678- void accept_request(int);+ void *accept_request(void *);+ void *accept_request(void *pclient) &#123; ...+ return NULL; ...+ return NULL;+ &#125; 接着在accept_request函数内第一行再添加int client = *(int*)pclient;即可，后面会解释原因。 然后在main函数中，将pthread_create函数的第四个参数改为传入client_sock的地址即可：main12- if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)+ if (pthread_create(&amp;newthread , NULL, accept_request, &amp;client_sock) != 0) 现在通过编译所得到的 httpd 是一个线程版本的服务器。 但无论是线程版还是无线程版，都需要修改以下内容才可以在 Linux 下运行： 首先是Makefile，与源码中注释 5 一样，需要删除-lsocket指令，并将-lpthread指令放在最后面，具体如下：Makefile12- gcc -W -Wall -lsocket -lpthread -o httpd httpd.c+ gcc -W -Wall -o httpd httpd.c -lpthread然后，还需要修改index.html的权限，去掉这个文件的可执行权限，终端下执行命令chmod 600 index.html即可。 最后，还需要提醒的是此源码的 CGI 脚本需要用 perl 来执行，所以要先安装 perl，如何安装，此处不表，自行百度，但 perl 安装好之后又会存在一个 perl 路径的问题。 具体而言，源码中 CGI 脚本的路径是#!/usr/local/bin/perl -Tw，但不同 Linux 发行版的软件安装路径可能不一致，比如 Ubuntu 16.04 下需要将路径改为#!/usr/bin/perl -Tw。所以，如若可以访问index.html页面，但无法执行 CGI 脚本，可以尝试从这方面调试。 最后的最后（再废话一下😂），还需要说明的是本文所有的代码部分，不会修改或删除 J. David Blackstone 曾经留下的注释，这部分注释也可以读读，对直接理解函数的功能有用，但是英文的，读起来可能不太方便🙂。 下面就开始逐个分析一下关键的函数。 main先从main函数开始，先搞清楚大致的工作流程是什么，相关的注释已经写在对应位置：main1234567891011121314151617181920212223242526272829int main(void) &#123; // 初始化变量 int server_sock = -1; // 服务器套接字 u_short port = 0; // 服务器端口 int client_sock = -1; // 与客户端连接的句柄 struct sockaddr_in client_name; int client_name_len = sizeof(client_name); pthread_t newthread; // 声明线程 id server_sock = startup(&amp;port); // 启动服务器，用指定端口开启 http 服务 printf("httpd running on port %d\n", port); // debug 信息 while (1) &#123; // 调用 accept 函数，返回与客户端连接的文件描述符 // accept 函数是一种阻塞函数，阻塞等待用户浏览器发起访问 client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die("accept"); /* accept_request(client_sock); */ // 通过 client_sock 调用 accept_request 函数对用户进行访问 // 在这个过程中，会解析用户浏览器发来的请求 if (pthread_create(&amp;newthread, NULL, (void*)accept_request, (void*)&amp;client_sock) != 0) perror("pthread_create"); &#125; // 关闭服务器套接字 close(server_sock); return 0;&#125; 以下是相关知识点简要说明： sockaddr_in是网络编程中的一种结构，在不同的环境中其定义也不一致。 in_addr是一个结构体，可以用来表示一个 32 位的 IPv4 地址。 accept函数是库函数，作用是通过套接字接受一个连接。 pthread_create这里，再着重说一下pthread_create函数，它是类 Unix 操作系统中创建线程的库函数（Linux 现在也有了）。功能是先将线程创建好，然后开始运行相关的线程函数。前面已经提到了需要对pthread_create函数的调用做一些修改：main12- if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)+ if (pthread_create(&amp;newthread , NULL, accept_request, &amp;client_sock) != 0) 实际上，在笔者的 Ubuntu 16.04 系统下，pthread_create函数的第三个参数需要一个返回空指针且参数为void *的函数指针（类型为void *(*)(void *)），所以需要修改accept_request函数的声明和定义；第四个参数则需要一个空指针（类型为void *），而这第四个参数实际上就是给函数指针指向的函数（也就是accept_request）使用的，之所以能直接传入client_sock的地址是因为笔者使用的 GCC 编译器会做隐式转换（implicit conversion），所以直接传指针即可，其他 C/C++ 系编译器会不会转换就不知道了。 startupstartup主要作用是用来启动服务，相关的注释已经写在对应位置：startup12345678910111213141516171819202122232425262728293031323334353637/**********************************************************************//* This function starts the process of listening for web connections * on a specified port. If the port is 0, then dynamically allocate a * port and modify the original port variable to reflect the actual * port. * Parameters: pointer to variable containing the port to connect on * Returns: the socket *//**********************************************************************/int startup(u_short *port) &#123; int httpd = 0; struct sockaddr_in name; // socket 函数会返回一个套接字 httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die("socket"); memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; // 协议族 name.sin_port = htons(*port); // 端口号 name.sin_addr.s_addr = htonl(INADDR_ANY); // IP 地址 // 绑定套接字 if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die("bind"); // 如果没有设置端口，就动态申请一个端口 if (*port == 0) /* if dynamically allocating a port */ &#123; int namelen = sizeof(name); // 利用 getsockname 函数来动态申请一个端口，这个端口会保存在结构体中 if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die("getsockname"); // 通过结构体的成员赋值给解引用的指针，利用指针改变原变量的值 *port = ntohs(name.sin_port); &#125; // 创建请求队列大小为 5 的监听队列 if (listen(httpd, 5) &lt; 0) error_die("listen"); return httpd;&#125; 从源码中可以发现，startup函数不仅创建好了套接字、端口，还开始进行监听了。虽然startup这个函数使用的系统 API 非常多，但结合注释也能大概知道功能是什么了。 accept_request这个函数是整个项目的关键函数，功能是接收客户端请求，并解析客户端发来的报文，再根据不同的方法和文件是否可执行来决定是否执行 CGI 程序。详细的注释请看下面的修改后源码：accept_request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/**********************************************************************//* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client *//**********************************************************************/void *accept_request(void *pclient) &#123; int client = *(int*)pclient; char buf[1024]; int numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL; // 利用 get_line 函数读取请求头的一行，返回字符串的长度 numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; // 截取出请求报文中的方法字符串 while(!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[j]; i++; j++; &#125; method[i] = '\0'; // strcasecmp 库函数，忽略大小写进行字符串比较，功能与 strcmp 函数类似 if(strcasecmp(method, "GET") &amp;&amp; strcasecmp(method, "POST")) &#123; // 整个测试程序只测试 GET 和 POST 方法，所以二者同时不满足条件时，说明是整个程序没有实现的方法 // 调用 unimplemented 函数向客户端直接发送异常页面 unimplemented(client); return NULL; // 因为修改了函数返回值，这里也加上 &#125; // 如果客户端发来的是 post 请求 if(strcasecmp(method, "POST") == 0) cgi = 1; // 将 cgi 标志置 1 // 重新使用 i 作为 url 字符数组的下标 i = 0; // 跳过请求报文中的空格 while(ISspace(buf[j]) &amp;&amp; (j &lt; sizeof(buf))) j++; // 解析出请求报文中的 url while(!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; sizeof(buf))) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = '\0'; // 如果客户端使用 GET 方法 // url 可能会带有 ?，且有查询参数 if(strcasecmp(method, "GET") == 0) &#123; query_string = url; while((*query_string != '?') &amp;&amp; (*query_string != '\0')) query_string++; if (*query_string == '?') &#123; // 如果 url 中有 ?，说明是查询请求，需要执行 CGI // 同时将这个字符串改为'\0'，并将 query_string 指针指向后面的字符串 cgi = 1; *query_string = '\0'; query_string++; &#125; &#125; // 资源路径设置为 htdocs/ sprintf(path, "htdocs%s", url); // 在路径后面加上具体的页面名称，现在路径是 htdocs/index.html，这个路径与此项目文件目录的结构一致 if(path[strlen(path) - 1] == '/') strcat(path, "index.html"); if(stat(path, &amp;st) == -1) &#123; // 如果无法按照路径获取到文件信息，说明文件不存在，此时的报文信息丢弃 // 并向浏览器发送 404 页面 while((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); not_found(client); &#125; else &#123; // stat(path, &amp;st) != -1，说明 path 是个目录 // 如果 path 是个目录，就将 path 改为 目录/index.html 这种文件路径的形式 if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, "/index.html"); if((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH)) // 如果文件可执行，当作 cgi 脚本执行 cgi = 1; if(!cgi) // 不执行 cgi 脚本，直接向客户端发送 HTML 文件 serve_file(client, path); else // 执行 cgi 脚本，此时要额外传入所使用的方法和查询字符串 execute_cgi(client, path, method, query_string); &#125; // 执行完毕，关闭套接字 close(client); return NULL; // 加上函数返回值&#125; 前面提到过需要修改index.html的文件权限，修改后这个文件的权限是-rw-------，可以发现只保留了用户对其的读写权限，没有可执行权限。为什么要这样改？可以从上面代码的 77 - 81 行发现答案，如果index.html文件可执行，那么就会被当作 CGI 脚本来执行，那这个文件就不会发送给客户端了。而且，从源码中还可以看出服务器解析客户端请求报文时，其实就是通过解析字符串来完成的。另外，前面还提到了需要在首行添加int client = *(int*)pclient;，之所以要添加这一句，其实就是尽可能的避免修改更多的代码，因为源码是直接使用client变量的。 get_lineget_line函数的功能与其名称一致，就是读取一行字符，以 CRLF 为结尾。可能会有人疑问为什么是 CRLF 为结尾的标志，因为这是 HTTP 协议规定的。下面是对应的注释和源码：get_line123456789101112131415161718192021222324252627282930313233343536373839404142434445/**********************************************************************//* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) *//**********************************************************************/int get_line(int sock, char *buf, int size) &#123; // CRLF == "\r\n" int i = 0; char c = '\0'; int n; while ((i &lt; size - 1) &amp;&amp; (c != '\n')) &#123; // 利用 recv 函数接受数据，长度为 1，用字符变量 c 来保存，recv 函数返回实际复制的字节数 n = recv(sock, &amp;c, 1, 0); /* DEBUG printf("%02X\n", c); */ if (n &gt; 0) &#123; if (c == '\r') &#123; // 读到换行符时 // 读取最后的回车符，但不删除输入流中的回车（MSG_PEEK 参数的意义） n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf("%02X\n", c); */ if ((n &gt; 0) &amp;&amp; (c == '\n')) // 如果是回车，就吃掉最后一个回车符 recv(sock, &amp;c, 1, 0); else c = '\n'; &#125; // 如果 c 不是'\r'或'\n' ，就放到缓存字符串中 buf[i] = c; i++; &#125; else c = '\n'; &#125; // 完成一行的读取，最后加上 C 字符串结束的标志 buf[i] = '\0'; return(i);&#125; 这个函数并不复杂，本质上就可以当作一个字符串相关的处理函数来理解。 not_found/bad_request/cannot_execute/headers/unimplementednot_found、bad_request、cannot_execute、headers和unimplemented这五个函数都很简单，只有一个功能就是向客户端发送信息，这里不细说了，直接看源码和对应注释即可：not_found1234567891011121314151617181920212223242526/**********************************************************************//* Give a client a 404 not found status message. *//**********************************************************************/void not_found(int client) &#123; // 与 unimplemented 函数类似，向客户端发送 404 页面 char buf[1024]; sprintf(buf, "HTTP/1.0 404 NOT FOUND\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "your request because the resource specified\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "is unavailable or nonexistent.\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/BODY&gt;&lt;/HTML&gt;\r\n"); send(client, buf, strlen(buf), 0);&#125; bad_request12345678910111213141516171819/**********************************************************************//* Inform the client that a request it has made has a problem. * Parameters: client socket *//**********************************************************************/void bad_request(int client) &#123; // 错误请求，向客户端发送 400 页面 char buf[1024]; sprintf(buf, "HTTP/1.0 400 BAD REQUEST\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "Content-type: text/html\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "&lt;P&gt;Your browser sent a bad request, "); send(client, buf, sizeof(buf), 0); sprintf(buf, "such as a POST without a Content-Length.\r\n"); send(client, buf, sizeof(buf), 0);&#125; cannot_execute1234567891011121314151617/**********************************************************************//* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. *//**********************************************************************/void cannot_execute(int client) &#123; // CGI 脚本无法执行，返回 500 页面 char buf[1024]; sprintf(buf, "HTTP/1.0 500 Internal Server Error\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;P&gt;Error prohibited CGI execution.\r\n"); send(client, buf, strlen(buf), 0);&#125; headers12345678910111213141516171819/**********************************************************************//* Return the informational HTTP headers about a file. *//* Parameters: the socket to print the headers on * the name of the file *//**********************************************************************/void headers(int client, const char *filename) &#123; // 向客户端发送响应报文头 char buf[1024]; (void)filename; /* could use filename to determine file type */ strcpy(buf, "HTTP/1.0 200 OK\r\n"); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); strcpy(buf, "\r\n"); send(client, buf, strlen(buf), 0);&#125; unimplemented12345678910111213141516171819202122232425262728/**********************************************************************//* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket *//**********************************************************************/void unimplemented(int client) &#123; // 字符串缓存 char buf[1024]; // 向客户端发送一个方法未实现的提示业面 // 先用 sprintf 函数向 buf 写入要输出的字符串 // 再用 send 函数通过套接字向客户端发送 sprintf(buf, "HTTP/1.0 501 Method Not Implemented\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/BODY&gt;&lt;/HTML&gt;\r\n"); send(client, buf, strlen(buf), 0);&#125; serve_fileserve_file函数用来向客户端发送文件，需要有客户端套接字和对应的文件路径作为参数。serve_file12345678910111213141516171819202122232425262728293031/**********************************************************************//* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve *//**********************************************************************/void serve_file(int client, const char *filename) &#123; FILE *resource = NULL; int numchars = 1; char buf[1024]; // 默认字符 buf[0] = 'A'; buf[1] = '\0'; // 与 accept_request 函数一样，丢弃剩余的报文信息 while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); // 用文件指针打开文件 resource = fopen(filename, "r"); if (resource == NULL) // 如果文件未找到，发送 404 页面 not_found(client); else &#123; // 先发送报文头 headers(client, filename); // 再发送 html 文件 cat(client, resource); &#125; // 关闭文件指针 fclose(resource);&#125; catcat函数的功能类似 Linux 中的cat命令，都是读取逐行读取文件，不过这里的cat函数需要逐行读取文件并发送给客户端。cat12345678910111213141516/**********************************************************************//* Put the entire contents of a file out on a socket. This function * is named after the UNIX "cat" command, because it might have been * easier just to do something like pipe, fork, and exec("cat"). * Parameters: the client socket descriptor * FILE pointer for the file to cat *//**********************************************************************/void cat(int client, FILE *resource) &#123; char buf[1024]; // 逐行读取 html 文件，并发送给客户端，读到 EOF 时，读取完毕，跳出循环 fgets(buf, sizeof(buf), resource); while (!feof(resource)) &#123; send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); &#125;&#125; execute_cgiexecute_cgi函数也是一个关键函数，具体功能是执行 CGI 程序，具体请看下面的源码和注释：execute_cgi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/**********************************************************************//* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script *//**********************************************************************/void execute_cgi(int client, const char *path, const char *method, const char *query_string) &#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; // 默认字符 buf[0] = 'A'; buf[1] = '\0'; if(strcasecmp(method, "GET") == 0) // 如果客户端的请求是 GET 方法，忽略掉剩余的报文 while((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); else &#123; /* POST */ // 如果是 POST 方法，逐行读取获取 content_length numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) &#123; // 加上字符串结束符，便于使用 strcasecmp 函数 buf[15] = '\0'; if(strcasecmp(buf, "Content-Length:") == 0) content_length = atoi(&amp;(buf[16])); numchars = get_line(client, buf, sizeof(buf)); &#125; // 错误请求 if(content_length == -1) &#123; bad_request(client); return; // 直接返回 &#125; &#125; // 成功读取请求后，向客户端发送请求成功报文 // 不管 GET 还是 POST，都需要 sprintf(buf, "HTTP/1.0 200 OK\r\n"); send(client, buf, strlen(buf), 0); // 创建 2 个管道 // pipe 函数会建立管道 // 默认数组的第一个元素是读入端，第二个元素是写入端 // cgi_output[0] 是读入端，cgi_output[1] 是写入端 if(pipe(cgi_output) &lt; 0) &#123; cannot_execute(client); return; &#125; // cgi_input[0] 是读入端，cgi_input[1] 是写入端 if(pipe(cgi_input) &lt; 0) &#123; cannot_execute(client); return; &#125; // 创建子进程 // fork 函数在子进程中返回 0 // 在父进程中返回子进程的 id // 当返回负数时，表示子进程创建失败 if((pid = fork()) &lt; 0 ) &#123; cannot_execute(client); return; &#125; if(pid == 0) &#123; /* child: CGI script */ // 子进程运行 CGI 脚本，利用管道接受从父进程发来的客户端的请求 char meth_env[255]; char query_env[255]; char length_env[255]; // 把 stdout 重定向到 cgi_output[1] 写入端 // 对于子进程而言，这是写入端，但对父进程而言，这是读入端 // 也就是说子进程向 cgi_output[1] 写入内容 // 父进程从 cgi_output[0] 读取内容 dup2(cgi_output[1], 1); // 把 stdin 重定向到 cgi_input[0] 读入端 // 对于子进程而言，这是读入端，但对父进程而言，这是写入端 // 也就是说父进程向 cgi_input[1] 写入内容 // 子进程从 cgi_input[0] 读取内容 dup2(cgi_input[0], 0); // 以上两个管道的两个通道，都是子进程在使用 // 下面两个管道的通道要留给父进程使用，在子进程中关闭掉 // 分别是管道 cgi_output 的读入端和管道 cgi_input 的写入端 close(cgi_output[0]); close(cgi_input[1]); sprintf(meth_env, "REQUEST_METHOD=%s", method); // 设置环境变量 // 注意：设置的环境仅对程序本身有效。你在程序里做的改变不会 // 反映到外部环境中，这是因为变量的值不会从子进程传播到父 // 进程，这样做更安全。 putenv(meth_env); if(strcasecmp(method, "GET") == 0) &#123; // GET 方法对应 query_string sprintf(query_env, "QUERY_STRING=%s", query_string); putenv(query_env); &#125; else &#123; /* POST */ // POST 方法对应 content_length sprintf(length_env, "CONTENT_LENGTH=%d", content_length); putenv(length_env); &#125; // 执行对应的 CGI 脚本 execl(path, path, NULL); exit(0); &#125; else &#123; /* parent */ // 父进程先读取客户端请求，再通过管道发给子进程 // 子进程运行 CGI 脚本得到的结果也通过管道发给父进程 // 父进程再发给客户端 // 关闭子进程所使用的管道通道 close(cgi_output[1]); close(cgi_input[0]); if(strcasecmp(method, "POST") == 0) for(i = 0; i &lt; content_length; i++) &#123; // 从客户端接收请求报文 recv(client, &amp;c, 1, 0); // 父进程通过管道向子进程写入从客户端接收的报文 write(cgi_input[1], &amp;c, 1); &#125; // 父进程通过管道读取子进程写入管道的信息 while(read(cgi_output[0], &amp;c, 1) &gt; 0) // 然后依次发送给客户端 send(client, &amp;c, 1, 0); // 关闭父进程使用的管道通道 close(cgi_output[0]); close(cgi_input[1]); // 等待子进程运行结束 waitpid(pid, &amp;status, 0); &#125;&#125; 这个函数的难点在于对父子进程之间管道通信的理解，单纯读注释可能会被绕晕，这里引用别人 blog 的一张图，结合下面这张图应该会清楚一些。 summary现在回过头来，可以发现服务器的工作流程其实很简单： 启动本地服务 接收并分析客户端请求 执行对应 CGI 程序 发送 CGI 程序执行结果给客户端 关闭套接字 也就是下面这张图： 实际上，如果单纯是针对 tinyhttpd 这个小项目而言，下面这张图会更细节一点： 同样的，tinyhttpd 项目所设计的函数也可以按功能分类： 最后，不得不感叹，麻雀虽小，但是依然五脏俱全~ 参考内容：1. EZLippi/Tinyhttpd2. HTTP服务器的本质:tinyhttpd源码分析及拓展3. Tinyhttpd精读解析]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>TinyHttpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_类的简单构造案例]]></title>
    <url>%2F2023%2F02%2F12%2FC-%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%84%E9%80%A0%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[这篇文章主要是介绍用 C++ 实现的一个简单数学类——分数类，其中包含了对应的基本运算规则。 前言学习完 C++ 关于类的部分后，很想自己动手写一写，所以这里尝试自己用 C++ 的语言写一个简单的类。 类的定义首先完成类的定义，先考虑分数的组成——分子和分母，这里为了数据处理时方便，简单认为分子和分母都是有符号整数，数据类型就用int。12345class Fraction &#123;private: int numerator; int denominator;&#125;; 类的功能设计好类的定义后，接下来要考虑的就是类的功能函数了。按照三五法则，必须要为这个类提供拷贝构造函数、拷贝复制运算符和析构函数。同时，因为要求包含基本运算规则，所以必须要完成对应四个运算符的重载等功能。 构造函数这里提供一个有参构造函数，注意在 C++ 中，如果提供了构造函数，编译器就不再提供默认构造函数了，但可以通过default关键字继续使用由编译器提供的默认构造函数。此时Fraction.h文件的内容为：123456789class Fraction &#123;public: Fraction() = default; Fraction(int up, int down); ~Fraction() = default;private: int numerator; int denominator;&#125;; 类的默认构造函数使用编译器自动生成，有参构造函数的定义放在Fraction.cpp文件中：1Fraction::Fraction(int up, int down): numerator(up), denominator(down) &#123;&#125; 有参构造函数直接使用constructor initialize list来完成定义。 析构函数因为数据结构很简单，直接使用编译器默认生成的析构函数，直接添加到Fraction.h文件中即可。123456789class Fraction &#123;public: Fraction() = default; Fraction(int up, int down); ~Fraction() = default;private: int numerator; int denominator;&#125;; 拷贝构造函数顾名思义，拷贝构造函数的功能就是拷贝原来的对象，并按照原来的对象构造一个新对象，所以拷贝构造函数的定义可以写成下面这种形式：1234Fraction::Fraction(const Fraction &amp;f) &#123; numerator = f.numerator; denominator = f.denominator;&#125; 注意这里使用了const和&amp;，使用const是因为不对原对象做修改，而使用&amp;是因为拷贝构造函数还有定义出来，如果不用&amp;，编译器会默认调用这个对象的拷贝构造函数来复制这个形参。 C++ 中拷贝构造函数的调用时机：使用一个已经创建完毕的对象初始化一个新对象。值传递的方式给函数参数形参。以值方式返回局部对象。 拷贝赋值运算符在 C++ 中，运算符本质上也是函数，重载运算符就是在重新定义函数，而拷贝赋值运算符就是重载赋值运算符。12345Fraction::Fraction&amp; operator=(const Fraction &amp;fra) &#123; numerator = fra.numerator; denominator = fra.denominator; return *this;&#125; 注意这里的细节： 为了实现a = b = c;这样的效果（也就是链式编程法则），需要返回自身的引用。 形参的类型是常量引用，一方面是避免拷贝和修改形参，另一方面无论形参的类型是常量还是非常量都是可以使用的。 返回自身是通过this指针完成的。 重载 &lt;&lt; 运算符为了便于输出，需要先重载&lt;&lt;运算符。重载&lt;&lt;运算符时，可以用成员函数的形式重载，也可以用全局函数的形式重载。利用成员函数重载&lt;&lt;运算符，最后得到的效果是f &lt;&lt; cout;，但我们想要的效果是cout &lt;&lt; f;，而后一种结果可以通过全局函数的形式重载得到。由于前面将类的数据成员定义为私有属性，而全局函数为了能访问到类的私有成员，需要将该全局函数声明为类的友元函数，所以需要在fraction.h头文件中，加入友元函数声明：1friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, Fraction &amp;f); 将该函数的定义放到test.cpp中：1234ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; out &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator; return out;&#125; 注意，这里假定输出分数的形式类似于1/2。 定义好后面的计算运算符后，发现可能存在分数为 0、负、假分数和整数的情况，这时输出格式会有一些变化： 若为负分数，先输出负号，在输出分数，如-1/2 若为 0，直接输出0 若为假分数，先输出整数，在输出分数，如3 1/2表示三又二分之一 若为整数，直接输出整数值，如2/2，输出1 12345678910ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; f.reduction(); if(f.denominator == 1) cout &lt;&lt; f.numerator; else if(abs(f.numerator) &gt; f.denominator) cout &lt;&lt; f.numerator / f.denominator &lt;&lt; f.numerator % f.denominator &lt;&lt; '/' &lt;&lt; f.denominator; else cout &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator;&#125; 重载 &gt;&gt; 运算符同理&lt;&lt;运算符的思路，假定输入两个整数分别代表分子和分母。1friend std::istream&amp; operator&gt;&gt;(std::istream &amp;in, Fraction &amp;f); 1234istream&amp; operator&gt;&gt;(istream &amp;in, Fraction &amp;f) &#123; in &gt;&gt; f.numerator &gt;&gt; f.denominator; return in;&#125; 重载 == 运算符为了方便比较两个函数相等，顺便把==运算符也重载了，判断逻辑也很简单，默认所有的分数都是最简形式的，只要分子分母同时相等就是相等的分数。12345bool operator==(const Fraction &amp;fra) &#123; if(numerator == fra.numerator &amp;&amp; denominator == fra.denominator) return true; else return false;&#125; ==运算符重载完成后，可以直接用来重载!=运算符。 功能函数在设计分数的运算规则之前，需要先准备好一些功能函数来便于计算。 最小公约数这个函数定义的声明放在function.h文件中，定义放在对应的function.cpp中，使用辗转相除法的思路计算最大公约数。1234long long gcd(int a, int b) &#123; if(b == 0) return a; else return gcd(b, a % b);&#125; 绝对值函数这个函数定义的声明放在function.h文件中，定义放在对应的function.cpp中，功能是返回int型变量的绝对值。123int abs(int a) &#123; return a &gt; 0 ? a : -a;&#125; 化简函数当分母与分子可以约分时，要化为最简分数。考虑到特殊情况，如果分子为 0，就让分母为 1。12345678910111213void Fraction::reduction() &#123; if(denominator &lt; 0) &#123; numerator = -numerator; denominator = -denominator; &#125; if(numerator == 0) &#123; denominator = 1; &#125; else &#123; int d = gcd(abs(numerator), abs(denominator)); numerator /= d; denominator /= d; &#125;&#125; 重载 + 运算符分数的加法有点麻烦，需要先通分，计算后，再约分。不过，我们已经把化简的过程独立出来了，所以直接计算，然后再调用化简函数即可。1234567Fraction Fraction::operator+(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator + fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; 接下来，如法炮制其他运算符。 重载 - 运算符1234567Fraction Fraction::operator-(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator - fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; 重载 * 运算符1234567Fraction Fraction::operator*(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.numerator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; 重载 / 运算符1234567Fraction Fraction::operator/(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator; res.denominator = denominator * fra.numerator; res.reduction(); return res;&#125; 总结尽管是个简单的案例，但其中涉及了很多 C++ 的基础知识点。最后贴出所有文件（其实一共也就五个文件😂）的代码：fraction.h1234567891011121314151617181920212223#pragma once#include &lt;iostream&gt;class Fraction &#123;public: friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, Fraction &amp;f); friend std::istream&amp; operator&gt;&gt;(std::istream &amp;in, Fraction &amp;f); Fraction() = default; Fraction(int up, int down); Fraction(const Fraction &amp;fra); Fraction operator=(const Fraction &amp;fra); bool operator==(const Fraction &amp;fra); Fraction operator+(const Fraction &amp;fra); Fraction operator-(const Fraction &amp;fra); Fraction operator*(const Fraction &amp;fra); Fraction operator/(const Fraction &amp;fra); ~Fraction() = default;private: int numerator; int denominator; void reduction();&#125;; fraction.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include "fraction.h"#include "function.h"Fraction::Fraction(int up, int down): numerator(up), denominator(down)&#123;&#125;Fraction::Fraction(const Fraction &amp;f) &#123; numerator = f.numerator; denominator = f.denominator;&#125;Fraction Fraction::operator=(const Fraction &amp;fra) &#123; numerator = fra.numerator; denominator = fra.denominator; return *this;&#125;bool Fraction::operator==(const Fraction &amp;fra) &#123; if(numerator == fra.numerator &amp;&amp; denominator == fra.denominator) return true; else return false;&#125;void Fraction::reduction() &#123; if(denominator &lt; 0) &#123; numerator = -numerator; denominator = -denominator; &#125; if(numerator == 0) &#123; denominator = 1; &#125; else &#123; int d = gcd(abs(numerator), abs(denominator)); numerator /= d; denominator /= d; &#125;&#125;Fraction Fraction::operator+(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator + fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator-(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator - fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator*(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.numerator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator/(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator; res.denominator = denominator * fra.numerator; res.reduction(); return res;&#125; function.h1234#pragma oncelong long gcd(int a, int b);int abs(int a); function.cpp12345678long long gcd(int a, int b) &#123; if(b == 0) return a; else return gcd(b, a % b);&#125;int abs(int a) &#123; return a &gt; 0 ? a : -a;&#125; test.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include "fraction.h"using namespace std;ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; f.reduction(); if(f.denominator == 1) cout &lt;&lt; f.numerator; else if(abs(f.numerator) &gt; f.denominator) cout &lt;&lt; f.numerator / f.denominator &lt;&lt; ' ' &lt;&lt; f.numerator % f.denominator &lt;&lt; '/' &lt;&lt; f.denominator; else cout &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator; return out;&#125;istream&amp; operator&gt;&gt;(istream &amp;in, Fraction &amp;f) &#123; in &gt;&gt; f.numerator &gt;&gt; f.denominator; return in;&#125;int main() &#123; Fraction a, b, res; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; if(a == b) cout &lt;&lt; "a = b" &lt;&lt; endl; else cout &lt;&lt; "a != b" &lt;&lt; endl; /* 这里需要用 res 接收计算结果，如果直接写成 cout &lt;&lt; a + b &lt;&lt; endl; 会存在与 &lt;&lt; 的优先级问题，从而得不到正确的结果。当然，也可以写成 cout &lt;&lt; (a + b) &lt;&lt; endl; */ res = a + b; cout &lt;&lt; res &lt;&lt; endl; res = a - b; cout &lt;&lt; res &lt;&lt; endl; res = a * b; cout &lt;&lt; res &lt;&lt; endl; res = a / b; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_01_月总结]]></title>
    <url>%2F2023%2F02%2F12%2F2023-01-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[要过年啦~ Every Breath You Take - The PoliceYour browser does not support the audio tag. 一月初，刚刚阳康就重新回到公司上班了。尽管对工作还不熟悉，但是身体已经逐渐适应了上班的节奏。十二月下旬做好的工作，也在一月初“投产”了，这是年前最后的事情了。忙完这个事情之后，就可以平静的等待过年了。提到过年，就不免得要买票，而买票又是个麻烦事。回去得买回家的票，回来得买返程的票，一旦没抢到就得考虑其他的交通方式，其实也不外乎就是换乘而已。不管怎么选择，总是很折腾人，这大概也是漂泊在外的游子心酸的沧海一粟了吧，不提也罢。 今年回家后，父母没有向往年一样“灌输”一些理念，取而代之的是轻松的谈话。与此对应，我也不再妄想改变他们的想法了，因为他们本该如此...另外，整个过年期间都在家里待着，哪里都没有去，哈哈，不得不说，还是在家里好。 可惜，时间过得很快，初六自己就踏上了返程，心里虽然有些许不舍，但也不能停止自己的脚步——初七上班啦！ 新的一年到来了，暂时没有想好这一年要做些什么样的事情，不过希望自己感兴趣的领域都能有所增强吧，比如：弹琴技巧、编程功底、阅读广度等等，哈哈。 对了，值得一提的是，这次春节假期读完了《乡土中国》，收获挺多，但是不懂的地方也有很多，自己果然还是无知啊~没事，下次重读的时候应该会有更多收获了。 最后，希望我的家人、朋友们都能身体健康！]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_年末小结]]></title>
    <url>%2F2023%2F01%2F02%2F2022-%E5%B9%B4%E6%9C%AB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知不觉，2022 已经过去了... 我想要的感觉 - 张震岳Your browser does not support the audio tag. 今天是 2023 年的第二天，也是元旦假期的最后一天。本来这篇文章应该在 2022 的最末写出来的，可是自己好像又偷懒了，哈哈。突然想到了上初中的自己，每逢周末，先玩再说，等到周末的下午才开始处理周末的家庭作业，现在的情况好像如出一辙~🤣但是不管怎么说，这件事情还是要做呀！ 好了，回想一下今年在干什么吧。 1 - 2 月这是去年过年的时候了，我还在家自己琢磨自己的世界。临近过年，也帮家里办了一些年货。不过，最辛苦应该是母亲了，先是回了一趟老家，安排了一下过年的事情，然后又赶到 SY，照顾来年要高考的妹妹。过年的事情就很简单了，年夜饭是我烧的，老、中、青三代人一起坐着吃了顿团年饭，谈的事情依然是关于我的事情，呵呵，这些已经习以为常了，放在心里就好。意料之中（之所以这么说，后面会提到）的是小时候一起长大的表哥竟然在我家待了好几天，有次吃饭竟然还喝高吐了，饭桌上，也向我、我父亲表达了他自己的压力。是啊，他一晃 28 了，还没结婚，心里压力很大。我也试着安慰他，你女朋友从高中谈到现在工作，一起过了都好几年了，老夫老妻了，还怕不能结婚？结果他只是摇摇头，简单说了句结婚要房啊。后来又聊到了他的父母，在酒精的作用下，他也不在控制自己的情感，洒下了几滴热泪...也许是自己一事无成对父母的愧疚吧。后面又去了其他亲戚家里吃饭，自己突然发现，好像感觉都不一样了。 3 - 4 月这两个月是自己准备找工作的时间，第一件事就是巩固自己的算法能力，其实是试试自己的脑子是不是还是转的动，结果发现，还是转的动的😂。另外在这个时间写了很多和算法题相关的 blog，这些可以在归档页面看，自己也确实收获了一些东西。尽管这时我的时间大部分都花在写代码上，但是让我印象最深刻的事情是写了几个小时的代码后，一个人在田野上溜达，看看身边的稻田和小河，突然意识到原来世界上还有其他的生物啊。 4 - 5 月这两个月在疯狂练琴，哈哈，二手淘了本《民谣吉他考级教程》，练了好几首上面的歌，一级一级的，最后把《普通朋友》的百分之七十拿下了。这期间对民谣吉他的弹唱技巧、和弦理论收获很多，但是感觉还很不够。当然了，自己还是依然写代码，偶尔还跑去钓钓鱼，守在河边一下午，等到傍晚提起鱼篓，看着蹦蹦跳跳的鱼儿，心里甭提有多欢乐了🤣~ 6 月本来打算去朋友小 z 所在的城市找工作，但是因为疫情关系，封城了，计划搁浅，索性继续过自己的生活，天天弹琴、打码，倒也过的消遣。 7 - 8 月妹妹高考顺利结束，因为填写志愿的关系，需要我去一趟，本来母亲和父亲已经过去了，但是跟妹妹的沟通好像无法顺利进行，索性我就过去了。到了之后，又久违的吃到了母亲做的🐟，真香~跟妹妹好好聊了三天后，志愿的事情结束了，接下来就是等待录取结果了。父亲和母亲也都回到自己的工作上去了，剩下我跟妹妹两个人。本来以为会过几天消遣日子，结果牙疼又找上门了。折腾几天都没休息好，去医院之后才知道是急性牙髓炎，又是吃药，又是根管治疗，花掉三千块钱，耗时二十多天，终于算是结束了...后来，录取结果出来后就收拾东西回老家了，这时才意识到，这是家里四个人最后一次一起齐聚 SY 这个城市了。回到老家后，又急匆匆的办完了升学宴，虽然很累，但是事情都顺利解决了。 9 - 11 月九月是开学的日子，也是我又大一岁的月份。妹妹的大学开学后，送妹妹去学校的时候去了一趟 WH。完事之后，又去了一趟黄鹤楼，领略了一下“现代美景”。回到家后，又开始思忖自己找工作的事情了，想着趁着秋招，出来找工作吧。10 月 11 日出门了，又花了 1 个月时间，终于找到了一份工作😂。 12 月整体而言，十二月是充满工作和学习的一个月。月初时，每天早上得六点多起来，坐上一个多小时的地铁，再骑 20 分钟的车，才能到达工作地点，每天都很忙碌的奔波在工作地点和住的地方之间。到了月中，被新冠给上身了，直接居家半个月了😂，目前算是熬过来了，准备明天上班了哈哈。 回头看看，今年好像什么事情也没有做，没有具体的清单列出自己做的事情，好像还真的感觉是在空度光阴呢。不过，仔细一想，不是自己没有做什么，而在于短期之内，这些东西还没办法显现出来，所以，沉住气吧~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_05]]></title>
    <url>%2F2022%2F12%2F26%2FNand2Tetris-Part1-05%2F</url>
    <content type="text"><![CDATA[这周好像要开始讲具体的计算机结构了... Unit 5.1 Von Neumann Architecture这节课的标题是冯诺依曼结构，实际上讲到了 3 个概念：数据总线（data bus）、地址总线（address bus）和控制总线（control bus）。这些总线就是计算机内部信息的公路，比特流在这些总线上流动，不同功能的比特流在不同的总线上流动。计算机的硬件设备，如内存、CPU等都连接在这些总线上，时不时的读入信息和输出信息。 Unit 5.2 The Fetch-Execute Cycle这节课主要在讲解提取-执行周期（Fetch-Execute Cycle）的大致过程。按照前面的思路，程序的数据和控制指令都保存在一块内存芯片中，那 CPU 是如何知道什么时候该执行那条指令，如何去分辨控制指令和数据呢？ 实际上，CPU 有一个叫做 Program Counter 的程序寄存器来专门记录内存中保存指令的地址，数据地址和指令地址（Program Counter）中保存比特的一同流入 Multiplexor 中，而这个多路复用器用一位控制位来区分现在是提取（Fetch）周期还是执行（Execute）周期。如果是提取模式，那么就读取指令地址，将具体的指令加载到 CPU 中；如果是执行周期，就读取数据地址，将具体的数据加载到 CPU 中用于执行。 Unit 5.3 Central Processing Unit这节课的主要内容是 CPU 的内部结构、功能和对应的实现原理，讲的不是很深入。CPU 实际上就是 ALU 和其他寄存器的组合体，与计算相关的功能是由 ALU 实现的，过程控制是由 ALU 和其他寄存器组合完成的。老师用上周讲的 A 指令和 C 指令举例，说明了 CPU 是如何识别这些指令，如何实现这些指令的功能，这里就不具体展开了。 Unit 5.4 The Hack Computer这节课主要在讲 Hack Computer 的结构：一块 CPU、一个 ROM32K 的外存、一块内存，再加键盘和屏幕两个 I/O 设备。接着老师又分开讲解了每部分硬件的构成原理，不过讲的不是很深入，与前面提到的差不多，毕竟这一周的任务就是做这些东西。 Unit 5.5 Project Overview这周主要实现 3 个硬件设备，而这些设备就是上一周用到的设备。 Memory第一个实现的设备是 Memory，实现过程真是一言难尽，明明是相对容易的问题，却想了很久，最后才意识到是自己有些基础概念（或者说默认规则）没理解清楚，导致做不出来，查资料纠正过来后，就迎刃而解了。但话说回来，能这样一步步做到第五周也是没谁了😅...不多说了，进入正题。Memory 的实现相对比较简单，参考资料已经给了很详细的提示——参考第三周构造内存芯片的思路完成。按照提示的思路，完成 Memory 需要使用 RAM16K、Screen 和 Keyboard 这三个主要芯片，然后再加上其他若干芯片。此时，已知的内容是 Memory 的地址范围在$[0, 24576]$，并且分别对应着内存、显示器和键盘的地址范围，即：1230x0000 - 0x3FFFF -&gt; 0000 .... 0000 - 0111 .... 1111 -&gt; Ram0x4000 - 0x5FFFF -&gt; 0010 .... 0000 - 0101 .... 1111 -&gt; Screen0x6000 -&gt; 1100 .... 0000 -&gt; Keyboard 结合实现 RAM16K 的思路，实现 Memory 也需要使用一个 DMux4Way 将输入的地址区分开，然后将特定的管脚连接到特定的芯片上即可，最后再用 Mux4Way16 输出即可，整体思路还算是比较简单的。因为已经知道 RAM16K 是 14 位寻址的，Screen 是 13 位寻址的，Keyboard 就一个地址，而 Memory 的 address 是 15 位的，所以可以很自然的想到用 address 的前两位来作为 DMux4Way 的 sel bits，这样就可以区分出地址了。但是，在选择管脚作为 sel bits 和连接管脚的时候，我没有搞清楚在 hdl 语言中比特流到底是怎么流动的，导致我无论怎么操作管脚都是错误的...（虽然按照错误思路编写好的 hdl 能跑完和内存相关的部分脚本）具体而言，以一条 A 指令为例：1234567891011121314 指令 对应的比特流 流入机器的顺序（与人正好相反）@3001 -&gt; 000101110111001 -&gt; 100111011101000之前理解的比特流在 hdl 中的顺序v[0] v[1] v[2] v[3] ... v[13] v[14] 0 0 0 1 ... 0 1 实际比特流在 hdl 中的顺序v[0] v[1] v[2] v[3] ... v[13] v[14] 1 0 0 1 ... 0 0 所以，在 hdl 中，选取头两位作为 sel bits，就应该选取 v[13] 和 v[14] 而不是 v[0] 和 v[1]，同时可以发现，实际顺序中的 0 - 14 也确实代表着进入到计算机内的比特流顺序，也说明这样表示是科学的。PS：这里其实可以深入扩展一下 MSB 和 LSB 的概念。 最后，贴出正确的实现代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/Memory.hdl/** * The complete address space of the Hack computer&apos;s memory, * including RAM and memory-mapped I/O. * The chip facilitates read and write operations, as follows: * Read: out(t) = Memory[address(t)](t) * Write: if load(t-1) then Memory[address(t-1)](t) = in(t-1) * In words: the chip always outputs the value stored at the memory * location specified by address. If load==1, the in value is loaded * into the memory location specified by address. This value becomes * available through the out output from the next time step onward. * Address space rules: * Only the upper 16K+8K+1 words of the Memory chip are used. * Access to address&gt;0x6000 is invalid. Access to any address in * the range 0x4000-0x5FFF results in accessing the screen memory * map. Access to address 0x6000 results in accessing the keyboard * memory map. The behavior in these addresses is described in the * Screen and Keyboard chip specifications given in the book. *//* 0x0000 - 0x3FFFF -&gt; 0000 .... 0000 - 0111 .... 1111 -&gt; Ram 0x4000 - 0x5FFFF -&gt; 0010 .... 0000 - 0101 .... 1111 -&gt; Screen 0x6000 -&gt; 1100 .... 0000 -&gt; Keyboard*/CHIP Memory &#123; IN in[16], load, address[15]; OUT out[16]; PARTS: // Put your code here: DMux4Way(in=load, sel=address[13..14], a=load0, b=load1, c=loadsrc, d=loadkb); Or(a=load0, b=load1, out=loadram); RAM16K(in=in, load=loadram, address=address[0..13], out=uram); Screen(in=in, load=loadsrc, address=address[0..12], out=usrc); Keyboard(out=ukb); Mux4Way16(a=uram, b=uram, c=usrc, d=ukb, sel=address[13..14], out=out);&#125; 另外，还有一点，Memory 的测试脚本在执行到测试 Keyboard 的时候，需要在软件上切换成键盘输入，具体的操作方法（Stackoverflow 论坛上的方法）： To anyone facing the same problem… on the Hardware Simulator user interface, right above where you see the script executing the tests, there are three drop down boxes. The one furthest to the right which is labeled “View” is probably currently set to “Script.” Click the drop down and select “Screen,” and you will see an interface that has a keyboard icon. Click it and then hit the corresponding key to complete the test. CPU第二个实现的是 CPU，花了我半个月的时间，总算是大致理解了设计原理，而且还是参考别人的做法...想要完整的设计出 CPU，首先必须要搞明白老师课上给的设计图： 这张图清楚的标出了 bits 在 Hack-CPU 中的流动，并指出了在特定 control bit 位置时所使用的芯片，所以需要我们做的事情就是搞清楚这些 control bit 是什么和并合理使用它们得到想要的输出。 从图中可以看到，整个 CPU 一共有 4 个输出，分别是：outM、writeM、addressM 和 pc，还有 3 个输入，分别是：instruction、inM 和 reset，这些名词的含义可以直接从hdl文件中得到：123456789inM[16], // M value input (M = contents of RAM[A])instruction[16], // Instruction for executionreset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0).outM[16], // M value outputwriteM, // Write to M? addressM[15], // Address in data memory (of M)pc[15]; // address of next instruction 按照课程中老师讲解的思路，我们可以先实现与 ALU 相关的内容： 为了方便表示和使用，提前一次性将 C 指令的各个 bit 全部提取出来：12345678910111213141516// C-insAnd(a=instruction[15], b=instruction[12], out=ca); // aAnd(a=instruction[15], b=instruction[11], out=c1); // c1And(a=instruction[15], b=instruction[10], out=c2); // c2And(a=instruction[15], b=instruction[9], out=c3); // c3And(a=instruction[15], b=instruction[8], out=c4); // c4And(a=instruction[15], b=instruction[7], out=c5); // c5And(a=instruction[15], b=instruction[6], out=c6); // c6And(a=instruction[15], b=instruction[5], out=d1); // d1And(a=instruction[15], b=instruction[4], out=d2); // d2And(a=instruction[15], b=instruction[3], out=d3); // d3And(a=instruction[15], b=instruction[2], out=j1); // j1And(a=instruction[15], b=instruction[1], out=j2); // j2And(a=instruction[15], b=instruction[0], out=j3); // j3 ARegister and inM这里我们按照 instruction 和 inM 从左至右的方向进行实现，首先实现的是与 ARegister 相关的内容。按照图示，指令（instruction）刚进入到 CPU 时，就会有一个 control bit 用来区分是 A 指令还是 C 指令，此时图示是使用一个 Mux16 来完成的。而对于 A/C 指令的区分，通过第四章的知识可知指令的首位为 0 即为 A 指令，为 1 则为 C 指令，所以直接按照首位 bit 进行区分即可。 但仔细看图可以发现，图上还有一个 ALU output 也指向这里，这是为什么？实际上这是因为经过 ALU 计算后的 C 指令也有可能会访问 ARegister，这还是第四章的知识，具体参考下面的表格： 所以需要先用 Mux16 将 instruction 和 ALUout 多路复用，而在到达 ARegister 后，又出现了一个 control bit，此时为了将区分这两种情况的 bit 位组合起来，需要使用一个 Mux 来实现。同时，观察到图示上 ARegister 的 output 也指向了 addressM，这也就是说 ARegister 与 Memory 是对应的，而我们已经知道了 Memory 的地址是 15 位的，所以 ARegister 的前 15 位就是 addressM。综上，与 ARegister 相关的内容，可以设计为：ARegister123456// instruction[15]: 0 -&gt; A, 1 -&gt; CMux16(a=instruction, b=ALUout, sel=instruction[15], out=uins);// ARegisterMux(a=true, b=instruction[5], sel=instruction[15], out=insA); // ALUout -&gt; A RegisterARegister(in=uins, load=insA, out[0..14]=addressM, out=uAreg); 再接着朝右走，ARegister 的 output 会和 inM 一起进入 Mux16，也即：inM12// inMMux16(a=uAreg, b=inM, sel=ca, out=u1); 之所以这里会用到 Mux16，是因为只有 C 指令的 a bit 才能区分这条 C 指令是操作 M 寄存器的，反之就是 A 指令了。 DRegister and writeM继续观察设计图，ALU 的输入一共有两个，已经解决了一个，还有一个 DRegister 需要解决。相比 ARegister 而言，DRegister 就简单多了，只有一个输入就是 ALU output，同样按照第四章的知识： 所以我们只需要讨论对应指令的 d2 位即可：DRegister12// DRegisterDRegister(in=ALUout, load=d2, out=uDreg); 同时，我们也可以发现只有当 d3 为 1 时，才会写入 M 寄存器，也就是 writeM 才会是 1：writeM12// writeMAnd(a=instruction[15], b=d3, out=writeM); 这里可能会有人疑问为什么是 C 指令的 d2 和 d3 位，实际上书的第四章已经解释了： ALU解决了 ALU 的输入问题，现在再考虑如何使用 ALU 来完成计算。ALU 的接口直接参考书上的图示： 除了两个输入，还有 6 个控制位需要解决，而这 6 个控制位正好对应的就是 C 指令的 comp bits： 同时，从上面的指令图中也可以看出 ALU 的 x 一定是 DRegister 的输出，y 一定是 ARegister 的输出和 inM 中的一个，比如下面这条指令： 所以 ALU 可以设计为：ALU12// ALUALU(x=uDreg, y=u1, zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6, out=ALUout, out=outM, zr=zr, ng=ng); C-JUMP by PC最后要实现的功能是 C 指令的跳转功能，这部分功能是通过 PC 来实现的，但是否跳转取决于 C 指令的 jump field： 根据 ALU 输出的 zr 和 ng 刚好可以判断 output 的大小：zr and ng1234567// PCNot(in=zr, out=notzr);Not(in=ng, out=notng);And(a=notzr, b=ng, out=negative); // ALUout &lt; 0And(a=zr, b=notng, out=zero); // ALUout = 0And(a=notzr, b=notng, out=positive); // ALUout &gt; 0 接下来，再来逐一实现跳转功能：JUMP12345678910// JUMPAnd(a=j3, b=positive, out=JGT); // JGTAnd(a=j2, b=zero, out=JEQ); // JEQAnd(a=j1, b=negative, out=JLT); // JLTAnd(a=j1, b=j2, out=tmp);And(a=tmp, b=j3, out=JMP); // JMP + JNE + nullOr(a=JGT, b=JEQ, out=jmp1); // JGT + JEQ + JGE, 3 possibilitiesOr(a=jmp1, b=JLT, out=jmp2); // jmp1 + JLT + JLE, 5 possibilitiesOr(a=jmp2, b=JMP, out=jmp3); // jmp2 + JMP + JNE + null, 8 possibilities 考虑到 PC 还有一个自增的功能，当指令为 A 指令时，不进行跳转，PC 自增：increment12And(a=instruction[15], b=jmp3, out=load); // not C-insNot(in=load, out=inc); // increment 最后写入 PC 中：PC1PC(in=uAreg, inc=inc, load=load, reset=reset, out[0..14]=pc); CPU_CodesCPU123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/CPU.hdl/** * The Hack CPU (Central Processing unit), consisting of an ALU, * two registers named A and D, and a program counter named PC. * The CPU is designed to fetch and execute instructions written in * the Hack machine language. In particular, functions as follows: * Executes the inputted instruction according to the Hack machine * language specification. The D and A in the language specification * refer to CPU-resident registers, while M refers to the external * memory location addressed by A, i.e. to Memory[A]. The inM input * holds the value of this location. If the current instruction needs * to write a value to M, the value is placed in outM, the address * of the target location is placed in the addressM output, and the * writeM control bit is asserted. (When writeM==0, any value may * appear in outM). The outM and writeM outputs are combinational: * they are affected instantaneously by the execution of the current * instruction. The addressM and pc outputs are clocked: although they * are affected by the execution of the current instruction, they commit * to their new values only in the next time step. If reset==1 then the * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather * than to the address resulting from executing the current instruction. */CHIP CPU &#123; IN inM[16], // M value input (M = contents of RAM[A]) instruction[16], // Instruction for execution reset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0). OUT outM[16], // M value output writeM, // Write to M? addressM[15], // Address in data memory (of M) pc[15]; // address of next instruction PARTS: // Put your code here: // C-ins bits And(a=instruction[15], b=instruction[12], out=ca); // a And(a=instruction[15], b=instruction[11], out=c1); // c1 And(a=instruction[15], b=instruction[10], out=c2); // c2 And(a=instruction[15], b=instruction[9], out=c3); // c3 And(a=instruction[15], b=instruction[8], out=c4); // c4 And(a=instruction[15], b=instruction[7], out=c5); // c5 And(a=instruction[15], b=instruction[6], out=c6); // c6 And(a=instruction[15], b=instruction[5], out=d1); // d1 And(a=instruction[15], b=instruction[4], out=d2); // d2 And(a=instruction[15], b=instruction[3], out=d3); // d3 And(a=instruction[15], b=instruction[2], out=j1); // j1 And(a=instruction[15], b=instruction[1], out=j2); // j2 And(a=instruction[15], b=instruction[0], out=j3); // j3 // instruction[15]: 0 -&gt; A, 1 -&gt; C Mux16(a=instruction, b=ALUout, sel=instruction[15], out=uins); // A-ins Mux(a=true, b=instruction[5], sel=instruction[15], out=insA); // ALUout -&gt; A Register ARegister(in=uins, load=insA, out[0..14]=addressM, out=uAreg); // inM Mux16(a=uAreg, b=inM, sel=ca, out=u1); // DRegister DRegister(in=ALUout, load=d2, out=uDreg); // writeM And(a=instruction[15], b=d3, out=writeM); // ALU ALU(x=uDreg, y=u1, zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6, out=ALUout, out=outM, zr=zr, ng=ng); // PC Not(in=zr, out=notzr); Not(in=ng, out=notng); And(a=notzr, b=ng, out=negative); // ALUout &lt; 0 And(a=zr, b=notng, out=zero); // ALUout = 0 And(a=notzr, b=notng, out=positive); // ALUout &gt; 0 // JUMP And(a=j3, b=positive, out=JGT); // JGT And(a=j2, b=zero, out=JEQ); // JEQ And(a=j1, b=negative, out=JLT); // JLT And(a=j1, b=j2, out=tmp); And(a=tmp, b=j3, out=JMP); // JMP + JNE + null Or(a=JGT, b=JEQ, out=jmp1); // JGT + JEQ + JGE, 3 possibilities Or(a=jmp1, b=JLT, out=jmp2); // jmp1 + JLT + JLE, 5 possibilities Or(a=jmp2, b=JMP, out=jmp3); // jmp2 + JMP + JNE + null, 8 possibilities And(a=instruction[15], b=jmp3, out=load); // not C-ins Not(in=load, out=inc); PC(in=uAreg, inc=inc, load=load, reset=reset, out[0..14]=pc);&#125; ComputerComputer 的设计思路还是参考老师上课给出的思路： 有了前面的设计基础（被反复拷打🤣），现在只需要按照上图中的思路将各个硬件连接起来即可，最后得到的代码如下：Computer123456789101112131415161718192021222324252627// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/Computer.hdl/** * The HACK computer, including CPU, ROM and RAM. * When reset is 0, the program stored in the computer&apos;s ROM executes. * When reset is 1, the execution of the program restarts. * Thus, to start a program&apos;s execution, reset must be pushed &quot;up&quot; (1) * and &quot;down&quot; (0). From this point onward the user is at the mercy of * the software. In particular, depending on the program&apos;s code, the * screen may show some output and the user may be able to interact * with the computer via the keyboard. */CHIP Computer &#123; IN reset; PARTS: // Put your code here: ROM32K(address=Upc, out=ROMins); CPU(inM=MinM, instruction=ROMins, reset=reset, outM=UoutM, writeM=UwriteM, addressM=UaddrM, pc=Upc); Memory(in=UoutM, load=UwriteM, address=UaddrM, out=MinM);&#125; Unit 5.6 Perspective这周一共只有两个问题： 冯诺依曼结构和哈佛结构有什么差异？ 哈佛结构是冯诺依曼结构的一个变种，二者的差异在于哈佛结构的数据内存和指令内存是分开的，而冯诺依曼结构的数据和指令是存放在一起的，这也就导致哈佛结构进行取址执行只需要一个时间周期，而冯诺依曼结构需要两个独立的时间周期。另外，还提到了如何构建结合两种结构特点的计算机，答案就是通过有限状态机的形式来构建，这里不深究。 计算机连接其他的外设，是如何工作的？ 除了键盘和屏幕，计算机有很多其他的外设（这里的外设包括显卡、网卡等硬件设备），而计算机连接这些外设的方式与连接键盘和屏幕是类似的（注意这里的类似指的是现代计算机而不是 Hack）。换句话说，现代计算机连接外设都是通过设备控制器（device controllers）来完成的，这点其实也可以从 Windows 系统中的设备管理器页面看出，而之所以要这样做是为了降低 CPU 的工作压力。 Unit 5.7 Summary这一章真的让我感慨良多...（其实是被虐的体无完肤🤣，不过还是完成了😤） 本章算是对前五章内容的汇总，基本把前五章所学的知识点都概括进来了。一开始琢磨 CPU 和 Memory 如何设计的时候，真的是脑袋都要想破了，想了很久一点头绪都没有，导致自己越想越烦躁，越想越想不出来，完全冷静不下来。然后，就一直拖着，结果就是进度很慢，花了半个月，这篇 Blog 才完成...这样真的不好😥，还是要注意效率。 现在回想起来，不够冷静是一个问题，还有一个问题是自己完成这些内容的时间间隔太长了，第一章的基础芯片、第二章的 ALU 和第三周的 RAM，都是一两年前完成的了，现在重新捡起来学习，原来的感觉都没了...所以，学习需要趁热打铁，熟练才能生巧！ 另外，还想说的是，前五章的核心内容就是如何设计硬件，而贯穿前五章设计硬件的技巧（或者说思路），就是如何使用特定的 control bit 来分情况输入输出比特流，这一点在 Mux、ALU、RAM、PC、CPU 和 Memory 上都有体现。 最后，希望自己再接再厉，趁热打铁，赶紧把第六章的汇编器完成了，这回不能偷懒了！😤]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新冠感染记]]></title>
    <url>%2F2022%2F12%2F19%2F%E6%96%B0%E5%86%A0%E6%84%9F%E6%9F%93%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[新冠已经三年了，今天终于轮到我了...写这篇文章并不是想说一些跟新冠相关的看法，只是想记录一下自己的新冠过程。 12 月 15 日 晚同住的朋友小 z 告诉我，他好像出现了新冠的症状，但是我接受了，晚上依然住在一起。 12 月 16 日 早因为是周五还得上班，所以醒的很早，先做了个核酸。然后，若无其事的在馒头店，吃了早点。 12 月 17 日周六放假了，早上起床后，喉咙开始出现干涩的症状，但不是很严重，可以感觉很明显，也没有太当回事，心里只想着痊愈后别影响我唱歌就好。 起床去菜市场买了只鸡，再加一点山药、枸杞、红枣，炖了锅汤，跟小 z 一起裹了腹。下午，小 z 去医院检查肺部和开新冠的证明（为了保险），我顺路做了个单管。其实做不做都无所谓，自己绝对是阳了，之前在校区做的混管结果是待复核。 12 月 18 日17 日晚上睡觉的时候，还没有什么感觉，等到早上 4、5 点的时候，开始浑身酸痛，四肢无力，并伴有发烧。因为在床上，发烧脑袋也有点晕乎乎的，后脑勺有点痛（跟偏头痛相比差远了，主要是晕），感觉自己额头烫烫的，降温方式是隔一段时间用被子扇风😂，并将胳膊露在被子外面。后来感觉额头还是很烫，就把手机靠在自己的额头，恰巧因为冬天的关系，放置在外的手机温度很低，放到额头的一瞬间真的是很舒服... 整天基本处于发烧状态，凌晨大概是发烧温度最高的时候，吃了一粒过期的布洛芬，又躺在床上眯了会，感觉好像好受了一些。 后来起床溜达了一会，中午什么都不想吃，而且时不时有反胃的感觉，只吃了一碗小米粥，补充了一点碳水化合物。然后吃了颗布洛芬（还是过期的😂），又去床上睡觉了。刚上床，感觉奇冷无比，全身不再发烧，而是发冷。迫不得已，让小 z 搞了个热水袋，才慢慢睡着，睡醒后，用脚一摸热水袋，竟然觉得很烫，就知道自己又开始发烧了。 晚上的状态还可以，发烧温度应该下降到了 37.x，能做一点脑力活动了。然后，就看了看视频。 12 月 19 日今天是周一，工作日，早上起来没感觉到发烧，可能是已经变成低烧了吧，反正感觉比昨天好多了。 不过还是觉得很冷，并且手脚偶尔还是发冷，中午出去走了一圈，晒了会太阳，还是觉得冷，说明自己的发烧状态还没痊愈。 但是不管怎么样，得上班啊~😂这两天，还是挺忙的...希望明天自己和朋友小 z 能恢复的更好~💪 12 月 20 日又过了一天，身体的酸痛感已经快要消失了，可惜还是有鼻塞、流涕、咳嗽的症状。对了，还忘记了发烧，呵呵，发烧的症状也基本消失了，就是天天居家办公，坐在家里觉得好冷哦。目前身体已经没有其他不适的症状了，自我感觉身体状况也在逐渐的恢复，这可真是让人高兴的事情😁。傍晚，去做了个核酸，应该大概率还是阳性，不过还是检测一下，看下自己身体的状况吧。不过，做核酸的过程中，核酸检查人员告诉我阳性次数越多，码变绿的时间就越长，让我自己考虑清楚。没想太多，也没问太多还是做了，我寻思，我的码从未变红，我随便一次核酸阴性不就完事了吗？？？可问题是，我是不会那么干的😂，那样既对自己不负责，也对别人不负责。不管怎么说，自己的病情是在逐渐好转的，这点是毋庸置疑的，剩下的事情就是好好居家办公了，加油吧~ 12 月 21 日咳嗽的症状进一步缓解，但是还是有痰，发烧的症状已经可以确定消失了~今天久违的洗了个澡，间隔了大约 4、5 天？头发都油的不成样子了，要不是因为发烧，绝不会拖这么久...另外，虽然洗的时候很冷，但是洗完了是真的舒服~😎可惜，让人烦心的事情是工作仍然没有完成，但话又说回来，工作又怎么能真正的完成呢，所以，明天再说咯~🤣 12 月 23 日转眼已过一周了，感染新冠的症状每天都在逐步缓解，但自己的体力还是有所下降，现在没走两步路，就开始气喘吁吁的，感觉累得不行...但是也不能急着就开始做剧烈运动，需要慢慢恢复，一步一步来，以免产生不好的事情。同住的小 z，今天早上告诉我，他的核酸已经转阴了，恭喜他已经痊愈了。而我这几天没有做核酸，暂时不知道自己的情况。最近的一次核酸是在 3 天前，结果是阳性。按照日期来计算，我也快要转阴了。不过，下周要居家办公了，做不做核酸好像只与自己有关了。作为监测自己身体健康的手段，下周再做核酸也不迟。 12 月 27 日昨天早上做了一次核酸，结果是晚上出来的，已经转阴了。算起来，前前后后有十来天了。不容易啊，自己好像又经历了取经路上的一“难”。记得发烧的那两天，自己心里还在嘀咕，难受的日子总是过得很漫长。没想到，转眼之间，自己就快痊愈了。虽然核酸是转阴了，但是自己的呼吸道并没有完全恢复，依然还是咳嗽不断。有时候，感觉恨不得把肺咳出来了😂，尽管这个描述很夸张，但我是真的想表达出我的咳嗽情况...还有一点切身感受，那就是自己的体力下降了很多，感觉爬几层楼都喘的不行，像是自己提前步入老年生活了😂。不管怎么样，自己的心态还是得摆正。呵呵，好死不如赖活着，现在看这句话，其实也隐藏了很多劳动人民的智慧呢。另外，这几天看了一些网上的信息，说是阳康人员近几周都需要好好休息。个人感觉，也确实需要好好休息，让自己的身体好好恢复下。最后，希望关心我的人和我关心的人都能早早恢复~ 1 月 2 日今天是 2023 年的第二天，12 月 27 日核酸结果转阴后，12 月剩下几天依然还是天天做核酸，也都是阴性。明天就要回去上班了，晚上做了一个抗原，也是阴性的。目前，对自己而言，新冠应该算是告一段落了...差不多半个月的居家时间，也跟自己说声辛苦了，不容易啊~话说，明天去行里应该还很忙呢，哈哈，Fighting 吧🧐]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_04]]></title>
    <url>%2F2022%2F12%2F17%2FNand2Tetris-Part1-04%2F</url>
    <content type="text"><![CDATA[接着 2 年前的课程继续学习😂... Unit 4.1 Machine Languages: Overview本小节主要介绍与机器语言相关的一些基本认识，大胡子老师提到了图灵祖师爷和冯诺伊曼祖师爷😂。不得不说，只要是跟计算机相关的东西，一定要介绍这 2 位祖师爷。实际上，这个小节主要介绍的内容是讲内存与 CPU 如何沟通，通俗来讲，就是在讲计算机是如何执行指令的。因为 CPU 只认识 0 和 1 的比特流，所以内存需要讲这些比特流传给 CPU，由 CPU 计算好了之后在传给 RAM。而那些比特流就是指令（Instruction），而 CPU 计算的结果就是人需要的数据（Data）。当然了，CPU 传给 RAM 的数据依然是比特流，转换为人能看懂的东西，还需要特定的软件来阅读。 最后，大胡子老师又讲了一点跟机器语言相关的东西，不过这机器语言看着挺像汇编的，虽然也没学过汇编...😂 Unit 4.2 Machine Language: Elements依然延续上一节和机器语言相关的内容，不过这一小节讲的更多的是机器语言的语法，或者说，是这一条指令在计算机（Hack）内如何在执行。 Addressing Modes机器语言的指令都是地址模式（Addressing Mode，也不知道这么翻译对不对？）的，按照大胡子老师的讲解，机器语言可以直接作用于寄存器，大概就是这个意思。举了四个例子：1234567891011// RegisterAdd R1, R2 // R2 &lt;- R2 + R1// DirectAdd R1, M[200] // Mem[200] &lt;- Mem[200] + R1// IndirectAdd R1, @A // Mem[A] &lt;- Mem[A] + R1// ImmediateAdd 73, R1 // R1 &lt;- R1 + R3 这难道看着不就是汇编吗？😂 Unit 4.3 The Hack Computer and Machine Language本小节主要讲解即将要做的 Hack Computer 的工作原理和在 Hack 上用的 Machine Language 的一些语法。Hack 中的机器语言的执行过程是：实际上也就是 CPU 读取保存在 instruction memory 内的指令（instructions），然后加载保存在 data memory 中的数据，计算后，将结果保存在 data memory 中。实际上，这个图还可以画成：这样会更清晰一些。Hack 是个 16 的计算机，所以这些硬件的总线宽度也是 16-bits 的。 The A-instruction直译是 A-指令，实际上就是 Hack 的机器语言中的一种语法，利用@来表示地址，后面跟上数字，这个数字代表内存地址。只不过，这个语法需要借助 A 寄存器来完成。所以实际上，Hack 中这条语句的执行过程是先将@后的地址存入 A 寄存器，而 A 寄存器中的地址值，会被当作RAM[A]来使用，实际上 M 就是 RAM[A]，基本语法：12@0M=1 // RAM[0] = 1 The C-instructionC-指令，这是个复合语句，有点类似 C/C++ 中的 for 循环，基本语法：1234dest = comp; jump // both dest and jump are optionalcomp = 0, 1, -1, D... // read the book get the othersdest = null, M, D, MD... // read the book get the othersjump = null, JGT, JEQ... // read the book get the others 老师举得例子这里就不写了。 Unit 4.4 Hack Language Specification本小节继续在讲与 Hack Language 相关的内容，Hack program 就是用 Hack machine language 写的一系列指令，实际上这与其他程序语言是一样的。接着，老师又讲了讲符号指令（Symbolic instructions）和二进制代码在 Hack Language 中的对应关系（这些查书都可以查到，理解起来也比较简单）。 Unit 4.5 Input/Output本小节主要介绍了在 Hack 中如何使用两个 I/O 设备。首先是 Screen，Hack 中的 Screen 是一个 8K 的内建芯片（built-in chip），实际上是一个二维矩阵，512 列，256 行，这个矩阵的每一个元素代表一个 bit，直接通过地址来操控这些 bit。对应的，按照地址的索引方式有两个：$ Screen[32 * row + col / 16] $ 和 $ RAM[16384 + 32 * row + col / 16]$，二者本质上是一样的，只不过前者直接从代表 Screen 的那部分内存开始索引，而后者从整个内存单元的开头进行索引。从这里也可以看出，Screen 在内存中的开始地址是 16385。第二个介绍的键盘的使用，也是一个内建芯片（built-in chip），但是这个内建芯片没有输入，只有输出，对应的输入其实就是你现在用的键盘，每按一下不同的按键，点击 tick，就可以产生不同的效果。 Unit 4.6 Hack Programming Part 1本小节是讲解 Hack Machine Language 的第一课，主要内容是 Hack Machine Language 是如何操作寄存器和内存的。只需要按照具体的语法书写指令，就可以操作寄存器和内存了。但是这样写出的程序，存在一个问题，那就是没法结束，老师给的建议是完成功能后，在结尾写一个循环。 Unit 4.7 Hack Programming Part 2本小节是讲解 Hack Machine Language 的第二课，主要内容是 Hack Machine Language 中的分支（Branching）、变量（Variables）和迭代（Iteration）三种结构的用法，这三种结构都是由前面提到的 A 指令和 C 指令构成的。 Branching分支结构会用到类似 C 语言中go to关键字的功能，会跳转到一行开始执行。这里，又引出了行号的概念，也就是可以直接写成@8，这个数字 8 就代表跳到第 8 行开始执行。为了提高可读性，可以写成@label，只需要再在后面的某一行写上(label)即可，其中的 label 是可以写成有意义的字符的。 Variables变量的用法和分支中 label 的用法是类似的写法都是@label，如果没有在后面的语句中写上(label)，那么汇编器就会认为这个 label 是个变量。另外，变量的实际内存地址是从地址 16 开始的，这个地址位于 RAM 芯片上。 Iteration同样，循环结构也是由 A 指令和 C 指令构成。老师没有具体讲解循环指令的写法，给了一个累加的示例程序自己看。然后就是书写这类程序的建议，先写好伪代码，然后再写成机器语言代码。 Unit 4.8 Hack Programming Part 3这是最后一节课了，终于要讲完了哈...😂这节课提到了指针的概念，为了解释指针的使用，老师举了一个例子。高级语言中的数组在低级语言中是不存在的，那低级语言是如何来完成对应的功能呢？答案是用指针完成的，数组名 arr 就是首地址，然后用一个 i 代表偏移量，也就有：$ arr + i = arr[i] $，显然这与 C 语言是一致的（果然，C 语言学的好，这方面很容易理解）。 后面又提到了之前提到的两个设备：屏幕和键盘，分别演示了两个 demo 程序，算是讲解了在 CPU Emulator 中如何使用这两个设备。 Unit 4.9 Project 4 Overview这周的任务比较少，只有两个任务。第一个任务是用机器语言写一个乘法程序，能正确获得 2 个数的乘法结果即可；第二个任务是用机器语言写一个交互程序，每当按下键盘的按键时，模拟器的屏幕就会变黑，松开按键就会还原。 Mult从思路上来讲，乘法的实现很简单，ALU 是有加法运算功能的，所以写一个循环，重复加上相同的数字，最后将结果保存在指定的寄存器中即可。先看下简单的加法是怎么写的：123456789// D = R0@R0D=M// D = D + R1@R1D=D+M// R2 = D@R2M=D 老师还讲过一个从 1 加到 100 的程序：1234567891011121314151617181920212223// Adds 1 + ... + 100 @i M=1 @sum M=0(LOOP) @i D=M @100 D=D-A @END D;JGT @i D=M @sum M=D+M @i M=M+1 @LOOP 0;JMP(END) @END 0;JMP 这个程序已经把完成这个任务需要的循环写好了，照着这个改一改就可以了，合理偷懒😘。改完之后：12345678910111213141516171819202122 @i M=0 @R2 M=0(LOOP) @R0 D=M @i D=D-M @END D;JLE // D &lt; 0, jump to END @R1 D=M @R2 M=D+M @i M=M+1 @LOOP 0;JMP(END) @END 0;JMP 用测试脚本试了下，没有问题。需要说明的是，循环的写法有很多种，不用局限于一种。话说回来，这段代码的可读性是真的差。单独看这段代码，或者隔一段时间来看，应该完全不知道写的是啥... Fill这个问题可以分成 2 个子问题： 如何使屏幕全部变黑？ 如何获取键盘输入？ 先考虑第一个问题。在考虑这个问题之前，先研究一下老师的视频中的示例程序：12345678910111213141516171819202122232425262728293031323334353637 @R0 D=M @n M=D @i M=0 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(LOOP) @i D=M @n D=D-M @END D;JGT // if i&gt;n go END @address A=M M=-1 @i M=M+1 @32 D=A @address M=D+M // address = address + 32 @LOOP 0;JMP // go to LOOP(END) @END // program&apos;s end 0;JMP 这个程序最终实现的效果是，在屏幕上打印了一个 16 个像素宽，$RAM[0]$ 个长度的黑色矩形。从这个程序中，可以得出几个结论： 内存中一个地址指向的 16 位寄存器就代表了屏幕中 16 个像素点，把这个内存单元的值改为 -1，就可以使这 16 个像素点变黑。 地址每加 1，就会跳过 16 个像素点，也即每移动一个寄存器，就会跳过 16 个像素点。 屏幕的一行由 32 个内存单元（寄存器）来映射这些像素点。 有了这些结论，要想得到一个完全变黑的屏幕，只需要从 16834 这个地址开始，把接下来共 8192 个内存单元的值全置为 -1 即可。（实际上，16384 + 8192 = 24576，这个地址就是映射为键盘的地址，同时也可以知道为什么老师要说屏幕是 8K 的。）修改下代码：12345678910111213141516171819202122232425262728293031323334353637 @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(LOOP) @i D=M @n D=D-M @END D;JGT // if i&gt;n go END @address A=M M=-1 @i M=M+1 @1 D=A @address M=D+M // address = address + 32 @LOOP 0;JMP // go to LOOP(END) @END // program&apos;s end 0;JMP 实际上，只需要设置循环次数为 8192 次，i 的递进值改为 1 即可。运行后，就可以实现屏幕变黑的效果了。 现在考虑第二个问题。有了前面的思考，目前已经知道了地址为 24576 的内存单元保存的是按键的值。简言之对应两种情况： 按键了，值不为 0。 未按键，值为 0。 那么，可以根据这个情况，分别执行将屏幕变黑和变白的子代码块（这个语言没有函数的概念，不知道怎么描述了...😂）。修改后的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687(PRIMARYLOOP) @KBD D=M @0 D=D-A @WHITE D;JEQ @BLACK 0;JMP(BLACK) @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(BLOOP) @i D=M @n D=D-M @BEND D;JGT // if i&gt;n go BEND @address A=M M=-1 @i M=M+1 @1 D=A @address M=D+M // address = address + 1 @BLOOP 0;JMP // go to BLOOP(BEND) @PRIMARYLOOP 0;JMP(WHITE) @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(WLOOP) @i D=M @n D=D-M @WEND D;JGT // if i&gt;n go WEND @address A=M M=0 @i M=M+1 @1 D=A @address M=D+M // address = address + 1 @WLOOP 0;JMP // go to WLOOP(WEND) @PRIMARYLOOP 0;JMP 上面的代码实际上是两个重复的部分，而主循环程序也不过 8 行，主要是背后的逻辑太简单了，就是一个条件语句，两个分支，把所有情况都写出来即可。不过，因为机器语言有很多跳跃语句，所以用于跳跃的 label 一定要写的清晰明了一点，不然容易把自己搞混。 Unit 4.10 Perspective又到了这周的问题时间： Hack Machine Language 和现实中的机器语言有什么区别？ Hack Machine Language 很简单，相比之下，现实中的机器语言提供了更丰富的指令和功能，比如乘法和除法。但是，这些功能也可以在 Hack 这台计算机的更高层完美实现。 所有的机器语言是不是都要拥有改变寄存器的值和获取某个寄存器的地址这两个功能？ 实际上，现实的机器语言不仅仅只提供了这两个基础功能。 人们用机器语言写程序时，会遇到困难吗？ （这问题问的😂）实际上，人们并不直接用机器语言写程序，而是直接用高级语言写程序，再用编译器将高级语言翻译成机器语言。但是，如果要提高程序的性能，就必须要能看懂高级语言被翻译后的机器语言。对应的，这个课程的第二部分，也会学习与编译器相关的内容，并试着去编写一个编译器。 这周的主题是机器语言，相比前面的内容，这一章终于跟电路联系的不是那么紧密了。这一章的难点更多的是在语言的语法方面，好在老师给的示例程序很多，借用一下，就可以很好的完成作业了。]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_11_月总结]]></title>
    <url>%2F2022%2F12%2F04%2F2022-11-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[十一月悄悄溜走啦~ November Rain - Guns’n’RoseYour browser does not support the audio tag. 不知不觉，距离上次写类似的文章，又过了半个月了。半个月来，上海的天气总是阴阴的，时不时还伴随着细雨，啪嗒啪嗒落在行人匆忙的雨伞上。空气的温度，也随着秋雨的降落而骤降。是冬天，冬天来了，雨水用它自己的方式在提醒着人们，该加衣服了，呵呵。尽管头顶的乌云仍未消散，但是抬起头好像已经可以看到光线从云层中照射下来了。 回到自己的生活中来。重新开始上班生活也已过半月了，天天倒是清闲的很，基本没什么事情，大多数时间都是在看自己感兴趣的书籍，待的人都有点心慌了😂。期间，一起同住的朋友小 z 成密接了，被隔离 5+3 了，自己倒是没什么问题。现在，他已经隔离完了，也没有什么问题。关于疫情的问题，也已经越来越明朗了起来，这是好事。 半个月的上班生活，一共写了 4 篇 Blog，其中 3 篇都是与 VBS 有关，这也是公司的要求了，毕竟是接下来要使用的工具。剩下的 1 篇是关于简单使用 G++ 编译器的，这些完成的都很轻松。其他的时间都是在读《C++ Primer》这本书了，这段时间算上来一共读了 8 章，算是读完了 C++ 基础部分，并且开始读 C++ 标准库了。 读这本书的过程中，确实收获了一些东西，也有一些读的一知半解的地方。当然了，自己也没想着一遍就全读懂了（如果真的这样，也就没有必要读这本书了），后面实践过程中遇到了，回头来看应该会理解的更深刻吧。 按照人事的说法，下周就可以正式的开始工作了，心里还是有点期待新的工作内容的。可是，昨天与同事聊过之后，发现自己的工作内容好像主要都是和 VBS 相关的，自己明明想做的是与 C/C++ 相关的后端方向。同时，还得知自己做的项目好像是与 ATM 相关的东西😂，一听名字就觉得是很老的技术。哎😔，自己真是命途多舛啊。 不管怎么说，从做人做事的角度来看，得干一行爱一行，事情也要有始有终的做才行。希望自己的工作内容与自己的发展方向有关吧。 另外，不得不提的是自己的上班时间太紧张了。八点半上班，自己得六点过一点起来赶地铁，赶公交。而且还是在冬天，早上起床真是受罪啊，哈哈。所以，自己一定要对得起自己才行啊~ 最后，希望自己别生病、健健康康的就好😁。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLI 下 G++ 的使用方法]]></title>
    <url>%2F2022%2F11%2F24%2FCLI-%E4%B8%8B-G-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[学习一下 CLI 下如何使用 G++/GCC 编译器。 缘由学习如何使用编译器对了解程序的产生过程是很有帮助的（废话😁），不至于脱离了 IDE，就完全不会编程了。实际上，通过阅读编译过程中产生的中间文件，会对编译器的工作过程有一个很清晰的认识。 这里以 G++ 编译器的使用为例，并且只作简单的一些探讨（GCC 与 G++会有不同的地方，但基本使用方法差别不大）。 编译过程G++ 的编译过程主要分为四个阶段：预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。 预处理在预处理的过程中，编译器会对一些宏指令（预编译指令，包括引入头文件之类）进行替换。以下面的源代码为例：1234567#include &lt;iostream&gt;#define number 10int main() &#123; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0;&#125; 在终端输入：1$ g++ -E test.cpp -o test.i 使用-E指令，让编译器生成预处理后的.i文件。接着用文本编辑器打开 test.i 文件（windows 下没有 tail 这样直接查看文件尾部的命令😑），直接看最下面的部分：12345int main() &#123; std::cout &lt;&lt; 10 &lt;&lt; std::endl; return 0;&#125; 原先设定的宏number已经被替换为 10 了，同时因为引入了iostream这个头文件，所以上面还多了两万多行的代码，其实就是把iostream头文件的内容直接插入到test.i这个文件内了。 编译预处理之后，可以直接对test.i文件进行编译，生成汇编代码。在终端输入：1$ g++ -S test.i -o test.s 使用-S指令，让编译器生成编译后的.s文件。test.s打开后可以发现是一堆汇编指令，但内容相比test.i要少了很多，也就是说，编译器在这个过程中又删除掉了不需要的部分。 汇编有了汇编代码后，就可以利用汇编器将汇编代码编译为二进制文件了，对于 G++ 而言，汇编器应该内嵌到了 G++ 之中，所以直接使用 G++ 就可以了。1$ g++ -c test.s -o test.o test.o文件打开后就是十六进制数，这就是生成的二进制文件。 链接最后，再将二进制文件与 G++ 的标准库进行链接，生成可执行程序test.exe并执行。123$ g++ test.o -o test.exe$ test.exe10 执行test.exe这个文件后，CLI 给出的结果是 10，这个结果与源码的内容是吻合的。 分离式编译上述内容都是在一个源文件完成的，但实际过程中，肯定不可能只有一个源文件，而这些源文件可能会存在相互使用的文件，所以就需要编译器支持分离式编译（separate compilation）。 简而言之，就是在编译main.cpp之前，先将要使用的其他源文件编译完成，再进行main.cpp的编译。也就是说，在编译一个源文件之前要确保它的“依赖”已经编译完成。以下面 3 个文件为例：func.h12#pragma oncevoid func(); func.cpp1234#include &lt;iostream&gt;void func() &#123; std::cout &lt;&lt; "hello world!" &lt;&lt; std::endl;&#125; main.cpp1234567#include &lt;iostream&gt;#include "func.h"int main() &#123; func(); return 0;&#125; CLI 编译过程依次是：12345$ g++ -c func.cpp$ g++ -c main.cpp$ g++ func.o main.o -o main.exe$ main.exehello world! 这样就算是编译完成了。 总结这篇文章，只是简单记录了一下编译器的工作过程和使用方法，不至于在没有 IDE 的时候望洋兴叹。实际上，这里并没有深入探讨类、函数、容器等复杂结构的编译过程，这些问题又都包含了很多其他的问题，留作下次探讨了。]]></content>
      <categories>
        <category>Tools</category>
        <category>GCC/G++</category>
      </categories>
      <tags>
        <tag>G++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_蠕虫病毒]]></title>
    <url>%2F2022%2F11%2F18%2FVBS-%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[这几天看了很多跟 VBS 相关的资料... 起因虽然看了很多资料，但是没做出什么东西来，感觉好像也没收获什么东西。偶然想到原来在学校打印店插 U 盘打印文件后，U 盘总是会感染蠕虫病毒。琢磨了一下，好像这种简单的病毒就是 VBS 来做的？ 病毒的特征印象中，这种蠕虫病毒会把 U 盘内的文件全部隐藏，并生成一个指向隐藏文件的快捷方式。所以，这种病毒并不会损坏文件，没有什么破坏性。但是对于不熟悉 windows 操作系统的人，多半会认为自己的文件已经丢失了。现在回头想想，这个病毒倒像是哪个顽皮的同学在学校机房传播的恶作剧😂。 病毒的本质这种蠕虫病毒的本质就是脚本程序，也就是让计算机利用用户的权限做一些损坏用户自身文件的事情。执行不同的脚本程序需要不同的脚本解释器，如果要让病毒快速传播，一定要选一个用途比较广的脚本解释器。显然，VBS 脚本解释器是最好的选择。因为只要是微软的操作系统，那么一定自带 VBS 脚本解释器。所以在不需要额外安装的情况下，病毒可以直接运行。 如何实现先分解一下要实现的功能： 找到当前目录下的所有文件，包括目录和文件。 创建指向当前文件或目录的快捷方式。 将原文件隐藏。 获取所有文件在 VBS 中，与文件的相关操作需要用到文件对象模型FileSystemObject。这个文件对象模型中封装了许多与访问文件相关的方法。首先，我们创建这个文件模型：123456789'设置变量必须要声明才能使用Option Explicit'声明 3 个变量分别表示文件对象、文件和子目录Dim Fso, Folders, SubFolders'创建文件对象Set Fso = CreateObject("Scripting.FileSystemObject")'获取当前目录下所有文件，"." 代表当前目录的路径'这里 GetFolder 返回的是一个 Folder 对象Set Folders = Fso.GetFolder(".") 设置 WshShell 对象如果说前面提到的文件对象是用来处理与文件相关操作的，那么WshShell就是用来执行一些系统操作的对象。123'创建 WshShell 对象，用于后面创建快捷方式Dim WshShellSet WshShell = WScript.CreateObject("WScript.Shell") 创建快捷方式因为 Folder 对象不能直接遍历，所以为了把功能做的更加完善（无论是目录还是文件，全部都变成快捷方式并隐藏原文件），需要分别遍历。同时，如果当前目录下文件超过一个，也不能只新建一个快捷方式，所以需要生成多个快捷方式，这个过程可以用数组来实现，并且由于不知道具体有多少个文件，这个数组必须是变长的。12345678910111213141516171819202122232425262728293031'声明一个变长数组，和对应的下标Dim ShellLink()Dim indexindex = 0'为文件设置快捷方式并隐藏原文件Dim Files, fileSet Files = Folders.FilesFor Each file In Files file.attributes = 2 '设置为隐藏 redim ShellLink(index) '创建快捷方式，快捷方式默认放在当前目录下，名称与原文件一致，后缀为 .lnk Set ShellLink(index) = WshShell.CreateShortcut(".\" &amp; file.Name &amp; ".lnk") ShellLink(index).TargetPath = file '快捷方式的目标路径为原文件 ShellLink(index).IconLocation = file '快捷方式的图标为原文件 ShellLink(index).Save '保存快捷方式 index = index + 1 '保存快捷方式Next'为目录设置快捷方式的过程类似Dim SubFolders, folderSet SubFolders = Folders.SubFolders '获取子目录For Each folder In SubFolders folder.attributes = 2 redim ShellLink(index) Set ShellLink(index) = WshShell.CreateShortcut(".\" &amp; folder.Name &amp; ".lnk") ShellLink(index).TargetPath = folder ShellLink(index).IconLocation = folder ShellLink(index).Save index = index + 1Next 结语到这里，蠕虫病毒的大致功能就完成了。但严格意义上讲，这篇文章做的东西只能算作是一个 VBS 脚本，因为它并不像具备病毒的破坏性和传播性，也不想讨论如何这样干😂。不过，不得不承认的是 VBS 这类轻量级的脚本语言，用来写一些提高工作效率的脚本是很方便的，语法简单，功能齐全，上手速度很快。另外，现在 Web 端用的都是 JS，VBS 可能也没有什么用武之地了。最后贴一下整体源码（可以直接保存为 .vbs 文件在文件夹内运行）：123456789101112131415161718192021222324252627282930313233343536373839404142434445&apos;设置变量必须要声明才能使用Option Explicit&apos;声明 3 个变量分别表示文件对象、文件和子目录Dim Fso, Folders&apos;创建文件对象Set Fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)&apos;获取当前目录下所有文件，&quot;.&quot; 代表当前目录的路径&apos;这里 GetFolder 返回的是一个 Folder 对象Set Folders = Fso.GetFolder(&quot;.&quot;)&apos;创建 WshShell 对象，用于后面创建快捷方式Dim WshShellSet WshShell = WScript.CreateObject(&quot;WScript.Shell&quot;)&apos;声明一个变长数组，和对应的下标Dim ShellLink()Dim indexindex = 0&apos;为文件设置快捷方式并隐藏原文件Dim Files, fileSet Files = Folders.FilesFor Each file In Files file.attributes = 0 &apos;设置为隐藏 redim ShellLink(index) &apos;创建快捷方式，快捷方式默认放在当前目录下，名称与原文件一致，后缀为 .lnk Set ShellLink(index) = WshShell.CreateShortcut(&quot;.\&quot; &amp; file.Name &amp; &quot;.lnk&quot;) ShellLink(index).TargetPath = file &apos;快捷方式的目标路径为原文件 ShellLink(index).IconLocation = file &apos;快捷方式的图标为原文件 ShellLink(index).Save &apos;保存快捷方式 index = index + 1 &apos;保存快捷方式Next&apos;为目录设置快捷方式的过程类似Dim SubFolders, folderSet SubFolders = Folders.SubFolders &apos;获取子目录For Each folder In SubFolders folder.attributes = 0 redim ShellLink(index) Set ShellLink(index) = WshShell.CreateShortcut(&quot;.\&quot; &amp; folder.Name &amp; &quot;.lnk&quot;) ShellLink(index).TargetPath = folder ShellLink(index).IconLocation = folder ShellLink(index).Save index = index + 1Next]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_简单实例]]></title>
    <url>%2F2022%2F11%2F15%2FVBS-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[这篇文章来记录一些用 vbscript 编写的实例。 大部分实例是内嵌在 html 中的脚本，剩余是 windows 下的脚本。 显示日期和时间12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Today's date is " &amp; date()) document.write("&lt;br&gt;") document.write("The time is " &amp; time()) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 运行结果：Today's date is 2022/11/15The time is 13:26:56 --&gt; 上面的代码中，包含了两个 vbs 自带的函数：date()和time()，一个返回日期，一个返回时间。 显示星期12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;VBScripts' function &lt;b&gt;WeekdayName&lt;/b&gt; is used to get a weekday:&lt;/p&gt; &lt;script type="text/vbscript"&gt; document.write("&lt;p&gt;") document.write(weekdayname(1)) document.write("&lt;br&gt;") document.write(weekdayname(2)) document.write("&lt;/p&gt;&lt;p&gt;") document.write("Get the abbreviated name of a weekday:") document.write("&lt;br&gt;") document.write(weekdayname(1, true)) document.write("&lt;br&gt;") document.write(weekdayname(2, true)) document.write("&lt;/p&gt;&lt;p&gt;") document.write("Get the current weekday:") document.write("&lt;br&gt;") document.write(weekdayname(weekday(date))) document.write("&lt;br&gt;") document.write(weekdayname(weekday(date), true)) document.write("&lt;/p&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 运行结果：VBScripts' function WeekdayName is used to get a weekday:星期日星期一Get the abbreviated name of a weekday:周日周一Get the current weekday:星期二周二 --&gt; 注意weekdayname函数的返回会根据是否提供第二个参数而变化。 显示月份和星期12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Today's day is " &amp; weekdayname(weekday(date))) document.write("&lt;br&gt;") document.write("The month is " &amp;monthName(month(date))) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- 运行结果：Today's day is 星期二The month is 十一月 --&gt; 计算日期差12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Countdown to year 3000:&lt;/p&gt;&lt;p&gt;&lt;script type="text/vbscript"&gt;millennium=CDate("1/1/3000 00:00:00")document.write(millennium &amp; "&lt;br&gt;")document.write("It is " &amp; DateDiff("yyyy", Now(), millennium) &amp; " years to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("m", Now(), millennium) &amp; " months to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("d", Now(), millennium) &amp; " days to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("h", Now(), millennium) &amp; " hours to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("n", Now(), millennium) &amp; " minutes to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("s", Now(), millennium) &amp; " seconds to year 3000!&lt;br&gt;")&lt;/script&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Countdown to year 3000:3000/1/1It is 978 years to year 3000!It is 11726 months to year 3000!It is 356889 days to year 3000!It is 8565322 hours to year 3000!It is 513919281 minutes to year 3000!It is 30835156829 seconds to year 3000!--&gt; cdate函数用来生成一个日期，其中包含日期和具体时间；now函数用来返回当前日期和时间；datediff函数用来计算日期和时间之差。 计算日期之和123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write(DateAdd("d", 0, date())) document.write("&lt;br&gt;") document.write(DateAdd("d", 30, date())) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Tue Nov 15 00:00:00 UTC+0800 2022Thu Dec 15 00:00:00 UTC+0800 2022 --&gt; dateadd用来计算日期之和，用法与datediff类似。 按照不同格式输出日期/时间123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write(formatdatetime(date(), vbgeneraldate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vblongdate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vbshortdate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vblongtime)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vbshorttime)) &lt;/script&gt; &lt;p&gt;Syntax for formatdatetime: formatdatetime(date, nameformat).&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：2022/11/152022年11月15日2022/11/150:00:0000:00 Syntax for formatdatetime: formatdatetime(date, nameformat).--&gt; formatdatetime函数可以根据不同的格式输出日期，第一个参数为日期，第二个参数为格式类型。 大小写转换1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Have a nice day!" document.write(txt &amp; "&lt;br&gt;") document.write(ucase(txt)) document.write("&lt;br&gt;") document.write(lcase(txt)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- Have a nice day!HAVE A NICE DAY!have a nice day! --&gt; ucase函数转换为大写，lcase转换为小写。 删除字符串两端的空格1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; fname = " Bill " document.write("Hello" &amp; Trim(fname) &amp; "Gates&lt;br&gt;") document.write("Hello" &amp; RTrim(fname) &amp; "Gates&lt;br&gt;") document.write("Hello" &amp; LTrim(fname) &amp; "Gates&lt;br&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- HelloBillGatesHello BillGatesHelloBill Gates--&gt; Trim函数默认删除字符串两端的空格，RTrim默认删除字符串右端的空格，LTrim默认删除字符串左端的空格。PS：document.write在显示字符串时，开头不显示，结尾默认只显示一个。 逆置字符串12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Hello Everyone!" document.write(txt &amp; "&lt;br&gt;") document.write(strreverse(txt)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Hello Everyone!!enoyrevE olleH --&gt; 跟 C++ 中的 reverse 函数一样，没什么好说的。 取整函数1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = 48.66776677 j = 48.33333333 document.write(round(i)) document.write("&lt;br&gt;") document.write(round(j)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：4948 --&gt; 跟 C/C++ 的round函数功能类似，默认四舍五入。 返回随机数12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; randomize() document.write(rnd()) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：0.3182794451713562 --&gt; randomize函数用于产生随机数种子，rnd函数用于返回一个随机数，数字总是小于 1 且大于等于 0。 产生 [0, 99] 的随机数123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; randomize() random_number = int(100 * rnd()) document.write("A random number: &lt;b&gt;" &amp; random_number &amp; "&lt;/b&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：A random number: 37 --&gt; 从字符串的左侧或右侧返回指定数目的字符1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to our web site!" document.write(left(txt, 5)) document.write("&lt;br&gt;") document.write(right(txt, 5)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Welcosite! --&gt; 替换字符串中的字符12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to this web!" document.write(txt &amp; "&lt;br&gt;") document.write(replace(txt, "web", "page")) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Welcome to this web!Welcome to this page! --&gt; 从一段字符串指定位置返回指定数目的字符123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to our web site!" document.write(txt &amp; "&lt;br&gt;") document.write(mid(txt, 9, 2)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--运行结果：Welcome to our web site!to --&gt; 有点类似 C++ string 类的substr函数。]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_Basic]]></title>
    <url>%2F2022%2F11%2F14%2FVBS-basic%2F</url>
    <content type="text"><![CDATA[记录一些与 VBS 相关的东西。 什么是 VBSVBScript 是微软出品的脚本语言,是 ASP（Active Server Pages）默认使用的脚本语言。VBS 是一个动态脚本语言，也是 VB 的轻量版本，IE 使用 VBS 的地方比较多（好像只有 IE 支持了😂），这应该也是今后的工作内容了。 VBS 的第一个例子Internet Explorer 支持 VBScript，所以可以在 IE 浏览器中执行 VBS 脚本。 注意由于新版 IE 也已经不再支持 VBScript 了，所以要在前端执行 VBScript 脚本就必须使用老版本的 IE（😓这技术栈也太老了吧）。比如：12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Hello World!") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 以上面这段代码为例，编辑保存为 HTML 文件，再用 IE 打开无法直接显示，需要打开 IE 的开发者模式，将文档模式改为小于 10 才能显示...换句话说，最新的 IE11 已经不支持 VBScript 了，IE10 及以下版本才能正常显示...这个真的太老了吧，我怎么感觉我在给地级市、县级市的银行 ATM 机写代码...扯远了... 如何使用 VBS话说回来，看来用到 VBS 的场景主要就是在 IE 浏览器上就一些与用户交互的事情了？也就是说，实际上就是往网页里面写脚本🤣，用的还不是 JavaScript 这种用的多的脚本语言，用的还是 VBS 这种... 在 HTML 中，&lt;script&gt;用来向 HTML 中插入 VBScript。换句话说，写好的 VBS 脚本必须写在&lt;script&gt;和&lt;/script&gt;，并且需要使用type属性来定义脚本语言的类型为text/vbscript。另外，需要注意的是，vbscript 是不区分大小写的，是否需要大小写要按照工作要求来定。 VBS 输出当 VBScript 被用在 Web 服务器上的 ASP 页面时，语句response.write()产生输出；当使用 IE 来测试时，语句document.write()来产生输出（这点好像与 JavaScript 是类似的）。不同类型的变量在输出时需要用到&amp;和&quot;&quot;符号，比如：123Dim namename="xxx"document.write("My name is:"&amp;name) 简而言之，字符串需要用&quot;&quot;括起来，&amp;用来连接两个不同的变量。 VBS 变量VBScript 使用Dim关键字来声明（创建）一个变量，注意大小写，比如：123Dim xDim carnamecarname="Volvo" 有时可能会写错变量的名字，如carname写成carnime，此时脚本会自动创建一个carnime的变量。为了避免不必要的错误，可以在脚本的顶端写上：Option Explicit，比如：123Option ExplicitDim carnamecarname=value 这样脚本就只能使用声明后的变量了。Dim声明的变量既可以赋数字，也可以赋为字符串。 VBS 数组用法类似 C 语言，如下：12345Dim names(2)names(0)="Tove"names(1)="Jani"names(2)="Stale"mother=names(0) 注意与 C 语言差异的地方在于，Dim names(2)中的数字为 2，表示数组的下标从 0 开始，因此该数组包含 3 个元素。多维数组的声明方法也是类似的，比如声明一个 5 行 7 列的多维数组：1Dim table(4, 6) 再看下面多维数组的实例：1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;script type="text/vbscript"&gt; Dim x(2,2) x(0,0)="Volvo" x(0,1)="BMW" x(0,2)="Ford" x(1,0)="Apple" x(1,1)="Orange" x(1,2)="Banana" x(2,0)="Coke" x(2,1)="Pepsi" x(2,2)="Sprite" for i=0 to 2 document.write("&lt;p&gt;") for j=0 to 2 document.write(x(i,j) &amp; "&lt;br&gt;") next document.write("&lt;/p&gt;") next &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; VBS 程序VBScript 可使用两种程序：子程序和函数。 子程序VBScript 中的子程序是一系列语句，被封装在Sub和End Sub语句内，可以执行某些操作，但是不会返回值，并且可以带有参数。比如：123Sub mysub()some statementsEnd Sub 或者123Sub mysub(argument1, argument2)some statementsEnd Sub 函数VBScript 中的函数与 C/C++ 中的函数类似，执行一系列操作并返回结果，写法与子程序类似，将函数体封装在Function和End Function之中就可以了。可以参考下面这个例子：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; Function myfunction(a, b) myfunction = a + b End Function document.write(myfunction(5, 9)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; VBS 条件与其他程序语言类似，VBScript 使用If、Then、Else、ElseIf和Select Case来作为条件控制语句，用法也是与其他语言类似的，直接看 3 个例子。第一个：12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script type="text/vbscript"&gt; i = hour(time) If i &lt; 10 Then document.write("Good Morning!") Else document.write("Have a nice day!") End If&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 在上面的代码中，hour是 vbscript 自带的函数，返回一天中当前的小时数（0 - 23）。与 C/C++ 有差别的地方在于条件语句需要用End If来表示结束。第二个：12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = hour(time) if i = 9 then document.write("Just started...!") elseif i = 11 then document.write("Hungry!") elseif i = 12 then document.write("Ah, lunch-time!") elseif i = 17 then document.write("Time to go home!") else document.write("Unknow") end if &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 第三个：12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; d = weekday(Date) document.write(d &amp; "&lt;br&gt;") select case d case 1 document.write("Sleepy Sunday") case 2 document.write("Monday again!") case 3 document.write("Just Tuesday!") case 4 document.write("Wednesday!") case 5 document.write("Thursday...") case 6 document.write("Finally Friday!") case else document.write("Super Saturday!!!") end select &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 相比 C/C++ 中的switch，这里不用写很多break是一件很不错的事情。不过说句题外话，为什么周二的数字要设置成 3 ？ VBS 循环在 VBS 中，可以使用四种循环：For...Next、For Each...Next、Do...Loop和While...Wend。 For…NextFor语句规定计数变量i以及它的初始值和结束值，Next语句会以 1 作为步进值来递增变量i。比如下面这个例子：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 0 to 5 document.write("The number is " &amp; i &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：123456The number is 0The number is 1The number is 2The number is 3The number is 4The number is 5 看来，0 to 5是从 0 到 5，得运行 6 次。如果为了在不改变边界条件的情况下，减少循环次数，可以使用Step关键字来完成，看下面这个例子：12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 0 to 5 step 2 document.write("The number is " &amp; i &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：123The number is 0The number is 2The number is 4 对应的，当Step后的数字为复数时，就可以使循环变量递减了。如果有时候要在循环运行到一定程度的时候退出循环呢？此时可以使用Exit For关键字，比如：1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 1 to 10 document.write("The number is " &amp; i &amp; "&lt;br&gt;") if i = 5 then exit for next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：12345The number is 1The number is 2The number is 3The number is 4The number is 5 For Each…NextFor Each...Next针对集合中的每个项目或者数组中的每个元素来重复运行某段代码，直接看下面这个例子：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; dim cars(2) cars(0) = "Volvo" cars(1) = "Saab" cars(2) = "BMW" for each x in cars document.write(x &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Do…Loop类似 C 语言的do-while，直接看例子：123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = 0 do while i &lt; 10 document.write(i &amp; "&lt;br&gt;") i = i + 1 loop &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 运行结果：123456789100123456789 总结到这里为止，与 VBScript 相关的基础内容学习就算是完成了。接下来要做的事情，是做一些 VBS 实例，学习一下 VBS 的内建函数（可能就是以后的生产力工具）。]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_10_月总结]]></title>
    <url>%2F2022%2F11%2F11%2F2022-10-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[不知不觉，来上海一个月了... 是否 - 崔健Your browser does not support the audio tag. 突然很想听这首歌... 10 月 11 日来的上海，依稀记得自己拖着行李箱，背着吉他和电脑包，来到这个陌生城市的场景：从这天早上离开家门，却没有坐到最早一班车，只好等下一班，结果却碰到了准备回重庆家乡的大叔；到达武汉，又在汉口火车站角落的快餐店吃了午饭后，踏上了奔赴上海的动车；之后路过江西、南京、扬州、杭州等城市后，最后到了上海，又跟着亲爱的朋友小 z 坐上地铁，慢慢回到了他的家。 这一个月来，自己的心态其实没有什么太大的变化。因为很多问题，自己这几年已经想的很清楚了。只是自己不愿意那样做而已，为什么会这样？因为自己是人，会受这样或那样的情绪左右，会变得不再相信一些事情，从而失去支撑自己的“柱子”。现在看来，能思考的人作为一个独立的个体，本身就不应该将自己的存在依靠在那些“柱子”上。 扯远了... 回过头来，这个月自己走过了一些上海的街道，感受了一下国际化大都市的魅力，尽管这些并未在自己的心中惊起任何的涟漪，大概自己唯一能确定的就是自己都这些东西已经存在了一定的免疫力了。从自己踏上离家的车时，自己的目的就是来工作的。这一个月来，自己也是按照这个目的来进行的。虽然求职过程有点心累，但最终结果自己是满意的，所以觉得自己可能转了一点运了吧？ 另外，不得不感谢小 z 给我的帮助，给了我很多有用的建议，还帮我修改了多次简历... 现在工作已经找到了，接下来要做的事情就是好好工作了。😂 具体如何，下个月再见吧~ 翻了翻手机相册，就留一张上海外滩的夜景照片吧~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_set 容器的常见用法]]></title>
    <url>%2F2022%2F11%2F01%2FC-set-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[好久没有水文了，这次梳理一下 set 的用法。 set 的翻译就是集合，但是与数学上集合不同的是 set 是一个内部自动有序且不含重复元素的容器。因为这个特点，set 在某些场景下能很方便的解决一些问题。 使用 set 之前，需要先引入 set 头文件。另外，set 的底层好像是用红黑树来实现的？ 初始化set 的初始化与 vector 和其他 STL 容器类似（可以看下 set 提供的构造函数）：1234set&lt;int&gt; s1;set&lt;double&gt; s2;set&lt;char&gt; s3;set&lt;int&gt; s4[100] // s4 大小为 100，内部每一个元素都是一个 set 访问set 只能通过迭代器（iterator）访问：123set&lt;int&gt;::iterator it;set&lt;double&gt;::iterator it;set&lt;char&gt;::iterator it; set 的迭代器只能通过自增（减）运算符来改变：12345678910111213141516171819#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; set&lt;int&gt; st; st.insert(1); st.insert(2); st.insert(3); st.insert(4); st.insert(5); for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; ' '; &#125; return 0;&#125;/*out:1 2 3 4 5 */ 常用函数insert向集合内插入元素，前面说过了，集合会自动排序和去重。1st.insert(x); find集合内查找元素，返回 set 中对应值为 value 的迭代器，时间复杂度为 O(logN)。1st.find(value); count查询集合内是否存在值为 value 的元素，如果存在返回 1，反之，返回 0。1st.count(value); eraseerase 函数用于删除集合内的元素，两种用法。 删除单个元素按照这个元素的迭代器进行删除：1st.erase(it); 删除单个值为 value 的元素：1st.erase(value); 删除一个区间的元素需要提供区间首尾的迭代器：12st.erase(it1, it2);st.erase(it1, st.end()); sizesize 函数用来返回集合内元素个数。1st.size(); clearclear 函数用来清空 set 内的所有元素。1st.clear(); lower_boundlower_bound 函数是 set 内集成的一个二分查找函数，功能与std::lower_bound函数的功能是类似的。对 set 而言，使用其内部的 lower_bound 函数的效率会更高，用起来也更方便，只用提供一个 value 即可，但前提是要确保 value 的类型与 set 容器内元素类型一致。另外，lower_bound 函数的返回值是 set 的迭代器。12345set&lt;int&gt; st;st.insert(1);st.insert(2);st.insert(3);st.lower_bound(2); upper_bound与上述 lower_bound 函数的用法一致，与std::upper_bound功能类似。 扩展有时候可能不需要 set 容器的去重功能，可以使用 multiset；有时候不需要排序功能，就可以使用 unordered_set，此时由于没有排序操作了，运行速度会快很多。unordered_set 在某些场合下，还可以当作哈希表来用。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Set</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 80 场双周赛]]></title>
    <url>%2F2022%2F06%2F13%2FLeetcode-%E7%AC%AC-80-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上周的双周赛~还是 3 题选手，这次周赛的题好像也简单了一点... 2299. Strong Password Checker IIAnalysis思路很直接，判断字符串是否符合要求即可。 Code这是当时提交通过的代码：1234567891011121314151617class Solution &#123;public: bool strongPasswordCheckerII(string password) &#123; string ht = "!@#$%^&amp;*()-+"; int n = password.size(); if(n &lt; 8) return false; bool lower = false, upper = false, num = false, spec = false, consective = false; for(int i = 0; i &lt; n; i++) &#123; if(isupper(password[i])) upper = true; if(islower(password[i])) lower = true; if(isdigit(password[i])) num = true; if(ht.find(password[i]) != string::npos) spec = true; if(i != 0 &amp;&amp; password[i] == password[i - 1]) consective = true; &#125; return lower &amp;&amp; upper &amp;&amp; num &amp;&amp; spec &amp;&amp; !consective; &#125;&#125;; 可惜的是，一开始用的是if-else if导致 WA 了一次。其实只要将是否出现连续字符单独拿出来判断就可以了。实际上也可以用二进制位来取代bool变量：12345678910111213141516class Solution &#123;public: bool strongPasswordCheckerII(string password) &#123; int n = password.size(); if(n &lt; 8) return false; int flag = 0; for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0 &amp;&amp; password[i] == password[i - 1]) return false; if(isupper(password[i])) flag |= 1; else if(islower(password[i])) flag |= 2; else if(isdigit(password[i])) flag |= 4; else flag |= 8; &#125; return flag == 15; &#125;&#125;; 这种技巧会被用在状态压缩等其他高级解法中。 2300. Successful Pairs of Spells and PotionsAnalysis简单来讲，这个题就是在算笛卡尔积，然后统计对应的符合条件的结果即可。如果直接暴力，复杂度是 $O(n^2)$，数量级在 $10^{10}$，肯定会超时。为了避免超时，就不能直接算笛卡尔积，可以先对 pairs 进行排序，然后遍历 spells 时，二分查找 pairs 中第一个满足条件的解，这样就可以直接得到符合条件的组合数目了。 Code这是当时提交通过的代码：12345678910111213class Solution &#123;public: vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, long long success) &#123; int n = spells.size(); vector&lt;int&gt; ans(n); sort(potions.begin(), potions.end()); for(int i = 0; i &lt; n; i++) &#123; long long tmp = (success % spells[i] == 0 ? success / spells[i] : success / spells[i] + 1); ans[i] = potions.end() - lower_bound(potions.begin(), potions.end(), tmp); &#125; return ans; &#125;&#125;; 这个题一开始也 WA 了一次，原因是 tmp 用的int，没有考虑到 spells 中的数为 1，而 success 为超出int范围的情况。实际上，当时比赛的时候，其实一看到 WA 就反应过来是 tmp 没用long long的问题。而且，出错的那个用例正好是很长的那个，一看就知道是最后专门用来卡边界的。但是，自己还是死死的盯着输出和预期结果很久，浪费了不少时间😐。实际上，上面的这段代码是向上取整的思路。对于正整数而言，$xy \geqslant success$ 等价于 $y \geqslant \lceil \frac {success} x \rceil$，也等价于 $ y &gt; \lfloor \frac {success - 1} x \rfloor$。那么，上面的代码可以改成：123456789101112class Solution &#123;public: vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, long long success) &#123; int n = spells.size(); vector&lt;int&gt; ans(n); sort(potions.begin(), potions.end()); for(int i = 0; i &lt; n; i++) &#123; ans[i] = potions.end() - upper_bound(potions.begin(), potions.end(), (success - 1) / spells[i]); &#125; return ans; &#125;&#125;; 2302. Count Subarrays With Score Less Than KAnalysis这是第四个题，但是第三个提交的题。为什么第三个提交呢？因为差不多是原题...😂类似的题是：713. Subarray Product Less Than K。所以这个题的解法也很多，当时的思路是滑动窗口 + 前缀和的思路。 Code这是当时提交通过的代码：1234567891011121314151617181920class Solution &#123;public: long long countSubarrays(vector&lt;int&gt;&amp; nums, long long k) &#123; long long ans = 0, sum = 0; int n = nums.size(); int left = 0, right = 0; while(right &lt; n) &#123; sum += nums[right]; long long product = sum * (right - left + 1); while(left &lt;= right &amp;&amp; product &gt;= k) &#123; sum -= nums[left]; left++; product = sum * (right - left + 1); &#125; ans += right - left + 1; right++; &#125; return ans; &#125;&#125;; 与其说是前缀和的思路，倒不如说是在模拟，不过也相差无几。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 296 场周赛]]></title>
    <url>%2F2022%2F06%2F05%2FLeetcode-%E7%AC%AC-296-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[这次周赛的题目感觉简单了一点。成了三题选手了...😂，第四题被卡在第 68 个用例了，可惜了。 6090. Min Max GameAnalysis直接按照题目来模拟就行。 Code这是当时提交通过的代码：12345678910111213141516171819class Solution &#123;public: int minMaxGame(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 1) return nums[0]; while(n != 1) &#123; n = nums.size(); vector&lt;int&gt; tmp; for(int i = 0; i &lt; n / 2; i++) &#123; int t; if(i % 2 == 0) t = min(nums[2 * i], nums[2 * i + 1]); else t = max(nums[2 * i], nums[2 * i + 1]); tmp.push_back(t); &#125; nums = tmp; &#125; return nums[0]; &#125;&#125;; 改直观一点：123456789101112131415161718class Solution &#123;public: int minMaxGame(vector&lt;int&gt;&amp; nums) &#123; int n; while(n != 1) &#123; n = nums.size(); vector&lt;int&gt; tmp; for(int i = 0; i &lt; n / 2; i++) &#123; int t; if(i % 2 == 0) t = min(nums[2 * i], nums[2 * i + 1]); else t = max(nums[2 * i], nums[2 * i + 1]); tmp.push_back(t); &#125; nums = tmp; &#125; return nums[0]; &#125;&#125;; 6091. Partition Array Such That Maximum Difference Is KAnalysis思路是排序 + 贪心。为了使分成的序列尽可能少，需要将差值满足条件的数尽可能多的放在一个序列中。实际上也就是小数与小一点的数放一个序列，大数与大一点的数放在一个序列。 Code这是当时提交通过的代码：12345678910111213141516class Solution &#123;public: int partitionArray(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int cnt = 0; int left = 0, right; while(left &lt; n) &#123; int right = left; while(right &lt; n &amp;&amp; nums[right] - nums[left] &lt;= k) right++; cnt++; left = right; &#125; return cnt; &#125;&#125;; 这样写有点滑动窗口的味道，其实可以改的更简单一点：1234567891011121314class Solution &#123;public: int partitionArray(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(), cnt = 0; for(int i = 0, j = 0; j &lt; n; j++) &#123; if(nums[j] - nums[i] &gt; k) &#123; cnt++; i = j; &#125; &#125; return cnt + 1; &#125;&#125;; 6092. Replace Elements in an ArrayAnalysis思路是哈希 + 模拟。因为需要将nums中的operation[i][0]替换成operation[i][1]，为了方便查找元素，用哈希表保存一下nums中元素的下标。每次完成替换操作后，哈希表会删除被替换的那个数字的下标（也可以不删除），然后更新新元素的下标。 Code这是当时提交通过的代码：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; arrayChange(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; operations) &#123; int n = nums.size(), m = operations.size(); unordered_map&lt;int, int&gt; indices; for(int i = 0; i &lt; n; i++) &#123; indices[nums[i]] = i; &#125; for(int i = 0; i &lt; m; i++) &#123; int x = operations[i][0], y = operations[i][1]; int index = indices[x]; nums[index] = y; indices[y] = index; indices.erase(x); &#125; return nums; &#125;&#125;; 实际上，这个题可以反着思考。比如有 3 次操作，分别是[1, 3]、[2, 1]和[3, 2]，那么可以从后模拟这些操作，最终 mp 中的元素就是：mp[3] = 2, mp[2] = 1, mp[1] = mp[3] = 2。然后再遍历一次 nums 数组，直接修改对应的元素即可。123456789101112131415class Solution &#123;public: vector&lt;int&gt; arrayChange(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; operations) &#123; unordered_map&lt;int, int&gt; mp; int m = operations.size(); for(int i = m - 1; i &gt;= 0; i--) &#123; if(!mp.count(operations[i][1])) mp[operations[i][0]] = operations[i][1]; else mp[operations[i][0]] = mp[operations[i][1]]; &#125; for(int &amp;i: nums) &#123; if(mp.count(i)) i = mp[i]; &#125; return nums; &#125;&#125;; 逆序遍历 operations 数组的好处在于，如果一个数字会被多次修改，那这个数字再逆序遍历的过程中会直接得到它最终被修改的那个数字，这样就避免了很多不需要的修改。同时需要说明的是，因为题目限定了 nums 中的所有数字互不相同、operations 中的数字也是在 nums 中不存在的，所以可以直接不加区分的正向修改，也就是最上面的做法，但逆向思考的方法也适用有重复数字的出现。 最后一个题，明天在来~ 2296. Design a Text EditorAnalysis题目意思很清晰，当时的思路是纯模拟。 Code暴力模拟这是当时提交的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TextEditor &#123; string te; int pos;public: TextEditor() : pos(-1)&#123; &#125; void addText(string text) &#123; if(pos == -1) &#123; pos = text.length(); for(int i = 0; i &lt; te.size(); i++) &#123; text.push_back(te[i]); &#125; te = text; &#125; else if(pos == te.length()) &#123; te += text; pos = te.length(); &#125; else &#123; string tmp = ""; for(int i = 0; i &lt; pos; i++) &#123; tmp.push_back(te[i]); &#125; tmp += text; int t = pos; pos = tmp.length(); while(t &lt; te.length()) &#123; tmp.push_back(te[t]); t++; &#125; te = tmp; &#125; &#125; int deleteText(int k) &#123; int cnt = 0; for(int i = 0; i &lt; k; i++) &#123; if(pos &gt; 0) &#123; te.erase(te.begin() + pos - 1); pos--; cnt++; &#125; else break; &#125; return cnt; &#125; string cursorLeft(int k) &#123; string tmp = ""; pos -= k; if(pos &lt; 0) &#123; pos = -1; return tmp; &#125; int tpos = pos - 1, i = 10; while(tpos &gt;= 0 &amp;&amp; i &gt; 0) &#123; tmp.push_back(te[tpos]); tpos--; i--; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorRight(int k) &#123; string tmp = ""; if(pos == -1) pos = k; else pos += k; if(pos &gt; te.length()) pos = te.length(); int tpos = pos - 1, i = 10; while(tpos &gt;= 0 &amp;&amp; i &gt; 0) &#123; tmp.push_back(te[tpos]); tpos--; i--; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125;&#125;; 纯纯的模拟思路，死在第 68 个用例的原因是写了很多输出语句来调试代码（Leetcode 返回的错误信息是超出输出限制）。删除多余的输出语句后，还是死在了第 72 个用例，原因是超时了，想想写了这么多 reverse，不超时怪了。这个题用模拟确确实实是可以做出来的，只是我的思路有点问题，参考了别人的暴力解法：123456789101112131415161718192021222324252627282930313233class TextEditor &#123;public: TextEditor() : curpos(0) &#123;&#125; void addText(string text) &#123; te.insert(curpos, text); curpos += text.length(); &#125; int deleteText(int k) &#123; int pos = max(0, curpos - k); int num = curpos - pos; text.erase(pos, num); curpos = pos; return num; &#125; string cursorLeft(int k) &#123; curpos = max(0, curpos - k); int num = min(10, curpos); return te.substr(curpos - num, num); &#125; string cursorRight(int k) &#123; int len = te.length(); curpos = min(len, curpos + k); int num = min(10, curpos); return te.substr(curpos - num, num); &#125;private: string te; int curpos;&#125;; 不得不说，还是自己 API 用的不熟练...实际上，这个题的正确做法应该是用双向链表或者栈来做。 链表模拟为什么要使用双向链表？因为需要左移或右移光标，双向链表可以很容易的完成这个操作。先考虑链表创建的过程中需要的东西。首先是结点的定义和构造函数：12345struct Node &#123; char ch; Node *pre, *next; Node(char _ch): ch(_ch), pre(nullptr), next(nullptr)&#123;&#125;&#125;; 创建链表肯定要插入结点：1234567Node* insert(Node* pos, Node* node) &#123; node-&gt;pre = pos; node-&gt;next = pos-&gt;next; node-&gt;pre-&gt;next = node; node-&gt;next-&gt;pre = node; return node;&#125; 题目还要求要删除，所以删除结点的操作也需要：1234void remove(Node* pos) &#123; pos-&gt;pre-&gt;next = pos-&gt;next; pos-&gt;next-&gt;pre = pos-&gt;pre;&#125; 偷下懒，不做真正的删除，只断链...（实际项目中可别这样干）接下来要考虑的问题就是 TextEditor 需要什么。首先肯定需要一个光标位置cur，这个指针指向光标位置左边的第一个结点。既然是链表，不妨创建一个头（哑）结点来方便插入。12345678910class TextEditor &#123;public: TextEditor() &#123; head = new Node(); head-&gt;pre = head-&gt;next = head; cur = head; &#125;private: Node *cur, *head;&#125; 之所以把头结点的指向自身，是为了方便后面移动光标的操作，注意整个链表是成环的。插入与删除文本就很简单了：12345678910111213141516void addText(string text) &#123; for(char ch: text) &#123; Node *tmp = new Node(ch); cur = insert(cur, tmp); &#125;&#125;int deleteText(int k) &#123; int tmp = k; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; remove(cur-&gt;next); k--; &#125; return tmp - k;&#125; 光标左移与右移的操作都需要返回一段文本，不妨把这个功能封装起来，让左移与右移只完成移动的功能。返回的字符串长度是 10 和光标左边字符数之间的最小值。因为前面让头结点指向了自身，所以可以让头结点作为左边最小字符的边界条件。另外，别忘了要翻转字符串。123456789101112string text() &#123; Node *p = cur; string tmp = ""; int k = 10; while(k &amp;&amp; p != head) &#123; tmp.push_back(p-&gt;ch); k--; p = p-&gt;pre; &#125; reverse(tmp.begin(), tmp.end()); return tmp;&#125; 然后是左移操作，光标最多只能移动到头结点处：1234567string cursorLeft(int k) &#123; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; k--; &#125; return text();&#125; 最后是右移，光标只能移动到最后一个结点处，同样可以用最后一个结点的next是否是头结点来判断是否到了链表末尾：1234567string cursorRight(int k) &#123; while(k &amp;&amp; cur-&gt;next != head) &#123; cur = cur-&gt;next; k--; &#125; return text();&#125; 合并：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class TextEditor &#123;public: struct Node &#123; char ch; Node *pre, *next; Node()&#123;&#125; Node(char _ch): ch(_ch), pre(nullptr), next(nullptr)&#123;&#125; &#125;; Node* insert(Node* pos, Node* node) &#123; node-&gt;pre = pos; node-&gt;next = pos-&gt;next; node-&gt;pre-&gt;next = node; node-&gt;next-&gt;pre = node; return node; &#125; void remove(Node* pos) &#123; pos-&gt;pre-&gt;next = pos-&gt;next; pos-&gt;next-&gt;pre = pos-&gt;pre; &#125; TextEditor() &#123; head = new Node(); head-&gt;pre = head-&gt;next = head; cur = head; &#125; void addText(string text) &#123; for(char ch: text) &#123; Node *tmp = new Node(ch); cur = insert(cur, tmp); &#125; &#125; int deleteText(int k) &#123; int tmp = k; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; remove(cur-&gt;next); k--; &#125; return tmp - k; &#125; string text() &#123; Node *p = cur; string tmp = ""; int k = 10; while(k &amp;&amp; p != head) &#123; tmp.push_back(p-&gt;ch); k--; p = p-&gt;pre; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorLeft(int k) &#123; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; k--; &#125; return text(); &#125; string cursorRight(int k) &#123; while(k &amp;&amp; cur-&gt;next != head) &#123; cur = cur-&gt;next; k--; &#125; return text(); &#125;private: Node *cur, *head;&#125;; 如果是 C++ 的话，可以用 STL 内的 list 来完成，思路是一致的：123456789101112131415161718192021222324252627282930313233343536373839404142434445class TextEditor &#123;private: list&lt;char&gt; l; list&lt;char&gt;::iterator cur = l.begin();public: TextEditor() &#123;&#125; void addText(string text) &#123; for(char ch: text) &#123; l.insert(cur, ch); &#125; &#125; int deleteText(int k) &#123; int k0 = k; for(; k &amp;&amp; cur != l.begin(); k--) &#123; cur = l.erase(prev(cur)); &#125; return k0 - k; &#125; string text() &#123; string tmp; auto it = cur; for(int k = 10; k &amp;&amp; it != l.begin(); k--) &#123; it = prev(it); tmp.push_back(*it); &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorLeft(int k) &#123; for(; k &amp;&amp; cur != l.begin(); k--) &#123; cur = prev(cur); &#125; return text(); &#125; string cursorRight(int k) &#123; for(; k &amp;&amp; cur != l.end(); k--) &#123; cur = next(cur); &#125; return text(); &#125;&#125;; 栈模拟准确来说，应该是用双栈来模拟，说的更直观一点就是对顶栈，也就是这两个栈的栈顶是拼在一起的，这样题目要求的光标位置就是这两个栈对顶的位置，而移动光标的操作就是两个栈来回倒的过程了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class TextEditor &#123;private: stack&lt;char&gt; left, right;public: TextEditor() &#123;&#125; void addText(string text) &#123; for(char ch: text) &#123; left.push(ch); &#125; &#125; int deleteText(int k) &#123; int k0 = k; while(k &amp;&amp; !left.empty()) &#123; left.pop(); k--; &#125; return k0 - k; &#125; string text() &#123; int k = 10; string tmp; while(k &amp;&amp; !left.empty()) &#123; tmp.push_back(left.top()); k--; left.pop(); &#125; reverse(tmp.begin(), tmp.end()); for(char &amp;ch: tmp) &#123; left.push(ch); &#125; return tmp; &#125; string cursorLeft(int k) &#123; while(k &amp;&amp; !left.empty()) &#123; k--; right.push(left.top()); left.pop(); &#125; return text(); &#125; string cursorRight(int k) &#123; while(k &amp;&amp; !right.empty()) &#123; k--; left.push(right.top()); right.pop(); &#125; return text(); &#125;&#125;; 为了更好的使用 API，其实直接用 string 容器来当作栈更好。123456789101112131415161718192021222324252627282930313233343536373839class TextEditor &#123; string left, right;public: TextEditor() &#123; left = right = ""; &#125; void addText(string text) &#123; left += text; &#125; int deleteText(int k) &#123; int k0 = k; for(; k &amp;&amp; left.length() &gt; 0; k--) &#123; left.pop_back(); &#125; return k0 - k; &#125; string cursorLeft(int k) &#123; if(left.length() &lt; k) k = left.length(); for(int i = 0; i &lt; k; i++) &#123; right.push_back(left.back()); left.pop_back(); &#125; string ans(left.end() - min(10, (int)left.length()), left.end()); return ans; &#125; string cursorRight(int k) &#123; if(right.length() &lt; k) k = right.length(); for(int i = 0; i &lt; k; i++) &#123; left.push_back(right.back()); right.pop_back(); &#125; string ans(left.end() - min(10, (int)left.length()), left.end()); return ans; &#125;&#125;; Summary这次周赛比较简单，没 AK 说明自己还是太弱了...😂最后一个题挺不错的，解法挺多的，虽然没有卡掉暴力解法，但是题目倒是很能打开思路，难度算在中等比较好。第 2、3 题算是中等题中的简单题了...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 295 场周赛]]></title>
    <url>%2F2022%2F06%2F01%2FLeetcode-%E7%AC%AC-295-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上周周赛。双题选手。 2287. Rearrange Characters to Make Target StringAnalysis统计 s 中和 target 相同的字符次数，然后模拟构成 target 子串即可。 Code这是当时提交通过的代码：12345678910111213141516171819202122232425class Solution &#123;public: int rearrangeCharacters(string s, string target) &#123; vector&lt;int&gt; cnt(26); int len = s.length(); for(int i = 0; i &lt; len; i++) &#123; cnt[s[i] - 'a']++; &#125; int ret = 0; bool flag = true; while(true) &#123; len = target.length(); for(int i = 0; i &lt; len; i++) &#123; cnt[target[i] - 'a']--; if(cnt[target[i] - 'a'] &lt; 0) &#123; flag = false; break; &#125; &#125; if(!flag) break; ret++; &#125; return ret; &#125;&#125;; 实际上，这个题可以通过维护两个哈希表做除法来确定最多能组成几个 target。123456789101112131415161718class Solution &#123;public: int rearrangeCharacters(string s, string target) &#123; vector&lt;int&gt; cnt1(26), cnt2(26); int len = s.length(); for(char c: s) &#123; cnt1[c - 'a']++; &#125; for(char c: target) &#123; cnt2[c - 'a']++; &#125; int min_val = INT_MAX; for(char c: target) &#123; min_val = min(min_val, cnt1[c - 'a'] / cnt2[c - 'a']); &#125; return min_val; &#125;&#125;; 2288. Apply Discount to PricesAnalysis这个题实际上算是个披着中等题外衣的简单题，难点在于对不同情况的分类，所以很容易 WA（WA 了 5 次😓）。 Code这是当时提交通过的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string discountPrices(string sentence, int discount) &#123; int len = sentence.length(); string ret = ""; for(int i = 0; i &lt; len; i++) &#123; if(sentence[i] != '$') ret.push_back(sentence[i]); else &#123; ret.push_back(sentence[i]); if(i &gt; 0 &amp;&amp; sentence[i - 1] != ' ') continue; i++; if(i == len) break; if(!isdigit(sentence[i])) &#123; ret.push_back(sentence[i]); continue; &#125; double tmp = 0; bool flag = true; int pos = i; while(i &lt; len &amp;&amp; sentence[i] != ' ') &#123; if(!isdigit(sentence[i]) &amp;&amp; sentence[i] != ' ') &#123; flag = false; break; &#125; tmp = tmp * 10 + sentence[i] - '0'; i++; &#125; if(flag) &#123; tmp = tmp * (1 - discount / 100.0) + 0.005; string t = to_string(tmp); int j = 0; while(j &lt; t.length() &amp;&amp; t[j] != '.') &#123; ret.push_back(t[j]); j++; &#125; ret.push_back(t[j]); ret.push_back(t[j + 1]); ret.push_back(t[j + 2]); if(i != len) &#123; ret.push_back(sentence[i]); &#125; &#125; else &#123; ret += sentence.substr(pos, i - pos + 1); &#125; &#125; &#125; return ret; &#125;&#125;; 被那几个用例来回折磨...稍微改一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: string discountPrices(string sentence, int discount) &#123; int len = sentence.length(); string ret = ""; for(int i = 0; i &lt; len; i++) &#123; if(sentence[i] != '$') ret.push_back(sentence[i]); else &#123; ret.push_back(sentence[i]); if(i &gt; 0 &amp;&amp; sentence[i - 1] != ' ') continue; i++; if(i == len) break; if(!isdigit(sentence[i])) &#123; ret.push_back(sentence[i]); continue; &#125; double tmp = 0; bool flag = true; int pos = i; while(i &lt; len &amp;&amp; sentence[i] != ' ') &#123; if(!isdigit(sentence[i]) &amp;&amp; sentence[i] != ' ') &#123; flag = false; break; &#125; tmp = tmp * 10 + sentence[i] - '0'; i++; &#125; if(flag) &#123; tmp = tmp * (1 - discount / 100.0) + 0.005; string t = to_string(tmp); int j = 0; while(j &lt; t.length() &amp;&amp; t[j] != '.') &#123; ret.push_back(t[j]); j++; &#125; for(int k = j; k &lt; j + 3; k++) &#123; ret.push_back(t[k]); &#125; if(i != len) ret.push_back(sentence[i]); &#125; else &#123; ret += sentence.substr(pos, i - pos + 1); &#125; &#125; &#125; return ret; &#125;&#125;; 题目要保留 2 位小数，那么第 3 位小数就要四舍五入，一个解决办法是直接加上 0.005，另外一个解决办法是用long double。PS：C++ 的字符串能力确实不如其他语言...这个题写的有点折磨人。 2289. Steps to Make Array Non-decreasingAnalysis这个题想了挺久的，可惜没想出来...当时把第二个题改好，就已经毫无耐心了，看了两眼后面两个题就溜了😂。现在再回来倒腾一下。 Codeem，先琢磨一下暴力解法。1234567891011121314151617181920class Solution &#123;public: int totalSteps(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; while(true) &#123; int n = nums.size(); vector&lt;int&gt; tmp; bool flag = true; tmp.push_back(nums[0]); for(int i = 1; i &lt; n; i++) &#123; if(nums[i] &lt; nums[i - 1]) flag = false; else tmp.push_back(nums[i]); &#125; if(!flag) cnt++; else break; nums = tmp; &#125; return cnt; &#125;&#125;; 暴力解法还算是比较容易想到（好像前几周的周赛的第一道跟这个差不多），思路就是暴力模拟，时间复杂度是 $O(n^2)$，死在第 79 个用例了。参考了一下大佬的题解：等价转换 + 利用单调性（Python/Java/C++/Go）。原来这是个单调栈的题，但是想到用单调栈来处理不算容易。首先要能想到的是将问题是一个数字能否“活到”最后，只取决于这个数字的左边有没有比它更大的数字。如果有，那这个数字一定会被拿掉；反之，这个数字一定会出现在结果序列中。然后需要考虑的是被拿掉的数字会在那一轮筛选中被拿掉。观察用例可以发现，被拿掉的数字肯定是这个数字与其左边第一个大于它的数字中间的数被拿掉之后才会被拿掉（我在说什么呢？😂）。以5, 3, 4, 5, 7, 3, 6, 11, 8, 5, 11为例，6一定会被拿掉，但是6一定是在其前面的3被拿掉后的下一轮筛选中被拿掉。换句话说，拿掉6需要的操作数就是拿掉3需要的操作数加 1。 按照这样的思路，可以使用一个单调递减栈来存储元素及其对应被拿掉的轮次（用时刻来表示也是可以的）。当栈顶元素小于当前元素时，就弹出栈顶元素，同时取被弹出元素轮次的最大值maxt，然后将当前元素与maxt + 1入栈。如果此时栈为空，说明当前元素不会被拿掉，maxt = 0，然后入栈。123456789101112131415161718class Solution &#123;public: int totalSteps(vector&lt;int&gt;&amp; nums) &#123; int ans = INT_MIN; stack&lt;pair&lt;int, int&gt;&gt; st; for(int i: nums) &#123; int maxt = 0; while(!st.empty() &amp;&amp; st.top().first &lt;= i) &#123; maxt = max(maxt, st.top().second); st.pop(); &#125; maxt = st.empty() == true ? 0 : maxt + 1; st.emplace(i, maxt); ans = max(ans, maxt); &#125; return ans; &#125;&#125;; 难点在思路上，本身的实现过程其实并不复杂。 2290. Minimum Obstacle Removal to Reach CornerAnalysis第一眼看到这个题的时候，就意识到了这是个与图相关的走迷宫的题目。跟图相关的内容，已经是忘的差不多... Code实际上这是个最短路的问题，grid可以直接当作这个图的邻接矩阵，那么整个题的求解过程就可以直接用 bfs 来完成。123456789101112131415161718192021222324class Solution &#123;public: int dirs[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; int minimumObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX)); queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(0, 0); dist[0][0] = 0; while(!q.empty()) &#123; auto u = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int newx = u.first + dirs[i][0]; int newy = u.second + dirs[i][1]; if(0 &lt;= newx &amp;&amp; newx &lt; m &amp;&amp; 0 &lt;= newy &amp;&amp; newy &lt; n &amp;&amp; dist[newx][newy] &gt; dist[u.first][u.second] + grid[u.first][u.second]) &#123; dist[newx][newy] = dist[u.first][u.second] + grid[u.first][u.second]; q.emplace(newx, newy); &#125; &#125; &#125; return dist[m - 1][n - 1]; &#125;&#125;; 这个题还可以用其他求最短路的方法来处理，留作以后的练习。 Summary第二个题出与字符串相关的题真是太麻烦了...写完了就没耐心写后面的题了。第三个题的思考难度还是挺大的，想不出来还是做得少。第四个题其实算是个送分的困难题，没抓住。😂]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 79 场双周赛]]></title>
    <url>%2F2022%2F05%2F31%2FLeetcode-%E7%AC%AC-79-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上周的双周赛~又成双题选手了~ 2283. Check if Number Has Equal Digit Count and Digit ValueAnalysis这个简单题很奇怪...大概意思是如果所有的下标i在字符串num中出现的次数与num[i] - &#39;0&#39;相等，就返回 true，反之返回 false。感觉怪的很...出题人是不是不知道怎么出简单题了？😂 Code这是当时提交通过的代码：12345678910111213class Solution &#123;public: bool digitCount(string num) &#123; vector&lt;int&gt; cnt(10); for(char &amp;ch: num) &#123; cnt[ch - '0']++; &#125; for(int i = 0; i &lt; num.length(); i++) &#123; if(num[i] - '0' != cnt[i]) return false; &#125; return true; &#125;&#125;; 题目其实看了挺久的，生怕 WA 了。实际上，这里也可以换成位运算：12345678910111213class Solution &#123;public: bool digitCount(string num) &#123; vector&lt;int&gt; cnt(10); for(char &amp;ch: num) &#123; cnt[ch &amp; 15]++; &#125; for(int i = 0; i &lt; num.length(); i++) &#123; if((num[i] &amp; 15) != cnt[i]) return false; &#125; return true; &#125;&#125;; 注意运算符的优先级。 2284. Sender With Largest Word CountAnalysis这个题实际上是两个题的结合版，一个是统计单词，一个是分割单词。所以，这个题算是在考 hash 和 split。 Code这是当时提交通过的代码：123456789101112131415161718192021222324252627class Solution &#123;public: string largestWordCount(vector&lt;string&gt;&amp; messages, vector&lt;string&gt;&amp; senders) &#123; map&lt;string, int&gt; mp; int n = messages.size(), mmax = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; int cnt = 0; bool flag = true; for(char &amp;ch: messages[i]) &#123; if(flag &amp;&amp; ch != ' ') &#123; cnt++; flag = false; &#125; else if(ch == ' ') flag = true; &#125; mp[senders[i]] += cnt; mmax = max(mmax, mp[senders[i]]); &#125; string ret = ""; for(auto it = mp.rbegin(); it != mp.rend(); it++) &#123; if(it-&gt;second == mmax) &#123; ret = it-&gt;first; break; &#125; &#125; return ret; &#125;&#125;; 因为题目规定大写字母的字典序小于小写字母，所以要挑出题目规定的字典序最大的那个人。题目虽然说了开头和结尾没有多余的空格，但是中间没保证，所以没有直接统计空格数，而是当遇到单词时统计。另外，注意反向迭代器的遍历操作。看了其他人的题解，发现这题压根没有中间有多余空格的用例...😂所以，改简单一点：123456789101112131415161718192021222324class Solution &#123;public: string largestWordCount(vector&lt;string&gt;&amp; messages, vector&lt;string&gt;&amp; senders) &#123; map&lt;string, int&gt; mp; int n = messages.size(), mmax = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; int cnt = 0; bool flag = true; for(char &amp;ch: messages[i]) &#123; if(ch == ' ') cnt++; &#125; mp[senders[i]] += ++cnt; mmax = max(mmax, mp[senders[i]]); &#125; string ret = ""; for(auto it = mp.rbegin(); it != mp.rend(); it++) &#123; if(it-&gt;second == mmax) &#123; ret = it-&gt;first; break; &#125; &#125; return ret; &#125;&#125;; 2285. Maximum Total Importance of RoadsAnalysis这个题有点意思，大致题意是如何安排结点的值才能使得每条路上结点和的总和最大。当时一眼看到题目，以为是最短路的逆思维——最长路，想了一会，没什么具体的思路，就放弃了。现在看了提示后，发现这个题其实跟最短路没有关系，算是涉及到图的结点的度的贪心题。为了使结果能达到最大，需要按照结点的度来给结点安排值，度越大的结点其值就越大，这样在最终计算时，才能得到最大值。 Code思路是统计 + 排序 + 贪心，看了提示后才想到的：12345678910111213141516171819202122class Solution &#123;public: long long maximumImportance(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; cities(n); for(auto &amp;v: roads) &#123; cities[v[0]]++; cities[v[1]]++; &#125; vector&lt;int&gt; indices(n); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return cities[i] &gt; cities[j]; &#125;); int val = n; for(int i = 0; i &lt; n; i++) &#123; cities[indices[i]] = val--; &#125; long long ret = 0; for(auto &amp;v: roads) &#123; ret += (cities[v[0]] + cities[v[1]]); &#125; return ret; &#125;&#125;; 先统计结点的度，然后再按照结点度的大小对下标排序，再按照度的大小给结点赋值，最后累加所有道路的重要性即可。这种对下标排序的方法是第一次参加周赛时，从大佬写的第三个题的题解学来的。实际上，这个题完全可以不用按照度给下标排序，对度排序后直接做计算就可以了，因为每个结点被计算的次数就是其度的值，所以可以写的简单一些：12345678910111213141516class Solution &#123;public: long long maximumImportance(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; degree(n + 1); for(auto &amp;v: roads) &#123; degree[v[0]]++; degree[v[1]]++; &#125; sort(degree.begin(), degree.end()); long long ret = 0; for(int i = 0; i &lt;= n; i++) &#123; ret += i * (long long)degree[i]; &#125; return ret; &#125;&#125;; PS：注意相乘时可能会溢出。 2286. Booking Concert Tickets in GroupsAnalysis跟上周一样，最后一个题也是设计题。想了挺久的，还是没想出来😭，题意就不说了。看了下提示跟标签，这个题好像还是在考线段树... Code参考题解：线段树二分（Python/Java/C++/Go） 看了半天题解跟视频没看懂，估计是内力不太够，先留着吧😂。 Summary线段树看的晕乎乎的。。可惜这个第三个题没做出来，本来应该好像差不多算是可以做出来的吧😂，下次争取一定。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Heart of Gold》简易吉他谱]]></title>
    <url>%2F2022%2F05%2F29%2F%E3%80%8AHeart-of-Gold%E3%80%8B%E7%AE%80%E6%98%93%E5%90%89%E4%BB%96%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[摇滚老炮 Neil Young 1971 年 26 岁写的歌... 相当喜欢这首歌...不能算是自己严格单独靠耳朵听扒下来的，结合了别人的演奏示范扒的。 示范： 整首歌都挺容易的，只是有一些地方要注意一下。前奏：123456Em7 D EmEm7 D EmEm C D GEm C D GEm C D GEm7 D Em 前奏注意的地方就是 Em 和弦的击弦，Em7 -&gt; D 的连续下扫，4分、8 分音符和 16 分音符的切换。总体来说，难点在节奏感跟右手功夫上。演唱 + 间奏 + 结尾：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Heart of gold1 = G Tepo 4/4Em C D G I want to live, I want to giveEm C D G I&apos;ve been a miner for a heart of goldEm C D G It&apos;s these expressions i never giveEm7 G C G keep me searching for a heart of gold, and I&apos;m getting oldEm7 G C G keep me searching for a heart of gold, and I&apos;m getting old(interlude start)Em C D GEm C D GEm C D GEm7 D Em(end)Em C D G I&apos;ve to been to Hollywood, I&apos;ve been to RedwoodEm C D G I Crossed the ocean for a heart of goldEm C D G I&apos;ve been in my mind, it&apos;s such a fine lineEm7 G C G keep me searching for a heart of gold, and I&apos;m getting oldEm7 G C G keep me searching for a heart of gold, and I&apos;m getting old(interlude start)Em C D GEm C D GEm C D GEm7 D Em(end)Em7 D Em keep me searching for a heart of goldEm7 D Em You keep me searching and I&apos;m growing oldEm7 D Em keep me searching for a heart of goldEm7 G C G I&apos;ve been a miner of heart of gold 首先是间奏，和弦走向和节奏与前奏一样；中间两段演唱部分也一样，难点在 Em7 -&gt; G -&gt; C -&gt; G 这里，需要注意连续的 8 分 + 后 16 的连续扫弦和 C 和弦的空拍与延音，需要一定的节奏感；最后一段 Em7 -&gt; D -&gt; Em 的节奏与间奏有差别，但与 Em7 -&gt; G -&gt; C -&gt; G 类似，多看看视频就可以了。另外，在连续下扫的时候，为了突出层次感，可以在一拍连扫 2 下 4 5 弦（或者 4 5 6 ）弦。 总体来说，这首歌没横按，所以左手基本没难度，难点在右手的扫弦与节奏感上。不过要想跟原版差不多，需要一把扫弦声音集中、粗犷一点的琴，并且插上音响，用拨片扫。 说回来这首歌，写的相当不错，又好弹，又好听，又有深度，其中的一句歌词还贴在我右边的简介里面。Heart of gold 啊，怎么样才能找到 Heart of gold 啊，这对每个人而言都是值得用一生思考的问题。也许对老杨而言，Heart of gold 是给自己的一种追求，并且是要时时刻刻贯彻的这种追求。正如此，他才能在《Hey hey my my》中大唱 Rock’n’Roll can never die，爆发出来的生命力、感染力如此之强。 想想老杨 26 岁写的这首歌，Dylan 20 岁写的《Blowing in the wind》，罗大佑 20 岁写的《歌》，这些家伙怎么都是年纪轻轻就能写出这么有深度的歌😭。 ...不写，我怎么听啊😂。话说，手头上 G 调口琴歇菜了，等日后在扒扒口琴的谱子。 忘记分析一下和弦了：这是首 G 调的歌，总体来讲，有 3 个和弦走向： Em7 -&gt; D -&gt; Em，也就是 6/7 -&gt; 5 -&gt; 6，Em7 的组成音是 3、5、7、2，正好可以用 D 来衔接。 Em -&gt; C -&gt; D -&gt; G，也就是 6 -&gt; 4 -&gt; 5 -&gt; 1，老套路了。 Em7 -&gt; G -&gt; C -&gt; G，也就是 6/7 -&gt; 1 -&gt; 4 -&gt; 1，这个应该只是为了符合主旋律编的吧。]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 294 场周赛]]></title>
    <url>%2F2022%2F05%2F29%2FLeetcode-%E7%AC%AC-294-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上周的周赛...这周退化成单题选手了😂 2278. Percentage of Letter in StringAnalysis第一个题比较简单，统计下次数，再算一下就可以了。 Code这是当时提交的代码：12345678910class Solution &#123;public: int percentageLetter(string s, char letter) &#123; int cnt = 0; for(char c: s) &#123; if(c == letter) cnt++; &#125; return cnt * 100 / s.length(); &#125;&#125;; 2280. Minimum Lines to Represent a Line ChartAnalysis这是第三个题，但是是自己第二个提交的题。题意不难理解，就是找出整个折线图中所有斜率不同的线段。当时的思路是，用一个变量统计线段数，挨个算相邻点构成的直线的斜率，相同就忽略，不同就加 1。本来一开始是打算直接用 set 的，但是后来想到，斜率相等但不是相邻的线段，是不同的两条线段。 Code这是当时提交的代码，死在 58 个用例了。1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; int cnt = 1; int prek = (stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); int curk; sort(stockPrices.begin(), stockPrices.end()); for(int i = 2; i &lt; size; i++) &#123; curk = (stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; 上面的代码有点小问题，那就是在开始计算之前，就应该排序。1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; int prek = (stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); int curk; for(int i = 2; i &lt; size; i++) &#123; curk = (stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; 换了下位置，又被卡在第 62 个用例了。看了下题解，发现这是个精度问题，直接用除法会损失小数，造成本不该相等的斜率相等了，这样就漏解了。将int换成double会被卡在第 80 个用例。幸运的是，C++ 提供了long double这种 16 个字节的基本类型，就可以直接用除法了。1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; long double prek = (long double)(stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); long double curk; for(int i = 2; i &lt; size; i++) &#123; curk = (long double)(stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; 但这个题，还可以从判断 3 点是否共线的角度思考，也就是向量的叉积。123456789101112131415class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; for(int i = 2; i &lt; size; i++) &#123; long long x1 = stockPrices[i][0] - stockPrices[i - 1][0], y1 = stockPrices[i][1] - stockPrices[i - 1][1]; long long x2 = stockPrices[i - 1][0] - stockPrices[i - 2][0], y2 = stockPrices[i - 1][1] - stockPrices[i - 2][1]; if(y1 * x2 != y2 * x1) cnt++; &#125; return cnt; &#125;&#125;; 当然，判断 3 点是否共线还可以计算这 3 个点组成的三角形面积是否为 0，而三角形的面积计算公式既可以用向量，也可以用海伦凯勒公式。 2279. Maximum Bags With Full Capacity of RocksAnalysis这是第二个题，一看就是背包问题，基本没做过类似的题，就直接弃了。上一次做的时候，是春赛的第二题，这次得把两个题都搞定。仔细一看这个题，实际上是个贪心的题目。为了得到装满石头的背包的最大数量，最开始放石头的背包一定是快装满的背包。 Code没想到回过神来想到的第一种解法是重新构造结构体在排序...1234567891011121314151617181920212223242526class Solution &#123;public: struct package&#123; long long remain, size, now; package(): remain(0), size(0), now(0)&#123;&#125; &#125;; int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; int n = capacity.size(); package pak[n]; for(int i = 0; i &lt; n; i++) &#123; pak[i].size = capacity[i]; pak[i].now = rocks[i]; pak[i].remain = pak[i].size - pak[i].now; &#125; sort(pak, pak + n, [](package a, package b) &#123; return a.remain &lt; b.remain; &#125;); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; if(pak[i].remain != 0) &#123; additionalRocks -= pak[i].remain; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(pak[i].remain == 0) cnt++; &#125; return cnt; &#125;&#125;; 实际上用 multiset 就可以了。12345678910111213141516171819class Solution &#123;public: int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; multiset&lt;int&gt; remains; int n = capacity.size(); for(int i = 0; i &lt; n; i++) &#123; remains.insert(capacity[i] - rocks[i]); &#125; int cnt = 0; for(auto &amp;i: remains) &#123; if(i != 0) &#123; additionalRocks -= i; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(i == 0) cnt++; &#125; return cnt; &#125;&#125;; 使用 multiset 容器的时间、空间消耗都很大，不如直接换成 vector，然后排序。1234567891011121314151617181920class Solution &#123;public: int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; vector&lt;int&gt; remains; int n = capacity.size(); for(int i = 0; i &lt; n; i++) &#123; remains.push_back(capacity[i] - rocks[i]); &#125; sort(remains.begin(), remains.end()); int cnt = 0; for(auto &amp;i: remains) &#123; if(i != 0) &#123; additionalRocks -= i; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(i == 0) cnt++; &#125; return cnt; &#125;&#125;; 果然，快多了...这么一看的话，这个题当时是可以做出来的，没经过仔细思考，直接认为这个题需要用 dfs 来求解...大意失荆州了啊~ 2281. Sum of Total Strength of WizardsAnalysis题意不难理解，就是算出所有子数组最小值与对应的和的积然后再相加。 参考思路：计算每个数字作为最小值的贡献。 如这篇题解所说先做一下 907 比较好。仔细拆分下来这个题实际上是前缀和 + 单调栈 + 数学，不过自己能单独做出来，估计得很长一段时间后了。 Code123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: const int mod = 1e9 + 7; int totalStrength(vector&lt;int&gt;&amp; strength) &#123; int n = strength.size(); stack&lt;int&gt; st; vector&lt;int&gt; left(n, -1), right(n, n); for(int i = 0; i &lt; n; i++) &#123; while(!st.empty() &amp;&amp; strength[st.top()] &gt; strength[i]) &#123; right[st.top()] = i; st.pop(); &#125; if(!st.empty()) left[i] = st.top(); st.push(i); &#125; vector&lt;int&gt; psum = strength; for(int i = 1; i &lt; n; i++) &#123; psum[i] = (psum[i] + psum[i - 1]) % mod; &#125; vector&lt;int&gt; ppsum = psum; for(int i = 1; i &lt; n; i++) &#123; ppsum[i] = (ppsum[i] + ppsum[i - 1]) % mod; &#125; auto f = [&amp;](int l, int r) &#123; if(r &lt; 0) return 0; if(l &lt; 0) return ppsum[r]; return (ppsum[r] - ppsum[l] + mod) % mod; &#125;; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; int l = left[i] + 1, r = right[i] - 1; long long sleft = 1ll * f(l - 2, i - 1) * (r - i + 1) % mod; long long sright = 1ll * f(i - 1, r) * (i - l + 1) % mod; ret += 1ll * strength[i] * (((sright - sleft) + mod) % mod) % mod; ret %= mod; &#125; return ret; &#125;&#125;; Summary这次周赛大意了，本来第二个题可以做的，结果把时间都花在第三个题上了（大致思路是对的，但没做出来）。第二题的主要问题是，搞错题目类型了，然后就放掉了...第三题其实是每日一题见过的类似题目，但是升级到中等题就做不出来了...第四题是个很不错的单调栈 + 前缀和的综合题，花时间把这个题吃透应该能有所值。 总之，这周的周赛有点亏😭。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_vector 容器的常见用法]]></title>
    <url>%2F2022%2F05%2F28%2FC-vector-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[梳理一下 vector 的常见用法。C++ 的 vector 本质上是一个动态数组，也就是可以自动扩容的数组，具体如何实现这里不深究。如果要使用 vector，需要添加 vector 头文件。 初始化vector 的初始化有很多种方式（本质上就是如何如何使用 vector 提供的构造函数）：123456789101112vector&lt;int&gt; v1; // v1 是一个空 vector，内部元素都是 int 类型的vector&lt;int&gt; v2(v1); // v2 中包含了 v1 所有元素的副本vector&lt;int&gt; v2 = v1; // 同上vector&lt;int&gt; v3(size, val); // v3 是大小为 size，内部元素全是 val 的 vectorvector&lt;int&gt; v4(size); // v4 的大小是 size，内部元素全是 0vector&lt;int&gt; v5&#123;a, b, c, ...&#125; // v5 包含了初始值个数的元素，前几个元素被赋予相应的值vector&lt;int&gt; v5=&#123;a, b, c, ...&#125; // 同上vector&lt;int&gt; v6[size] // v6 的大小为 size，内部每一个元素都是单独的 vector，长度不限vector&lt;vector&lt;int&gt;&gt; v6(size) //同上vector&lt;int&gt; v7(v1.begin(), v1.begin() + k); // v7的大小为 k，内部元素顺序与 v1 的前 k个元素一致vector&lt;vector&lt;int&gt;&gt; v7; // 不限定长度的二维 vectorvector&lt;vector&lt;int&gt;&gt; v8(size, vector&lt;int&gt;(size)); // 同时限定一维和二维的大小 上面的int都可以换成其他基本类型、类或容器。 访问下标vector 访问元素的方式有很多，可以用类似数组下标的方式访问，此时下标范围是[0, v.size() - 1]。1234vector&lt;int&gt; v(5);v[0] = 0;v[1] = 1;v[2] = 2; 迭代器STL 容器都可以用迭代器来访问。12345678910111213141516#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;; auto it = v.begin(); cout &lt;&lt; *it &lt;&lt; endl; cout &lt;&lt; *(++it) &lt;&lt; endl; cout &lt;&lt; *(v.begin() + 1) &lt;&lt; endl; return 0;&#125; /*out:122*/ 除了迭代器与下标，vector 还可以用一些成员函数来访问。 运算符两个 vector 可以直接用==和!=来判断相同与否，也即其内部元素是否都一致。123456789101112#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;int&gt; v1&#123;1, 2, 3&#125;; vector&lt;int&gt; v2&#123;1, 2, 3&#125;; if(v1 == v2) cout &lt;&lt; "Same" &lt;&lt; endl; return 0;&#125; /*out:Same*/ 类似的运算符还有&lt;、&lt;=、&gt;和&gt;=，比较规则是内部元素的字典序。 常用函数push_back向 vector 容器末尾添加元素。1v.push_back(x); emplace_backC++ 11 引入的新函数，与 push_back 相比更高效，用法基本相同。因为 push_back 只能接受一个元素，如果传入不是一个基础数据类型，那么就需要先将对象构造好，push_back 才会将这个对象传入 vector 中。12345678#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;pair&lt;int, int&gt;&gt; v; v.push_back(make_pair(1, 2)); v.emplace_back(1, 2); return 0;&#125; pop_back删除 vector 容器内末尾元素。1v.pop_back(); clear清除 vector 容器内所有元素。1v.clear(); resize重新设置 vector 容器的大小。12vector&lt;int&gt; v(2);v.resize(5); 注意，resize 函数不会真的改变当前容器的大小，只是将记录当前容器大小的那个变量改成重新设置的大小。 sizesize 函数返回容器的大小，在未设置大小的情况下，返回容器内元素的个数。1v.size(); begin返回 vector 第一个元素的迭代器。1v.begin(); end返回越界后的第一个位置的迭代器。1v.end(); rbegin返回 vector 容器逆序后的第一个元素的迭代器，也就是原序列的最后一个元素。1v.rbegin(); rend返回 vector 容器逆序后，越界的第一个位置的迭代器，也就是原序列第一个元素的前一个位置。1v.end(); 注意：rbegin 和 rend 函数返回的迭代器都是反向迭代器，++运算符是向前迭代，--运算符是向后迭代，这与正向迭代器是不同的！所以，如果需要对 vector 降序排序，可以直接写成sort(v.rbegin(), v.rend());。 frontfront 函数返回 vector 第一个元素的值。1v.front(); backback 函数返回 vector 最后一个元素的值。1v.back(); insert向任意迭代器位置插入元素。1v.insert(it, val); 注意，迭代器 it 必须是 v 内的。 erase删除迭代器为 it 的元素。1v.erase(it); 删除迭代器区间[first, last)内的所有元素。1v.erase(first, last);]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 293 场周赛]]></title>
    <url>%2F2022%2F05%2F28%2FLeetcode-%E7%AC%AC-293-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[又是之前的周赛~ 2273. Find Resultant Array After Removing AnagramsAnalysis不知道为什么简单题的题目都好长啊...题意就是删除连续出现的字母异位词，只保留最开始的哪一个。但是要注意，如果是相隔的字母异位词，是不用删除的。 Code这是当时提交通过的代码：12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) &#123; int size = words.size(); vector&lt;string&gt; ret; int i = 0; while(i &lt; size) &#123; string s1 = words[i]; ret.push_back(words[i]); sort(s1.begin(), s1.end()); int j = i + 1; while(j &lt; size) &#123; string s2 = words[j]; sort(s2.begin(), s2.end()); if(s2 != s1) break; j++; &#125; i = j; &#125; return ret; &#125;&#125;; 当时 WA 了一次的原因是，一次性把所有的字母异位词都删除了，没有注意只删除相邻的。判断是否是异位词，可以统计也可以排序，直接排序会比较方便，但统计的时间复杂度更低。既然使简单题，那就怎么方便怎么来好了。 2274. Maximum Consecutive Floors Without Special FloorsAnalysis这个题跟上一次周赛的题目很像，一样跟区间有关，所以这个题实际上就是在求分割后的最大区间。 Code一开始使用的暴力模拟 + hash 的思路：1234567891011121314151617181920class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); unordered_set&lt;int&gt; ht; for(int &amp;i: special) &#123; ht.insert(i); &#125; int maxstairs = 0; while(bottom &lt;= top) &#123; while(ht.count(bottom) &amp;&amp; bottom &lt; top) bottom++; if(bottom == top) break; int i = bottom + 1; while(i &lt;= top &amp;&amp; !ht.count(i)) i++; maxstairs = max(maxstairs, i - bottom); bottom = i; &#125; return maxstairs; &#125;&#125;; 因为 special 中的值范围是 $[1, 10^9]$，所以超时了。后面仔细一想，其实只需要把每个区间的间隔算出来，其中的最大值就是需要的结果了。但这种做法需要提前对 special 排序，并且要额外考虑最后的 top。1234567891011121314151617181920212223class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); vector&lt;int&gt; tmp = special; sort(tmp.begin(), tmp.end()); if(tmp[size - 1] != top) &#123; tmp.push_back(top + 1); size++; &#125; int maxstairs = 0; for(int i = 0; i &lt; size &amp;&amp; bottom &lt; top; i++) &#123; int end = tmp[i]; if(end == bottom) &#123; bottom++; continue; &#125; maxstairs = max(maxstairs, end - bottom); bottom = ++end; &#125; return maxstairs; &#125;&#125;; 当时莫名其妙的不想对 special 这个数组做修改，就另外拷贝了一个，现在删掉拷贝：12345678910111213141516171819202122class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); sort(special.begin(), special.end()); if(special[size - 1] != top) &#123; special.push_back(top + 1); size++; &#125; int maxstairs = 0; for(int i = 0; i &lt; size &amp;&amp; bottom &lt; top; i++) &#123; int end = special[i]; if(end == bottom) &#123; bottom++; continue; &#125; maxstairs = max(maxstairs, end - bottom); bottom = ++end; &#125; return maxstairs; &#125;&#125;; 实际上，可以将 bottom - 1 和 top + 1 也放在数组内，一起进行排序，这样就不用单独考虑 top 了。1234567891011121314class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; special.push_back(bottom - 1); special.push_back(top + 1); sort(special.begin(), special.end()); int n = special.size(); int maxstairs = 0; for(int i = 0; i &lt; n - 1; i++) &#123; maxstairs = max(maxstairs, special[i + 1] - special[i] - 1); &#125; return maxstairs; &#125;&#125;; 2275. Largest Combination With Bitwise AND Greater Than ZeroAnalysis题意是选取给定数组中的数，要求这些数按位与后的结果大于 0，返回最长组合的长度。实际上，要想按位与的结果不为 0，那么只需要保证最后的结果某一位不为 0 即可。换句话说，最长组合的中的所有数字肯定在某个 bit 上都是 1，这样才能保证最后的结果不为 0。按照这个思路，分别统计每一位上不为 0 的数字个数，个数最多的就是需要返回的结果。可惜这个题，当时没做出来，可能是想太多了，或者还是对位运算的理解不够深刻。 Code1234567891011121314151617class Solution &#123;public: int largestCombination(vector&lt;int&gt;&amp; candidates) &#123; int cnt[24] = &#123;0&#125;; int n = candidates.size(); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; 24; j++) &#123; if((1 &lt;&lt; j) &amp; candidates[i]) cnt[j]++; &#125; &#125; int ret = 0; for(int i = 0; i &lt; 24; i++) &#123;w reerv ret = max(ret, cnt[i]); &#125; return ret; &#125;&#125;; 2276. Count Integers in IntervalsAnalysis这个题还是跟区间相关的题目，不过比第二个题复杂了一些。当时读题的时候，没搞懂count这个函数到底是什么意思，主要是没读懂Returns the number of integers that are present in at least one interval。事后看了题解才发现，就是当前区间内数的个数。所以这个值可以单独用一个变量来进行记录，并在每次调用add函数的时候，更新这个值。不过，思考这个题确实需要线段树的相关知识。 Code12345678910111213141516171819202122232425class CountIntervals &#123; int cnt = 0; set&lt;pair&lt;int, int&gt;&gt; st;public: CountIntervals() &#123; &#125; void add(int left, int right) &#123; int l = left, r = right; auto it = st.lower_bound(&#123;left - 1, -2e9&#125;); while(it != st.end() &amp;&amp; it-&gt;second &lt;= right) &#123; l = min(l, it-&gt;second); r = max(r, it-&gt;first); cnt -= it-&gt;first - it-&gt;second + 1; st.erase(it++); &#125; cnt += r - l + 1; st.insert(&#123;r, l&#125;); &#125; int count() &#123; return cnt; &#125;&#125;; 姑且算是理解了这种做法了，得在做几个类似的题加深一下印象。 Summary得再开一个学习计划了~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 78 场双周赛]]></title>
    <url>%2F2022%2F05%2F25%2FLeetcode-%E7%AC%AC-78-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上上周的双周赛~过 2 个题就谢天谢地了😂... 2269. Find the K-Beauty of a NumberAnalysis题目意思稍微有点绕，当时做的时候感觉中文的题干好像读不通顺😂。总之，理解起来花了点时间...首先要把 num 当作字符串，然后再找出字符串 num 中长度为 k 且能整除 num 的子串，返回这些子串的个数。然后还有两个限制条件： 允许有前缀 0。 0 不能整除任何值。 第一个条件看示例很容易明白，第二个也是常识。 Code竞赛做的时候，这个题 WA 了两次，一是题目没理解清楚就开始做了，二是有点着急了，写好了就直接提交，没有自己编个样例试试...这是当时提交通过的代码：12345678910111213class Solution &#123;public: int divisorSubstrings(int num, int k) &#123; string str = to_string(num); int len = str.length(), ret = 0; for(int i = 0; i &lt;= len - k; i++) &#123; string tmp = str.substr(i, k); int t = stoi(tmp); if(t != 0 &amp;&amp; num % t == 0) ret++; &#125; return ret; &#125;&#125;; 不管怎么说，WA 两次真是不应该。另外，这个题也可以从数学角度思考，依次从 num 的末尾取下 k 位数字组成整数进行判断即可。1234567891011class Solution &#123;public: int divisorSubstrings(int num, int k) &#123; long long ret = 0, mask = pow(10, k); for(int x = num; x &gt;= mask / 10; x /= 10) &#123; int tmp = x % mask; if(tmp != 0 &amp;&amp; num % tmp == 0) ret++; &#125; return ret; &#125;&#125;; 2270. Number of Ways to Split ArrayAnalysis这个题一看就是前缀和的题目...可惜又 WA 了一次...WA 的原因是前缀和数组用的int，应该要用long long。实际上，这是第二次在周赛上做前缀和的题目犯这个错误了...思路就是算出前缀和，然后依次判断即可。 Code这是当时提交通过的代码：12345678910111213141516171819class Solution &#123;public: int waysToSplitArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;long long&gt; prefixsum(size); int ret = 0; prefixsum[0] = nums[0]; for(int i = 1; i &lt; size; i++) &#123; prefixsum[i] = prefixsum[i - 1] + nums[i]; &#125; for(int i = 0; i &lt; size; i++) &#123; if(i &lt; size - 1 &amp;&amp; prefixsum[i] &gt;= (prefixsum[size - 1] - prefixsum[i])) &#123; ret++; cout &lt;&lt; prefixsum[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; &#125; &#125; return ret; &#125;&#125;; 虽然可以通过，但是代码思路不够清晰，改一下：12345678910111213class Solution &#123;public: int waysToSplitArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), ret = 0; long long left = 0, right = accumulate(nums.begin(), nums.end(), 0LL); for(int i = 0; i &lt; size - 1; i++) &#123; left += nums[i]; right -= nums[i]; if(left &gt;= right) ret++; &#125; return ret; &#125;&#125;; 2271. Maximum White Tiles Covered by a CarpetAnalysis题意很清晰，返回盖住最多的瓷砖数目。换成数学语言就是，如何让更多的符合条件的数（瓷砖）落在区间长度为 carpetlen 的区间中。这个题想了挺久的，理解清楚题目意思后，就感觉这是个区间贪心的问题，但是没做过类似的问题...还是题做少了。 Code这个题的思路是排序 + 滑动窗口 + 贪心：1234567891011121314151617class Solution &#123;public: int maximumWhiteTiles(vector&lt;vector&lt;int&gt;&gt;&amp; tiles, int carpetLen) &#123; sort(tiles.begin(), tiles.end()); long long now = 0, ans = 0; for(int i = 0, j = 0; i &lt; tiles.size(); i++) &#123; while(j &lt; tiles.size() &amp;&amp; tiles[j][1] + 1 - tiles[i][0] &lt;= carpetLen) &#123; now += tiles[j][1] - tiles[j][0] + 1; j++; &#125; if(j &lt; tiles.size()) ans = max(ans, now + max(0, tiles[i][0] + carpetLen - tiles[j][0])); else ans = max(ans, now); now -= tiles[i][1] - tiles[i][0] + 1; &#125; return ans; &#125;&#125;; 大致过程是枚举瓷砖区间，不超过毯子长度的情况下，将尽可能多的瓷砖放入毯子下，整个窗口的大小就是毯子的长度。当最后一块瓷砖只能部分放入毯子下时，需要单独加上这部分长度。上面的思路是从瓷砖区间的右端点来思考的，也可以从瓷砖区间的左端点来思考：12345678910111213141516class Solution &#123;public: int maximumWhiteTiles(vector&lt;vector&lt;int&gt;&gt;&amp; tiles, int carpetLen) &#123; sort(tiles.begin(), tiles.end()); long long now = 0, ans = 0, left = 0; for(auto &amp;v: tiles) &#123; now += v[1] - v[0] + 1; while(tiles[left][1] &lt; v[1] - carpetLen + 1) &#123; now -= tiles[left][1] - tiles[left][0] + 1; left++; &#125; ans = max(ans, now - max(v[1] - carpetLen + 1 - tiles[left][0], 0)); &#125; return ans; &#125;&#125;; 虽然这个思路简洁一些，但是感觉要难想一些。 2272. Substring With Largest VarianceAnalysis题目还算直接，就是求子串中出现次数最多与最少的字符的次数差。很容易想到暴力解法，枚举每一个子串，再统计其中出现的次数，作差即可。借助 map，暴力解法的时间复杂度应该是 $O(n^2log\Sigma)$，数据范围是 $10^4$，多半是要超时。实际上，当时看到这个题目第一反应就是字符串和 dp 的结合题，不过还是把暴力的思路写下来了。 Code这是当时提交的暴力代码：1234567891011121314151617181920class Solution &#123;public: int largestVariance(string s) &#123; int len = s.length(); int maxlv = INT_MIN; for(int i = 0; i &lt; len; i++) &#123; unordered_map&lt;char, int&gt; cnt; for(int j = i; j &lt; len; j++) &#123; cnt[s[j] - 'a']++; int maxappear = INT_MIN, minappear = INT_MAX; for(auto &amp;[c, i]: cnt) &#123; if(i &gt; maxappear) maxappear = i; if(i &lt; minappear) minappear = i; &#125; maxlv = max(maxlv, maxappear - minappear); &#125; &#125; return maxlv; &#125;&#125;; 当时没有借助 map，用的是 unordered_map，时间复杂度是 $O(n^2\Sigma)$，所以还是得想办法用 dp。看了下大佬的题解，发现这个题的难点在问题的理解与转化上。按照题意，最大波动值只有 2 个字符（一个出现的次数最多，一个出现的次数最少）决定，至于是哪两种，没办法直接确定，所有的可能共有 $26 \times 25 = 650$ 种。假设枚举到了组合（a，b）（并不是&#39;a&#39;和b），在子串中，将 a 看作是 1，b 看作是 -1，其他字符看作 0，问题就转化为求这个数组最大的连续子列和。在整个枚举的过程中，还需要注意字符 a 和 b 都必须出现在子字符串中，不能将只包含字符 a 或 b 的子字符串作为答案。同时，用一个变量 diff 来记录字符 a 和字符 b 出现次数之差，初始值为 0，再用另一个变量 diff_with_b 来记录 b 是否出现和 a、b 出现次数之差，初始化为负无穷。1234567891011121314151617181920212223class Solution &#123;public: int largestVariance(string s) &#123; int ans = 0; for(char a = 'a'; a &lt;= 'z'; a++) &#123; for(char b = 'a'; b &lt;= 'z'; b++) &#123; if(a == b) continue; int diff = 0, diff_with_b = -s.length(); for(char c: s) &#123; if(c == a) &#123; diff++; diff_with_b++; &#125; else if(c == b) &#123; diff_with_b = --diff; diff = max(diff, 0); &#125; ans = max(ans, diff_with_b); &#125; &#125; &#125; return ans; &#125;&#125;; 将 $s[i]$ 当作字符 a 和 b，还可以进一步优化时间复杂度：1234567891011121314151617181920class Solution &#123;public: int largestVariance(string s) &#123; int ans = 0; int diff[26][26] = &#123;0&#125;, diff_with_b[26][26]; memset(diff_with_b, 0x80, sizeof(diff_with_b)); for(char ch: s) &#123; ch -= 'a'; for(int i = 0; i &lt; 26; i++) &#123; if(i == ch) continue; diff[ch][i]++; diff_with_b[ch][i]++; diff_with_b[i][ch] = --diff[i][ch]; diff[i][ch] = max(diff[i][ch], 0); ans = max(ans, max(diff_with_b[ch][i], diff_with_b[i][ch])); &#125; &#125; return ans; &#125;&#125;; 这个优化有点没看懂... Summary得整个专题训练下...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 292 场周赛]]></title>
    <url>%2F2022%2F05%2F21%2FLeetcode-%E7%AC%AC-292-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[上上周的周赛了...一如既往的双题选手...每次复盘都要拖好久🤐 2264. Largest 3-Same-Digit Number in StringAnalysis找出子串中最大的 3 位数，且这个 3 位数，必须各数位相等。 Code当时提交的代码：1234567891011121314class Solution &#123;public: string largestGoodInteger(string num) &#123; vector&lt;string&gt; nums; int len = num.length(); for(int i = 0; i &lt; len - 2; i++) &#123; if(num[i] == num[i + 1] &amp;&amp; num[i] == num[i + 2]) nums.push_back(num.substr(i, 3)); &#125; int size = nums.size(); sort(nums.begin(), nums.end()); if(size == 0) return ""; else return nums[size - 1]; &#125;&#125;; 现在再看，写的麻烦了一点，改简单一点：1234567891011121314class Solution &#123;public: string largestGoodInteger(string num) &#123; string ans = ""; int len = num.length(); for(int i = 0; i &lt; len - 2; i++) &#123; if(num[i] == num[i + 1] &amp;&amp; num[i] == num[i + 2]) &#123; string tmp = num.substr(i, 3); if(tmp &gt; ans) ans = tmp; &#125; &#125; return ans; &#125;&#125;; 2265. Count Nodes Equal to Average of SubtreeAnalysis统计出所有结点的值与以对应结点为根结点的树的结点值之和的平均值相等的结点数目...读起来相当拗口，不过题目意思就是如此。 Code当时做的时候没什么好想法，就是把所有结点构成的树的结点和都算出来，求出平均值，再进行比较，这样做时间复杂度很高，勉强通过。这是当时提交的代码：1234567891011121314151617181920212223242526class Solution &#123;public: int averageOfSubtree(TreeNode* root) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; queue&lt;TreeNode*&gt; q1; q1.push(root); int cnt = 0; while(!q1.empty()) &#123; TreeNode *node = q1.front(); q1.pop(); queue&lt;TreeNode*&gt; q2; q2.push(node); int sum = 0, nodecnt = 0; while(!q2.empty()) &#123; TreeNode *tmp = q2.front(); q2.pop(); sum += tmp-&gt;val; nodecnt++; if(tmp-&gt;left) q2.push(tmp-&gt;left); if(tmp-&gt;right) q2.push(tmp-&gt;right); &#125; if(sum / nodecnt == node-&gt;val) cnt++; if(node-&gt;left) q1.push(node-&gt;left); if(node-&gt;right) q1.push(node-&gt;right); &#125; return cnt; &#125;&#125;; 遍历思路是 bfs 的思路，用 dfs 也能实现类似的思路，不再写了。现在要考虑一下，能不能边计算，边判定。从题目的示例来分析，所有的叶子结点都是满足条件的，非叶子结点才需要判定。而完成判定需要两个条件，一是知道以当前结点为子树的结点值之和，而是这颗子树的结点总数。按照 dfs 的思路，如果一开始判断的是叶结点，然后再将值返回给非叶结点，这样就不用重复计算了。也就是说，每次需要返回两个值，一个是子树所有结点值之和，而是结点的数量。1234567891011121314151617181920class Solution &#123;public: pair&lt;int, int&gt; dfs(TreeNode *root, int &amp;ans) &#123; if(root == nullptr) &#123; return &#123;0, 0&#125;; &#125; pair&lt;int, int&gt; left, right; left = dfs(root-&gt;left, ans); right = dfs(root-&gt;right, ans); int sum = left.first + right.first + root-&gt;val; int cnt = left.second + right.second + 1; if(sum / cnt == root-&gt;val) ans++; return &#123;sum, cnt&#125;; &#125; int averageOfSubtree(TreeNode* root) &#123; int ans = 0; dfs(root, ans); return ans; &#125;&#125;; 注意在 averageOfSubtree 这个函数中，忽略掉了 dfs 的返回值，实际项目中可别这样写。回头再看这个题目，dfs 的思路跟后序遍历很像，整体的思路跟树形 dp 也很像。 2266. Count Number of TextsAnalysis题目信息有点多，大致意思就是给一串代表九宫格键盘按键顺序的字符串，算出这个字符串可以被解码成多少种可能。 Code这个题当时想了挺久的，但是没想出来，属于是有思路，但是思路又不是那么完全的那种题目。当时的思路是，按照数字分类，也就是 7 和 9 一类，剩下的一类，然后分割字符串，一个一个找出所有的连续且字符都相等的子串。因为 7 和 9 最多按 4 下，其他数字最多按 3 下，所以计算出对应的可能，然后依次乘起来，就是总的可能数，同时别忘了取余。但是，看到示例 2 又想到了数字可能出现很多次，那这样统计就不对了，思路就搁浅了... 看了下别人的题解，发现这是个字符串和 dp 结合的题（完全没往 dp 上想...），数字需要分类的想法倒是没错。其实，当时思考这个题的时候，应该察觉到了前面的选择会影响后面的选择，这也就是 dp 的特点。这个人的题解把这个题的 dp 思路说的很清楚，这里不赘述了。123456789101112131415161718192021222324class Solution &#123;public: int countTexts(string pressedKeys) &#123; int mod = 1e9 + 7; int len = pressedKeys.length(); vector&lt;long long&gt; dp(len); dp[0] = 1; for(int i = 1; i &lt; len; i++) &#123; dp[i] = dp[i - 1]; if(pressedKeys[i] == pressedKeys[i - 1]) &#123; dp[i] += i &gt;= 2 ? dp[i - 2] : 1; if(i &gt;= 2 &amp;&amp; pressedKeys[i] == pressedKeys[i - 2]) &#123; dp[i] += i &gt;= 3 ? dp[i - 3] : 1; if((pressedKeys[i] == '7' || pressedKeys[i] == '9') &amp;&amp; i &gt;= 3 &amp;&amp; pressedKeys[i] == pressedKeys[i - 3]) &#123; dp[i] += i &gt;= 4 ? dp[i - 4] : 1; &#125; &#125; &#125; dp[i] %= mod; &#125; return dp[len - 1]; &#125;&#125;; 回头再看这道题，首先的问题是没意识到是 dp，再者就是这个状态转移方程可能写不出来，原因可能是没做过类似的字符串 + dp 的题（上周那个困难题还没搞懂啊...）。仔细想想，这个题的 dp 思路与跳台阶、青蛙过河本质上是一样的，都是一维 dp 的思路，只是这个题需要考虑一下字符的不同情况。再回到题目中，上面的思路中，$dp[i]$ 代表的就是以 $pressedKeys[i]$ 结尾的可能数，这样做可能会使 $dp[i - k], k = 2, 3, 4$ 不存在。所以需要将 $dp[i]$ 的定义修改成以 $pressedKeys[i - 1]$ 结尾的可能数，就可以避开这个问题了，这个细节，以后思考 dp 类问题的时候千万不要忘了。123456789101112131415161718192021222324class Solution &#123;public: int countTexts(string pressedKeys) &#123; int mod = 1e9 + 7; int len = pressedKeys.length(); vector&lt;long long&gt; dp(len + 1); dp[0] = 1, dp[1] = 1; for(int i = 2; i &lt;= len; i++) &#123; dp[i] = dp[i - 1]; if(pressedKeys[i - 1] == pressedKeys[i - 2]) &#123; dp[i] += dp[i - 2]; if(i &gt;= 3 &amp;&amp; pressedKeys[i - 1] == pressedKeys[i - 3]) &#123; dp[i] += dp[i - 3]; if((pressedKeys[i - 1] == '7' || pressedKeys[i - 1] == '9') &amp;&amp; i &gt;= 4 &amp;&amp; pressedKeys[i - 1] == pressedKeys[i - 4]) &#123; dp[i] += dp[i - 4]; &#125; &#125; &#125; dp[i] %= mod; &#125; return dp[len]; &#125;&#125;; 类似的，一维 dp 还可以通过滚动数组的思想来解决，就不写了... 最后一个题，又要想很久了，明天再写... 又拖了几天~ 2267. Check if There Is a Valid Parentheses String PathAnalysis同样是能读懂题意，但是不知道如何下手的题目...只能学习一下大佬们的思路了。 Code参考思路：DP。123456789101112131415161718192021222324252627class Solution &#123;public: bool hasValidPath(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if(grid[0][0] == ')') return false; int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; f; for(int i = 0; i &lt; n; i++) &#123; f.push_back(vector&lt;vector&lt;bool&gt;&gt;()); for(int j = 0; j &lt; m; j++) &#123; f.back().push_back(vector&lt;bool&gt;(n + m)); &#125; &#125; f[0][0][1] = true; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; int t = grid[i][j] == '(' ? 1 : -1; for(int k = 0; k &lt; n + m; k++) &#123; int kk = k - t; if(kk &lt; 0 || kk &gt;= n + m) continue; if(i &gt; 0) f[i][j][k] = f[i][j][k] || f[i - 1][j][kk]; if(j &gt; 0) f[i][j][k] = f[i][j][k] || f[i][j - 1][kk]; &#125; &#125; &#125; return f[n - 1][m - 1][0]; &#125;&#125;; 这种三维 dp 的思路可太强了，就是有点没理解... Summary发现一个问题：虽然参加周赛挺好玩的，但是每次后面 2 个难一点的题做不出来，事后看题解，感觉学习效果不是很好？？？得把时间集中在专题训练上才行...😐]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《美丽的梭罗河》简易吉他谱]]></title>
    <url>%2F2022%2F05%2F20%2F%E3%80%8A%E7%BE%8E%E4%B8%BD%E7%9A%84%E6%A2%AD%E7%BD%97%E6%B2%B3%E3%80%8B%E7%AE%80%E6%98%93%E5%90%89%E4%BB%96%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[这是原来扒的歌，是黄秋生在电影《太阳照常升起》演唱的版本... 这几天突然又想起了这首歌，记得原来扒这个歌的时候，纯靠耳朵听和别人提示的和弦走向，才把大致的指法弄清楚。现在，补充了一定的乐理后，不知道是不是又会对这首歌有不同的看法呢？所以，就再来研究一下这首歌。 原版电影片段： 简易谱：12345678910111213141516171819 美丽的梭罗河1 = GTempo 4/4 G G G美 丽 的 梭 罗 河，我 为 你 歌 唱！G D D7 G你 的 光 荣 历 史，我 永 远 记 在 心 上。G G G G G D D7 G 旱 季 来 临，你 轻 轻 流 淌，雨 季 时，波 涛 滚 滚，你 流 向 远 方。G C D G A A A D D 你 的 船 员 来 自 梭 罗，万 重 山 送 你 一 路 前 往，滚 滚 的 波 涛 流 向 远 方，一 直 流 入 海 洋。G G G G G D D7 G 你 的 历 史，就 是 一 只 船，商 人 们 乘 船 远 航 在 美 丽 的 河 面 上。G C D G A A A D D(arpeggio) 你 的 船 员 来 自 梭 罗，万 重 山 送 你 一 路 前 往，滚 滚 的 波 涛 流 向 远 方，一 直 流 入 海 洋。 G G G美 丽 的 梭 罗 河，我 为 你 歌 唱！G D D7 G G(arpeggio)你 的 光 荣 历 史，我 永 远 记 在 心 上。 说明： 右手指法就是常见的 4/4 拍的分解和弦伴奏指法，也即 T3231323。 谱子中存在很多 G 和 A，实际弹的时候，有的是原位和弦，有的是该和弦的第二转位。比如第一句歌词的 G，其实都是 G/D，也就是 G 的第二转位（G 和弦的组成音是 G B D），对应的，此时的 T 表示的就是 4 弦。当然，按照 63231323 来弹也行，就是听着不是很和谐。 这个歌有很多地方是从反拍开始唱的。 整首歌的和弦走向大概是：G -&gt; D -&gt; D7 -&gt; G 和 G -&gt; C -&gt; D -&gt; G -&gt; A -&gt; D -&gt; G。前一个和弦走向是编配的经典套路，主和弦直接到属和弦，再过渡到属七和弦，最后回到主和弦。后一个和弦走向有一个奇怪的地方，就是 A 和弦不是 G 大调的顺阶和弦。但黄 sir 还是这么弹了，原因应该是因为这一段的旋律音全部是 re，如果用 Am 听起来就很怪（尽管 Am 是 G 大调的顺阶和弦），而用 A 这个大三和弦听起来就会和谐很多， 虽然这首歌是印尼的民谣，但是听的时候，想的全是 long river 和 yellow river。电影中，黄 sir 的唱法很符合现代人的听觉感受，但是与当时背景下的唱法是天差地别的。对于姜导想要表达什么东西，已经不想去深究了。但借着这首歌，胸中升起的是对脚下这块“土地”又爱又恨的矛盾情感... 扯远了。总之，这首歌很适合初学者练习，毕竟指法很简单，也没有横按，唯一的难点应该是在弹唱配合上。作为扒歌的初级练习，也挺合适的，和弦走向简单，都是常用的一些和弦，比较容易分辨。]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day20]]></title>
    <url>%2F2022%2F05%2F19%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day20%2F</url>
    <content type="text"><![CDATA[最后一天~3 个设计题... 380. Insert Delete GetRandom O(1)Analysis这个好像在每日一题做过...题目要求实现一个叫随机集合的类，同时要求每个函数的时间复杂度都是$O(1)$。 Codeconstructor先思考一下实现这个类的底层数据结构是什么。因为题目要求插入、删除都是$O(1)$，所以必须要借助哈希表，那存储数据用 vector 就可以了。同时，因为题目还要求能以等概率取到所有的数，所以在构造函数内，需要生成一下随机数种子。123456789class RandomizedSet &#123;public: RandomizedSet() &#123; srand((unsigned)time(NULL)); &#125;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; indices;&#125;; insert哈希表直接保存元素的在 vector 中的下标，如果哈希表内已经存在这个元素，就不再进行插入操作了。1234567bool insert(int val) &#123; if(indices.count(val)) return false; int index = nums.size(); nums.push_back(val); indices[val] = index; return true;&#125; remove为了避免删除 vector 中的元素后要移动元素，每次删除元素前，先将最末尾的元素移动到要删除的元素位置，然后再删除这个元素。当然，这里说的删除，实际上都不是真正意义上的删除，这点与磁盘的工作原理是类似的。12345678910bool remove(int val) &#123; if(!indices.count(val)) return false; int index = indices[val]; int last = nums.back(); nums[index] = last; indices[last] = index; nums.pop_back(); indices.erase(val); return true;&#125; getRandom构造函数内已经生成了随机数种子，这里直接用就可以了。1234int getRandom() &#123; int randomindex = rand() % nums.size(); return nums[randomindex];&#125; Summary123456789101112131415161718192021222324252627282930313233class RandomizedSet &#123;public: RandomizedSet() &#123; srand((unsigned)time(NULL)); &#125; bool insert(int val) &#123; if(indices.count(val)) return false; int index = nums.size(); nums.push_back(val); indices[val] = index; return true; &#125; bool remove(int val) &#123; if(!indices.count(val)) return false; int index = indices[val]; int last = nums.back(); nums[index] = last; indices[last] = index; nums.pop_back(); indices.erase(val); return true; &#125; int getRandom() &#123; int randomindex = rand() % nums.size(); return nums[randomindex]; &#125;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; indices;&#125;; 622. Design Circular QueueAnalysis又是一堆题目说明，实际上就是设计循环队列，只是在一些地方与普通队列有所差别。 Codeconstructor类似普通队列，底层数据结构用 vector 就可以了，同时需要有两个指针 front 和 rear，分别指向队首和队尾元素。在构造函数里面，初始化这两个指针，顺便设置数组的容量为k + 1。1234567891011class MyCircularQueue &#123;public: MyCircularQueue(int k) &#123; maxsize = k + 1; data.resize(maxsize); front = rear = -1; &#125;private: vector&lt;int&gt; data; int front, rear, maxsize;&#125;; isEmpty考虑其他函数之前，先思考如何判断队列为空和满。很容易想到的是，当首尾指针相等时，队列就为空了。123bool isEmpty() &#123; return front == rear;&#125; isFull与判空一样，当首尾指针相等时，也会出现队列满的情况。所以为了区分这两种情况，就需要 vector 内空一个位置当作标志位，来判断是否队满。123bool isFull() &#123; return (rear + 1) % maxsize == front;&#125; enQueue入队时，移动队尾指针，先判断队列是否为满，然后放入元素或者返回false。123456bool enQueue(int value) &#123; if(isFull()) return false; rear = (rear + 1) % maxsize; data[rear] = value; return true;&#125; 注意，这里是先移动指针在放入元素。 deQueue出队时，移动队首指针，先判断队列是否为空，然后移动队首指针即可。12345bool deQueue() &#123; if(isEmpty()) return false; front = (front + 1) % maxsize; return true;&#125; Front先判空，然后取元素。由于入队时，是先移动指针，所以这里也取的是front指针的下一个位置。1234int Front() &#123; if(isEmpty()) return -1; return data[(front + 1) % maxsize];&#125; Rear先判断空，然后取元素。由于入队时已经移动过指针了，所以rear指向的就是队尾的元素，直接返回即可。1234int Rear() &#123; if(isEmpty()) return -1; else return data[rear];&#125; 在这里可以看出，如果入队时先放入元素，在移动指针，可能会无法直接通过rear来找到队尾元素。按照先放入元素在移动指针的思路，当rear为 0、front不为 0 时，队尾元素在数组的末尾，好像没办法直接通过取余来得到队尾元素的指针...解决方法就是特判一下，然后用front来寻找队尾元素，所以不如直接先移动指针，在放入元素，再移动指针。 Summary123456789101112131415161718192021222324252627282930313233343536class MyCircularQueue &#123;public: MyCircularQueue(int k) &#123; maxsize = k + 1; data.resize(maxsize); front = rear = 0; &#125; bool enQueue(int value) &#123; if(isFull()) return false; rear = (rear + 1) % maxsize; data[rear] = value; return true; &#125; bool deQueue() &#123; if(isEmpty()) return false; front = (front + 1) % maxsize; return true; &#125; int Front() &#123; if(isEmpty()) return -1; return data[(front + 1) % maxsize]; &#125; int Rear() &#123; if(isEmpty()) return -1; else return data[rear]; &#125; bool isEmpty() &#123; return front == rear; &#125; bool isFull() &#123; return (rear + 1) % maxsize == front; &#125;private: vector&lt;int&gt; data; int front, rear, maxsize;&#125;; 729. My Calendar IAnalysis感觉这是一个跟区间相关的题目... Codemethod 1底层就用 vector，日期是一对一对出现的，所以直接用 pair 即可。12345678class MyCalendar &#123;public: MyCalendar() &#123; &#125;private: vector&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; 不造成重复预订的条件是开始日期和结束日期都不会被占用，所以可以直接判断。1234567bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(!(start &gt;= e || end &lt;= s)) return false; &#125; calendar.push_back(make_pair(start, end)); return true;&#125; 做一下逻辑运算，化简一下判断条件，就是：1234567bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(start &lt; e &amp;&amp; end &gt; s) return false; &#125; calendar.push_back(make_pair(start, end)); return true;&#125; 最后合并到一起：123456789101112131415class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(start &lt; e &amp;&amp; end &gt; s) return false; &#125; calendar.push_back(make_pair(start, end)); return true; &#125;private: vector&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; method 2注意到，如果预订的日期是按照时间顺序来排序的话，再插入下一个日期时，就可以用二分查找，来寻找合理的插入位置了。123456789101112131415161718192021222324252627282930313233343536class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; if(calendar.size() == 0) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else &#123; auto pos = calendar.lower_bound(make_pair(start, 0)); if(pos == calendar.end()) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else if(pos == calendar.begin()) &#123; if(pos-&gt;first &gt;= end) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else &#123; if(pos-&gt;first &gt;= end) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else return false; &#125; &#125; &#125;private: set&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; 简化一下：123456789101112131415161718192021222324252627282930313233343536class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; if(calendar.size() == 0) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else &#123; auto pos = calendar.lower_bound(&#123;start, 0&#125;); if(pos == calendar.end()) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else if(pos == calendar.begin()) &#123; if(pos-&gt;first &gt;= end) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else &#123; if(pos-&gt;first &gt;= end) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else return false; &#125; &#125; &#125;private: set&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; 不过这样写二分实在是不太美观...实际上，要考虑的情况也不需要这么多...换用 map 来保存，用 end 来进行二分查找，找到的元素的 start 一定大于等于 end 的。此时，要判断的是，这个元素之前的 end 是否小于等于要插入的元素的 start，满足，那就直接插入即可。因为 map 是有序（以 key 为排序依据，这里就是每个元素的 start）的，所以这个元素就可以被插入在这里。12345678910111213141516class MyCalendar &#123;public: MyCalendar() &#123; calendar[-1] = -1; &#125; bool book(int start, int end) &#123; auto pos = calendar.lower_bound(end); if((--pos)-&gt;second &lt;= start) &#123; calendar[start] = end; return true; &#125; return false; &#125;private: map&lt;int, int&gt; calendar;&#125;; Summary设计的题目，感觉做起来有点无聊...哈，这个学习计划完成了，倒是个让人觉得轻松的事情。不过，不是很熟悉二分的应用，需要练习一下。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day19]]></title>
    <url>%2F2022%2F05%2F18%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day19%2F</url>
    <content type="text"><![CDATA[倒数第二天~ 1797. Design Authentication ManagerAnalysis这种设计类得题目都这么长的吗？实际问题不复杂，理解题意要想半天...话说回来，这个题实际上是个散列题，需要用一个变量timetolive来记录验证码的“存活”时间，同时，利用 map 来保存验证码与其对应的“死亡”时刻（注意这里是时刻），也就是currentTime + timetolive。最后要注意的一点是过期事件优先于其他操作，也就是说在t = 10，某个验证码“死亡”了，同时对这个验证码执行renew操作，此时不会改变任何东西。 Code1234567891011121314151617181920212223242526class AuthenticationManager &#123; unordered_map&lt;string, int&gt; ht; int timetolive;public: AuthenticationManager(int timeToLive) &#123; timetolive = timeToLive; &#125; void generate(string tokenId, int currentTime) &#123; ht[tokenId] = currentTime + timetolive; &#125; void renew(string tokenId, int currentTime) &#123; if(ht.count(tokenId) != 0 &amp;&amp; ht[tokenId] &gt; currentTime) &#123; ht[tokenId] = currentTime + timetolive; &#125; &#125; int countUnexpiredTokens(int currentTime) &#123; int cnt = 0; for(auto &amp;[_, time]: ht) &#123; if(time &gt; currentTime) cnt++; &#125; return cnt; &#125;&#125;; 707. Design Linked ListAnalysis实现链表，em，老生常谈的问题，不过要实现的函数太多，最好分开思考。首先应该明确题目的要求： 链表结点具有两个属性：val 和 next。 链表结点的下标是从 0 开始的。 Code总共要实现 5 个函数，先大致分析一下每个函数如何实现： 获取第 index 个结点的值，这个直接遍历链表就可以得到，所以需要有链表的头指针。 链表的第一个元素之前添加结点，同样需要头指针。 链表的最后一个元素之后添加结点，可以从头遍历到尾，也可以直接用尾指针解决。 第 index 个结点之前添加结点，遍历链表，然后插入即可，需要头指针。 删除第 index 个结点，遍历链表，删除即可。 按照对函数的分析，选择用带头（哑）结点和尾指针的方式来完成这个链表。 constructor首先是结点的构造以及对应的构造函数的书写，这里的原则是怎么方便怎么来😂。1234567891011121314151617class MyLinkedList &#123;public: struct ListNode &#123; int val; ListNode *next; ListNode(int val): val(val), next(nullptr)&#123;&#125;; &#125;; MyLinkedList()&#123; size = 0; dummyhead = new ListNode(0); tail = dummyhead; &#125;private: int size; ListNode *dummyhead; ListNode *tail;&#125; 注意私有成员得写在后面，因为ListNode的声明（declaration）和定义（definition）在 public 里面。不过，如果想要写在前面应该也能用 typedef 来完成吧？懒得尝试了...多写一个ListNode的构造函数，这样方便新建结点，同时MyLinkedList的构造函数也需要初始化当前链表的哑结点、尾指针和结点总数了。 addAtHead先思考 addAtHead 函数的写法，因为有了哑结点，所以在这个位置插入就很简单：123456void addAtHead(int val) &#123; ListNode *newnode = new ListNode(val); newnode-&gt;next = dummyhead-&gt;next; dummyhead-&gt;next = newnode; size++;&#125; 但是这里有一个问题，那就是尾指针是否会受到影响。显然，如果是第一个结点插入，那么尾指针同时也需要变成指向第一个结点。那如果插入第二个结点呢？当然就不需要在改变尾指针了。1234567void addAtHead(int val) &#123; ListNode *newnode = new ListNode(val); newnode-&gt;next = dummyhead-&gt;next; dummyhead-&gt;next = newnode; size++; if(size == 1) tail = newnode;&#125; addAtTail再来思考如何在尾部插入结点。与前面的思考一样，因为有了尾指针，所以就很容易的在尾部插入结点了：123456void addAtTail(int val) &#123; ListNode *newnode = new ListNode(val); tail-&gt;next = newnode; tail = newnode; size++;&#125; addAtIndex按照题目的解释，当 index 等于链表长度时，直接在末尾插入结点；当 index 大于链表长度时，当作输入的错误，忽略掉即可；当 index 小于 0 时，在头部插入；当 index 大于 0 小于 index 时，在链表中间插入结点。对应的，针对这 4 种情况： 直接在尾部插入。 忽略。 直接在头部插入结点。 先找到要插入的位置的前一个结点，然后插入结点。 1234567891011121314void addAtIndex(int index, int val) &#123; if(index &gt; size) return; ListNode *newnode = new ListNode(val); if(index == size) &#123; tail-&gt;next = newnode; tail = newnode; &#125; else &#123; ListNode *cur = dummyhead; while(index--) cur = cur-&gt;next; newnode-&gt;next = cur-&gt;next; cur-&gt;next = newnode; &#125; size++; &#125; 实际上，这个题并没有给 index 小于 0 的情况，所以就直接这么写了。看了下评论区，当时好像是给了的，结果被太多人吐槽，就删除了吧😂？不过，题目本身就说了 index 是从 0 开始的，出现负数确实可以当作错误的输入给 pass 掉。虽然，题目也对这个函数的功能进行了解释，但是感觉不对负数做处理，才是正常人的思考模式🤔？ 另外，因为有哑结点的存在，所以寻找插入位置时，直接从哑结点开始，这样当 index 为 0，找到的结点，就是要插入位置的前一个结点。还要注意的一个地方是在尾部插入结点后，一定要记得修改尾指针。 get获取链表中第 index 个结点的值，直接遍历链表即可。由于保存了链表当前的结点总数，所以在查找前可以简单判断一下。123456int get(int index) &#123; if(index &lt; 0 || index &gt; size - 1) return -1; ListNode *cur = dummyhead-&gt;next; while(index--) cur = cur-&gt;next; return cur-&gt;val;&#125; 需要注意的是，这里要返回的是下标为 index 结点的值，所以循环开始时cur得指向第一个真实的结点。 deleteAtIndex同样，删除之前也可以先对 index 进行判断。12345678910void deleteAtIndex(int index) &#123; if(index &lt; 0 || index &gt; size - 1) return; ListNode *cur = dummyhead; while(index--) cur = cur-&gt;next; ListNode *tmp = cur-&gt;next; if(tmp == tail) tail = cur; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; size--;&#125; 删除时，需要寻找的同样是被删除结点的前一个结点，所以循环开始时cur指向哑结点即可。同样，注意当删除的是最后一个结点时，尾指针要改成指向最后一个结点的前驱结点。 Summary跟设计相关的题目的难点不在算法复杂度上，而是在理解题意和如何实现上。特别是第二个题目，有些地方其实交代的不是很清楚。特别是“第 index 个”这种说法，很容易让人产生误解。假如 index 是 3，到底是第 3 个结点呢，还是第 4（0，1，2，3） 个结点呢？当然，这个题目是第 4 个。其实，不管是 3 还是 4，如果在这种问题上耗费太多时间，就没有意义了...尽管这个题把链表的大部分操作都考到了，但是还是觉得有不足的地方。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day18]]></title>
    <url>%2F2022%2F05%2F17%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day18%2F</url>
    <content type="text"><![CDATA[还有两天哦~ 155. Min StackAnalysis实现一个最小栈，相比栈而言，其实就多了一个返回栈内最小值的功能，可以直接用一个变量来记录最小值。 Code底层数据结构就用数组就可以了，用一个变量 tp 作为栈顶指针，再用变量 minimumofstk 记录栈内最小值。123456789101112131415161718192021222324252627282930313233class MinStack &#123; int stk[30010]; int tp, minimumofstk;public: MinStack() &#123; tp = -1; minimumofstk = INT_MAX; &#125; void push(int val) &#123; stk[++tp] = val; if(val &lt; minimumofstk) minimumofstk = val; &#125; void pop() &#123; int tmp = stk[tp--]; if(tp == -1) minimumofstk = INT_MAX; else if(tmp == minimumofstk) &#123; minimumofstk = stk[tp]; for(int i = 0; i &lt; tp; i++) &#123; if(stk[i] &lt; minimumofstk) minimumofstk = stk[i]; &#125; &#125; &#125; int top() &#123; return stk[tp]; &#125; int getMin() &#123; return minimumofstk; &#125;&#125;; 这种思路会有一个问题，那就是每次 pop 操作之后都需要更新最小值（尽管 getMin 操作的确是常数时间内完成的），时间复杂度是$O(n)$。实际上，常数时间内获取最小值的操作可以借助一个辅助栈完成。每次将元素入栈时，都将该元素与辅助栈栈顶元素比较，如果小于，即将该元素放入辅助栈，此时辅助栈栈顶的元素就是主栈内的最小值。1234567891011121314151617181920212223242526class MinStack &#123; stack&lt;int&gt; stk; stack&lt;int&gt; min_stk;public: MinStack() &#123; min_stk.push(INT_MAX); &#125; void push(int val) &#123; stk.push(val); min_stk.push(min(min_stk.top(), val)); &#125; void pop() &#123; stk.pop(); min_stk.pop(); &#125; int top() &#123; return stk.top(); &#125; int getMin() &#123; return min_stk.top(); &#125;&#125;; 341. Flatten Nested List IteratorAnalysis没看懂这题到底什么意思...直接冲向题解区😂。 Code实际上就是树形结构的扁平化，只不过在整个过程中需要借助一下这个类的内部函数。1234567891011121314151617181920212223242526class NestedIterator &#123; vector&lt;int&gt; vals; vector&lt;int&gt;::iterator cur; void dfs(const vector&lt;NestedInteger&gt; &amp;nestedList) &#123; for(auto &amp;nest: nestedList) &#123; if(nest.isInteger()) &#123; vals.push_back(nest.getInteger()); &#125; else &#123; dfs(nest.getList()); &#125; &#125; &#125;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; dfs(nestedList); cur = vals.begin(); &#125; int next() &#123; return *cur++; &#125; bool hasNext() &#123; return cur != vals.end(); &#125;&#125;; 将全部元素全部扁平化的思路，其实有点投机了。因为题目的名称是 list iterator，所以实现的功能应该是迭代到哪一步了，就把那一步展开。12345678910111213141516171819202122232425262728class NestedIterator &#123; stack&lt;NestedInteger&gt; st;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; for(int i = nestedList.size() - 1; i &gt;= 0; i--) &#123; st.push(nestedList[i]); &#125; &#125; int next() &#123; NestedInteger cur = st.top(); st.pop(); return cur.getInteger(); &#125; bool hasNext() &#123; while(!st.empty()) &#123; NestedInteger cur = st.top(); if(cur.isInteger()) &#123; return true; &#125; st.pop(); for(int i = cur.getList().size() - 1; i &gt;= 0; i--) &#123; st.push(cur.getList()[i]); &#125; &#125; return false; &#125;&#125;; 其实这个题，写起来很容易，就是着重理解题目的意思。 Summary与设计模式相关的题，需要读点相关书籍才能理解的更透彻...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day17]]></title>
    <url>%2F2022%2F05%2F16%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day17%2F</url>
    <content type="text"><![CDATA[要没了。 1845. Seat Reservation ManagerAnalysis题目的意思很直接，从 reverse 函数的功能来看，就是最小堆的出堆操作了。所以，这个题是要构造最小堆。 Code堆的功能可以直接用优先队列来完成。C++ 的优先队列默认是大根堆，如果要用小根堆就得写成priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;，其中第二个参数就是优先队列的底层数据结构，而第三个参数表示值越小越优先，对应的less&lt;int&gt;则表示值越大越优先。12345678910111213141516171819class SeatManager &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;public: SeatManager(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; q.push(i); &#125; &#125; int reserve() &#123; int tmp = q.top(); q.pop(); return tmp; &#125; void unreserve(int seatNumber) &#123; q.push(seatNumber); &#125;&#125;; 860. Lemonade ChangeAnalysis默认的找钱规则是能找大的尽量找大的，所以这是一个跟贪心相关的问题。用 2 个变量来记录能被找出去的 5 块和 10 块的数目，模拟找钱。如果顾客给了 20 块，此时有两种找钱方法，但是得按照规则来进行。一旦某个变量为负了，说明没办法正确找零。 Code1234567891011121314151617181920212223class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; int five, ten; five = ten = 0; int size = bills.size(); for(int i = 0; i &lt; size; i++) &#123; if(bills[i] == 10) &#123; five--; ten++; if(five &lt; 0) return false; &#125; else if(bills[i] == 20) &#123; if(ten == 0) five -= 3; else &#123; ten--; five--; &#125; if(ten &lt; 0 || five &lt; 0) return false; &#125; else five++; &#125; return true; &#125;&#125;; Summary第一个题如果要是自己写堆，估计挺废劲的😂。第二个题还 WA 了一次，有点亏...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day16]]></title>
    <url>%2F2022%2F05%2F15%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day16%2F</url>
    <content type="text"><![CDATA[go on, go on! 61. Rotate ListAnalysis好像做过跟这个题类似的旋转数组的题，把给定的链表当成循环链表，然后移动位置就可以了。 Code先用数组来处理，可能思路会简单一点。1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; tmp, list; ListNode *p = head; while(p != nullptr) &#123; tmp.push_back(p); p = p-&gt;next; &#125; int size = tmp.size(); k %= size; if(k == 0) return head; for(int i = size - k; i &lt; size; i++) &#123; list.push_back(tmp[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; list.push_back(tmp[i]); &#125; for(int i = 0; i &lt; size - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - 1]-&gt;next = nullptr; return list[0]; &#125;&#125;; 脑子抽了，在数组的下标上迷糊了好久...还是原来做过的类似题啊，废了🙃。改成只用一个数组的：123456789101112131415161718192021222324class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; list; ListNode *p = head; while(p != nullptr) &#123; list.push_back(p); p = p-&gt;next; &#125; int size = list.size(); k %= size; if(k == 0) return head; for(int i = size - k; i &lt; size - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - 1]-&gt;next = list[0]; for(int i = 0; i &lt; size - k - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - k - 1]-&gt;next = nullptr; return list[size - k]; &#125;&#125;; 再改成纯指针的：1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; ListNode *p = head; int cnt = 0; while(p != nullptr) &#123; cnt++; p = p-&gt;next; &#125; k %= cnt; if(k == 0) return head; p = head; ListNode *pre; int tmp = cnt - k; while(tmp--) &#123; pre = p; p = p-&gt;next; &#125; pre-&gt;next = nullptr; pre = p; while(p-&gt;next != nullptr) p = p-&gt;next; p-&gt;next = head; return pre; &#125;&#125;; 好像pre也可以省下？额，好像不行。 173. Binary Search Tree IteratorAnalysis读完一遍题目，其实没太明白题目的意思。尝试的写了一下，竟然通过了，仔细一看这个题 80% 的通过率啊~ Code12345678910111213141516171819202122232425class BSTIterator &#123; vector&lt;int&gt; seq; int pointer, count;public: void inorder(TreeNode *root) &#123; if(root == nullptr) return; inorder(root-&gt;left); seq.push_back(root-&gt;val); inorder(root-&gt;right); &#125; BSTIterator(TreeNode* root) &#123; inorder(root); pointer = 0; count = seq.size(); &#125; int next() &#123; return seq[pointer++]; &#125; bool hasNext() &#123; if(pointer &lt; count) return true; else return false; &#125;&#125;; 思路很简单，得到中序序列后，设置一个指针pointer用于 next 函数，再设置一个count记录结点总个数，用于 hasNext 函数。看了下官方题解，这种方法有个大名叫扁平化😂。还可以用栈来模拟单次遍历二叉树，就不写了吧。 Summary我算是发现了，这个系列，好像数学题是最多的，涉及的算法思想和数据结构反而很少...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day15]]></title>
    <url>%2F2022%2F05%2F14%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day15%2F</url>
    <content type="text"><![CDATA[还是两道链表题。 2. Add Two NumbersAnalysis披着链表外壳的大数加法题，算是模拟加法与合并链表两个题的结合版。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr &amp;&amp; l2 != nullptr) &#123; int sum = l1-&gt;val + l2-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while(l1 != nullptr) &#123; int sum = l1-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l1 = l1-&gt;next; &#125; while(l2 != nullptr) &#123; int sum = l2-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l2 = l2-&gt;next; &#125; if(carry) &#123; ListNode *tmp = new ListNode(carry); p-&gt;next = tmp; &#125; p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; 这样写虽然很思路清楚，但是看着很繁琐（主要是太长），改短一点：123456789101112131415161718192021222324class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr || l2 != nullptr) &#123; int n1 = l1 != nullptr ? l1-&gt;val : 0; int n2 = l2 != nullptr ? l2-&gt;val : 0; int sum = n1 + n2 + carry; ListNode *tmp = new ListNode(sum % 10); carry = sum / 10; p-&gt;next = tmp; p = tmp; if(l1 != nullptr) l1 = l1-&gt;next; if(l2 != nullptr) l2 = l2-&gt;next; &#125; if(carry) p-&gt;next = new ListNode(carry); p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; 445. Add Two Numbers IIAnalysis这是上个题的升级版，差别在于这里将数字的每一位正序存在链表中了，所以计算之前得先逆置链表。 Code直接把上面的代码与原来写过的反转链表代码抄过来😂。1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; l1 = reverseList(l1); l2 = reverseList(l2); return reverseList(addTwoNumbers1(l1, l2)); &#125; ListNode* addTwoNumbers1(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr || l2 != nullptr) &#123; int n1 = l1 != nullptr ? l1-&gt;val : 0; int n2 = l2 != nullptr ? l2-&gt;val : 0; int sum = n1 + n2 + carry; ListNode *tmp = new ListNode(sum % 10); carry = sum / 10; p-&gt;next = tmp; p = tmp; if(l1 != nullptr) l1 = l1-&gt;next; if(l2 != nullptr) l2 = l2-&gt;next; &#125; if(carry) p-&gt;next = new ListNode(carry); p = L; L = L-&gt;next; delete(p); return L; &#125; ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125;&#125;; 还有一个进阶提示是不反转链表如何做。如果不反转链表的话，可以用栈来保存链表节点，然后依次取栈顶结点来进行计算，计算思路与上一个题是一样的。不过为了直接得到正序的结果，在构造新链表的时候，需要将最先插入的结点放到最后面，所以这里的指针使用与上一个题不一样（实际上就是链表的另一种建立方法）。偷个懒，不写了吧😁。 Summary感觉链表的题做的有点乏味，因为是基础的缘故，好像也没有编一些复杂数据结构的题到这个系列吗？]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day14]]></title>
    <url>%2F2022%2F05%2F13%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day14%2F</url>
    <content type="text"><![CDATA[继续，继续。 143. Reorder ListAnalysis按照题目给定的方式来重排链表，就是头一个，尾一个，交替排列。 Code很容易想到用栈来保存倒序的链表，这样重排时就可以直接拿来用了。12345678910111213141516171819202122232425class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head-&gt;next) return; stack&lt;ListNode*&gt; st; ListNode *p = head; int cnt = 0; while(p) &#123; st.push(p); cnt++; p = p-&gt;next; &#125; p = head; for(int i = 1; i &lt; cnt; i++) &#123; if(i % 2) &#123; ListNode *tmp = p-&gt;next; p-&gt;next = st.top(); st.pop(); p = p-&gt;next; p-&gt;next = tmp; &#125; else p = p-&gt;next; &#125; p-&gt;next = nullptr; &#125;&#125;; 时间复杂度：$O(n)$，空间复杂度：$O(n)$。看了下官方题解，还有另外一种解法：将链表按照中间结点分成两部分，将后半部分链表翻转，然后合并两个子链表就可以得到结果了。把原来写过的题的代码直接 copy 过来：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* find middle node + reverse list + merge list */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head-&gt;next) return; ListNode *mid = middleNode(head); ListNode *L1 = head; ListNode *L2 = mid-&gt;next; mid-&gt;next = nullptr; L2 = reverseList(L2); mergeTwoLists(L1, L2); &#125; ListNode* middleNode(ListNode* head) &#123; ListNode *slow = head, *fast = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head != nullptr) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125; void mergeTwoLists(ListNode* list1, ListNode* list2) &#123; ListNode *p1; ListNode *p2; while(list1 != nullptr &amp;&amp; list2 != nullptr) &#123; p1 = list1-&gt;next; p2 = list2-&gt;next; list1-&gt;next = list2; list1 = p1; list2-&gt;next = list1; list2 = p2; &#125; &#125;&#125;; 时间复杂度：$O(n)$，空间复杂度：$O(1)$，虽然优化了空间复杂度，但是好麻烦，有没有。PS：空指针的判断最好不要用!，写成!= nullptr比较好。 138. Copy List with Random PointerAnalysis题目好长啊...em…这个题如果对深拷贝和指针理解的比较清晰的话，应该很容易读懂题目要干什么。其实就是将原链表 copy 一份，但是新链表每个的 random 的值要变成新链表的对应结点的地址，需要注意的是新链表结点的相对位置与旧链表是一样的。 Codemethod 11234567891011121314151617181920212223242526272829303132class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, int&gt; ht; vector&lt;Node*&gt; nodes; Node *p = head; int index = 0; while(p) &#123; ht[p] = index++; Node *node = new Node(p-&gt;val); nodes.push_back(node); p = p-&gt;next; &#125; int indices[1005]; memset(indices, -1, sizeof(indices)); p = head; index = 0; while(p) &#123; if(p-&gt;random != nullptr) indices[index] = ht[p-&gt;random]; index++; p = p-&gt;next; &#125; for(int i = 1; i &lt; index; i++) &#123; nodes[i - 1]-&gt;next = nodes[i]; &#125; for(int i = 0; i &lt; index; i++) &#123; if(indices[i] != -1) nodes[i]-&gt;random = nodes[indices[i]]; &#125; return nodes[0]; &#125;&#125;; 这题太麻烦了，而且容易把人绕晕😵。因为 random 是个指针，所以为了知道原链表中每个结点中 random 到底指向的是当前链表的第几个结点，必须要将原链表结点的地址按照[address, index]的格式散列。然后再重新遍历原链表，这样就知道每个结点的 random 到底指向的是当前链表的第几个结点了。这样在复制好新链表后，这样重新遍历一次新链表就可以将所有新结点的 random 指针全部设置好。 仔细想想，有必要用 hash 来保存结点的地址与索引的映射吗？直接按照旧结点与新结点地址的映射来保存不是更好吗？因为这样在遍历新链表的时候依然可以一次性修改所有新结点的 random 指针。12345678910111213141516171819202122232425class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, Node*&gt; ht; vector&lt;Node*&gt; nodes; Node *p = head; int cnt = 0; while(p) &#123; Node *node = new Node(p-&gt;val); node-&gt;random = p-&gt;random; ht[p] = node; nodes.push_back(node); p = p-&gt;next; cnt++; &#125; for(int i = 0; i &lt; cnt; i++) &#123; nodes[i]-&gt;random = ht[nodes[i]-&gt;random]; &#125; for(int i = 1; i &lt; cnt; i++) &#123; nodes[i - 1]-&gt;next = nodes[i]; &#125; return nodes[0]; &#125;&#125;; 再回头想想，之所以要用到 vector，是为了保存每个新结点，然后再遍历 vector 将新节点连成链表。有办法不用 vector，同时也将链表连起来吗？回顾链表的建立，很容易会想到建立链表的几种方法：头插法、尾插法等，不过感觉最好用的还是带头（哑）结点的尾插法（链表建立的方法很多，叫法可能不一致，总之会就行了😂）。123456789101112131415161718192021222324252627class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, Node*&gt; ht; Node *L = new Node(INT_MAX); Node *p = head, *t = L; while(p) &#123; Node *node = new Node(p-&gt;val); node-&gt;random = p-&gt;random; t-&gt;next = node; t = t-&gt;next; ht[p] = node; p = p-&gt;next; &#125; t = L; L = L-&gt;next; delete(t); t = L; while(t) &#123; if(ht.count(t-&gt;random)) t-&gt;random = ht[t-&gt;random]; t = t-&gt;next; &#125; cout &lt;&lt; endl; return L; &#125;&#125;; 这个写完之后，其实可以发现前面写的代码有点问题。问题在于修改新链表的 random 时，没有先用 map 的 count 函数做判断，但依然可以提交通过。为什么呢？因为在之前的代码中，哈希表ht中没有保存 key 为nullptr 的键值对，在执行ht[nullptr] = xxx时，会自动添加这一项，但对应的 value 默认是0，而这个0与 C/C++ 的NULL和nullptr表示的值（仅就值而言）是一样的。所以，应该是编译器自动的将这个 0 转换为空指针赋给了 random（没错，g++ 会自己做强制类型转换，将赋值语句右边的变量类型转换为赋值语句左边的变量类型）。而巧合的是，复制这些新结点的旧结点的random本来就是nullptr 😂，所以是不影响结果的正确性的。 因为这个题只给了带参的构造函数，所以要带个参数😁。看了一眼官方题解，果然，这种思路可以改成递归。1234567891011121314class Solution &#123;public: unordered_map&lt;Node*, Node*&gt; ht; Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; if(!ht.count(head)) &#123; Node *node = new Node(head-&gt;val); ht[head] = node; node-&gt;next = copyRandomList(head-&gt;next); node-&gt;random = copyRandomList(head-&gt;random); &#125; return ht[head]; &#125;&#125;; 说是递归，实际上是回溯 + 哈希的思路。 method 2官方题解给的第二种思路，倒是挺有意思。以A-&gt;B-&gt;C-&gt;D为例，先改成A-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;-&gt;D-&gt;D&#39;。这样改了之后，对于新链表而言，可以很容易的找到新链表结点之间与原链表结点之间一致的相对位置，也就是node-&gt;random-&gt;next。1234567891011121314151617181920212223class Solution &#123;public: unordered_map&lt;Node*, Node*&gt; ht; Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; for(Node *node = head; node != nullptr; node = node-&gt;next-&gt;next) &#123; Node *nodenew = new Node(node-&gt;val); nodenew-&gt;next = node-&gt;next; node-&gt;next = nodenew; &#125; for(Node *node = head; node != nullptr; node = node-&gt;next-&gt;next) &#123; Node *nodenew = node-&gt;next; nodenew-&gt;random = (node-&gt;random != nullptr) ? node-&gt;random-&gt;next : nullptr; &#125; Node *headnew = head-&gt;next; for(Node *node = head; node != nullptr; node = node-&gt;next) &#123; Node *nodenew = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; nodenew-&gt;next = (nodenew-&gt;next != nullptr) ? nodenew-&gt;next-&gt;next : nullptr; &#125; return headnew; &#125;&#125;; Summray这两个与链表相关的中等题还有点意思，基本上可以想到做法，虽然可以通过，但不是比较优秀的解法。突然发现，中等题，好像就是把单一的知识点结合起来了。就像这两个题，既需要链表的知识，也需要哈希、栈的一些知识。所以，还是要见多识广。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day13]]></title>
    <url>%2F2022%2F05%2F12%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day13%2F</url>
    <content type="text"><![CDATA[不知道写什么好了...😁 304. Range Sum Query 2D - ImmutableAnalysis这是个前缀和的题，而且是二维数组的前缀和。 Codemethod 1这种题如果知道推导的公式的话，就很简单了。不过，还是自己先做一下。因为知道了是前缀和的题，所以先按照一维前缀和的思路来处理。1234567891011121314151617181920class NumMatrix &#123;public: vector&lt;vector&lt;int&gt;&gt; prefixsum = vector&lt;vector&lt;int&gt;&gt;(205, vector&lt;int&gt;(205)); NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; prefixsum[i][j + 1] = prefixsum[i][j] + matrix[i][j]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; int sum = 0; while(row1 &lt;= row2) &#123; sum += prefixsum[row1][col2 + 1] - prefixsum[row1][col1]; row1++; &#125; return sum; &#125;&#125;; em，一维前缀和的思路，勉强通过了。 method 2再回头考虑二维前缀和的思路，首先应该明确的二维前缀和中的和，是以当前坐标的元素为右下角（也就是最后一个）元素的矩阵的元素之和。按照推导公式（具体怎么推导不讨论了）可以知道：123prefixsum[i + 1][j + 1] = prefixsum[i - 1][j] + prefixsum[i][j - 1] - prefixsum[i - 1][j - 1] + matrix[i][j] 之所以要写成 i + 1 与 j + 1 的形式，是为了避免当 row = 0，col = 0 时的特殊判断，这点与一维前缀和的思路是一致的。对应的：123sumRegion(row1, col1, row2, col2)= prefixsum[row2 + 1][col2 - 1] - prefixsum[row1][col2 + 1] - prefixsum[row2 + 1][col1] + prefixsum[row1][col1] 就可以得到下面的代码了：1234567891011121314151617181920class NumMatrix &#123;public: vector&lt;vector&lt;int&gt;&gt; prefixsum = vector&lt;vector&lt;int&gt;&gt;(205, vector&lt;int&gt;(205)); NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if(m &gt; 0) &#123; int n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; prefixsum[i + 1][j + 1] = prefixsum[i][j + 1] + prefixsum[i + 1][j] - prefixsum[i][j] + matrix[i][j]; &#125; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return prefixsum[row2 + 1][col2 + 1] - prefixsum[row1][col2 + 1] - prefixsum[row2 + 1][col1] + prefixsum[row1][col1]; &#125;&#125;; PS：画一个矩形，用求矩形小块面积的思路来理解二维前缀和比较直观，看公式容易看晕。 910. Smallest Range IIAnalysis这个题是 908. Smallest Range I 的加强版，差别在于这个题既可以对数组元素加 k，也可以对数组元素减 k。所以，为了保持操作结束后的数组的最值差最小，就得让数组中大的数减 k，小的数加 k。但难点在于，该如何界定这里提到的大和小呢？ Code虽然，这个题的标签是贪心、排序和数学，但个人感觉是个抖机灵题目。这个人的题解写的很清楚：太难了，只能画图凭直觉。1234567891011121314class Solution &#123;public: int smallestRangeII(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int mymin, mymax, size = nums.size(); int ans = nums[size - 1] - nums[0]; for(int i = 0; i &lt; size - 1; i++) &#123; mymin = min(nums[0] + k, nums[i + 1] - k); mymax = max(nums[size - 1] - k, nums[i] + k); ans = min(ans, mymax - mymin); &#125; return ans; &#125;&#125;; Summary前缀和的题目挺常规，第二个题有点奇怪~顺路再把一维前缀和的题目给做了：303. Range Sum Query - Immutable。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day12]]></title>
    <url>%2F2022%2F05%2F11%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day12%2F</url>
    <content type="text"><![CDATA[20 天才能结束，才到 12 天啊。 438. Find All Anagrams in a StringAnalysis找出字符串 s 中存在的 p 的字母异位词。 Code这种题很容易想到 $O(n^2)$ 的暴力解法，但是数据规模是 $[1, 3 × 10^4]$，毫无疑问会超时。按照题目的类型来看，应该是滑动窗口的题目，先把暴力解法写出来吧。12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt;= slen - plen; i++) &#123; vector&lt;int&gt; tmp(26); for(int j = i; j &lt; i + plen; j++) &#123; tmp[s[j] - 'a']++; &#125; if(tmp == cnt) ret.push_back(i); &#125; return ret; &#125;&#125;; 没想到，这个暴力解法也能过。判断是否是字母异位词也可以用排序来实现，这是从昨天的题中学来的，但是排序的时间复杂度是 $O(nlogn)$，不如 $O(n)$ 的散列来的快。现在再回头考虑如何用滑动窗口来处理：12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26), tmp(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; tmp[s[i] - 'a']++; &#125; if(cnt == tmp) ret.push_back(0); for(int i = 0; i &lt; slen - plen; i++) &#123; tmp[s[i]- 'a']--; tmp[s[i + plen] - 'a']++; if(tmp == cnt) ret.push_back(i + 1); &#125; return ret; &#125;&#125;; 滑动窗口的难点在于如何理解窗口，就这个题来讲，窗口的大小就是字符串 p 的长度。每次滑动窗口的时候，就把左端的字符从窗口移出去，再把右端的字符加入到窗口中来。官方题解还提供了一种优化版的滑动窗口思路，即不再统计窗口内字符的数量，只用一个变量 diff 来记录当前窗口字符串与 p 中数量不同的字母的个数。123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[s[i] - 'a']++; cnt[p[i] - 'a']--; &#125; int diff = 0; for(int i = 0; i &lt; 26; i++) &#123; if(cnt[i] != 0) diff++; &#125; if(diff == 0) ret.push_back(0); for(int i = 0; i &lt; slen - plen; i++) &#123; // left if(cnt[s[i] - 'a'] == 1) diff--; else if(cnt[s[i] - 'a'] == 0) diff++; cnt[s[i] - 'a']--; // right if(cnt[s[i + plen] - 'a'] == -1) diff--; else if(cnt[s[i + plen] - 'a'] == 0) diff++; cnt[s[i + plen] - 'a']++; // judge if(diff == 0) ret.push_back(i + 1); &#125; return ret; &#125;&#125;; 注意下标为 0 时的判断得写在外面，目的是为了在滑动窗口的循环中先滑动窗口，再进行判断，这样就可以取到下标为 slen - plen 的位置了，且不至于越界。翻了下评论区，好像还有一种滑动窗口的解法：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; &#125; int left = 0, right = 0; while(right &lt; slen) &#123; cnt[s[right] - 'a']--; while(cnt[s[right] - 'a'] &lt; 0) &#123; cnt[s[left] - 'a']++; left++; &#125; if(right - left + 1 == plen) ret.push_back(left); right++; &#125; return ret; &#125;&#125;; 感觉这种解法不太好想，最好想的解法还是一开始的滑动窗口解法。滑动窗口的解法，应该是从双指针衍生出来的解法。难点在于，如何移动窗口的左端点 left，并同时将符合条件的解找出来。回到上面的解法来，巧妙之处在于在移动 left 的同时，让统计（也可以叫 hash）数组 cnt 还原了。 713. Subarray Product Less Than KAnalysis找出乘积小于 k 且元素连续的子数组，这个题一看也是滑动窗口的题，也是 5 月 5 日的每日一题。 Code暴力解法死在 93 个用例了😂。12345678910111213141516class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(), cnt = 0; for(int i = 0; i &lt; size; i++) &#123; int product = 1; for(int j = i; j &lt; size; j++) &#123; product *= nums[j]; if(product &lt; k) cnt++; else break; &#125; &#125; return cnt; &#125;&#125;; 直接换滑动窗口：123456789101112131415161718class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(), cnt = 0; int left = 0, right = 0, product = 1; while(right &lt; size) &#123; product *= nums[right]; while(left &lt;= right &amp;&amp; product &gt;= k) &#123; product /= nums[left]; left++; &#125; cnt += right - left + 1; right++; &#125; return cnt; &#125;&#125;; 这里的难点在于理解子数组个数 cnt 的计算，这个值是随着滑动窗口的改变而改变的，每一次循环，加入或者减少元素，这个值都需要加上当前窗口内元素能构成的子数组个数。也就是说，当前窗口 $[left, right]$ 能构成的符合条件的子数组个数就是 $right - left + 1$ 个，把所有窗口的情况全加起来就是要求的结果了（这也是处理这类连续问题的关键）。官方题解还提供了一种有趣的可以用二分来解决的方法：123456789101112131415161718class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(); vector&lt;double&gt; logprefix(size + 1); for(int i = 0; i &lt; size; i++) &#123; logprefix[i + 1] = logprefix[i] + log(nums[i]); &#125; double logk = log(k); int cnt = 0; for(int r = 0; r &lt; size; r++) &#123; int l = upper_bound(logprefix.begin(), logprefix.begin() + r + 1, logprefix[r + 1] - logk + 1e-10) - logprefix.begin(); cnt += r + 1 - l; &#125; return cnt; &#125;&#125;; 这种方法需要用到前缀和、二分查找和数学知识，很灵活，不是那么好想。 Summary滑动窗口掌握的还不熟练，还得再来点题目才行。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day11]]></title>
    <url>%2F2022%2F05%2F10%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day11%2F</url>
    <content type="text"><![CDATA[继续，继续。 1376. Time Needed to Inform All EmployeesAnalysis题目真长，不过意思还算简单，实质上就是在求树的最长路径，而通知时间就是结点与结点之间的边权，这与图很类似。 Codebfs从 bfs 的角度来思考可能会容易一些。12345678910111213141516171819202122232425class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int i = 0; i &lt; n; i++) &#123; if(manager[i] == node) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; &#125; &#125; &#125; int maxtime = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; if(maxtime &lt; totaltime[i]) maxtime = totaltime[i]; &#125; return maxtime; &#125;&#125;; 可惜，这段代码提交上去超时了，原因是找子结点的时候是又重复遍历了一次数组。既然这样，那就按照根结点来统计一下子结点的下标：123456789101112131415161718192021222324252627class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); unordered_map&lt;int, vector&lt;int&gt;&gt; indices; for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) indices[manager[i]].push_back(i); &#125; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int &amp;i: indices[node]) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; &#125; &#125; int maxtime = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; if(maxtime &lt; totaltime[i]) maxtime = totaltime[i]; &#125; return maxtime; &#125;&#125;; 这种思路虽然可以通过，但是时间、空间消耗都比较大。仔细一看，这种思路实际上是利用邻接表遍历图，并求出最长路径，那干脆直接按照图的方式来写：12345678910111213141516171819202122232425class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); vector&lt;vector&lt;int&gt;&gt; adj(n); for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) adj[manager[i]].push_back(i); &#125; queue&lt;int&gt; q; q.push(root); int maxtime = INT_MIN; while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int &amp;i: adj[node]) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; if(totaltime[i] &gt; maxtime) maxtime = totaltime[i]; &#125; &#125; return maxtime; &#125;&#125;; 把 unordered_map 换成 vector 时间、空间消耗都减少很多😂。另外，因为不存在环（题目给的都是树），所以 visit 数组就可以省去了。 dfs再回头想想 dfs 怎么写，按照前面的思路，当作图来写 dfs：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; totaltime = vector&lt;int&gt;(1e5); int maxtime = INT_MIN; void dfs(int u, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; informTime) &#123; for(int i = 0; i &lt; adj[u].size(); i++) &#123; int v = adj[u][i]; totaltime[v] = informTime[u] + totaltime[u]; if(maxtime &lt; totaltime[v]) maxtime = totaltime[v]; dfs(v, adj, informTime); &#125; &#125; int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;vector&lt;int&gt;&gt; adj(n); for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) adj[manager[i]].push_back(i); &#125; dfs(headID, adj, informTime); return maxtime; &#125;&#125;; 同样，因为没有环，所以也不需要 visit 数组。 49. Group AnagramsAnalysis这个题第一眼看过去，没读懂，仔细又读了一下，原来是个分类的题目，只需要将字母异位词组合在一起就可以了。话说，求字母异位词好像就是求字母的全排列，不得不又联想到昨天做的那个题😂。不过这个题，感觉用 hash 会好一点。 Code一开始总数想让 hash 直接映射成不同类型字母异位词的下标，倒腾半天 map&lt;vector&lt;int&gt;, int&gt;，没倒腾出来，只能用暴力一点的解法了。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); vector&lt;bool&gt; ht(size); vector&lt;vector&lt;string&gt;&gt; ret; int amount = 0; while(amount &lt; size) &#123; vector&lt;int&gt; cnt1(26); int index = 0; while(index &lt; size &amp;&amp; ht[index] == true) index++; int len = strs[index].length(); for(int i = 0; i &lt; len; i++) &#123; cnt1[strs[index][i] - 'a']++; &#125; vector&lt;string&gt; tmp; for(int i = 0; i &lt; size; i++) &#123; len = strs[i].length(); vector&lt;int&gt; cnt2(26); for(int j = 0; j &lt; len; j++) &#123; cnt2[strs[i][j] - 'a']++; &#125; if(cnt2 == cnt1) &#123; tmp.push_back(strs[i]); ht[i] = true; &#125; &#125; amount += tmp.size(); ret.push_back(tmp); &#125; return ret; &#125;&#125;; 这段代码姑且算是能出结果了，可惜提交上去超时了。突然发现，自己有点被题目绕晕了。而且，这个题的难点好像是在如何合理使用 STL 来表示 hash 上。省去了一些重复的判断：1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); vector&lt;bool&gt; ht(size); vector&lt;vector&lt;string&gt;&gt; ret; int amount = 0; while(amount &lt; size) &#123; vector&lt;int&gt; cnt1(26); int index = 0; vector&lt;string&gt; tmp; while(index &lt; size &amp;&amp; ht[index] == true) index++; int len = strs[index].length(); for(int i = 0; i &lt; len; i++) &#123; cnt1[strs[index][i] - 'a']++; &#125; ht[index] = true; tmp.push_back(strs[index++]); while(index &lt; size) &#123; vector&lt;int&gt; cnt2(26); int tmplen = strs[index].length(); if(ht[index] == false &amp;&amp; len == tmplen) &#123; for(int i = 0; i &lt; tmplen; i++) &#123; cnt2[strs[index][i] - 'a']++; &#125; if(cnt2 == cnt1) &#123; tmp.push_back(strs[index]); ht[index] = true; &#125; &#125; index++; &#125; amount += tmp.size(); ret.push_back(tmp); &#125; return ret; &#125;&#125;; 还是超时的，是我把这个问题想的太复杂了吗？分析一下上面的代码，判断两个词是字母异位词是基于两个词的字符个数相同，这就需要分别对两个词中的字符进行统计并判断是否相同。同时，设置了一个 hash 表来标记这个词是否被统计过，统计过了就说明是其他词的字母异位词，就不再统计了。strs 的长度范围是 $[1, 10^4]$，词的长度范围是 $[0, 100]$，极端情况下，就是 $10^6$，按理说这种思路，虽然很慢，应该是可以过的。不过，这种思路下，可能会产生很多无效统计。既然事实已经证明，这种方法不行了，就得换个思路了。瞅了两眼官方题解，突然发现官方题解不是用字符串的字母统计结果当作 map 的映射，而是将字符串先排序，如果字符串的排序结果一致就说明是字母异位词，真鸡贼啊😂~等等，好像发现了什么东西，回到一开始的思路，重新写了一下：123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); map&lt;vector&lt;int&gt;, int&gt; indices; vector&lt;vector&lt;string&gt;&gt; ret(size); int index = 0; for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; cnt(26); int len = strs[i].length(); for(int j = 0; j &lt; len; j++) &#123; cnt[strs[i][j] - 'a']++; &#125; if(indices.count(cnt)) &#123; ret[indices[cnt]].push_back(strs[i]); &#125; else &#123; ret[index].push_back(strs[i]); indices[cnt] = index++; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; ans; for(auto &amp;v: ret) &#123; if(v.size() != 0) ans.push_back(move(v)); &#125; return ans; &#125;&#125;; 干，一开始的思路是可以通过的，尽管时间和空间消耗不忍直视。突然发现好像一开始倒腾半天没出来的原因是语法写错了，感觉今天不在状态（我还傻傻的一个一个去判断🙃）。既然明确了这个思路，那不妨写的更简单一点：1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); map&lt;vector&lt;int&gt;, vector&lt;string&gt;&gt; ht; vector&lt;vector&lt;string&gt;&gt; ret; for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; cnt(26); int len = strs[i].length(); for(int j = 0; j &lt; len; j++) &#123; cnt[strs[i][j] - 'a']++; &#125; ht[cnt].push_back(strs[i]); &#125; for(auto &amp;[v1, v2]: ht) &#123; ret.push_back(v2); &#125; return ret; &#125;&#125;; ...还真能这样写啊（C++ 的语法跟 STL 的知识还得补🙃）。另外，unordered_map 好像不能把 vector 当作 key。现在回到官方题解的思路上来：1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); unordered_map&lt;string, vector&lt;string&gt;&gt; mp; for(string &amp;s: str) &#123; string key = s; sort(key.begin(), key.end()); mp[key].push_back(s); &#125; vector&lt;vector&lt;string&gt;&gt; ret; for(auto &amp;[s, v]: mp) &#123; ret.push_back(v); &#125; return ret; &#125;&#125;; 相比自己的思路，时间、空间消耗都少了一半。官方题解的第二种思路与自己的思路是一样的，只是用了稍微复杂一点的语法：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; auto arrayHash = [fn = hash&lt;int&gt;&#123;&#125;] (const array&lt;int, 26&gt;&amp; arr) -&gt; size_t &#123; return accumulate(arr.begin(), arr.end(), 0u, [&amp;](size_t acc, int num) &#123; return (acc &lt;&lt; 1) ^ fn(num); &#125;); &#125;; unordered_map&lt;array&lt;int, 26&gt;, vector&lt;string&gt;, decltype(arrayHash)&gt; mp(0, arrayHash); for(string &amp;str: strs) &#123; array&lt;int, 26&gt; counts&#123;&#125;; int len = str.length(); for(int i = 0; i &lt; len; i++) &#123; counts[str[i] - 'a']++; &#125; mp[counts].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; ret; for(auto it = mp.begin(); it != mp.end(); it++) &#123; ret.push_back(it-&gt;second); &#125; return ret; &#125;&#125;; 有好多看不懂的语法...暂时放着吧。 Summary感觉今天脑子有点迷迷糊糊的，不太清醒。话说，老是做题，都没有具体的看看书，也没有好好的总结一下]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 291 场周赛]]></title>
    <url>%2F2022%2F05%2F09%2FLeetcode-%E7%AC%AC-291-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[这是上上周的周赛了...这场周赛依然是双题选手... 2259. Remove Digit From Number to Maximize ResultAnalysis给定一个字符串，在不改变字符顺序的情况下，返回删除一个给定字符后，能得到的十进制下的最大结果。 Code这是当时提交的代码：1234567891011121314151617181920212223class Solution &#123;public: string removeDigit(string number, char digit) &#123; vector&lt;int&gt; indices; int len = number.length(); for(int i = 0; i &lt; len; i++) &#123; if(number[i] == digit) indices.push_back(i); &#125; if(indices.size() == 1) &#123; number.erase(number.begin() + indices[0]); return number; &#125; else &#123; string max = number; max.erase(max.begin() + indices[0]); for(int i = 1; i &lt; indices.size(); i++) &#123; string t = number; t.erase(t.begin() + indices[i]); if(max &lt; t) max = t; &#125; return max; &#125; &#125;&#125;; 看了下别人的思路，其实这个题完全可以不重新构造子串。需要考虑的问题是对于有多个 digit 的字符串而言，删除哪一个位置的 digit 后得到的数是最大的。分析一下，被删除的 digit 可能靠前，比如 1231，删除 1；也可能靠后，比如 1323，删除 3。这两种情况其实有个很容易忽略的细节在内，即删除的 digit 的后面的字符一定是大于 digit 的，或者删除的是末尾的 digit。为什么会出现这种情况呢？因为前面的数字是在高位的，减少了一位后，每一位上的数字就变了，实际改变的就是结果数字的大小。比如 1231，如果删除后面的 1，那么 2 就变成了百十位，3 就变成了个位，但是如果删除前面的 1 ，2 就变成了百位，3 就变成了十位。结果就是，这个数字是删除后的数字中最大的。1234567891011121314class Solution &#123;public: string removeDigit(string number, char digit) &#123; int len = number.length(), pos = -1; for(int i = 0; i &lt; len; i++) &#123; if(number[i] == digit) &#123; pos = i; if(i + 1 &lt; len &amp;&amp; number[i] &lt; number[i + 1]) break; &#125; &#125; number.erase(number.begin() + pos); return number; &#125;&#125;; 实质上是一种贪心的过程。 2260. Minimum Consecutive Cards to Pick UpAnalysis找出左右边界相等的最短连续子序列。 Codemethod 1这是当时提交的代码：12345678910111213141516171819202122class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); map&lt;int, vector&lt;int&gt;&gt; ht; for(int i = 0; i &lt; size; i++) &#123; ht[cards[i]].push_back(i); &#125; int minimum = INT_MAX; for(auto &amp;[x, v]: ht) &#123; if(v.size() &gt; 1) &#123; int tmp = v[1] - v[0] + 1, s = v.size(); for(int i = 1; i &lt; s - 1; i++) &#123; if(tmp &gt; v[i + 1] - v[i]) tmp = v[i + 1] - v[i] + 1; &#125; if(minimum &gt; tmp) minimum = tmp; &#125; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; 本质上是哈希 + 暴力搜索的思路，即找出每一对边界相同的子列，比较它们的大小，返回最小值。换成 unordered_map 应该会好一些：12345678910111213141516171819202122class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, vector&lt;int&gt;&gt; ht; for(int i = 0; i &lt; size; i++) &#123; ht[cards[i]].push_back(i); &#125; int minimum = INT_MAX; for(auto &amp;[x, v]: ht) &#123; if(v.size() &gt; 1) &#123; int tmp = v[1] - v[0] + 1, s = v.size(); for(int i = 1; i &lt; s - 1; i++) &#123; if(tmp &gt; v[i + 1] - v[i]) tmp = v[i + 1] - v[i] + 1; &#125; if(minimum &gt; tmp) minimum = tmp; &#125; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; 果然，时间减少了大约一半。多用了一个 hashmap，时间没怎么减少，内存倒是减少了：123456789101112131415161718class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, set&lt;int&gt;&gt; ht1; unordered_map&lt;int, int&gt; ht2; for(int i = 0; i &lt; size; i++) &#123; if(ht2.count(cards[i])) ht1[cards[i]].insert(i - ht2[cards[i]] + 1); ht2[cards[i]] = i; &#125; int minimum = INT_MAX; for(auto &amp;[x, s]: ht1) &#123; if(minimum &gt; *s.begin()) minimum = *s.begin(); &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; 理论分析时间复杂度应该是要优于上面只用一个 hashmap 的解法。仔细想想，有必要把每一个左右边界相等的子序列的长度都算出来吗？其实是没有的，只需要 hashmap 保存上一次的相等元素的下标即可，要得到最近的两个相等元素的长度，直接作差就可以了，然后再从这些值中找出最小值即可。1234567891011121314class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, int&gt; ht; int minimum = INT_MAX; for(int i = 0; i &lt; size; i++) &#123; if(ht.count(cards[i])) minimum = min(minimum, i - ht[cards[i]] + 1); ht[cards[i]] = i; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; ...还是自己太憨了😓。 method 2看了下这道题的标签，好像也是个滑动窗口的题目。123456789101112131415161718192021class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_set&lt;int&gt; ht; int left, right, ans; left = right = 0; ans = INT_MAX; while(right &lt; size) &#123; while(ht.count(cards[right])) &#123; ans = min(ans, right - left + 1); ht.erase(cards[left]); left++; &#125; ht.insert(cards[right]); right++; &#125; if(ans == INT_MAX) return -1; else return ans; &#125;&#125;; 滑动窗口也需要用一个 hashmap 来判断，当前数字是不是之前出现过（出现过才可以构成符合条件的子序列）。PS：这个题的 $cards[i]$ 的范围是 $[0, 10^6]$，所以直接开个很大的数组当 hashmap 来用，运行时间会快很多。 2022年5月14日，消停了几天，我又回来了。 2261. K Divisible Elements SubarraysAnalysis虽然题目很短，但是感觉是个比较麻烦的题目。首先需要找出符合条件的子数组，但是为了确保唯一性，还需要检查是否子数组是否出现过，所以这个题不能简单的用滑动窗口的思路来处理。 Code暴力解法还是很容易想到的（当时比赛怎么没想到啊😂）。1234567891011121314151617181920212223class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; map&lt;vector&lt;int&gt;, bool&gt; ht; int ret = 0, size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; tmp; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; tmp.push_back(nums[j]); if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; else &#123; if(!ht.count(tmp)) &#123; ht[tmp] = true; ret++; &#125; &#125; &#125; &#125; return ret; &#125;&#125;; 本以为 nums 的长度范围只有 $[1, 200]$，暴力解法应该也可以通过，结果还是无法通过。为了确保解的唯一性，hash 表没办法拿掉，想要提高时间效率，就得在找解的方法上下功夫。看了下官方题解，没有用子数组来作为哈希的 key，而是将子数组序列化为字符串，让这个字符串作为哈希元素，其他的思路基本上是一致的。12345678910111213141516171819class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; unordered_set&lt;string&gt; arrs; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; string s; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; s.append(to_string(nums[j])); s.push_back('#'); arrs.insert(s); &#125; &#125; return arrs.size(); &#125;&#125;; 这段代码是可以通过的。回头想想，应该是直接将子数组作为 map 的 key 导致消耗的时间太多了。更要命的是，我还用了count函数，不如直接ht[cnt] = xxx;，最后直接返回ht.size()。123456789101112131415161718class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; map&lt;vector&lt;int&gt;, bool&gt; ht; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; tmp; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; tmp.push_back(nums[j]); if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; ht[tmp] = true; &#125; &#125; return ht.size(); &#125;&#125;; 没想到，改了下还真的可以通过了😂，就是时间、空间消耗惨不忍睹。就这个题而言，没办法通过的原因，很大一部分是对 map、set 这类容器的不了解... 2262. Total Appeal of A StringAnalysis这个题是前面几个题的进化版😂，感觉用第 3 个题的思路，完全可以。不过数据范围是 $10^5$，$O(n^2)$ 铁定得超时。 Code这是当时提交的超时代码：123456789101112131415161718192021222324class Solution &#123;public: long long appealSum(string s) &#123; long long ret = s.length(); int len = s.length(); unordered_set&lt;char&gt; ht; for(int i = 0; i &lt; len; i++) &#123; ht.insert(s[i]); &#125; ret += ht.size(); for(int step = 2; step &lt; len; step++) &#123; for(int i = 0; i &lt;= len - step; i++) &#123; unordered_set&lt;char&gt; ht; int start = i, end = i + step; while(start &lt; end) &#123; ht.insert(s[start]); start++; &#125; ret += ht.size(); &#125; &#125; return ret; &#125;&#125;; 现在看，感觉当时想复杂了，思路是按照不同长度来枚举子字符串，结果死在 52 个用例了。这是刚刚写的：12345678910111213141516171819202122232425262728class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; vector&lt;int&gt; cnt(26); int l = str.length(); for(int i = 0; i &lt; l; i++) &#123; cnt[str[i] - 'a']++; &#125; int count = 0; for(int i = 0; i &lt; 26; i++) &#123; if(cnt[i] &gt; 0) count++; &#125; ret += count * times; &#125; return ret; &#125;&#125;; 用了下哈希的思路，死在 55 个用例了，尽量一个循环就把单个字符串的引力算出。12345678910111213141516171819202122232425262728class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; vector&lt;int&gt; cnt(26); int l = str.length(); int count = 0; for(int i = 0; i &lt; l; i++) &#123; if(cnt[str[i] - 'a'] == 0) &#123; count++; &#125; cnt[str[i] - 'a']++; &#125; ret += count * times; &#125; return ret; &#125;&#125;; 结果死在 53 个用例了，等等，用 set 不是更香😂？1234567891011121314151617181920212223class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; unordered_set&lt;char&gt; se; for(auto &amp;c: str) &#123; se.insert(c); &#125; ret += se.size() * times; &#125; return ret; &#125;&#125;; 结果死在 52 个用例了😂，set 比 vector 省事了不少，就是时间消耗越来越多了。看了下别人的题解，这个题好像是 dp 和 字符串的结合题。123456789101112131415class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); vector&lt;int&gt; last(26, -1); for(int i = 0, sum_g = 0; i &lt; s.length(); i++) &#123; int c = s[i] - 'a'; sum_g += i - last[c]; ret += sum_g; last[c] = i; &#125; return ret; &#125;&#125;; 暂时理解不了这种思路，再做点题了，回头看看。 Summary这次竞赛，可惜的是第三个题没做出来。一般来讲，暴力解法应该是想得到的。想到了暴力解法，然后换个 STL 容器估计就可以通过了😂。可惜了~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day10]]></title>
    <url>%2F2022%2F05%2F09%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day10%2F</url>
    <content type="text"><![CDATA[继续冲~ 503. Next Greater Element IIAnalysis这跟之前做的那个温度题很像，应该都是单调栈的题目。不过不同的是，这个题返回的值是遍历顺序的第一个大的值。也就是说，如果这个元素后面不存在比它大的数，那么就循环的从开头遍历到这个元素，找出比它大的第一个元素。 Codemethod 1很自然就想到暴力解法了：12345678910111213141516class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int left = 0, right = i + 1; while(right &lt; size &amp;&amp; nums[right] &lt;= nums[i]) right++; while(left &lt; i &amp;&amp; nums[left] &lt;= nums[i]) left++; if(right != size) ret[i] = nums[right]; else if(left != i) ret[i] = nums[left]; else ret[i] = -1; &#125; return ret; &#125;&#125;; 嗯，这个解法是可以通过的。实际上，在向右遍历的过程中如果找到了，就没有必要再向左找了，所以可以优化一下：12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int pre = 0, rear = i + 1; bool flag = false; while(rear &lt; size) &#123; if(nums[rear] &gt; nums[i]) &#123; ret[i] = nums[rear]; flag = true; break; &#125; rear++; &#125; if(flag) continue; else &#123; while(pre &lt; i) &#123; if(nums[pre] &gt; nums[i]) &#123; ret[i] = nums[pre]; break; &#125; pre++; &#125; if(pre == i) ret[i] = -1; &#125; &#125; return ret; &#125;&#125;; 相比上一段代码而言，时间消耗减少了 3 倍...不过依然不是一个好解法。 method 2正如前面所说，这个题还可以用单调栈的思路来解决。不过，这个题还有一个不一样的地方，如果这个数字后没有比它更大的数了，就需要循环的从头开始查找。但是，单调栈只能找到这个元素后面第一个比它大的元素啊。实际上，这里有一个简单的做法，那就是重新在遍历一次，这有点类似循环队列。12345678910111213141516class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size, -1); stack&lt;int&gt; st; for(int i = 0; i &lt; size * 2 - 1; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i % size]) &#123; ret[st.top()] = nums[i % size]; st.pop(); &#125; st.push(i % size); &#125; return ret; &#125;&#125;; 重复的遍历过程，可以用取余运算替代。仔细想想，一次遍历结束后，对于一个元素而言，如果其后面存在比它大的元素，那么比这个元素大的第一个元素就找到了。对应的，第二次遍历的时候就不用入栈了，所以，把两次遍历的过程分开：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size, -1); stack&lt;int&gt; st; for(int i = 0; i &lt; size; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) &#123; ret[st.top()] = nums[i]; st.pop(); &#125; st.push(i % size); &#125; for(int i = 0; i &lt; size; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) &#123; ret[st.top()] = nums[i]; st.pop(); &#125; &#125; return ret; &#125;&#125;; 556. Next Greater Element IIIAnalysis题意很简单，给一个数，将这个数字的每一位重新组合形成一个新的数，在所有的这些新数中，找出比给定的数大且是这些数中最小的数（话都不会说了）。 Code给的 n 的范围是 $[1, 2^{31} - 1]$，也就是最多不超过 10 位。10 个数字构成十位数，一共有 10! 种，这是极端情况下，一般是小于这个数的，因为可能存在重复的数字。如果 dfs 搜索出所有结果，然后再选出符合条件的最小值，堆栈可能会爆。换个角度理解，重新构造数字的过程，实际上也是每一位上的数字重新排列的过程。 首先思考一下什么样数字没有比它大的数？显然，数位上的数字是逆序排列的数字，比如：321、872 和 9991 等，这类数字已经是这些数字组合的最大排列了。再来思考如何组成比给定数下一个大的数，下一个大换句话说，就是刚刚大、大了一点，也就是说，这个这个新数字与原数字是有部分相同的数位的，而且为了保证是“下一个大”，高位上的数字一定是相同的。也就是说，需要从低位开始找。哪找什么样子的呢？按照前面的分析，如果是逆序排列的数字，不存在比它大的数。所以，要找的那个数字就是第一个不构成逆序的数字。还是举例子，比如 943765，倒数过来，第一个不构成逆序的数字就是 3。找到第一个不构成逆序的数之后呢？同样为了保证“下一个大”，不能去动前面的数字，所以只能找后面的数来与这个数交换。实际上，我们可以很容易的看出 943765 的“下一个大”的数字就是 945367，也就是让 3 与其后面比它第一个大的 5 进行交换，然后再逆序得到的 763 这个序列。按照这样的思路，就可以得到下一个大的数字了。123456789101112131415161718192021class Solution &#123;public: int nextGreaterElement(int n) &#123; string s = to_string(n); int len = s.length(); if(len == 1) return -1; int pos = len - 2; while(pos &gt;= 0 &amp;&amp; s[pos] &gt;= s[pos + 1]) pos--; if(pos &lt; 0) return -1; int nextpost = len - 1; while(nextpost &gt;= 0 &amp;&amp; s[nextpost] &lt;= s[pos]) nextpost--; swap(s[pos], s[nextpost]); reverse(s.begin() + pos + 1, s.end()); long long ret = 0; for(int i = 0; i &lt; len; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; if(ret &gt; INT_MAX) return -1; return ret; &#125;&#125;; 最后别忘记了，题目限定了数字的结果是 $[1, 2^{31} - 1]$ 的范围内。另外，转换整数的过程可以调用库函数 stoll 完成：1long long ret = stoll(s); 31. Next PermutationAnalysis顺路把这个题也解决了，好像与上面的题目是一样的。读了一下题目，果然是一样的。解题的思路基本上是一致的，只是不需要在做 int 溢出判断了。 Codeem，思路完全一致...12345678910111213141516class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); int pos = size - 2; while(pos &gt;= 0 &amp;&amp; nums[pos] &gt;= nums[pos + 1]) pos--; if(pos == -1) &#123; reverse(nums.begin(), nums.end()); &#125; else &#123; int nextpos = size - 1; while(nextpos &gt;= 0 &amp;&amp; nums[nextpos] &lt;= nums[pos]) nextpos--; swap(nums[pos], nums[nextpos]); reverse(nums.begin() + pos + 1, nums.end()); &#125; &#125;&#125;; 容易忽略的地方还有一点，那就是在寻找这两个数时，一定要严格大于或小于，不能等于。实际上，C++ 内有现成的函数可以用😁。123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; Summary不知道说什么好了...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 77 场双周赛]]></title>
    <url>%2F2022%2F05%2F08%2FLeetcode-%E7%AC%AC-77-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[RT...好不容易昨天把 290 场周赛的问题写完了~这也是前面参加的周赛系列... 2255. Count Prefixes of a Given StringAnalysis题意比较直接，给一系列字符串，判断这些字符串是不是 s 的前缀。实际上，需要满足 2 个条件： 第一个字符相同。 是 s 的子串。 Code这是当时提交的代码：12345678910class Solution &#123;public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int size = words.size(), cnt = 0; for(int i = 0; i &lt; size; i++) &#123; if(s.find(words[i]) == 0) cnt++; &#125; return cnt; &#125;&#125;; 其实不用 find 函数，用 substr 函数也是可以的：12345678910class Solution &#123;public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int cnt = 0; for(auto &amp;w: words) &#123; if(s.substr(0, w.length()) == w) cnt++; &#125; return cnt; &#125;&#125;; 也可以全部自己写：1234567891011121314151617class Solution &#123;public: bool isprefix(string &amp;w, string &amp;s) &#123; if(w.length() &gt; s.length()) return false; for(int i = 0; i &lt; w.length(); i++) &#123; if(w[i] != s[i]) return false; &#125; return true; &#125; int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int cnt = 0; for(string &amp;w: words) &#123; if(isprefix(w, s)) cnt++; &#125; return cnt; &#125;&#125;; 思路都是一样的... 2256. Minimum Average DifferenceAnalysis题目稍微有点长，不过意思也很直接，就是将元素分成两部分，算出平均值后，作差取绝对值。 Code这是当时提交的代码：1234567891011121314151617181920class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; vector&lt;long long&gt; pre(size + 1), ave(size + 1); for(int i = 0; i &lt; size; i++) &#123; pre[i + 1] = pre[i] + nums[i]; &#125; for(int i = 0; i &lt; size - 1; i++) &#123; ave[i] = abs(pre[i + 1] / (i + 1) - (pre[size] - pre[i + 1]) / (size - i - 1)); &#125; ave[size - 1] = pre[size] / size; int pos = 0; for(int i = 1; i &lt; size; i++) &#123; if(ave[i] &lt; ave[pos]) pos = i; &#125; return pos; &#125;&#125;; 基本思路是求前缀和，然后再遍历数组算出所有的绝对差，再查找最小的。当时没看数据规模是 $1 \le nums.length \le 10^5$，$0 \le nums[i] \le 10^5$，忽略了在计算过程中可能出现的溢出，结果 WA 了一次，把 vector 的类型改成 long long 后就通过了，坑爹啊。 当时思考的时候，在下标的运算上思考了一会。其实是最后一个数字，出现了 0 作为除数的情况，特别处理一下就可以了。现在看来就没有必要用重新在用数组保存每一个元素的绝对差了：1234567891011121314151617181920212223class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; vector&lt;long long&gt; pre(size + 1); for(int i = 0; i &lt; size; i++) &#123; pre[i + 1] = pre[i] + nums[i]; &#125; long long minabsave = LONG_MAX, tmp; int pos = -1; for(int i = 0; i &lt; size - 1; i++) &#123; tmp = abs(pre[i + 1] / (i + 1) - (pre[size] - pre[i + 1]) / (size - i - 1)); if(tmp &lt; minabsave) &#123; minabsave = tmp; pos = i; &#125; &#125; tmp = pre[size] / size; if(tmp &lt; minabsave) pos = size - 1; return pos; &#125;&#125;; 仔细观察可以发现，如果一开始就把数组的和求出来，那么好像前缀和数组也不需要了。1234567891011121314151617181920212223class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; long long minabsave = LONG_MAX, tmp, sum = 0, pre = 0; for(int i = 0; i &lt; size; i++) &#123; sum += nums[i]; &#125; int pos = -1; for(int i = 0; i &lt; size - 1; i++) &#123; pre += nums[i]; tmp = abs(pre / (i + 1) - (sum - pre) / (size - i - 1)); if(tmp &lt; minabsave) &#123; minabsave = tmp; pos = i; &#125; &#125; tmp = sum / size; if(tmp &lt; minabsave) pos = size - 1; return pos; &#125;&#125;; 2257. Count Unguarded Cells in the GridAnalysis题目意思其实很简单，警卫所有能看见的格子都是被保卫的，被墙堵着，看不见的就是没被保卫的。当时做的时候，总以为是个图的题目，结果写半天 bfs。写完运行发现，结果不对，仔细一想，这好像就是个模拟题？结果又全删了，重新再写。 Code这是当时提交的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(); for(int i = 0; i &lt; walls.size(); i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpy++; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) cnt++; &#125; &#125; return cnt; &#125;&#125;; 上面是当时写的暴力解法，可惜死在第 38 个用例了。基本思路就是用不同的标记来表示某个格子是被保卫的、墙、警卫或没被保卫的，这与现在题目给出的提示是一致的思路。仔细看下上面这段代码，实际上最后一个 $O(n^2)$ 的循环可以省去，直接用矩阵总数减去被标记的格子数目即可。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpy++; &#125; &#125; return m * n - cnt; &#125;&#125;; 可惜这样还是过不去 38 个用例。仔细想想，每个警卫可能存在横坐标或者纵坐标相同的时候，这样按照上面的代码就会产生重复标记的过程。得想办法去除这部分重复的过程，可以使用 set 存入所有的横坐标与纵坐标，然后再分别遍历，但这样无法判断墙是在点的左边还是右边（上边还是下边），这样就会漏解了。看了别人的题解，才发现自己忽略了一个细节...那就是从警卫开始遍历的时候，如果遇到警卫了，也可以直接退出循环（与墙是一样的）。因为，遇到的这个警卫之前的遍历过程也是这样的😂。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpy++; &#125; &#125; return m * n - cnt; &#125;&#125;; em，总算是通过了...忽略了细节啊...不过这段代码看的有点废劲，借用一下图的 bfs 写法，改一下：12345678910111213141516171819202122232425262728293031class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; for(int j = 0; j &lt; 4; j++) &#123; int newx = x + X[j], newy = y + Y[j]; while(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n) &#123; if(matrix[newx][newy] == 0) &#123; matrix[newx][newy] = 1; cnt++; &#125; else if(matrix[newx][newy] != 1) break; newx += X[j]; newy += Y[j]; &#125; &#125; &#125; return m * n - cnt; &#125;&#125;; 好多了，看来还是跟 bfs 有点瓜葛的...😑 2258. Escape the Spreading FireAnalysis题目略长，读完之后，感觉像是第 3 题的加强版...也可以认为是走迷宫的加强版，知道是跟 bfs 相关的题，无奈，没什么思路... Code读了一下大佬们的思路，记录一下。首先要注意到题目要求的是初始位置可以停留的最多分钟数，所以在枚举时间的时候，需要找到一个合适的方式来枚举。另外，题目说明了什么样的情况算是安全到达了——在火蔓延到之前到达安全屋。那么也就是说，人在某个时刻 t 开始逃生，只要能在火势蔓延之前到达安全屋即可。 但是要注意人逃生与火势蔓延的差别，人是在 t 时刻之后才开始逃生（开始动），火是从 0 时刻就开始蔓延了。也就是说，需要先用 bfs 让火势蔓延 t 时刻，然后再用 bfs 得出人逃生的路径的同时让火势继续蔓延，比对二者之间到达相同格子的时刻。 如果人在中途与火相遇了，那肯定就无法逃生了，但人若是与火同时到达安全屋，那也是可以逃生的。 再回头想想如何枚举时间比较合理，按照 $O(n)$ 的时间来枚举肯定不太行，比它更短的时间就是 $O(logn)$ 了，想到这里，脑子里自然就会浮现二分的影子。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; const int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;public: bool check(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int t) &#123; int m = grid.size(), n = grid[0].size(); bool fire[m][n]; memset(fire, 0, sizeof(fire)); vector&lt;pair&lt;int, int&gt;&gt; f, q; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == 1) &#123; fire[i][j] = true; f.emplace_back(i, j); &#125; &#125; &#125; auto separate_fire = [&amp;] () &#123; vector&lt;pair&lt;int, int&gt;&gt; nf; for(auto &amp;[i, j]: f) &#123; for(auto [dx, dy]: dirs) &#123; int x = i + dx, y = j + dy; if(0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; !fire[x][y] &amp;&amp; grid[x][y] != 2) &#123; fire[x][y] = true; nf.emplace_back(x, y); &#125; &#125; &#125; f = move(nf); &#125;; while(t-- &amp;&amp; !f.empty()) separate_fire(); if(fire[0][0]) return false; bool vis[m][n]; memset(vis, 0, sizeof(vis)); vis[0][0] = true; q.emplace_back(0, 0); while(!q.empty()) &#123; vector&lt;pair&lt;int, int&gt;&gt; nq; for(auto &amp;[i, j]: q) &#123; if(!fire[i][j]) &#123; for(auto [dx, dy]: dirs) &#123; int x = i + dx, y = j + dy; if(0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; !fire[x][y] &amp;&amp; !vis[x][y] &amp;&amp; grid[x][y] != 2) &#123; if(x == m - 1 &amp;&amp; y == n - 1) return true; vis[x][y] = true; nq.emplace_back(x, y); &#125; &#125; &#125; &#125; q = move(nq); separate_fire(); &#125; return false; &#125; int maximumMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); int left = -1, right = m * n; while(left &lt; right) &#123; int mid = (left + right + 1) / 2; if(check(grid, mid)) left = mid; else right = mid - 1; &#125; return left &lt; m * n ? left : 1e9; &#125;&#125;; 姑且算是搞清楚了大致的求解过程。不过很显然，对于图的内容早忘完了的我，现在琢磨这个问题有点浪费时间了，暂时先放着。 Summary额，这次周赛之后，从做一个题签个到，变成了做二个题，再签到了，哈哈🤣。回过头来看，第三个题其实已经想到了做法了，只是在如何优化时间上没有经验啊。直接原因是忽略了一些细节，根本原因还是不熟练。仔细想想，第 3 题跟第 4 题好像是递进关系的题目，第 4 题好像是第 3 题的加强版一样，都是 bfs。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day9]]></title>
    <url>%2F2022%2F05%2F08%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day9%2F</url>
    <content type="text"><![CDATA[从周赛回来了~ 1630. Arithmetic SubarraysAnalysis题目有点长，大概意思就是判断给定下标区间内的数能不能构成等差数列。 Code如果这个题要优化时间，感觉可以从构成等差数列的最大区间入手呢？先暴力再说😂。123456789101112131415161718192021222324class Solution &#123;public: vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123; int size = nums.size(), rangesize = l.size(); vector&lt;bool&gt; ret(rangesize); for(int i = 0; i &lt; rangesize; i++) &#123; int left = l[i], right = r[i]; vector&lt;int&gt; tmp; while(left &lt;= right) tmp.push_back(nums[left++]); sort(tmp.begin(), tmp.end()); int diff = tmp[1] - tmp[0]; bool flag = true; for(int j = 1; j &lt; tmp.size() - 1; j++) &#123; if(diff != tmp[j + 1] - tmp[j]) &#123; ret[i] = false; flag = false; break; &#125; &#125; if(flag) ret[i] = true; &#125; return ret; &#125;&#125;; em，暴力过了...🤣想想如何优化，仔细想想构成等差数列的最大区间，其内部的小区间不一定能构成等差数列，所以这个思路可能不太行。这样看来，一定要得把给定的小区间范围内的数挑出来后，才能进行判断。看了一下别人的思路，其实可以避免排序。按照等差数列的性质，数列中每一项减去首项后，得到的结果全部是公差的倍数，这样就只用判断这些差是否能别第一项公差整除即可，就不用排序了。但是要注意公差 d 为 0 时，无法当作除数，但等差数列的公差是可以为 0 的（此时数列为常数列）。12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123; int rangesize = l.size(); vector&lt;bool&gt; ret(rangesize); for(int i = 0; i &lt; rangesize; i++) &#123; int left = l[i], right = r[i]; int min1 = INT_MAX, min2 = INT_MAX; for(int j = left; j &lt;= right; j++) &#123; if(nums[j] &lt; min1 &amp;&amp; nums[j] &lt; min2) &#123; min2 = min1; min1 = nums[j]; &#125; else if(nums[j] &gt;= min1 &amp;&amp; nums[j] &lt; min2) &#123; min2 = nums[j]; &#125; &#125; int size = right - left + 1; if(size &lt;= 2) &#123; ret[i] = true; continue; &#125; int d = min2 - min1; bool flag = true; vector&lt;bool&gt; visited(size, false); for(int j = left; j &lt;= right; j++) &#123; int tmp = nums[j] - min1; if((d == 0 &amp;&amp; tmp != 0) || (d != 0 &amp;&amp; (tmp % d != 0 || tmp / d &gt;= size || visited[tmp / d]))) &#123; flag = false; break; &#125; if(d != 0) visited[tmp / d] = true; &#125; ret[i] = flag; &#125; return ret; &#125;&#125;; 就这个题而言，运行速度确实提升了不少... 429. N-ary Tree Level Order TraversalAnalysis这个题好像是之前每日一题做过的题哈...常规题型，N 叉树的层序遍历。 Code这是原来写的：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; if(!root) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; ret; queue&lt;Node*&gt; q; q.push(root); while(!q.empty()) &#123; int cnt = q.size(); vector&lt;int&gt; level; for(int i = 0; i &lt; cnt; i++) &#123; Node* cur = q.front(); q.pop(); level.push_back(cur-&gt;val); for(auto child: cur-&gt;children) &#123; q.push(child); &#125; &#125; ret.push_back(level); &#125; return ret; &#125;&#125;; 现在写的：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;Node*&gt; q; q.push(root); ret.push_back(&#123;root-&gt;val&#125;); while(!q.empty()) &#123; queue&lt;Node*&gt; tmp; vector&lt;int&gt; v; while(!q.empty()) &#123; Node *node = q.front(); q.pop(); int size = node-&gt;children.size(); for(int i = 0; i &lt; size; i++) &#123; tmp.push(node-&gt;children[i]); v.push_back(node-&gt;children[i]-&gt;val); &#125; &#125; q = tmp; if(v.size() != 0) ret.push_back(v); &#125; return ret; &#125;&#125;; 虽然现在自己写也通过了，不过还是有不足的地方啊...首先是没有必要再用一个队列来保存下一层的结点顺序，只需要每次循环前记录下队列的大小就可以了。其次，就是有些地方还可以再写的简单点...12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;Node*&gt; q; q.push(root); while(!q.empty()) &#123; int cnt = q.size(); vector&lt;int&gt; level; for(int i = 0; i &lt; cnt; i++) &#123; Node* node = q.front(); q.pop(); level.push_back(node-&gt;val); for(auto &amp;child: node-&gt;children) &#123; q.push(child); &#125; &#125; ret.push_back(move(level)); &#125; return ret; &#125;&#125;; 用了一下 move 函数，提升一下速度。 Summary感觉这两个题的难度大概是周赛第二道题的难度...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day8]]></title>
    <url>%2F2022%2F05%2F07%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day8%2F</url>
    <content type="text"><![CDATA[怎么今天还是数学题？ 54. Spiral MatrixAnalysis这个题是在 PTA 上做过的题，题意很简单，其实就是按照螺旋顺序输出数组。 Code两个注意的地方： 当矩阵只有一个元素时，需要特判一下。 当矩阵是 $n × n$ 的方阵时，中间的元素需要特判一下，不然会死循环。 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); int index = 0, count = m * n, r = 0, c = 0; if(count == 1) return matrix[0]; int U = 0, D = m - 1, L = 0, R = n - 1; vector&lt;int&gt; ret(count); while(index &lt; count) &#123; while(index &lt; count &amp;&amp; c &lt; R) ret[index++] = matrix[r][c++]; while(index &lt; count &amp;&amp; r &lt; D) ret[index++] = matrix[r++][c]; while(index &lt; count &amp;&amp; c &gt; L) ret[index++] = matrix[r][c--]; while(index &lt; count &amp;&amp; r &gt; U) ret[index++] = matrix[r--][c]; r++, c++; U++, D--, L++, R--; if(index == count - 1) &#123; ret[index++] = matrix[r][c]; break; &#125; &#125; return ret; &#125;&#125;; 973. K Closest Points to OriginAnalysis找出距离原点最近的 k 个点，有点按照距离排序的味道。 Codemethod 1先排序再说：123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; int size = points.size(); vector&lt;int&gt; dis(size); vector&lt;int&gt; indices(size); for(int i = 0; i &lt; size; i++) &#123; dis[i] = points[i][0] * points[i][0] + points[i][1] * points[i][1]; &#125; iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return dis[i] &lt; dis[j]; &#125;); vector&lt;vector&lt;int&gt;&gt; ret; for(int i = 0; i &lt; k; i++) &#123; ret.push_back(points[indices[i]]); &#125; return ret; &#125;&#125;; 好吧，果然是排序啊，从周赛题学来的思路用到了。仔细想想，重新用数组排序，不如直接拿原数组排序😓：123456789class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; sort(points.begin(), points.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] * a[0] + a[1] * a[1] &lt; b[0] * b[0] + b[1] * b[1]; &#125;); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; 记得排序时要引用，不然时间、内存消耗惨不忍睹...这样排序其实没有上面快，可能是因为计算过程在排序内部的原因。 method 2这个题还可以从堆的角度来思考。由于 C++ 的 priority queue 默认的是大根堆，可以先将前 k 个元素放入堆内，然后遍历剩余 n - k 个元素。每个元素与堆顶元素比较，如果距离大于堆顶元素，就弹出堆顶元素，并将当前元素入队。这样，遍历结束后，堆内的元素就是需要的结果。1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; priority_queue&lt;pair&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; k; i++) &#123; q.emplace(points[i][0] * points[i][0] + points[i][1] * points[i][1], i); &#125; int size = points.size(); for(int i = k; i &lt; size; i++) &#123; int dis = points[i][0] * points[i][0] + points[i][1] * points[i][1]; if(dis &lt; q.top().first) &#123; q.pop(); q.emplace(dis, i); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret; while(!q.empty()) &#123; ret.push_back(points[q.top().second]); q.pop(); &#125; return ret; &#125;&#125;; method 3按照官方题解的思路，这个题还可以从快排的角度来思考：1234567891011121314151617181920212223242526class Solution &#123; mt19937 gen&#123;random_device&#123;&#125;()&#125;;public: void random_select(vector&lt;vector&lt;int&gt;&gt;&amp; points, int left, int right, int k) &#123; int pivot_id = uniform_int_distribution&lt;int&gt;&#123;left, right&#125;(gen); int pivot = points[pivot_id][0] * points[pivot_id][0] + points[pivot_id][1] * points[pivot_id][1]; swap(points[right], points[pivot_id]); int i = left - 1; for(int j = left; j &lt; right; j++) &#123; int dis = points[j][0] * points[j][0] + points[j][1] * points[j][1]; if(dis &lt;= pivot) &#123; i++; swap(points[i], points[j]); &#125; &#125; i++; swap(points[i], points[right]); if(k &lt; i - left + 1) random_select(points, left, i - 1, k); else if( k &gt; i - left + 1) random_select(points, i + 1, right, k - (i - left + 1)); &#125; vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; int size = points.size(); random_select(points, 0, size - 1, k); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; 对目前的自己信息量有点大，先放着了😑。但是得先记着直接调用库函数的解决方法：123456789class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; nth_element(points.begin(), points.begin() + k - 1, points.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] * a[0] + a[1] * a[1] &lt; b[0] * b[0] + b[1] * b[1]; &#125;); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; 太顶了😂。 Summary矩阵的题做的有点无聊了，第二个题感觉还可以，有点意思~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day7]]></title>
    <url>%2F2022%2F05%2F06%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day7%2F</url>
    <content type="text"><![CDATA[今天不出门了... 48. Rotate ImageAnalysis题意很简单，将矩阵顺时针旋转 90° 即可。 Codemethod 1尽管题目限定了原地交换，但还是先不按照要求做一下。抛开限制条件之后，这实际上就是矩阵的行转列问题。1234567891011121314class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), r = 0, c = 0; vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n)); for(int i = n - 1; i &gt;= 0; i--) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[r++][c] = matrix[i][j]; &#125; r = 0, c++; &#125; matrix = ret; &#125;&#125;; 虽然这段代码也能过，但是没有找出转换规律，把行列互换的思想带入到代码内：12345678910111213class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[j][n - 1 - i] = matrix[i][j]; &#125; &#125; matrix = ret; &#125;&#125;; 这样就可以看出 matrix 与转换后的矩阵的坐标规律了。 method 2现在，再来思考一下加入限制条件后的方法。按照前面的思路，对于矩阵中的任意元素，可以得到：$ret[c][n - 1 - r] = matrix[r][c]$，也就是说，需要在 $(c, n - 1 - r)$ 这个位置填入 $matrix[r][c]$。这样，如果直接交换 $matrix[r][c]$ 和 $matrix[c][n - 1 - r]$ 不就可以达到原地交换的效果了吗？但问题是 $matrix[c][n - 1 - r]$ 转换后的位置不是 $(r, c)$，那是什么？按照前面的思路，$matrix[c][n - 1 - r]$ 的位置应该是 $matrix[n - 1 - r][n - 1 - c]$。此时，可以发现由于矩阵有 4 条边，所以每一轮交换中也是 4 个数在进行交换。按照规律，可以很容易的找到这 4 个数，并且相互交换，这样可以得到下面的过程：123swap(matrix[r][c], matrix[c][n - 1 - r])swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c])swap(matrix[r][c], matrix[n - 1 - c][r]) 注意因为交换位置之后，原来位于其他位置的元素在进行交换后都到了 $(r, c)$ 这个位置，所以实际上每次都是这个位置在进行交换。明确交换过程后，还需要解决一个问题，那就是如何枚举需要交换的元素呢？此时，按照矩阵的边长又可以分成 2 种情况： 奇数，矩阵中心的元素不用交换，剩余元素需要交换。 偶数，矩阵所有元素都需要交换。 另外，由于每次交换是 4 个元素一起交换，所以枚举了 1 个之后，剩下的元素是已经交换完成了，就不用再枚举了，那也就是说实际上只用枚举的元素个数是：$$\begin{cases}\frac {n^2}{4} &amp; n 是偶数 \\\frac {n^2 - 1}{4} &amp; n 是奇数 \\\end{cases}$$显然，r 的取值范围是 $[0, n / 2)$，那 c 呢？实际上，枚举的方法也有多种，所以 c 的范围也有区别。这里举两种枚举方法：一种是从外层枚举到内层的方法（也可以认为是顺时针交换），此时 c 的范围是 $[r, end - 1)$，end - 1 就是内层矩阵列的边界，end 这个值一开始是等于 n 的，但是交换完一层元素后，需要减 1，再把坐标移到内层进行交换。1234567891011121314class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), end = n; for(int r = 0; r &lt; n / 2; r++) &#123; for(int c = r; c &lt; end - 1; c++) &#123; swap(matrix[r][c], matrix[c][n - 1 - r]); swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c]); swap(matrix[r][c], matrix[n - 1 - c][r]); &#125; end--; &#125; &#125;&#125;; 这种思路稍微可能稍微有点绕...还有一种是将矩阵分块，将矩阵按照元素个数相等的规则分成 4 块，这样只用枚举第一块的元素，就可以完成整个矩阵的交换了，此时 c 的范围就是 $[0, \frac{n + 1}{2})$ 了。12345678910111213class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int r = 0; r &lt; n / 2; r++) &#123; for(int c = 0; c &lt; (n + 1) / 2; c++) &#123; swap(matrix[r][c], matrix[c][n - 1 - r]); swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c]); swap(matrix[r][c], matrix[n - 1 - c][r]); &#125; &#125; &#125;&#125;; 感觉这种思路更直接一点。 method 3现在再来回头看这个问题，利用矩阵变换（前面提到的行列互换），可以很轻松的得到结果，但需要消耗额外空间；为了不消耗额外空间，就无法行列互换，只能找出坐标规律，直接交换。如果能把矩阵的变换与找规律结合起来，能不能实现原地交换呢？答案是可以的...以样例中的矩阵 $$\begin{bmatrix}5 &amp; 1 &amp; 9 &amp; 11 \\2 &amp; 4 &amp; 8 &amp; 10 \\13 &amp; 3 &amp; 6 &amp; 7 \\15 &amp; 14 &amp; 12 &amp; 16 \\\end{bmatrix}$$ 按照水平轴翻转，得到 $$\begin{bmatrix}15 &amp; 14 &amp; 12 &amp; 16 \\13 &amp; 3 &amp; 6 &amp; 7 \\2 &amp; 4 &amp; 8 &amp; 10 \\5 &amp; 1 &amp; 9 &amp; 11 \\\end{bmatrix}$$ 再按主对角线翻转（也就是求矩阵的转置矩阵），得到 $$\begin{bmatrix}15 &amp; 13 &amp; 2 &amp; 5 \\14 &amp; 3 &amp; 4 &amp; 1 \\12 &amp; 6 &amp; 8 &amp; 9 \\16 &amp; 7 &amp; 10 &amp; 11 \\\end{bmatrix}$$ 这就是需要的结果...😂水平轴翻转只需要枚举一半的矩阵元素即可：12345for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125;&#125; 同样，主对角线翻转也只需要枚举一半的矩阵元素：12345for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125;&#125; 联立起来，就可以得到完整的通过代码了：12345678910111213141516class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; 为什么可以这样做呢？水平轴翻转时坐标的变换规律是：$matrix[r][c] &lt;=&gt; matrix[n - 1 - r][c]$。主对角线翻转时坐标的变换规律是：$matrix[r][c] &lt;=&gt; matrix[c][r] = matrix[c][n - 1 - r]$。这与前面的规律实际上是一致的...只不过水平轴翻转时，只有主对角线上的元素被交换到了最终位置。再回头想想，如果一开始将矩阵转置，然后再将矩阵竖直翻转不也可以得到最终结果吗？哈哈另外，再说点题外话。按照线性代数的理论，像这样的矩阵变换应该可以通过乘以一个特殊的单位矩阵得到...也许还有更简单的方法吧... 1886. Determine Whether Matrix Can Be Obtained By RotationAnalysis这个题有点像上面那个题的升级版，依次顺时针转换 90°，如果与给定矩阵相同，就返回 true，否则返回 false。有了前面的思考，这个题简直不要太简单哈。一个矩阵最多按 90° 旋转 4 次就回到它最初的样子了，所以，这个题最多旋转 3 次就可以得到结果了。 Code直接复制粘贴了😁...1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123; if(mat == target) return true; int n = mat.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; return false; &#125;&#125;; 把上面写的函数抄过来，封装一下：123456789101112131415161718192021222324class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125; bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123; if(mat == target) return true; for(int i = 0; i &lt; 3; i++) &#123; rotate(mat); if(mat == target) return true; &#125; return false; &#125;&#125;; 嗯，看起来舒服多了... Summary不知道这种矩阵变换的实际应用场景是什么...突然有点好奇了...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day6]]></title>
    <url>%2F2022%2F05%2F05%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day6%2F</url>
    <content type="text"><![CDATA[冲啊~ 739. Daily TemperaturesAnalysis找出每一天之后再过几天的温度会比这一天高（我在写啥呢😂），感觉有点 dp 的味道？ Codemethod 1先暴力再说：12345678910111213class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int index = i + 1; while(index &lt; size &amp;&amp; temperatures[index] &lt;= temperatures[i]) index++; if(index != size) ret[i] = index - i; &#125; return ret; &#125;&#125;; 好吧，果不其然的超时了。这个暴力做法的时间复杂度是 $O(n^2)$，很难不超时。换个角度想一下，如果从后往前遍历数组会怎么样？这样最后一个数字的返回值一定是 0，然后，继续向前遍历，如果遇到与之前遍历过的数字小的数字，那要怎么计算当前数字的返回值呢？所以需要提前将出现过的数字的下标记录下来。由于是从后往前遍历，即使是存在重复元素，也可以保证记录的下标是当前数字后距离其最近的那个数字，也就可以满足是第一个比当前数字大的数字的条件了。1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int size = temperatures.size(); vector&lt;int&gt; ret(size), indices(101, INT_MAX); for(int i = size - 1; i &gt;= 0; i--) &#123; int warmerindex = INT_MAX; for(int tem = temperatures[i] + 1; tem &lt;= 100; tem++) &#123; warmerindex = min(warmerindex, indices[tem]); &#125; if(warmerindex == INT_MAX) ret[i] = 0; else ret[i] = warmerindex - i; indices[temperatures[i]] = i; &#125; return ret; &#125;&#125;; 这个是可以通过的，对应的时间复杂度是 $O(n \times D)$，其中 $n$ 是数组元素个数，$D$ 是 100 与数组元素的差，最坏情况下是 70。对应的空间复杂度是 $O(c)$, 其中 c 是 $100$。 method 2实际上这个题可以用单调栈的思想来处理，不过在解决这道题之前可以用另外一道题熟悉一下单调栈的思想：496. Next Greater Element I。123456789101112131415class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; stack&lt;int&gt; st; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = size - 1; i &gt;= 0; i--) &#123; int tmp = temperatures[i]; while(!st.empty() &amp;&amp; temperatures[st.top()] &lt;= tmp) st.pop(); ret[i] = st.empty() ? 0 : st.top() - i; st.push(i); &#125; return ret; &#125;&#125;; 感觉从后往前遍历比较好理解，始终让栈顶保存比当前元素大且距离最近的元素的下标。如果栈空，说明当前元素后没有更大的元素了，就返回 0；如果栈不空，就判断栈顶元素是不是比当前元素大，满足条件，二者下标之差就是返回值，不满足就出栈，判断栈内其他元素是否满足。如果要从前往后做也不是不行，但是由于最大值是后面才出现的，所以只能在出现更大值后，再更新前面的值需要返回的下标：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; stack&lt;int&gt; st; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int tem = temperatures[i]; while(!st.empty() &amp;&amp; tem &gt; temperatures[st.top()]) &#123; int previousindex = st.top(); ret[previousindex] = i - previousindex; st.pop(); &#125; st.push(i); &#125; return ret; &#125;&#125;; 两个遍历过程比较一下，可以发现，从后往前遍历，栈中下标代表的元素值从栈顶到栈底是递增的，而从前往后遍历，元素值从栈顶到栈底是递减的。 58. Length of Last WordAnalysis找出字符串最后一个单词的长度，字符串的前面和后面都可能存在多个空格。 Code嗯，好像找到最后一个字符的下标与最后一个空格的下标，做差就行了？12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = s.length(); int lastspaceindex = INT_MAX, lastcharindex = INT_MAX; for(int i = len - 1; i &gt;= 0; i--) &#123; if(isalpha(s[i]) &amp;&amp; lastcharindex == INT_MAX) lastcharindex = i; if(s[i] == ' ' &amp;&amp; lastcharindex != INT_MAX) &#123; lastspaceindex = i; break; &#125; &#125; if(lastspaceindex == INT_MAX) return lastcharindex + 1; else return lastcharindex - lastspaceindex; &#125;&#125;; 感觉这个思路不是很清晰...把查找最后一个单词的下标与查找最后一个单词前空格的下标分开写吧：1234567891011121314151617181920class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = s.length(); int spaceindex, lastcharindex = len - 1; for(int i = len - 1; i &gt;= 0; i--) &#123; if(isalpha(s[i])) &#123; lastcharindex = i; break; &#125; &#125; spaceindex = lastcharindex - 1; while(spaceindex &gt;= 0) &#123; if(s[spaceindex] == ' ') break; spaceindex--; &#125; if(spaceindex == -1) return lastcharindex + 1; else return lastcharindex - spaceindex; &#125;&#125;; 同样是一个循环，为什么这个提交上去时间会比上一个快不少？是因为上一段代码 if 写太多了吗？写到这里，可以发现，其实不做差也行，弄一个计数变量统计一下就行了。偷下懒，不写了吧... Summary单调栈的思想感觉很不多，用来求下一个最大或最小好像挺好用的？突然想起来上个月做的 PAT 真题了...等下去写一下。话说回来，对单调栈的掌握还不是很牢固，还得多来点题目巩固一下。做上面那个题目的时候，还想到了上周周赛排序 + 二分的思路了，结果写完，发现有重复元素就不行了😂，方法没选对，就很难受了。不过，也说明自己对排序 + 二分的思路理解的不够深刻吧。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day5]]></title>
    <url>%2F2022%2F05%2F04%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day5%2F</url>
    <content type="text"><![CDATA[在外面待了一天...还好是两个简单题哈~ 67. Add BinaryAnalysis二进制加法，应该不难哈。 Code因为题目给定的 a 和 b 的长度规模在 $[1, 10^4]$，所以不能转换成十进制求和后再转换为二进制。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int p1 = 0, p2 = 0, carry = 0; while(p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123; int tmp = a[p1++] + b[p2++] + carry - 2 * '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else if(tmp == 2) &#123; ans.push_back('0'); carry = 1; &#125; else &#123; ans.push_back('1'); carry = 1; &#125; &#125; while(p1 &lt; len1) &#123; int tmp = carry + a[p1++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; while(p2 &lt; len2) &#123; int tmp = carry + b[p2++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 先逆置字符串会方便计算，因为不知道那个数更大，所以干脆都写一个循环算了。嗯，现在把重复的部分封装一下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; void addremains(string &amp;s, int &amp;pos, string &amp;ans, int &amp;carry) &#123; while(pos &lt; s.length()) &#123; int tmp = carry + s[pos++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; &#125;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int p1 = 0, p2 = 0, carry = 0; while(p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123; int tmp = a[p1++] + b[p2++] + carry - 2 * '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else if(tmp == 2) &#123; ans.push_back('0'); carry = 1; &#125; else &#123; ans.push_back('1'); carry = 1; &#125; &#125; if(p1 != len1) addremains(a, p1, ans, carry); if(p2 != len2) addremains(b, p2, ans, carry); if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 感觉这样写不太美观哈。实际上，也不是一定非要写到外面去，carry 对应的不同情况也可以通过取余运算和除运算汇总到一起。12345678910111213141516171819class Solution &#123;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int maxlen = max(len1, len2), carry = 0; for(int i = 0; i &lt; maxlen; i++) &#123; carry += i &lt; len1 ? (a[i] == '1') : 0; carry += i &lt; len2 ? (b[i] == '1') : 0; ans.push_back((carry % 2) ? '1' : '0'); carry /= 2; &#125; if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 如果题目限制了四则运算，那这个题还可以用位运算来解决，之后补一下吧。 989. Add to Array-Form of IntegerAnalysis一个以数组形式储存的整数和一个 int 型整数，计算二者之和。 Code因为 k 的取值范围是 $[1, 10^4]$，所以 k 最多也就是 5 位，那么实际上只用计算数组的最后几位与 k 的和，然后在加回数组上去就可以了。但是又可能存在 num 比 k 小的情况，这样综合考虑下来，不如直接两个数组做大数加法得了😓。按照上一个题的思路来完成就可以了：12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; vector&lt;int&gt; knum, ans; while(k) &#123; knum.push_back(k % 10); k /= 10; &#125; reverse(num.begin(), num.end()); int carry = 0, size1 = num.size(), size2 = knum.size(); int maxsize = max(size1, size2); for(int i = 0; i &lt; maxsize; i++) &#123; carry += i &lt; size1 ? num[i] : 0; carry += i &lt; size2 ? knum[i] : 0; ans.push_back(carry % 10); carry /= 10; &#125; if(carry) ans.push_back(carry); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 但是针对这个问题而言，真的需要用一个数组来保存 k 吗？应该是不需要的吧。12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; vector&lt;int&gt; ans; int size = num.size(); for(int i = size - 1; i &gt;= 0; i--) &#123; int sum = num[i] + k % 10; k /= 10; if(sum &gt;= 10) &#123; k++; sum -= 10; &#125; ans.push_back(sum); &#125; while(k) &#123; ans.push_back(k % 10); k /= 10; &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 看了下官方的题解，这个题好像还有一种思路，那就是直接把 k 加到最后一位，让个位数字为这一位的结果，剩下的数字在加上前一位：12345678910111213class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; int size = num.size(); vector&lt;int&gt; ans; for(int i = size - 1; i &gt;= 0 || k &gt; 0; i--, k /= 10) &#123; if(i &gt;= 0) k += num[i]; ans.push_back(k % 10); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 这段代码好像看起来更精简一点。 Summary这两天做的题怎么都是这种大数四则运算的题目？感觉没什么趣味性...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day4]]></title>
    <url>%2F2022%2F05%2F03%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day4%2F</url>
    <content type="text"><![CDATA[又钓了一天鱼...忘记做防晒了，胳膊肘子都晒红了... 1367. Linked List in Binary TreeAnalysis判断链表序列是否存在于树的路径中。 Code先用官方题解的思路水过去了...12345678910111213class Solution &#123; bool dfs(TreeNode *rt, ListNode *head) &#123; if(head == nullptr) return true; if(rt == nullptr) return false; if(rt-&gt;val != head-&gt;val) return false; return dfs(rt-&gt;left, head-&gt;next) || dfs(rt-&gt;right, head-&gt;next); &#125;public: bool isSubPath(ListNode* head, TreeNode* root) &#123; if(root == nullptr) return false; return dfs(root, head) || isSubPath(head, root-&gt;left) || isSubPath(head, root-&gt;right); &#125;&#125;; em，现在再来把这个题做一下。第一眼看到这个题目的时候，想到的做法其实是先求出所有叶结点的路径，然后再判断链表序列是不是路径的子串即可。可惜，忘记路径怎么求的了。所以，又重新做了一下另外一个题：257. Binary Tree Paths。做完这个题之后，就可以再按照这个思路来做了。PS：因为路径可以通过 bfs 和 dfs 来求，所以也写出类似的思路吧。dfs：12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; paths; void dfs(TreeNode *root, string path) &#123; if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; path += to_string(root-&gt;val); paths.push_back(path); return; &#125; path += to_string(root-&gt;val); dfs(root-&gt;left, path); dfs(root-&gt;right, path); &#125; bool isSubPath(ListNode* head, TreeNode* root) &#123; string listseq; while(head) &#123; listseq += to_string(head-&gt;val); head = head-&gt;next; &#125; dfs(root, ""); int size = paths.size(); for(int i = 0; i &lt; size; i++) &#123; if(paths[i].find(listseq) != string::npos) return true; &#125; return false; &#125;&#125;; 虽然可以通过，但是时间消耗跟内存消耗实在是惨不忍睹了...bfs：12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isSubPath(ListNode* head, TreeNode* root) &#123; string listseq; while(head) &#123; listseq += to_string(head-&gt;val); head = head-&gt;next; &#125; queue&lt;TreeNode*&gt; q; queue&lt;string&gt; path; q.push(root); path.push(to_string(root-&gt;val)); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); string tmp = path.front(); path.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) tmp += to_string(node-&gt;val); if(tmp.length() &gt;= listseq.length()) &#123; if(tmp.find(listseq) != string::npos) return true; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); path.push(tmp + to_string(node-&gt;left-&gt;val)); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); path.push(tmp + to_string(node-&gt;right-&gt;val)); &#125; &#125; return false; &#125;&#125;; 用 bfs 消耗的时间会比上面的 dfs 要少（尽管依然惨不忍睹），因为使用 bfs 并不是一定要求出所有的路径，只需要判断当前得到的树的结点序列是否包含了链表序列即可。现在回头来想一下官方题解中用到的方法，实际是就是 dfs 求结点路径的同时遍历链表，这样时间消耗才会降低。 43. Multiply StringsAnalysis大数乘法，按照列算式做乘法的规则，算出每一位与另外一个数的积，然后依次加起来就可以得到最后结果了。做这个题的同时算是把大数加法也复习了一下。 Codemethod 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; string ans = "0"; int len1 = num1.length(), len2 = num2.length(); for(int i = len2 - 1; i &gt;= 0; i--) &#123; string curr; int add = 0; for(int j = len2 - 1; j &gt; i; j--) &#123; curr.push_back(0); &#125; int y = num2.at(i) - '0'; for(int j = len1 - 1; j &gt;= 0; j--) &#123; int x = num1.at(j) - '0'; int product = x * y + add; curr.push_back(product % 10); add = product / 10; &#125; while(add != 0) &#123; curr.push_back(add % 10); add /= 10; &#125; reverse(curr.begin(), curr.end()); for(auto &amp;c: curr) &#123; c += '0'; &#125; ans = addStrings(ans, curr); &#125; return ans; &#125; string addStrings(string &amp;num1, string &amp;num2) &#123; int i = num1.size() - 1, j = num2.size() - 1, add = 0; string ans; while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123; int x = i &gt;= 0 ? num1.at(i) - '0' : 0; int y = j &gt;= 0 ? num2.at(j) - '0' : 0; int result = x + y + add; ans.push_back(result % 10); add = result / 10; i--; j--; &#125; reverse(ans.begin(), ans.end()); for (auto &amp;c: ans) &#123; c += '0'; &#125; return ans; &#125;&#125;; 字符串相加的函数是这个题：415. Add Strings。做完 415 之后，又把这个题重新做了一下，思路上没有什么变化，只是按照自己的风格写了下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; string ans = "0"; int len1 = num1.length(), len2 = num2.length(); for(int i = len2 - 1; i &gt;= 0; i--) &#123; string tmp; int number = num2[i] - '0', carry = 0; for(int j = len2 - 1; j &gt; i; j--) &#123; tmp.push_back('0'); &#125; for(int j = len1 - 1; j &gt;= 0; j--) &#123; int res = number * (num1[j] - '0') + carry; if(res &gt; 9) &#123; carry = res / 10; res %= 10; &#125; else carry = 0; tmp.push_back(res + '0'); &#125; while(carry) &#123; tmp.push_back(carry % 10 + '0'); carry /= 10; &#125; reverse(tmp.begin(), tmp.end()); ans = addStrings(ans, tmp); &#125; return ans; &#125; string addStrings(string num1, string num2) &#123; string ans; int len1 = num1.length(), len2 = num2.length(), carry = 0; for(int i = len1 - 1, j = len2 - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = carry; sum += i &gt;= 0 ? num1[i] - '0' : 0; sum += j &gt;= 0 ? num2[j] - '0' : 0; if(sum &gt;= 10) &#123; carry = 1; sum -= 10; &#125; else carry = 0; ans.push_back(sum + '0'); &#125; if(carry) ans.push_back(carry + '0'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; 按照前面提到的，这种方法本质上是在做加法。 method 2看了一下官方解法的第二种方法，本质上是先转换为数组，然后进行乘法运算。具体的计算过程其实与做加法是差不多的，只是在处理每一位与另一个数的每一位相乘的结果时，做了一点优化。按照乘法的计算规则，每次运算得到的结果在最后结果的哪一位（十、百、千位等）上是可以确定，所以直接累加起来就好了，而且这个数字肯定是不大于 100 的，但可能是 2 位数或 1 位数。然后再统一处理进位，就会比较方便。最后就是把每一位数字转换为字符了。还有一点要注意的是，一个 m 位数和一个 n 位数，二者的结果一定是一个 m + n - 1 位数或 m + n 位数，也就是说结果的长度最多不超过 m + n。12345678910111213141516171819202122232425class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; int len1 = num1.length(), len2 = num2.length(); vector&lt;int&gt; ansarr(len1 + len2); for(int i = len1 - 1; i &gt;= 0; i--) &#123; int x = num1[i] - '0'; for(int j = len2 - 1; j &gt;= 0; j--) &#123; int y = num2[j] - '0'; ansarr[i + j + 1] += x * y; &#125; &#125; for(int i = len1 + len2 - 1; i &gt; 0; i--) &#123; ansarr[i - 1] += ansarr[i] / 10; ansarr[i] %= 10; &#125; int index = ansarr[0] == 0 ? 1 : 0; string ans; while(index &lt; len1 + len2) &#123; ans.push_back(ansarr[index++] + '0'); &#125; return ans; &#125;&#125;; Summary今天的两个题都是水过去的😑，明天还有点事，早点睡了，后面再补吧... 2022-5-5 23:50 补了下第二个题。2022-5-6 21:04 补了下第一个题。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day3]]></title>
    <url>%2F2022%2F05%2F02%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day3%2F</url>
    <content type="text"><![CDATA[钓鱼去了，晚上才回来~ 赶紧，赶紧。 150. Evaluate Reverse Polish NotationAnalyisem，首先得知道，Reverse Polish Notation 就是后缀表达式，也就是说，这是个后缀表达式求值的问题。一般而言，后缀表达式的问题是用栈来求解的。 Code直接用栈做。123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; int size = tokens.size(); for(int i = 0; i &lt; size; i++) &#123; if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") &#123; int a, b, res; a = st.top(); st.pop(); b = st.top(); st.pop(); if(tokens[i] == "+") res = a + b; else if(tokens[i] == "-") res = b - a; else if(tokens[i] == "*") res = a * b; else if(tokens[i] == "/") res = b / a; st.push(res); &#125; else &#123; int tmp = 0, len = tokens[i].length(); int index = 0, flag = true; if(tokens[i][index] == '-') &#123; flag = false; index++; &#125; while(index &lt; len) &#123; tmp = tmp * 10 + tokens[i][index] - '0'; index++; &#125; if(!flag) tmp = -tmp; st.push(tmp); &#125; &#125; return st.top(); &#125;&#125;; 需要注意的地方就是减（除）法时，分清楚减（除）数与被减（除）数。em，借用一下库函数，再精简一下：123456789101112131415161718192021class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; int size = tokens.size(); for(int i = 0; i &lt; size; i++) &#123; if(isdigit(tokens[i][0]) || isdigit(tokens[i][1])) &#123; st.push(atoi(tokens[i].c_str())); &#125; else &#123; int a, b; a = st.top(); st.pop(); b = st.top(); st.pop(); if(tokens[i] == "+") st.push(a + b); else if(tokens[i] == "-") st.push(b - a); else if(tokens[i] == "*") st.push(a * b); else st.push(b / a); &#125; &#125; return st.top(); &#125;&#125;; 用 isdigit 函数判断是否是数字时，不要直接判断第二个字符，这样可能会越界。因为 Leetcode 给的一定是合法的后缀表达式，所以可以写的这么“肆无忌惮”😜。 66. Plus OneAnalysis不算大数加法的大数加法题。 Code12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(), i = 0; reverse(digits.begin(), digits.end()); int carry = 1; while(i &lt; size) &#123; digits[i] += carry; if(digits[i] &gt;= 10) &#123; digits[i] -= 10; carry = 1; &#125; else carry = 0; i++; &#125; if(carry) digits.push_back(carry); reverse(digits.begin(), digits.end()); return digits; &#125;&#125;; 先逆置的原因是，如果存在进位，可以直接在数组末尾添加，重新逆置后就是结果了。剪一下枝：1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(), i = 0; if(digits[size - 1] + 1 &lt; 10) &#123; digits[size - 1] += 1; return digits; &#125; reverse(digits.begin(), digits.end()); int carry = 1; while(i &lt; size) &#123; digits[i] += carry; if(digits[i] &gt;= 10) &#123; digits[i] -= 10; carry = 1; &#125; else &#123; carry = 0; break; &#125; i++; &#125; if(carry) digits.push_back(carry); reverse(digits.begin(), digits.end()); return digits; &#125;&#125;; 看了别人的做法，这个题可以从判断每一位计算后是不是 0 来思考，如果是 0 那么说明有进位，继续计算，如果没有，就可以退出循环了：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(); int i = size - 1; while(i &gt;= 0) &#123; digits[i]++; if(digits[i] == 10) digits[i] = 0; else break; i--; &#125; if(digits[0] == 0) &#123; digits.push_back(0); digits[0] = 1; &#125; return digits; &#125;&#125;; 不得不说，这个思路确实比较好。 Summary钓鱼回来有点累，还好问题轻松解决，可以早点睡觉了😂。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day2]]></title>
    <url>%2F2022%2F05%2F01%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day2%2F</url>
    <content type="text"><![CDATA[我发现在这个系列不给每日的主题了。 110. Balanced Binary TreeAnalysis判断一颗树是否是平衡二叉树。 Codebfs用 dfs 写了半天还是 WA 了，改用 bfs 了😤。bfs：12345678910111213141516171819class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(abs(getdepth(node-&gt;left) - getdepth(node-&gt;right)) &gt; 1) return false; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return true; &#125;&#125;; 用 bfs 感觉思考起来轻松很多啊。 dfsem，用 bfs 通过之后，思路清晰了很多，又把 dfs 改了一下通过了。dfs：12345678910111213class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1; if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1; return abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; 改一下：1234567891011121314class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1; if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1; if(abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &gt; 1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; 感觉思路还是不够清晰，再改下：1234567891011121314class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;right); if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left); if(abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &gt; 1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; 试了下，也可以不写这么多 if（XD）：1234567891011class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; return abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; 以上代码的思路实际上是基于先序遍历的思路来完成的，这种思路的缺点在于每遇到一个结点就要计算出其子树的深度，在计算深度的过程中，就会重复的遍历那些叶子结点。为了避免这个缺点，可以使用后序遍历的思路来完成：12345678910111213class Solution &#123;public: int height(TreeNode *root) &#123; if(!root) return 0; int leftheight = height(root-&gt;left); int rightheight = height(root-&gt;right); if(leftheight == -1 || rightheight == -1 || abs(leftheight - rightheight) &gt; 1) return -1; else return max(leftheight, rightheight) + 1; &#125; bool isBalanced(TreeNode* root) &#123; return height(root) &gt;= 0; &#125;&#125;; 两种思考方法其实大同小异。 459. Repeated Substring PatternAnalysis判断一个字符串是否可以由其子串重复构成。 Codemethod 1先暴力做一下：12345678910111213141516class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; int len = s.length(); for(int i = 1; i &lt;= len / 2; i++) &#123; if(len % i == 0) &#123; for(int j = 0; j &lt; len - i; j += i) &#123; string tmp = s.substr(j, i), t; while(t.length() &lt; len) t += tmp; if(t == s) return true; &#125; &#125; &#125; return false; &#125;&#125;; 果然超时了。观察一下上面的暴力解法，在第二层循环内，按间隔去除子串后，又按照原字符串的长度，将子串构造成等长的字符串，最后再判断是否一致，从而来判断是否满足条件，所以这段代码的时间复杂度是 $O(n^3)$。可问题在于，真的需要重新构造一个字符串，来进行判断吗？答案是不用，因为每次枚举的是子串的长度，所以只需要根据这个长度来判断不同子串的字符是否一致即可。12345678910111213141516class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; int len = s.length(); for(int i = 1; i &lt;= len / 2; i++) &#123; if(len % i == 0) &#123; for(int j = 0; j &lt; len - i; j += i) &#123; string tmp = s.substr(j, i), t; while(t.length() &lt; len) t += tmp; if(t == s) return true; &#125; &#125; &#125; return false; &#125;&#125;; 这段代码的时间复杂度是 $O(n^2)$，是可以通过的。 method 2有了上面的思考，应该就认识到这个题是个字符串匹配的问题，毫无疑问，可以用 KMP 来完成。但 KMP 早就忘了，以后再看吧。仔细观察一下样例，符合条件的字符串都有一个特点，那就是其满足条件的子串一定是出现多次的（实际上最少得出现 2 次，此时子串的长度是原串的一半）。这样，不妨原串 s 拼接成 s+s，然后第一个字符与最后一个字符，得到一个新字符串 news，此时再来判断 s 是否是 news 的子串。如果是，那么就是满足条件的，反之则不满足条件。123456class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; return (s + s).find(s, 1) != s.length(); &#125;&#125;; 直接调用库函数就可以完成，也不用严格意义上的删除第一个字符与最后一个字符。 Summary虽然是 2 个简单题，不过都得动动脑子才能通过啊。如果还想要更优的解法，还得下更多功夫...另外，至于 KMP，日后再说了...😑]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode 第 290 场周赛]]></title>
    <url>%2F2022%2F04%2F30%2FLeetcode-%E7%AC%AC-290-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[如题... 这是第一次在 Leetcode 上参加周赛，签了一下到😆。 2248. Intersection of Multiple ArraysAnalysis第一个题比较简单，找出数组的交集即可。 Code12345678910111213141516class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; cnt(1005), ret; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; nums[i].size(); j++) &#123; cnt[nums[i][j]]++; &#125; &#125; for(int i = 0; i &lt; 1005; i++) &#123; if(cnt[i] == size) ret.push_back(i); &#125; return ret; &#125;&#125;; 这是当时自己的做法。时间复杂度与空间复杂度都是 $O(n)$。这样写其实有个缺陷，那就是受限于数组元素的大小，如果出现负数或者太大的数，就有问题了。所以，应该用 map 取代普通的数组。如果不要求有序，用 unordered_map 可能会更好：123456789101112131415class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int size = nums.size(); map&lt;int, int&gt; cnt; for(auto v: nums) &#123; for(int x: v) cnt[x]++; &#125; vector&lt;int&gt; ret; for(auto [key, val]: cnt) &#123; if(val == size) ret.push_back(key); &#125; return ret; &#125;&#125;; 这个题还可以使用 set 来模拟，依次求当前数组与 set 内元素的交集，得到的交集再与下一个数组求交集（需要有一个 tmpset 来保存结果），依次求完，最后的结果就是所有数组的交集。不过这种做法没有用 map 的方法直接明了，所以就不写了。 6043. Count Number of Rectangles Containing Each PointAnalysis这是第 3 个题，不过是第二个提交的题。题意理解起来还算容易，就是求出每个点被多少个矩形包括。 Code理解题意后，其实可以发现这不是个很复杂的题目。判断一个点是否在矩形内，只需要这个点的横纵坐标分别小于等于矩形右上端点（也就是题目给的点）的横纵坐标即可，那么很容易的就会想到暴力解法：123456789101112131415class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; vector&lt;int&gt; ret; int pointnums = points.size(), rectanglenums = rectangles.size(); for(int i = 0; i &lt; pointnums; i++) &#123; int x = points[i][0], y = points[i][1], cnt = 0; for(int j = 0; j &lt; rectanglenums; j++) &#123; if(x &lt;= rectangles[j][0] &amp;&amp; y &lt;= rectangles[j][1]) cnt++; &#125; ret.push_back(cnt); &#125; return ret; &#125;&#125;; 这是当时提交的代码，果然，提交上去超时了。没想到怎么优化时间复杂度，就放弃了...😂简单分析一下，可以知道上述算法的时间复杂度是 $O(m \times n)$，其中 $m$ 是点个数，$n$ 是矩形的个数，这不超时就怪了。后面看了别人的解题思路后，发现其实这个（准确说是这类）问题其实可以分解成 2 个子问题： 判断当前点的横坐标是不是都小于等于所有矩形的横坐标。 判断当前点的纵坐标是不是都小于等于所有矩形的纵坐标。 如果能把这两个事情放在两个单独的循环完成，或者说分开进行，然后合并 2 个结果是不是就能缩短时间复杂度了呢？当然是的啊！虽然这个问题的解决过程肯定不可能这么理想化，不过这是一个不错的思考思路。进一步观察题目，可以发现纵坐标的规模是 $[1, 100]$，横坐标的规模是 $[1, 10^9]$。为什么纵坐标规模这么小？显然有猫腻啊，不妨先按照相同的纵坐标，统计所有不同的横坐标的矩形：1234vector&lt;vector&lt;int&gt;&gt; rec(110);for(auto &amp;v: rectangles) &#123; rec[v[1]].push_back(v[0]);&#125; 由于纵坐标规模较小，所以可以直接拿来当作数组的下标。得到这样的结果后，进一步思考如何进行判断。 因为纵坐标是下标，所以可以直接找出纵坐标大于等于点的纵坐标的所有矩形（时间复杂度 $O(1)$），也即 $rec[i], i &gt;= h$。但如果矩形的横坐标不满足条件也是不符合题意的，所以也要在这些纵坐标符合条件的矩形中，快速找出所有横坐标符合条件的矩形。实际上，在 rec 这个数组中，每一个元素都是纵坐标相等的矩形的横坐标的集合。要完成上面说的事情，其实只需要遍历这些集合即可（此时问题已经转化了）。 到这里，回过头看可以发现，上面提到的 2 个问题，已经被拆开来分别解决了。 继续思考下去，遍历横坐标（上面提到的集合），一般是直接遍历，那样时间复杂度就是 $O(n)$。因为，外层还有 m 个点，如果直接这样遍历，估计还是够呛。有什么办法？答案是先排序，求满足条件矩形个数时再用二分查找。排序：123for(auto &amp;v: rec) &#123; sort(v.begin(), v.end());&#125; 是的，排序可以在遍历点的循环外做完，这样就可以直接用了😂。剩下就是遍历点，然后统计出所有的矩形就好了：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int size = points.size(); vector&lt;vector&lt;int&gt;&gt; rec(110); for(auto &amp;v: rectangles) &#123; rec[v[1]].push_back(v[0]); &#125; for(auto &amp;v: rec) &#123; sort(v.begin(), v.end()); &#125; vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int x = points[i][0], y = points[i][1]; for(int j = y; j &lt;= 100; j++) &#123; if(!rec[j].empty()) &#123; ret[i] += rec[j].end() - (lower_bound(rec[j].begin(), rec[j].end(), x)); &#125; &#125; &#125; return ret; &#125;&#125;; 二分查找直接调用 lower_bound 函数来完成，做差的结果就是当前纵坐标下，所有大于等于点的横坐标的矩形个数。不容易啊，好歹算是通过了。现在回过头来看一下这个算法的时间复杂度： 首先按照纵坐标来统计横坐标，$O(m)$。 排序，$O(nlogn)$。 最后就是统计所有符合条件的个数，$O(m × 100 × logn)$，这个 100 可以换成字母，表示横坐标或纵坐标规模小的那个。 合计就是：$O(m) + O(nlogn) + O(H_{min} m logn)$。对应的空间复杂度：$O(m + n)$。 没做过这类题，还真不太好想。还剩 2 道题，明天再写。 嗯，又瞅了几眼其他人的题解，发现上面这种思路是一种叫做按行统计的思路。这种思路是将纵坐标看作行，提前将横坐标提前排好序并按纵坐标大小，一行一行的保存起来，然后再逐行进行二分查找来统计符合条件的矩形总数。 如果按照只纵坐标排序，那么需要提前将矩形和点按纵坐标从大到小排序。然后在遍历点的同时，将纵坐标符合条件的矩形横坐标放入到一个新的数组 arr 中，直到不满足条件。此时，arr 中放的就是所有纵坐标符合条件的矩形横坐标，对其排序后二分查找，也一样可以算出满足条件的矩形总数。因为纵坐标是递减，所以下一个点的纵坐标一定是小于已经放入 arr 矩形的纵坐标的。剩下要做的事情，就是从剩余的矩形中找出符合当前点的横坐标的矩形横坐标，然后放入 arr 中，排序后二分。 回过头来想一想，如果在上面这种思路中也将矩形按纵坐标从大到小排好序，那在向 arr 数组中添加矩形横坐标时，不就只用遍历一次矩形横坐标了吗？没错，确实是这样的。所以，还是都提前排好序比较好：123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(rectangles.begin(), rectangles.end(), [](auto &amp;a, auto &amp;b) &#123; return a[1] &gt; b[1]; &#125;); int size = points.size(); vector&lt;int&gt; indices(size); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return points[i][1] &gt; points[j][1]; &#125;); vector&lt;int&gt; ans(size), arr; int i = 0; for(int id: indices) &#123; int start = i; while(i &lt; rectangles.size() &amp;&amp; rectangles[i][1] &gt;= points[id][1]) &#123; arr.push_back(rectangles[i++][0]); &#125; if(start &lt; i) sort(arr.begin(), arr.end()); ans[id] = arr.end() - lower_bound(arr.begin(), arr.end(), points[id][0]); &#125; return ans; &#125;&#125;; 如果只按照横坐标排序呢？同样的，需要先对矩形与点按横坐标从大到小排序。另外，由于纵坐标的范围比较小（$[1, 100]$），就算不用二分也是可以接受的，所以不如直接将纵坐标相同的矩形全部统计出来。然后遍历点的时候，将纵坐标满足条件的矩形个数逐个相加即可。这个方法有点类似前面提到的按行统计，但是这种方法在计算个数时会更快一点。12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(rectangles.begin(), rectangles.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] &gt; b[0]; &#125;); int size = points.size(); vector&lt;int&gt; indices(size); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return points[i][0] &gt; points[j][0]; &#125;); vector&lt;int&gt; ans(size), cnt(101); int i = 0; for(int id: indices) &#123; while(i &lt; rectangles.size() &amp;&amp; rectangles[i][0] &gt;= points[id][0]) &#123; ++cnt[rectangles[i++][1]]; &#125; ans[id] = accumulate(cnt.begin() + points[id][1], cnt.end(), 0); &#125; return ans; &#125;&#125;; 同样的，因为提前将点按横坐标从大到小排序了，所以也不存在遗漏与错解的情况。em...上面提到的这些思路好像是从树状数组中来的，树状数组的概念等以后真的用到了，再说吧，这个题就到此为止了。 2251. Number of Flowers in Full BloomAnalysis这是第 4 个题，不过是第三个提交的题。同样，也是因为题意理解起来比较容易，就很容易想到暴力解法。 Code暴力解法其实很简单，只需要判断人到达的天数，在那些花儿的花期内即可，这是当时写的：123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; int fsize = flowers.size(), psize = persons.size(); unordered_map&lt;int, int&gt; ht; for(int i = 0; i &lt; fsize; i++) &#123; int start = flowers[i][0], end = flowers[i][1]; while(start &lt;= end) &#123; ht[start++]++; &#125; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt; psize; i++) &#123; ret.push_back(ht[persons[i]]); &#125; return ret; &#125;&#125;; 上面这个暴力解法的时间复杂度是 $O(n^2)$，尽管明知道是超时的，还是提交一下，签个到😂。看了一下大佬们的思路，又回头想了想，当时已经想到了这个题是按照区间（也就是花期）来统计出每一天盛开的花的数目，只是暴力遍历的方法时间消耗太大了。实际上，这里其实可以用差分的思想来做，可惜，当时我不懂（自信点，懂了可能也不会用😂）...嗯，具体要怎么做呢？实际上与暴力代码内的统计次数类似，但是只统计两个值：start 和 end + 1。因为，花儿的花期是在 $[start, end]$ 内，所以这个区间内的花儿的盛开数量要全部加 1，也就是 start 加 1。过了花期之后，花儿盛开数量就减 1，对应的就是 end + 1 减 1。12345map&lt;int, int&gt; ht;for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--;&#125; 这样就可以把不同花期内花儿的盛开数量统计出来了。接下来要做的事情就是，把每人到达的那一天盛开的花儿数量算出来就可以了，同样，不断累加就行。12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; map&lt;int, int&gt; ht; for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--; &#125; int psize = persons.size(); vector&lt;int&gt; ans(psize); int index = 0; for(int &amp;i: persons) &#123; int sum = 0; auto it = ht.begin(); while(it != ht.end() &amp;&amp; it-&gt;first &lt;= i) &#123; sum += it++-&gt;second; &#125; ans[index++] = sum; &#125; return ans; &#125;&#125;; 但这段代码写上去还是超时的，为什么？看一下具体结果，前面暴力解法被卡在了样例 32，这个解法被卡在了样例 45，说明这种方法在时间上是更优秀的。那么，还有什么地方可以继续优化一下呢？注意到，在遍历每人到达的天数时，每次都要从 ht 的开头算到尾，能想办法优化这个过程吗？因为 ht 本身已经有序了，所以完全可以先求出 ht 的前缀和（当然不管有序无序，都可以算前缀和），这样就不用重复再算了。但是可惜的是，题目规定的 $persons[i]$ 的范围是 $[1, 10^9]$，哪里能开这么大的数组呢...回想一下上个题，累加计算时做的优化是什么？是对下标和累加的数组提前排序，然后再累加就可以了。现在，用到这里来：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; map&lt;int, int&gt; ht; for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--; &#125; int psize = persons.size(); vector&lt;int&gt; ans(psize); vector&lt;int&gt; indices(psize); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return persons[i] &lt; persons[j]; &#125;); int sum = 0; auto it = ht.begin(); for(int &amp;i: indices) &#123; while(it != ht.end() &amp;&amp; it-&gt;first &lt;= persons[i]) &#123; sum += it++-&gt;second; &#125; ans[i] = sum; &#125; return ans; &#125;&#125;; 同样，indices 也需要按下标从小到大进行排序。这样，ht 就只用遍历一次就可以算出所有 $persons[i]$ 的值了（感觉本质还是前缀和的思想）。提交上去是可以通过的...简单分析一下，时间复杂度是 $O(nlogn) + O(mlogm) + O(n) + O(m)$，n 是 flowers 的长度，m 是 persons 的长度，前一个 $O(nlogn)$ 是 ht 底层排序消耗的时间，后面的就不说了，实际上可以直接写成 $O(nlogn) + O(mlogm)$；空间复杂度就是 $O(n + m)$。 到这里，这个题已经算是用比较简单的方法解决了。再回顾一下差分的思想，是将每天开花的数目与每天凋谢的数目全部累加起来的。换个角度来思考，对于某一天而言，这一天开花的数目其实等于这一天之前开花的总数目减去这一天之前凋谢的花儿的总数目。如果能得到当前天之前凋谢的花儿总数目与这一天开花的总数目，二者作差之后，不就是这一天能看到的花儿总数目吗？那么如何统计每天开花的数目与凋谢的数目呢？与前面一样，用 map 让天数与开花数目相互映射吗？这样，就又回到暴力解法去了...实际上用 2 个数组就可以完成了。123456int fsize = flowers.size();vector&lt;int&gt; starts(fsize), ends(fsize);for(auto &amp;v: flowers) &#123; starts.push_back(v[0]); ends.push_back(v[1]);&#125; 接着，再用上一题求和的方法：排序和二分。前一天开花的数目，12345678sort(starts.begin(), starts.end());sort(ends.begin(), ends.end());int psize = persons.size();vector&lt;int&gt; ans(psize);for(int i = 0; i &lt; psize; i++) &#123; ans[i] = (upper_bound(starts.begin(), starts.end(), persons[i]) - starts.begin()) - (lower_bound(ends.begin(), ends.end(), persons[i]) - ends.begin());&#125; 最后合并起来：1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; int fsize = flowers.size(); vector&lt;int&gt; starts(fsize), ends(fsize); for(auto &amp;v: flowers) &#123; starts.push_back(v[0]); ends.push_back(v[1]); &#125; sort(starts.begin(), starts.end()); sort(ends.begin(), ends.end()); int psize = persons.size(); vector&lt;int&gt; ans(psize); for(int i = 0; i &lt; psize; i++) &#123; ans[i] = (upper_bound(starts.begin(), starts.end(), persons[i]) - starts.begin()) - (lower_bound(ends.begin(), ends.end(), persons[i]) - ends.begin()); &#125; return ans; &#125;&#125;; 就可以求得最终结果了...时间复杂度：$O((n + m)logn)$。空间复杂度：$O(n)$。 2249. Count Lattice Points Inside a CircleAnalysis好的，现在再回到第二题。这个题当时没什么思路，原因是不知道怎么枚举。题意倒是比较简单，给定一定数量的圆，返回至少出现在一个圆内的格点数目。格点的定义题目已经解释了，其实就是坐标为整数的点，并且离圆心的距离小于等于半径。 Code现在想想，其实可以想出暴力解法（可能是分析前面题目的经验吧）。因为圆心、半径给的都是整数，所以，每个圆一定会外切一个矩形，按照这个矩形的左下端点和边长进行枚举，再判断是否满足条件。为了避免重复，可以利用 set。1234567891011121314151617class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; map&lt;pair&lt;int, int&gt;, int&gt; points; for(auto v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2], r = v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; for(int i = leftlowerx; i &lt;= l; i++) &#123; for(int j = leftlowery; j &lt;= h; j++) &#123; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= r * r) points[make_pair(i, j)] = 1; &#125; &#125; &#125; return points.size(); &#125;&#125;; 因为 set 与 pair 一起使用时要重新写下 hash 函数（遗憾的是...我不知道 C++ 这个怎么写😂），就直接用 map 了。可惜的是，方向是找对了，就是还是超时了，死在第 57 个样例了。看了下提示：Since you need to reduce the search space, consider the minimum and maximum possible values of the coordinates of a lattice point contained in any circle.。想了下，枚举每个圆的外切矩形一定会有很多重复的点，如果我们直接从能容纳所有圆的那个最大的外切矩形坐标开始枚举，再利用 hash 不就可以减少重复比较的次数了吗？是的，就是这样的...感谢提示~1234567891011121314151617181920212223242526272829class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; int leftlowerxmin = INT_MAX, leftlowerymin = INT_MAX; int lmax = INT_MIN, hmax = INT_MIN; for(auto &amp;v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; if(l &gt; lmax) lmax = l; if(h &gt; hmax) hmax = h; if(leftlowerx &lt; leftlowerxmin) leftlowerxmin = leftlowerx; if(leftlowery &lt; leftlowerymin) leftlowerymin = leftlowery; &#125; map&lt;pair&lt;int, int&gt;, int&gt; latticepoints; for(int i = leftlowerxmin; i &lt;= lmax; i++) &#123; for(int j = leftlowerymin; j &lt;= hmax; j++) &#123; if(latticepoints.count(make_pair(i, j))) break; for(auto &amp;v: circles) &#123; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= v[2] * v[2]) &#123; latticepoints[make_pair(i, j)] = 1; break; &#125; &#125; &#125; &#125; return latticepoints.size(); &#125;&#125;; 这个其实也是暴力解法，只是转换了一下思考的角度...突然发现，好像前面的暴力解法，忘记用 hash 的性质了...123456789101112131415161718class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; map&lt;pair&lt;int, int&gt;, int&gt; points; for(auto v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2], r = v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; for(int i = leftlowerx; i &lt;= l; i++) &#123; for(int j = leftlowery; j &lt;= h; j++) &#123; if(points.count(make_pair(i, j))) continue; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= r * r) points[make_pair(i, j)] = 1; &#125; &#125; &#125; return points.size(); &#125;&#125;; 加上 hash 后竟然通过了...😂，就是时间、空间消耗惨不忍睹。看了下大佬们的思路，这个题好像还有其他解法，懒得继续思考了，这个题就到此为止了... Summary现在回头看一下这次场周赛的题目，感觉 4 个题有点类似，特别是第 2 题、第 3 题和第 4 题，都有数学的影子在里面。另外，这几个题好像的题目形式都与树状数组有点关系，等之后研究一下再来看看吧。不过现在再回头看看，感觉好像也不是特别复杂的题目（我在说什么 P 话😂）。哈哈，当时做的时候还是问题很多的，现在疑惑差不多就解决了，反而觉得不难了...真是应了那句话了：难者不会，会者不难。不过，我想，现在的“会者”也是从曾经的“难者”一步一步过来的吧...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 天编程能力基础_day1]]></title>
    <url>%2F2022%2F04%2F30%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day1%2F</url>
    <content type="text"><![CDATA[为什么这个需要 20 天才能结束，感觉 14 天足够了啊，只是想做点中等题。第一天，两个简单题试试水~ 896. Monotonic ArrayAnalysis题意是判断给定的数组是不是单调的，感觉比较简单，一个循环就搞定了。 Codemethod 1因为要确定数组是递减的还是递增的，所以对前两个出现的不相等元素进行比较。所以这里就有一个坑，不能直接那数组的第一个元素跟第二个元素进行比较。1234567891011121314151617181920class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return true; int p1 = 0, p2 = 1; while(p1 &lt; size &amp;&amp; p2 &lt; size &amp;&amp; nums[p1] == nums[p2]) p1++, p2++; if(p2 == size) return true; if(nums[p1] &gt;= nums[p2]) &#123; for(int i = p1; i &lt; size - 1; i++) &#123; if(nums[i] &lt; nums[i + 1]) return false; &#125; &#125; else &#123; for(int i = p1; i &lt; size - 1; i++) &#123; if(nums[i] &gt; nums[i + 1]) return false; &#125; &#125; return true; &#125;&#125;; 注意这种方法只用遍历一次数组，时间复杂度为 $O(n)$。实际上，可以精简一下这种思考模式。对于一个数组而言，其内部相邻的元素可能存在 3 种关系：相等、大于和小于。按照题目的要求，单调的数组只存在两种情况： 相邻元素大于等于 相邻元素小于等于 并且这两种情况只可能出现一种，如果两种同时出现，那这个数组一定不是单调的。此时，问题就转化判断数组内相邻元素的情况了，那么就可以这样写了：123456789101112class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; bool inc = true, dec = true; int size = nums.size(); for(int i = 0; i &lt; size - 1; i++) &#123; if(nums[i] &gt; nums[i + 1]) inc = false; if(nums[i] &lt; nums[i + 1]) dec = false; &#125; return inc || dec; &#125;&#125;; method 2实际上，判断单调就是判断数组是否有序，那就可以直接接用现成的库函数。123456class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; return is_sorted(nums.begin(), nums.end()) || is_sorted(nums.rbegin(), nums.rend()); &#125;&#125;; 注意这样需要遍历 2 次数组，但时间复杂度依然是 $O(n)$。 28. Implement strStr()Analysis题意很直接，实现 strstr 函数即可。话说，这个查找子串的题让我想到了 KMP...不过，这是道 easy 题。如果目的是锻炼一下 KMP 的话，估计是 hard 了。日后复习 KMP 的时候再补一下这个题吧。 Codemethod 1先暴力做一下：1234567891011121314151617181920class Solution &#123;public: int strStr(string haystack, string needle) &#123; int pos = -1, len1 = haystack.length(), len2 = needle.length(); if(len2 == 0) return 0; for(int i = 0; i &lt; len1; i++) &#123; if(haystack[i] == needle[0]) &#123; int tmp = i + 1, j; for(j = 1; j &lt; len2; j++, tmp++) &#123; if(needle[j] != haystack[tmp]) break; &#125; if(j == len2) &#123; pos = i; break; &#125; &#125; &#125; return pos; &#125;&#125;; 注意别丢了 needle 为空串的情况。 method 2复习一下 string 容器的库函数😂：123456class Solution &#123;public: int strStr(string haystack, string needle) &#123; return haystack.find(needle); &#125;&#125;; Summary总共 20 天，41 个题，一天才 2 个题，为什么不设置成 14 天，一天 2 - 3 个题呢？虽说是基础，一天 3 个中等题应该是也可以接受的吧？]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day10]]></title>
    <url>%2F2022%2F04%2F29%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[这个也要结束了啊。 182. Duplicate EmailsAnalysis题意比较简单，找出重复的电子邮件即可。 Code先统计邮件地址的出现次数：123select distinct email, count(email) as cntfrom Persongroup by email 在找出出现次数大于 2 的邮件地址：1234567select email as emailfrom ( select distinct email, count(email) as cnt from Person group by email) as twhere t.cnt &gt; 1 因为 WHERE 无法与聚合函数一起用，但 HAVING 可以，那就存在另外一种做法了：1234select email as Emailfrom Persongroup by Emailhaving count(email) &gt; 1 1050. Actors and Directors Who Cooperated At Least Three TimesAnalysis找出演员与导演合作次数大于 3 次的一对演员 id 与导演 id。 Code思路跟上个题一样：1234567select actor_id, director_idfrom ( select actor_id, director_id, count(director_id) as cnt from ActorDirector as ad group by actor_id, director_id) as twhere t.cnt &gt; 2 1234select actor_id, director_idfrom ActorDirector as adgroup by actor_id, director_idhaving count(director_id) &gt; 2 1587. Bank Account Summary IIAnalysis找出余额大于 10000 的人。 Code先统计账户的总共余额：123select account, sum(amount) as balancefrom Transactionsgroup by account 接着用左连接查询余额大于 10000 的用户与对应余额：12345678select name, balancefrom Users as uleft join ( select account, sum(amount) as balance from Transactions group by account) as ton t.balance &gt; 10000 and t.account = u.account 此时得到的结果是所有人的名字，余额少于 10000 的余额栏则会填入 null，实际上这是连接导致的笛卡尔积，所以得再次查询一下：123456789101112select name as NAME, balance as BALANCEfrom ( select name, balance from Users as u left join ( select account, sum(amount) as balance from Transactions group by account ) as t on t.balance &gt; 10000 and t.account = u.account) as awhere balance is not null 实际上可以写的更简单一点：123456789select name, balancefrom Users as uleft join ( select account, sum(amount) as balance from Transactions group by account) as ton t.account = u.accountwhere balance &gt; 10000 1084. Sales Analysis IIIAnalysis跟前面几个题差不多，但是麻烦的地方在于需要判断一下“仅”。 Code为了判断唯一性，可以用 MAX 和 MIN 函数来完成：123456select product_id, product_namefrom Sales as sjoin Product as pon s.product_id = p.product_idgroup by s.product_idhaving min(sale_date) &gt;= '2019-01-01' and max(sale_date) &lt;= '2019-03-31' Summary话说，感觉今天做的几个题都比较简单，可能是已经做了一些题，熟悉了的缘故。话说，真快啊，这个也做完了，不过，这些东西感觉好像很容易忘记，好像已经有点记不清前几天做的什么题了😂。总之，还是要多复习复习。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day9]]></title>
    <url>%2F2022%2F04%2F28%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[今天的主题是控制流。 1393. Capital Gain/LossAnalysis按照买卖的不同价格，算出股票的总盈利。 Code一开始想通过连接查询然后再做差求和得到结果，结果连接过程中消除不掉笛卡尔积，只能尝试其他思路了。123select stock_name, sum(if(operation = 'Sell', price, 0)) - sum(if(operation = 'Buy', price, 0)) as capital_gain_lossfrom Stocksgroup by stock_name 再回头看这道题的思路，果然是对应控制流的主题啊。实际上，这个题用 CASE WHEN 也是可以解决的：123select stock_name, sum(case operation when 'Sell' then price else -price end) as capital_gain_lossfrom Stocksgroup by stock_name 1407. Top TravellersAnalysis算出每个人的旅行总路程。 Code按照上一题的类似的思路，可以得到下面的代码：12345select name, sum(distance) as travelled_distancefrom Users as u, Rides as rwhere u.id = r.user_idgroup by nameorder by travelled_distance desc, name 但是现在有一个问题，有一个人的路程是 0，这个没查询出来。也就是说，这个题需要用到连接查询，并且在某个表中没有匹配时，返回 0。那么，不妨用左连接来做这个事情：123456select name, ifnull(sum(distance), 0) as travelled_distancefrom Users as uleft join Rides as ron u.id = r.user_idgroup by nameorder by travelled_distance desc, name 1158. Market Analysis IAnalysis给了 3 个表，题意是求出 2019 年内员工的订单数，并且给出员工入职日期，同时没有订单的需要返回 0。 Code先统计出订单数：1234select buyer_id, count(order_id) as cntfrom Orders as owhere o.order_date &gt;= '2019-01-01' and o.order_date &lt;= "2019-12-31"group by buyer_id 然后用 LEFT JOIN 连接查询，没有匹配就返回 0：123456789select u.user_id as buyer_id, join_date, ifnull(t1.cnt, 0) as orders_in_2019from Users as uleft join ( select buyer_id, count(order_id) as cnt from Orders as o where o.order_date &gt;= '2019-01-01' and o.order_date &lt;= "2019-12-31" group by buyer_id) as t1on u.user_id = t1.buyer_id Summary连接查询用的不是很熟练...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day8]]></title>
    <url>%2F2022%2F04%2F27%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[还是计算函数哈~ 586. Customer Placing the Largest Number of OrdersAnalysis挑出订单数最多的顾客即可。 Codemethod 1先统计出相同 customer_number 拥有的不同的 order_number 的个数：123select distinct customer_number, count(order_number) as order_numberfrom Ordersgroup by customer_number 按 order_number 的个数倒序排列：1234select distinct customer_number, count(order_number) as order_numberfrom Ordersgroup by customer_numberorder by order_number desc 可以发现，第一行就是要的答案了，此时再从这个表中挑出需要的信息：12345678select customer_numberfrom ( select distinct customer_number, count(order_number) as order_number from Orders group by customer_number order by order_number desc ) as t1limit 1 实际上可以写的更简单一点：12345select distinct customer_numberfrom Ordersgroup by customer_numberorder by count(order_number) desclimit 1 method 2在统计出 order_number 的个数后，也可以直接挑出最大值：1234567select customer_numberfrom ( select distinct customer_number, count(order_number) as order_number from Orders group by customer_number ) as t1where t1.order_number = (select max(order_number) from t1) 但遗憾的是，这样写会报错，原因是不合语法。实际上，这是一个执行顺序的问题。在 SQL 中，WHERE 是先于 SELECT 执行，也就是说 SQL server 在执行语句的时候，它不知道 t1 是什么，就没办法执行了（有点无力吐槽 SQL 奇奇怪怪的语法了😑）。如果还想要用这个思路来解决问题，就得先将 order_number 的个数统计出来，就需要用到 WITH AS 了。1234with t1 as (select customer_number, count(order_number) as order_number from Orders group by customer_number)select customer_numberfrom t1where t1.order_number = (select max(order_number) from t1) 511. Game Play Analysis IAnalysis找出用户的最早注册日期。 Code123select distinct player_id, min(event_date) as first_loginfrom Activitygroup by player_id em，这个题比较简单，本以为最小日期不能直接用 MIN 函数，没想到可以用。 1890. The Latest Login in 2020Analysis找出在 2020 年内用户的最后一次登录信息。 Codemethod 1找出最后的一次信息，可以借助 MAX 函数，限定 2020 年内，可以借助 WHERE。1234select distinct user_id, max(time_stamp) as last_stampfrom Loginswhere time_stamp &gt;= '2020-01-01 00:00:00' and time_stamp &lt; '2021-01-01 00:00:00'group by user_id method 2实际上，限定年份的时候，可以借助日期函数 YEAR。1234select user_id, max(time_stamp) as last_stampfrom Loginswhere year(time_stamp) = 2020group by user_id 1741. Find Total Time Spent by Each EmployeeAnalysis找出不同日期，不同人待在办公室的总时间。 Code先求出每个人留在办公室的时间，用 out_time 减去 in_time 即可。12select event_day, emp_id, (out_time - in_time) as difffrom Employees 然后算出总和，按照不同的人和不同的日期将结果集组合到一起。123456select distinct event_day as day, emp_id, sum(diff) as total_timefrom ( select event_day, emp_id, (out_time - in_time) as diff from Employees ) as t1group by event_day, emp_id 也可以写的更简单一点：123select distinct event_day as day, emp_id, sum(out_time - in_time) as total_timefrom Employeesgroup by event_day, emp_id Summary除了第一个题的 LIMIT 没想到外，另外 3 个题比较简单。另外，第一个题的第二种思路感觉比较合理一点（就实际运用而言），但是需要用到 WITH AS，SQL 语法真是奇怪啊。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day7]]></title>
    <url>%2F2022%2F04%2F26%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[em，今天的主题是计算函数啊。 1141. User Activity for the Past 30 Days IAnalysis不知道为什么，总是很抗拒描述数据库的题目。题目大概意思就是统计出活跃用户（2019-07-27 前 30 天内只要有一次活动的都算活跃用户）人数。 Code首先要思考的第一个问题是如何挑出与 2019-07-27 相差不超过 30 天的数据：123select *from Activity as actwhere datediff(act.activity_date, '2019-07-27')&gt;-30 也可以写成：123select *from Activity as actwhere datediff('2019-07-27', act.activity_date)&lt;30 接下来要解决的问题是，挑出出不同的日期：123456select distinct activity_date as dayfrom ( select * from Activity as act where datediff(act.activity_date, '2019-07-27')&gt;-30 ) as t1 注意，派生表必须要命名，而且必须要写在外面。此时，得到的结果只有符合条件的日期，还需要统计不同 id 的用户个数，使用 COUNT 可以完成统计，再用 GROUP BY 组合就可以了：1234567select distinct activity_date as day, count(distinct user_id) as active_usersfrom ( select * from Activity as act where datediff(act.activity_date, '2019-07-27')&gt;-30 ) as t1group by activity_date em，实际上，可以不写那么麻烦：1234select activity_date as day, count(distinct user_id) as active_usersfrom Activitywhere datediff('2019-07-27', Activity.activity_date) &lt; 30group by activity_date 1693. Daily Leads and PartnersAnalysis按照日期找出不同产品销售时不同的 lead_id 和 partner_id。 Code123select date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partnersfrom DailySalesgroup by date_id, make_name 嗯，这个题跟上个题一样的。 1729. Find Followers CountAnalysis这个题好像是最简单的。 Code1234select user_id, count(distinct follower_id) as followers_countfrom Followersgroup by user_idorder by user_id Summary我发现一个问题，如果要是从实际去理解这些题目做法的用意，无疑是没有意义的😂，因为没法搞清楚这样做是为了什么。但是出于做题和熟悉 SQL 语法的目的，按照要求做挑出符合条件的数据就好。另外，查询得到不同的信息后，需要用 GROUP BY 组合到一起，今天的 3 个题都是这样的。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day6]]></title>
    <url>%2F2022%2F04%2F25%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[今天还是合并呢。 197. Rising TemperatureAnalysis找出后一个数据比前一个数据大的数据（我在写什么玩意呢？😂），其实就是比较相邻的数据，挑出后面比前面大的那个。 Code123select Weather.idfrom Weatherjoin Weather as w on datediff(Weather.recordDate, w.recordDate) = 1 and Weather.temperature &gt; w.temperature 实际上这个题，其实是一个日期比较的题，当日期的差是 1 的时候，说明是相邻的 2 天。 607. Sales PersonAnalysis这个题真长，理解起来也不太容易。大概意思就是将 com_id 为 1 的 sales_id 的 name 挑出来（我在写什么东西啊😂）。 Code12345678select S.namefrom SalesPerson as Swhere s.sales_id not in ( select O.sales_id from Orders as O left join Company as C on O.com_id = C.com_id where C.name = 'RED') Summary我发觉这个系列的数据库例题是真不错，好像工作中都用的到？？？]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day5]]></title>
    <url>%2F2022%2F04%2F24%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[今天的主题是合并呢，感觉好像会用到 UNION。 175. Combine Two TablesAnalysis将两个表连接，进行组合查询。 Code123select firstName, lastName, city, statefrom Person left join Addresson Person.personId = Address.personId 1581. Customer Who Visited but Did Not Make Any TransactionsAnalysis找出只出现在 Visits 内而不出现在 Transactions 内的 visit_id，同时相同 customer_id 的个数。 Codemethod 1可以使用 GROUP BY 来将两个查询的结果组合起来。1234select customer_id, count(customer_id) as count_no_transfrom Visitswhere Visits.visit_id not in (select visit_id from Transactions)group by customer_id method 2也可以连接查询在组合。12345select customer_id, count(customer_id) as count_no_transfrom Visits left join Transactionson Visits.visit_id = Transactions.visit_idwhere amount is nullgroup by customer_id 1148. Article Views IAnalysis找出自己看过自己文章的作者，重复出现的，只列出 1 次记录，感觉这个今天最简单的题了。 Code1234select distinct viewer_id as idfrom Viewswhere Views.author_id = Views.viewer_idorder by id Summary还是不熟悉啊。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day4]]></title>
    <url>%2F2022%2F04%2F23%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[看了下今天的主题：组合查询和指定选取，感觉有点复杂。 1965. Employees With Missing InformationAnalysis找出缺失信息的数据，需要 2 个表一起组合查询。实际上，就是挑出 2 个表中只出现了 1 次的 employee_id。 Code123456789select employee_idfrom ( select employee_id from Employees union all select employee_id from Salaries) as ansgroup by employee_idhaving count(employee_id) = 1order by employee_id 1795. Rearrange Products TableAnalysis这个题是需要将表的数据重新排列，有点像是在做行列转换。 Code实际上是行列转换，然后再组合成一张表。1234567891011select product_id, 'store1' as store, store1 as pricefrom Productswhere store1 is not nullunion allselect product_id, 'store2' as store, store2 as pricefrom Productswhere store2 is not nullunion allselect product_id, 'store3' as stroe, store3 as pricefrom Productswhere store3 is not null 608. Tree NodeAnalysisSQL 与 树的结合题？ Codemethod 1第一种方法是分别挑出 3 种不同的结点，然后组合到一起。1234567891011121314151617181920212223select id, 'Root' as typefrom Treewhere p_id is nullunionselect id, 'Leaf' as typefrom Treewhere id not in ( select distinct p_id from Tree where p_id is not null) and p_id is not nullunionselect id, 'Inner' as typefrom Treewhere id in ( select distinct p_id from tree where p_id is not null) and p_id is not null method 2可以使用 CASE WHEN 来精简一下代码：12345678910select id as 'id', case when tree.id = (select atree.id from tree atree where atree.p_id is null) then 'Root' when tree.id in (select atree.p_id from tree atree) then 'Inner' else 'Leaf' end as typefrom treeorder by 'id' method 3还可以使用 IF 函数：123456select atree.id, if(isnull(atree.p_id), 'Root', if(atree.id in (select p_id from tree), 'Inner', 'Leaf')) typefrom tree atreeorder by atree.id 176. Second Highest SalaryAnalysis题意很简单，找出第二小的值。怎么这种题，一道数据库了，就感觉这么难做呢？ Codemethod 1可以使用 LIMIT OFFSET 来完成取第二的操作。但是，如果只有一个数据，结果就是 NULL 了。所以，需要将第一个表作为临时表。123456select ( select distinct salary from Employee order by salary desc limit 1 offset 1 ) as SecondHighestSalary method 2也可以使用 IFNULL 直接返回 NULL：12345select ifnull( (select distinct salary from Employee order by salary desc limit 1 offset 1), null) as SecondHighestSalary Summary怎么感觉有点难呢？还是用的少了。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day3]]></title>
    <url>%2F2022%2F04%2F22%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[感觉 SQL 的题目都挺容易的... 1667. Fix Names in a TableAnalysis这个题是在考察如何修改数据，并且需要将首字符与剩余字符做区分。 Code123select user_id, concat(upper(left(name, 1)), lower(substring(name, 2))) as name from Usersorder by user_id 1484. Group Sold Products By The DateAnalysis这个题有点麻烦，需要依次解决 3 个问题： 选出不同的日期 按照不同日期统计卖出的商品类型 将不同日期卖出的所有商品合并成一个字符串 Code1234select distinct sell_date, count(distinct product) as num_sold, group_concat(distinct product) as productsfrom Activitiesgroup by sell_dateorder by sell_date 1527. Patients With a ConditionAnalysis挑出含有含有特定子串的行。 Code123select patient_id, patient_name, conditionsfrom Patientswhere conditions regexp '^DIAB1|\\sDIAB1' 其中的\\s就是空格，所以用空格代替也是可以的。 Summary每天都熟悉一点数据库的用法，汗😓。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day2]]></title>
    <url>%2F2022%2F04%2F21%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[继续，继续。 1873. Calculate Special BonusAnalysis挑出满足两个条件的数据： name 不是以 M 开头 id 是奇数 Code123select employee_id, if(employee_id % 2 = 0 or name like 'M%', 0, salary) as bonusfrom Employees 627. Swap SalaryAnalysissex 为 m 就改为 f，为 f 就改为 m。 Codemethod 11update Salary set sex = if(sex = 'm', 'f', 'm') method 2也可以用 CASE WHEN 来完成。123456update Salaryset sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END; 196. Delete Duplicate EmailsAnalysis删除重复元素即可。 Codemethod 1123delete p1.*from Person p1, Person p2where p1.Email = p2.Email and p1.id &gt; p2.id method 2如果这个题不限制 select 的话，其实还有另外一种方法：12delete from Personwhere id not in (select dt.id from (select min(id) as id from Person group by email) dt) Summary今天的内容主要是删除和修改的内容，不是特别难，主要还是熟悉基本用法。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL 的一些基础知识点]]></title>
    <url>%2F2022%2F04%2F20%2FSQL-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[记录一下 SQL 的一些相关知识。 ConceptSQL，全称 Structured Query Language，直译就是结构化的查询语言。按照百度百科的解释，这是一种特殊目的的编程语言，是一种数据库查询和程序设计语言。目前，对它的认识到这里就可以了。 Composition一个数据库通常包含一个或多个表。每个表由一个名字标识（有点像变量），表内包含带有数据的记录，使用 SQL 语句就可以对这些数据进行增、删、改、查。 SQL LanguageSQL 可以分成两个部分：数据操作语言（DML）和数据定义语言（DDL）。注意，SQL 对大小写不敏感！查询和更新指令构成了 SQL 的 DML 部分，包括：SELECT、UPDATE、DELETE、INSERT INTO 等。数据定义语言（DDL）使用户可以创建或删除表格，或者是定义索引（键），规定表之间的链接，以及施加表间的约束。这类语句包括：CREATE DATABASE、ALTER DATABASE、CREATE TABLE、ALTER TABLE、DROP TABLE、CREATE INDEX、DROP INDEX 等。 SELECTSELECT 语句用于从表中选取数据。123SELECT 列名称 FROM 表名称SELECT * FROM 表名称SELECT name1,name2 FROM 表名称 DISTINCTDISTINCT 算是一个关键词，用于返回唯一不同的值，可以用来修饰 SELECT。1SELECT DISTINCT 列名称 FROM 表名称 WHERE如果需要有条件地从表中选取数据，可将 WHERE 子句添加到 SELECT 语句。1SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 WHERE 能使用的运算符包括以下几种： 操作符 描述 = 等于 &lt;&gt; 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 BETWEEN 在某个范围内 LIKE 搜索某种模式 注意：在某些版本的 SQL 中，&lt;&gt; 也可以写成 !=。一般语法：1SELECT * FROM 表名称 WHERE 列名称='xxx' 注意：SQL 使用单引号来环绕文本值（大部分数据库系统也接受双引号），数据就不用使用引号了。 AND &amp; ORAND 和 OR 运算符(没错，这是俩运算符，至少在 SQL 里面是的)用于基于一个以上的条件对记录进行过滤。一般语法：12SELECT * FROM 表名称 WHERE 列名称='xxx' OR\AND 列名称='xxx'SELECT * FROM 表名称 WHERE (列名称='x' OR 列名称='y') AND 列名称='z' ORDER BYORDER BY 语句用于根据指定的列对结果集进行排序，默认按照升序对记录进行排序。如果希望按照降序对记录进行排序，可以使用 DESC 关键字。一般语法：1234SELECT 列名称 FROM 表名称 ORDER BY 列名称SELECT 列名称 FROM 表名称 ORDER BY 列名称1,列名称2SELECT 列名称 FROM 表名称 ORDER BY 列名称 DESCSELECT 列名称 FROM 表名称 ORDER BY 列名称1 DESC,列名称2 ASC INSERT INTOINSERT INTO 用于向表格中插入新的行，一般语法：12INSERT INTO 表名称 VALUES (值1, 值2,...)INSERT INTO 表名称 (列1, 列2,...) VALUES(值1,值2,...) UPDATEUPDATE 语句用于修改表中的数据，一般语法：12UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值UPDATE 表名称 SET 列名称 = 新值,... WHERE 列名称 = 某值 DELETEDELETE 语句用于删除表中的行，一般语法：1DELETE FROM 表名称 WHERE 列名称 = 值 如果需要删除所有行，可以写成：12DELETE FROM 表名称DELETE * FROM 表名称 此时，表的结构、属性和索引都是完整的。 通配符通配符的作用有点类似正则表达式，需要与 LIKE 运算符一起使用，包含以下几种： 通配符 描述 % 代表零个或多个字符 - 仅替代一个字符 [charlist] 字符列中的任何单一字符 [^charlist] 或者 [!charlist] 不在字符中的任何单一字符 一般语法：123456789101112# 选出存在以 xx 开头的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE 'xx%'# 选出存在包含 xx 的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE '%xx%'# 选出存在第一个字符后是 xx 的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE '_xx%'# 选出存在形如 X_x 的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE 'X_x%'# 选出存在 X/Y/Z 开头的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE '[XYZ]%'# 选出不存在 X/Y/Z 开头的列的行SELECT * FROM 表名称 WHERE 列名称 LIKE '[!XYZ]%' IFIF 用来构成条件表达式，一般语法：12# expr1 为 true，返回值为 expr2, 否则为 expr3IF(expr1, expr2, expr3) IFNULL作用类似 IF，一般语法：12# expr1 不为 null 时，返回 expr1，否则返回 expr2IFNULL(expr1, expr2) AS简单来讲，AS 就是用来修改名字的，一般语法：12# SELECT 列名称 AS 别名 FROM 表名称SELECT xx AS yy FROM 表名称 CASE WHENCASE WHEN 的用法与一般编程语言的 switch 语句类似，一般语法：123456CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 WHEN condition3 THEN result3 ELSE resultEND; 不同的是，switch 语句需要用 break，但是 CASE WHEN 只会返回一个 result。 GROUP BYGROUP BY 的作用是根据一个或多个列对结果集进行分组，一般语法：123SELECT 列名称, 功能函数 FROM 表名称WHERE xxxGROUP BY 列名称 MINMIN 函数用来返回一列中的最小值，NULL 不包括在内，一般语法：1SELECT MIN(列名称) FROM 表名称 UPPER将字符转换为小写，一般语法：1UPPER(字符串) LOWER将字符转换为大写，一般语法：1LOWER(字符串) CONCAT用于将 2 个字符串连接起来，一般语法：1CONCAT(string1, string2) GROUP_CONCATGROUP_CONCAT 用来连接多个字符串（字段），一般用法：123456# 会将所有列名称连接起来，默认用 , 隔开GROUP_CONCAT(列名称)# 会将所有不同列名称连接起来，默认用 , 隔开GROUP_CONCAT(DISTINCT 列名称)# 会将所有列名称连接起来，自行设置分隔符GROUP_CONCAT(列名称, 分隔符) SUBSTRING用于截取字符串，一般语法：12345678# 截取 string 的第 1 个字符后的所有字符SUBSTRING(string, 1)# 截取 string 的第 1 个字符后的 3 个字符SUBSTRING(string, 1, 3)# 截取 string 的倒数第 3 个字符SUBSTRING(string, -3)# 截取 string 从倒数第 3 个字符开始取 2 个字符SUBSTRING(string, -3, 2) 还有很多其他的用法，不一一列举了。 LEFT算是 SUBSTRING 的简化版，一般语法：12# 截取 string 左边的 4 个字符LEFT(string, 4) RIGHT算是 SUBSTRING 的简化版，一般语法：12# 截取 string 右边的 4 个字符RIGHT(string, 4) COUNTCOUNT 函数用来返回指定了列的值的数目（NULL 不计入），一般语法：12345SELECT COUNT(列名称) FROM 表名称# 返回表中的记录数SELECT COUNT(*) FROM table_name# 返回指定列的不同值的数目SELECT COUNT(DISTINCT 列名称) FROM 表名称 IN / NOT IN这个两个操作符与字面意思一样，判断数据在不在子集合内，一般用法：12SELECT * FROM 表名称 WHERE 列名称 IN ('xx', 'yy', 'zz')SELECT * FROM 表名称 WHERE 列名称 NOT IN ('xx', 'yy', 'zz') UNION / UNION ALLUNION 操作符用来合并两个或多个 SELECT 语句的结果集。但是要注意，UNION 内部的 SELECT 语句必须拥有相同数量的列，列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。一般用法：123SELECT 列名 FROM 行名UNIONSELECT 列名 FROM 行名 UNION ALL 与 UNION 的用处是一样的，但是 UNION ALL 会列出所有值，包括重复的，UNION 则不会。 HAVINGHAVING 的用处类似 WHERE，也是在按条件选取数据。但是 WHERE 关键字无法与合计函数一起使用，一般用法：1234SELECT 列名, 函数()FROM 表名GROUP BY 列名HAVING 函数() LIMITLIMIT 一般用来查询数据，一般用法：1234# 读取 y 条数据LIMIT y# 跳过 x 条数据，读取 y 条数据LIMIT x, y OFFSETOFFSET 一般和 LIMIT 一起使用：12# 跳过 x 条数据，读取 y 条数据LIMIT y OFFSET x JOINJOIN 用于根据两个或多个表种的列之间的关系，从这些表种查询数据。它还有 3 位兄弟：LEFT JOIN、RIGHT JOIN 和 FULL JOIN，区别是： JOIN：如果表种至少一个匹配，则返回行。 LEFT JOIN：即使右表种没有匹配，也从左表中返回所有的行。 RIGHT JOIN：即使左表中没有匹配，也从右表中返回所有的行。 FULL JOIN：只要其中一个表中存在匹配，就返回行。 插一张图：它们的用法都差不多：1234SELECT xxfrom 表名1JOIN 表名2ON 条件 DATEDIFFDATEDIFF 是用来计算时间差的 SQL 函数，一般用法：12345# startdate 和 enddate 参数是合法的日期表达式# datepart 参数可以是年、月、日、季度等值SELECT DATEDIFF(datepart, startdate, enddate) AS DIFFDATE# 返回结果为 1 SELECT DATEDIFF(day, '2008-12-29', '2008-12-30') AS DIFFDATE YEARYEAR 函数用来获取字符串中的年份，一般用法：12# 返回 2018SELECT YEAR('2018-10-10') WITH ASWITH AS 用来定义一个 SQL 片段，这个片段会被整个 SQL 语句所用到，有点类似 C 语言里面的预编译，一般用法：123# 执行 select * from xxx 得到一个片段，这个片段名叫 A# 注意，这个片段实际上也是一个表WITH A AS (select * from xxx) MAX/MIN两个最值函数，功能不说了，一般用法：12SELECT MAX(列名) FROM 表名SELECT MIN(列名) FROM 表名]]></content>
      <categories>
        <category>Programming</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 天 SQL 入门_day1]]></title>
    <url>%2F2022%2F04%2F20%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[这个系列好像是和数据库相关的内容，需要补充一点这些知识。做这些题目前，需要了解一些 SQL 语法。 595. Big CountriesAnalysis2 个注意点： 只要挑出需要显示的列 不少于指定的数值即满足条件 Code1select name, area, population from World where area &gt;= 3000000 or population &gt;= 25000000 也可以使用 UNION 来连接两个子查询。123select name, area, population from World where area &gt;= 3000000 union select name, area, population from World where population &gt;= 25000000 1757. Recyclable and Low Fat ProductsAnalysis这个题跟上个题差不多。 Coed1select product_id from Products where low_fats='Y' and recyclable='Y' 但是这题没办法用 UNION 来连接两个子查询，因为这个题要用 AND。 584. Find Customer RefereeAnalysis也是差不多的题，但是要注意如何得到 null。 Code1select name from Customer where referee_id != 2 or referee_id is null 注意不要写成：referee_id = null。 183. Customers Who Never OrderAnalysis这个题要复杂一些，这个问题实质上是从 2 个表中，找出符合条件的数据，所以有几个要解决的问题： 从表 1 中挑出名称，从表 2 中找出符合条件的数据 最后得到的结果的表头要改变 如何判断不满足条件 Code1select name as 'Customers' from Customers where id not in (select customerID from Orders) Summary问题都比较简单，但是不懂语法就很难受了。得找本书看看数据库的相关语法，不然有点懵逼。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day12]]></title>
    <url>%2F2022%2F04%2F19%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[这个也要结束了吗？ 1603. Design Parking SystemAnalysis设计一个停车点的类。 Code没啥说的，这个很简单。1234567891011121314151617181920212223/** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem* obj = new ParkingSystem(big, medium, small); * bool param_1 = obj-&gt;addCar(carType); */class ParkingSystem &#123;public: vector&lt;int&gt; park = vector&lt;int&gt;(4); ParkingSystem(int big, int medium, int small) &#123; park[1] = big; park[2] = medium; park[3] = small; &#125; bool addCar(int carType) &#123; if(!park[carType]) return false; else &#123; park[carType]--; return true; &#125;; &#125;&#125;; 303. Range Sum Query - ImmutableAnalysis这个题也很简单，因为数量级很小，直接用 vector 就行。但这样没什么意思，用普通的整型数组算了。 Codemethod 1直接用整型数组。123456789101112131415161718192021222324/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(left,right); */class NumArray &#123;public: int numbers[10005] = &#123;0&#125;; NumArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; numbers[i] = nums[i]; &#125; &#125; int sumRange(int left, int right) &#123; int sum = 0; while(left &lt;= right) &#123; sum += numbers[left++]; &#125; return sum; &#125;&#125;; 提交之后，时间与空间的消耗很大，这样的做法显然有点不值得。 method 2因为这个题目只要求求和，所以，可以使用前缀和的思想来做。粗略估算一下极端情况的数值，$nums[i]$ 最大是 $10^5$，$nums$ 的大小最大为 $10^4$，那么计算情况就是 $10^9$ 和 $10^{-9}$，这是在 int 范围内的数字。1234567891011121314class NumArray &#123;public: int numbers[10005] = &#123;0&#125;; NumArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; numbers[i + 1] = nums[i] + numbers[i]; &#125; &#125; int sumRange(int left, int right) &#123; return numbers[right + 1] - numbers[left]; &#125;&#125;; Summary没啥说的，最后一天的题，都是比较简单的面对对象的思维。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day11]]></title>
    <url>%2F2022%2F04%2F18%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[4 个与容器和库相关的题。 1356. Sort Integers by The Number of 1 BitsAnalysis按照数字的二进制中 1 的个数进行排序，如果 1 的个数相等就按照自然数大小排序。分析一下，完成这道题，其实需要解决 2 个问题： 算出每个数字中 1 的个数 排序 由于数字与其二进制中 1 的个数是对应的关系，所以使用 map 来保存这些数字比较方便（map 可以自动排序）。但是使用 map 会自动去除重复元素，这样结果就不对了。注意到这个题目的最大值是 $10^4$，这个数的二进制总共有 14 位，也就是说，这个题目的测试数据中不会存在 1 的个数超过 14 的数（实际上不可能有 14 位都是 1 的数，因为这个数超过了 $10^4$）。那就可以按照这些数据的二进制中 1 的个数分别存放，然后在排序，这样就可以解决重复的问题了。 Codemethod 11234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), maxcount = 0; vector&lt;vector&lt;int&gt;&gt; res(14, vector&lt;int&gt;()); for(int i = 0; i &lt; size; i++) &#123; int tmp = __builtin_popcount(arr[i]); res[tmp].push_back(arr[i]); if(tmp &gt; maxcount) maxcount = tmp; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt;= maxcount; i++) &#123; sort(res[i].begin(), res[i].end()); for(int j: res[i]) &#123; ret.push_back(j); &#125; &#125; return ret; &#125;&#125;; method 2现在，再回到题目上，要求按照数字二进制中 1 的个数进行排序。对于面对对象的语言来讲，如果能把这个数字的二进制中 1 的个数作为这个类的一个成员变量，然后再用这个成员变量排序，不也可以得到结果吗？但遗憾的是，Leetcode 并不能自行构造类，所以只能“凑”一下了。123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; bits(10001, 0); for(int i = 0; i &lt; size; i++) &#123; bits[arr[i]] = __builtin_popcount(arr[i]); &#125; sort(arr.begin(), arr.end(), [&amp;](int a, int b) &#123; if(bits[a] != bits[b]) return bits[a] &lt; bits[b]; else return a &lt; b; &#125;); return arr; &#125;&#125;; 实际上，求取 bits 数组的过程可以提前做好。123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; bits(10001, 0); for(int i = 1; i &lt;= 10000; i++) &#123; bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1); &#125; sort(arr.begin(), arr.end(), [&amp;](int a, int b) &#123; if(bits[a] != bits[b]) return bits[a] &lt; bits[b]; else return a &lt; b; &#125;); return arr; &#125;&#125;; 232. Implement Queue using Stacks这个题是做过的题了，参考：Leetcode_14 天数据结构入门_day9。 242. Valid Anagram这个也是做过的题，参考：Leetcode_14 天数据结构入门_day6。 217. Contains Duplicate还是做过的，参考：Leetcode_14 天数据结构入门_day1。 Summary今天的题好像都做过了啊...话说，与容器和库相关的题，就是专门让用库函数和容器的题目吗？]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day14]]></title>
    <url>%2F2022%2F04%2F18%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day14%2F</url>
    <content type="text"><![CDATA[好快啊，这个要做完了。 98. Validate Binary Search TreeAnalysis判断一棵树是否是二叉搜索树。 Codemethod 1用递归来解决这个问题的关键在于，如何判断左子树所有结点都小于根节点（对应的，右子树所有结点都大于根节点），所以，需要设置一个区间，在分别遍历左、右子树时，对应改变区间的值，一旦某个结点的值不在区间内，说明这个结点一定不满足二叉搜索树的要求。1234567891011class Solution &#123;public: bool judge(TreeNode *root, long long lower, long long upper) &#123; if(!root) return true; if(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper) return false; return judge(root-&gt;left, lower, root-&gt;val) &amp;&amp; judge(root-&gt;right, root-&gt;val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return judge(root, LONG_MIN, LONG_MAX); &#125;&#125;; method 2实际上，这个题还有一种更直接的方法，因为二叉搜索树的中序遍历序列是有序的，所以可以直接得到这棵树的序列，然后判断序列是否有序即可。1234567891011121314151617class Solution &#123;public: void inorder(TreeNode *root, vector&lt;int&gt;&amp; v) &#123; if(!root) return; inorder(root-&gt;left, v); v.push_back(root-&gt;val); inorder(root-&gt;right, v); &#125; bool isValidBST(TreeNode* root) &#123; vector&lt;int&gt; tmp; inorder(root, tmp); for(int i = 0; i &lt; tmp.size() - 1; i++) &#123; if(tmp[i + 1] &lt;= tmp[i]) return false; &#125; return true; &#125;&#125;; 653. Two Sum IV - Input is a BSTAnalysis这是两数之和的第 4 代升级版吗？😂 Codemethod 112345678910class Solution &#123;public: unordered_set&lt;int&gt; ht; bool findTarget(TreeNode* root, int k) &#123; if(!root) return false; if(ht.find(root-&gt;val) != ht.end()) return true; else ht.insert(k - root-&gt;val); return findTarget(root-&gt;left, k) || findTarget(root-&gt;right, k); &#125;&#125;; method 212345678910111213141516class Solution &#123;public: unordered_set&lt;int&gt; ht; bool findTarget(TreeNode* root, int k) &#123; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(ht.find(node-&gt;val) != ht.end()) return true; ht.insert(k - node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return false; &#125;&#125;; 235. Lowest Common Ancestor of a Binary Search TreeAnalysis做这个题之前，首先要明确 LCA 的概念，虽然英文是 Lowest Common Ancestor，但并不能直接理解成最小公共祖先，而是要理解成最近（最低）公共祖先。 Codemethod 1要求最近公共祖先，那得先知道祖先是什么。所以，这个问题实际上是一个求子结点路径的问题。分别得到 2 个子结点的路径后，就可以很容易的找到 2 个子结点路径中的最近公共结点了，这就是它们的最近公共祖先。12345678910111213141516171819202122class Solution &#123;public: void getpath(TreeNode *root, TreeNode *target, vector&lt;TreeNode*&gt;&amp; path) &#123; path.push_back(root); if(root == target) return; if(root-&gt;val &gt; target-&gt;val) getpath(root-&gt;left, target, path); if(root-&gt;val &lt; target-&gt;val) getpath(root-&gt;right, target, path); &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; ppath, qpath; getpath(root, p, ppath); getpath(root, q, qpath); TreeNode *lca; int index = 0; while(index &lt; ppath.size() &amp;&amp; index &lt; qpath.size()) &#123; if(ppath[index] == qpath[index]) lca = ppath[index]; else break; index++; &#125; return lca; &#125;&#125;; 求路径的过程，也可以不用递归来做，直接根据二叉搜索树的性质来：123456789101112131415161718192021222324class Solution &#123;public: void getpath(TreeNode *root, TreeNode *target, vector&lt;TreeNode*&gt;&amp; path) &#123; while(root) &#123; path.push_back(root); if(root-&gt;val == target-&gt;val) return; else if(root-&gt;val &gt; target-&gt;val) root = root-&gt;left; else root = root-&gt;right; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; ppath, qpath; getpath(root, p, ppath); getpath(root, q, qpath); TreeNode *lca; int index = 0; while(index &lt; ppath.size() &amp;&amp; index &lt; qpath.size()) &#123; if(ppath[index] == qpath[index]) lca = ppath[index]; else break; index++; &#125; return lca; &#125;&#125;; method 2仔细想想这个问题，实际上是不需要分别求出两个子结点的路径的，可以直接一次性求 2 个结点的路径，但不是真正的求出来。如果当前结点比 2 个结点都大，就去遍历左子树；反之都小，就去遍历右子树。一旦不满足这 2 种情况，就说明这个结点是这两条路径的分岔点，那这个结点就是 LCA 了。换句话说，就是这 2 个结点的公共路径的最后一个结点就是 LCA。1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while(root) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left; else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right; else break; &#125; return root; &#125;&#125;; 有意思的是，p、q 这 2 个结点要么是在这个分岔点的不同子树中，要么其中一个就是这个分岔点。有了上面的思路，递归的思路自然也有了：12345678class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); else return root; &#125;&#125;; 自然，bfs 的思路也出来了：123456789101112131415class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; queue&lt;TreeNode*&gt; qu; qu.push(root); TreeNode *lca; while(!qu.empty()) &#123; lca = qu.front(); qu.pop(); if(lca-&gt;val &gt; p-&gt;val &amp;&amp; lca-&gt;val &gt; q-&gt;val) qu.push(lca-&gt;left); else if(lca-&gt;val &lt; p-&gt;val &amp;&amp; lca-&gt;val &lt; q-&gt;val) qu.push(lca-&gt;right); else break; &#125; return lca; &#125;&#125;; Summary不同的树具有不同的性质，题目是根据这些性质出的，自然也得根据这些性质来求解，题目是做不完的，所以，更多的是抓住题目的本质。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day10]]></title>
    <url>%2F2022%2F04%2F17%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[链表与树相关的题。 1290. Convert Binary Number in a Linked List to IntegerAnalysis按照链表结点的值，计算出其表示的二进制数。 Codemethod 1很自然的就会想到这样的迭代做法：12345678910111213141516171819class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode *p = head; int ret = 0, cnt = 0; while(p) &#123; cnt++; p = p-&gt;next; &#125; p = head; cnt--; while(p) &#123; if(p-&gt;val) ret += (1 &lt;&lt; cnt); cnt--; p = p-&gt;next; &#125; return ret; &#125;&#125;; method 2实际上，并不是一定非要求出链表的结点数，只需要每次计算前，先乘以 2，再相加即可。12345678910111213class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode *p = head; int ret = 0; while(p) &#123; ret &lt;&lt;= 1; ret |= p-&gt;val; p = p-&gt;next; &#125; return ret; &#125;&#125;; 876. Middle of the Linked List这个题是做过的题，参考：Leetcode_14 天算法入门_day5。 104. Maximum Depth of Binary Tree这个题也是做过的题，参考：Leetcode_14 天数据结构入门_day11。 404. Sum of Left LeavesAnalysis求所有左边叶子结点之和。 Codedfs使用 dfs 的难点在于到达叶子结点的时候，无法判断此结点是否是左叶子，所以需要提前判断。12345678910111213141516class Solution &#123;public: bool isleaf(TreeNode *node) &#123; return !node-&gt;left &amp;&amp; !node-&gt;right; &#125; int dfs(TreeNode *root) &#123; int ans = 0; if(root-&gt;left) ans += isleaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left); if(root-&gt;right &amp;&amp; !isleaf(root-&gt;right)) ans += dfs(root-&gt;right); return ans; &#125; int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; else return dfs(root); &#125;&#125;; 也可以写的更简略一点：12345678910class Solution &#123;public: bool isleaf(TreeNode *node) &#123; return node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right; &#125; int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right) + (isleaf(root-&gt;left) ? root-&gt;left-&gt;val : 0); &#125;&#125;; bfsbfs 的思路感觉要清晰很多。123456789101112131415161718class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; int sum = 0; if(!root) return sum; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;left) &#123; if(!node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) sum += node-&gt;left-&gt;val; else q.push(node-&gt;left); &#125; if(node-&gt;right) q.push(node-&gt;right); &#125; return sum; &#125;&#125;; Summary树的递归还是不熟练啊...还得多练习一下。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day13]]></title>
    <url>%2F2022%2F04%2F17%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day13%2F</url>
    <content type="text"><![CDATA[2 个跟二叉搜索树相关的题。 700. Search in a Binary Search TreeAnalysis在二叉搜索树中，查找与给定值相同的结点，并返回这个结点。 Codedfs12345678class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root || root-&gt;val == val) return root; else if(root-&gt;val &gt; val) return searchBST(root-&gt;left, val); else return searchBST(root-&gt;right, val); &#125;&#125;; bfs123456789101112131415class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;val == val) return node; else if(node-&gt;val &gt; val &amp;&amp; node-&gt;left) q.push(node-&gt;left); else if(node-&gt;val &lt; val &amp;&amp; node-&gt;right) q.push(node-&gt;right); &#125; return nullptr; &#125;&#125;; loop由于二叉搜索树具有左边小右边大性质，这个题还可以写的更直接：123456789101112class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root) return root; while(root) &#123; if(root-&gt;val == val) return root; else if(root-&gt;val &gt; val) root = root-&gt;left; else root = root-&gt;right; &#125; return nullptr; &#125;&#125;; 实际上，这就是二分查找。 701. Insert into a Binary Search TreeAnalysis这个题与上面的题基本一致，只是需要插入一个结点，实际上就是在查找插入的位置。 Codedfs123456789class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); if(root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); else root-&gt;right = insertIntoBST(root-&gt;right, val); return root; &#125;&#125;; bfs12345678910111213141516171819202122232425class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;val &gt; val) &#123; if(node-&gt;left) q.push(node-&gt;left); else &#123; node-&gt;left = new TreeNode(val); break; &#125; &#125; else &#123; if(node-&gt;right) q.push(node-&gt;right); else &#123; node-&gt;right = new TreeNode(val); break; &#125; &#125; &#125; return root; &#125;&#125;; loop同样，根据二叉搜索树的性质，也可以直接用循环来做：1234567891011121314151617181920212223class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); TreeNode *tmp = root; while(root) &#123; if(root-&gt;val &gt; val) &#123; if(root-&gt;left) root = root-&gt;left; else &#123; root-&gt;left = new TreeNode(val); break; &#125; &#125; else &#123; if(root-&gt;right) root = root-&gt;right; else &#123; root-&gt;right = new TreeNode(val); break; &#125; &#125; &#125; return tmp; &#125;&#125;; Summary这几天有关树的题都不难，所以尽量把能想到的方法都写出来。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day12]]></title>
    <url>%2F2022%2F04%2F16%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[树的题，有点意思啊。 226. Invert Binary TreeAnalysis题意很简单，翻转二叉树。 Codedfs123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; TreeNode *tmp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; bfs1234567891011121314151617181920class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; int size = q.size(); for(int i = 0; i &lt; size; i++) &#123; TreeNode *tmp, *node = q.front(); q.pop(); tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 也可以写的更简单一点：1234567891011121314151617class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *tmp, *node = q.front(); q.pop(); tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return root; &#125;&#125;; 112. Path SumAnalysis判断根节点到叶子结点的路径长度是否与给定值相等。 Codedfs123456789101112class Solution &#123;public: bool dfs(TreeNode *root, int targetSum, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val + sum == targetSum) return true; return dfs(root-&gt;left, targetSum, sum + root-&gt;val) || dfs(root-&gt;right, targetSum, sum + root-&gt;val); &#125; bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; return dfs(root, targetSum, 0); &#125;&#125;; 嗯，这样写，不够优雅，改一下：12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return targetSum == root-&gt;val; return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val); &#125;&#125;; bfs123456789101112131415161718192021222324252627class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; queue&lt;TreeNode*&gt; q; queue&lt;int&gt; sum; q.push(root); sum.push(root-&gt;val); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); int tmp = sum.front(); sum.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) &#123; if(tmp == targetSum) return true; continue; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); sum.push(node-&gt;left-&gt;val + tmp); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); sum.push(node-&gt;right-&gt;val + tmp); &#125; &#125; return false; &#125;&#125;; 使用 bfs 会麻烦一些，需要将所有根结点到叶子结点的路劲长度算出来，需要用队列来保存中间的计算结果，因为结点出队的顺序与根结点到这个结点的路劲长度是对应的。 Summary树的题目有很多，有些题目很灵活，要多想想。不过本质都是一样的，那就是对树的遍历。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day9]]></title>
    <url>%2F2022%2F04%2F16%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[还是 3 个字符串相关的题目。 709. To Lower CaseAnalysis只用将大写字母转换为小写即可。 Code123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(int i = 0; i &lt; s.length(); i++) &#123; if(isupper(s[i])) s[i] = tolower(s[i]); &#125; return s; &#125;&#125;; em，既然使用 C++ 写的，就用 C++11 的写法：123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(char&amp; ch: s) &#123; ch = tolower(ch); &#125; return s; &#125;&#125;; 也可以自己实现 tolower 的功能：123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(char&amp; ch: s) &#123; if(isupper(ch)) ch |= 32; &#125; return s; &#125;&#125;; 为什么可以写成ch |= 32？因为大写字母的 ASCII 码要转换为小写就是加上 32，而这些大写字母的二进制表示有一个共同点，那就是表示 32 的那一位上全部是 0。换句话说，要让这个数字增加 32，只需要将这个数字的表示 32 的二进制数位从 0 变成 1 即可。这样写的好处就是用位运算取代了加运算，可以极大的提升效率。 1309. Decrypt String from Alphabet to Integer MappingAnalysis解码字符串，em，这是个简单的字符串分类讨论题。 Code12345678910111213141516171819class Solution &#123;public: string freqAlphabets(string s) &#123; string ret; int i = 0; while(i &lt; s.length()) &#123; if(isdigit(s[i])) &#123; if(isdigit(s[i + 1]) &amp;&amp; s[i + 2] == '#') &#123; ret += ((s[i] - '0') * 10 + (s[i + 1] - '0') + 'a' - 1); i += 3; &#125; else &#123; ret += (s[i] - '0' + 'a' - 1); i += 1; &#125; &#125; &#125; return ret; &#125;&#125;; em，逻辑过程还可以更加精炼一点：1234567891011121314151617class Solution &#123;public: string freqAlphabets(string s) &#123; string ret; int i = 0; while(i &lt; s.length()) &#123; if(i + 2 &lt; s.length() &amp;&amp; s[i + 2] == '#') &#123; ret += ((s[i] - '0') * 10 + (s[i + 1] - '0') - 1 + 'a'); i += 3; &#125; else &#123; ret += (s[i] - '0' - 1 + 'a'); i += 1; &#125; &#125; return ret; &#125;&#125;; 953. Verifying an Alien DictionaryAnalysis按照给定的顺序对字符串排序，em，这个题好像是字符串排序的原理。 Code12345678910111213141516171819202122232425class Solution &#123;public: bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) &#123; int seq[26] = &#123;0&#125;; for(int i = 0; i &lt; order.length(); i++) &#123; seq[order[i] - 'a'] = i; &#125; for(int i = 0; i &lt; words.size() - 1; i++) &#123; int minlen = min(words[i].length(), words[i + 1].length()), index = 0; bool flag = true; while(index &lt; minlen) &#123; if(words[i][index] != words[i + 1][index]) &#123; if(seq[words[i][index] - 'a'] &gt; seq[words[i + 1][index] - 'a']) &#123; flag = false; &#125; break; &#125; index++; &#125; if(!flag) return false; else if(index == minlen &amp;&amp; words[i].length() &gt; words[i + 1].length()) return false; &#125; return true; &#125;&#125;; 这个题有点麻烦，但不是个难题。因为不同的样例会给出不同的字母顺序，所以最好将字母顺序散列的保存起来，后面比较的时候就可以直接用了。 Summaryem，3 个简单的字符串相关题目，都挺简单的。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day11]]></title>
    <url>%2F2022%2F04%2F15%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[还是树~ 102. Binary Tree Level Order TraversalAnalysis大名鼎鼎的 bfs。 Codebfs123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;TreeNode*&gt; q; q.push(root); int cnt = 1; while(!q.empty()) &#123; vector&lt;int&gt; tmp; TreeNode *node; int sum = 0; for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) &#123; q.push(node-&gt;left); sum++; &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); sum++; &#125; &#125; cnt = sum; ret.push_back(tmp); &#125; return ret; &#125;&#125;; 因为题目要求按层输出结点，所以一次性要遍历完一层的所有结点，就需要提前将下一层的结点个数计算出来，这样才能保证最终得到的结果符合题意。实际上，在开始循环之前，队列的大小就是当前层的结点个数，也就可以写成这样：1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; vector&lt;int&gt; tmp; TreeNode *node; int cnt = q.size(); for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; ret.push_back(tmp); &#125; return ret; &#125;&#125;; 这样写，看着会清爽很多。 dfs既然 bfs 能解决这个问题，同样 dfs 也可以解决这个问题。123456789101112131415class Solution &#123;public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, TreeNode *root, int level) &#123; if(ret.size() &lt; level + 1) ret.push_back(vector&lt;int&gt;()); ret[level].push_back(root-&gt;val); if(root-&gt;left) dfs(ret, root-&gt;left, level + 1); if(root-&gt;right) dfs(ret, root-&gt;right, level + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; dfs(ret, root, 0); return ret; &#125;&#125;; 实际上，这里用到的 dfs 就是二叉树的先序遍历，但这里的关键在于，要按照层数来访问结点，同时在访问结点前，需要提前创建好数组。 104. Maximum Depth of Binary TreeAnalysis求二叉树的深度，em，这个题依然可以从 dfs 和 bfs 两个方向入手。 Codedfs先从 dfs 入手。1234567891011121314class Solution &#123;public: void dfs(TreeNode *root, int depth, int &amp;maxdepth) &#123; if(!root) return; if(depth &gt; maxdepth) maxdepth = depth; dfs(root-&gt;left, depth + 1, maxdepth); dfs(root-&gt;right, depth + 1, maxdepth); &#125; int maxDepth(TreeNode* root) &#123; int maxdepth = 0; dfs(root, 1, maxdepth); return maxdepth; &#125;&#125;; 当然了，也可以这样写：12345678910111213class Solution &#123;public: void dfs(TreeNode *root, int depth, int &amp;maxdepth) &#123; if(depth &gt; maxdepth) maxdepth = depth; if(root-&gt;left) dfs(root-&gt;left, depth + 1, maxdepth); if(root-&gt;right) dfs(root-&gt;right, depth + 1, maxdepth); &#125; int maxDepth(TreeNode* root) &#123; int maxdepth = 0; if(root) dfs(root, 1, maxdepth); return maxdepth; &#125;&#125;; 看着清爽了一些？其实，这个还可以写的更夸张😂，如下：1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; else return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; 前面写的递归的思路本质上还是遍历二叉树的思路，但这样写的思路是基于分治的，二叉树的高度就是左右子树的高度加 1，所以只需要不断的去计算子树的高度再返回加 1 就可以得到整个树的高度了。 bfs二叉树的深度对应的就是二叉树的层数。123456789101112131415161718192021class Solution &#123;public: int maxDepth(TreeNode* root) &#123; int maxdepth = 0; if(!root) return maxdepth; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node; int cnt = q.size(); for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; maxdepth++; &#125; return maxdepth; &#125;&#125;; 101. Symmetric TreeAnalysis判断一棵二叉树是否对称，这个题显然要用 dfs 来做。 Codedfs判断二叉树是否对称，实际上就是要判断左右子树是不是一样的，所以使用 2 个指针递归的去判断即可。123456789101112class Solution &#123;public: bool check(TreeNode *root1, TreeNode *root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if(!root1 || !root2) return false; else return root1-&gt;val == root2-&gt;val &amp;&amp; check(root1-&gt;left, root2-&gt;right) &amp;&amp; check(root1-&gt;right, root2-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return check(root-&gt;left, root-&gt;right); &#125;&#125;; 注意，一开始递归的时候不要直接写check(root, root)，这样就多判断了一遍，因为第一次递归中check(root1-&gt;left, root2-&gt;right)和check(root1-&gt;right, root2-&gt;left)是一样的。 bfs同样，这个题也可以用 bfs 来做。123456789101112131415161718192021class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root-&gt;left); q.push(root-&gt;right); TreeNode *u, *v; while(!q.empty()) &#123; u = q.front(); q.pop(); v = q.front(); q.pop(); if(!u &amp;&amp; !v) continue; if((!u || !v) || (u-&gt;val != v-&gt;val)) return false; q.push(u-&gt;left); q.push(v-&gt;right); q.push(u-&gt;right); q.push(v-&gt;left); &#125; return true; &#125;&#125;; 同样，第一次入队的时候直接将左右子结点入队。 Summary3 个树的相关题目，做的挺有意思的。有关二叉树的题，有时候用 dfs 做很简单，有时候用 bfs 做很简单，所以，最好是能合理的选择最简单的方法完成。当然，也不排除可能面试时要用特定的方法写，所以最好还是都会比较好。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day8]]></title>
    <url>%2F2022%2F04%2F15%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[3 个字符串相关的题。 1768. Merge Strings AlternatelyAnalysis交替合并字符串，多出来的字符放到末尾即可，这个题有点类似合并链表的题目。 Code12345678910111213class Solution &#123;public: string mergeAlternately(string word1, string word2) &#123; string ret; int i = 0, j = 0; while(i &lt; word1.length() &amp;&amp; j &lt; word2.length()) &#123; ret += i &lt;= j ? word1[i++] : word2[j++]; &#125; while(i &lt; word1.length()) ret += word1[i++]; while(j &lt; word2.length()) ret += word2[j++]; return ret; &#125;&#125;; 不过，这样写好像不是那么优雅，改一下：123456789101112class Solution &#123;public: string mergeAlternately(string word1, string word2) &#123; string ret; int i = 0, j = 0; while(i &lt; word1.length() || j &lt; word2.length()) &#123; if(i &lt; word1.length()) ret += word1[i++]; if(j &lt; word2.length()) ret += word2[j++]; &#125; return ret; &#125;&#125;; 1678. Goal Parser InterpretationAnalysis简单的分词器，按照不同的情况判断就好。 Code1234567891011121314151617181920class Solution &#123;public: string interpret(string command) &#123; string ret; int i = 0; while(i &lt; command.length()) &#123; if(command[i] == 'G') &#123; ret += "G"; i++; &#125; else if(command[i] == '(' &amp;&amp; command[i + 1] == ')') &#123; ret += "o"; i += 2; &#125; else &#123; ret += "al"; i += 4; &#125; &#125; return ret; &#125;&#125;; 389. Find the DifferenceAnalysis找出字符串 t 中多出的字母即可。 Codemethod 1直接散列。12345678910111213class Solution &#123;public: char findTheDifference(string s, string t) &#123; int letters[26] = &#123;0&#125;, i = 0; while(i &lt; s.length()) letters[s[i++] - 'a']++; i = 0; while(i &lt; t.length()) &#123; int tmp = --letters[t[i++] - 'a']; if(tmp &lt; 0) break; &#125; return t[--i]; &#125;&#125;; method 2当然也可以不使用散列，只需要将 2 个字符串字符的和求出做差，即可得到需要的结果。123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; int sum1 = 0, sum2 = 0; for(char ch: s) sum1 += ch; for(char ch: t) sum2 += ch; return sum2 - sum1; &#125;&#125;; 之所以能这么干，是因为 ASCII 码本身就是以整数的形式存储的。 method 3既然知道了 ASCII 码是整数形式存储的，那么这个问题就转化为了，寻找只出现一次的数，就可以利用位运算来完成了。123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char ret = 0; for(char ch: s) ret ^= ch; for(char ch: t) ret ^= ch; return ret; &#125;&#125;; Summary简单的字符串相关题目，做起来丝毫不废劲啊...不过还是要注意一下一题多解的情况，尽量开阔自己的思路，要能想到其他更优秀的解法。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day10]]></title>
    <url>%2F2022%2F04%2F14%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[3 个题，正好对应二叉树的先、中、后序遍历。 144. Binary Tree Preorder TraversalAnalysis二叉树的先序遍历，遍历顺序为：根左右。 Codemethod 1递归写法非常简单。12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void pre(vector&lt;int&gt;&amp; seq, TreeNode *root) &#123; if(!root) return; seq.push_back(root-&gt;val); pre(seq, root-&gt;left); pre(seq, root-&gt;right); &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; pre(ret, root); return ret; &#125;&#125;; method 2如果不用递归，也可以使用一个栈来模拟。1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); ret.push_back(root-&gt;val); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; method 3实际上还有一种叫做 Morris 遍历的方法，能将空间复杂度降到 $O(1)$。12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; ret.push_back(p1-&gt;val); p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else p2-&gt;right = nullptr; &#125; else ret.push_back(p1-&gt;val); p1 = p1-&gt;right; &#125; return ret; &#125;&#125;; 这种方法很好，但是用的很少（多半是为了面试？）。这种遍历方法实质上只干了一件事情，那就是：利用子树最右子结点的空指针指向其在中序遍历下需要访问的下一个结点，这样就可以不用通过回退来访问下一个结点了，直接用修改好的空指针就可以拿到下一个需要访问的结点的地址，此时，会再次用这个结点进入循环，因为这个子树最右子结点的右指针已经被修改为之前的结点的地址了，所以要再改为 null。 94. Binary Tree Inorder TraversalAnalysis中序遍历 Code同样写 3 种遍历方法。 method 11234567891011121314class Solution &#123;public: void inorder(vector&lt;int&gt;&amp; seq, TreeNode* root) &#123; if(!root) return; inorder(seq, root-&gt;left); seq.push_back(root-&gt;val); inorder(seq, root-&gt;right); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; inorder(ret, root); return ret; &#125;&#125;; method 21234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); ret.push_back(root-&gt;val); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; method 3123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else &#123; ret.push_back(p1-&gt;val); p2-&gt;right = nullptr; &#125; &#125; else ret.push_back(p1-&gt;val); p1 = p1-&gt;right; &#125; return ret; &#125;&#125;; 145. Binary Tree Postorder TraversalAnalysis后序遍历 Codemethod 11234567891011121314class Solution &#123;public: void postorder(vector&lt;int&gt;&amp; seq, TreeNode* root) &#123; if(!root) return; postorder(seq, root-&gt;left); postorder(seq, root-&gt;right); seq.push_back(root-&gt;val); &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; postorder(ret, root); return ret; &#125;&#125;; 在这几个问题上，递归是真的香... method 2使用栈来模拟后序遍历，与前序和中序有一点不同，既可以使用 2 个栈来完成，也可以只用 1 个栈来完成。双栈：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; ret.push_back(st2.top()-&gt;val); st2.pop(); &#125; return ret; &#125;&#125;; 使用双栈的核心思路就是：按照根右左的顺序进行先序遍历，然后用栈弹出这个遍历顺序，这样总体的遍历顺序就是左右根了，这也就是后序遍历的顺序了。实际上，也可以不使用双栈，直接用 reverse 函数来逆置遍历得到的结果序列。单栈：12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; TreeNode *pre = nullptr; while(root || !st.empty()) &#123; while(root)&#123; st.push(root); root = root-&gt;left; &#125; root = st.top(); st.pop(); if(!root-&gt;right || root-&gt;right == pre) &#123; ret.push_back(root-&gt;val); pre = root; root = nullptr; &#125; else &#123; st.push(root); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; 使用单栈完成模拟后序遍历的思路与先、中序的差别在于：如何判断这个结点已经遇到了 3 次，只有当第 3 次遇到这个结点时，才访问它。所以，要使用一个 pre 指针来记录其右子树是否已经访问（因为开始时就已经将每一层最左边的结点入栈了，所以只用判断右），如果已经访问了右子结点，那么说明这是第 3 次遇到这个结点了，就访问它。 method 3同样后序遍历也有其对应的 Morris 遍历方法。12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void addpath(vector&lt;int&gt;&amp; seq, TreeNode *node) &#123; int cnt = 0; while(node) &#123; cnt++; seq.push_back(node-&gt;val); node = node-&gt;right; &#125; reverse(seq.end() - cnt, seq.end()); &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else &#123; p2-&gt;right = nullptr; addpath(ret, p1-&gt;left); &#125; &#125; p1 = p1-&gt;right; &#125; addpath(ret, root); return ret; &#125;&#125;; Morris 的后序遍历方法本质上其实与双栈实现的后序遍历没有太大的区别，但是胜在空间复杂度是 $O(1)$。换句话说，addpath 函数在做的事情，就是在回到根结点的时候，利用根节点按照根右的顺序遍历左子树，然后再用 reverse 函数逆置，这样整体顺序就是右根了，而左边的叶子结点一定是排在二者前面的，所注意最终顺序就是左右根了。 Summary二叉树的遍历的递归做法，其实就是 DFS。尽管递归很简单，但是对非递归的做法也要熟悉，Morris 可能要求较少，但是用单栈实现的非递归做法，多看的话，应该可以很熟练的背下来吧。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day7]]></title>
    <url>%2F2022%2F04%2F14%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[两个跟矩阵相关的简单题。 1572. Matrix Diagonal SumAnalysis返回对角线元素之和即可。 Code1234567891011class Solution &#123;public: int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(), sum = 0; for(int i = 0, j = n - 1; i &lt; n &amp;&amp; j &gt;= 0; i++, j--) &#123; sum += mat[i][i]; sum += mat[i][j]; &#125; return n % 2 ? sum - mat[n / 2][n / 2] : sum; &#125;&#125;; 注意当 n 是奇数时，中间的元素会被计算 2 次，所以结果要减去。嗯，这样写可能不太美观？改一下：12345678910class Solution &#123;public: int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(), sum = 0; for(int i = 0; i &lt; n; i++) &#123; sum += mat[i][i] + mat[i][n - i - 1]; &#125; return sum - mat[n / 2][n / 2] * (n &amp; 1); &#125;&#125;; 566. Reshape the Matrix这是做过的题，参考：Leetcode_14 天数据结构入门_day4。 Summary今天的 2 个题做的太轻松啦~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day9]]></title>
    <url>%2F2022%2F04%2F13%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[2 个跟栈、队列相关的题。 20. Valid ParenthesesAnalysis经典的括号匹配问题。 Code1234567891011121314151617181920class Solution &#123;public: bool isValid(string s) &#123; if(s.length() % 2) return false; stack&lt;char&gt; st; bool flag = true; for(char ch: s) &#123; if(ch == '(' || ch == '[' || ch == '&#123;') st.push(ch); else if(!st.empty()) &#123; char tmp = st.top(); if(ch == ')' &amp;&amp; tmp == '(') st.pop(); else if(ch == ']' &amp;&amp; tmp == '[') st.pop(); else if(ch == '&#125;' &amp;&amp; tmp == '&#123;') st.pop(); else flag = false; &#125; else flag = false; &#125; if(st.empty() &amp;&amp; flag) return true; else return false; &#125;&#125;; 注意如果字符串长度为奇数，那么一定不符合条件。 232. Implement Queue using StacksAnalysis这也是个经典的问题：用栈实现队列。 Codemethod 11234567891011121314151617181920212223242526272829303132333435class MyQueue &#123;public: stack&lt;int&gt; st1, st2; MyQueue() &#123; &#125; void push(int x) &#123; while(!st1.empty()) &#123; st2.push(st1.top()); st1.pop(); &#125; st2.push(x); while(!st2.empty()) &#123; st1.push(st2.top()); st2.pop(); &#125; &#125; int pop() &#123; if(st1.empty()) return false; int front = st1.top(); st1.pop(); return front; &#125; int peek() &#123; if(st1.empty()) return false; else return st1.top(); &#125; bool empty() &#123; return st1.empty(); &#125;&#125;; 重点考虑 push 操作，始终将元素按照队列出队的顺序放在第一个栈中，这样可以简化其他操作。按照这样的思路，除了新元素外，其他元素都需要入栈 2 次，出栈 2 次，总共的操作次数就是 $4n + 2$，其中 $n$ 是队列的大小。 method 2实际上，也可以不用每次都将元素倒换到第一个栈内。设置一个 front 变量，始终保存最后一个入栈的元素。每次出队，就将第一个栈中的元素全部倒入到第二个栈中，同时弹出第二个栈的栈顶元素，这样就不用来回的倒换元素了，但要稍微修改下 peek 操作和 empty 操作。另外，这样做的实际操作次数是远小于第一种方法的。12345678910111213141516171819202122232425262728293031323334class MyQueue &#123;public: int front; stack&lt;int&gt; st1, st2; MyQueue() &#123; &#125; void push(int x) &#123; if(st1.empty()) front = x; st1.push(x); &#125; int pop() &#123; if(st2.empty()) &#123; while(!st1.empty()) &#123; st2.push(st1.top()); st1.pop(); &#125; &#125; int tmp = st2.top(); st2.pop(); return tmp; &#125; int peek() &#123; if(!st2.empty()) return st2.top(); return front; &#125; bool empty() &#123; return st1.empty() &amp;&amp; st2.empty(); &#125;&#125;; Summary栈与队列都是简单的线性表结构，不难理解，但是在处理一些问题的时候，也要灵活使用。一般而言，面对对象的程序语言都会封装好类似的容器，所以要熟悉掌握这些容器的使用。与栈相关的经典题型，还有表达式求值问题，与队列相关的问题，还有循环队列等。不过，都是万变不离其宗。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day6]]></title>
    <url>%2F2022%2F04%2F13%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[3 个简单题~ 1588. Sum of All Odd Length SubarraysAnalysis题意是求含有奇数个项的所有子序列的和，100 的数量级，应该可以直接做出来。 Codemethod 1用 step 来控制每次选择连续奇数个数组成子序列，然后求和。12345678910111213141516class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; for(int step = 1; step &lt;= size; step += 2) &#123; for(int i = 0; i &lt; size; i++) &#123; if(i + step &lt;= size) &#123; for(int j = i; j &lt; i + step; j++) &#123; sum += arr[j]; &#125; &#125; else break; &#125; &#125; return sum; &#125;&#125;; 这样做的时间复杂度是 $O(n^3)$。 method 2但是直接做显然不够优雅，观察上面的计算过程，以 $1, 2, 3$ 的序列为例，计算过程是 $1 + 2 + 3 + 1 + 2 + 3 = 9$，实际上是求了两次数组的元素之和，如果能想个办法只求一次和就好了。按照这样的思考思路，可以使用前缀和思想来做。1234567891011121314151617class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; vector&lt;int&gt; prefixnum(size + 1); for(int i = 0; i &lt; size; i++) &#123; prefixnum[i + 1] = prefixnum[i] + arr[i]; &#125; for(int i = 0; i &lt; size; i++) &#123; for(int step = 1; step + i &lt;= size; step += 2) &#123; int tmp = i + step - 1; sum += prefixnum[tmp + 1] - prefixnum[i]; &#125; &#125; return sum; &#125;&#125;; 使用前缀和需要借助 $O(n)$ 的空间，但可以将时间复杂度降到 $O(n^2)$。 method 3尽管利用前缀和思想解决了重复求和的问题，但是整个过程还是不断的将和重复的相加。按照给的样例 $1, 4, 2, 5, 3$ 的计算过程可以发现，这 5 个元素总是不断的重复出现，最终的结果可以写成：$1 \times 3 + 4 \times 4 + 2 \times 5 + 5 \times 4 + 3 \times 3 = 58$，整个数字序列的系数对应它们的出现次数，分别是：$3, 4, 5, 4, 3$。如果能很容易得到这些系数，那么整个计算过程不就简单了吗？实际上，这些系数的含义正好就是当前这个数字能组成的连续奇数个项的子序列的个数（说的有点绕）。那么仔细思考一下，对于一个数字，如果其出现在奇数个连续数字的子序列中，那么其左右两边数的个数要么同是奇数要么同是偶数，只有这样最终得到的序列的项数才是奇数。那么，假设当前数字为 $arr[i]$，其左边的数字个数为 $leftcount$，右边的数字为 $rightcount$，分类讨论一下： 同是奇数，那么 $arr[i]$ 左边的奇数个数就是 $leftodd = \lfloor \frac {leftcount + 1}{2} \rfloor$，右边奇数的个数就是 $rightodd = \lfloor \frac {rightcount + 1}{2} \rfloor$，这样由 $arr[i]$ 组成的子序列个数就是 $leftodd \times rightodd$。 同是偶数，那么 $arr[i]$ 左边的偶数个数就是 $lefteven = \lfloor \frac {leftcount}{2} \rfloor + 1$，右边偶数的个数就是 $righteven = \lfloor \frac {rightcount}{2} \rfloor + 1$，这样由 $arr[i]$ 组成的子序列个数就是 $lefteven \times righteven$。 最终由 $arr[i]$ 组成的符合条件的子序列个数就是 $leftodd \times rightodd \sum lefteven \times righteven$，这也就是它的系数。12345678910111213class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; for(int i = 0; i &lt; size; i++) &#123; int leftcount = i, rightcount = size - i - 1; int leftodd = (leftcount + 1) / 2, rightodd = (rightcount + 1) / 2; int lefteven = leftcount / 2 + 1, righteven = rightcount / 2 + 1; sum += arr[i] * (leftodd * rightodd + lefteven * righteven); &#125; return sum; &#125;&#125;; 283. Move Zeroes这个题是做过的题，参考：Leetcode_14 天算法入门_day3。再做一次吧~ 1672. Richest Customer WealthAnalysis这好像是道单纯的二维数组遍历的题目~ Code1234567891011121314class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int max = -1, sum; for(int i = 0; i &lt; accounts.size(); i++) &#123; sum = 0; for(int j = 0; j &lt; accounts[i].size(); j++) &#123; sum += accounts[i][j]; &#125; if(max &lt; sum) max = sum; &#125; return max; &#125;&#125;; 嗯，回忆一下库函数的使用吧。12345678910class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int maxwealth = -1, sum; for(int i = 0; i &lt; accounts.size(); i++) &#123; maxwealth = max(maxwealth, accumulate(accounts[i].begin(), accounts[i].end(), 0)); &#125; return maxwealth; &#125;&#125;; Summary嗯，我发觉这里面的简单题总是有不那么简单的做法啊，就拿第一个题来说，不管是前缀和的思路还是数学的思路，都是很不错的锻炼思维的方法，得多思考下。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day8]]></title>
    <url>%2F2022%2F04%2F12%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[今天还是链表哦 206. Reverse Linked List这个题做过啦，参考：Leetcode_14 天算法入门_day10再写一遍~ 83. Remove Duplicates from Sorted ListAnalysis删除有序链表的重复元素，既然给定的是有序的，那么重复元素一定是相邻的，这样就好办了。 Codemethod 1123456789101112131415class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return nullptr; ListNode *cur = head, *p; while(cur) &#123; if(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123; p = cur-&gt;next; cur-&gt;next = p-&gt;next; delete(p); &#125; else cur = cur-&gt;next; &#125; return head; &#125;&#125;; method 2不用想，肯定有递归的做法😂。123456789class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; head-&gt;next = deleteDuplicates(head-&gt;next); if(head-&gt;val == head-&gt;next-&gt;val) head-&gt;next = head-&gt;next-&gt;next; return head; &#125;&#125;; 递归是在回退的时候删除的结点，但本质上并没有将结点占用的内存手动释放掉。 Summary链表的题做了一些了，基本思路算是齐活了，就是递归写的不熟练...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linked_list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day5]]></title>
    <url>%2F2022%2F04%2F12%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[keeping going~ 589. N-ary Tree Preorder TraversalAnalysisN 叉树的先序遍历，直接递归。 Codemethod 1123456789101112131415class Solution &#123;public: void pre(Node *root, vector&lt;int&gt;&amp; ret) &#123; if(!root) return; ret.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++) &#123; pre(root-&gt;children[i], ret); &#125; &#125; vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; pre(root, vector&lt;int&gt;&amp; ret); return ret; &#125;&#125;; 对这道题的递归过程倒是很清楚，哈哈。 method 2借助栈也可以来完成，由于孩子结点可能有多个，所以需要用 map 来记录一下访问到了那个孩子结点。12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; stack&lt;Node*&gt; st; unordered_map&lt;Node*, int&gt; ht; Node *node = root; while(!st.empty() || node != nullptr) &#123; while(node != nullptr) &#123; ret.push_back(node-&gt;val); st.push(node); if(node-&gt;children.size() &gt; 0) &#123; ht[node] = 0; node = node-&gt;children[0]; &#125; else node = nullptr; &#125; node = st.top(); int index = (ht.count(node) ? ht[node] : -1) + 1; if(index &lt; node-&gt;children.size()) &#123; ht[node] = index; node = node-&gt;children[index]; &#125; else &#123; st.pop(); ht.erase(node); node = nullptr; &#125; &#125; return ret; &#125;&#125;; 可以发现，因为每次需要保持左边的结点先访问，所以要先将左边第一个结点入栈。结合栈先进后出的特点，不妨一次性将结点的孩子全部逆序入栈，这样栈顶元素就是需要访问的最左边的元素。123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; stack&lt;Node*&gt; st; st.push(root); while(!st.empty()) &#123; Node *node = st.top(); st.pop(); ret.push_back(node-&gt;val); for(auto it = node-&gt;children.rbegin(); it != node-&gt;children.rend(); it++) &#123; st.push(*it); &#125; &#125; return ret; &#125;&#125;; 496. Next Greater Element IAnalysis这个题有点麻烦，先找出 $nums1[i]$ 在 $nums2$ 中的位置（也就是 $nums2[j]$），然后在找出 $nums2[j]$ 之后第一个比 $nums2[j]$ 大的数。 Codemethod 1数量级不大，直接暴力解决。1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; ret.resize(nums1.size()); for(int i = 0;i &lt; nums1.size(); i++) &#123; bool flag1 = false, flag2 = false; for(int j = 0; j &lt; nums2.size(); j++) &#123; if(nums2[j] == nums1[i]) flag1 = true; if(flag1 &amp;&amp; nums2[j] &gt; nums1[i]) &#123; ret[i] = nums2[j]; flag2 = true; break; &#125; &#125; if(!flag2) ret[i] = -1; &#125; return ret; &#125;&#125;; 使用 2 个 bool 变量来协助查找，就不用重复遍历 nums2 了，这样总体时间复杂度是 $O(nums1.length × nums2.length)$。 method 2还有一个进阶提示，问有没有 $O(nums1.length + nums2.length)$ 的解法，也不知道这个提示要求的是时间复杂度还是空间复杂度。看了一下题解，原来是时间复杂度啊。要达到这样的时间复杂度，需要借助一种新的思想——单调栈（Monotonic Stack）。当然了，本质上还是用栈，只不过先遍历 $nums2$ 将所有数字后面第一个比它大的数都找到，然后在遍历 $nums1$，为了方便查询，借助一下哈希表。123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; stack&lt;int&gt; st; unordered_map&lt;int, int&gt; ht; for(int i = nums2.size() - 1; i &gt;= 0; i--) &#123; int num = nums2[i]; while(!st.empty() &amp;&amp; num &gt;= st.top()) st.pop(); ht[num] = st.empty() ? -1 : st.top(); st.push(num); &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt; nums1.size(); i++) &#123; ret.push_back(ht[nums1[i]]); &#125; return ret; &#125;&#125;; em...好好体会一下栈的这种应用。 1232. Check If It Is a Straight LineAnalysis这个题好像在考一次函数的知识点，这好像是初中数学。 Code直接用前 2 个点求出一次函数的方程，然后验证后面的点是否在上面即可。123456789101112131415161718192021222324class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; double k, b, diff1, diff2; diff1 = coordinates[1][1] - coordinates[0][1]; diff2 = coordinates[1][0] - coordinates[0][0]; if(diff1 == 0) &#123; for(int i = 0; i &lt; coordinates.size() - 1; i++) &#123; if(coordinates[i][1] != coordinates[i + 1][1]) return false; &#125; &#125; else if(diff2 == 0) &#123; for(int i = 0; i &lt; coordinates.size() - 1; i++) &#123; if(coordinates[i][0] != coordinates[i + 1][0]) return false; &#125; &#125; else &#123; k = diff1 / diff2; b = coordinates[0][1] - k * coordinates[0][0]; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if(coordinates[i][1] != b + k * coordinates[i][0]) return false; &#125; &#125; return true; &#125;&#125;; 注意几个点： 坐标轴上的点也能连成一条直线。 形如 $y = 2, x = 1$ 这样与坐标轴垂直的线也符合题意。 注意求斜率时，$x$ 不能为 0。 实际上为了避免上面的问题，完全可以不求斜率。因为直线还有其他形式的方程，所以使用其他方程就可以得到不一样的代码。123456789101112131415class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; int deltax = coordinates[0][0], deltay = coordinates[0][1]; for(int i = 0; i &lt; coordinates.size(); i++) &#123; coordinates[i][0] -= deltax; coordinates[i][1] -= deltay; &#125; int A = coordinates[1][1], B = -coordinates[1][0]; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if(coordinates[i][0] * A + coordinates[i][1] * B != 0) return false; &#125; return true; &#125;&#125;; 上面的代码将第一个点平移到原点，其他点平移了第一个点的距离。这样利用直先的一般式（$y = Ax + By + C$）求 A 和 B 时，任意一个点的横纵坐标改变一下符号就可以了，这就省去了求斜率的过程。 当然了，还可以用直线的两点式（$\frac{y-y1}{x-x1} = \frac{y-y2}{x-x2}$）来求。1234567891011121314class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if( (coordinates[i][0] - coordinates[0][0]) * (coordinates[i][1] - coordinates[1][1]) != (coordinates[i][0] - coordinates[1][0]) * (coordinates[i][1] - coordinates[0][1]) ) return false; &#125; return true; &#125;&#125;; 另外，加一句，计算机做除法消耗的时间是大于乘法的。 Summary今天的 3 个题，说简单也不是那么简单，因为都需要动点脑筋后才能变得简单。特别是第二个和第三个题，这两个题，用的方法不一样，写出来的代码也是不一样的。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day7]]></title>
    <url>%2F2022%2F04%2F11%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[之前链表的题确实没做够啊~ 141. Linked List CycleAnalysis判断链表中是否存在环，很直观的做法就是利用哈希表了，如果访问过的结点又再次被访问了，那么一定存在环。 Codemethod 1直接用 set 容器来构造一个哈希表。1234567891011121314class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *p = head; unordered_set&lt;ListNode*&gt; ht; while(p) &#123; if(ht.find(p) != ht.end()) return true; ht.insert(p); p = p-&gt;next; &#125; return false; &#125;&#125;; method 2有个进阶提示，如何能在常量的空间复杂度解决这个问题。有了做 202. Happy Number 的经验，这里很自然就会想到用快慢指针来解决这个问题。123456789101112class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *slow = head, *fast = head-&gt;next; while(fast &amp;&amp; slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next; &#125; return fast != nullptr; &#125;&#125;; 注意，如果不存在循环链表，并且 fast 指向的是倒数第二个结点时，直接跳 2 个结点会出错，因为那个结点是不存在的，所以需要判断一下。当然，也可以在开始的时候将快慢指针设置一样。12345678910111213class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *slow = head, *fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 21. Merge Two Sorted Lists这个题是做的题，参考：Leetcode_14 天算法入门_day10。嗯，代码就不贴了，再写一下就行了。 203. Remove Linked List ElementsAnalysis感觉这个题比上个题容易，只要删除链表中值为 val 的结点就可以了。先找到结点位置，然后在删除。 Codemethod 1借助哑结点来完成，比较简单。1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *L = new ListNode; ListNode *p = L, *cur; p-&gt;next = head; while(p) &#123; if(p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; cur = p-&gt;next; p-&gt;next = cur-&gt;next; delete(cur); &#125; else p = p-&gt;next; &#125; p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; method 2同样，这个题依然可以用递归来做，就是有点难想到啊。12345678class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; if(head == nullptr) return head; head-&gt;next = removeElements(head-&gt;next, val); return head-&gt;val == val ? head-&gt;next : head; &#125;&#125;; Summary这几个链表题感觉比较简单、常规，不过递归的做法真难想啊。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linked_list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day4]]></title>
    <url>%2F2022%2F04%2F11%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[这个系列好像都是简单题...有点没有挑战性~ 1822. Sign of the Product of an ArrayAnalysis这个题如果直接算，会溢出。实际上，并没有算出来的必要，用负数的个数就可以来判断最终结果是否为负。 Code1234567891011class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int negative = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] == 0) return 0; else if(nums[i] &lt; 0) negative++; &#125; return negative % 2 == 1 ? -1 : 1; &#125;&#125;; 话说回来，还是 WA 了一次，还是看题仔细一点啊。 1502. Can Make Arithmetic Progression From SequenceAnalysis一开始没看懂 arithmetic progression，看了用例才知道，原来是等差数列的意思。也就是说，题目意思就是判断给定数字序列是否构成一个等差数列。这样的话，直接排序然后逐个判断就行了。 Code1234567891011class Solution &#123;public: bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end()); int diff = arr[0] - arr[1]; for(int i = 1; i &lt; arr.size() - 1; i++) &#123; if(diff != arr[i] - arr[i + 1]) return false; &#125; return true; &#125;&#125;; 202. Happy NumberAnalysis这个题目名字有点喜感...题目有 PAT 的味道了。按照题目的意思，对于每一个数字而言，如果是快乐数，那么最终会变成 1；如果不是快乐数，那么最终会无限循环下去。那么，应该如何判断陷入无限循环中了呢？ Codemethod 1要判断陷入无限循环，可以借助哈希表，只要出现过的数字又一次出现了，那么一定说明这个数不是快乐数。12345678910111213141516171819class Solution &#123;public: bool isHappy(int n) &#123; int now; set&lt;int&gt; ht; while(1) &#123; now = 0; while(n) &#123; now += pow(n % 10, 2); n /= 10; &#125; if(now == 1) return true; if(ht.find(now) != ht.end()) break; ht.insert(now); n = now; &#125; return false; &#125;&#125;; method 2既然知道了会陷入循环，而且题目又给出了一个循环的例子，大可以看看循环中的数都是些什么。按照 $n=2$ 输入后，最后会得到：$4, 16, 37, 58, 89, 145, 42, 20, 4,...$ 的循环。也就是说，非快乐数最终会陷入这样的无限循环中。这样，我们就可以设置两个指针来解决这个问题。123456789101112131415161718192021/* method 2 */class Solution &#123;public: int getnumber(int n) &#123; int ret = 0; while(n) &#123; int d = n % 10; n /= 10; ret += d * d; &#125; return ret; &#125; bool isHappy(int n) &#123; int slow = n, fast = getnumber(n); while(fast != 1 &amp;&amp; slow != fast) &#123; slow = getnumber(slow); fast = getnumber(getnumber(fast)); &#125; return fast == 1; &#125;&#125;; 因为最终陷入循环的数字序列是固定的（也可以把这个数字序列看出是循环的），所以 slow 跟 fast 一定会相遇。 method 3有了上面的过程，就可以直接设置一个固定的哈希表，如果算到这些数字了，直接返回 false 即可。12345678910111213141516171819202122class Solution &#123;public: unordered_set&lt;int&gt; numbers &#123;4, 16, 37, 58, 89, 145, 42, 20&#125;; int getnumber(int n) &#123; int ret = 0; while(n) &#123; int d = n % 10; n /= 10; ret += d * d; &#125; return ret; &#125; bool isHappy(int n) &#123; int now; while(n != 1) &#123; now = getnumber(n); if(numbers.find(now) != numbers.end()) return false; n = now; &#125; return true; &#125;&#125;; 1790. Check if One String Swap Can Make Strings EqualAnalysis题意比较简单，只要能通过不超过 1 次交换得到两个相同的字符串，就返回 true，所以直接模拟就可以了。 Code123456789101112131415class Solution &#123;public: bool areAlmostEqual(string s1, string s2) &#123; if(s1.length() != s2.length()) return false; vector&lt;int&gt; index; for(int i = 0; i &lt; s1.length(); i++) &#123; if(s1[i] != s2[i]) index.push_back(i); if(index.size() == 2) break; &#125; if(index.size() == 0) return true; else if(index.size() == 1) return false; swap(s2[index[0]], s2[index[1]]); return s1 == s2; &#125;&#125;; Summary简单题想要直接 AC 也需要费一点功夫啊。今天的第三个题，其实后面的 2 种做法就不是那么的简单，但是在性能上是更优秀的，这就是凸显技术能力强弱的地方了，所以，要好好把握。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自学吉他的一点心得]]></title>
    <url>%2F2022%2F04%2F10%2F%E8%87%AA%E5%AD%A6%E5%90%89%E4%BB%96%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[最近写的都是跟编程相关的文章，有点乏味了。正巧，最近感觉自己的吉他水平又有了一点进步，所以总结（感慨）一下。 来自我心 - 老狼Your browser does not support the audio tag. 先说说上面这首歌吧，是狼叔第一张专辑《恋恋风尘》里面的一首歌，由郁冬作词作曲。在收藏这张专辑之前，其实我应该并没有听过这首歌，当时我并没有想要把这张专辑的歌全部收藏，只是想收藏里面的另外一首歌——《恋恋风尘》。后来有一次带着耳机，莫名的循环到了这张专辑，耐着性子听了下去。突然发现，这张专辑的歌都很有特色，而且制作精良，也很符合年轻人的口味（也许只是我的口味）。然后我就收藏了，到现在越发觉得这张专辑的歌是越听越耐听。 话说回来，就《来自我心》而言，这首歌最打动我的还是吉他伴奏（当然这首歌整体本来就很好）。这种风格的伴奏，给人的感觉十分的和谐生动、自然流畅，就好像花儿从花苞到长成鲜花的过程一样。乍听之下，可能觉得很稀松平常，但是随着这种旋律的不断深入，就开始生动活泼起来了。 有点巧合的是，我后来又得知（尽管我已经忘记从何得知）了这首歌的伴奏是由杨乐老师编配的，而他自己的口琴专辑——《口琴》，又是我非常喜欢的专辑。 曾经的我非常想自己把这首歌的伴奏弹下来，现在，我快要实现了，这无疑让我很开心，但也让我回忆起了曾经的自己。 原来的自己，总是喜欢把注意力放在弹奏上。心中想的只有一件事情：能独立弹奏出来就可以了。实际上，我现在觉得这对“学习”这个过程而言，太敷衍。因为，能独立弹奏出来并不意味着，这首歌（或者曲子）已经学习完成了。事实上，你并不清楚这个谱子为什么要这样编。换句话说，你可能压根不知道你在弹什么东西。你唯一能确定的事情就是，这样弹能出来好听的旋律。然后，你要做的剩下的事情就是不断强化肌肉记忆。现在想想，这样的学习方法很容易磨掉一个人的耐心。 不过，有的人可能并不是想要学到什么东西，也许只是单纯的打发时间，或者自娱自乐。如果是这样，私以为完全没必要来自己弹奏乐器，练好唱歌就好了😂。 对了，还有乐理。 乐理这个东西，自己很早就接触过了，但是一直不明白到底如何用到歌曲和旋律中。这段时间，尝试了一下扒歌，编配和弦之后，才明白一些原来自己已经“明白过”的乐理概念。比如： 主音是什么？如何根据主音来确定一首流行歌曲或者民谣歌曲的调性。 和弦是什么？常用的一些和弦走向。 不同调性的歌曲如何互相转化？ 类似的问题还有很多。虽然，我现在已经可以回答上面这些问题了。但是，我并不能很好的回答这些问题，比如还有很多常用的和弦走向我不知道，编配时使用的和弦并不全是固定调内的和弦，常用的一些编配方法等等。 所以，为了强化这方面的能力，就不能仅仅是能弹奏一首歌就足够了，还需要分析一下谱子，想想为什么要这样编。另外，要多尝试自己扒歌，编配和弦，多体会和弦的色彩。 想到这里，又发现自己仍然还有很多不懂的东西。但是，也很期待将来自己的进步啊。 最后，附上自己的 ls16。]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day6]]></title>
    <url>%2F2022%2F04%2F10%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[今天是 3 个跟字符串相关的题目。 387. First Unique Character in a StringAnalysis找出第一个字符串中第一个出现且只出现过一次的字符。 Code直接散列。12345678910111213class Solution &#123;public: int firstUniqChar(string s) &#123; int times[26] = &#123;0&#125;; for(auto ch: s) &#123; times[ch - 'a']++; &#125; for(int i = 0; i &lt; s.length(); i++) &#123; if(times[s[i] - 'a'] == 1) return i; &#125; return -1; &#125;&#125;; 383. Ransom NoteAnalysis判断 ransomNote 这个字符串是否能被 magazine 这个字符串中的字符组成。 Code直接散列，跟上个题差不多的思路。123456789101112131415class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if(magazine.length() &lt; ransomNote.length()) return false; int times[26] = &#123;0&#125;; for(auto ch: magazine) &#123; times[ch - 'a']++; &#125; for(auto ch: ransomNote) &#123; times[ch - 'a']--; if(times[ch - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125;; 242. Valid AnagramAnalysis这个题跟上个题也是类似的... Codemethod 1123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; vector&lt;int&gt; count1(26), count2(26); for(auto ch: s) &#123; count1[ch - 'a']++; &#125; for(auto ch: t) &#123; count2[ch - 'a']++; &#125; if(count1 == count2) return true; else return false; &#125;&#125;; 直接比较 vector 的骚操作忘记是从哪里学的了，当然也可以采取与上一题一样的思路，出现负数就返回 false。还有一个进阶提示：如果输入的是 Unicode 字符怎么办？要解决这个问题，首先需要知道的是 Unicode 与 Ascii 的不同。当然，不同点很多，但是在这个题目的背景下，只需要注意 Unicode 字符占 2 个字节，而 Ascii 只占 1 个字节。那么，如果还想用哈希的思路来解决这个问题，就需要对哈希表的 key 进行修改。不过，C++ 有现成的 map，所以直接用 map 就行了。 method 2不过，只是解决这个题的话，其实还有一种做法，那就是排序，只要排序后的 2 个字符串一样，那就是符合条件的。123456789class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; sort(s.begin(), s.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; Summary这 3 个字符串处理的题，都比较简单...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day3]]></title>
    <url>%2F2022%2F04%2F10%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[条件语句？ 976. Largest Perimeter TriangleAnalysis这个题乍一看挺简单的，其实需要稍微思考一下。首先，能否组成三角形，可以借助两边之和或者之差来进行判断。接下来的问题就是如何得到周长最大的三角形，要使周长最大，边长肯定得最大。自然而然，不妨将数组从大到小排序，然后依次判断是否是三角形，符合就直接返回周长，可以确定的是，这个周长一定是最大值。为什么？可以用反证法来说明，假设 $nums[0]$、$nums[1]$和$nums[2]$能构成三角形，存在 $nums[i]$ 使得由 $nums[0]$、$nums[1]$ 和 $nums[i]$ 构成的三角形的周长更大，就必有 $nums[i] &gt; nums[2]$，那么此时这个数组一定不是有序的。同样的，如果 $nums[0]$、$nums[1]$ 和 $nums[2]$ 不能构成三角形，那么 $nums[i], 2 &lt; i &lt; n$ 也不能与 $nums[1]$ 和 $nums[0]$ 组成三角形。 Code按照上面的思路，可以写出下面的代码：1234567891011class Solution &#123;public: int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), [](int a, int b) &#123; return a &gt; b; &#125;); for(int i = 0; i &lt; nums.size() - 2; i++) &#123; int a = nums[i], b = nums[i + 1], c = nums[i + 2]; if(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) return a + b + c; &#125; return 0; &#125;&#125;; 回过头再来想一下，可以发现这实际是个贪心问题。 1779. Find Nearest Point That Has the Same X or Y CoordinateAnalysis题目有点长，要耐心的读下题。 Code1234567891011121314151617class Solution &#123;public: int nearestValidPoint(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int minmd = 0x3fffffff, index = -1; for(int i = 0; i &lt; points.size(); i++) &#123; if(points[i][0] == x &amp;&amp; points[i][1] == y) return i; else if(points[i][0] == x || points[i][1] == y) &#123; int tmp = abs(x - points[i][0]) + abs(y - points[i][1]); if(tmp &lt; minmd) &#123; minmd = tmp; index = i; &#125; &#125; &#125; return index; &#125;&#125;; Summary考贪心的题目，有时候挺难想的，而且只要想到了就很简单，想不到就很难...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day5]]></title>
    <url>%2F2022%2F04%2F09%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[两个中等题~ 36. Valid SudokuAnalysis看到这个题目，立马去玩了一局数独。好在这个题目并不是求解，而是只用判断给定数独矩阵的合法性即可。也就是说，对于矩阵中存在的元素而言，必须满足： 这一行只有这一个元素 这一列只有这一个元素 9 宫格只有这一个元素 当且仅当这 3 个条件都满足，这个数独矩阵才合法。 Codemethod 1按照上面的思路，逐个判断就可以了。123456789101112131415161718192021222324252627class Solution &#123;public: bool isvalid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int r, int c) &#123; for(int i = 0; i &lt; 9; i++) &#123; if(i != c &amp;&amp; board[r][i] == board[r][c]) return false; &#125; for(int i = 0; i &lt; 9; i++) &#123; if(i != r &amp;&amp; board[i][c] == board[r][c]) return false; &#125; int R = r &gt;= 3 ? r &gt;= 6 ? 9 : 6 : 3; int C = c &gt;= 3 ? c &gt;= 6 ? 9 : 6 : 3; for(int i = R - 3; i &lt; R; i++) &#123; for(int j = C - 3; j &lt; C; j++) &#123; if(i != r &amp;&amp; j != c &amp;&amp; isdigit(board[i][j]) &amp;&amp; board[i][j] == board[r][c]) return false; &#125; &#125; return true; &#125; bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i = 0; i &lt; 9; i++) &#123; for(int j = 0; j &lt; 9; j++) &#123; if(isdigit(board[i][j]) &amp;&amp; !isvalid(board, i, j)) return false; &#125; &#125; return true; &#125;&#125;; 把行与列的判断放在前面，并且先对下标进行判断的目的，是为了能在一定程度上减少判断的次数。 method 2回过头来看这道题的话，其实不算难题，就是比较麻烦。按照上面的代码，可以发现有很多重复判断的地方，可以使用哈希表优化一下。对于每一个元素而言，需要满足 3 个条件，按照这样的思路，需要维护的哈希表个数一共是：9 + 9 + 9 = 18。1234567891011121314151617181920212223class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int rows[9][9] = &#123;0&#125;; int columns[9][9] = &#123;0&#125;; int submatrix[3][3][9] = &#123;0&#125;; for(int i = 0; i &lt; 9; i++) &#123; for(int j = 0; j &lt; 9; j++) &#123; char c = board[i][j]; if(c != '.') &#123; int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; submatrix[i / 3][j / 3][index]++; if(rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || submatrix[i / 3][j / 3][index] &gt; 1) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;; 虽然使用哈希表很简洁，但是就这个问题而言，一共要维护 27 个哈希表。这与 $9×9$ 矩阵的遍历所消耗的时间相比，感觉实际上还不如直接暴力来的划算？实际生产环境中多等个零点几秒估计也不会造成什么经济损失？😂 73. Set Matrix ZeroesAnalysis这个题最容易想到的做法应该是先找到所有 0 的位置，然后根据这些位置再来将符合条件的元素置零即可。尽管题目要求原地算法，但是先把想到的办法写出来吧 Codemethod 1按照上面的思路，很容易就可以得到暴力解法。123456789101112131415161718192021class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;pair&lt;int, int&gt;&gt; zeropoints; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) zeropoints.push_back(make_pair(i, j)); &#125; &#125; for(auto it: zeropoints) &#123; int x = it.first, y = it.second; for(int i = 0; i &lt; n; i++) &#123; matrix[x][i] = 0; &#125; for(int i = 0; i &lt; m; i++) &#123; matrix[i][y] = 0; &#125; &#125; &#125;&#125;; 之所以要先将点挑出来，是因为置零之后会影响后面的判断，所以要分开进行。另外，从上面的代码中，可以很容易的发现，在遍历 0 点的坐标时，x、y 可能会出现相等的情况，这样就会产生很多重复操作。 method 2按照上面的思路，借助哈希表来优化一下。$m×n$ 的矩阵一共需要 $m + n$个哈希表来维护。12345678910111213141516171819202122232425262728class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;pair&lt;int, int&gt;&gt; zeropoints; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) zeropoints.push_back(make_pair(i, j)); &#125; &#125; int rows[201] = &#123;0&#125;, columns[201] = &#123;0&#125;; for(auto it: zeropoints) &#123; int x = it.first, y = it.second; if(!rows[x]) &#123; rows[x] = 1; for(int i = 0; i &lt; m; i++) &#123; if(i != y) matrix[x][i] = 0; &#125; &#125; if(!columns[y]) &#123; columns[y] = 1; for(int i = 0; i &lt; n; i++) &#123; if(i != x) matrix[i][y] = 0; &#125; &#125; &#125; &#125;&#125;; 实际上，也可以不用存储每个点的坐标，只需要分别存储行号和列号即可，那么不妨用 set 来存储，这样还可以自动去除重复的行、列。然后遍历 set，将符合要求的行、列的所有元素全部置为零即可。偷一下懒，这段代码就不写了。 method 3但是不管是用 set 还是 pair，需要的存储空间都是 $O(m + n)$，有什么办法能原地进行呢？答案是用第一行和第一列来更新矩阵剩余的元素，再用剩余的元素来更新第一行和第一列的元素。但是，这样会改变第一行和第一列的元素，会无法判断其本身是否存在 0，所以需要用 2 个变量来记录第一行和第一列是否含 0。12345678910111213141516171819202122232425262728293031class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); bool frow0 = false, fcol0 = false; for(int i = 0; i &lt; n; i++) &#123; if(!matrix[0][i]) frow0 = true; &#125; for(int i = 0; i &lt; m; i++) &#123; if(!matrix[i][0]) fcol0 = true; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][j]) &#123; matrix[i][0] = matrix[0][j] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0; &#125; &#125; if(frow0) &#123; for(int i = 0; i &lt; n; i++) matrix[0][i] = 0; &#125; if(fcol0) &#123; for(int i = 0; i &lt; m; i++) matrix[i][0] = 0; &#125; &#125;&#125;; 回过头来看的话，这种解法就是将第一行、第一列当成了散列表。那还能不能更优化呢？当然可以，不妨设 fcol0 是用来记录第一列是否存在 0，与上面的思路类似，在设置好 fcol0 后，用剩余的元素处理第一行和第一列的元素（这两件事可以同时进行）。然后，再用处理后的第一行、第一列元素来处理剩余的元素。这里可以发现，第一行是否存在 0 的信息会被记录在 $matrix[0][0]$ 中。接下来，按照上面的思路来修改矩阵的值就可以了。1234567891011121314151617181920212223242526class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); bool fcol0 = false; for(int i = 0; i &lt; m; i++) &#123; if(!matrix[i][0]) fcol0 = true; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][j]) &#123; matrix[i][0] = matrix[0][j] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0; &#125; &#125; if(!matrix[0][0]) &#123; for(int i = 1; i &lt; n; i++) matrix[0][i] = 0; &#125; if(fcol0) &#123; for(int i = 0; i &lt; m; i++) matrix[i][0] = 0; &#125; &#125;&#125;; 需要注意的是，最后单独处理第一行第一列时，一定要先判断第一行是否全为 0，因为 fcol0 可能会使不为 0 的 $matrix[0][0]$ 变为 0，这就影响了后面的判断了。事实上，也可以用 $matrix[0][0]$ 来记录列是否存在 0，这样就需要设置一个 frow0 来记录第一行是否存在 0 了。同样地，也需要先用 $matrix[0][0]$ 判断。 Summary今天的 2 个题都挺有意思的。第一个题数组下标的转换是需要体会的点，这种做法其实很方便的。第二个题对空间的优化也很不错，不过理解起来可能没有那么容易，得仔细体会下。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day2]]></title>
    <url>%2F2022%2F04%2F09%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[好像有做过的题？ 191. Number of 1 Bits这个题做过的，参考 Leetcode_14 天算法入门_day13。直接调用库函数，再做一次。123456class Solution &#123;public: int hammingWeight(uint32_t n) &#123; return __builtin_popcount(n); &#125;&#125;; 1281. Subtract the Product and Sum of Digits of an IntegerAnalysis第一次在 Leetcode 上见到数位拆分的题。不是难题，直接做就行了。 Code12345678910111213class Solution &#123;public: int subtractProductAndSum(int n) &#123; int product = 1, sum = 0, digit; do &#123; digit = n % 10; n /= 10; product *= digit; sum += digit; &#125; while(n); return product - sum; &#125;&#125;; Summary今天这两个题太简单了...还好有其他的学习计划。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 天编程能力入门_day1]]></title>
    <url>%2F2022%2F04%2F08%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[感觉题目不够做，再开启一个学习计划吧~ 1523. Count Odd Numbers in an Interval RangeAnalysis找出 $[low, high]$ 内的奇数。 Code这题也太容易了吧？12345678910class Solution &#123;public: int countOdds(int low, int high) &#123; int count = 0; for(; low &lt;= high; low++) &#123; if(low % 2) count++; &#125; return count; &#125;&#125;; 竟然超时了，判断奇偶还有什么骚操作吗？仔细想一下，这个题应该是个数学题。自然数中，奇数与偶数都是交替排列的，也就是说，奇数后面的后面的数还是奇数。那么，根据给定数字的不同，不如直接将中间奇数的个数算出来，如下：1234567class Solution &#123;public: int countOdds(int low, int high) &#123; if(low % 2 &amp;&amp; high % 2) return (high - low) / 2 + 1; else return (high - low) / 2 + high % 2 + low % 2; &#125;&#125;; 这样写显然不够优雅，改一下：123456class Solution &#123;public: int countOdds(int low, int high) &#123; return (high - low) / 2 + (high % 2 || low % 2); &#125;&#125;; 嗯，好多了。实际上，区间 $[0, x]$ 的奇数个数就等于 $\lfloor \frac{x + 1}{2} \rfloor$。那么可以用前缀和思想来处理这个问题，如下：123456class Solution &#123;public: int countOdds(int low, int high) &#123; return ((high + 1) &gt;&gt; 1) - (low &gt;&gt; 1); &#125;&#125;; 1491. Average Salary Excluding the Minimum and Maximum SalaryAnalysis在计算总薪水的同时，得到最大值和最小值，然后返回结果就可以了。 Code123456789101112class Solution &#123;public: double average(vector&lt;int&gt;&amp; salary) &#123; int size = salary.size(), sum = salary[0], min = salary[0], max = salary[0]; for(int i = 1; i &lt; size; i++) &#123; sum += salary[i]; if(min &gt; salary[i]) min = salary[i]; if(max &lt; salary[i]) max = salary[i]; &#125; return (sum - min - max) * 1.0 / (size - 2); &#125;&#125;; Summary虽然是简单题，但是如何把简单题做的更简单也需要多动脑筋。其实第二个题，可以直接调用 API，但是直接一个循环解决会更好。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day4]]></title>
    <url>%2F2022%2F04%2F08%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[Let`s go go go! 566. Reshape the MatrixAnalysis这个题目有点挂羊头卖狗肉的感觉。隐约记得数据结构那本书好像讲过一点关于矩阵的压缩存储的知识。 Code直接做吧。12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123; int m = mat.size(), n = mat[0].size(); if(m * n != r * c) return mat; int tr = 0, tc = 0; vector&lt;vector&lt;int&gt;&gt; ret(r, vector&lt;int&gt;(c)); for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; ret[i][j] = mat[tr][tc++]; if(tc == n) &#123; tr++; tc = 0; &#125; &#125; &#125; return ret; &#125;&#125;; 不过，好像可以结合矩阵的压缩存储知识优化一下：123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123; int m = mat.size(), n = mat[0].size(); if(m * n != r * c) return mat; vector&lt;vector&lt;int&gt;&gt; ret(r, vector&lt;int&gt;(c)); for(int index = 0; index &lt; m * n; index++) &#123; ret[index / c][index % c] = mat[index / n][index % n]; &#125; return ret; &#125;&#125;; 118. Pascal’s TriangleAnalysisdp 题，他又来了😂。这个题就是求杨辉三角。好像不是很复杂的样子，设置一个 dp 二维数组，显然，$dp[0][0] = 1$，$dp[1][0] = 1, dp[1][1] = 1$，$dp[2][0] = 1, dp[2][1] = dp[1][0] + dp[1][1] = 2, dp[2][2] = dp[1][1] = 1$。按照这种思路，可以得到状态转移方程：$dp[i][0] = dp[i - 1][0], dp[i][i] = dp[i - 1][i - 1], dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]$。 Code因为最后的输出结果总没有多余的 0 存在，所以为了返回符合条件的矩阵，dp 数组只能与返回的矩阵分开了。12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int dp[31][31] = &#123;0&#125;; dp[0][0] = 1; ret.push_back(&#123;dp[0][0]&#125;); for(int i = 1; i &lt; numRows; i++) &#123; vector&lt;int&gt; tmp; dp[i][0] = dp[i - 1][0]; tmp.push_back(dp[i][0]); for(int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; tmp.push_back(dp[i][j]); &#125; dp[i][i] = dp[i - 1][i - 1]; tmp.push_back(dp[i][i]); ret.push_back(tmp); &#125; return ret; &#125;&#125;; 不过，这样写总感觉不太优雅，嗯，改一下：1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ret(numRows); for(int i = 0; i &lt; numRows; i++) &#123; ret[i].resize(i + 1); ret[i][0] = ret[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; ret[i][j] = ret[i - 1][j - 1] + ret[i - 1][j]; &#125; &#125; return ret; &#125;&#125;; 果然，这样写清爽很多。 Summary今天的题目比较简单？感觉好像可以在多来几道题？话说，杨辉三角这个东西性质还挺多的，说不定可能会出其他性质的题。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day3]]></title>
    <url>%2F2022%2F04%2F07%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[每日几道题，不要偷懒~ 350. Intersection of Two Arrays IIAnalysis这是个很直观的题目，找出两个数组的交集即可。 Codemethod 1在不要求保留原数据的情况下，可以直接查找。之所以要把找到过的元素改为 -1，是为了避免在一个数组中出现了 2 次，但在另外一个数组中只出现一次的情况。12345678910111213141516171819/* method 1 */class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int m = nums1.size(), n = nums2.size(); for(int i = 0; i &lt; m; i++) &#123; int tmp = nums1[i]; for(int j = 0; j &lt; n; j++) &#123; if(tmp == nums2[j]) &#123; nums2[j] = -1; ret.push_back(tmp); break; &#125; &#125; &#125; return ret; &#125;&#125;; method 2为了提高效率，不妨设置两个散列表，用来统计每个数组中数字的出现次数，接着再从散列表中挑出同时出现的数字即可。12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int ht1[1005] = &#123;0&#125;, ht2[1005] = &#123;0&#125;; for(int i = 0; i &lt; nums1.size(); i++) &#123; ht1[nums1[i]]++; &#125; for(int i = 0; i &lt; nums2.size(); i++) &#123; ht2[nums2[i]]++; &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(ht1[i] &amp;&amp; ht2[i]) &#123; int tmp = ht1[i] &gt; ht2[i] ? ht2[i] : ht1[i]; for(int j = 0; j &lt; tmp; j++) &#123; ret.push_back(i); &#125; &#125; &#125; return ret; &#125;&#125;; 但是这样用散列表不够聪明，应该可以只用一个散列表，如下：1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int ht[1005] = &#123;0&#125;; for(int i = 0; i &lt; nums1.size(); i++) &#123; ht[nums1[i]]++; &#125; for(int i = 0; i &lt; nums2.size(); i++) &#123; if(ht[nums2[i]]) &#123; ret.push_back(nums2[i]); ht[nums2[i]]--; &#125; &#125; return ret; &#125;&#125;; 这个题还有 3 个进阶提示： 给出的数组如果是排序的如何优化？如果是排序的，就可以用双指针了。换句话说，第一种解法就可以改成先排序，在遍历数组了。 nums1 的容量小于 nums2 的容量，哪种方法更优？如果两个数组的容量大小差距过大，那么排序 + 双指针会更好一些。 内存无法一次性读取数组的元素，那种方法更优？显然散列更优。 121. Best Time to Buy and Sell StockAnalysis从问题的复杂性来看，这个题的题意还算简单。 Codemethod 1最先想到的永远是暴力解法，毫无疑问的超时了😂。1234567891011121314151617181920class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size = prices.size(), max = 0; vector&lt;int&gt; profit(size); for(int i = 0; i &lt; size; i++) &#123; int index = i, tmax = prices[i]; for(int j = index + 1; j &lt; size; j++) &#123; if(tmax &lt; prices[j]) &#123; tmax = prices[j]; index = j; &#125; &#125; if(index == i) profit[i] = -1; else profit[i] = prices[index] - prices[i]; if(profit[i] &gt; max) max = profit[i]; &#125; return max; &#125;&#125;; 暴力解法的思路是基于贪心的，不过好像还可以优化一下代码：123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size = prices.size(), ans = 0; for(int i = 0; i &lt; size; i++) &#123; for(int j = i + 1; j &lt; size; j++) &#123; ans = max(ans, prices[j] - prices[i]); &#125; &#125; return ans; &#125;&#125;; method 2容易发现，第 i 天的利润只与第 i 天之前的最低价有关。选择在不同的天数购买，最终会得到不同的利润结果，这种题目多半要用动态规划的思路。设置一个 dp 数组用来表示第 i 天之前的最低价，再设置一个变量 ans 来维护当前最大的利润。12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int days = prices.size(), ans = 0; vector&lt;int&gt; dp(days); dp[0] = prices[0]; for(int i = 1; i &lt; days; i++) &#123; dp[i] = min(dp[i - 1], prices[i]); ans = max(ans, prices[i] - dp[i]); &#125; return ans; &#125;&#125;; 这里，再利用滚动数组的思想来优化一下代码：1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int days = prices.size(), ans = 0, minprice = prices[0]; for(int i = 1; i &lt; days; i++) &#123; minprice = min(minprice, prices[i]); ans = max(ans, prices[i] - minprice); &#125; return ans; &#125;&#125;; Summary虽然是两道简单题，但是考察的思想是很重要的思想。另外，动态规划的题目可真是灵活啊...还是题目做少了吗？😂]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day2]]></title>
    <url>%2F2022%2F04%2F06%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[这两天的主题都是数组，感觉叫线性表更合适。 1. Two SumAnalysis好吧，这是 leetcode 第一题，估计没人没做过吧。做法很多，用散列做一下得了。 Code123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; ht; vector&lt;int&gt; ret(2); for(int i = 0; i &lt; nums.size(); i++) &#123; if(ht.find(target - nums[i]) != ht.end()) &#123; ret[0] = ht[target - nums[i]], ret[1] = i; break; &#125; ht[nums[i]] = i; &#125; return ret; &#125;&#125;; 88. Merge Sorted ArrayAnalysis这个题跟合并链表好像是一个类型的题。 Codemethod 1先按照常规做法做一下。题目要求没有返回值，所以最后的结果只能存储在 nums1 中，那就只能想办法把 nums2 的数插到 nums1 中。12345678910111213141516171819/* method 1 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; int tmp = nums2[i], pos = 0; while(pos &lt; m &amp;&amp; tmp &gt; nums1[pos]) pos++; if(pos != m) &#123; int index = m; while(index &gt; pos) &#123; nums1[index] = nums1[index - 1]; index--; &#125; &#125; nums1[pos] = tmp; m++; &#125; &#125;&#125;; 从上面的解法中也可以看出链表与线性表在插入元素上的效率差异。 method 2下面换一种解法。1234567891011/* method 2 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int index = 0; for(int i = m; i &lt; m + n; i++) &#123; nums1[i] = nums2[index++]; &#125; sort(nums1.begin(), nums1.end()); &#125;&#125;; 直接拷贝到后面，排序完事。 method 3别忘记了，题目还有一个条件，那就是 nums1 和 nums2 本身是有序的，那么就可以按照队列的思路来做了。让 nums1和 nums2 的元素按大小依次入队，最后结果就是所求。123456789101112131415161718192021/* method 3 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; vector&lt;int&gt; queue(m + n); int pos1 = 0, pos2 = 0, index = 0; while(pos1 &lt; m &amp;&amp; pos2 &lt; n) &#123; if(nums1[pos1] &lt; nums2[pos2]) &#123; queue[index] = nums1[pos1]; pos1++; &#125; else &#123; queue[index] = nums2[pos2]; pos2++; &#125; index++; &#125; while(pos1 &lt; m) queue[index++] = nums1[pos1++]; while(pos2 &lt; n) queue[index++] = nums2[pos2++]; nums1 = queue; &#125;&#125;; 上面的解法其实是双指针的用法，但是额外消耗了空间。之所以要消耗空间，是因为先选出小的元素，后面的元素如果不后移就会被覆盖了。那么，先选大的元素，就不用担心这个问题了。12345678910111213141516171819/* method 4 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int pos1 = m - 1, pos2 = n - 1, index = m + n - 1; while(pos1 &gt;= 0 &amp;&amp; pos2 &gt;= 0) &#123; if(nums1[pos1] &gt; nums2[pos2]) &#123; nums1[index] = nums1[pos1]; pos1--; &#125; else &#123; nums1[index] = nums2[pos2]; pos2--; &#125; index--; &#125; while(pos1 &gt;= 0) nums1[index--] = nums1[pos1--]; while(pos2 &gt;= 0) nums1[index--] = nums2[pos2--]; &#125;&#125;; Summary今天的两个题比较简单，但是第二个题的解法很多，特别是双指针的解法，很灵活。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天数据结构入门_day1]]></title>
    <url>%2F2022%2F04%2F05%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[再来试试数据结构入门，其实就是想做点树的题。 217. Contains DuplicateAnalysis这个题排序和哈希都可以做。 Code1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; ht; for(auto it: nums) &#123; if(ht.find(it) != ht.end()) return true; ht.insert(it); &#125; return false; &#125;&#125;; 排序的就不写了。 53. Maximum SubarrayAnalysis这个题是个很经典的题目，做法很多。 Codemethod 1第一个做法就是从动态规划的角度来思考。显然，边界就是数组的第一个元素，也即：$dp[0] = nums[0]$；针对数组的第二个元素，此时这个数可能与前一个序列构成和更大的序列，也可能构成和更小的序列（也即前一个序列和是负数，这个数正数），那么就有：$dp[1] = max(dp[0] + nums[1], nums[1])$。按照这样的思路就可以得到状态转移方程：$dp[i] = max(dp[i - 1] + nums[i], nums[i])$。12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; int maxsum = dp[0]; for(int i = 1; i &lt; nums.size(); i++) &#123; dp[i] = max(nums[i], nums[i] + dp[i - 1]); if(maxsum &lt; pre) maxsum = dp[i]; &#125; return maxsum; &#125;&#125;; 可以发现，每次计算的 $dp[i]$ 其实只与 $dp[i - 1]$ 和 $nums[i]$ 有关，那么就可以不用数组来完成了：123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = nums[0]; int maxsum = pre; for(int i = 1; i &lt; nums.size(); i++) &#123; pre = max(nums[i], nums[i] + pre); if(maxsum &lt; pre) maxsum = pre; &#125; return maxsum; &#125;&#125;; method 2其实这个题还可以从贪心的角度来思考，对于一个序列而言，要使其值增大，就必须加上一个正数。也就是说，遇到正数就加上，遇到负数就清 0，重新开始计算。123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int sum = 0, maxsum = INT32_MIN; for(int i = 0; i &lt; nums.size(); i++) &#123; sum += nums[i]; if(sum &gt; maxsum) maxsum = sum; if(sum &lt;= 0) sum = 0; &#125; return maxsum; &#125;&#125;; 虽然这个题可以用贪心的角度来思考，但是不如 dp 直接，然且很不容易想到。贪心总是没有固定的思考方法，要结合实际条件来思考。 method 3最后一种方法，就是分治（divede and conquer）了，分治的思路暂时不写了，先记住，分治是递归的去解决子问题。123456789101112131415161718192021222324/* method 3: divide and conquer */class Solution &#123;public: struct Status &#123; int lsum, rsum, msum, isum; &#125; Status pushup(Status l, Status r) &#123; int isum = l.isum + r.isum; int lsum = max(l.lsum, l.isum + r.lsum); int rsum = max(r.rsum, r.isum + l.rsum); int msum = max(max(l.msum, r.msum), l.rsum + r.lsum); return (Status) &#123;lsum, rsum, msum, isum&#125;; &#125; Status get(vector&lt;int&gt; &amp;a, int l, int r) &#123; if(l == r) return (Status)&#123;a[l], a[l], a[l], a[l]&#125;; int m = (l + r) &gt;&gt; 1; Status lsub = get(a, l, m); Status rsub = get(a, m + 1, r); return pushup(lsun, rsub); &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return get(nums, 0, nums.size() - 1).msum; &#125;&#125;; Summary第一道题比较简单，第二个题要复杂一点，不过也不是难到做不出来的那种。不过，分治法确实不是很好理解。仔细想一想，数据结构入门确实是数据结构简单，算法思想可不简单啊😂。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day14]]></title>
    <url>%2F2022%2F04%2F05%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day14%2F</url>
    <content type="text"><![CDATA[最后一天的位运算了。 190. Reverse BitsAnalysis这个题必须要用循环来做？ Codemethod 1这个题实际上是一个二进制数串逆置的问题，所以把每一位都提取出来就可以了。1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t ret = 0; for(int i = 0; i &lt; 32; i++) &#123; if(n &amp; 0x80000000) ret += pow(2, i); n &lt;&lt;= 1; &#125; return ret; &#125;&#125;; 因为最后得到的结果是个整数，所以直接算就行了。不过实际上，是没有必要用 pow 函数的。而且，也没有必要一定非得执行 32 次。所以，优化一下：1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t ret = 0; for(int i = 0; i &lt; 32 &amp;&amp; n &gt; 0; i++) &#123; ret |= (n &amp; 1) &lt;&lt; (31 - i); n &gt;&gt;= 1; &#125; return ret; &#125;&#125;; method 2看了题解才知道，这个题还可以用分治的思路来做。分治思路的核心在于不断交换奇偶数位，先依次交换相邻的 2 个数位，然后每 4 个进行交换，依次执行，最后 16 个数位进行交换，就得到了结果，这个过程有点类似归并排序。12345678910111213141516class Solution &#123;private: const uint32_t M1 = 0x55555555; const uint32_t M2 = 0x33333333; const uint32_t M3 = 0x0f0f0f0f; const uint32_t M4 = 0x00ff00ff;public: uint32_t reverseBits(uint32_t n) &#123; n = n &gt;&gt; 1 &amp; M1 | (n &amp; M1) &lt;&lt; 1; n = n &gt;&gt; 2 &amp; M2 | (n &amp; M2) &lt;&lt; 2; n = n &gt;&gt; 4 &amp; M3 | (n &amp; M3) &lt;&lt; 4; n = n &gt;&gt; 8 &amp; M4 | (n &amp; M4) &lt;&lt; 8; return n &gt;&gt; 16 | n &lt;&lt; 16; &#125;&#125;; 190. Reverse BitsAnalysis这个题首先想到的是借助 hash 来完成。 Codemethod 1虽然题目限定了线性时间复杂度与常数空间，但是先做了再说吧。用 hash 就会额外消耗 $O(n)$ 的空间，当然，这个题其实也可以用排序来做，这个就不写了。123456789101112131415161718/* method 1 */class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; ht; for(int i = 0; i &lt; nums.size(); i++) &#123; ht[nums[i]]++; &#125; int ret = 0; for(auto it: ht) &#123; if(it.second == 1) &#123; ret = it.first; break; &#125; &#125; return ret; &#125;&#125;; 既然出现位运算这里，肯定还有更优的解法。 method 2实际上这里要用到亦或（^）运算的性质，也即： $a \oplus a = 0$ $a \oplus 0 = a$ $a \oplus b \oplus a = a \oplus a \oplus b = 0 \oplus b = b$ 这样就可以直接遍历数组，全部元素异或运算，最后的结果就是那个只出现一次的数字。1234567891011/* method 2 */class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; for(auto i: nums) &#123; ret ^= i; &#125; return ret; &#125;&#125;; Summary这两天碰到的位运算相关的题目都是比较简单的题目，只要掌握好运算的性质和一些特殊的使用技巧就行了。如果在不知道这些技巧和性质的情况下来做这些题，可能很难想到从位运算的角度去解决，多半会用其他方法来解决，所以还是要熟悉一点。 尽管这 14 天的题目都是一些简单的题目，但是也涵盖了大部分算法思想：二分、双指针、递归、分治、动态规划、回溯、DFS、BFS等等，需要做更多的相关练习来巩固...不过最好是结合一定的数据结构，这样效果应该会更好。是的，现在就赶紧开始强化一下数据结构吧 :p。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Bit_Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day13]]></title>
    <url>%2F2022%2F04%2F04%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day13%2F</url>
    <content type="text"><![CDATA[最后两天的主题都是位运算，除了 C 可能还会用到这些，其他的生产环境还会用到这些东西嘛？ 231. Power of TwoAnalysis题目大意是判断一个数是否是 2 的 n 次方。 Codemethod 1首先想到的方法，肯定是直接拿循环来判断。但是要注意的是，因为 n 的类型是 int，为了避免计算过程种产生的溢出，就要使用 long long。当然也可以用位运算来代替 pow 函数判断，不过只要用了循环，感觉都大同小异。12345678910111213/* method 1 */class Solution &#123;public: bool isPowerOfTwo(int n) &#123; long long i = 0, tmp; while(true) &#123; tmp = pow(2, i); if(tmp == n) return true; else if(tmp &gt; n) return false; i++; &#125; &#125;&#125;; method 2仔细分析一下可以发现，2 的幂的二进制表示中只有一个 1 存在。假设 n 是 2 的幂，那么 n-1 就不是 2 的幂，且 n-1 的幂一定是 011...1，这种样子。此时就有 n &amp; (n-1) = 0。1234567/* method 2 */class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0 ? true : false; &#125;&#125;; 注意使用这种方法一定要注意运算符的优先级。 191. Number of 1 BitsAnalysis题目大意是找出一个二进制数中 1 的个数，这个个数也叫Hamming weight。 Codemethod 1毫无疑问，最先想到的做法永远是循环...1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n) &#123; if(n &amp; 1) cnt++; n &gt;&gt;= 1; &#125; return cnt; &#125;&#125;; 这段代码的运行时间取决于 n 这个数的二进制长度。 method 2题目提示能不能优化运行的次数，就上面的代码而言，其实已经是很快的运行速度了。不过，还可以继续减少运行的次数。这里要借用一下第一道题里的计算技巧，因为 n &amp; n-1 的结果是 n 这个数去掉最低位的 1 后的结果。所以利用这一点，要计算 1101 这样的数中 1 的个数，用这种方法就可以跳过中间的 0 了。123456789101112/* method 2 */class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n) &#123; n &amp;= (n - 1); cnt++; &#125; return cnt; &#125;&#125;; Summary位运算的使用技巧还有很多，这类运算技巧在执行某些算法的时候好像可以极大的提升执行的速度。原因无它，只是这样写更贴近底层的运算。当多个不同的位运算一起用的时候，由于优先级的存在，人脑确实有点难理解。而且，有大部分人读不懂...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Bit_Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day12]]></title>
    <url>%2F2022%2F04%2F03%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[今天的主题是动态规划（dp），之前就想琢磨一下这类问题了。不过，今天应该都是比较简单的 dp 问题。 70. Climbing StairsAnalysis这是个很经典的 dp 入门问题，每次跳台阶可以选择跳 1 阶或 2 阶，当前的选择会影响到下一跳的选择。显然，如果只用跳 1 阶，那么只有 1 种跳法；如果跳 2 阶，就有 2 种跳法，由此可得：$dp[1] = 1, dp[2] = 2$。此时，手动算一下跳 3 阶的情况，也即：1 1 1、1 2和2 1这 3 种情况，则$dp[3] = 3$，同理，$dp[4] = 5$。这样就可以得到递归公式（也叫状态转移方程）：$dp[i] = dp[i - 1] + dp[i - 2]$。想到这里会发现，这是个 fibonacci 数列问题。 Code1234567891011class Solution &#123;public: int climbStairs(int n) &#123; int dp[50]; dp[1] = 1, dp[2] = 2; for(int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 198. House RobberAnalysis这个题算是上面那个题的变式，从后往前算可能会稍微好理解一点？假设总共有 n 个数字，对于最后一个数字，$dp[n - 1] = nums[n - 1]$，$dp[n - 2] = nums[n - 2]$，倒数第 3 个数就是$dp[n - 3] = nums[n - 3] + dp[n - 3 + 2]$，但是倒数第四个数就不一样了。题目只是要求不能选择相邻的，没说不能隔 2 个选，所以$dp[n - 4] = nums[n - 4] + max(dp[n - 4 + 2], dp[n - 4 + 3])$，从而可以得到状态转移方程：$dp[i] = nums[i] + max(dp[i + 2], dp[i + 3])$。 Codeone dimension1234567891011121314151617class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105], size = nums.size(); if(size == 1) return nums[0]; dp[size - 1] = nums[size - 1], dp[size - 2] = nums[size - 2]; int Max = dp[size - 1] &gt; dp[size - 2] ? dp[size - 1] : dp[size - 2]; if(size == 2) return Max; dp[size - 3] = nums[size - 3] + dp[size - 1]; Max = Max &gt; dp[size - 3] ? Max : dp[size - 3]; for(int i = size - 4; i &gt;= 0; i--) &#123; dp[i] = nums[i] + max(dp[i + 2], dp[i + 3]); if(dp[i] &gt; Max) Max = dp[i]; &#125; return Max; &#125;&#125;; 当然，也可以从前往后算：1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 0) return 0; if(size == 1) return nums[0]; int dp[105]; dp[0] = nums[0], dp[1] = max(dp[0], nums[1]); for(int i = 2; i &lt; size; i++) &#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); &#125; return dp[size - 1]; &#125;&#125;; two dimension这个题其实也可以从 2 维 dp 的角度来考虑。dp[i][0]表示第 i 家偷，dp[i][1]表示第 i 家不偷，每一次偷得到的值是相邻一家未偷与当前这一家的数字之和，这是题目要求的相邻。123456789101112class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105][2], size = nums.size(); dp[0][0] = nums[0], dp[0][1] = 0; for(int i = 1; i &lt; size; i++) &#123; dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]); &#125; return max(dp[size - 1][0], dp[size - 1][1]); &#125;&#125;; 感觉二维 dp 好像还难理解一点？ 120. TriangleAnalysis这个题也是经典的 dp 求解数塔问题。采用自底向上的思路来进行 dp，设这个数塔有 n 层，那么$dp[n][j] = triangle[n][j]$，此时，$dp[n][j]$就是这个问题的边界，也就是最底层的那一排数。继续向上一层，$dp[n - 1][j]$就是$min(dp[n][j], dp[n][j + 1]) + triangle[n - 1][j]$，那么状态转移方程就是$dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1])$。 Codebottom-up按照上面的思路，可以得到下面的代码：1234567891011121314/* bottom-up */class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;vector&lt;int&gt;&gt; dp = triangle; int size = triangle.size(); for(int i = size - 2; i &gt;= 0; i--) &#123; for(int j = 0; j &lt;= i; j++) &#123; dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]; &#125; &#125; return dp[0][0]; &#125;&#125;; top-down在按照自顶向下的思路做一下：显然自顶向下时，$dp[0][0] = triangle[0][0]$就是边界第二行的第一个数只能从其右上的数往下，所以 $dp[i][0] = dp[i - 1][0] + triangle[i][0]$；同理，第二行的最后一个数就是 $dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]$。那么中间的数，就是：$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]$，这就是这个题的状态转移方程。 12345678910111213141516/* top-down */class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;vector&lt;int&gt;&gt; dp = triangle; int size = triangle.size(); for(int i = 1; i &lt; size; i++) &#123; dp[i][0] = dp[i - 1][0] + triangle[i][0]; for(int j = 1; j &lt; i; j++) &#123; dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]; &#125; dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]; &#125; return *min_element(dp[size - 1].begin(), dp[size - 1].end()); &#125;&#125;; Summary今天的三道 dp 题，感觉都不是难题，应该都是十分经典的入门题，做的挺有意思，特别是推导状态转移方程这里。稍微细想一下，这种题好像理解了题目意思，就知道应该是 dp 题了？另外，从这 3 个题来讲，dp 题的做法应该很多，不过都大同小异，首先要找到边界，明确 dp 数组下标的含义，然后想办法推导出状态转移方程就差不多了。多说无益，需要再来点题目练练手。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic_Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day11]]></title>
    <url>%2F2022%2F04%2F02%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[今天是 3 道中等题，有点难度？？？今天的主题依然是递归跟回溯。 77. CombinationsAnalysis这个题看着挺简单的，其实不是个简单的题目...最直观的思路，应该是先挑出 1，然后从剩余大于 1 的数中挑选出 k - 1 个数，依次挑选即可。按照这种思路，写了一下，越写感觉越不对劲。只凭单纯的循环，可能并不能完美的表达出这种过程，还需要一点思考，还是先按照常规的思路来吧。 Codebacktracking这个题其实是个经典的回溯法应用题，对于每一个数字只有选与不选两种可能，当选出的数的个数等于 k 时，就找到解，可以返回了，注意大于 n 的数字不能选。123456789101112131415161718192021/* dfs */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; if(cur == n + 1) return; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; 但是为什么总感觉递归用的这么别扭呢？接下来，可以修改下代码，“剪掉”某些情况，比如当 tmp 的大小与剩余数字之和小于 k 时，此时不论怎样都是无解的，这样就没有必要继续递归下去了，这样就可以写成：12345678910111213141516171819202122/* dfs */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() + (n - cur + 1) &lt; k) return; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; if(cur == n + 1) return; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; 按照 Leetcode 给的测试样例，速度的提升很明显。实际上，当cur == n + 1时，tmp 的大小与剩余数字之和一定是小于等于 k 的，这样就会被第一个或第二个 if 返回了，所以，最终的代码可以写成：123456789101112131415161718192021/* dfs: tmp.size + (n - cur + 1) &lt; k */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() + (n - cur + 1) &lt; k) return; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; iteration这里不得不在提到一下使用循环（迭代）的方法，代码如下：12345678910111213141516171819/* iteration */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int i = 0; vector&lt;int&gt; tmp(k, 0); while(i &gt;= 0) &#123; tmp[i]++; if(tmp[i] &gt; n) i--; else if(i == k - 1) ret.push_back(tmp); else &#123; i++; tmp[i] = tmp[i - 1]; &#125; &#125; return ret; &#125;&#125;; 这个解法其实并没有单纯的利用循环，反而有一点动态规划的影子在里面，又有一点回溯的影子在里面。 46. PermutationsAnalysis看到这个题，直接就想到了 next_permutation 这个函数，果断直接用。 Codenext_permutation()123456789101112/* next_permutation */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(nums.begin(), nums.end()); do&#123; ret.push_back(nums); &#125; while(next_permutation(nums.begin(), nums.end())); return ret; &#125;&#125;; 这里有个问题，一开始没有对 nums 进行排序，提交是无法通过的。百度了一下，发现 next_permutation 在生成排列的时候是按照当前顺序生成下一个排列，直到数字序列是降序为止。也就是说，如果数字序列一开始不是严格的升序序列，那么就可能会漏掉可能存在的排列组合，所以要先排序，不过题目也不是每个样例都是无序序列，当然了，直接排序还无脑一点。 backtracking1234567891011121314151617181920/* dfs */class Solution &#123;public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, int first, int len) &#123; if(first == len) &#123; ret.push_back(nums); return; &#125; for(int i = first; i &lt; len; i++) &#123; swap(nums[i], nums[first]); dfs(ret, nums, first + 1, len); swap(nums[i], nums[first]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(ret, nums, 0, nums.size()); return ret; &#125;&#125;; 虽然是回溯的入门题，但感觉不是很好想啊... 784. Letter Case PermutationAnalysis这个题算是上面这个题的变式，复杂度差不多。 Code直接按照上面的思路来做，注意对每一个字母，需要转换大小写后再选择，然后还需要还原（回溯的思想），但数字就不用了。12345678910111213141516171819202122232425class Solution &#123;public: string tmp; void dfs(vector&lt;string&gt;&amp; ret, string s, int first, int length) &#123; if(first == length) &#123; ret.push_back(s); return; &#125; if(isupper(s[first])) &#123; s[first] += 32; dfs(ret, s, first + 1, length); s[first] -= 32; &#125; else if(islower(s[first])) &#123; s[frist] -= 32; dfs(ret, s, first + 1, length); s[first] += 32; &#125; dfs(ret, s, first + 1, length); &#125; vector&lt;string&gt; letterCasePermutation(string s) &#123; vector&lt;string&gt; ret; if(s.length() &gt; 0) dfs(ret, s, 0, s.length()); return ret; &#125;&#125;; Summary今天是 3 道考察回溯算法的题，难度不是很大，但是其中蕴含的思想要好好体会。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursion&amp;Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day10]]></title>
    <url>%2F2022%2F04%2F01%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[今天的主题是递归跟回溯，正好强化一下对递归的理解。 21. Merge Two Sorted ListsAnalysis这个题放在递归这里怎么感觉不是很合理呢？看到这个题，一般都不会想到用递归来做吧？ Codemethod 1如果不用递归，就只能遍历链表了。按照构造一个新链表的思路，先设置一个头结点，然后分别将 list1 和 list2 中符合条件的结点依次串到头结点后面即可，最后别忘了释放头结点。12345678910111213141516171819202122232425262728/* method 1: no recursion */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; if(list1 == nullptr) return list2; if(list2 == nullptr) return list1; if(list1 == nullptr &amp;&amp; list2 == nullptr) return nullptr; ListNode* head = new ListNode(0); ListNode* p = head; while(list1 &amp;&amp; list2) &#123; if(list1-&gt;val &lt; list2-&gt;val) &#123; p-&gt;next = list1; p = list1; list1 = list1-&gt;next; &#125; else &#123; p-&gt;next = list2; p = list2; list2 = list2-&gt;next; &#125; &#125; if(list1) p-&gt;next = list1; if(list2) p-&gt;next = list2; p = head; p = p-&gt;next; delete(head); return p; &#125;&#125;; method 2为什么会觉得这递归这么难想呢？😂1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; if(list1 == nullptr) return list2; else if(list2 == nullptr) return list1; else if(list1-&gt;val &lt; list2-&gt;val) &#123; list1-&gt;next = mergeTwoLists(list1-&gt;next, list2); return list1; &#125; else &#123; list2-&gt;next = mergeTwoLists(list1, list2-&gt;next); return list2; &#125; &#125;&#125;; 206. Reverse Linked ListAnalysis这个题一看就想用栈来做...递归是不可能递归的，这辈子都不可能递归的... Codemethod 1用栈做会稍微麻烦一点，因为要重新构造链表。1234567891011121314151617181920212223/* method 1: use stack */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; stack&lt;ListNode*&gt; st; ListNode* p = head; while(p) &#123; st.push(p); p = p-&gt;next; &#125; ListNode* t = st.top(); p = t; st.pop(); while(!st.empty()) &#123; p-&gt;next = st.top(); st.pop(); p = p-&gt;next; &#125; p-&gt;next = nullptr; return t; &#125;&#125;; method 2不用栈做的话，需要用到 3 个指针。123456789101112131415/* method 2: no stack */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *pre = nullptr, *cur = head, *next; while(cur) &#123; next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125;; method 312345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* newhead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return newhead; &#125;&#125;; 递归真香。注意上面这段代码，newhead 实际上一直都指向原链表的最后一个结点。 method 4123456789101112131415161718class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125;&#125;; 实际上，这道题还可以用头插法建立一个新链表，这样建立的链表本身就是逆置的。 Summary用 2 道链表的题目来巩固递归，感觉不太合理，不过好在能整理一下链表的知识。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursion&amp;Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day9]]></title>
    <url>%2F2022%2F03%2F31%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[今天好像还真的给图？ 542. 01 MatrixAnalysis看到这个题，很容易想到的思路就是 bfs，每个点逐一使用 bfs 然后返回离这个点最近的 0 的层数就好了。 Codebfs尝试用 bfs 写了一下，结果超时了，应该是因为每个点逐一使用 bfs，有很多的重复操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445/* bfs, these codes will cause time limited exceeded. */class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int x, int y) &#123; if(x &lt; 0 || x &gt;= mat.size() || y &lt; 0 || y &gt;= mat[0].size()) return false; return true; &#125; int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int sr, int sc) &#123; set&lt;pair&lt;int, int&gt;&gt; ht; int level = 0; if(mat[sr][sc] == 0) return level; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); ht.insert(make_pair(sr, sc)); while(!q.empty()) &#123; int size = q.size(); level++; for(int i = 0; i &lt; size; i++) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int j = 0; j &lt; 4; j++) &#123; int newx = x + X[j], newy = y + Y[j]; if(isvalid(mat, newx, newy) &amp;&amp; ht.find(make_pair(newx, newy)) == ht.end()) &#123; if(mat[newx][newy] == 0) return level; q.emplace(newx, newy); ht.insert(make_pair(newx, newy)); &#125; &#125; &#125; &#125; return -1; &#125; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; vector&lt;vector&lt;int&gt;&gt; ret = mat; int m = mat.size(), n = mat[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[i][j] = bfs(mat, i, j); &#125; &#125; return ret; &#125;&#125;; 回头想想，上面代码在做什么事情？将每一个点到 0 的距离求出来，换而言之，就是在求单源最短路径。按照这样的思路，单源超时了，不妨在试试多源的思路。假设所有的 0 到一个超级 0 点的距离是 1，这样矩阵中非 0 点的到 0 点的距离就是其到达超级 0 点的距离减一。这样在 bfs 开始的第一步，将所有的 0 点入队，这样就可以找到所有与 0 点距离为 1 的非 0 点，然后再根据这些点找到距离为 2 的非 0 点，依次执行就可以得到最终的结果了。123456789101112131415161718192021222324252627282930313233/* bfs: version 2 */class Solution &#123;private: static constexpr int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n)); vector&lt;vector&lt;int&gt;&gt; inq(m, vector&lt;int&gt;(n)); queue&lt;pair&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(mat[i][j] == 0) &#123; q.emplace(i, j); inq[i][j] = 1; &#125; &#125; &#125; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dirs[d][0], newy = y + dirs[d][1]; if(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; !inq[newx][newy]) &#123; dist[newx][newy] = dist[x][y] + 1; q.emplace(newx, newy); inq[newx][newy] = 1; &#125; &#125; &#125; return dist; &#125;&#125;; 按照多源最短路的思路就可以很好的解决这道题了，inq 这个数组是用来标记是否入过队。实际上这个题，还可以从 dp 的角度思考，等做了 dp 的简单题后再回头来看。 994. Rotting OrangesAnalysis这个题跟上面的题是一样的思路，所以偷一下懒，直接用上面写好的代码。不过，有些地方要改成满足这道题的条件。首先，按照这个题的过程，只需要访问为 1 或者 2 的结点，为 0 的结点不需要访问。再者，由于一开始需要将所有烂橘子入队，此时可以同时算出好橘子的总数 cnt，这样在腐烂的过程中，可以依次减去腐烂的橘子个数。bfs 结束后，就可以用 cnt 来判断是否所有的橘子都腐烂了，这样就不用再重新遍历 grid 与 dist 是否全部橘子都腐烂了。 Code12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;private: static constexpr int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;public: int dist[10][10]; int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); memset(dist, -1, sizeof(dist)); vector&lt;vector&lt;int&gt;&gt; inq(m, vector&lt;int&gt;(n)); queue&lt;pair&lt;int, int&gt;&gt; q; int cnt = 0, ans = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == 2) &#123; q.emplace(i, j); dist[i][j] = 0; inq[i][j] = 1; &#125; else if(grid[i][j] == 1) cnt++; &#125; &#125; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dirs[d][0], newy = y + dirs[d][1]; if(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; !inq[newx][newy] &amp;&amp; grid[newx][newy]) &#123; dist[newx][newy] = dist[x][y] + 1; q.emplace(newx, newy); inq[newx][newy] = 1; if(grid[newx][newy] == 1) &#123; cnt--; ans = dist[newx][newy]; if(cnt == 0) break; &#125; &#125; &#125; &#125; return cnt ? -1 : ans; &#125;&#125;; Summary今天做的两道题本质上是最短路的问题，这类问题的难点在于理解题目的条件，只要能理解题目，就是一道简单题，但是代码量一般都比较长。所以，还是需要多做才能熟练。不得不再说一句，不了解树和图的知识，做这种题的效果就不是很好...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day8]]></title>
    <url>%2F2022%2F03%2F30%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[今天的主题还是搜索~冲，冲，冲！ 617. Merge Two Binary TreesAnalysis果然，简单题都很直接，不会做完全就是基础不够扎实... Codedfs123456789101112/* dfs */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if(root1 == nullptr) return root2; if(root2 == nullptr) return root1; TreeNode* merged_node = new TreeNode(root1-&gt;val + root2-&gt;val); merged_node-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); merged_node-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); return merged_node; &#125;&#125;; 用 dfs 写是真的简单。 bfs12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* bfs */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if(root1 == nullptr) return root2; if(root2 == nullptr) return root1; TreeNode* merged_node = new TreeNode(root1-&gt;val + root2-&gt;val); queue&lt;TreeNode*&gt; q, q1, q2; q.push(merged_node); q1.push(root1); q2.push(root2); while(!q1.empty() &amp;&amp; !q2.empty()) &#123; auto node = q.front(), node1 = q1.front(), node2 = q2.front(); q.pop(), q1.pop(), q2.pop(); auto left1 = node1-&gt;left, left2 = node2-&gt;left; auto right1 = node1-&gt;right, right2 = node2-&gt;right; if(left1 != nullptr || left2 != nullptr) &#123; if(left1 != nullptr &amp;&amp; left2 != nullptr) &#123; auto left = new TreeNode(left1-&gt;val + left2-&gt;val); node-&gt;left = left; q.push(left); q1.push(left1); q2.push(left2); &#125; else if(left1 != nullptr) &#123; node-&gt;left = left1; &#125; else if(left2 != nullptr) &#123; node-&gt;left = left2; &#125; &#125; if(right1 != nullptr || right2 != nullptr) &#123; if(right1 != nullptr &amp;&amp; right2 != nullptr) &#123; auto right = new TreeNode(right1-&gt;val + right2-&gt;val); node-&gt;right = right; q.push(right); q1.push(right1); q2.push(right2); &#125; else if(right1 != nullptr) &#123; node-&gt;right = right1; &#125; else if(right2 != nullptr) &#123; node-&gt;right = right2; &#125; &#125; &#125; return merged_node; &#125;&#125;; 用 bfs 写真的麻烦了很多，而且就代码的执行效率和消耗空间而言，也不太优秀。很久没有写跟树相关的代码了，反而不太会了。 116. Populating Next Right Pointers in Each NodeAnalysis又是跟树相关的题目，因为没有复习树的相关知识点，感觉练习的效果不是很好。扯远了，回到这道题。读完题目，这个题一看就想到用层序遍历（bfs），但是需要解决的问题是如何判断那些结点是在同一层。应该可以从结点个数下手，因为题目已经限定了是完美二叉树。 Codelevel order123456789101112131415161718192021/* level order */class Solution &#123;public: Node* connect(Node* root) &#123; if(root == nullptr) return nullptr; queue&lt;Node*&gt; q; int cnt = 1; q.push(root); while(!q.empty()) &#123; int size = q.size(); for(int i = 0; i &lt; size; i++) &#123; Node* node = q.front(); q.pop(); if(i &lt; size - 1) node-&gt;next = q.front(); if(node-&gt;left != nullptr) q.push(node-&gt;left); if(node-&gt;right != nullptr) q.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; 好吧，真是生疏了，并不用判断是不是在一层，因为层序遍历就是一层一层遍历的，看来是完全忘记树的层序遍历了😂。不过，虽然可以用层序遍历解决这个问题，但是题目要求使用常数个存储空间，也就是空间复杂度得是$O(1)$，那只能换一种方法来做了。 next pointer仔细想一想，题目要做的事情实际上就是将树的每一层结点串起来形成一个链表，这样要做的事情就是找到指定结点的地址并交给对应的 next。当位于第 N 层时，可以很容易的找到第 N + 1 层的结点，因为父节点可以很容易找到子结点。这时，就存在 2 种情况： 子结点的父节点相同，这样左子结点的 next 就有：leftchild-&gt;next = parent-&gt;right。 子结点的父节点不同，也就是右子结点与另一颗父节点的左子结点相连，也就有：rightchild-&gt;next = parent-&gt;next-&gt;left。 有了这个思路后还需要考虑一下根节点跟每一层的最后一个结点。根节点直接修改 next 就可以了，但是如何知道是最后一个结点呢？实际上在第 N 层时，这一层的链表已经在第 N - 1 层构造好了，也就是说，直接遍历即可，到末尾自然就是 NULL 了。另外，将根结点当作第 0 层，可能会好理解一些。123456789101112131415161718/* use next pointer */class Solution &#123;public: Node* connect(Node* root) &#123; if(root == nullptr) return nullptr; Node* leftmost = root; while(leftmost-&gt;left != nullptr) &#123; Node* head = leftmost; while(head != nullptr) &#123; head-&gt;left-&gt;next = head-&gt;right; if(head-&gt;next != nullptr) head-&gt;right-&gt;next = head-&gt;next-&gt;left; head = head-&gt;next; &#125; leftmost = leftmost-&gt;left; &#125; return root; &#125;&#125;; Summary看着今天的主题还是搜索以为还是简单的纯搜索问题呢，没想到直接跟树联系到一起了...嗯，明天不会直接就上图了吧？这两道题也是很基础常规的与树相关的题目，没做出来，真该反省一下了。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day7]]></title>
    <url>%2F2022%2F03%2F29%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[滑动窗口还没练够啊，就到 DFS 了...14 天显然不够用。废话少说，一道简单题，一道中等题。 733. Flood FillAnalysis这个题是个很明显的搜索题，思考了一下 dfs 的做法，没想出来...然后就从 bfs 的角度来做，做出来了，就是代码写的比较乱... Codebfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isvisited[55][55] = &#123;false&#125;; int X[4] = &#123;-1, 1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; struct Node &#123; int x, y; &#125; node; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int m, int n, int value) &#123; if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) return false; if(isvisited[x][y]) return false; if(image[x][y] != value) return false; return true; &#125; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int m = image.size(), n = image[0].size(), value = image[sr][sc]; node.x = sr, node.y = sc; queue&lt;Node&gt; q; q.push(node); isvisited[node.x][node.y] = true; while(!q.empty()) &#123; Node tmp = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int x = tmp.x + X[i]; int y = tmp.y + Y[i]; if(isvalid(image, x, y, m, n, value)) &#123; node.x = x; node.y = y; isvisited[x][y] = true; image[x][y] = newColor; q.push(node); &#125; &#125; &#125; image[sr][sc] = newColor; return image; &#125;&#125;; 好吧，来简化一下代码：123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; if(newColor == image[sr][sc]) return image; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int m = image.size(), n = image[0].size(), value = image[sr][sc]; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); image[sr][sc] = newColor; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &gt;= 0 &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; n &amp;&amp; image[newX][newY] == value) &#123; q.emplace(newX, newY); image[newX][newY] = newColor; &#125; &#125; &#125; return image; &#125;&#125;; 需要注意的是，上面的这段 bfs 代码并没有对点是否入队进行判断，所以当 newColor 与 image[sr][sc] 相等的时候，会陷入死循环。但是按照这个题目的条件，如果二者相等了，就可以直接返回了。为什么能直接返回？因为当源点上下左右四个相邻点的值与源点值相等时，那么也一定与 newColor 相等了。 dfs为什么总觉得 dfs 的递归很怪呢？123456789101112131415161718192021class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123; if(image[x][y] == color) &#123; image[x][y] = newColor; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &gt;= 0 &amp;&amp; newX &lt; image.size() &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; image[0].size()) &#123; dfs(image, newX, newY, color, newColor); &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int curColor = image[sr][sc]; if(curColor != newColor) dfs(image, sr, sc, curColor, newColor); return image; &#125;&#125;; 695. 岛屿的最大面积Analysis这个题实质上就是在找由相邻的 1 组成的最大块...换句话讲，这个题其实也就是在找图的极大连通子图，并返回最大结点数。 Codebfs感觉对 bfs 的熟悉程度要深一点，dfs 总是摸不清楚递归边界，不知道把递归边界写在哪里，bfs 不一会就写出来了。1234567891011121314151617181920212223242526272829303132333435363738/* bfs */class Solution &#123;public: bool inq[55][55] = &#123;false&#125;; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int sr, int sc, int m, int n) &#123; int count = 0; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); inq[x][y] = true; count++; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &lt; m &amp;&amp; newX &gt;= 0 &amp;&amp; newY &lt; n &amp;&amp; newY &gt;= 0 &amp;&amp; grid[newX][newY] &amp;&amp; !inq[newX][newY]) &#123; inq[newX][newY] = true; q.emplace(newX, newY); &#125; &#125; &#125; return count; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(), ans = 0; for(int x = 0; x &lt; m; x++) &#123; for(int y = 0; y &lt; n; y++) &#123; if(grid[x][y] &amp;&amp; !inq[x][y]) &#123; int tmp = bfs(grid, x, y, m, n); ans = tmp &gt; ans ? tmp : ans; &#125; &#125; &#125; return ans; &#125;&#125;; bfs 内的 if 的条件，一定要先判断是否越界，不然会 rumtime error（也就是越界），这其实是个不算 bug 的 bug😂，不过还是让我琢磨了快 20 分钟。 dfs还是写个判断点是否符合条件的函数吧，这样看着条理会清晰一点。12345678910111213141516171819202122232425262728293031323334/* dfs */class Solution &#123;public: bool inq[55][55] = &#123;false&#125;; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if(x &lt; 0 || x &gt;= grid.size() || y &lt; 0 || y &gt;= grid[0].size()) return false; if(inq[x][y] || grid[x][y] == 0) return false; return true; &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if(!isvalid(grid, x, y)) return 0; inq[x][y] = true; int count = 1; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; count += dfs(grid, newX, newY); &#125; return count; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(), ans = 0; for(int x = 0; x &lt; m; x++) &#123; for(int y = 0; y &lt; n; y++) &#123; if(grid[x][y] &amp;&amp; !inq[x][y]) &#123; int tmp = dfs(grid, x, y); ans = tmp &gt; ans ? tmp : ans; &#125; &#125; &#125; return ans; &#125;&#125;; 用不好 dfs 的原因，应该是对递归边界的理解很迷。 Summary今天的两道题应该算是很常规的 dfs、bfs 入门题型了，感觉这部分内容已经跟图沾上边了。尽管代码一般都比较长，但是感觉还是滑动窗口、DP 之类的题目更难理解一点，这些反而比较易于理解，也可能是还没碰到难题吧。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门-day6]]></title>
    <url>%2F2022%2F03%2F28%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[今天是滑动窗口了，终于不是双指针了，感觉双指针的题还没做够😂。两道中等题。 3. Longest Substring Without Repeating CharactersAnalysis寻找无重复字符的最长子串，这个问题好像可以用 KMP 来解决，但是我早就忘记了 KMP 怎么用了。然而，遗憾的是滑动窗口的题我也没做过，所以就只能暴力解决了。没想到，竟然还可以过。 Codemethod 1比较尴尬的是，一开始老是想用滑动窗口来做，结果提交了 3 次没过，直接删了重新写暴力解法，一次就过了。1234567891011121314151617/* method 1: violent solutions */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int len = s.length(), i, j, ret = 0; for(i = 0; i &lt; len; i++) &#123; string tmp; tmp += s[i]; for(j = i + 1; j &lt; len; j++) &#123; if(tmp.find(s[j]) == string::npos) tmp += s[j]; else break; &#125; if(tmp.length() &gt; ret) ret = tmp.length(); &#125; return ret; &#125;&#125;; method 2学习一下滑动窗口的解法。1234567891011121314151617181920/* method 2: use a set simulate hashtable to judge whether the char has appeared or not. */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; ht; int n = s.length(); int rk = -1, ans = 0; for(int i = 0; i &lt; n; i++) &#123; if(i != 0) &#123; ht.erase(s[i - 1]); &#125; while(rk + 1 &lt; n &amp;&amp; ht.find(s[rk + 1]) == ht.end()) &#123; ht.insert(s[rk + 1]); rk++; &#125; ans = max(ans, rk - i + 1); &#125; return ans; &#125;&#125;; 滑动窗口好像必须要有一个 hash 表来判断是否出现重复的字符？不知道是不是原来研究过 KMP 的缘故，感觉挺容易理解的，就是自己写不出来😂。 method 3好吧，并不是一定需要 hash 表来判断是否出现重复的字符，感觉下面这段代码才是原汁原味的滑动窗口...1234567891011121314151617181920212223/* method 3: silding window */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int len = s.length(); int start, end, index, ans, l; start = end = ans = l = 0; while(end &lt; len) &#123; char tmp = s[end]; for(index = start; index &lt; end; index++) &#123; if(tmp == s[index]) &#123; start = index + 1; l = end - start; break; &#125; &#125; end++; l++; ans = max(ans, l); &#125; return ans; &#125;&#125;; 仔细分析一下，好像跟上面的暴力解法是一样的？实际上应该是不一样的，因为上面写的暴力解法里面有很多拷贝字符、判断字符是否重复的操作，但这里并没有。也就是说，这段代码在判断字符是否重复的过程中，其实就已经完成了对字符的拷贝？ 567. Permutation in StringAnalysis虽然理解了题意，但是好像没有思路🙃，陷在如何求字符串全排的泥淖中了。 Codemethod 1要用滑动窗口来解题，有一个信息必须要得到，那就是：当两个字符串的每个字符的个数都相等时，一个字符串才是另一个字符串的排列。这样，问题就转化成了判断 s2 是否有子串与 s1 的字符个数相等，这样就可以用两个数组来统计字符个数了。PS：没想到 vector 可以直接进行比较...1234567891011121314151617181920/* method 1: sliding window */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt1(26), cnt2(26); for(int i = 0; i &lt; n; i++) &#123; cnt1[s1[i] - 'a']++; cnt2[s2[i] - 'a']++; &#125; if(cnt1 == cnt2) return true; for(int i = n; i &lt; m; i++) &#123; ++cnt2[s2[i] - 'a']; --cnt2[s2[i - n] - 'a']; if(cnt1 == cnt2) return true; &#125; return false; &#125;&#125;; method 2实际上，这个题也可以只用一个 vector，但是需要一个变量 diff 来保存当前子串是否与 s1 存在字符个数不相等的字符个数。不过，一时半会，好像还是看不明白。123456789101112131415161718192021222324252627282930/* method 2: just use one vector */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; n; i++) &#123; --cnt[s1[i] - 'a']; ++cnt[s2[i] - 'a']; &#125; int diff = 0; for(int c: cnt) &#123; if(c != 0) diff++; &#125; if(diff == 0) return true; for(int i = n; i &lt; m; i++) &#123; int x = s2[i] - 'a', y = s2[i - n] - 'a'; if(x == y) continue; if(cnt[x] == 0) diff++; cnt[x]++; if(cnt[x] == 0) diff--; if(cnt[y] == 0) diff++; cnt[y]--; if(cnt[y] == 0) diff--; if(diff == 0) return true; &#125; return false; &#125;&#125;; method 3没想到这题还能用双指针做，好吧，更加有点看不明白了。1234567891011121314151617181920212223/* method 3: use tow pointers */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; n; i++) &#123; cnt[s1[i] - 'a']--; &#125; int left = 0; for(int right = 0; right &lt; m; right++) &#123; int x = s2[right] - 'a'; cnt[x]++; while(cnt[x] &gt; 0) &#123; cnt[s2[left] - 'a']--; left++; &#125; if(right - left + 1 == n) return true; &#125; return false; &#125;&#125;; Summary今天的两道题稍微复杂了一点，不是那么好理解，需要多做几次。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day5]]></title>
    <url>%2F2022%2F03%2F27%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[还是 two pointers 啊。继续，继续。 876. Middle of the Linked ListAnalysis找链表的中间结点，比较常规的一道题。 Codemethod 1单指针需要遍历两次链表，略麻烦。123456789101112131415class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *tmp = head; int cnt = 0; while(tmp) &#123; cnt++; tmp = tmp-&gt;next; &#125; tmp = head; for(int i = 0; i &lt; cnt / 2; i++) tmp = tmp-&gt;next; return tmp; &#125;&#125;; method 2双指针只用遍历一次链表，但要注意判空的条件。123456789101112class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *slow = head, *fast = head; while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125;&#125;; method 3没想到官方提供了一种数组的题解，不过与其说是数组，不如说是队列。1234567891011class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; arr = &#123;head&#125;; while(arr.back()-&gt;next != nullptr) &#123; arr.push_back(arr.back()-&gt;next); &#125; return arr[arr.size() / 2]; &#125;&#125;; 19. Remove Nth Node From End of ListAnalysis删除链表的的倒数第 n 个结点，这也是个很常规的题目。 Codemethod 1假设总结点数是 N，只用一个指针时，删除倒数第 n 个结点，就是删除正数第 N - n 个结点，所以要计算一下链表的长度，另外还需要考虑一下删除的是不是第一个结点了。12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode* tmp = head; int cnt = 0; while(tmp != nullptr) &#123; cnt++; tmp = tmp-&gt;next; &#125; cnt -= n; tmp = head; ListNode* t; if(cnt == 0) &#123; t = head-&gt;next; head = t-&gt;next; &#125; else &#123; for(int i = 0; i &lt; cnt - 1; i++) tmp = tmp-&gt;next; t = tmp-&gt;next; tmp-&gt;next = t-&gt;next; &#125; delete(t); return head; &#125;&#125;; method 2用双指针的解法，与单指针类似。但是如果在一开始加一个头结点话，删除结点时，就不用太考虑是否是第一个结点了。这种在表头加的结点叫做哑结点。1234567891011121314151617181920class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode *dummy = new ListNode(0, head); ListNode *first = head; ListNode *second = dummy; for(int i = 0; i &lt; n; i++) first = first-&gt;next; while(first != nullptr) &#123; first = first-&gt;next; second = second-&gt;next; &#125; first = second-&gt;next; second-&gt;next = first-&gt;next; delete(first); first = dummy-&gt;next; delete(dummy); return first; &#125;&#125;; method 3用栈也可以做。1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode *dummy = new ListNode(0, head); stack&lt;ListNode*&gt; st; ListNode *tmp = dummy; while(tmp != nullptr) &#123; st.push(tmp); tmp = tmp-&gt;next; &#125; for(int i = 0; i &lt; n; i++) &#123; st.pop(); &#125; ListNode *pre = st.top(); tmp = pre-&gt;next; pre-&gt;next = tmp-&gt;next; delete(tmp); pre = dummy-&gt;next; delete(dummy); return pre; &#125;&#125;; method 4看评论，发现竟然还能用递归做😂，递归边界是遍历到链表表尾，判定条件是访问的结点数等于要删除的结点位置。不得不说，用递归来解决这个问题很巧。1234567891011class Solution &#123;public: int cur = 0; ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; head-&gt;next = removeNthFromEnd(head-&gt;next, n); cur++; if(n == cur) return head-&gt;next; return head; &#125;&#125;; Summary今天是两个很常规的题目，不算难题，自己想也比较容易解决，就是可能想不到多种方法来解决这些问题。还有一个很奇怪的地方，按理说，即便加了哑结点，在不改变 head 的情况下，直接返回 head 应该是不会错误的。但是，address sanitizer 会报错，是有潜在的内存错误吗？🤔]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day4]]></title>
    <url>%2F2022%2F03%2F26%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[为什么第四天的主题还是 two pointers，有点腻了。腻了也还是要肝😐 344. Reverse StringAnalysis这个题可太常见了。 Codemethod 11234567891011/* method 1: use a array to copy */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; vector&lt;char&gt; ret; for(int i = s.size() - 1; i &gt;= 0; i--) &#123; ret.push_back(s[i]); &#125; s = ret; &#125;&#125;; method 212345678910111213141516171819202122/* method 2: just exchange the elements */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int size = s.size(); for(int i = 0; i &lt; size / 2; i++) &#123; char tmp = s[size - i - 1]; s[size - i - 1] = s[i]; s[i] = tmp; &#125; &#125;&#125;;/* also can write like this */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int left = 0, right = s.size() - 1; while(left &lt; right) &#123; swap(s[left++], s[right--]); &#125; &#125;&#125;; 557. Reverse Words in a String IIIAnalysis这个题稍微复杂一点，要将每个单词反转，但不能改变单词的绝对位置。反转单词的任务就交给上个题得到的 reverse 函数了，剩下要解决的问题就是如何找到单词了。不过，与其说是找单词，不如说是找空格，只要找到第一个不是空格的字符，然后在找到下一个空格字符，那么这中间的内容就是单词了。 Codereverse 函数就不写了，直接吃现成的。1234567891011121314151617class Solution &#123;public: string reverseWords(string s) &#123; int len = s.length(); for(int i = 0; i &lt; len; i++) &#123; if(s[i] != ' ') &#123; int j; for(j = i + 1; j &lt; len; j++) &#123; if(s[j] == ' ') break; &#125; reverse(s.begin() + i, s.begin() + j); i = j; &#125; &#125; return s; &#125;&#125;; Summary今天给的是两道简单题，都比较简单。第二个题目稍微难一点点，而且第一个题得到的东西可以直接在第二个题目里面用到，这种安排很不错。如果直接做第二个题，说不定会想到其他地方去。PS：第二个题，用栈也能做。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_2022_春_乙级真题试水]]></title>
    <url>%2F2022%2F03%2F25%2FPAT-2022-%E6%98%A5-%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E8%AF%95%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[买了套 2022 春季的 PAT 乙级真题做着玩。 本来抱着做着玩的想法，结果被教育了。满分 100 分，结果只拿了 72 分，尴尬。乙级题库是上个星期做完了？反正是过去有一段时间了，最近都在 Leetcode 上打码了，PAT 玩的少，好像有点手生了？话说回来，这还是第一次做 PAT 的考试题，不熟悉也是正常吧，给自己一点安慰。废话少说，直接看题目吧。 7-1 暴力破解旅行箱上的密码锁通常都只有 3 位数字，如果忘了密码，只要有足够的耐心，哪怕用逐一枚举的办法，也可以暴力破解。如果还能隐约记得数字的范围，则可以大大降低破解的工作量。 本题就请你根据用户记忆中的数字范围，列出所有可能的密码。 输入格式输入第一行给出一个正整数 n（≤8），随后一行列出 n 个 0 - 9 范围内的数字，是用户记忆中可能属于密码的数字。题目保证 n 个数字没有重复，数字间以空格分隔。 输出格式按照密码组成的 3 位数从小到大的顺序，输出这 n 个数字能组成的所有可能的 3 位数密码。要求每行输出 10 个，同行数字以 1 个空格分隔，行首尾不得有多余空格。注意：如果有前导零，也不可忽略。 输入样例1235 2 8 输出样例123222 225 228 252 255 258 282 285 288 522525 528 552 555 558 582 585 588 822 825828 852 855 858 882 885 888 Analysis这个题迷惑性挺强的，第一眼看过去，以为是求 3 个数字全排列的题目。实际上也确实是这样的题目，但是没有那么简单。因为数字个数是不限定的，可能会给少于 3 个的数字，也可能会给大于 3 个的数字。所以，大体上就有 2 种情况： n &gt;= 3。 n &lt; 3。 在考试时间写这个问题的时候，一直在纠结怎么输出，怎么能枚举出所有的可能。一会觉得直接输出数字方便，一会又觉得直接算出来用集合自动排序更简单。结果最后还是选择了集合，因为集合既可以避免重复选取，又可以排序。那么，接下来要考虑的问题就是把所有可能的数字算出来了。因为只需要组成 3 位数，所以按照之前的分析就可以知道： n &gt;= 3，此时只用分别选择数字作为百位、十位和个位就行了，反而比较容易处理。 n = 2，因为限定了最后得到的 3 位数中必须要有 2 个数字，从排列的角度来讲，就是往 2 个数字组成的队列中插空，但是这两个数字也是可以交换位置的，所以就是 2 * 3 = 6，一共 6 种可能的组合方式。 n = 1，与 n = 2 时同理，但此时只用将唯一的数字分别当作百位、十位和个位，计算一次就行了。 n = 0，这个情况，做题的时候忘了...实际上就 000-999 这 1000 个数。 以上就是做题时的分析了，浪费了挺多时间的。 Code这是当时写的代码，真乱啊。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; password;const int maxn = 10 + 5;int arr[maxn] = &#123;0&#125;, n;int main() &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; int tmp; if(n == 1) &#123; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = arr[0] * 100 + i * 10 + j; password.insert(tmp); &#125; &#125; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = i * 100 + arr[0] * 10 + j; password.insert(tmp); &#125; &#125; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = i * 100 + j * 10 + arr[0]; password.insert(tmp); &#125; &#125; &#125; else if(n == 2) &#123; for(int i = 0; i &lt; 10; i++) &#123; tmp = i * 100 + arr[0] * 10 + arr[1]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[0] * 100 + i * 10 + arr[1]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[0] * 100 + arr[1] * 10 + i; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = i * 100 + arr[1] * 10 + arr[0]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[1] * 100 + i * 10 + arr[0]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[1] * 100 + arr[0] * 10 + i; password.insert(tmp); &#125; &#125; else &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; for(int k = 0; k &lt; n; k++) &#123; tmp = arr[i] * 100 + arr[j] * 10 + arr[k]; password.insert(tmp); &#125; &#125; &#125; &#125;// cout &lt;&lt; password.size() &lt;&lt; endl; set&lt;int&gt;::iterator it = password.begin(); int cnt = 0; for(; it != password.end(); it++) &#123; printf("%03d", *it); cnt++; if(cnt == password.size()) cout &lt;&lt; endl; else if(cnt % 10) cout &lt;&lt; ' '; else cout &lt;&lt; endl; &#125; return 0;&#125; 上面的代码，提交上去之后，只拿了 12 分，还有 2 个测试点没过。现在想想，可能有个测试点是 n = 0 的情况吧，那另外一个测试点呢？ 7-2 学霸所谓“学霸”，就是每个学期选课学时最长的人。本题就给你所有课程的学时和选课名单，请你找出那个学霸。如果有总学时并列最多的情况，则选那个选课门数最多的。如果还有并列，就按学号升序输出他们吧~ 输入格式输入在第一行中给出一个正整数：N（≤5000）为课程总数。随后 N 行，每行给出一门课的选课信息，格式如下1学时 人数 选课人1 选课人2 …… 其中 学时 是该课程的学时，一个不超过 100 的正整数；人数 是该课程的选课人数，为不超过 200 的非负整数；选课人i 是第 i 个选课学生的编号，是一个 5 位数字。题目保证不同学生对应的编号不同，且同一门课程的选课名单中没有重复的学生。 输出格式首先在一行中输出学霸（们）的选课总学时和门数，随后在下一行中按照编号升序输出所有满足题面描述的学霸。编号间以 1 个空格分隔，行首尾不得有多余空格。题目保证至少存在一位学霸。 输入样例123456532 5 10001 00003 91032 02387 1099364 2 36775 9103216 3 10993 02387 3677516 4 02387 56772 10993 0000332 3 10993 02387 88024 输出样例1296 402387 10993 Analysis第二个题目是比较简单的，但是也有坑。而且，给的信息很多，需要仔细读题才能确定那些信息是用来得到结果的。一开始本来是想用 map 来做的，后面看到学生编号反正是个 5 位数，我直接散列得了。这个思路也没错，但是当时做的时候没有考虑到输出的限制，题目已经说了有并列的情况了，所以还需要对最后的结果进行排序。但是，做题的时候，有点方，完全没有想到这里来。其实就是太方了，搞得题目没有读清楚，就开始写了。 Code这是当时写的代码，因为没有考虑到并列的情况，所以也只拿了 14 分...123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int studytimes[maxn] = &#123;0&#125;, amount[maxn] = &#123;0&#125;;int main() &#123; int n, time, peos, id; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; time &gt;&gt; peos; while(peos--) &#123; cin &gt;&gt; id; studytimes[id] += time; amount[id]++; &#125; &#125; int max_time = studytimes[0], max_amount = amount[0]; for(int i = 1; i &lt; maxn; i++) &#123; if(max_time &lt; studytimes[i]) max_time = studytimes[i]; if(max_amount &lt; amount[i]) max_amount = amount[i]; &#125; cout &lt;&lt; max_time &lt;&lt; ' ' &lt;&lt; max_amount &lt;&lt; endl; bool flag = true; for(int i = 1; i &lt; maxn; i++) &#123; if(max_time == studytimes[i] &amp;&amp; max_amount == amount[i]) &#123; if(flag) &#123; printf("%05d", i); flag = false; &#125; else printf(" %05d", i); &#125; &#125; return 0;&#125; 现在再看，真是不应该。 7-3 排课排课是个世界难题。 假设每个学期有 N 个教学班的课需要排，每周有 M 个时间段可以上课，全校共有 K 间教室，不同排课组合方案的个数可能会超过整个宇宙的质子数。更为复杂的是，每个学期排课前，学校还会收集每个教学班任课老师不能上课的时间段，还要保证排课不与老师的时间安排起冲突。 当然，本题不是要求你实现一个排课算法，而是要求你实现一个排课方案检查算法。即给定每个教学班上课的时间和地点，你需要检查这个时间段和地点是否只有这一个班上课，并且这个上课时间不会正好是任课老师不能上课的时间。 输入格式输入在第一行中给出三个正整数：$N（≤10^4）$为教学班总数；$M（≤40）$为一周内上课时间段的个数；$K（≤10^3）$为教室总数。数字间以空格分隔。以下我们就将教学班、时间段、教室分别从 1 开始顺序编号。 随后 N 行，每行给出一个教学班的任课教师时间限制和排课的信息。格式如下：1L T[1] ... T[L] Time Room 其中L是任课教师的时间限制数量（&lt; M），后面给出L个该老师不能上课的时间段编号；Time是该教学班安排的上课时间段编号，Room 是上课教室编号。我们假设每个教学班的任课老师都不一样。 输出格式如果给定的课表安排是完全无冲突的，则在一行内输出：Perfect Arrangement for N classes!其中N是教学班数量。 如果课表有冲突，则需要输出冲突原因。我们首先假设教学班是按照编号递增序进行排课的，教学资源先到先得。如果后面安排的教学班 A 跟前面的教学班 B 排在了同一个时间和地点，则在一行中输出ERROR: Conflict between A and B.，此时教学班 A 暂不安排。如果教学班 A 的上课时间跟任课教师有冲突，则在一行中输出ERROR: Conflict with instructor for A.。当两种冲突都发生时，分两行输出，先输出教学班冲突的信息。 输入样例 11234565 20 102 1 5 10 70 10 35 2 4 6 8 10 3 33 10 3 18 15 11 20 19 10 输出样例 11Perfect Arrangement for 5 classes! 输入样例 21234565 20 102 1 5 10 70 10 75 2 4 6 8 10 6 33 10 3 18 6 32 20 10 10 7 输出样例 21234ERROR: Conflict between 2 and 1.ERROR: Conflict with instructor for 3.ERROR: Conflict between 5 and 1.ERROR: Conflict with instructor for 5. Analysis这个题跟第二道题是一个类型的题目，都是信息给的很多，需要根据题目条件，运用不同的信息。唯一的坑点，就是要读清楚题目，但遗憾的是，这与我无关... Code这是当时写的代码，提交后是 15 分...1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;const int maxn = 10000 + 5;struct Class &#123; int timelimit[45]; int time, room;&#125; cla[maxn];int main() &#123; int n, m, k, l, time_t, room_t; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); scanf("%d", &amp;l); for(int j = 0; j &lt; l; j++) &#123; scanf("%d", &amp;cla[1].timelimit[j]); &#125; scanf("%d %d", &amp;cla[1].time, &amp;cla[1].room); bool flag1 = true; for(int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;l); for(int j = 0; j &lt; l; j++) &#123; scanf("%d", &amp;cla[i].timelimit[j]); &#125; scanf("%d %d", &amp;cla[i].time, &amp;cla[i].room); for(int j = 1; j &lt; i; j++) &#123; if(cla[i].time == cla[j].time &amp;&amp; cla[i].room == cla[j].room) &#123; printf("ERROR: Conflict between %d and %d.\n", i, j); flag1 = false; break; &#125; &#125; for(int j = 0; j &lt; l; j++) &#123; if(cla[i].time == cla[i].timelimit[j]) &#123; printf("ERROR: Conflict with instructor for %d.\n", i); cla[i].time = -1; flag1 = false; break; &#125; &#125; &#125; if(flag1) printf("Perfect Arrangement for %d classes!\n", n); return 0;&#125; 7-4 简易测谎测谎通常使用一套准备好的问题提问被测试者，通过分析被测试者的反应得到结果。比较高级的测谎技术会使用测谎仪，监视被测试者的生理活动状况。我们这里的简易测谎则是通过对问题答案的特征分析来做出判断。 首先我们要求被测试者做完 N 道单选题，每道题有 8 个选项，由小写英文字母a-h来表示。这样就得到一个长度为 N 的、由a-h小写英文字母组成的字符串。对每个字符串打分，得分超过某个给定阈值 T 的就判断为“疑似说谎者”。打分原则如下： 以f开头的，得分 −2； 以a结尾的，得分 −1； 对于每一段长度大于 5 的连续选择同一字母的最长子串，得分 +3； a后面紧跟e或h的，得分 −4； 对于每一段长度大于 3 的连续选择相邻递增字母的最长子串（例如abcd或defgh），得分 +5。本题就请你写程序完成对被测试者的判断。 输入格式输入第一行给出 3 个正整数：N（6≤N≤100）为测谎问卷的题目数；T （≤100）为判断说谎的得分阈值；K（≤100）为被测试者人数。 随后 K 行，每行给出一个被测试者的答案字符串。 输出格式对每个被测试者的答案，在一行中输出其得分。如果分数超过阈值，则在其分数后输出!!!。 输入样例123456712 1 6fghaebcdedddahhhhhhgbaaacdeffffffffffffffghecaaafeeeeeeeegcbaaaaaabbbbbb 输出样例123456-1-28!!!-316!!! Analysis这个题感觉是这套卷子最常规的一道题了，因为很明显就是字符串处理的题目。但这个题目的坑点在于，要分开讨论的情况太多了，比较费时间。特别是连续长度大于 5 的情况和连续相邻递增字母的情况，需要仔细梳理一下下标的对应关系，实际上，并不是一个难题。 Code这是当时写的代码，提交后是 18 分。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;const int maxn = 100 + 5;char str[maxn];int main() &#123; int n, T, t, k; scanf("%d %d %d", &amp;n, &amp;T, &amp;k); while(k--) &#123; scanf("%s", str); t = 0; if(str[0] == 'f') t -= 2; if(str[n - 1] == 'a') t -= 1; for(int i = 0; i &lt; n; i++) &#123; if(str[i] == 'a') &#123; if(str[i + 1] == 'e' || str[i + 1] == 'h') &#123; t -= 4; i = i + 1; &#125; &#125; if(str[i] == str[i + 1]) &#123; int j; for(j = i + 2; j &lt; n; j++) &#123; if(str[i] != str[j]) break; &#125; if(j - i &gt; 5) &#123; t += 3; i = j; i--; &#125; &#125; if(str[i + 1] == str[i] + 1) &#123; int j; for(j = i; j &lt; n; j++) &#123; if(str[j + 1] != str[j] + 1) break; &#125; if(j - i &gt;= 3) &#123; t += 5; i = j; i--; &#125; &#125; &#125; printf("%d", t); if(t &gt; T) printf("!!!"); printf("\n"); &#125; return 0;&#125; 7-5 前K大数本题目标非常简单：给定 N 个整数，找出前 K 个最大的数，并按递减序输出。 输入格式输入第一行给出 2 个正整数$N (≤10^6) $和 $K (≤5)$。随后一行给出 N 个整数键值，范围在区间$[−2^{30} ,2^{30}]$内，以空格分隔。 输出格式按递减序在一行中输出前 K 个最大的数。 注意：一行中输出的数字间须以 1 个空格分隔，行首尾不得有多余空格。 输入样例 11210 440 25 60 -15 30 -21 80 -1 -5 27 输出样例 1180 60 40 30 输入样例 2124 523 -17 99 1 输出样例 2199 23 1 -17 Analysis这个题的形式倒是很简单，不过想拿满分也不是那么容易。因为题目没说不会出现重复元素，所以，很明显的一个坑点就是重复元素。一开始想到的做法是先排序，然后用 hashmap 把输出过的元素标记了，结果提交之后直接就 Time Limited Exceeded 跟 Memory Limited Exceeded 了。然后就直接跳过做前面的题去了，当时这道题是第三个做的。 Code这是当时写的代码，提交之后是 13 分。1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;bool cmp(int a, int b) &#123; return a &gt; b;&#125;unordered_map&lt;int, int&gt; ht;const int maxn = 1000000 + 5;int numbers[maxn] = &#123;0&#125;;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; numbers[i]; &#125; sort(numbers, numbers + n, cmp); bool flag = true; int index = 0; while(k) &#123; if(ht[numbers[index]] == 0) &#123; if(flag) &#123; cout &lt;&lt; numbers[index]; flag = false; &#125; else cout &lt;&lt; ' ' &lt;&lt; numbers[index]; ht[numbers[index]] = 1; k--; &#125; index++; if(index &gt;= n) break; &#125; return 0;&#125; 其实，感觉上面的代码正常应该不会超时，应该是那个测试样例死循环了。至于内存超限，只能不用 hashmap，再想想其他的做法了。 Summary乙级题库的最后 10 道题好像是 2019 年的真题，具体是啥时候的就不知道了。但是，个人感觉比这次考试的要容易一些。特别是 1101、1102、1103、1106、1107、1108，基本跟送分题一样，但这张卷子的前 3 道题，不是那么明显的送分题，埋了一点点坑。这套卷子的第 4 题跟第 5 题就稍微常规一点了。不过，话说回来，不知道是不是这几天没玩 PAT，所以手真的生了的缘故，刚一拿到题目，竟然有点无从下手的感觉。总而言之，先把这几道题目的 AC 代码写出来吧。]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day3]]></title>
    <url>%2F2022%2F03%2F25%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[第三天的主题还是 two pointers，一道简单题，一道中等题。 283. Move ZeroesAnalysis拿到这种题之后，脑子里面反应的第一解法，就是直接用 vector 拷贝...😂试了下，确实是可以解出来的。不过既然出现在这里还是用双指针的方法做一下。 Codemethod 11234567891011class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret(nums.size()); int index = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i]) ret[index++] = nums[i]; &#125; nums = ret; &#125;&#125;; method 2123456789101112131415161718class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int first = 0, second = 1, size = nums.size(); while(first &lt; size) &#123; if(nums[first] == 0) &#123; while(second &lt; size &amp;&amp; nums[second] == 0) second++; if(second &lt; size) &#123; swap(nums[first], nums[second]); first++, second++; &#125; else break; &#125; else &#123; first++; if(second &lt;= first) second++; &#125; &#125; &#125;&#125;; method 3按照上面代码的思路，从左边指针来考虑问题，会比较麻烦，实际上，可以直接从右边指针的角度来考虑问题。此时，左边指针就是非零数的尾部，右边指针就是待处理数字序列的头部，这样右边指针每遇到一个非零数，就直接移到左边。12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = 0, size = nums.size(); while(right &lt; size) &#123; if(nums[right]) &#123; swap(nums[left], nums[right]); left++; &#125; right++; &#125; &#125;&#125;; 167. Two Sum II - Input Array Is SortedAnalysis这个题是 1. Two Sum 的加强版，之前的解法在这里可以用。所以，首先想到的就是暴力求解跟哈希，但这两种方法都没有使用题目给的条件：数组有序。 Codemethod 11234567891011121314151617/* method 1: violent solution, will cause time limit exceeded. */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; ret; int size = numbers.size(); for(int i = 0; i &lt; numbers.size(); i++) &#123; for(int j = i + 1; j &lt; numbers.size(); j++) &#123; if(numbers[j] + numbers[i] == target) &#123; ret.push_back(i + 1); ret.push_back(j + 1); &#125; &#125; &#125; return ret; &#125;&#125;; 暴力解法，果然不出所料的会超时啊。 method 2123456789101112131415161718/* method 2: use hash map */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; ret(2); map&lt;int, int&gt; hash; int size = numbers.size(); hash[numbers[0]] = 0; for(int i = 1; i &lt; size; i++) &#123; if(hash.find(target - numbers[i]) != hash.end()) &#123; ret[0] = hash[target - numbers[i]] + 1; ret[1] = i + 1; &#125; hash[numbers[i]] = i; &#125; return ret; &#125;&#125;; 哈希虽然不超时，但是额外的消耗了内存空间。 method 3考虑到数组有序，所以可以使用前两天学习的二分查找，这样时间复杂度就是 $O(nlogn)$ 了。1234567891011121314151617/* method 3: use binary search */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i = 0; i &lt; numbers.size(); i++) &#123; int left = i + 1, right = numbers.size() - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(numbers[mid] == target - numbers[i]) &#123; return &#123;i + 1, mid + 1&#125;; &#125; else if(numbers[mid] &gt; target - numbers[i]) right = mid - 1; else left = mid + 1; &#125; &#125; return &#123;-1, -1&#125;; &#125;&#125;; method 4由于这个题出现在双指针里面，所以肯定可以使用双指针的解法。如何使用双指针呢？需要设置两个指针分别从数组的左右两边进行遍历，每次将指针所指的值之和与目标值进行比较。如果大于目标值，那么左移右指针；如果小于，那么右移左指针。可能会有人觉得漏解，实际上并不会。从反证法的角度很容易想明白，如果右指针固定，左指针左边存在满足条件的解，或者左指针固定，右指针右边存在满足条件的解，那么这个数组一定不是有序的。1234567891011121314/* method 4: use two pointers */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while(left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if(sum &lt; target) left++; else if(sum &gt; target) right++; else return &#123;left + 1, right + 1&#125;; &#125; return &#123;-1, -1&#125;; &#125;&#125;; Summary双指针用来解决一些问题真是有奇效啊。大体上来讲，要么是从中间向两边遍历，要么是两边向中间遍历。遇到这种类型的题目的时候，不妨从这两个角度思考一下，说不定问题就能得到解决。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day2]]></title>
    <url>%2F2022%2F03%2F24%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[第二天的主题是 two pointers，一道简单题，一道困难题。 977. Squares of a Sorted ArrayAnalysis这个题第一眼看到后，脑子里面浮现出来的解法，就是直接算，然后排序。尝试了一下，也是可以这样做的。不过，既然出现在双指针这里，应该可以用双指针来做。用双指针处理有 2 种思路： 从中间向两边遍历，这样需要先找到中间值，可以认为中间值是平方后数组的最小值，也可以认为是数组中正负数的分界点（题目已经限定是非降序数组，所以正负数是分别分布在两边的）。 从两边向中间遍历，这样每次选出来的值实际上是数组剩余数字中的最大值，所以需要逆序一下。 Codemethod 11234567891011class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; &#125; sort(nums.begin(), nums.end()); return nums; &#125;&#125;; method 2这里选择平方后最小值为中间值。1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), min_index = 0, min = nums[0] * nums[0]; for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; if(nums[i] &lt; min) &#123; min = nums[i]; min_index = i; &#125; &#125; int left = min_index - 1, right = min_index + 1; vector&lt;int&gt; ret; ret.push_back(min); while(left &gt;= 0 &amp;&amp; right &lt;= size - 1) &#123; if(nums[left] &gt;= nums[right]) &#123; ret.push_back(nums[right]); right++; &#125; else &#123; ret.push_back(nums[left]); left--; &#125; &#125; while(left &gt;= 0) &#123; ret.push_back(nums[left--]); &#125; while(right &lt;= size - 1) &#123; ret.push_back(nums[right++]); &#125; return ret; &#125;&#125;; method 312345678910111213141516class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; &#125; vector&lt;int&gt; ret(size); int index = size - 1; for(int i = 0, j = size - 1; i &lt;= j;) &#123; if(nums[i] &gt; nums[j]) ret[index--] = nums[i++]; else ret[index--] = nums[j--]; &#125; return ret; &#125;&#125;; 189. Rotate ArrayAnalysis这个题很经典，做法很多，是做过很多次的题目了。用 reverse 函数是最简单直观、而且消耗低的做法了，如果用直接交换数字的方法，需要计算出遍历的次数，但是实际上可以单独设置一个 count，用来记录交换的次数，一旦等于 n 说明都交换过了，就可以退出循环了，这样也是可以的。 Codemethod 11234567891011121314151617181920212223/* method 1: use queue, but cost many memory */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; vector&lt;int&gt; ret; queue&lt;int&gt; q; k %= size; for(int i = 0; i &lt; size; i++) &#123; q.push(nums[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; tmp = q.front(); q.pop(); q.push(tmp); &#125; while(!q.epmty()) &#123; ret.push_back(q.front()); q.pop(); &#125; nums = ret; &#125;&#125;; method 212345678910111213141516/* method 2: use vector, also cost many memory */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; vector&lt;int&gt; ret; k %= size; for(int i = size - k; i &lt; size; i++) &#123; ret.push_back(nums[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; ret.push_back(nums[i]); &#125; nums = ret; &#125;&#125;; method 31234567891011/* method 3: use reverse function */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; k %= size; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); &#125;&#125;; method 412345678910111213141516171819202122232425262728293031class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; k %= size; /* version 1 */ int count = gcd(size, k); for(int start = 0; start &lt; count; start++) &#123; int cur = start; int prev = nums[start]; do&#123; int next = (cur + k) % size; swap(nums[next], prev); cur = next; &#125; while(start != cur); &#125; /* version 2 int count = 0; for(int start = 0; count &lt; n; start++) &#123; int cur = start; int prev = nums[start]; do&#123; int next = (cur + k) % size; swap(nums[next], prev); cur = next; count++; &#125; while(start != cur); &#125; */ &#125;&#125;; Summary有时候用双指针来解决一些问题时，可能会有奇效，整体而言，思路不算难。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 天算法入门_day1]]></title>
    <url>%2F2022%2F03%2F23%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[来试试 Leetcode 14 天算法入门的难度。第一天的主题是二分查找，给了 3 道简单题。 704. Binary SearchAnalysis注意退出循环的条件是left &lt;= right。 Code12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; /* You can also write this way to avoid overflows. mid = (right - left) / 2 + left; */ mid = (left + right) / 2; if(nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if(nums[mid] == target) return mid; &#125; return -1; &#125;&#125;; 278. First Bad VersionAnalysis这个题一开始想到的是直接循环，结果不出所料的超时了，然后又改成了二分。话说，好像没有看清楚题目的条件：You should minimize the number of calls to the API.。之所以要返回 left，是因为 left 一定是 bad version。但是，mid 在每次循环后，就不一定是 bad version 了。 Code123456789101112131415161718// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int left = 1, right = n, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(isBadVersion(mid)) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;; 35. Search Insert PositionAnalysis一开始被这个题绕进去了，以为要把找到没找到的情况单独的拿出来讨论。实际上，按照二分查找的思路，mid 最后只有两种结果： 找到了 target 的位置。 找到了最后一个小于 target 的值的位置。 所以根据不同情况返回 target 的位置或 target 要插入的位置就可以了。 实际上，这个原理应该是 lower_bound() 函数的实现原理，只不过，lower_bound() 函数返回的位置信息应该是查找不到后的 left（如果没查找到，最终 right 一定会小于 left，因为只有这样才能退出循环），而这个值其实也就是插入的位置。其实也就是说，找到了，就返回 mid，没找到，就返回 left。 Codeversion 11234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(nums[mid] == target) break; else if(nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if(target &lt;= nums[mid]) return mid; else return mid + 1; &#125;&#125;; version 2123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; version 31234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(nums[mid] == target) break; else if(nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if(target == nums[mid]) return mid; else return left; &#125;&#125;; Summary一次性连续 3 做道同知识点的题目，对巩固这个知识点倒是很有帮助。二分查找返回的下标确实是一个容易让人迷惑的点，可能会有人喜欢把循环的条件写成left &lt; right，这样写应该也是可以的，不过返回值可能需要相应的做出调整。]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_stack&queue容器的基本用法]]></title>
    <url>%2F2022%2F03%2F18%2FC-stack-queue%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文只介绍 stack 和 queue 的一些常见用法，不着重讨论如何实现的问题。 intro与其他 STL 容器一样，使用 stack 与 queue，需要分别引入头文件 stack 和 queue。 stack栈（stack）是一种后进先出（FILO）的数据结构。就好比放盘子一样，在不将叠放好的盘子全部举起的情况下，只能先依次拿最上面的盘子使用（这个比方可能不太恰当）。栈的声明比较简单，直接：1stack&lt;int&gt; st; 其中，int可以换成其他数据类型、结构体或容器。接下来，在看一下与栈相关的函数。 emptyempty 用来判断栈是否为空，空就返回true，否则就返回false，如：1234567891011121314#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;char&gt; st; if(st.empty()) cout &lt;&lt; "emtpy"; else cout &lt;&lt; "no"; return 0;&#125;/*out:empty*/ poppop 用来弹出栈顶元素，如：1st.pop(); pushpush 用来将元素压入栈内，如：1st.push(); sizesize 用来返回栈内元素的个数，如：12345678910111213141516#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); cout &lt;&lt; st.size(); return 0;&#125;/*out:3*/ toptop 用来返回栈顶元素，如：12345678910111213141516#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); int a = st.top(); cout &lt;&lt; a; return 0;&#125;/*out:3 注意使用前先判断栈不空，不然会产生未知错误。 queue这里介绍的队列（queue）只是一种先进先出（FIFO）的数据结构。就跟生活中的排队是一回事，前排的人先通过。队列的声明与栈一样，如：1queue&lt;int&gt; q; 其中，int可以换成其他数据类型、结构体或容器。接下来，在看一下与队列相关的函数。 emptyempty 用来判断队列是否为空，空就返回true，否则就返回false，用法与栈一致。 pushpush 用来将元素压入队内，如：12queue&lt;int&gt; q;q.push(1); front/backfront 和 back 分别用来返回队首与队尾元素，如：1234queue&lt;int&gt; q;q.push(1);int a = q.front();int b = q.back(); poppop 用来弹出队首元素，如：123queue&lt;int&gt; q;q.push(1);q.pop(); sizesize 用来返回队列内元素的个数，用法与栈一致。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_string 容器的常见用法]]></title>
    <url>%2F2022%2F03%2F14%2FC-string-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C++ 提供了两种类型的字符串表示形式：C 语言类型和引入的 string 类。在某些场景下，使用新的 string 类来处理字符串十分方便，这里介绍一下其常见的用法。 定义如果要使用 string，需要添加 string 头文件。但在 C++ 11 中，iostream 这个头文件内好像已经包含了 string ，具体如何，这里不做讨论。定义 string 的方式跟基本数据类型相同，只需要在 string 后面跟上变量名即可：1string str; 如果要初始化，就需要直接对 string 类型的变量赋值：1string str = "abcd"; 有时候需要一个含有 n 个相同字符的字符串，此时可以利用 string 的构造函数完成：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str = string(4, 'a'); cout &lt;&lt; str &lt;&lt; endl; return 0;&#125;/*out:aaaa*/ 还可以用构造函数完成截取字符串的操作：123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcd"; string s = string(str, 1, 3); cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;/*out:bcd*/ 访问C++ 提供了两种多种访问 string 类的方式。 通过下标访问C++ 可以通过下标直接访问到 string 类型变量的每一个字符变量，如：123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ 访问单个字符还可以通过 at 函数来完成：123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ 如果要输入或输出整个字符串，就得用 cin 和 cout：12345678#include &lt;iostream&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; cout &lt;&lt; str;&#125; 硬要用 scanf 和 printf 也是可以的，如：12345678#include &lt;iostream&gt;using namespace std;int main() &#123; string str; scanf("%s", str.c_str()); printf("%s", str.c_str());&#125; 通过迭代器访问string 类与其他 STL 容器一样，也是支持用迭代器访问的，如：12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; string::iterator it = str.begin(); for(; it != str.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ 这个用法有点类似指针，另外，it + 2和str[2]表示的是同一个字符。 操作符operator +=这是 string 的加法，类似 C 语言中的 strcat，java 里面也有类似的用法，如：123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcde"; string str2 = "efghi"; string str3 = str1 + str2; str1 = str1 + str2; cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str3 &lt;&lt; endl;; &#125;/* out:abcdeefghiabcdeefghi*/ 注意：string 类可没有 +、/、×，不要惯性思考了。 compare operator两个 string 类型的变量可以直接用 &lt;、&gt;、==、&lt;=、&gt;=、!= 直接进行比较，规则是按字典序逐个字符进行比较，这个功能类似 C 语言中的 strcmp，如：123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aa", str2 = "aaa", str3 = "abc", str4 = "xyz"; if(str1 &lt; str2) printf("1\n"); if(str1 != str3) printf("2\n"); if(str4 &gt;= str3) printf("3\n"); &#125;/* out:123*/ 常用函数相较于 C 语言，string 类封装了很多常用的字符串操作函数，可以直接拿来用，很方便。 length/sizelength 和 size 返回 string 的长度，也就是字符串的长度，如：12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaa", str2 = "11aaa"; cout &lt;&lt; str1.size() &lt;&lt; ' ' &lt;&lt; str2.length();&#125;/* out:3 5*/ insertinsert 的用法有很多，这里只列举常见的几个用法。 字符串中插入字符串基本写法：str1.insert(pos, str2)，在 str1 的 pos 这个位置，插入字符串 str2，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz", str2 = "11aaa"; str1.insert(2, str2); cout &lt;&lt; str1;&#125;/* out:aa11aaaz*/ 还可以使用迭代器来完成，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz", str2 = "11aaa"; str1.insert(str1.begin() + 2, str2.begin(), str2.end()); cout &lt;&lt; str1;&#125;/* out:aa11aaaz*/ 字符串中插入多个字符基本写法：str1.insert(pos, count, ch)，在 str1 的 pos 这个位置，插入 count 个字符 ch，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz"; str1.insert(2, 1, 'c'); cout &lt;&lt; str1;&#125;/* out:aacz*/ 同样，也可以使用迭代器来完成。参考链接：C++ string类insert用法总结 eraseerase 可以用来删除单个字符或一个区间内的所有字符。 删除单个字符基本写法：str1.erase(it)，it 为要删除的字符的迭代器，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcde"; str1.erase(str1.begin() + 2); cout &lt;&lt; str1;&#125;/* out:abde*/ 删除一个区间内的字符删除一个区间内的字符有两种方法，str1.erase(first, last)和str1.erase(pos, length)，也就是区间的写法。第一种写法 first 与 last 必须要是迭代器，删除的区间是[first, last)，左闭右开；第二种写法中 pos 为需要开始删除的起始位置，length 为删除的字符个数，如：123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg", str2; str2 = str1; str1.erase(str1.begin() + 2, str1.end() - 1); cout &lt;&lt; str1 &lt;&lt; endl; str2.erase(2, 4); cout &lt;&lt; str2;&#125;/* out:abgabg*/ 参考链接：c++ string的erase删除方法 clearclear 用来清空 string 中的数据，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg"; str1.clear(); cout &lt;&lt; str1.length();&#125;/* out:0*/ substrsubstr 用来返回子串，基本写法：str.substr(pos, len)，即返回从 pos 开始，长度为 len 子串，如：1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg", str2; str2 = str1.substr(3, 3); cout &lt;&lt; str2;&#125;/* out:def*/ 也可以直接写str.substr(pos)，会直接返回从 pos 开始，直到字符串结尾的子串。 findfind 用来查找子串，这个子串也可以是一个字符，基本写法：str.find(str2)或str.find(str2, pos)，如果不加参数 pos，那么 find 会返回 str2 在 str 中第一次出现的位置，否则就返回 string::npos（是一个常数，本身的值是 -1，但由于它是 unsigned_int 类型，所以也可以认为是 4294967295）。而加了 pos 后，就会从 str 的第 pos 个位置开始匹配 str2，返回值与不加 pos 一致。如：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "hello world"; string str1 = "llo", str2 = "you"; cout &lt;&lt; str.find('e') &lt;&lt; endl; if(str.find(str1) != string::npos) cout &lt;&lt; str.find(str1) &lt;&lt; endl; if(str.find(str1, 2) != string::npos) cout &lt;&lt; str.find(str1, 2) &lt;&lt; endl; if(str.find(str2) != string::npos) cout &lt;&lt; str.find(str2) &lt;&lt; endl; else cout &lt;&lt; "no pos" &lt;&lt; endl;&#125;/* out:122no pos*/ 参考链接：C++ string中的find()函数 replacereplace 用来替换子串，基本用法：str.replace(pos, len, str2)或str.replace(it1, it2, str2)。第一种写法是把 str 从第 pos 个位置开始、长度为 len 的子串替换为 str2；第二种写法是把 str 的迭代器 [it1, it2) 范围的子串替换为 str3，如：1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "Maybe you will turn around."; string str2 = "will not"; string str3 = "surely"; cout &lt;&lt; str.replace(10, 4, str2) &lt;&lt; endl; cout &lt;&lt; str.replace(str.begin(), str.begin() + 5, str3) &lt;&lt; endl;&#125;/* out:Maybe you will not turn around.surely you will not turn around.*/ to_stringto_string 用来将数值转化为字符串，基本用法：string num = to_string(1234213)，如：12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; string str = to_string(1234567); cout &lt;&lt; str &lt;&lt; endl; str = to_string(1.223563333); cout &lt;&lt; str &lt;&lt; endl; str = to_string(-121); cout &lt;&lt; str &lt;&lt; endl;&#125;/* out:12345671.223563-121*/ 这个函数，处理某些问题时，可能有奇效。参考链接：c++ to_String() appendappend 函数用来向字符串末尾添加字符或另一个字符串，基本用法：str.append(5, &#39;+&#39;)或str1.append(str2)，如：12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcd", str2 = "efgh"; cout &lt;&lt; str1.append(5, '+') &lt;&lt; endl; cout &lt;&lt; str1.append(str2) &lt;&lt; endl; return 0;&#125;/* out:abcd+++++abcd+++++efgh*/ 参考链接：C++中string append函数的使用与字符串拼接 pop_back/push_back严格来讲，这两个函数应该是从基类继承过来的（盲猜一下 string 的基类估计是 vector 😂），用法上与 vector 中的 push_back 和 pop_back 无差别：12345string str = "aaa"// 在 str 末尾添加一个字符 bstr.push_back('b');// 在 str 末尾删除一个字符str.pop_back();]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两件小事]]></title>
    <url>%2F2021%2F12%2F07%2F%E4%B8%A4%E4%BB%B6%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[今天发生了两件小事，都与水相关。 两件小事都很平常，都是普通人会碰到，可能也会做的事情。 之所以想要写下来，主要是为了让自己反省，为什么会做出这样的事情，为什么会得到这样的结果。 不过，倒也不是想完完全全的自我批判。 两件事情的关联性很大，事情的经过是这样的： 下午，我拿了一个水桶准备去社区的直饮用水站接点纯净水，顺路在去水站前方 150 米处的自来水公司交水费（主要是为了询问最近水表记录是否正确）。等到我来到水站后，空无一人，索性就直接用桶接水，想着不如顺路去自来水公司交下水费吧（此时的我，丝毫没有考虑到在我离开的时候，可能会有人来接水）。然后，我就留下了我的桶（接水器的开关会自动关闭）。 来到自来水公司后，报了位置与住户信息，工作人员提醒有 2 年的垃圾处理费没有交，但我记得很清楚，去年的垃圾处理费是我亲自来交的。口头说明并不能让工作人员相信，于是，我就将去年的发票拿给了工作人员。果然，见到发票，工作人员就信服了。之后，又询问了有关水表记录的事情，但丝毫没有打消我的疑惑。因为后面又有人也等着交水费，我索性打消了继续询问下去的念头。 回到水站后，一看接水器，水桶没了，环视周围一圈，结果跟来的时候一样，一个人也没有。 事情的大概就是这样，其实可以精炼一下： 在有发票的情况下，让工作人员修改了信息，避免了不需要的损失 丧失了对环境的警惕，将“有价值”的物品暴露在无人的环境中，造成了损失 总结一下，可以看出这两件事情都是因水而起的，但是结果却正好相反。归根结底，它们所反映出来的是我在处理事情上的存在的问题。那么，这些问题又是什么呢？是粗心的问题吗？我觉得应该不单单是粗心的问题，单从第一件事情来讲，我并没有犯下粗心的错误；而从第二件事情的角度来看，我的错误是太天真了。当时，我只想了两点就做出了决定： 现在没人来接水，周围又没有多少人，先去交了水费在回来吧 如果有人来接水，看到我的桶在上面，应该会把我的桶拿下来吧 现在，在回头看我的想法，确实是天真，你就这么放心别人不会顺手牵羊直接把你那刚接好水的桶直接拿走吗？特别是在周围还没有任何监控设备的情况下，也没有跟其他人打招呼。 固然拿走我的桶的人是不道德的，他应该把我的桶拿下来然后放到旁边（尽管桶已经接好了水），但我又强烈觉得是我在这件事情上的处理是错误的。如果我接了水先送回家去，然后再去交水费不行吗？时间上也是来的及的，为什么会急于这一时呢？不管何时何地，还是要对周围环境保持较高的警惕性才行，因为你并不知道麻烦会何时找上身。更不能容忍自己的是，东西遗失了，连寻找的线索都没有。就好比，在黑暗的环境中与人搏斗，你是伸手不见五指，而你的敌人是带着夜视仪的。这样下去，失败的一方只会是自己。 尽管这是小事，但是从中折现出的自身所存在的问题不容小视。 2021-12-8 今天又站在那位顺手牵羊的人的角度想了一下，当他看到有一个“无人认领”（他认为是这样）的桶放在他面前时，他直接就拿走了的这个行为，是不是就好比在大马路上捡了钱一样呢？如果是我捡了钱，那我一样也会揣进自己的腰包，当然，失主要是就在旁边就另谈了，因为我怕这样可能会被打。但就这件事而言，至少我作为桶的主人，并没有在现场留下“暂时存放，请勿拿走”之类的信息，也没有在他拿走之时出来阻止他。如果一味的将希望寄托在别人身上，希望别人是一个高素质的人，是一个不会随便拿不是自己东西的人，这个想法在目前的社会环境下，果然还是不现实的，那这就又回到了还是我自己太天真的问题上了。 之所以又写这些的目的，其实是我不太想去过分指责拿我桶的人，因为我觉得对普通的老百姓而言，这其实是“人之常情”，但主要的问题还是在我。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 的一些概念]]></title>
    <url>%2F2021%2F11%2F17%2FC%2B%2B-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此文用于记录学习 C++ 过程中遇到的一些知识点。 命名空间命名空间里面包含了逻辑结构上相互关联的一组类、函数、模板等。命名空间像是一个容器，把某些在逻辑结构上相关的“对象”放在一起并与外界区分。特别的，命名空间里面的变量名或类名可以和命名空间外的变量名和类名重名。 修饰符signed、unsigned、short、long 是 C++ 中的修饰符，当 short 和 long 用来修饰 int 时，int 可省略不写，表示短整型数据或长整型数据（也就是说，没有 short 和 long 这种数据类型）。 内存分配C++ 程序在运行时，计算机内存被分为程序代码区、全局数据区、堆区、栈区四个部分。 静态存储区分配静态分配方式下的内存在程序编译的时候就已经分配好了且存在于程序的整个运行过程。例如 static 变量，其生命周期随程序的结束而结束，而飞像一般变量随函数或作用域的结束而结束。 当然，除了 static 变量，还有一种全局对象 static object，也可以存放在静态存储区。 栈内存分配栈内存分配方式下的内存是存在于某作用域的一块空间。例如调用某个函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会被自动释放。 堆内存分配堆内存分配，也称动态内存分配，通常使用 new 和 delete 关键字进行管理。堆内存空间可由用于手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片。 函数重载函数重载指定义一个函数参数类型或参数个数不同的重名函数。当程序执行时，编译器将调用参数类型与函数形参类型一致的函数。 面向对象程序设计的特点这部分内容都是概念性内容，应该算是所有面向对象的程序语言的基本特性。 抽象抽象是指对具体问题或对象进行概括，抽出其公共性质并加以描述的过程。一般情况抽象分为数据抽象和行为抽象，其中数据抽象是指一个对象区别于另一个对象的特征，行为抽象是指某类对象的共同特征。 封装封装是指将抽象得到的数据和行为相结合，隐藏对象属性和实现细节且仅对外提供公共访问方式的过程。 继承继承是指通过代码复用在保持原有类特性的基础上对子类进行具体说明的过程，通俗来说继承就是精简重复代码的手段。 多态多态是指一段程序能够处理多种类型对象的能力，函数重载就是实现多态的一种手段。在 C++ 中，多态可分为强制多态、重载多态、类型参数化多态和包含多态。 类类一般是由类名、数据成员、函数成员三部分组成。定义类的基本形式为：12345678class name &#123; public: 外部接口 protected: 保护性成员 private: 私有成员&#125; 其中 public、protected、private 表示访问控制属性，用于控制类成员的访问权限。特别的，没有分配控制属性的默认为 private 私有成员。public 成员可以在类外直接访问；protected 成员可以在子类中访问；private 成员只能被本类的成员函数访问。 类的成员函数成员函数描述了类的行为。成员函数在类中只用说明其函数的返回类型、名字和参数表，而函数的具体实现在类外说明，其基本形式为：1234567class name &#123; 函数的返回类型 函数名(参数列表)&#125;;返回值类型 类名::函数名(参数列表) &#123; 函数体&#125; 对象在 C++ 中，对象是某类事物的实例，其声明形式为：1类名 对象名; 引用引用与指针主要有三个区别： 可以通过*p = 0或者*p = NULL来描述一个空指针，但不存在空引用。 指针可在任何时间进行初始化操作，而引用只能定义时进行初始化操作。 指针变量指向内存的一个存储单元，而引用只不过是原变量的一个别名而已。 内存泄漏内存泄漏的可能场景很多，但通俗来讲，内存泄漏应该叫“内存闲置”更合适。也就是说，内存泄漏其实指的就是程序在结束之前，申请的内存在用完之后，没有被释放掉，那么程序再次需要内存的时候，就无法再使用这块内存了，只能再换一整块了。当然了，这只是通俗的理解方式，并不是那么严谨。 语言类型C++ 是一种静态数据类型语言，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。与之相反的，Python 的类型检查是在程序运行时进行的。 内置类型C++ 的基本内置类型包括两部分：算数类型和空类型。算数类型包含了字符、整数型、布尔值和浮点数，空类型不对应具体的值。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮滑初探]]></title>
    <url>%2F2021%2F11%2F13%2F%E8%BD%AE%E6%BB%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[鬼使神差的买了一双直排轮滑鞋子！😑 诺！就是下面这个东西： 事情起因是这样的：临近双十一了，想着是不是买点什么东西，天天在家闲着，偶尔出门发现走路挺远的，最近也没有骑车了，是不是整个代步工具？以来可以提高下“效率”，二来顺便锻炼身体。 结果就这样鬼使神差的想到了轮滑跟滑板，滑板其实是去年就开始想尝试玩玩的东西了，这次还是忍住了。考虑到二者都是需要身体平衡性的体育活动，索性就买轮滑鞋子了。主要还是滑板噪音有点大，这玩意好像不怎么吵？ 具体感受如何，要等玩一玩之后才能分析。 不过，拿这东西当代步工具的我，是不是又落伍了？人家的代步工具可是四个轮子的车啊！诶？突然发现，这玩意好像单脚四轮，双脚八轮，得，当我没说。 不管如何，轮滑本质是一种体育活动。当然了，至少目前而言，确实可以满足我的需求： 代步 锻炼 好吧，现在是 2021 年 11 月 13 日，今天是第一天见到这位兄弟，希望它好好待我，少让给我摔几跤。\ 日期：2021-11-14下午趁着阳光明媚的时候，折腾了 2 个小时，摔了好几次。特别有一次是完全失去平衡，屁股（准确说是尾椎骨）大面积着地，当下觉得屁股开花了，那叫一个疼，光是重新再站起来就花了几分钟。 练习时间是 2 小时没错，但是自我感觉收效甚微。仔细琢磨了一下，没想出个所以然，结果又去找了点视频看，发现好像是自己太着急了。大概意思就是目前连走都没学会就想跑了，没办法，晚上又练习了几百次原地踏步，蹲下站起，后来又尝试了一下滑行，好像找到了点感觉？但遗憾的是，不会拐弯 :(。 日期：2021-11-15傍晚练习了大概一个多小时，只是练习近距离的推步滑行和平衡前滑，感觉还行，基本上感觉大概有了吧。然后又尝试了下刹车跟转弯，感觉刹车会容易一点，但是转弯一点感觉都没抓住，可能还需要在多摔几次才能有感觉吧。是的，我现在有点后悔没买护具了，这样我活动的时候也放得开一点，不至于现在有点畏手畏脚的（毕竟昨天的屁股还历历在目，不过已经好多了）。 练习的时候突然想起来小时候学骑自行车的时候了，长辈在后面扶着座椅，我在前面骑，他们突然松开手，骗我还没有，然后我接着骑，骑着骑着就会了。其实，轮滑应该也是一样，关键就是要找到身体的所适应的平衡感。如何去找呢？只有大胆尝试，多摔几次，应该就能找到了。遗憾的是，我并没有护具来支撑我做这样的事情，但不管如何还是要继续练习下去。 日期：2021-11-16哈，今天感觉还行，练习时间在一个半小时左右，摔了四次，不过好在没有受大伤，就是右手手掌不小心挂了个彩，一个小伤口，再次说明了护具对初学者的重要性。不过，我好像有一个可以保护手掌的“护具”，明天可以试一试。 话说，今天差点刷了个嘴啃泥，好在手支撑住了。还有一次，差点栽到人家鸡笼里面了 XD。总之，没受大伤就好。 今天主要的练习内容是推步滑行和平衡前滑，感觉还行，就是动作姿势还是有些不到位。 日期：2021-11-17右腿膝盖增加一处擦伤，还好只是轻微。话说，今天绕着家滑了一圈，不得不吐槽下农村的水泥路，有些路段横条纹太多了，脚在上滑过时，颠的我脚都麻了，站都站不稳了，特别容易摔（不过，反过来想好像也能锻炼一下平衡感？🤔）。没有横条纹的路段，那滑的就很舒服了，脚上没有颠簸感，很稳当，累了就平衡前滑溜一下，然后再滑，当然滑的时间太长了，也还是要休息下的。 前几天练习转弯一点感觉没有，今天尝试了下，好像有点感觉，就跟人走路转弯一样，不用非得不动，可以迈小步滑过弯。 还有一点时觉得自己体力不太够，滑不了太远就觉得腰酸，这是什么“毛病”？还是我的姿势有些不到位，使得我的腰肌负荷过大，所以很快就觉得累了？ 日期：2021-11-18今天滑的很累，但是感觉很好，现在大概能持续滑行比较久了，对于之前的问题，今天可以稍微回答一下了： 滑不了太远就觉得累，是不是姿势不对？准确来讲，不是姿势不对，而是姿势维持的太久了。滑行的时候，为了保持身体的平衡感，一般会略微屈膝，身体前倾。很显然，即便没有穿轮滑鞋，就在平地上维持这个姿势也很累，更何况是穿了轮滑鞋。所以，应该在滑行的时候应该要直立起来，当然了，直立必须要建立在维持了平衡的基础上，不然就摔跤了。还有一点就是，身体尽可能的要放松，不要太僵硬了，肌肉太紧张了，也会容易产生疲劳。 如何转弯？转弯其实可以边滑边转（只要步子迈小点），也可以滑着转。滑着转其实就是 A 字转弯，这个动作的重点在于要使用鞋子的内刃，至于腿绷紧其实只是辅助的作用。往那边转，就用那只脚的韧。 话说，今天尝试了下冲坡，果然，两次都摔了。还有一次，滑了太久，很累，脚突然一下没劲了，直接栽草丛里了，2333。对了，今天有好几次差点要摔跤，结果都奇怪的稳住了，很诧异，应该是身体对这种失去平衡的感觉适应了一些吧。 今天基本没停过，一直在滑，滑了大概 3 个小时，最后一个小时去街上玩了一下，感觉还行，也不是很难。最后，脱下鞋子的那一刻是真的感觉全身有点酸了，出汗的感觉还是好啊。 日期：2021-11-19尝试了一下“长途”滑行，一去一来，一起是 10 公里，花了大概 1 个小时，看来现在自己的滑行速度大概也就 8 - 10 km/h 了吧，这个速度具体是什么样子的呢？就跟慢慢骑自行车一样。 整个滑行过程是在国道公路上进行的，虽然是在在公路边上滑行，但也要注意后方的车辆，注意不要反向滑行，要遵守基本的交通规则，要戴好护具。公路滑行的时候，要小心路上的小石头，当速度过快的时候，轮子一旦碰到这些石头就会突然像前冲一下，容易摔跤，所以要小心、慢速。每当这个时候，我就后悔为什么没有买护具。说实在的，如果是高速公路的话，基本不会有这种问题，相比国道而言，高速公路产生的摩擦力也会小很多，也会更加省力。但遗憾的是，那是高速公路，不是高速“滑道”，这路是给车跑的。 从拿到轮滑鞋到今天为止，差不多一周了吧，基本的滑行与东西好像掌握了，但还不是很牢固。这两天在街上滑行的动作其实已经不是刚开始学的推步滑行了，之前一直觉得自己总是喜欢用内刃，现在发现，在街上滑行的时候，脚其实是有一个上前蹬的动作的，也就是说，两脚交替滑行的时候，其实是在交替向前蹬，这时也就必然会有一只脚在前方，一只脚在后方，很显然，在后面的那只脚蹬地的时候，就会用到内刃。 总体而言，滑行时间不长，但我总觉得轮滑这个东西理论占 40%，实际占 60%，更多还是要靠身体去感受，要靠身体去熟悉踩在轮子上的平衡感，感觉自己其实算是滑着滑着就会了，也没有过分的去追求动作姿势，更多的还是靠身体感受平衡。不过，在滑行过程中，姿势也还是要尽量保持正确的，因为这样可以滑的更快、更省力。另外还有一点就是，护具是需要的，我发觉我没戴护具就敢去街上浪，实在是太莽了，真的是“艺高人胆大”。因为没有护具，也有点怕做几十公里的长途滑行，毕竟还是安全为重。 日期：2021-11-24一去一来，一共 30 公里，给我累死了，总共耗时 4 个小时，，差不多是 7 - 8 km/h 的速度，感觉自己腿都要滑断了，特别是最后 5 公里，心里总是在嘀咕：我的天，怎么还有这么远啊，啥时候能到啊。这段短途旅程的好消息是全程只摔了一次，坏消息是又是屁股摔了，不过好在是左侧大腿先着地，当时是挺难受的，后来就好很多了，因为没有把鞋子背在身上，所以中途也不能换鞋，滑太久之后，脚着实是难受啊。另外，是在最后只剩下五分之一路程的时候摔的，干，主要是那时候看不见啊… 突然发现一个问题，长时间穿着鞋子滑行，脚踝会很累。尽管相比跑步而言，轮滑对膝盖的负荷要小很多，但是感觉对脚踝的负荷要大很多。之所以会这样，是因为在滑行的过程中时刻要注意刃的控制。当然了，可能也是我不熟练的原因，滑行时总是蹩脚。也有可能与鞋子有关，鞋子没有穿好，不够紧时，为了控制刃，会借助鞋帮使力，这样就使得脚踝的负荷很大。 今天还犯了一个大忌，到达目的地的时候是五点，在目的地溜达和休息耗去了半小时，等到准备返回时，已经五点半了，天都要黑了（深秋，天黑得早），结果滑到了五分之二的路程时，天已经是看不见了，路边上又没有路灯，结果一路摸黑回来。注意啊，在没有护具的情况下，摸黑回来，简直就是瞎子在滑，这是一件非常危险的事情，以后不能在这样搞了。 对了，还了解到一个信息。按照法律来讲，是不允许在路上玩轮滑或者滑板的，一旦出事，自己就是全责。虽然路上没有交警专门抓，但是还是要注意啊。不过，8 - 10 km/h 的速度基本上是不可能出事的，即便出事最多皮肉伤，但是有时候擦到人家车漆那就事大了，所以还是要注意这点。唯一的解决办法就是练好刹车，在有需要的时候来个急刹车。 这是当时滑到桥上拍的照片，这就是深秋下午 4 点的太阳，说是 12 点我都信… 从目的地返程的时候，用手机直接最大音量放朴树的《在希望的田野上》，当真是觉得自己还是“活着”的啊。 后来天一黑，果断直接换到摇滚了，乌漆嘛黑的，不壮下胆不行，23333。一路上，伴随着汽车的鸣笛声，从 simple man 到 don’t stop 再到 highway to hell（这个果断切了），等到快到家，看到路灯时候已经是 everybody hurts 了，哈，突然感觉世界都亮了，不过，快到家的时候，是觉得最累的时候，太累了，脚都抬不起来了。到家时，已经伸手不见五指了，原来很快就能爬完的五层楼，硬是一步一个台阶踩稳了才抬脚。 总之，以后是再也不能跟瞎子一样了，一定要计算好时间，不然等到真有事，就晚了（别在像个憨憨一样了，一直莽）。 日期：2021-11-27一下子滑几十公里的后果就是得休息几天才能缓过来，脚踝还是有点酸疼的感觉啊。 今天大概又滑了几公里吧，现在回头算算滑行总路程大概有 50 - 60 公里了，这也算是有一点滑行经验了吧？然后又尝试了一下葫芦步跟弓步转弯，葫芦步还挺容易的，但还需要多练习，现在步子还不能迈的很大，慢慢练，步子应该就可以迈大一点了。至于弓步转弯，现在还没有找到感觉，还得看视频学习下。 学习新动作可又有的折腾了，好消息是找到了一个不错的场地，坏消息是又得摔跤啦，希望可以尽快掌握两个动作吧。 日期：2021-12-24距离上次滑行到今天，中途短途滑行过 2 次，可能是上次滑行之后休息了比较长的时间缘故，再次滑行的时候，左脚脚踝没有了之前酸疼的感觉，也明显感觉自己的脚对刃的操控好像更加灵活了，不知道是不是自己太久没有滑了的缘故。 这两次滑行都是短途的，没有去太远的地方，再加上天气变冷、晴天较少的缘故，2 次滑行的时间间隔也比较大，不过都是很轻松的在滑。 第一次主要尝试了一下自己能滑行的最快速度，测试了一下大概是 12 km/h 这样的速度，不过，只测试了一次，两个来回，精准度就不是那么高了。在保持这个速度的过程中，其实感觉人挺累的，因为要保持速度，所以必须要尽可能的半蹲滑行，手也要背在背后，从而降低风阻，这样的后果就是很容易就感觉到累了，而且，滑不了太远就开始喘气了，应该还是我自身体力太弱的缘故，当然也有姿势不标准的原因在内。也许，体力方面可以通过跑步来锻炼一下。 第二次本来想的是随便浪一下，免得受伤，毕竟冬天受伤了不好恢复。没成想，从穿上鞋子开始，一直在尝试跳跃。尝试一番后，轻轻的跳跃好像已经不在话下了，这对跨越一下小障碍物倒是很有帮助；大幅度的跳跃也能跳起来，但是落地的一瞬间会明显有一种站不稳的感觉，可能是速度太快导致的。也许，跳跃落地过程中改变一下与地面接触的刃，可能会使落地更加平稳。后来，又尝试了一下冲坡，没错，就是原来摔了 3 次屁股的那个坡，一共尝试了 2 次。一开始是从坡的中间开始冲下来的，感觉自己很平稳的就下来了，也没减速，并且冲坡带来的速度比较快，而且不用自己费劲，就很舒服。之后再尝试的时候，就直接从坡顶上冲下来了。其实在冲坡之前心里是准备减速下坡的，结果真到了那时候，根本就不能减速，一是因为速度的缘故，贸然减速很可能会一头栽出去；二是我没有在那种情况下稳定刹车的经验。幸运的是，当时的我感觉这个速度是我可以控制的，我感觉我的脚，不，我的鞋子，是可以很好的抓住地面的。结果，毫无减速的直接就从坡上冲了下来，那感觉是真的很舒畅，就好像心提到嗓子眼，然后又回去了一样，我觉着，喜爱极限运动的人在成功挑战一项极限运动的时候应该也是这样的感觉吧，这样才能算是确确实实的是在活着。]]></content>
      <categories>
        <category>Life</category>
        <category>Sport</category>
      </categories>
      <tags>
        <tag>Skating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS 课程下的汇编笔记]]></title>
    <url>%2F2021%2F11%2F11%2FHIT-OS-%E8%AF%BE%E7%A8%8B%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[此文用来记录在进行 HIT_OS 课程时，遇到的一些跟汇编语言相关的问题（纯汇编小白角度）。 注意：以下内容都是 x86 机器下的汇编知识。 entryentry是汇编语言中的伪指令，告诉 cpu 这段汇编程序的入口是什么，一般而言，后面跟的就是汇编程序入口。 movmov是数据传送指令，也是最基本的汇编编程指令，用于将一个数据从源地址传送到目标地址（寄存器之间的数据传送本质上也是一样），其特点是不破坏源地址单元的内容（属于复制性质，不属于搬家性质），基本用法：123! mov dst,src mov EAX,#050aH ;将十六进制数 050a 传送到通用寄存器 EAX 中 mov DI,BX ;寄存器之间传数 注意 mov 的两个操作数不能同时为段寄存器，其他注意事项等内容参考百度百科：MOV。 xor这个没啥说的，异或操作，C 语言中出现过的东西。不过在汇编这里好像用的很多？ ax ah alax 是 cpu 内部一个寄存器助记符，通常称之为累加器。以这门课上的 16 位 cpu 为例，ah（a high） 就是 ax 的高八位，al（a low） 就是 ax 的低八位。通俗来讲，若 ax=1234h，那么 ah=12h，al=34h。对应的，其他寄存器一样也有与其对应的 h 和 l。 intint 应该是汇编中专门用来调用中断的一个指令，后面跟的就是各种各样的“中断码”，不同的“中断码”实现的功能不一样。 基地址与段地址对一个程序而言，基地址就是这个程序被机器执行时机器所需要的“东西”（可以是数据也可以代码段等?）的地址，基地址就是这个这个程序的“段”的起始地址，而机器要拿到这些“东西”就需要段地址。换句话说，基地址其实跟段地址是类似的东西。具体的理解参考百科这个回答：什么是基地址和段地址？主要用途是？ 汇编中的 ## 在汇编中表示立即寻址，举个简单的例子：1mov A,#21H 该指令的意思是将值 21H 送给寄存器 A 中暂存，如果把#去掉，那么意思就是将地址 21H 里面的内容送给寄存器 A 了。 汇编中的 .参考链接：ARM中的汇编指令。 姑且认为.byte、.text这类指令是 GNU 的伪汇编指令。另外，上述文章中还有很多其他指令的介绍，也可以算作参考资料。 x86 下的寄存器参考文章里面写的已经很清楚了，但我们目前需要了解的东西比较简单，就是有多少个寄存器，名字叫什么。8086的编程模型包括 8、16 和 32 位的寄存器,按照位分类： 8 位的寄存器包括 AH，AL，BH，BL，CH，CL，DH 和 DL。 16 位寄存器包括 AX，BX，CX，DX，SP，BP，DI，SI，IP，FLAGS，CS，DS，ES，SS，FS，和 GS。 扩展的 32 位的指令包括 EAX，EBX，ECX，EDX，ESP，EBP，EDI，ESI，EIP 和 EFLAGS。 所有的 32 位寄存器和 16 位寄存器中的 FS 或者 GS 都仅仅能够在 80386 以上使用。 参考文章：Intel 80X86寄存器分类介绍 CFCF 是汇编中的进位标志位，主要用来反映运算是否产生进位或错位。如果运算结果的最高位产生了一个进位或错位，其值就为 1。与之对应的是两个跳转指令： jc 和 jnc，前者当 CF=1 时，跳转，后者反之。 jnc这条语句的功能有点类似 C 语言中的 goto，但它与 goto 不同的地方在于，它需要有一个进位。换句话说，jnc xxx这条语句之前会有运算，运算的结果会影响 CF 的值。当 CF=0 时，它就会产生与 goto 一样的功能，反之，就跳过这条语句，就是 continue 的功能了。 ldslds 指从存储器取出 32 位地址的指令，格式有：lds oprd1, oprd2，其中，oprd1 为任意一个 16 位的存储器，oprd2 为 32 位的存储器。 []汇编中的 [] 表示一种间接的取操作数的方式，有点类似于 C 语言中的指针概念，具体参考下面这个回答：汇编语言加中括号表示什么？ rep movsbrep movsb 其实是两个指令，但是一般是联合起来用的，同时在这条指令之前必然要对 cx 这个寄存器的值进行设置，因为 cx 的值代表了重复多少次。具体的细节可以参考这篇文章：汇编中 rep movsb 字、字节、位字（word）这个概念应该就是针对 cpu 而言的，不严谨的讲，字可能就是 cpu 一次性能处理的指令长度；而字节（byte）是一个存储概念，位（bit）也算是一个存储概念。比如，对 16 位 cpu 而言 1 个字长就是 2 个字节，16 位。所以，不同型号的 cpu ，其字的大小是不一样的，当然了，这样说可能不太严谨。 call这个指令类似 C 语言中的 goto，但是这个指令执行完子程序后要回来，这是二者的区别。详细参考这个回答：汇编语言中的 call 是什么意思]]></content>
      <categories>
        <category>Programming</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS_Basic]]></title>
    <url>%2F2021%2F11%2F10%2FHIT-OS-Basic%2F</url>
    <content type="text"><![CDATA[此系列博文用来记录 MOOC 上自学哈工大操作系统课程（由李治军老师授课）时的笔记。 L1这一节课主要是老师说明学习课程的目的和本课程的要求。另外，就是在实验楼熟悉下实验环境。 L2这一讲老师主要是在说明电脑接通电源后在做些什么事情。 关于组成计算机的五大部件（这又是老生常谈了）：输入设备、输出设备、存储器、运算器、控制器。计算机的工作方式：取指执行，“指”实际上指的是指针，这个指针指向的是位于内存中的命令。这个概念应该贯穿了整个操作系统的设计。 熟悉一下实验楼的基本操作：12345678910111213141516171819202122232425262728293031323334353637383940# 解压文件$ cd oslab$ tar -zxvf hit-oslab-linux-20110823.tar.gz -C /home/shiyanlou/# 编译内核$ cd linux-0.11$ make all # all 可省略，有时需要先 make clean # 运行内核$ cd ~/oslab # 需要再 run 这个脚本文件所在的目录下$ ./run # 执行这条命令后会出现 Bochs 的窗口# 汇编调试$ cd ~/oslab # 同样需要在这个目录下$ ./dbg-asm # 可以使用 help 来查看调试系统的命令# C 语言调试，需要使用两个窗口。# 第一个窗口$ cd \~/oslab$ ./dbg-c# 第二个窗口$ cd \~/oslab$ ./rungdb# 文件交换$ cd ~/oslab$ sudo ./mount-hdc # 先挂载$ cd hdc$ ls -l# 此时看到的文件就是 hdc-0.11.img 这个镜像文件内的文件$ cd ~/oslab$ sudo umount hdc # 读写完毕后要卸载# 1. 注意不要在读写内核文件时运行内核，也不要在运行内核时读写内核内的文件# 2. 关闭 Bochs 之前，要先执行一下 `sync` 保存一下 L3这一讲老师主要讲了操作系统启动时做的两件事： 读入系统 完成初始化 具体如何进行需要借助代码分析。 Experiment 1实验项目 1 的主题是控制系统的启动，主要包含的内容： 阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解； 按照下面的要求改写 0.11 的引导程序 bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序 setup.s。 改写 bootsect.s 主要完成如下功能：bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。） 改写 setup.s 主要完成如下功能： bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。 setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。 改写 bootsect.s这个任务比较容易，因为老师上课的时候大致上讲过了，所以只需要按照老师给的提示来完成就行了。先把实验环境按照上个实验的步骤弄好，解压文件。 先找到 bootsect.s123$ cd linux-0.11/boot/$ ls$ vim bootsect.s 进入 bootsect.s 的编辑页面后能看到 Linus 91年写下的说明，充满了年代感。映入眼中的全是汇编代码，对于不懂汇编的人来说有点难受。不过没关系，找到指定位置然后修改就行。 首先，要修改的文本的位置是在 bootsect.s 文件内的 244 - 247 行处（直接找就行了）：1234msg1: .byte 13,10 .ascii &quot;Loading system ...&quot; .byte 13,10,13,10 改为自己喜欢的即可，这里我们改为：color_os is booting ...。接着我们还需要在修改一下要显示的字符个数，那么该如何找到代码位置呢？可想而知，这段字符串是要在开机的时候显示的，也就是说，开机后的光标干的第一件事情就是显示这串字符，那只要找到读入光标的位置就行了（其实也可以直接用 vim 的搜索功能找到与 msg1 相关的地方就可以了）。 接下来要修改的位置是在 98 行处：1mov cx,#24 上面的这个24实际上就是之前Loading system ...加上 3 个换行符、3 个回车符的和。这里，数一下修改后的字符个数，应该改为 29。 这样就差不多了，来尝试编译运行一下:12$ cd linux-0.11$ make all 没有错误提示就可以尝试运行了。12$ cd ~/oslab$ ./run 观察结果可以发现已经改成想要的结果了。 Review这里我们按照老师给的提示在完成一下这个实验。根据老师的提示，可以写出 bootsect.s 最终的源码：1234567891011121314151617181920212223242526272829entry _start_start:! read cursor pos mov ah,#0x03 ! ah need to be set as 03, so the bios interruption can check it xor bh,bh int 0x10! print the message we set mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ! es need to be set mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 这里再来简单解释一下这段汇编代码（毕竟没学过汇编，就当学汇编了），entry是汇编代码中的伪指令，用来指示汇编程序的入口，显然，在上述代码中，它告诉 cpu 程序的入口是 _start。!后面的内容就是注释，mov、xor这样的“标识符”在汇编里面叫做操作码，后面紧跟的就是操作数，二者之间用空格隔开，操作数之间用,隔开。 bios 0x10 中断根据 ah 的不同的值来发挥不同的功能（其他 bios 中断可能也有）。不同功能需要的输入与返回都是不想同的，这部分的内容的疑问可以查询老师给的手册上的注释，也可以直接查 bios 中断的手册。 之所以要改动寄存器 es 的值，是因为 0x10 中断规定了 es:bp 是字符串的首地址（也就是起始位置），也就是说，只有 bp 的值是无法让机器显示字符串的。 info_loop是利用 jmp 指令设置的一个循环，这条指令会让机器一直执行这个循环。如果没有这条指令，机器就会去寻找下一个能启动的设备。 .org也是汇编中的伪指令，它告诉 cpu 下面的语句从地址 510 处开始执行，相比原本的内核代码，这里舍弃掉了root_dev，所以需要将地址设置为 510，这样当我们将磁盘引导扇区（共 512 字节）的最后两个字节设置为 0xAA55 时，机器读取到这里就会知道这个扇区是引导扇区了（是如何读的，这里就不解释了）。最后的 boot_flag就是启动标志的字面意思了，可想而知，后面跟的就是 0xAA55。可以猜测一下，这几行代码应该是后续工作做的准备。 搞定源码后，就可以开始编译内核运行检查一下运行结果了。以 Linux 为例，进入linux-0.11/boot目录下要编译和链接 bootsect.s 就要执行下面的命令：12as86 -0 -a -o bootsect.o bootsect.sld86 -0 -s -o bootsect bootsect.o 别急着去运行内核，先用ls -l命令检查下编译好的文件的大小。可以发现，bootsect 的文件大小是 544 字节，但是引导程序必须要正好占用一个磁盘扇区，即 512 字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件除了文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部，而这个文件的头部正好多了 32 个字节。 在 linux 下需要将文件大小改为 512 字节，也就是删掉头部，所以需要借助命令：12dd bs=1 if=bootsect of=Image skip=32cp ./Image ../Image 之后在 oslab 目录下，运行 run 脚本：1$ ./run 就可以得到这样的结果： 改写 setup.s先分析一下要求： 利用 setup.s 向屏幕输出一行“Now we are in SETUP” 利用 setup.s 获取基本硬件参数，这个内核本身就已经读了内存数 setup.s 不再加载 linux 内核，保持上述信息显示在屏幕上即可，这里可能会用到中断 先看第一条要求，这个跟前一个任务完成得事情是类似的，需要找到光标位置，然后打印即可。 尝试了一下，将 bootsect.s 内与光标和打印文字相关的代码抄到了 setup.s 这个文件对应读光标的位置，结果并不顶用。突然想到，是不是打印完一行字符后再将光标位置移动到行首呢？于是又在抄过来的代码下面补上了读光标位置的代码，结果还是不行，果然，不懂汇编，单纯的靠 Ctrl + C/V，还是不行，索性看下老师给的提示。 看了老师的提示，才发现老师讲的“改写”跟我理解的“改写”含义不是一样的。老师是直接从新写一个能完成任务的 bootsect.s 和 setup.s 文件，而我是直接改现成文件，水平过低，过低，2333。不过回过头来想一下，如果只是单纯完成实验，那么确实不需要读取那么多系统信息，也不需要系统完全启动，只要显示了需要的东西即可。既要显示文本，又要内核完好的启动，反而需要的知识量更多，这对初学者而言反而是不利的。好吧，理直气壮的安慰了自己，下面在按照老师给的思路来做一下。 根据老师给出的思路，可以很容易的完成这个实验的第一个任务，具体请看上文 Review。 下面我们首先让 setup.s 完成第一个子任务：向屏幕输出“Now we are in SETUP”。这个任务与 bootsect.s 干的事情很类似，事实上，我们还真的就只需要将前面下好的 bootsect.s 抄过来再修改一下就好了，改好后：123456789101112131415161718192021entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg2: .byte 13,10 .ascii &quot;Now we are in SETUP&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 因为 es 的值在 bootsect.s 已经改过了，所以这里要改回来，直接借助 cs 这个段寄存器。至于为什么能借助 cs 段寄存器达到我们的目的，是因为 cs 是保存微处理器执行代码的内存段，cs（代码段寄存器）持有段的起始位置，也就是我们需要的 0x07c0。这里，也不得不说，怪不得 cpu 里面要搞这么多寄存器的，其实都是用的着的，就是着实难记😓。还有一个需要注意的地方，就是 bootsect.s 已经用过 msg1 这个标识符了，这里需要用 msg2 了。 在编译 setup.s 之前，还需要做一件事情，那就是让 bootsect.s 读入 setup.s。那么如何读入 setup.s 呢？其实就是使用 0x13 中断，可以发现到目前位置我们都是通过 bios 中断在达到我们想要的结果。现在看来，bios 中断就像是可供使用的一个工具一样（事实上，它本身就是如此）。 那么跟着老师的思路，我们可以得到修改后的 bootsect.s 的源码：12345678910111213141516171819202122232425262728293031323334SETUPLEN=2SETUPSEG=0x07e0entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup mov dx,#0x0000 mov ax,#0x0000 int 0x13 jmp load_setupok_load_setup: jmpi 0,SETUPSEGmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 再来简单解释一下这段代码，0x13 中断对 ah、al、bh、bl、ch 和 cl 的值有要求，所以在调用它之前，要先得到我们想要的值。在 linux-0.11 的 bootsect.s 文件中，SETUPLEN 的值为 4，代表了 4 个扇区，这里我们只读 2 个，所以 SETUPLEN 的值在开头设置为 2。jmp load_setup是在末尾设置的循环，如果载入失败就会从头开始。 载入成功后，会跳转执行 setup.s。此时，需要先搞清楚 setup.s 在哪里，通过前面调用 0x13 中断可知我们将 setup.s 放在了 0x07c0 的后 2 个扇区。而 bootsect.s 本身占 1 个扇区，所以 SETUPSEG 需要设置为 0x07e0，就是 0x07c0 加了 512 字节（1 个扇区）后的地址，这样就完成了从 bootsect.s 到 setup.s 的跳转。 源码完成后就可以编译运行检查结果了。但现在有 2 个文件需要编译、链接。如果都手动编译，就太慢了，所以借助 Makefile 是最佳方式。 进入linux-0.11目录后，使用下面命令：1make BootImage 此时会看到下面的错误：12Unable to open &apos;system&apos;make: *** [BootImage] Error 1 有 Error！这是因为 make 根据 Makefile 的指引执行了tools/build.c，build.c 是为生成整个内核的镜像文件而设计的，而我们却只需要编译 bootsect.s 和 setup.s 。它在向我们要 “系统” 的核心代码。为完成实验，需要给它打个小补丁。 build.c 的工作原理从命令行参数得到 bootsect、setup 和 system 内核的文件名，将三者做简单的整理后一起写入 Image。其中 system 是第三个参数（argv[3]？）。当make all或者makeall的时候，这个参数传过来的是正确的文件名，build.c 会打开它，将内容写入 Image。而make BootImage时，传过来的是字符串 none。所以，改造 build.c 的思路就是当 argv[3] 是 none 的时候，只写 bootsect 和 setup，忽略所有与 system 有关的工作，或者在该写 system 的位置都写上 “0”。 要达到上述效果，我们只需要将 build.c 中第 178 - 190 行注释掉即可。 然后再进入到~/oslab/linux-0.11目录下，执行下面的命令：12make BootImage../run 就可以得到下面的结果： 可以发现这个结果跟之前 bootsect.s 产生的结果是类似的，原因就是因为这里的 setup.s 完全就是复制的 bootsect.s。 现在，再来解决最后一个任务：利用 setup.s 获取硬件参数，保存并输出到屏幕上，且不再加载内核。]]></content>
      <categories>
        <category>CS</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>HIT_OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 零散知识]]></title>
    <url>%2F2021%2F10%2F19%2FLinux-%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一些容易忘记且与 Linux 相关的一些实用知识，方便自己查询。 zsh 的一些快捷键 按键 作用 Ctrl + d 键盘输入结束或退出终端 Ctrl + s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl + z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl + a 将光标移至输入行头，相当于Home键 Ctrl + e 将光标移至输入行末，相当于End键 Ctrl + k 删除从光标所在位置到行末 Alt + Backspace 向前删除一个单词 Shift + PgUp 将终端显示向上滚动 Shift + PgDn 将终端显示向下滚动 Shell 常用的通配符 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [^list] 匹配除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1 - c2 中的任意单一字符，如：[0-9][a-z] {string1, string2, …} 匹配 string1 或 string2 （或更多）其一字符串 {c1..c2} 匹配 c1 - c2 中全部字符，如：{1..10} 系统日志文件 日志名称 记录信息 alternatives.log 系统的一些更新替代信息 apport.log 应用程序崩溃信息 apt/history.log 使用 apt-get 安装卸载软件的信息记录 apt/term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等 auth.log 登录认证的信息记录 boot.log 系统启动时的程序服务的日志信息 btmp 错误的信息记录 Consolekit/history 控制台的信息记录 dis-upgrade dis-upgrade 这种更新方式的信息记录 dmesg 启动时，显示屏幕上内核缓冲信息，与硬件有关的信息 dpkg.log dpkg 命令管理包的日志 faillog 用户登录失败详细信息记录 fontconfig.log 与字体配置有关的信息记录 kern.log 内核产生的信息记录，在自己修改内核时有很大帮助 lastlog 用户的最近信息记录 wtmp 登录信息的记录，wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 syslog 系统信息记录]]></content>
  </entry>
  <entry>
    <title><![CDATA[料理随记]]></title>
    <url>%2F2021%2F09%2F07%2F%E6%96%99%E7%90%86%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想不到自己接近一年没有更博后，再次更博的第一篇文章会是这个主题。不过反正也没有人看，权当是自己记录用的也可。 目前掌握的料理没有那么多，对烹饪的研究也不太深，索性就不分的太清楚了，直接记录下需要的大概信息即可。 酸辣土豆丝这道菜估计是很多人学会的第一道菜了，不过我好像已经忘记了第一个会做的菜了。 酸辣土豆丝要想炒好，土豆丝一定要切成“丝”。当然了，也不是说一定要跟米粉一样细，粗细适中，像火柴梗那个大小即可，略大也行，所以要熟练的使用菜刀，切记小心不要切到手指了。切好后的土豆丝，不要直接暴露在空气中，否则土豆丝的颜色会变灰，所以要放置在有水的碗中泡着。 一般而言，有些地方这道菜是不放青椒的。而为了有辣味，一开始起锅少烧好油后，蒜和干辣椒爆香后，就直接下土豆丝了。另外，为了维持土豆丝的白色（或者米黄色），多用白醋调味，而不是陈醋。 （依稀记得，母亲炒土豆丝时，辣味是加了豆瓣酱来的，并没有放干辣椒，这可能是我家的吃法。） 清炒西兰花这道菜在真正开始炒之前准备工作比较多。先是西兰花的处理，用刀去除老根，并将大朵西兰花改成小朵，洗净。然后，往锅内加水，水面稍为可以宽一点，待锅中水烧开后，将西兰花倒入锅中。注意焯水时间不要过久，否则一来会使西兰花的口感变老、变软，二来会使西兰花中的营养物质流失。 接着，起锅烧油，下蒜爆香，再倒入西兰花翻炒，加入盐、鸡精、白醋等调味料。由于之前进行了焯水这个步骤，所以这时，不要炒太久，闻到香味，差不多就可以出锅了。 当然了，说是清炒，并不是完全不加其他配菜了。为了菜色，可以加入适量的木耳和红椒丝来点缀（二者可以与西兰花一同焯水），为了增鲜，也可以在出锅前加入少许蚝油，翻炒均匀后再出锅。 清炒上海青这道菜的做法跟清炒西兰花类似（清炒青菜基本都是这样），可以提前焯水也可以不提前焯水。上海青的菜根尽量去除的彻底一点，这样吃起来会感觉嫩一些。为了避免油烧热后，直接下蒜爆香过度导致的蒜变黑、变糊，可以先放入上海青，稍微翻炒一会后，再下蒜，等到有蒜香了后，再出锅。 红烧鸡翅先将鸡翅改花刀，然后冷水下锅焯水，可以加入少许姜片与盐，待鸡翅差不多熟了后，捞出备用。然后倒出锅内的水，将锅内的肉沫清洗干净后，倒入适量的油。待油烧热后，下入蒜、姜爆香，此时可以小火慢烧，煸出香味后，开始加入酱油、醋、盐等其他调料。这里，我们使用豆瓣酱来使菜色变红。 待国内汤汁开始收汁后，加入之前备好的鸡翅，小火慢炖。出锅前，可以再加入少许青椒点缀菜色。 白灼基围虾这道菜分两个部分，一个是对虾的处理，另一个是如何调理蘸汁。 虾的处理同样包括两个部分，第一个是活虾的清洗，去掉虾头、虾脑、虾线等。第二个就是将虾煮熟，先烧开水，然后再将虾下锅。之所以要烧开水再下锅，是为了减少煮虾的时间，以免虾肉口感变老；同时，开水中可以加入适量的盐、生姜、料酒用来去除虾的腥味。大概煮 5 - 10 分钟左右，虾身变红后就可以捞出了。 蘸汁的处理不作细说，虽说这道菜是道粤菜，但我们是家常做法，所以按照自己的口味来调即可，建议少许酱油、陈醋、蒜蓉、糖、盐即可，糖、盐也可单独只加一种。若是喜欢吃其他的调味料（芥末？），也可以自己加。 土豆炖鸡块这道菜中的“鸡块”一定要选肉多的部位，推荐鸡大腿胯子，改成小刀，加盐腌制一定时间，也可以加入定量的生粉，使肉质更加鲜嫩，避免鸡肉口感较“面”。 倒入适量的油，先将鸡块炸熟，然后再加入老抽上色，继而加入蒜、姜、酱油、豆瓣酱、花椒等其他调料，等到菜色、菜香都出来后，加入适量的清水，盖上锅盖。稍微煮一会后，倒入土豆，先大火煮。观察土豆成色，差不多熟了后，改小火煮，此时汤汁开始收汁，可以再加入切好的青辣椒，用以调配菜色。将青辣椒翻炒出味后，即可出锅。 青椒肉丝先将猪肉洗净，然后切成丝。猪肉要想切的丝够细，大致注意 2 个点： 横切牛羊竖切猪，要顺着猪肉的纹理切，即刀和肉的纹理呈水平线 要想切丝，先要切片，片打的爆，丝就够丝（这跟切土豆丝是一样的） 切好的猪肉加入食盐、生粉（也可加入其他的调料，只要好吃皆可）腌制 10 - 20 分钟左右，期间可以准备好蒜、姜、干辣椒、青椒丝等。然后烧油，油温大概到八成，肉丝即可下锅，七八成熟后，加入蒜、姜、干辣椒。炒出香味后，再加入豆瓣酱、酱油、盐等调料，让菜色更亮，味道更鲜。此时，可以加入少许清水，以免火大糊锅。最后加入青椒丝，快速炒出味后，即可出锅。 糖拌西红柿挑几个成熟的西红柿，洗净。如果不喜欢吃皮，可以先在西红柿表面改一个大的十字花刀，然后用开水泡个 3 - 5 分钟左右，然后就可以轻易的撕掉表皮了。然后在将处理好的西红柿改成一页一页的形状，摆放在盘中后，撒上白糖即可。如果不是那么喜欢吃酸的，可以先将改好的刀的西红柿用少量盐腌制几分钟，然后再摆盘撒上白糖。 小葱拌豆腐挑一块完好的嫩豆腐块，切成一个个小正方体形状，待锅里水烧开后，再将豆腐下入过锅中焯水，锅中可以加入适量的盐，可能会使豆腐的口感更加紧致。熟后，盛入盘子中。此时，可以向盘子中加入调味料，锅里开始烧油。这道菜有人谁是东北菜，有人说是鲁菜，个人觉得像是鲁菜。而在鲁菜中，这道菜貌似味不是很重，所以一般不加酱油，大概只放盐、鸡精、白醋、香油。调味料加油后，撒上葱花，将锅里烧好的油淋到葱花上，在滴上几滴香油，很香。 酸辣大白菜选取新鲜白菜，菜叶太大的话可以用刀改小一点，洗净，放置一旁备用。准备一定量的蒜末，这道菜的辣味可以用干辣椒来调，也可以使用小米椒。先下辣椒跟蒜末炝锅，然后下白菜翻炒，期间可以加入一点清水。待白菜差不多熟了后，快速加入鸡精、盐、醋等调味料，翻炒均匀后，即可出锅。 肉沫茄子肉沫茄子的肉沫可以用纯瘦肉，也可以用五花肉的肉沫，一般肉店会直接卖肉沫，也可以买肉回来后自己剁，多出来的肉沫也可以用来包饺子。茄子可以选用紫皮茄子，一般不去皮，也可以选用青皮茄子，一般要去皮。先将茄子下锅炒软炒，盛出备用。然后将肉沫炒散，期间可以放入蒜末、生抽等调料，待肉沫炒好后再加入茄子，再加入盐、醋等调味料，翻炒均匀即可出锅。 手撕包菜这道菜跟炒酸辣大白菜累死，如果不想吃辣，可以不放辣椒，加入蒜末即可。在快要出锅的时候，可以加入适量白糖，使包菜吃起来更加鲜。 辣子鸡丁鸡丁的选材有两种： 鸡脯肉 鸡大腿肉 建议选择鸡大腿肉来做。如果选用鸡大腿肉来做，那么就需要对鸡大腿去骨，然后再将肉切丁，注意肉丁要切小一点（不要像下图中这么大）。切好后，用生粉、鸡蛋清、盐腌制一小会。在此期间，可以准备姜、蒜、花椒、干辣椒、青椒等。起锅烧好油后，下入鸡丁，注意不要让鸡丁粘连再一起。然后加入蒜、姜、花椒、干辣椒，炒出味，接着，加一小勺豆瓣酱炒出红油，加一点清水用作汤汁，再加入适量生抽。最后下入切成块状的青椒，将青椒炒出味即可出锅。 紫菜蛋花汤先将紫菜洗净，然后放置一旁备用。切好蒜末，起锅烧油，先下蒜末炝锅，然后加入清水，此时可以加入一定量的调味料。再将鸡蛋打入碗中，搅拌均匀。等锅里的水差不多烧开后，加入紫菜，搅拌散开，然后再倒入蛋液，注意为了避免蛋凝结成块，要将蛋液迂回倒入锅中，并用锅铲不断搅拌。大概锅过 1 - 2 分钟，蛋熟了，加入适量调味料后即可出锅。 这道菜可以放适量的虾皮，会使得汤味更加鲜美，当然不喜欢吃虾皮的也可以不放。 回锅肉挑一块上好的五花肉，最好肥瘦相间。买肉的时候记得让师傅去掉猪皮上的毛。一般而言，五花肉是不用去皮的，但猪毛还是要去除干净。将五花肉洗净后，放入锅中焯水，冷水下锅，可以加入姜片、葱、料酒、盐等来去腥，并使肉的口感紧实，期间要捞出锅中水上的浮沫。用一根筷子，能插到五花肉中时，就可以捞出锅了。快速用冷水冲一边，趁外冷内热，将五花肉切成薄片，不喜欢吃太多肥肉话，一定要尽量的切薄点。切好后，放在盘子中备用。准备好蒜苗、青椒、姜、蒜末，起锅烧油，下入蒜末、姜煸香，再下入肉片煸炒至肉片颜色变透明，边缘略微卷起。然后再加入豆瓣酱，炒出红油，再加入少许酱油调色，与肉片一起翻炒均匀。最后再下入蒜苗、青椒，快速翻炒，加入盐、醋等调味料即可出锅。 喜欢吃辣、麻的话，可以干辣椒、花椒与蒜末、姜一同下锅煸香，然后再炒肉。 萝卜烧鸡块这又是一道家常菜，做法其实与土豆钝鸡块差不多，但要注意萝卜要比土豆易熟，所以焖的时间不能太长，不然萝卜烂了就不好吃了。另外，之所以要用萝卜当配菜，其实是因为冬天到了，多吃萝卜，可以补充身体的水分，补气通肺。PS：下面的图片用的汤碗装的，看像着实不好，还是用盘子好。 黄瓜炒蛋这也是一道很常见的家常菜，备料过程就不细说了。先将搅拌均匀的蛋液倒入已烧到七、八成热的油锅中，使蛋成块变熟（这个表达有点怪，知道是什么意思就行），然后在倒入黄瓜，大火翻炒，注意锅中需要有点水分，可以适当加点水，边炒边加入调料，不一会便可出锅了。一般而言，这道菜里面还可以加入黑木耳来点缀菜色，好像也可以略微减少一点鸡蛋的腥味？同时，还可以加入一点蚝油，使菜的味道更加鲜美，或者单纯加点糖也可以，如果不喜欢加太多调味品，也可以不加。]]></content>
      <categories>
        <category>Life</category>
        <category>Cooking</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_03]]></title>
    <url>%2F2020%2F09%2F28%2FNand2Tetris-Part1-03%2F</url>
    <content type="text"><![CDATA[本周的主题是 Memory，先把做好的 ALU 放一边，我们来研究一下和内存（RAM）有关的问题。 Unit 3.1 Sequential Logic本小节主要在引出新的概念：顺序逻辑（Sequential Logic）、时间等，另外也指出了顺序逻辑与前两周所学的组合逻辑（Combinational Logic）的不同。换句话来讲，这周考虑的问题会更加贴近现实生活一点。 Unit 3.2 Filp Flops本小节介绍了本周内容所使用的最基本单元：Data Flip Flops（DFF），并说明了它的功能；接着继续讲解了内存的基本单元 1-Bit Registers，着重在说明它的运行过程。 Unit 3.3 Memory Units本小节介绍了内存单元（Memory units）的一些特点，并通过软件模拟了 RAM8 的运行过程。需要注意内存是一个具有时间属性的硬件单元，这个课程提到的内存单元是通过上面提到的 DFF 来“展现”时间功能的（实际不清楚，但是 DFF 确实是有这个功能的）。也就是说，在某个时刻，内存单元上的寄存器的电信号改变后，内存单元的输出依然不变，下一个时刻后，内存单元的输出才会改变。 同时，老师还提到了寄存器的地址和寄存器数量的关系，也就是 2 的对数关系。比如，RAM8 内部有 8 个 Register，那么就可以用 3 个 bit 来表示这 8 个 Register 的序号，也即：000、001、010、011、100、110、101 和 111，这个数字其实也就是内存的地址，这应该就是内存地址概念的由来了。 Unit 3.4 Counters本小节介绍了计数器（Counters）的一些功能和机制，包含 3 个方面： 能将值重置为 0。 能将值随着时间递增，且每 1s 增加 1。 能输出上一个时刻设置的值。 Unit 3.5 Project 3 Overview本周作业需要实现 7 个与内存相关的芯片和 1 个计数器，针对各个芯片的实现，老师给出了若干提示，而我们将会以 DFF 为 primitive chip 来构建另外 8 个芯片。 Bit这个老师已经讲过了，直接用 1 个 Mux 和 1 个 DFF 就可以实现，但是还额外需要一个 Mux 来帮助输出（不用 Mux，用其他的也可以）。123456789CHIP Bit &#123; IN in, load; OUT out; PARTS: Mux(a=t2, b=in, sel=load, out=t1); DFF(in=t1, out=t2); Mux(a=t2, b=true, sel=false, out=out);&#125; Register按照提示，直接用 16 个 Bit 叠加在一起就可以了。但是要注意一下时间的概念，也即这 16 个 Bit 是都处于工作状态的，尽管有些 Bit 的值可能并没有改变。12345678910111213141516171819202122CHIP Register &#123; IN in[16], load; OUT out[16]; PARTS: Bit(in=in[0], load=load, out=out[0]); Bit(in=in[1], load=load, out=out[1]); Bit(in=in[2], load=load, out=out[2]); Bit(in=in[3], load=load, out=out[3]); Bit(in=in[4], load=load, out=out[4]); Bit(in=in[5], load=load, out=out[5]); Bit(in=in[6], load=load, out=out[6]); Bit(in=in[7], load=load, out=out[7]); Bit(in=in[8], load=load, out=out[8]); Bit(in=in[9], load=load, out=out[9]); Bit(in=in[10], load=load, out=out[10]); Bit(in=in[11], load=load, out=out[11]); Bit(in=in[12], load=load, out=out[12]); Bit(in=in[13], load=load, out=out[13]); Bit(in=in[14], load=load, out=out[14]); Bit(in=in[15], load=load, out=out[15]);&#125; RAM8根据讲解，RAM8 内部包含了 8 个 Register，每个 Register 都可以存储数字，根据特定的地址（address）进行控制（包括写入值、清除值）。设计这个芯片的难点在于如何根据地址来操作 Register，这与第二单元设计 ALU 是一样的难点。第二单元，解决这个问题的方式是用 Mux 来选择不同的寄存器进行输出。而这里，涉及到选址和输入，需要使用 DMux 来进行选址和输入，通过 Register 后，再用 Mux 进行输出。因为 RAM8 内部包含了 8 个 Register，所以选用 DMux8Way 来处理选址和输入，再用 Mux8Way16 来输出指定地址的 Register 的值。123456789101112131415161718CHIP RAM8 &#123; IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address, a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); Register(in=in, load=load0, out=u0); Register(in=in, load=load1, out=u1); Register(in=in, load=load2, out=u2); Register(in=in, load=load3, out=u3); Register(in=in, load=load4, out=u4); Register(in=in, load=load5, out=u5); Register(in=in, load=load6, out=u6); Register(in=in, load=load7, out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address, out=out);&#125; RAM64有了前面的思路后，RAM64 实际上就是 8 个 RAM8 堆叠在一起。不过此时的地址需要用 6 位二进制数来表示，其中前 3 位用来表示是那一块 RAM8，后 3 位用来表示是这块 RAM8 上的哪一个 Register（实际上也就是总线宽度从 3 升级到了 6）。123456789101112131415161718CHIP RAM64 &#123; IN in[16], load, address[6]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM8(in=in, load=load0, address=address[3..5], out=u0); RAM8(in=in, load=load1, address=address[3..5], out=u1); RAM8(in=in, load=load2, address=address[3..5], out=u2); RAM8(in=in, load=load3, address=address[3..5], out=u3); RAM8(in=in, load=load4, address=address[3..5], out=u4); RAM8(in=in, load=load5, address=address[3..5], out=u5); RAM8(in=in, load=load6, address=address[3..5], out=u6); RAM8(in=in, load=load7, address=address[3..5], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM512同理，RAM512 实际上就是 8 个 RAM64 堆叠在一起。对应的，现在需要 9 位二进制数来表示地址了，也就是总线宽度扩展到了 9。123456789101112131415161718CHIP RAM512 &#123; IN in[16], load, address[9]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM64(in=in, load=load0, address=address[3..8], out=u0); RAM64(in=in, load=load1, address=address[3..8], out=u1); RAM64(in=in, load=load2, address=address[3..8], out=u2); RAM64(in=in, load=load3, address=address[3..8], out=u3); RAM64(in=in, load=load4, address=address[3..8], out=u4); RAM64(in=in, load=load5, address=address[3..8], out=u5); RAM64(in=in, load=load6, address=address[3..8], out=u6); RAM64(in=in, load=load7, address=address[3..8], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM4K同理，RAM4k 实际上就是 8 个 RAM512 堆叠在一起。对应的，现在需要 12 位二进制数来表示地址了，也就是总线宽度扩展到了 12。123456789101112131415161718CHIP RAM4K &#123; IN in[16], load, address[12]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM512(in=in, load=load0, address=address[3..11], out=u0); RAM512(in=in, load=load1, address=address[3..11], out=u1); RAM512(in=in, load=load2, address=address[3..11], out=u2); RAM512(in=in, load=load3, address=address[3..11], out=u3); RAM512(in=in, load=load4, address=address[3..11], out=u4); RAM512(in=in, load=load5, address=address[3..11], out=u5); RAM512(in=in, load=load6, address=address[3..11], out=u6); RAM512(in=in, load=load7, address=address[3..11], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM16K同理，RAM16k 实际上就是 4 个 RAM4K 堆叠在一起。对应的，现在需要 14 位二进制数来表示地址了，也就是总线宽度扩展到了 14。1234567891011121314CHIP RAM16K &#123; IN in[16], load, address[14]; OUT out[16]; PARTS: DMux4Way(in=load, sel=address[0..1], a=load0, b=load1, c=load2, d=load3); RAM4K(in=in, load=load0, address=address[2..13], out=u0); RAM4K(in=in, load=load1, address=address[2..13], out=u1); RAM4K(in=in, load=load2, address=address[2..13], out=u2); RAM4K(in=in, load=load3, address=address[2..13], out=u3); Mux4Way16(a=u0, b=u1, c=u2, d=u3, sel=address[0..1], out=out);&#125; PCProgram Counter，简称 PC，直译就是程序计数器。这个小芯片真的想了很久都没有什么思路...准确来讲，不是没有构造的思路，而是不知道怎么用 HDL 语言来描述。没办法，只好阅读一下别人写的代码了，结果发现，大家好像在这里都有点问题，hha~🤣。回过头来，一开始不知道怎么写，只能翻老师给的资料，看看能不能找到点思路。没想到还整的找到了，就是书上第写的： Counter A w-bit counter consists of two main elements: a regular w-bit register, andcombinational logic. The combinational logic is designed to (a) compute the counting function, and (b) put the counter in the right operating mode, as mandated by the values of its three control bits. Tip: Most of this logic was already built in chapter 2. 仔细看最后一行：Tip: Most of this logic was already built in chapter 2.，原来第二章就做过了。再仔细一想，在做 ALU 的时候面对的也是类似的问题，那时是通过 Mux 来挑选出来合适的值进行输出的，那么用到这里应该也是可以的。 可是又该如何实现循环计数的功能呢？回想一下循环的过程，即上一次的结果作为这一次的初始值。那么在 HDL 里面是不是也可以这样写呢？答案是可以的（总觉得这样写有语法错误😂）。那么正常输出的值与循环递增的值又该如何保存呢？难道保存在一个 Register 里面？然后又开始没有思路了，直到又看到了别人文章里面的： Multiple OutputsSometimes you need more than one sub-bus connected to the output of a chip-part. Simply add more than one out= connection to the chip-part definition.CHIP Foo { IN in[16]; OUT out[8]; PARTS: Not16 (in=in, out[0..7]=low8, out[8..15]=high8); Something8 (a=low8, b=high8, out=out); }This also works if you want to use an output of a chip in further computations.CHIP Foo { IN a, b, c; OUT out1, out2; PARTS: Something (a=a, b=b, out=x, out=out1); Whatever (a=x, b=c, out=out2); } 原来单独的某个芯片是可以有两个输出的（out）的...最终，费了一番功夫后得到的通过代码：1234567891011CHIP PC &#123; IN in[16],load,inc,reset; OUT out[16]; PARTS: Inc16(in=prevalue, out=u1); Mux16(a=prevalue, b=u1, sel=inc, out=u2); Mux16(a=u2, b=in, sel=load, out=u3); Mux16(a=u3, b=false, sel=reset, out=u4); Register(in=u4, load=true, out=out, out=prevalue);&#125; Unit 3.6 Perspective这周的问题： 这周用 DFF 构建了其他的芯片，把 DFF 当作了拥有某种功能的黑盒子，那么它实际上是怎么构成的呢？ 大胡子老师解释说这不是我们这门课要教的内容（笑死😂），因为通过构造其他的芯片就可以学习到组合逻辑电路与时序逻辑电路的差别，所以要把重点放在构造其他的芯片上。不过，大胡子老师还是回答了这个问题，用两个 NAND 构造了一个 DFF。另外，NAND 也不是唯一用来构建内存系统的基础理论。 电脑只使用 RAM 作为内存设备吗？ 显然不是，还有 ROM、Flash Memory 和 Cache Memory。ROM 全称 Read Only Memory，是一种断电后也不会损失信息的存储设备（比如硬盘）；而 Flash Memory 则是介于 RAM 和 ROM 之间的存储设备，它的速度快于 ROM，慢于 RAM，但它的容量大于 RAM，小于 ROM，算是存储速度和空间的折中产物（比如 Mac 的闪存，手机的闪存）；最后是 Cache Memory，这个东西就是 CPU 的缓存。 这周的难点跟上周类似，用“电子语言”来构造循环、条件等复杂逻辑是真的难。第一个想到这些想法的人，真的是神来之笔，创造性太强了，估计这些发明家当时也没有想到曾经的逻辑电路能演变成现在的电脑吧。]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扒谱记录 - Homesteaders]]></title>
    <url>%2F2020%2F09%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-Homesteaders%2F</url>
    <content type="text"><![CDATA[《Homesteaders》是由 Joanie Madden 用哨笛演奏的一首凯尔特风格的曲子，是一首十分纯净的轻音乐。 Homesteaders - Joanie MaddenYour browser does not support the audio tag. 晚上弹琴的时候，脑海里突然响起了这首曲子的旋律，伴随着脑海内的旋律，眼前的景色好像又回到了高中时代。想到那时的自己，鬼使神差的找了一本言情小说读（可能是耐不住枯燥的学习生活吧，为什么不读科幻小说呢？？？）。一边读，一边听着这首曲子。最后，小说读完了，这首曲子也听了一遍又一遍。小说的情节现已难以回想起来了，但那时的自己流露出的些许感情却随着这首曲子的旋律一遍又一遍的刻进了自己的脑海。 其实，高中时代结束后，脑海就已经多次响起了这段熟悉旋律，可自己让它停留在脑中的时间不会超过 10 秒，索性这次让它停留的久一点。然后，用吉他试着弹了一下，还挺像的。随后找到原曲，听了几遍，不一会主旋律就扒出来了，记录下来，免得自己忘了。 这样的话，再过几年后的自己偶尔看到这些东西的时候，也许心中还能留有一丝感动吧！ 自扒谱：[5]1231[5] [6]123155(1)76 54345112316532123[6]123211[6] [5][5][6]12123211[6] [5][5][6]11(1)767(1)6 5452431236335321232(1)767(1)6 54524312363321[6] [7][]：降八度 ()：升八度]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_02]]></title>
    <url>%2F2020%2F09%2F21%2FNand2Tetris-Part1-02%2F</url>
    <content type="text"><![CDATA[本周的主题是 Boolean Arithmetic and the ALU Roadmap，旨在介绍如何构建加法器（adder）和算术逻辑单元（Arithmetic Logic Unit，ALU），学习路线依然还是从简单到复杂。 Unit 2.1 Binary Numbers本小节主要在说明二进制与十进制的一些联系，粗略介绍了一下进制转换的过程，但没有说明具体的方法。学过一门编程语言课的同学，肯定对这些都已经很熟悉；没学过的，老师讲的也很清晰。 Unit 2.2 Binary Addition本小节主要在介绍二进制加法规则，本质上与十进制是一样的。但由于二进制算术存在位数（bits）的限制，所以会产生溢出（overflow）的问题，老师暂时没有讲具体的解决办法，只说明了，在计算机内是会直接忽略掉的，但是使用者必须知道溢出了。接着，又由易到难的介绍了三种加法器，并大致说明了一下构造的方法，这也是本周的作业之一。 Unit 2.3 Negative Numbers前面介绍的规则都是与正数相关的，而本小节主要在介绍在计算机中如何表示负数，老师主要介绍了两种表示方法： 用最前面的 1 位（1 bit）代表符号，为 0，则为正数，为 1，则为负数，二者绝对值相等。这样表示会有一个问题，那就是会产生正 0 和 负 0，这样在做加、减法时会产生问题，所以舍弃了这种方法 用 $2^N + (-x) = 2^N - x$ 来表示负数，其中 -x 就是要表示的负数，这样表示后就没有负 0 了，且在做加、减法时也是完全正确的。 说点题外话，上面的几小节内容对应了组成原理中有关数的表示部分，提到的一些方法，其实就是原码、补码（radix complement）和反码的概念，可能是老师为了照顾非计算机专业的学生，一点没提这些东西，也有可能是国外讲课的风格导致了老师不会硬讲这些概念性的东西吧。 Unit 2.4 Arithmetic Logic Unit本小节主要在介绍后面要构建的计算机 Hack 的 ALU 是如何构建的。首先是对此 ALU 的基本介绍，包括其输入、输出、控制位（control bits），注意其控制位有两类，有 6 个算是功能控制位，剩下两个是输出控制位，且并没有说明输出控制位存在的意义。接着，说明了如何使用硬件模拟器来使用模拟 ALU 的一些功能，在这一块，如果对 ALU 的运算过程不清楚可以使用内置的（built-in）ALU 来熟悉一下过程。最后，举例验证了 ALU 能逐一实现所要求功能的可靠性，但老师没有介绍具体的原理，想了解就得自己看资料了。还剩下的最后一点是在说明 Hack ALU 的优点，通俗来讲其实就是一点：易于学习。 Unit 2.5 Project 2 Overview本小节主要在介绍这周的作业，并给出了一些提示信息。尽管在第一周已经实现了很多 chips，但是老师建议不要使用自己实现的 chips，直接使用软件自带（built-in）的 chips，原因是为了避免软件可能会产生的卡顿等情况。下面我们就来开始完成这周的作业。 HalfAdder按照老师给的提示，直接用 Xor 和 And 来实现就完事了。123456789CHIP HalfAdder &#123; IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry);&#125; FullAdder12345678910CHIP FullAdder &#123; IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, sum=s1, carry=v1); HalfAdder(a=s1, b=c, sum=sum, carry=v2); Or(a=v1, b=v2, out=carry);&#125; Add1612345678910111213141516171819202122CHIP Add16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: HalfAdder(a=a[0], b=b[0], sum=out[0], carry=c1); FullAdder(a=a[1], b=b[1], c=c1, sum=out[1], carry=c2); FullAdder(a=a[2], b=b[2], c=c2, sum=out[2], carry=c3); FullAdder(a=a[3], b=b[3], c=c3, sum=out[3], carry=c4); FullAdder(a=a[4], b=b[4], c=c4, sum=out[4], carry=c5); FullAdder(a=a[5], b=b[5], c=c5, sum=out[5], carry=c6); FullAdder(a=a[6], b=b[6], c=c6, sum=out[6], carry=c7); FullAdder(a=a[7], b=b[7], c=c7, sum=out[7], carry=c8); FullAdder(a=a[8], b=b[8], c=c8, sum=out[8], carry=c9); FullAdder(a=a[9], b=b[9], c=c9, sum=out[9], carry=c10); FullAdder(a=a[10], b=b[10], c=c10, sum=out[10], carry=c11); FullAdder(a=a[11], b=b[11], c=c11, sum=out[11], carry=c12); FullAdder(a=a[12], b=b[12], c=c12, sum=out[12], carry=c13); FullAdder(a=a[13], b=b[13], c=c13, sum=out[13], carry=c14); FullAdder(a=a[14], b=b[14], c=c14, sum=out[14], carry=c15); FullAdder(a=a[15], b=b[15], c=c15, sum=out[15], carry=c16);&#125; Inc161234567CHIP Inc16 &#123; IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, out=out);&#125; ALU_nostat按照老师所给资料上的提示，我们先不去考虑 ng 和 zr 这两个输出控制位，直接考虑输出即可。那我们先得构造出能根据 zx 和 nx 这两个控制位来选择性输出的逻辑电路，当然，这个逻辑电路总线宽度是 16 位的。结果硬想了好一会儿，没想出来。后来意识到，这个问题本质上其实就是在思考如何在没有条件编程语句的情况下构造出条件逻辑。胡乱的写了些代码，发现语法都不通，但脑子里始终想的都是：在现有的可使用的逻辑电路里，好像没有可以用于条件选择的啊？过了两天，又回来思考这个问题，突然发现，Mux 这种东西不是根据 sel bit 来选择性输出的吗？突然想到自己之前的想法：这东西应该是通信专业同学研究的东西吧...好吧，自己一开始就把正确的思考方向给抛到九霄云外去了，真是搬起石头砸自己的脚，想的我真是辛苦...扯远了，有了上面的思路后，这个问题其实就很容易了，直接看下面代码：1234567891011121314151617181920212223242526272829303132CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=out);&#125; ALU完成上面的任务后，接下来我们需要考虑的问题就是如何得到 zr 和 ng 的正确结果。按照前面的课程内容，我们已经知道负数的最高位 bit 是 1，所以 ng 就很容易得到了。但是 zr 就不是那么易得了，原因在于 0 的二进制最高位与普通正数的二进制最高位一样，都是 0 ，所以无法轻易的区分。这里好像又回到了我们在之前碰到的问题：如何在没有判断编程语句的情况下构造出判断逻辑呢？注意到 0 先取反再自增加 1 后，得到的二进制序列最高位与原序列最高位一致（溢出的 bit 舍弃），而其他的数由此过程得到的两个序列的最高位必然一个是 1，另一个是 0。如此一来，问题就解决了。当然了，要想得到 zr，最快的办法其实就是让最后的结果序列按位取或（Or）运算，采用之前构造的 Or8Way 这个逻辑电路，试了下，好像总是语法有问题...12345678910111213141516171819202122232425262728293031323334353637383940CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no zr ng Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=z5); Not16(in=z5, out=z6); Inc16(in=z6, out=z7); Or16(a=z5, b=z7, out[15]=z8); Not(in=z8, out=zr); And16(a=z5, b=true, out[15]=ng); Mux16(a=z3, b=z4, sel=no, out=out);&#125; Unit 2.6 Perspectives这周的问题主要有 4 个： 目前所构建的大约 20 种逻辑电路，是否都是标准的？ 问这个问题的人口中的标准应该是相对于工业界而言的，老师的回答很直接，除了用于学习的 ALU，其他都是标准的。其实仔细一想，太底层的东西，反而没有多种构建方法，大家用的其实都是那一套。 目前实现的 ALU 为何不能提供乘法或除法？ 因为课程中实现的 ALU 过于简单，只是为了学习使用。但你依然可以自己去实现乘法或除法，这取决于开发者是否需要给它添加这个功能。 课程中的 ALU 是否高效？ 课程中设计的大多数逻辑电路都是高效的，但有一种仍然可以改进的更高效，那就是——Adder。目前它“低效”的原因在于，其内部实现是由多个全加器“串”起来的，所以二进制比特流的流动存在一定的延迟。 为何建议学生使用 built-in chips？ 第一，使用 built-in chips 会更加高效；第二是因为可以避免一些未知的错误，而这些错误可能是由模拟器的 bug 导致的，也就是说这并不是你的代码有问题；第三，模拟器并不高效，使用自己构建的 chips 可能会进一步降低效率。 这周内容的难点在于如何构建 ALU，可见在没有高级语言的帮助下，如果想要在底层实现一些复杂逻辑，还是挺费脑子的。另外，还有一块知识老师没有强调，就是根据逻辑运算来构造实际运算，也就是 ALU 这样设计的背后原理，这部分内容可能又跟电学有点关系吧...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_01]]></title>
    <url>%2F2020%2F09%2F20%2FNand2Tetris-Part1-01%2F</url>
    <content type="text"><![CDATA[Nand2Tetris 是由希伯来大学的两位教授 Noam Nisan 和 Shimon Schocken 在 Coursera 上开设的在线课程（网络课程）。课程全称叫做：依据基本原理构建现代计算机：从与非门到俄罗斯方块（基于项目的课程），其主要内容与计算机组成原理、操作系统等科目的关联性较大，但课程的受众群体也不止局限于专业人士，且课程的实践性很强，对深入理解理论知识很有帮助。 Introduction第一周包含两个章节（一般情况下，一周一个）：Introduction 和 Boolean Functions and Gate Logic。顾名思义，Introduction 是对本课程的说明，Boolean Functions and Gate Logic 才是第一周的真正的学习内容。通过 Introduction 可以知道大体的学习路线是从基本的逻辑门单元开始，自下而上的学习如何构建计算机，继而构建出能在这台计算机上运行的程序，也即：Nand -&gt; Hack -&gt; Tetris。另外，对于购买了课程的同学而言，这章节会有一个编程作业，用来练习如何在 Coursera 上提交作业。但如果你是旁听生（auditor），那么可以忽略掉。 Boolean Functions and Gate Logic这部分内容属于计算机系统结构底层中的底层，课程从一个小小门逻辑电路开始讲起（当然不会讲与物理相关的内容，这也是老师让大家不要过分在意的地方），逐步介绍各种不同的逻辑电路，并自行构造具有一定复杂性的复合逻辑门电路。 Unit 1.1 Boolean Logic本小节主要介绍了三种基本的逻辑门（Logic gate）：与（And）、或（Or）和非（Not），并举例说明了与之对应的基本运算方法和规律。 三种逻辑门的真值表（Truth table）如下：And：$$\begin{array}{cc|c}x &amp; y &amp; And \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Or：$$\begin{array}{cc|c}x &amp; y &amp; Or \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Not：$$\begin{array}{c|c}x &amp; Not \\\hline0 &amp; 0 \\1 &amp; 0 \\\end{array}$$ 运算规律： 交换律（Commutative Law） x and y = y and x x or y = y or x 结合律（Associative Law） x and (y and z) = (x and y) and z x or (y or z) = (x or y) or z 分配律（Distributive Law） x and (y or z) = (x and y) or (x and z) x or (y and z) = (x or y) and (x or z) 德摩根律（De Morgan Law） not (x and y) = (not x) or (not y) not (x or y) = (not x) and (not y) 以上基本内容说不定就会用到，记录下。 Unit 1.2 Boolean Functions Synthesis本小节主要讲了三点： 如何根据真值表来反向构造布尔函数 介绍了一个结论：任意布尔函数都能被与或非三种运算表示（Any Boolean function can be represented using an expression containing AND, OR and NOT operations.） 接下来会用与非门（Nand）来构建其他逻辑门 Unit 1.3 Logic gates本小节着重在说明一个问题，即：这门课程不会从物理层面深究这种逻辑门是怎样实现的，但是会探讨如何利用基础逻辑门来构建复合逻辑门。另外，还介绍了在这个课程中会见到的一些描述用语。PS：God bless their souls. 感觉像是在嘲讽呢（笑）。 Unit 1.4 Hardware Description Language本小节主要在说明硬件描述语言（后面会简称 HDL）的语法规则，不多，建议直接自己看老师提供的手册，并试着写下代码，有了一定的感性认识后，再来听，可能会收获多一点。 Unit 1.5 Hardware Simulation本小节主要在讲如何使用课程提供的硬件模拟器和一些注意事项。 Unit 1.6 Multi Bit Buses本小节主要在说明多位（bit）逻辑门在本课程所用的 HDL 中的用法，并顺便大致的说明了一下总线的含义，对后面构造位逻辑单元有一定帮助，特别是有 HDL 代码的地方，对后面的作业很有帮助。 Unit 1.7 Project 1 Overview本小节主要在介绍第一周的作业以及这周作业对于后续课程的意义。不得不说，国内老师从来不会跟你讲作业的意义，最多给你讲讲错题。 扯远了，每周作业包括三个部分：代码源文件（.hdl）、测试脚本（.tst）和比对文件（.cmp）（其实就是程序正确的运行结果），每一个小作业（就是你要实现的每一个小芯片）都包含这三个文件。好消息是测试脚本跟正确答案老师都准备好了，坏消息是代码得自己写（其实也不算坏消息，本就是分内之事，笑），下面我们来完成这周的作业。 PS：有一点要注意，下面这些逻辑门实现的方式不唯一，这也是老师一再强调的东西。 NotNand 是我们在这个课程中可以直接使用的基本逻辑门，可以直接使用，Not 是我们要完成的第一个芯片，所以我们直接使用一个二元的与非门来实现一个一元的非门（The implementation of a unary Not gate from a binary Nand gate is simple.）。 一元非门只有两种情况，二元与非门有四种情况，那么我们直接用与非门的其中两种情况来表示非门即可，代码如下：1234567CHIP Not &#123; IN in; OUT out; PARTS: Nand(a=in, b=true, out=out);&#125; And一开始思考如何实现 And 时，有点无从下手的感觉后来，想了一会，想到了两种方法： 使用 2 个 Nand 使用 1 个 Nand，在使用 1 个 Not 12345678910111213CHIP And &#123; IN a, b; OUT out; PARTS: /* method 1: use 2 Nand Nand(a=a, b=b, out=c); Nand(a=c, b=true, out=out); */ /* method 2: use Nand and Not */ Nand(a=a, b=b, out=c); Not(in=c, out=out);&#125; Or实现 And 之后，此时我们可以使用上面实现好了的逻辑门来帮助实现 Or。 12345678910CHIP Or &#123; IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=nota, b=notb, out=e); Not(in=e, out=out);&#125; Xor异或运算有点特殊，同样还是用已经实现过的逻辑门来实现。123456789CHIP Xor &#123; IN a, b; OUT out; PARTS: Or(a=a, b=b, out=c); Nand(a=a, b=b, out=d); And(a=c, b=d, out=out);&#125; MuxMux 全称 Multiplexor，即多路复用器（大概是这个意思吧），这个东西应该是通信专业同学研究的东西，有三个输入：a，b 和 sel。规则就是根据 sel 的值来确定输出 a 还是 b，sel 有点像是校验码之类的东西吧。 粗略分析一下，Mux 有八种情况，我们先观察一下它的真值表。$$\begin{array}{ccc|c}a &amp; b &amp; sel &amp; Mux \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 \\\end{array}$$Mux 的结果中有 4 个值为真，仔细回想一下老师在 1.2 讲的有关反向构造布尔函数的知识，首先先列出所有真值的表达式，也就是上表中的第 3、4、6、8 行，可得： 第 3 行：a and (not b) and (not sel) 第 4 行：a and b and (not sel) 第 6 行：not a and b and sel 第 8 行：a and b and sel 继而我们可以得到 Mux 的布尔函数式子：(a and (not b) and (not sel)) or (a and b and (not sel)) or ((not a) and b and sel) or (a and b and sel)。汗，真长，不过先不管，我们直接按照这个函数来写代码，可以得到以下代码：12345678910111213141516171819202122232425CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=b, out=notb); Not(in=sel, out=notsel); Not(in=a, out=nota); And(a=a, b=notb, out=u1); And(a=u1, b=notsel, out=u2); And(a=a, b=b, out=v1); And(a=v1, b=notsel, out=v2); And(a=nota, b=b, out=w1); And(a=w1, b=sel, out=w2); And(a=a, b=b, out=x1); And(a=x1, b=sel, out=x2); Or(a=u2, b=v2, out=y1); Or(a=y1, b=w2, out=y2); Or(a=y2, b=x2, out=out);&#125; 测试后结果是正确的，不过这显然不够老师说的 elegant（笑），我们来把布尔函数式根据运算规则化简一下，可得：(a and (not sel)) or (b and sel)，从而可得：12345678910CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=sel, out=notsel); And(a=a, b=notsel, out=u); And(a=b, b=sel, out=v); Or(a=u, b=v, out=out);&#125; 测试后结果依然正确，说明化简是正确的。 为什么要使用上面的方法来构造布尔函数？因为此时我们能用的逻辑门已经不仅仅只有 Nand，还有先前已经构造好了的 And、Not、Or、Xor，这些都可以直接拿来用了，那还费脑子死想干嘛呢。当然了，这也是老师强调过的思想。 另外，通过上面的计算过程和老师的讲解，我们可以得到反向构造布尔函数时的几个要点： 选取结果序列中真值或假值较少的一方，上面的 Mux 中真假值都是 4 个，任取即可 用每一个值写出的式子必须保证其中的每一子项皆为真或假，比如以上面第 3 行为例，a、not b 和 not sel 的值都是 1 单个式子的每一子项要进行 and 运算，而每个式子之间则用 or 运算 PS：有关逻辑式子化简的问题，应该属于离散数学的知识。 DMuxDMux，Demultiplexor，即解复用器，与 Mux 是一对，二者的功能也正好相反，但 DMux 的特殊性在于它有两个输出。我们还是按照上面的思路来构建，先看一下 DMux 的真值表$$\begin{array}{c|cc}sel &amp; a &amp; b \\\hline0 &amp; in &amp; 0 \\1 &amp; 0 &amp; in \\\end{array}$$这是老师提供的资料上的真值表，好像不是很易于分析问题，那我们把详细的真值表整理出来：$$\begin{array}{cc|cc}sel &amp; in &amp; a &amp; b \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 \\\end{array}$$这样，我们在分析这个问题时，就可以单独考虑如何利用 sel 和 in 分别得到 a、b 这两列值，代码如下：1234567891011CHIP DMux &#123; IN in, sel; OUT a, b; PARTS: Not(in=in, out=notin); Or(a=sel, b=notin, out=v1); Not(in=v1, out=a); And(a=sel, b=in, out=b);&#125; Not16多位逻辑门是老师在 1.6 讲过的内容，构造的基本思想就是每一位都用一个逻辑门来计算，组合在一起就可以了。12345678910111213141516171819202122CHIP Not16 &#123; IN in[16]; OUT out[16]; PARTS: Not(in=in[0], out=out[0]); Not(in=in[1], out=out[1]); Not(in=in[2], out=out[2]); Not(in=in[3], out=out[3]); Not(in=in[4], out=out[4]); Not(in=in[5], out=out[5]); Not(in=in[6], out=out[6]); Not(in=in[7], out=out[7]); Not(in=in[8], out=out[8]); Not(in=in[9], out=out[9]); Not(in=in[10], out=out[10]); Not(in=in[11], out=out[11]); Not(in=in[12], out=out[12]); Not(in=in[13], out=out[13]); Not(in=in[14], out=out[14]); Not(in=in[15], out=out[15]);&#125; And1612345678910111213141516171819202122CHIP And16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]);&#125; Or1612345678910111213141516171819202122CHIP Or16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: Or(a=a[0], b=b[0], out=out[0]); Or(a=a[1], b=b[1], out=out[1]); Or(a=a[2], b=b[2], out=out[2]); Or(a=a[3], b=b[3], out=out[3]); Or(a=a[4], b=b[4], out=out[4]); Or(a=a[5], b=b[5], out=out[5]); Or(a=a[6], b=b[6], out=out[6]); Or(a=a[7], b=b[7], out=out[7]); Or(a=a[8], b=b[8], out=out[8]); Or(a=a[9], b=b[9], out=out[9]); Or(a=a[10], b=b[10], out=out[10]); Or(a=a[11], b=b[11], out=out[11]); Or(a=a[12], b=b[12], out=out[12]); Or(a=a[13], b=b[13], out=out[13]); Or(a=a[14], b=b[14], out=out[14]); Or(a=a[15], b=b[15], out=out[15]);&#125; Mux1612345678910111213141516171819202122CHIP Mux16 &#123; IN a[16], b[16], sel; OUT out[16]; PARTS: Mux(a=a[0], b=b[0], sel=sel, out=out[0]); Mux(a=a[1], b=b[1], sel=sel, out=out[1]); Mux(a=a[2], b=b[2], sel=sel, out=out[2]); Mux(a=a[3], b=b[3], sel=sel, out=out[3]); Mux(a=a[4], b=b[4], sel=sel, out=out[4]); Mux(a=a[5], b=b[5], sel=sel, out=out[5]); Mux(a=a[6], b=b[6], sel=sel, out=out[6]); Mux(a=a[7], b=b[7], sel=sel, out=out[7]); Mux(a=a[8], b=b[8], sel=sel, out=out[8]); Mux(a=a[9], b=b[9], sel=sel, out=out[9]); Mux(a=a[10], b=b[10], sel=sel, out=out[10]); Mux(a=a[11], b=b[11], sel=sel, out=out[11]); Mux(a=a[12], b=b[12], sel=sel, out=out[12]); Mux(a=a[13], b=b[13], sel=sel, out=out[13]); Mux(a=a[14], b=b[14], sel=sel, out=out[14]); Mux(a=a[15], b=b[15], sel=sel, out=out[15]);&#125; Or8Way12345678910111213CHIP Or8Way &#123; IN in[8]; OUT out; PARTS: Or(a=in[0], b=in[1], out=v1); Or(a=v1, b=in[2], out=v2); Or(a=v2, b=in[3], out=v3); Or(a=v3, b=in[4], out=v4); Or(a=v4, b=in[5], out=v5); Or(a=v5, b=in[6], out=v6); Or(a=v6, b=in[7], out=out);&#125; Mux4Way164 路 Mux16 使用三个 Mux16 即可完成，可能会有人问为什么要先让 a 和 c 先通过一次 Mux16。因为 sel bits 是从右往左读的，若 a 和 b 先通过一次 Mux16，当 sel[1]=0 时，就无法得到正确的输出结果了（sel[0]=0，就输出 a，sel[0]=1，就输出 b，但第一次通过 Mux16 后已经过滤掉 a 或 b 了）。123456789CHIP Mux4Way16 &#123; IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=c, sel=sel[1], out=v1); Mux16(a=b, b=d, sel=sel[1], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; Mux8Way16在 Mux4Way16 的基础上构造就行了，注意一下这里的语法。1234567891011CHIP Mux8Way16 &#123; IN a[16], b[16], c[16], d[16], e[16], f[16], g[16], h[16], sel[3]; OUT out[16]; PARTS: Mux4Way16(a=a, b=c, c=e, d=g, sel=sel[1..2], out=v1); Mux4Way16(a=b, b=d, c=f, d=h, sel=sel[1..2], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; DMux4Way先用 sel[1] 来区分 a、b 和 c、d 两组，再用 sel[0] 在组内分别区分 a、b 和 c、d。123456789CHIP DMux4Way &#123; IN in, sel[2]; OUT a, b, c, d; PARTS: DMux(in=in, sel=sel[1], a=u1, b=u2); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d);&#125; DMux8Way在 DMux4Way 的基础上构建就行，思路是完全一致的。1234567891011CHIP DMux8Way &#123; IN in, sel[3]; OUT a, b, c, d, e, f, g, h; PARTS: DMux4Way(in=in, sel=sel[1..2], a=u1, b=u2, c=u3, d=u4); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d); DMux(in=u3, sel=sel[0], a=e, b=f); DMux(in=u4, sel=sel[0], a=g, b=h);&#125; Unit 1.8 Perspectives本小节主要老师们回答学生在论坛区提出的一些典型问题，这次主要回答了 3 个问题： 能否不用 Nand 而是用其他的基本逻辑门来构建一个计算机？ 答案是 yes，这里我们不深究具体原因。 Nand gate 的具体工作原理 老师用电路图讲了一下，当然，这是电气工程师该干的活，就不具体讨论了 工业坏境下使用的 HDL 语言与课程使用的 HDL 语言有何差别 工业环境用的肯定功能更加强大，效率更高，学习的时间较长；而本课程的 HDL 语言只是为了满足教学使用，所以功能性会弱很多，但易于学习，且足够满足本课程的所有需要 本周内容过于底层，估计不少人觉得无聊，不过还好不是太难。当然，可能会有第一次使用这样的 HDL 语言和硬件模拟器而不熟悉的问题，不过老师提供的手册和视频的讲解帮助还是很大的。个人感觉老师给的手册如果能更详细一点，用例再多一点就更好了（主要还是自己太懒，笑）。]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 语法快速指南]]></title>
    <url>%2F2020%2F09%2F17%2FMathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MathJax 是一个 JavaScript 库，可以让你直接用 Latex 语法来书写数学公式，十分方便。想深入了解 MathJax，点击链接：MathJax，本文旨在整理一些平时写文档时常用的一些语法，便于复查。 书写位置平时写文档时，公式的放置位置有两个地方：文字中间和单独成块，这就跟单行代码与代码块一样。 放在文字中间的公式要用一对美元符号包括起来，如：$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$，显示为：$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ 单独成块的公式要用两对美元符号包括起来，如：$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$，显示为：$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ 希腊字母 显示 语法 显示 语法 $\gamma$ \gamma $\delta$ \delta $\epsilon$ \epsilon $\zeta$ \zeta $\eta$ \eta $\theta$ \theta $\iota$ \iota $\kappa$ \kappa $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\pi$ \pi $\rho$ \rho $\sigma$ \sigma $\tau$ \tau $\upsilon$ \upsilon $\phi$ \phi $\chi$ \chi $\psi$ \psi $\omega$ \omega 如果要大写希腊字母，将语法的首字母大写即可，如：\Sigma，显示为：$\Sigma$；如果要斜体希腊字母，在语法前加上var即可，如：\varsigma，显示为：$\varSigma$ 上下标上标使用^，下标使用_，二者后面再接字符，如果字符数大于一个需要使用一对花括号包括起来，如：$\sum_{i=0}^N$，显示为：$\sum_{i=0}^N$ 矢量$\vec a$显示为：$\vec a$；如果想改变字母上方的符号，可以这样写$$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \overrightarrow{xy} \quad $$，显示为：$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \ \ \ \overrightarrow{xy} \quad $ 括号小括号：$()$，显示为：$()$中括号：$[]$，显示为：$[]$尖括号：$&lt;&gt; \langle\rangle$，显示为：$&lt;&gt; \langle\rangle$\left和\right可以使符号大小与临近的公式相适应，如：$(\frac{x}{y})$，显示为：$(\frac{x}{y})$；而$\left(\frac{x}{y})\right$，显示为：$\left(\frac{x}{y}\right)$ 求和、极限和积分 求和使用\sum，如：$\sum_{i=0}^n{a_i}$，显示为：$\sum_{i=0}^n{a_i}$ 极限使用\lim，如:$\lim_{n \to 0}e^n $，显示为：$\lim_{n \to 0}e^n $ 积分使用\int，如：$\int_0^1 2x dx$，显示为：$\int_0^1 2x dx$ 分式与根式 分式使用\frac，用法为：$\frac{式1}{式2}$，显示为：$\frac{式1}{式2}$ 根式使用\sqrt，如：$\sqrt{x}{y}$，显示为：$\sqrt{x}{y}$ 特殊函数如：$\sin x \quad \ln x \quad \max(A, B, C)$，显示为：$\sin x \quad \ln x \quad \max(A, B, C)$ 取整函数向上取整：$\lceil x \rceil$，显示为：$\lceil x \rceil$向下取整：$\lfloor x \rfloor$，显示为：$\lfloor x \rfloor$ 特殊符号 显示 语法 显示 语法 $\infty$ \infty $\cup$ \cup $\cap$ \cap $\subset$ \subset $\subseteq$ \subseteq $\supset$ \supset $\in$ \in $\notin$ \notin $\varnothing$ \varnothing $\forall$ \forall $\exists$ \exists $\lnot$ \lnot $\nabla$ \nabla $\partial$ \partial $\geqslant$ \geqslant $\leqslant$ \leqslant 特殊符号还有很多这里不一一列举了。 空格LaTex 语法本身会忽略空格的存在需要用\来转译，如：$a b\ a\ b$，显示为：$a b\ a\ b$；一次性生成 4 个空格，需要使用\quad，如：$a \quad b$，显示为：$a \quad b$ 矩阵基本语法 起始标记：\begin{matrix}， 结束标记：\end{matrix} 每一行末尾标记：\\ 行间元素之间用&amp;分割 如：12345$$\begin&#123;matrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;matrix&#125;$$ 显示为：$$\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}$$ 矩阵边框用以下关键词替换掉起始、结束标记中的matrix，如： pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 如：1234567891011121314151617181920212223242526272829$$\begin&#123;pmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;pmatrix&#125;$$$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$$$\begin&#123;Bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Bmatrix&#125;$$$$\begin&#123;vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;vmatrix&#125;$$$$\begin&#123;Vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Vatrix&#125;$$ 显示为：$$\begin{pmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{pmatrix}$$ $$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}$$ $$\begin{Bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Bmatrix}$$ $$\begin{vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{vmatrix}$$ $$\begin{Vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Vmatrix}$$ 省略号 省略号：\dots，如：$1 \dots 5$，显示为：$1 \dots 5$ 横省略号：\cdots 竖省略号：\vdots 斜省略号：\ddots 如：123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;m1&#125; &amp; a_&#123;m2&#125; &amp; \cdots &amp; a_&#123;mn&#125; \\\end&#123;bmatrix&#125;$$ 显示为：$$\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\\end{bmatrix}$$ 行中矩阵如：$\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}$，显示为：$( \begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix} )$ 阵列使用array关键字，基本语法：1234$$\begin&#123;array&#125;&#123;格式串&#125;......\end&#123;array&#125;$$ 其中，“格式串”由四种字符构成，分别为： l，左对齐 c，居中 r，右对齐 |，建立竖直线 使用\hline可插入水平线。 如：123456$$\begin&#123;array&#125;&#123;c|lll&#125;- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end&#123;array&#125;$$ 显示为：$$\begin{array}{c|lll}- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end{array}$$ 方程组使用cases关键字，基本语法：1234$$\begin&#123;cases&#125;&#123;格式串&#125;......\end&#123;cases&#125;$$ 如：123456$$\begin&#123;cases&#125;a_1x + b_1y + c_1z = d_1\\a_2x + b_2y + c_2z = d_2\\a_3x + b_3y + c_3z = d_3\\\end&#123;cases&#125;$$ 显示为：$$\begin{cases}a_1x + b_1y + c_1z = d_1 \\a_2x + b_2y + c_2z = d_2 \\a_3x + b_3y + c_3z = d_3 \\\end{cases}$$所以，分段函数可以写成：123456$$f(x) = \begin&#123;cases&#125;0 &amp; x为无理数 \\x &amp; x为有理数 \\\end&#123;cases&#125;$$ 显示为：$$f(x) =\begin{cases}0 &amp; x为无理数 \\x &amp; x为有理数 \\\end{cases}$$ 字体转换要对公式的某一部分字符进行字体转换，使用\[字体格式] xxx即可，默认为意大利体，字体格式仅列举以下几种： 字体 语法 字体 语法 罗马体 \rm 意大利体 \it 黑体 \bf 花体 \cal 倾斜体 \sl 等线体 \sf 数学斜体 \mit 打字机字体 \tt 小体大写字母 \sc 如：1234567$$a\ b\ c \\\rm &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\\bf &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\$$ 显示为：$$a\ b\ c \\\rm {a\ b\ c} \\\it {a\ b\ c} \\\bf {a\ b\ c} \\\it {a\ b\ c} \\$$另外，一般会用text关键子来书写文本，如：$\text{无穷大}$，显示为：$\text{无穷大}$。 参考文章：MathJax 语法参考基本数学公式语法(of MathJax)Markdown 数学公式语法]]></content>
      <categories>
        <category>Tools</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法快速指南]]></title>
    <url>%2F2020%2F09%2F16%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[有关 Markdown 的概念性问题，请点击链接自行查看。本文旨在整理一些平时写文档时常用的一些语法，这样既方便他人查看，也以免自己忘记。 标题Markdown 支持两种形式的标题，Setext 和 atx，常用的是 atx 语法的标题，本文以此为主。Atx 样式的标题每行开头使用 1-6 个井号，井号的个数对应 1-6 级标题（最多也就 6 级），例如：12345# 一级标题## 二级标题#### 四级标题 效果如下： 块引用块引用的方式很简单，例如：1&gt; xxxx 效果如下： xxxx 引用内还可以包含 Markdown 的其他元素，如列表和代码块等，这里不详细介绍了。 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号、加号和连字符，使用任一符号都可以实现一样的效果，例如：1234567891011* peach* apple* banana+ peach+ apple+ banana- peach- apple- banana 效果如下： peach apple banana peach apple banana peach apple banana 有序列表有序列表使用数字加点完成（点后与字符之间有空格），例如：1231. peach2. apple3. banana 效果如下： peach apple banana 列表之间还可以进行嵌套使用，形成一级表头和二级表头这样的东西，如：12345- xxx - xxx1. 111 2. 222 效果如下： xxx xxx 111 222 代码块常见用法主要有单行代码块和多行代码块。 单行代码块单行代码块使用一对重音符``来书写，直接将代码放到重音符中间即可，如：1`xxx` xxxxxxxxx 多行代码块多行代码块使用三对重音符来书写，同样将代码块放到中间即可，如：12345(```)xxxbbbxxx(```)注意实际是没有括号的 效果如下：1xxxbbbxxx 水平线如果一行中只有三个以上的连字符、星号或下划线，则会在该位置生成一个&lt;hr&gt;标签，这条线可以叫水平线，也可以叫分割线，效果如下： 不同的 Markdown 编辑器渲染出来的效果可能不一样。 表格Markdown 内表格的用法有点麻烦，需要使用冒号、竖线和连字符来完成，如：1234表头 | 表头 | 表头-- | :--: | --:1 | 2 | 34 | 5 | 6 效果如下： 表头 表头 表头 1 2 3 4 5 6 大致说明一下：第二行是格式控制行，-有一个就可以了，有时为了对齐会多加几个；除了第二行外的其他行中的文字是默认居左的，两边都加:，就可以居中，右边加:就可以居右。 表格中的文字也能使用 Markdown 中文字相关的语法；如果想要改变表格中文字的颜色，可以借助font标签来完成。 文字与文字相关的语法，如：1234**加粗***斜体****斜体加粗***~~删除~~ 效果如下：加粗斜体斜体加粗删除 图片引用基本语法，如：123![图片名称](图片地址 &quot;图片下标题&quot;)如：![zzz](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600276810120&amp;di=ffb59bf5363570267ac8201139b33c94&amp;imgtype=0&amp;src=http%3A%2F%2Fa2.att.hudong.com%2F86%2F10%2F01300000184180121920108394217.jpg &quot;xxx&quot;) 效果如下： 链接基本语法，如：123[链接名称](链接地址)如：[Baidu](https://www.baidu.com) 效果如下：Baidu 参考文章：Markdown 中文文档Markdown基本语法]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_Summary]]></title>
    <url>%2F2020%2F09%2F16%2FZJU-DS-Summary%2F</url>
    <content type="text"><![CDATA[课堂笔记全部写完了，总结一下。 课堂评价虽然这是门在线课程，但是课堂的质量其实很高，主要归功于两位老师深入浅出的讲解，以及在合适的时间插入的课间习题。私认为姥姥跟何头已经尽量讲的简单一点了，但是由于这门课程的特殊性（抽象的东西太多），可能还是有人听的云里雾里，建议多听几遍。何头讲课比较直接，各种细节性问题都会给你讲清楚，姥姥讲课偶尔会“调皮”一下（心态真是年轻啊...），更想引发你自己的思考；他们的共同点就是课上讲的话都十分的精练，没什么废话，有些地方还得都听几遍才能懂。 另外，课间穿插的习题和视频后的讨论可以引发学生的思考，对理解课上的东西有一定的帮助，这也是值得称赞的地方；专门设置的“小白专场”也是十分贴心，值得好评。 课程练习课程练习主要有三种：课间习题、课后习题和 PTA 上的编程题。课间习题帮助理解课堂上所讲的内容；课后习题帮助巩固课堂上所讲的内容；PTA 上的作业题算是实打实的“应用题”，把课上学的理论一步步实现，既能加深对理论的理解，又能增强编码能力，十分不错。 有点美中不足的地方就是课后习题太少了，这类笔试题目如果能增多，对要考试的学生而言很有帮助。不过，老师们编的教材上也有不少习题，这可能是课后习题比较少的原因。 关于 PTA 上的编程题，建议全部做完（虽然老师说了那些必做，那些选做），一定要自己先做，不能一次 AC 不要紧，实在 AC 不了，再看老师的讲解（难一点的基本都讲了）。有些题目的解题思路其实有很多，光是直接百度就有很多资料可查。另外，题目总体难度大概就是 PAT 甲级的难度了，作业题里面有些就是当年的甲级真题，所以一定要好好做。 考试考试的形式比较简单，也很方便，每周作业都是编程题，考试有判断、选择、填空、编码题，没有做过针对性练习的同学可能会很不习惯，最好考试前做点针对性的练习。另外，如果考试结束后，能提供错题的答案就完美了。 个人体会数据结构与算法这门课是真的很抽象，基本全部都是理论化的东西，学的基本就是几十年前的计算机科学家论文上写的东西，得耐住性子，仔细钻研。这门课就好比修炼武侠绝技前修炼的“内功心法”一般，是根基，理论基础扎实了，实践能力才能稳步提高。不过，两位老师讲的很棒，着实方便了不少。 在把图学完的时候，感觉就像是有了“屠龙宝刀”却不知道怎么用一样。不过实际的生产坏境中，根本没机会让你去“屠龙”... 一般而言，计算机学科的科目要想学到东西，切忌不能空谈理论，一定得动手，动手去写，动脑子去想问题。就这门课而言，PTA 上的编程题都是十分不错的习题，一定得动脑子去写。就算不能解决，只要动脑子思考了问题，基本都会有收获。 自己算是把这门课反复学了好几遍才算是能理解一些东西了，可能是自己脑子太拙了吧... 不管怎么说，把所有的笔记整理完也算是完成了一件事，继续努力吧，骚年~😉]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_12-KMP]]></title>
    <url>%2F2020%2F09%2F15%2FZJU-DS-12-KMP%2F</url>
    <content type="text"><![CDATA[本周主要讲解几道题目，然后再介绍一下 KMP 算法。 串在了解KMP算法之前，我们先了解一下什么是串。串（String）其实也是线性表的一种应用，指的是线性存储的一组数据（常见是字符，正所谓“字符串”），当然，串不仅仅包含字符，它是通用的数据结构。同时，与串相关的操作集有很多，如：求串的长度、比较两串是否相等、两串相接、求子串、插入子串、匹配子串（KMP 就是干这事的）、删除子串等。 KMP匹配子串什么是“匹配子串”呢？看名字，其实有两个着重点，一个是匹配，一个是子串。举个例子，给定一段文本，从中找出某个指定的关键字，例如给定文本：This is not a bug, it’s destiny. ，需要从中找出 bug 这个关键字（当然这并不是件复杂的事情），这实际上就是“匹配子串”。 那么我们重新规范一下，就是：给定一个文本：string = xxxxxxx，在给定一个模式：pattern = xxxx，求 pattern 在 string 中出现的位置。 分析依据匹配子串的思路，如果要找pattern在string中出现的位置，分别使用两个指针，接着对string进行遍历，同时与pattern逐个字符进行比较，如果出现不相等的，则string的指针回退到初试比较位置的后一个位置（若从 i 开始比较，则回退到 i+1 开始比较），pattern的指针则回退到第一位，重复执行即可，这实际上是一种暴力解法。使用暴力解法时，串中肯定会有相同的序列存在，所以指针回溯后再次遍历比较时，就会进行重复的比较操作了，这样就做了很多无用的操作，而 KMP 算法就是用来解决这个问题的。 匹配函数KMP 算法在直接进行匹配前会对模式串（pattern）进行分析，借助一个辅助数组match[]，这个数组内保存着模式串按照下面的 $ match $ 函数计算的“值”，根据这些“值”，再构造合适的判断规则来解决这个问题；match[]数组的下标就是模式串每一个字符的下标。先来看一下这个 $ match $ 函数: $$match(j) = \begin{cases}&amp;\text{满足}p_0 \cdots p_i = p_{j-i} \cdots p_j \text{的最大}i(\lt j) \\&amp;-1\ \ \ \text{如果这样的} i \text{不存在}\end{cases}$$ 假设pattern为abcabcacab这个序列，下面来计算一下其由 $ match $ 函数得来的数组。1→2→3→4→重复先从a开始，a为首字符，根据 $ match $ 函数的规则，match(0) = -1继而到b，b需要和前面的a进行比较，发现不匹配，match(1) = -1再看c，此时对于match函数而言，i可以取两个值，分别是0和1（此时j=2），取0时，c直接和a比较，不匹配，取1时，那就是ab和bc进行比较，还是不匹配，所以match(2) = -1再看下一个a，此时i可以取三个值（0、1、2，注意match函数的条件是不大于j的最大i），取0，a和a比较，匹配成功，match(3) = 0，取1，ab和ca不匹配，取2，abc和bca也不匹配（若此时匹配，match(3)的值需要更新），所以match(3) = 0按照这种思路，重复直至结束。重复计算后，可以得到下表： pattern a b c a b c a c a b j 0 1 2 3 4 5 6 7 8 9 match -1 -1 -1 0 1 2 3 -1 0 1 match函数有多种和不同的称呼，有些书也叫next。另外，需要明确的是，这个特定函数的针对对象是pattern，也即是给定的模式串，而不是原串。另外，pattern比较短，string比较长，KMP算法只用分析一个短的子串而不用分析一个长串，这其实已经提升了效率。 算法实现使用 $ match $ 函数获得match[]数组后，如何去使用match[]数组又成为新问题。首先我们已经知道了，根据match[]数组可以避免去比较重复的序列，当不匹配时，指向pattern的指针p会去找p-1这个指针所指位置的match[]值，而这个match[]值加1就是指针p重新开始进行匹配的位置，即如下图所示：就是这样去使用match数组的，明确这个问题后，基本可以写出 KMP 算法的代码了，如下所示：1234567891011121314151617Position KMP(char *string, char *pattern) &#123; int n = strlen(string); /* O(n) */ int m = strlen(pattern); /* O(m) */ int s, p, *match; if(n &lt; m) return NotFound; match = (int*)malloc(m*sizeof(int)); BuildMatch(pattern, match); /* T(B) */ s = p = 0; while(s&lt;n &amp;&amp; p&lt;m) &#123; /* O(n) */ if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p-1] + 1; else s++; &#125; return (p==m)?(s-m):NotFound;&#125; 从上面的代码可以分析出其时间复杂度基本为$T = O(n+m) + T(B)$，BuildMatch函数的时间复杂度取决于其自身的实现方式，别忘记了，KMP是以它为前提的。 有了前面对 $ match $ 函数的分析，BuildMatch函数的构造就比较简单了，但若只是简单用线性的方法去构造match数组的话，会使得时间复杂度为$O(m^3)$，这就很不友好了，那怎么办呢？ 答案是利用match[]数组内的值，如果是计算第i个位置的match值，那么必定得去找i-1的match值加1所指位置的字符是否与i所指位置的字符相同，如果相同，皆大欢喜，match[i] == match[i-1] + 1了，如果不相等呢？ 就得去找i-1的match值的match值加1所指位置的字符是否与i所指位置的字符相同了（好绕...😓），也即match[match[i-1]]，若相同，match[i] == match[match[i-1]] + 1，如果还不相等，继续找吧...（还好是电脑干活😓）。可参考下图：基本代码如下：1234567891011121314void BuildMatch(char *pattern, int *match) &#123; int i, j; int m = strlen(pattern); /* O(m) */ match[0] = -1; for(j=1; j&lt;m; j++) &#123; /* O(m) */ i = match[i-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) &#123; match[j] = i+1; &#125; else match[j] = -1; &#125;&#125; 简单分析一下上述代码的时间复杂度，可得 $T_m(N) = O(m)$，综合起来 KMP 算法的时间复杂度就是 $T(N) = O(n+m)$，从暴力解法的 $O(n·m)$ 优化成 $O(n+m)$，确实厉害！ Homework串的模式匹配这道题目是用来测试各式各样的串的模式匹配算法的，按照姥姥给出的代码，可以得到下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define NotFound -1typedef int Position;void Build_Match(char *pattern, int *match) &#123; Position i, j; int m = strlen(pattern); match[0] = -1; for(j=1; j&lt;m; j++) &#123; i = match[j-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) match[j] = i+1; else match[j] = -1; &#125;&#125;Position KMP(char *string, char *pattern) &#123; int n = strlen(string); int m = strlen(pattern); Position s, p, *match; if(n &lt; m) return NotFound; match = (Position*)malloc(m*sizeof(Position)); Build_Match(pattern, match); s = p =0; while(s&lt;n &amp;&amp; p&lt;m) &#123; if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p - 1]+1; else s++; &#125; return (p == m) ? (s - m) : NotFound;&#125;int main(int argc, char const *argv[]) &#123; char string[] = "This is a simple example."; char pattern[] = "simple"; Position p = KMP(string, pattern); if(p == NotFound) printf("Not Found.\n"); else printf("%s\n", string+p); return 0;&#125;/*samples:in:abcabcabcabcacabxy3abcabcacabcabcabcdabcabcabcabcacabxyzout:abcabcacabxyNot FoundNot Found */]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_11-散列查找]]></title>
    <url>%2F2020%2F09%2F06%2FZJU-DS-11-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本周将介绍散列查找 引子先来回顾一下其他的查找方法： 名称 时间复杂度 顺序查找 $O(N)$ 二分查找（静态查找） $O(log_2N)$ 二叉搜索树 $O(h), h$为树高 平衡二叉树 $O(log_2N)$ 上表中的查找方法都是建立在容易比较关键字的情况下，如果关键字不容易比较呢？ 散列查找散列查找所要解决的问题就是： 计算位置：构造散列函数确定关键词存储位置解决冲突：应用某种策略解决多个关键词位置相同的问题 按照散列查找的做法，每次查找只进行计算就够了，时间复杂度为$O(1)$，也就是说查找时间与问题规模无关！ 抽象数据类型描述类型名称：符号集（Symbol Table）数据对象集：符号表是“名字（Name）- 属性（Attribute）”对的集合操作集：Table ∈ Symbol Table, Name ∈ NameType, Attr ∈ AttributeType SymbolTable InitializeTable(int TableSize)，创建一个长度为TableSize的符号表 Boolean IsIn(SymbolTable Table, NameType Name)，查找特定的名字Name是否在符号表Table中 AttributeType Find(SymbolTable Table, NameType Name)，获取Table中指定名字Name对应的属性 SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)，将Table中指定名字Name的属性修改为Attr SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)，向Table中插入一个新名字Name及其属性Attr SymbolTable Delete(SymbolTable Table, NameType Name)，从Table中删除一个名字Name及其属性 基本思想散列（Hashing）的基本思想如下： 以关键字$key$为自变量，通过散列函数$h$，计算出对应的函数值$h(k)$，作为数据对象的存储地址。 可能不同关键字会映射到同一散列地址上，这种情况称为冲突（Collision），这需要某种冲突解决策略。 这里引入装填因子(Loading Factor)的概念，即：散列表内元素个数（$n$）与散列表空间（$m$）的比值，即$\alpha = n / m$。 散列函数按照前面的思路，在构造散列函数时需要注意两点： 计算简单，以便提高地址转换速度 关键词对应的地址空间分布均匀，以尽量减少冲突 根据数据元素的不同，可以分为以数字关键词和字符关键词构造的散列函数。 数字关键词以数字为关键词的散列函数构造方法又有多种，依次如下： 名称 散列函数 直接定址法 $h(key) = a \times key + b, a, b$为常数 除留余数法 $h(key) = key mod p, p$取素数 数字分析法 $h(key) = atoi(key + 7)$ 折叠法 关键词分割成位数相同的几个部分叠加 平方取中法 关键字平方后取其中几位 字符关键词以字符为关键词的散列函数构造也有多种，依次如下：ASCII码加和法前3个字符移位法移位法散列函数：$h(key) = (\sum key[i])\ mod\ TableSize$，此法产生的冲突较为严重散列函数：$h(key) = (key[0] \times 27^2 + key[1] \times 27 + key[2])\ mod\ TableSize$，这里看作 27 进制数，依然存在冲突，散列函数：$h(key) = (\sum_{i=0}^{i-1} key[n-i-1] \times 32^i)\ mod\ TableSize$，看作 32 进制数涉及关键词，所有n个字符，并且分布比较均匀 1234567Index Hash(const char *Key, int TableSize) &#123; unsigned int h = 0; while(*Key != ‘\0’) &#123; h = (h &lt;&lt; 5) + *Key++; // h &lt;&lt; 5 &lt;==&gt; h*32 &#125; return h%TableSize;&#125; 冲突处理方法对于散列查找而言，产生冲突必定会影响效率，那么如何处理冲突呢？ 开放定址法开放定址法的思路比较简单，说白了，就是这个不行换另外一个，一旦产生了冲突（该地址已有其它元素），就按照某种规则寻找另一个空的地址。按照这种思路，寻找下一空地址的过程，称为探测，而它也有多种不同的探测方法。 线性探测顾名思义，线性探测法就是线性的探测法（说了没说系列？😏），也即以增量序列${1, 2, \ldots}（TableSize - 1）$循环试探下一个地址，也就是检测到冲突了，下标加一试试下一个地址，注意循环到末尾后若还没有空位置，则继续从头部开始循环，此法容易产生“聚集”现象。 平方探测平方探测也叫二次探测，以增量序列${1^2, -1^2, 2^2, -2^2, \ldots, q*2, -q^2}, q \le \lfloor TableSize \rfloor$，循环试探下一个存储地址，此法与线性探测唯一的区别只是增量序列不同而已。但平方探测存在一个很严重的问题，就是“抖动”现象，明明有空位置，但是就是无法探测到散列表的空位置，不过好在可以借助下面这个定理（感谢数学家🙇‍）。 定理：如果散列表长度TableSize是某个$4k+3$（$k$是正整数）形式的素数时，平方探测就可以探查到整个散列表空间。 双散列顾名思义，双散列，就是产生冲突了，再进行一次散列，两次散列的散列函数不同，而是第一次散列的结果将作为第二次散列的key，也即$d_i$为$i \times h_2(key)$，其探测序列为$h_2(key),\ 2h_2(key),\ 3h_2(key), \ldots$，很明显，对任意的key，$h_2(key) \neq 0$，为保证所有的散列存储单元都可以被探测到，$h_2$选为$h_2(key) = p - (key\ mod\ p)$，$p,\ TableSize$都是素数。 再散列当散列表元素太多（即装填因子$\alpha$太大）时，查找效率会下降，实际最大装填因子一般取$0.5 \le \alpha \le 0.85 $，对应的解决办法就是加倍扩大散列表，这个过程就叫做“再散列（Rehashing）”，注意，再散列时，原先的散列序列不是简单的复制，而是要重新计算。 分离链接法分离链接法最终产生的结构有点类似图的邻接表，其基本思想就是将相应位置上冲突的所有关键词存储在同一个单链表中，也就是说这种结构需要一个数组，并且数组内每个元素除了表示关键字还得有一个指针域，用来将链表串起来。 性能分析对于查找而言，衡量其效率的指标，依然是平均查找长度（ASL，分查找成功和不成功两种），平均查找长度的计算方法要视具体的散列方法而定。另外，影响产生冲突多少有以下三个因素： 散列函数是否军运 处理冲突的方法 散列表的装填因子$\alpha$ 下面直接给出其期望探测次数 p，不做深入的数学探讨。 线性探测法：$p =\begin{cases} \frac{1} {2} [1+\frac{1} {(1-\alpha)^2}],&amp; \text {对插入和不成功查找而言} \\\frac{1}{2}[1+\frac{1}{(1-\alpha)}],&amp; \text {对成功查找而言}\end{cases}$平方探测法：$p =\begin{cases} \frac{1} {(1-\alpha)},&amp; \text {对插入和不成功查找而言} \\\frac{-1} {\alpha} ln(1-\alpha),&amp; \text {对成功查找而言}\end{cases}$分离链接法：$p =\begin{cases} \alpha + e^{-\alpha},&amp; \text {对插入和不成功查找而言} \\1+ \frac{\alpha} {2},&amp; \text {对成功查找而言}\end{cases}$ 根据上面的公式我们可以得出下面几点结论： 当装填因子$\alpha &lt; 0.5$时，各种探测法的期望探测次数都不大随着$\alpha$的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数比成功查找的期望探测次数要大合理的最大装填因子$\alpha$应该不超过0.85 总结散列查找的优点很明显，选择合适的散列函数，散列查找效率的期望是常数$O(1)$，它几乎与关键字的空间的大小$n$无关，也适合于关键字直接比较计算量过大的问题；但它是以较小的$\alpha$为前提，是一个以空间换时间的查找方法；另外，它对关键字的存储是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大、最小值查找。 开放定址法的存储效率很高，但是存在“聚集”现象；分离链接法是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低，关键字的删除不需要“懒惰删除（不断链，只标记为空）”，从而没有存储“垃圾”，但太小的$\alpha$可能导致空间浪费，大的$\alpha$又将付出更多的时间代价，且不均匀的链表长度会导致时间效率的严重下降。 Homework11-1 电话聊天狂人这个题姥姥已经讲过了，直接用姥姥的代码有点麻烦，借助 C++ 的 MAP 和散列的思想，可以很轻松的解决这个问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2000000 + 5;map&lt;string, int&gt; phonenum2num;map&lt;int, string&gt; num2phonenum;int times[maxn] = &#123; 0 &#125;, n, index = 1;int main() &#123; cin &gt;&gt; n; string num; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; num; int tmp = phonenum2num.find(num)-&gt;second; if (!tmp) &#123; phonenum2num[num] = index; num2phonenum[index] = num; times[index] = 1; index++; &#125; else &#123; times[tmp]++; &#125; &#125; int max = times[1], maxindex = 1, count = 1; string madman = num2phonenum.find(1)-&gt;second; for (int i = 2; i &lt; index; i++) &#123; if (times[i] &gt; max) &#123; max = times[i]; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; else if (times[i] == max) &#123; if (num2phonenum.find(i)-&gt;second &lt; num2phonenum.find(maxindex)-&gt;second) &#123; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; count++; &#125; &#125; if (count == 1) cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max; else cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max &lt;&lt; ' ' &lt;&lt; count; return 0;&#125;/*samples:in:413005711862 1358862583213505711862 1308862583213588625832 1808792583215005713862 13588625832out:13588625832 3*/ 11-2 Hashing本题考察散列查找的冲突处理方法，题目很直白的告诉了处理冲突的方法是平方探测法，但题目要求的平方探测只会用正整数探测。这方面的知识，课上何老师已经讲的很清楚了，不过这个题的难点在于如何处理无法进行散列的数。 由于题目告诉了只会用正整数探测，其实算是变相的告诉你了，只要经过散列函数得到的下标值大于散列表长度，就认为无法存放了，也就是说并不会循环试探，明白这点后就好办了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 20000 + 10;bool hashTable[maxn] = &#123; 0 &#125;;bool isprime(int n) &#123; if (n &lt;= 1) return false; else &#123; int tmp = (int)sqrt(n); for (int i = 2; i &lt;= tmp; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125;int nextprime(int m) &#123; while (!isprime(m)) m++; return m;&#125;int hashfunc(int num, int hashkey) &#123; return num % hashkey;&#125;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; m = nextprime(m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; int index = hashfunc(tmp, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; &#125; else &#123; int step; for (step = 1; step &lt; m; step++) &#123; index = hashfunc(tmp + step * step, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; break; &#125; &#125; if (step &gt;= m) &#123; if (i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; '-'; &#125; &#125; &#125; return 0;&#125;/*samples:in:4 410 6 4 15out:0 1 4 -in:5 510 6 4 15 25out:0 1 4 - -in:5 55 10 6 4 15 out:0 1 2 4 -in:1 11out:1*/ 11-3 QQ 账户的申请与登陆这题用 MAP 简直太容易了，要是全部自己写，代码量略大。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; qqnum;int main() &#123; int n; char ope; cin &gt;&gt; n; string tmp_num, tmp_pass; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ope &gt;&gt; tmp_num &gt;&gt; tmp_pass; map&lt;string, string&gt;::iterator it; it = qqnum.find(tmp_num); switch (ope) &#123; case 'L': &#123; if (it == qqnum.end()) &#123; cout &lt;&lt; "ERROR: Not Exist" &lt;&lt; endl; &#125; else &#123; if (it-&gt;second == tmp_pass) &#123; cout &lt;&lt; "Login: OK" &lt;&lt; endl; &#125; else cout &lt;&lt; "ERROR: Wrong PW" &lt;&lt; endl; &#125; break; &#125; case 'N': &#123; if (it != qqnum.end()) &#123; cout &lt;&lt; "ERROR: Exist" &lt;&lt; endl; &#125; else &#123; qqnum[tmp_num] = tmp_pass; cout &lt;&lt; "New: OK" &lt;&lt; endl; &#125; break; &#125; default: break; &#125; &#125; return 0;&#125;/*samples:in:5L 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comL 1234567890 myQQ@qqL 1234567890 myQQ@qq.comout:ERROR: Not ExistNew: OKERROR: ExistERROR: Wrong PWLogin: OK*/ 11-4 Hashing - Hard Version这个题的意思很直观，就是给定一个用线性探测法构建的散列表，然后要根据这个得到数字序列的输入顺序。 这个题看起来很容易，其实有点难想。因为就样例而言，33 和 1 都有可能是第一个输入的，该怎么确定数字的输入顺序其实就是难点。 一般而言，做一道题时，想到的都是跟这个题相关的知识。但是这个题，确定输入顺序其实需要用到拓扑排序的知识。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000 + 3;vector&lt;int&gt; AdjL[maxn];int n, hashTable[maxn], elements = 0;bool isvis[maxn] = &#123;false&#125;;map&lt;int, int&gt; value2index;map&lt;int, int&gt; index2value;void toposort() &#123; int indegree[maxn] = &#123;0&#125;; for(int v = 0; v &lt; n; v++) &#123; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]++; &#125; &#125; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) &#123; if(indegree[i] == 0 &amp;&amp; hashTable[i] &gt;= 0) &#123; q.push(hashTable[i]); &#125; &#125; int count = 0; while(!q.empty()) &#123; int tmp = q.top(); q.pop(); cout &lt;&lt; tmp; if(count &lt; elements - 1) &#123; cout &lt;&lt; ' '; count++; &#125; int v = value2index[tmp]; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]--; if(indegree[AdjL[v][w]] == 0) q.push(hashTable[AdjL[v][w]]); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; hashTable[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(hashTable[i] &lt; 0) continue; value2index[hashTable[i]] = i; index2value[i] = hashTable[i]; elements++; int tmp = hashTable[i]; int index = tmp % n; if(hashTable[index] == hashTable[i] &amp;&amp; index == i) continue; else &#123; bool flag = true; queue&lt;int&gt; q; for(; index &lt; n || flag; index++) &#123; if(flag &amp;&amp; index &gt;= n) &#123; index %= n; flag = false; &#125; if(hashTable[index] == tmp) break; q.push(index); &#125; while(!q.empty()) &#123; int front = q.front(); q.pop(); AdjL[front].push_back(index); &#125; &#125; &#125; toposort(); return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_10-排序（下）]]></title>
    <url>%2F2020%2F09%2F05%2FZJU-DS-10-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周继续介绍排序算法。 快速排序快速排序与归并排序的策略有些类似，基本思想也是分治法，首先从待排序列中找一个主元，根据这个主元将待排序列的所有元素划分为两部分，一部分比它小，另一部分比它大，然后对两个子部分在进行划分和排序，依次重复操作，最后再将这些合并为一个序列。基本代码如下：12345678void Quick_Sort(ElementType A[], int N) &#123; if(N &lt; 2) return; pivot = 从A[]中选一个主元; 将S = &#123;A[] / pivot&#125; 分成2个独立子集; A1 = &#123;a ∈ S | A &lt;= pivot&#125;; A2 = &#123;a ∈ S | A &gt;= pivot&#125;; A[] = Quick_Sort(A1, N1)∪(pivot)∪Quick_Sort(A2, N2);&#125; 按照上述的伪码描述，快排需要解决的问题有两个： 1. 如何去选主元2. 如何进行子集划分 很明显，按照思路，能把第一个问题解决了，第二个问题也就迎刃而解了。 选主元那么主元应该怎么去选择呢？比较经典的方法就是取头、中、尾三个数（当然也可以五个数）的中位数（以序列{8, 12, 3}为例，它的中位数是8），选主元时，可以顺便将待选的三位数进行排序，这样当选出主元后，也可以待排序列数据的总个数减少，基本代码如下：123456789101112ElementType Median3(ElementType A[], int Left, int Right)&#123; int Center = (Left + Right)/2; if(A[Left] &lt; A[Center]) Swap(&amp;A[Left], &amp;A[Center]); if(A[Left] &lt; A[Right]) Swap(&amp;A[Left], &amp;A[Right]); if(A[Center] &lt; A[Right]) Swap(&amp;A[Center], &amp;A[Right]); /*after finish swap, A[Left] &lt;= A[Center] &lt;= A[Right]*/ /*put the pivot to A[Right-1], then only consider the sequence from A[Left+1] to A[Right-2]*/ Swap(&amp;A[Center], &amp;A[Right-1]); return A[Right-1];&#125; 按照上述代码，因为最后将pivot放到了Right-1位置，所以，另外两个元素的位置就可以不用在考虑了，只考虑区间$[Left+1, Right-1]$内的元素即可。 子集划分子集划分时，需要使用两个指针，一个首，一个尾，当尾指针小于首指针（两者已交叉）时，说明子集的划分已完成。在进行这个操作时，会存在一个问题，那就是遇到相等的元素怎么办？以最坏的情况（序列元素全部相等）为例，如果采取直接交换元素的方法，那么首、尾指针的每一次变化，都需要交换一次元素，结束后，主元pivot会被放在中间的位置，这样下一次循环的时候就会将剩下的序列在等分成两个序列，这样时间复杂度就是$O(NlogN)$了；那如果跳过相等的元素呢？在最坏的情况下，会有一端的指针停滞不前，那么每次就只有一个指针在移动，这样每次得到的子序列就$N, N-1, N-2, \dots, 1$了，那样时间复杂度依然是$O(N^2)$，所以还是采取交换元素的方法。另外，如果数据规模较小的话，，特别是数据总数连100都不到的时候，对于依然使用递归的快速排序而言，就不是那么划算了，所以需要做个判断，在数据规模较小的时候，采取其他的排序方式。 算法实现选好主元，明确子集的划分方法，就可以来构造算法了，基本代码如下：123456789101112131415161718void QuickSort(ElementType A[], int Left, int Right)&#123; if(Cutoff &lt;= Right-Left)&#123; Pivot = Median3(A, Left, Right); i = Left; j = Right - 1; for(; ; ) &#123; while(A[++i] &lt; pivot); while(A[--j] &gt; pivot); if(i &lt; j) Swap(&amp;A[i], &amp;A[j]); else break; &#125; Swap(&amp;A[i], &amp;A[Right-1]); QuickSort(A, Left, i-1); QuickSort(A, i+1, Right); &#125;else Insertion_Sort(A+Left, Right-Left+1);&#125; 上述代码的思路比较直观，先选好主元，在进行子集划分，然后将主元放到靠近中间的位置，此时主元的位置与最终结果序列的位置是一致的，这点与冒泡排序一样，每次都会有一个元素被排到最终位置。当待排元素小于阈值Cutoff时，直接使用插入排序解决剩下的元素序列。 表排序表排序适用于待排元素不是简单的整数，而是复杂、庞大的元素的时候，因为这些复杂、庞大的元素的交换和移动会十分费时。也就是说，表排序在排序过程中不需要移动元素，只需要移动指针即可，这种不移动元素，只移动指针的排序方法称为间接排序。定义一个指针数组作为“表”（table），表排序算法的操作对象就是这个“表”了。 物理排序假若仍然需要移动实际的元素来完成排序，那么可以根据下面这个结论在线性的时间复杂度内完成这个操作。 定理：N个数字的排列由若干个独立的环组成。 这里的“环”，其实是一个比较抽象的概念，指的是经过表排序后等到的table内，有些元素的顺序会形成一个序列，而这个序列就称作“环”。下面来看个例子，表排序前： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 表排序后： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 上表中，由{3, 5, 1, 0}这个下标序列可得对应的有序序列为{a, b, d, f}，这个序列是有序的，其对应关系如下表： A [0] [1] [3] [5] table 3 5 1 0 由上表中构成的关系，就是“环”，可以根据“环”得到有序的序列。紧接着，根据这些有序的序列，借助一个临时空间，遍历一次这个有序序列，就可以完成物理序列的排序。很明显可以得到，当table[i] == i时，环就结束了。 时间复杂度分析当初始序列为有序时，是最好的情况；当有$\lfloor N/2 \rfloor$个环时，每个环包含2个元素，交换两个元素需要三步操作，就需要$\lfloor 3N/2 \rfloor$次元素移动，而表排序针对的就是元素移动时间较长的存储结构，所以时间复杂度为$T = O(m\ N)$，$m$为每个元素的复制时间。 基数排序基数排序与其他排序算法有一个很大的差别，那就是不仅只是比大小了，因为单纯靠比较大小的排序算法的时间复杂度最低只能是$T(NlogN)$这个级别，所以得在添点“料”来继续提升速度，下面先来看看桶排序。 桶排序对于桶排序而言，假设待排序列有$N$个元素，先申请$N$个桶（有序，桶内保存指针），然后将每一个符合条件的值，插到这个有序的桶排列中，这样就可以了，大致代码如下：1234567891011void Bucket_Sort(ElementType A[], int N) &#123; count[]初始化; while(读入一个数据) &#123; 将该数据插入count[桶内保存的指针++]; &#125; for(i=0; i&lt;M; i++) &#123; if(count[i])&#123; 输出count[i]整个链表; &#125; &#125;&#125; 按照上述的伪码，有$N$个数据需要读入，$M$个数据需要输出，所以时间复杂度为$T(N, M) = O(M + N)$。但是当$M &gt;&gt; N$的情况下，使用桶排序就不是那么划算了，这就需要使用基数排序了。 桶排序基本思想了解了桶排序之后，基数排序就好理解了，基数排序建桶规则是按照给定数据的进制数建桶，例如{78, 123, 44, 678}， 这个序列的数都是十进制的，所以基数（桶的大小）为 10。 基数排序算法的主体思想采用的是次位优先（Least Significant Digit）的思想（也可以使用主位优先(Most Significant Digit)），简单来讲，第一次排序以个位数大小为基准来排序，第二次排序以十位数大小为基准来排序，但需要将第一次排序中的高位数拿出来，重复至最高位排完后结束。每躺排序过程中，需要访问$N$个结点，也需要访问$B$个桶，所以时间复杂度为$T=O(P(N+B))$。 多关键字排序扑克牌的花色就是一种“多关键字排序”，不同花色同花顺也有大小之分。 以为扑克牌排序为例，扑克牌有两种属性，分别是花色和大小，一副整齐的扑克牌，花色和大小必定都是整齐的，根据基数排序的思想，我们可以先按照大小来做基数排序，这需要13个桶来完成，排好序后，各个桶中的牌的大小都是相等的，此时我们在以花色为基数建桶，依次取出花色按顺序取出花色相同的牌放到不同花色的桶内即可，已经不需要根据大小排序了。 排序算法的比较 排序方法 平均时间复杂度 最坏情况时间复杂度 额外空间复杂度 稳定性 简单选择排序 $O(N^2)$ $O(N^2)$ $O(1)$ 不稳定 冒泡排序 $O(N^2)$ $O(N^2)$ $O(1)$ 稳定 直接插入排序 $O(N^2)$ $O(N^2)$ $O(1)$ 稳定 希尔排序 $O(N^d)$ $O(N^2)$ $O(1)$ 不稳定 堆排序 $O(NlogN)$ $O(NlogN)$ $O(1)$ 不稳定 快速排序 $O(NlogN)$ $O(N^2)$ $O(logN)$ 不稳定 归并排序 $O(NlogN)$ $O(NlogN)$ $O(N)$ 稳定 基数排序 $O(P(N+B))$ $O(P(N+B))$ $O(N+B)$ 稳定 尽管上表中给出了各排序算法的具体的时间复杂度，但是实际应用时还是需要根据实际情况来选择合适的排序算法。另外，从表中看到堆排序的性能比较好，但是实际效果不太理想。除了这些基础排序算法外，还有很多其他的排序算法，那些也值得进一步学习。 Homework10-4 统计工龄这个题目很简单，借助一下姥姥课上讲的桶排序的思想即可，C++ 语法的代码如下：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;int main() &#123; int n; std::cin &gt;&gt; n; int staff[55] = &#123; 0 &#125;, tmp; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; tmp; staff[tmp]++; &#125; for (int i = 0; i &lt; 52; i++) &#123; if (staff[i]) std::cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; staff[i] &lt;&lt; std::endl; &#125; return 0;&#125;/*samples:in:810 2 0 5 7 2 5 2out:0:12:35:27:110:1in:1010 2 0 0 0 5 7 2 5 2out:0:32:35:27:110:1*/ 10-5 PAT Judge这道题目的出题背景应该就是 PAT 的排名系统了，但其实是甲级题库的一道排序题，需要按照题目的要求来进行排序，直接使用 C++ 的库函数会方便许多。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10000 + 5;struct user&#123; int id, scores[6], sum, perfect; bool flag;&#125; us[maxn];int n, k, m, p[6] = &#123;0&#125;;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void init() &#123; for(int i = 1; i &lt;= n; i++) &#123; us[i].id = i; us[i].sum = us[i].perfect = 0; us[i].flag = false; memset(us[i].scores, -1, sizeof(us[i].scores)); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", p + i); &#125; int id, proid, scoob; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;proid, &amp;scoob); if(scoob != -1) us[id].flag = true; if(scoob == -1 &amp;&amp; us[id].scores[proid] == -1) us[id].scores[proid] = 0; if(scoob == p[proid] &amp;&amp; us[id].scores[proid] &lt; p[proid]) us[id].perfect++; if(scoob &gt; us[id].scores[proid]) us[id].scores[proid] = scoob; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] &gt; 0) us[i].sum += us[i].scores[j]; &#125; &#125; sort(us + 1, us + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; us[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) rank = i; printf("%d %05d %d", rank, us[i].id, us[i].sum); for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] == -1) printf(" -"); else printf(" %d", us[i].scores[j]); &#125; putchar('\n'); &#125; return 0;&#125; /*samples:in:7 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0out:1 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 -in:3 4 920 25 25 3000001 3 3000002 3 3000003 3 3000001 3 3000002 3 2000003 3 2000001 3 3000002 3 1000003 3 30out:1 00001 30 - - 30 -1 00002 30 - - 30 -1 00003 30 - - 30 -in:2 2 620 2000001 1 -100002 1 -100001 1 -100002 1 -100001 1 -100002 1 0out:(blank)*/ 10-6 Sort with Swap(0, i)这个题不太好想，但是与表排序非常类似。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int pos[maxn], n, ans = 0;int main() &#123; cin &gt;&gt; n; int remains = n - 1, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; pos[tmp] = i; if(tmp == i &amp;&amp; tmp != 0) remains--; &#125; int k = 1; while(remains &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; remains--; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;/*samples:in:103 5 7 2 6 4 9 0 8 1out£º9in:54 0 2 1 3out:3in:30 2 1out:2in:54 3 2 1 0out:4*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_09_排序（上）]]></title>
    <url>%2F2020%2F09%2F02%2FZJU-DS-09-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周将会介绍几种常见的排序算法。 简单排序简单排序是几个简单的排序算法的统称，下面来一一介绍。 冒泡排序冒泡排序的思想比较直观，每次循环时，会将数组（或链表）内相邻的两个元素进行比较，按照规定的递增（或递减）顺序向后移动，一直到重复到末尾，基本代码如下：123456789void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); &#125; &#125; &#125;&#125; 代码框架十分简单，但是这样会有一个问题，那就是待排序列在已经有序的情况下，依然会进行两次循环，尽管不会交换相邻元素的值，但是还是会进行判断，会白白浪费时间。仔细想一下，如果输入序列是有序的，那么元素的值一次也不会交换，根据这个特点，可以对上述的代码进行一点小优化，添加一个标志位，一次有序后就可以直接跳出循环了。具体代码如下：123456789101112void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; flag = 0; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); flag = 1; &#125; &#125; if(!flag) break; &#125;&#125; 按照上述代码的思路，可以较为清晰的分析出冒泡排序算法的时间复杂度： 最好的情况，序列为顺序序列，$T = O(N)$ 最坏的情况，序列为逆序序列，$T = O(N^2)$ 另外，对于冒泡排序而言，每一次冒泡结束（内层循环结束一轮）后都会有一个元素被放到这个序列有序后的最终位置上，而且，冒泡排序也不会交换相同元素的位置（使用$&gt;$而不是$\geq$），所以冒泡排序是稳定的排序算法，再者，冒泡排序还有一个优点，即排序的方向是一定的，只会按照一个方向遍历存储数据的数据结构，这是其他排序算法无法达到的。 插入排序插入排序有个很形象的例子，就是打扑克牌时“理牌”的过程，不过可能有点差别。区别在于，理扑克牌时，手上是没有牌的，而需要理的牌在牌堆里面，也就是说，有两个空间可以放牌，但插入排序实际上只使用了一个内存空间，这样的话，每一次插入时就需要先找到插入的位置了。按照“理牌”的过程来描述就是：先摸一张牌，从后往前找到合适的插入位置，将比这张牌大的牌向后移（腾出位置），再将新牌插入到这个位置下即可。基本代码如下：123456789void Insertion_Sort(ElementType A[], int N) &#123; for(P=1; P&lt;N; p++) &#123; temp = A[P]; for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;temp; i--) &#123; A[i] = A[i-1]; &#125; A[i] = temp; &#125;&#125; 插入排序和冒泡排序的时间复杂度类似： 最好的情况，序列为顺序序列，$T = O(N)$ 最坏的情况，序列为逆序序列，$T = O(N^2)$ 同时，插入排序也是稳定的排序算法。 时间复杂度下界 对于下标$i &lt; j$，如果$A[i] &gt; A[j]$，则称$(i, j)$是一对逆序对（Inversion）如序列${2, 3, 1}$中，$(2, 1)$和$(3, 1)$分别是一对逆序对，逆序对的个数称为逆序数，这与线性代数中的概念是一致的。 在冒泡排序和插入排序中，每次交换位置的两个相邻元素正好消去 1 个逆序对，那么它们的时间复杂度就是：$T(N, I) = O(N+I)$，其中$I$是逆序对的对数。很明显，如果序列基本有序，则$I$值可忽略不计，时间复杂度仅为$T(N)$，此时算法既简单，又高效。 定理：对于任意N个不同元素组成的序列平均具有$N(N-1)/4$个逆序对。 由上面的定理，我们可以得出：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为$\Omega(N^2)$。这意味着，如果想要提高算法的效率，就得在每次交换元素时，不止消去 1 个逆序对，这就要求每次交换的两个元素要在序列中相隔的比较远。 希尔排序希尔排序的主要目的就是每次交换元素时，通过消去多个逆序对来达到提升算法效率。其主要思想：先定义增量序列$D_M &gt; D_{M-1} &gt; \dots &gt; D_1 = 1$，然后对每个$D_k$进行“$D_k$-间隔”排序（$k=M, M-1, \dots,1$），值得注意的是，后面进行的“间隔”排序不会影响前面“间隔”排序的有序性，也即“$D_k$-间隔”有序的序列，在执行“$D_{k-1}$-间隔”排序后，仍然是“$D_k$-间隔”有序的。原始希尔排序，增量依次减半，$D_M = \lfloor N/2 \rfloor, D_k = \lfloor D{k+1}/2 \rfloor$，此时最坏情况下的时间复杂度为$T = \Theta(N^2)$，基本代码如下：1234567891011void Shell_Sort(ElementType A[], int N) &#123; for(D=N/2; D&gt;0; D/=2) &#123; for(P=D; P&lt;N; P++) &#123; temp = A[P]; for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;temp; i-=D) &#123; A[i] = A[i-D]; &#125; A[i] = temp; &#125; &#125;&#125; 在最坏的情况（每次进行间隔排序的序列都是有序的）下，希尔排序会退化成插入排序，原因在于增量元素不互质，则小增量可能根本不起作用。为了解决这个问题，引入了更多的增量序列： Hibbard增量序列，$D_k = 2^k - 1$，这样保证了相邻增量元素互质，最坏情况下$T = \Omega(N^{3/2})$，猜想$T_{avg} = O(N^{5/4})$ Sedgewick增量序列，${1, 5, 19, 41, 109, \dots}$，也即增量序列的每一个元素是由$9 \times 4^i + 1$或$4^i - 3 \times 2^i + 1$计算得到，猜想$T_{avg} = O(N^{7/6}), T_{worst} = O(N^{4/3})$ 由于希尔排序每次对增量序列进行排序，相邻的相等元素属于不同增量序列，则希尔排序可能会改变相等且相邻元素的相对位置，属于不稳定的排序。 选择排序选择排序是一种简单直观的排序算法，基本工作原理是每一次从待排序的数据元素中选出最小（大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，重复此过程直到全部待排序的数据元素排完。 简单选择排序简单选择排序的思路很简单，与选择排序的基本思想一致，基本代码如下：12345678void Selection_Sort(ElementType A[], int N) &#123; for(i=0; i&lt;N; i++) &#123; //find the minimum from A[i] to A[n-1], and return to Position MinPosition = ScanForMin(A, i, N-1); //replace the minimum element to the last position of the ordered part Swap(A[i], A[MinPosition]); &#125;&#125; 简单选择排序的时间复杂度主要有两个影响条件，第一个是查找最小值，第二个是交换，所以它的时间复杂度无论怎样都是$T=\Theta(N^2)$。 堆排序分析了简单选择排序算法的时间复杂度后，发现简单选择排序的时间都耗费在了查找最小值上，如果能把这一操作变快，那么简单选择排序的效率就能提高。根据选择排序的特点，每次查找的值必须是最小（大）值，这与小（大）根堆的性质是一致的，那么使用堆来进行元素的查找，每次弹出最小（大）值，就可以提升排序效率。基本代码如下：123456789void Heap_Sort(ElementType A[], int N) &#123; BuildHeap(A); for(i=0; i&lt;N; i++) &#123; tempA[i] = DeleteMin[A]; &#125; for(i=0; i&lt;N; i++) &#123; A[i] = tempA[i]; &#125;&#125; 上述代码的过程比较简单，每次找出最小（大）元素后，保存在一个临时数组内，然后在将临时数组内的排序结果复制到原始数组中。这样即需要额外的空间（$O(N)$）去存储这部分数据，又要额外的时间去复制元素。那么如何去避免这部分开销呢？请看下面的代码： 123456789void Heap_Sort(ElementType A[], int N) &#123; for(i=N/2; i&gt;=0; i--) &#123; PercDown(A, i, N); //Build heap &#125; for(i=N-1; i&gt;0; i--) &#123; Swap(&amp;A[0], &amp;A[i]); //delete max PercDown(A, 0, i); &#125;&#125; 按照上述代码，建立一个大根堆，排序开始后，交换大根堆最大元素与最末尾元素的值，完成后，将这个最大值剔除出堆，紧接着再调整为大根堆，重复执行上述操作。 定理：堆排序处理N个不同元素的随机排列的平均比较次数是$2NlogN - O(N log logN)$ 虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。 归并排序归并排序的核心就是有序子列的归并，首先，申请空间，保存合并后的有序序列，设定两个指针，最初位置分别为两个有序序列的起始位置，比较两个指针指向的元素，选择相对小的元素放到申请的空间内，并移动指针到下一位置，重复直至某一个子序列超出序列尾，接着将另一序列剩下的所有元素直接复制到申请空间的尾部。合并两个有序子列的基本代码如下：12345678910111213141516void Merge(ElementType A[], ElementType TempA[], int L, int R, int RightEnd) &#123; LeftEnd = R-1; //Suppose two subsequences are side-by-side Tmp = L; //initial position NumElements = RightEnd - L + 1; while(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd) &#123; if(A[L] &lt;= A[R]) TempA[Tmp++] = A[L++]; else TempA[Tmp++] = A[R++]; &#125; // copy the rest straightly while(L &lt;= LeftEnd) TempA[Tmp++] = A[L++]; while(R &lt;= RightEnd) TempA[Tmp++] = A[R++]; //copy the result to A[] from right to left for(i=0; i&lt;NumElements; i++, RightEnd--) &#123; A[RightEnd] = TempA[RightEnd] &#125;&#125; 归并算法在实现的时候有两种不同的策略，下面先介绍递归。 递归归并排序的递归算法的思想是基于分治法的，先将分开的子序列排好，在合并成一个大的序列。基本代码如下：123456789void MSort(ElementType A[], ElementType TempA[], int L, int RightEnd) &#123; int Center; if(L &lt; RightEnd) &#123; Center = (L + RightEnd)/2; MSort(A, TempA, L, Center); MSort(A, TempA, Center+1, RightEnd); Merge(A, TempA, L, Center+1, RightEnd); &#125;&#125; 基于分治法的归并排序递归算法的时间复杂度为$T(NlogN)$，推导过程如下：$$\begin{align} T(N)&amp; = 2 T(N/2)) + cN \\&amp; = 2\ (2T(N/2^2) + c N/2) + cN \\&amp; = \dots = 2^k * O(1) + ckN \\&amp; = O(NlogN)\end{align}$$可得$T(N) = O(NlogN)$，这个时间复杂度是很“强”的😆，也即是说在任何情况下（无论好坏）都是$NlogN$，另外，归并排序是稳定的排序算法。为了使它与上述其他排序算法的函数接口统一，再整理下代码：12345678void Merge_Sort_Recursion(ElementType A[], int N) &#123; ElementType *TempA; TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; MSort(A, TempA, 0, N-1); free(TempA); &#125; else Error("Insufficient Space.");&#125; 注意在上面的代码中，临时传递使用的数组是声明在Merge_Sort函数中的，这样做的好处就是避免了在MSort中重复声明和重复释放内存操作。 非递归归并排序的非递归算法基本思想依然是分治法的思想，每次循环先归并相邻的两个子列，子列长度逐渐增加，直至最后左右两个子列之和大于序列总长度。基本代码如下：123456789101112131415161718192021222324252627282930void Merge_Sort_Non_Recursion(ElementType A[], int N) &#123; int length; ElementType *TempA; length = 1; //initialize the length of subsequence TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; while(length &lt; N) &#123; Merge_pass(A, TempA, N, length); //left length *= 2; Merge_pass(TempA, A, N, length); //right length *= 2; &#125; &#125; else printf("Insufficient Space.\n");&#125;/*Merge adjacent ordered subsequence in pairs accroding to the current length of subsequence*/void Merge_pass(ElementType A[], ElementType TempA[], int N, int length) &#123; int i, j; for(i=0; i&lt;=N-2*length; i+=length) &#123; Merge(A, TempA, i, i+length, i+2*length-1); &#125; if(i+length &lt; N) &#123; //Merge the last two subsequence Merge(A, TempA, i, i+length, N-1); &#125; else &#123; //only one subsequence last for(j=i; j&lt;N; j++) TempA[j] = A[j]; &#125;&#125; 注意上述代码中的细节，Merge_pass是一个按照序列长度进行一次归并的函数，当序列长度发生变化的时候，将再次调用此函数，另外，在此函数内，for循环内归并的序列是前N/length - 1对，而不是N/length对，如果N是奇数，最后一个子列就被单独出来了，它与其他子列的长度不等，所以针对最后一个子列的处理，要与前面区分开来。再者，上述代码中length增长的倍数是2，理论上即是二路归并。 小结归并排序算法的优点很明显，那就是在任何情况（无论好坏）下，其时间复杂度都是$T(NlogN)$，同时，它还是稳定的排序算法，但是它有一个很明显的缺点，就是需要占用$O(N)$大小的空间，并且在内存内要频繁的进行倒换操作，所以，一般内部排序中不会使用归并排序，外部排序会使用归并排序。 Homework09-1 排序这个题专门用来检测自己实现的排序算法，最好把老师讲了的都实现一下。 冒泡排序123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void bubble_sort(int *array, int n) &#123; for(int i = n - 1; i &gt; 0; i--) &#123; bool flag = true; for(int j = 0; j &lt; i; j++) &#123; if(array[j] &gt; array[j + 1])&#123; swap(&amp;array[j], &amp;array[j + 1]); flag = false; &#125; &#125; if(flag) break; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; bubble_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 插入排序123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 希尔排序123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; for(int i = n - 1; i &gt; 0; i--) &#123; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; heap_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 归并排序非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; merge_pass(tmparr, array, n, length); length *= 2; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 递归12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void msort(int *array, int *tmparr, int left, int rightend) &#123; int center; if(left &lt; rightend) &#123; center = (left + rightend) / 2; msort(array, tmparr, left, center); msort(array, tmparr, center + 1, rightend); merge(array, tmparr, left, center + 1, rightend); &#125;&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; msort(array, tmparr, 0, n - 1); free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 09-2 Insert or Merge这个题形式简单，但是要想得满分，必须得对插入排序跟归并排序都很了解才行。 题目要求输出两样东西： 判断属于那一种排序 然后输出再进行下一次这种排序后所得的序列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; if(issame(tmparr)) &#123; merge_pass(tmparr, array, n, length); printarray(array, n); break; &#125; merge_pass(tmparr, array, n, length); length *= 2; if(issame(array)) &#123; merge_pass(array, tmparr, n, length); printarray(tmparr, n); break; &#125; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Merge Sort\n"); merge_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6out:Merge Sort1 2 3 8 4 5 7 9 0 6*/ 09-3 Insertion or Heap Sort这个题与上题类型一致，只不过把归并排序换成了堆排序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; int i; for(i = n - 1; i &gt; 0; i--) &#123; if(issame(array)) break; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); printarray(array, n);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Heap Sort\n"); heap_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9out:Heap Sort5 4 3 1 0 2 6 7 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_08-图（下）]]></title>
    <url>%2F2020%2F08%2F31%2FZJU-DS-08-%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这周课程主要介绍了图的另外两个应用：最小生成树和拓扑排序，顺带讲了一下关键路径 最小生成树什么是最小生成树（Minimum Spaning Tree）？它首先是一棵树，所以它没有回路，且 V 个顶点的最小生成树一定有 V-1 条边（这就是树的性值）。既然是生成树，所以这棵树包含了图中所有顶点，树中的 V-1 条边一定也都在图内；那最小是什么？最小的含义是指边的权重和最小。这里要注意，如果图是连通的，那么这个图一定存在最小生成树且不一定唯一。 下面介绍的两种生成最小生成树的算法本质思想都是基于“贪心”，这与前面的 Dijkstra 算法是一致的。所谓“贪心”，即是指每一步都要“最好”的，在最小生成树中，权重最小的边也就是“最好”的了。 Prim 算法Prim 算法的大致过程从一个顶点开始，慢慢的生长成一棵树，先看下它的伪码描述：12345678910111213141516171819void Prim() &#123; MST = &#123;S&#125;; while(1) &#123; V = 未收录顶点中 dist 最小者; if(V 不存在) break; 将 V 收录进 MST; dist[V] = 0; for(V 的每个邻接点 W) &#123; if(dist[W] != 0) &#123; if( 边权(V,W) &lt; dist[W]) &#123; dist[W] = 0; parent[W] = V; &#125; &#125; &#125; &#125; if(MST 中收录的顶点不到 |Ｖ| 个) Error("生成树不存在");&#125; Prim 算法与 Dijkstra 算法十分类似，就是循环内的判断条件不一样，其他基本一致。以下图为例，手动模拟一下 Prim 算法的运行过程。dist 数组用来筛选边权最小的顶点；parent 数组来保存树，且 parent 数组需要初始化为 -1，这里与并查集的思路是类似的。 以$v_1$为源点，dist 数组初始化： index 1 2 3 4 5 6 7 dist 0 ∞ ∞ ∞ ∞ ∞ ∞ parent -1 -1 -1 -1 -1 -1 -1 直接将 dist[1] 初始化为 0，然后$v_1$作为未收录顶点中 dist 最小者，将其收录进 MST，再访问其每个邻接点，此时可以将 dist 数组的值更新： index 1 2 3 4 5 6 7 dist 0 2 4 1 ∞ ∞ ∞ parent -1 1 1 1 -1 -1 -1 接着，未收录顶点中 dist 最小者就是$v_4$，收录进 MST，此时 dist 和 parent 数组更新： index 1 2 3 4 5 6 7 dist 0 2 2 0 7 7 4 parent -1 1 4 1 4 4 4 可以看到，因为$(v_4, v_3) &lt; (v_1, v_3)$，所以 dist[3] 与 parent[3] 的值将会得到更新。 再来，未收录顶点中 dist 最小者就是$v_2$，收录进 MST，此时 dist 和 parent 数组更新： index 1 2 3 4 5 6 7 dist 0 0 2 0 7 8 4 parent -1 1 4 1 4 4 4 依次类推，收录$v_3$，有： index 1 2 3 4 5 6 7 dist 0 0 0 0 7 5 4 parent -1 1 4 1 4 3 4 收录$v_7$，有： index 1 2 3 4 5 6 7 dist 0 0 0 0 6 1 0 parent -1 1 4 1 7 7 4 最后再分别选取$v_6$和$v_5$后，MST 中收录的顶点达到 |V| 个后就得到了最小生成树。通过上面也可以看出，Prim 中的 dist 数组的用途与 Djikstra 算法中 dist 数组的用途是完全一致的，只是两者的判断条件不一样而已。另外，Prim 算法的时间复杂度也就是$O(|V|^3)$。 Kruskal 算法Kruskal 算法的大致过程是在“选边”，也就是将森林合并成树，其伪码描述为：123456789101112131415void Kruskal(Graph G) &#123; MST = &#123;&#125;; while(MST 中找不到 |V|-1 条边 &amp;&amp; E 中还有边) &#123; 从 E 中取一条权重最小的边 E(v, w); //使用最小堆实现 将取出的最小边 E(v, w)从 E 中删除; if(E(v, w) 不在 MST 中构成回路) &#123; //使用并查集实现 将 E(v, w)加入 MST; &#125; else &#123; 彻底无视 E(v, w); &#125; &#125; if(MST 中找不到 |V|-1 条边) &#123; Error("生成树不存在"); &#125;&#125; 以下图为例，手动模拟一下 Kruskal 算法的运行过程。 依次加入边$(v_1, v_4)$、$(v_6, v_7)$、$(v_1, v_2)$、$(v_3, v_4)$、$(v_4, v_7)$、$(v_5, v_7)$即可，整个过程讲起来比 Prim 算法简单了不少，但是实现起来就稍微复杂一点，既要用到最小堆，又要用到并查集，但其时间复杂度也稍微优秀一点（相比 Prim），为：$O(|E|Log|E|)$。另外，笔试题中，Kruskal 算法解题速度是第一名，谁用谁知道。 拓扑排序拓扑排序不同于普通排序，普通排序就是按照某一规则对具有同类性质的元素进行升序或降序排序；而拓扑排序是针对有向无环图（Directed Acyclic Graph，DAG）G 进行的，是将图 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 $&lt;u, v&gt;$是图 G 的边（也即存在一条 u 到 v 的有向路径），则 u 在线性序列中一定出现在 v 之前，这样的序列叫做拓扑序列，而这个得到这个序列的过程就叫做拓扑排序。 而姥姥讲的 AOV 网，具体定以请点击链接参考下百度百科。另外，对于一个 AOV 网而言，如果有合理的拓扑序，则其必定是有向无环图。换句话说，也就是说拓扑排序可以用来检测图内是否有环，这也是笔试题中常用的知识点。 拓扑排序的伪码算法如下：12345678910111213141516171819void TopSort() &#123; for(图中每个顶点 V) &#123; if(Indegree[V] == 0) &#123; Enqueue(V, Q); &#125; &#125; while(!IsEmpty(Q)) &#123; V = Dequeue(Q); 输出V，或者记录 V 的输出序号; cnt++; for(V 的每个邻接点 W) &#123; if(--Indegree[W] == 0) &#123; Enqueue(W, Q); &#125; &#125; &#125; if(cnt != |V|) &#123; Error("图中有回路"); &#125;&#125; 关键路径关键路径问题是针对 AOE（Activity On Edge）网络而言的，属于拓扑排序的应用，一般用于安排项目的工序问题，图中的边代表工序，工序与工序之间有先后关系。也可以理解为边代表活动，顶点表示这个活动的结束，按照姥姥 PPT 中的介绍来理解即可，如下图所示： 接着跟着姥姥的 PPT 一起手动计算关键路径，可以得到下图的结果。 在上面的问题中，注意对那条“虚边”的理解，之所以会有这条虚边，其实是因为要想到达顶点 7，必须要先到达顶点 4 和 5。可能有人会问为什么是从 5 指向 4，很简单，因为 4 后到达，5 会先到达，如果 5 后到达，4 先到达，那就是 4 指向 5 了。 另外需要注意的就是机动时间的计算，还是要先理解机动时间的概念。机动时间这个东西，实际上就是可以偷懒的时间，后完成的人不能偷懒，但先完成的人就可以偷懒了。以顶点 5 为例，它的机动时间就是：$D_{&lt;5, 7&gt;} = Latest[7] - Earliest[i] - C_{&lt;5, 7&gt;} = 14 - 7 - 4 = 3$。会算这些东西后，就可以找出关键路径了，值得注意的是对一个 AOE 网而言，关键路径不一定是唯一的，这个从上图就可以看出。 Homework08-7 公路村村通很直观的最小生成树问题，一遍 Prim 算法就搞定了，如果不连通就输出 -1，反之就输出最小生成树的边权之和，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt; #define maxn 1005const int inf = 0x3fffffff;int nv, ne, G[maxn][maxn], dist[maxn];bool visited[maxn] = &#123; false &#125;;void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; for (int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void prim() &#123; for (int i = 0; i &lt; maxn; i++) dist[i] = inf; dist[1] = 0; int times = 0, totalweight = 0; while(1) &#123; int mindis = inf, v = -1; for (int i = 1; i &lt;= nv; i++) &#123; if (!visited[i] &amp;&amp; dist[i] &lt; mindis) &#123; mindis = dist[i]; v = i; &#125; &#125; if (v == -1) break; times++; visited[v] = true; totalweight += dist[v]; for (int w = 1; w &lt;= nv; w++) &#123; if (G[v][w] != inf &amp;&amp; !visited[w] &amp;&amp; G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; if (times == nv) printf("%d", totalweight); else printf("-1");&#125;int main() &#123; scanf("%d %d", &amp;nv, &amp;ne); init(); int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; scanf("%d %d %d", &amp;v1, &amp;v2, &amp;weight); G[v1][v2] = G[v2][v1] = weight; &#125; prim(); return 0;&#125;/*samples:in:6 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3out:12*/ 08-8 How Long Does It Take这道题虽然是英文的，但是题意很直观，就是直接求关键路径的最早完成时间，但实际上并没有要求也要输出关键路径，减少了点麻烦吧。解决这个问题的思路就是利用先拓扑排序，得到一个拓扑序列，然后通过这个拓扑序列来关键路径的最早完成时间。我们使用 STL 来偷下懒，将 Vector 当作邻接表来存储图，利用 Vector 内的成员函数 emplace_back（C++11 的新特性）来输入顶点和对应的边权要方便一些，但要这样用得先写好 node 的构造函数。在进行拓扑排序时，可以顺便将最早完成时间也一并计算出来。为了避免图可能不是连通的，也就是说此时是无解的，需要设置一个计数器来记录所得到的拓扑序列的顶点个数，如果与图的顶点总数不相等，那也就是说图是不连通的。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node&#123; int w, weight; node(int w, int weight) &#123; this-&gt;w = w; this-&gt;weight = weight; &#125;&#125;;vector&lt;node&gt; G[maxn];int nv, ne, indegree[maxn] = &#123; 0 &#125;, cost[maxn];void topsort() &#123; queue&lt;int&gt; q; for (int v = 0; v &lt; nv; v++) &#123; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]++; &#125; &#125; for (int i = 0; i &lt; maxn; i++) cost[i] = -1; int count = 0; for (int i = 0; i &lt; nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); cost[i] = 0; &#125; &#125; while (!q.empty()) &#123; int v = q.front(); q.pop(); count++; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]--; if (cost[G[v][w].w] &lt; cost[v] + G[v][w].weight) &#123; cost[G[v][w].w] = cost[v] + G[v][w].weight; &#125; if (indegree[G[v][w].w] == 0) &#123; q.push(G[v][w].w); &#125; &#125; &#125; if (count != nv) cout &lt;&lt; "Impossible"; else &#123; int max = cost[0]; for (int i = 1; i &lt; nv; i++) &#123; if (max &lt; cost[i]) max = cost[i]; &#125; cout &lt;&lt; max; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight; G[v1].emplace_back(v2, weight); &#125; topsort(); return 0;&#125;/*samples:in:9 120 1 60 2 40 3 51 4 12 4 13 5 25 4 04 6 94 7 75 7 46 8 27 8 4out:18in:4 50 1 10 2 22 1 31 3 43 2 5out:Impossiblein:7 60 3 23 4 21 2 32 4 24 5 34 6 2out:8*/ 08-9 关键活动这道题没啥说的，就是关键路径的问题。相比上道题，这道题要麻烦一些，因为这个题不仅要输出最早完成时间，还得输出关键路径，多亏了 STL 省了很多麻烦。求最早完成时间的思路与上面那题是一样的，直接一个拓扑排序就完事了。难点在于如何找关键路径，不能简单的直接拿拓扑序列来反向输出，那怎么办呢？仔细回忆一下课上的例子，可以发现关键路径的关键活动没有空余时间，假如 e 是活动的最早完成时间，l 是活动的最晚开始时间，那么关键活动的 e 与 l 是相等。按照这样的思路，将拓扑序列中的所有的关键活动的 e 和 l 求出，并进行比较，如果相等，就是关键活动了，当然了，前提是拓扑序列是存在的。但是别忘记了，题目要求从小到大输出关键活动，所以还需要对找出的序列进行排序，然后再输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node &#123; int v, w; node(int v, int w) &#123; this-&gt;v = v; this-&gt;w = w; &#125;&#125;;bool cmp(int a, int b) &#123; return b - a;&#125;vector&lt;node&gt; G[maxn];stack&lt;int&gt; topo;int nv, ne, ve[maxn] = &#123; 0 &#125;, vl[maxn], indegree[maxn] = &#123; 0 &#125;;bool topoorder() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= nv; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; indegree[G[i][j].v]++; &#125; &#125; for (int i = 1; i &lt;= nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); ve[i] = 0; &#125; &#125; while (!q.empty()) &#123; int u = q.front(); topo.push(u); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; indegree[G[u][i].v]--; if (ve[G[u][i].v] &lt; ve[u] + G[u][i].w) &#123; ve[G[u][i].v] = ve[u] + G[u][i].w; &#125; if (indegree[G[u][i].v] == 0) q.push(G[u][i].v); &#125; &#125; if (topo.size() != nv) return false; else return true;&#125;void criticalpath() &#123; int max = ve[1], maxid = 1; for (int i = 2; i &lt;= nv; i++) &#123; if (ve[i] &gt; max) &#123; max = ve[i]; maxid = i; &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; for (int i = 0; i &lt; maxn; i++) vl[i] = max; while (!topo.empty()) &#123; int u = topo.top(); topo.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v; if (vl[v] - G[u][i].w &lt; vl[u]) &#123; vl[u] = vl[v] - G[u][i].w; &#125; &#125; &#125; vector&lt;int&gt; keyact[maxn]; for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v, w = G[u][i].w; int e = ve[u], l = vl[v] - w; if (e == l) keyact[u].push_back(v); &#125; &#125; for (int i = 1; i &lt;= nv; i++) sort(keyact[i].begin(), keyact[i].end(), cmp); for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; keyact[u].size(); i++) &#123; cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; keyact[u][i] &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int u, v, w; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].emplace_back(v, w); &#125; if (!topoorder()) cout &lt;&lt; 0; else criticalpath(); return 0;&#125;/*samples:in:7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2out:171-&gt;22-&gt;44-&gt;66-&gt;7in:4 41 2 21 3 22 4 23 4 2out:41-&gt;31-&gt;22-&gt;43-&gt;4in:3 31 2 12 3 13 1 1out:0in:3 31 2 11 3 12 3 1out:21-&gt;22-&gt;3*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prologue（プロローグ - 押尾コータロー）- 翻弹]]></title>
    <url>%2F2020%2F08%2F29%2FPrologue%EF%BC%88%E3%83%97%E3%83%AD%E3%83%AD%E3%83%BC%E3%82%B0%20-%20%E6%8A%BC%E5%B0%BE%E3%82%B3%E3%83%BC%E3%82%BF%E3%83%AD%E3%83%BC%EF%BC%89-%20%E7%BF%BB%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Prologue（プロローグ - 押尾コータロー）是押尾于 2003 年发行的专辑《Dramatic》中的一首较为简单的指弹曲子。 谱子一共就两页，不长，但是编的真好，想要完整的弹下来还得费一番功夫。先看下原版谱子第 1 面（扫描件，画质略差见谅）： 谱子五线谱的左上角写着 Tuning = Standard，说明这是首标准调弦的曲子；五线谱的开头有一个高音谱号和一个“#”号表示这首曲子是 G 大调的；边上的$\frac{6}{8}$，表示这首曲子的节拍是八六拍；谱号上还有一个带方框的缩写的英文单词 Intro，表示前两小节是这首曲子的引子（就像某些小说开头的引子一样）；紧接着边上的 G 表示这俩小节的和弦走向是 G；还有后面带方框的英文分别代表这首曲子的 A 段、B 段、C 段等。 建议只看六线谱的也不要忽略上面的内容。 A 段需要注意的地方： 第二小节五线谱上的数字代表了左手的指法，但实际上你可以按照自己熟练的方式来演奏；另外，S 标记代表从 2 弦 3 品用滑音演奏法滑到 10 品，为了达到跟原曲的效果，滑到 10 品后，需要在弹一次 2 弦 10 品第四小节右手中指与无名指需要同时弹响 1、2弦，用滑音听起来会更棒第五小节左手中指与小指需要首先同时按住 6 弦 8 品和 3 弦 9 品第六小节左手食指需要横按，但食指横按的音可以“弱处理” 接下来就到 B 段了，个人感觉 B 段简单一些，后面几个小节在谱子的第二面： B 段需要注意的地方： 第七小节 1 弦的处理方式可以与 A 段第二小节类似第八小节食指小横按 1-4 弦 5 品 接着是 C 段需要注意的地方： 第二小节需要左手有一定的“力量”才能按好整个 C 段有多处需要用琶音技巧，才能更好的表达曲子情感的变化C 段属于结尾段，包括两个结尾部分，谱子上有标记 1 和 2，注意区分 原曲： 渣翻（还在酝酿之中）：]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>FingerStyle</tag>
        <tag>Guitar</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_07-图（中）]]></title>
    <url>%2F2020%2F08%2F28%2FZJU-DS-07-%E5%9B%BE%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周课程主要包括图论中最短路径的问题和有关树的习题课，习题课笔记添加到前面对应题目的所在的文章中了。 最短路径问题的抽象一般而言，最短路径问题都可抽象为：在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，从而，有： 这条路径就是两点之间的最短路径（Shortest Path） 第一个顶点为源点（Source） 最后一个顶点为终点（Destination） 按照这样的思路，最短路径问题又可以分别两类： 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径，根据图的类型不同又可以分为： （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点间的最短路径 无权图的单源最短路径算法考虑这类问题时，有一个原则，即：按照递增（非递减）的顺序找出各个顶点的最短路。以下图中的“图”为例： 无权图的单源最短路径问题本质上就是 BFS，假设源点为$v_3$，按照 BFS 的思路，通过$v_3$可以直接访问$v_1$和$v_2$，这算是与$v_3$的距离为 1 所能访问的顶点，依次类推，与$V_3$距离为 2 所能访问的顶点就是$v_2$和$v_4$，与$v_3$距离为 3 所能访问的顶点就是$v_5$和$v_7$。 接着在按照 BFS 算法写出其伪码算法：12345678910111213void Unweighted(Vertex S) &#123; Enqueue(S, Q); while(!IsEmpty(Q)) &#123; V = Dequeue(Q); for(V 的每个邻接点 W) &#123; if(dist[W] == -1) &#123; dist[W] = dist[V] + 1; path[W] = V; Enqueue(W, Q); &#125; &#125; &#125;&#125; 与 BFS 算法不同的是，这里用 dist 数组来保存源点到各个顶点的距离，用 path 数组保存了源点到各个顶点的路径。这里多说一句，若想知道路径的距离是多少直接访问 dist 数组即可；若要知道路径是什么，递归输出 path 数组即可（非递归输出的顺序是逆过来的）。 有权图的单源最短路径有权图的最短路径与无权图的最短路径最显著的区别就是，有权图的最短路径不一定是进过顶点最少的路径，而无权图的最短路径则一定是经过顶点最少的路径。以下图为例，$v_1 -&gt; v_4 -&gt; v_6$与$v_1 -&gt; v_4 -&gt; v_7 -&gt; v_6$相比，第二条路径要更短一点。同样，当图内存在负权值的边时，就可能产生负值圈（Negative-cost cycle），如下图：此时单源最短路径的算法是无法得到正确结果的，这里不深入讨论这类问题。 回过头来，有权图的单源最短路径算法与无权图的单源最短路算法有一个共同点，那就是二者皆是按照递增的顺序找出到各个顶点的最短路径，而有权图的单源最短路径算法也叫Dijkstra算法。 Dijkstra 算法Dijkstra 算法是典型的贪心算法，直接描述其过程有点麻烦，先看下面的伪码算法描述：123456789101112131415void Dijkstra(Vertex S) &#123; while(1) &#123; v = 未收录顶点中 dist 最小者; if(这样的 v 不存在) break; collected[v] = true; for(v 的每个邻接点 w)&#123; if(collected[w] == false) &#123; if(dist[v] + &lt;v, w&gt;的权值 &lt; dist[w]) &#123; dist[w] = dist[v] + &lt;v, w&gt;的权值; path[w] = v; &#125; &#125; &#125; &#125;&#125; 需要注意的地方： 不能解决有负边的情况 总是按照顶点序号递增（非递减）的顺序来开始算法 每次收录一个顶点 w 后要更新从 v 到 w 的最短路径的权值和 每次收录一个顶点 w 后可能会影响 v 到其他顶点的最短路径，所以要对 v 的邻接点进行访问 如何从未收录顶点中找出 dist 最小者是影响此算法时间复杂度的关键，根据方法的不同，有两种情况： 直接扫描所有未收录顶点，每次在找出所有顶点中 dist 最小的顶点，然后再访问当前这个顶点的所有邻接点，时间复杂度为：$O(|V^2| + |E|)$，这种方法适合稠密图 如果是将 dist 存在最小堆中，那么找出所有顶点中 dist 最小的顶点所耗费的时间就是$O(log|V|)$，但是最后还得将这个值插入到堆中，且对于一个连通的图而言，边数肯定大于等于顶点数，所以其时间复杂度为：$T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|)$，这种方法适合稀疏图 下面再以下图中的图为例，手动模拟一遍算法。 首先，dist 和 path 数组都要先初始化： index 1 2 3 4 5 6 7 dist ∞ ∞ ∞ ∞ ∞ ∞ ∞ path -1 -1 -1 -1 -1 -1 -1 注意上面下标是从 1 开始的，与顶点下标对应免得搞混，当然从 0 开始也是没有问题的，但后面分析问题时可能搞混淆。 接着从 $v_1$ 开始，在访问$v_1$的邻接点之前，需要先将 dist[1] 的值修改为 0，因为其自身到自身的距离是 0，然后访问$v_1$的邻接点，并更新这些邻接点对应的 dist 和 path 数组的值（$v_1$的邻接点只有$v_2$和$v_4$），此时 dist 与 path数组的值为： index 1 2 3 4 5 6 7 dist 0 2 ∞ 1 ∞ ∞ ∞ path -1 1 -1 1 -1 -1 -1 此时又回到循环体的开头部分，找出 dist 中最小的且未被访问过的，显然是$v_4$，然后利用$v_4$来更新 dist 和 path 数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 再继续下一轮循环，此时选出的顶点就是$v_2$，在更新 dist 和 path 数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 上面表格中的值与第二次循环没有变化，原因在于通过$v_2$并不能使$v_1$到达$v_4$和$v_5$的距离变小，所以也就不用更新 dist 和 path 数组的值。 再继续下一轮循环，此时选出的顶点就是$v_3$（注意是按递增顺序，所以不是$v_5$），此时通过$v_3$可以使$v_1$到$v_6$的距离变小，所以更新数组中的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 8 5 path -1 1 4 1 4 3 4 接着选定$v_5$，按照同样的过程，数组值也不用更新。 在选定$v_7$，此时可以使$v_1$到$v_6$的距离变小，更新数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 6 5 path -1 1 4 1 4 7 4 最后一个顶点是$v_6$，但$v_6$没有邻接点（就算有，此时其他顶点也都被访问过了），所以循环会结束。 注意上述过程与姥姥讲的略微有点不一致，也就是开头加入$v_1$后，数组值都是循环体内更新的；而姥姥讲的是在循环开始之前就已经全部更新好了。实际上，在循环体内更新还要更加方便一点。 有权图的多源最短路径考虑有权图的多源最短路径时，毫无疑问会想到直接将单源最短路径算法调用$|V|$（因为顶点个数是$|V|$），此时算法的时间复杂度为：$ T = O(|V^3| + |E| \times |V|)$，显然如果是稀疏图，效率较高。 那碰到稠密图怎么办呢？答案是用 Floyd 算法 Floyd 算法Floyd 算法与 Dijkstra 算法有点类似，但是其借助了数学归纳法，相比 Dijkstra 算法，代码要简单一点。 注意 Floyd 算法只能用于邻接矩阵，它本身也是通过邻接矩阵来更新最短路径的权值之和的，当$D^{k-1}$已经完成，递推到$D^k$时，主要理解两个点： 若 k 不在最短路径$i -&gt; \dots -&gt; j$之间，则$D^k = D^{k-1}$ 若 k 在最短路径径$i -&gt; \dots -&gt; j$之间，则该路径必定由两段最短路径组成：$D^k[i][j] = D^{k-1}[i][k] + D^{k-1}[k][j]$ 其伪码描述为：12345678910111213141516171819void Floyd() &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; D[i][j] = G[i][j]; // initialization path[i][j] = -1; &#125; &#125; // notice these loop variables for(k = 0; k &lt; N; k++) &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(D[i][k] + D[k][j] &lt; D[i][j]) &#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125;&#125; Homework07-4 哈利·波特的考试这道题目是典型的多源最短路径问题，直接用邻接矩阵存储图，然后调用 Folyd 算法即可得到所有的最短路径。但要注意这道题目的最优解是选择出到其他各顶点的综合距离最短的顶点，也就是说各个顶点到其他顶点的最短路径中最长的那条最短路径的最小值者就是最优解，好吧，很拗口。注意，并不能以最短路径之和最小者为最优解，这是错误的。这道题的代码写的比较简单，思路与上述一致，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;int n, m, G[maxn][maxn], dist[maxn][maxn];void floyd() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; dist[i][j] = G[i][j]; &#125; &#125; for(int k = 1; k &lt;= n; k++) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(dist[i][k] + dist[k][j] &lt; dist[i][j] &amp;&amp; i != j) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125;&#125;void findanimal() &#123; floyd(); int mindist = inf; int animal; for(int i = 1; i &lt;= n; i++) &#123; int maxdist = 0; for(int j = 1; j &lt;= n; j++) &#123; if(i != j &amp;&amp; dist[i][j] &gt; maxdist) maxdist = dist[i][j]; &#125; if(maxdist == inf) &#123; cout &lt;&lt; 0; return; &#125; if(mindist &gt; maxdist) &#123; mindist = maxdist; animal = i; &#125; &#125; cout &lt;&lt; animal &lt;&lt; ' ' &lt;&lt; mindist;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2]; G[v2][v1] = G[v1][v2]; &#125; findanimal(); return 0;&#125;/*samples:in:6 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80out:4 70*/ 07-5 Saving James Bond - Hard Version这道题目是上周题目的加强版，题目大意与姥姥在课上开头讲的一样，不仅要判断是否可以到达岸边，还要输出对应的路径。 解决这个问题的思路就是利用 BFS 算法来找最短路径，也就是无权图的单源最短路径。可能有的同学会觉得顶点之前的距离不就是边的权吗？其实不然，这个题目的边权不是直接给出，需要计算得到；而且，这个题目的最优解不是要求最短路径的权值最小，而是要求跳的次数最少，所以，只需要用计算出边权然后判断是否可达即可。 要求得具体经过了几跳到达岸边，稍微有点麻烦，但可以借鉴上篇文章六度空间那个题目的思路，在开始 BFS 之前先记录是哪个顶点，在每次循环结束之前，将当前加入路径的结点与记录的结点比对，如果相同，那么跳步数加 1，并将此结点记录后用作下轮循环判断。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node &#123; int x, y;&#125; coords[maxn];int n, d, path[maxn];bool vis[maxn] = &#123;false&#125;;int firstjump(int v) &#123; int dis = d - sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) + 7.5; if(dis &gt; 0) return dis; else return 0;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125;bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool cmp(int a, int b) &#123; return firstjump(a) &gt; firstjump(b);&#125;void printpath(int inde) &#123; if(path[inde] == -1) &#123; cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl; return; &#125; printpath(path[inde]); cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl;&#125;void save007() &#123; if(d &gt;= 50 - 15 / 2) &#123; cout &lt;&lt; 1; return; &#125; else &#123; int order[maxn]; queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) &#123; order[i] = i; path[i] = -1; &#125; sort(order, order + n, cmp); int last, tail; for(int i = 0; i &lt; n; i++) &#123; if(firstjump(order[i])) &#123; q.push(order[i]); vis[order[i]] = true; last = order[i]; &#125; &#125; int step = 2; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(issafe(front)) &#123; cout &lt;&lt; step &lt;&lt; endl; printpath(front); return; &#125; for(int i = 0; i &lt; n; i++) &#123; if(!vis[i] &amp;&amp; jump(front, i)) &#123; q.push(i); path[i] = front; vis[i] = true; tail = i; &#125; &#125; if(last == front) &#123; step++; last = tail; &#125; &#125; if(q.empty()) cout &lt;&lt; 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; coords[i].x &gt;&gt; coords[i].y; &#125; save007(); return 0;&#125;/*samples:in:17 1510 -2110 21-40 1030 -5020 4035 100 -10-25 2240 -40-30 30-10 220 1125 2125 1010 1010 35-30 10out:40 1110 2110 35in:4 13-12 1212 12-12 -1212 -12out:0in:1 5030 30out:1*/ 07-6 旅游规划这道题目是中文的，读起来没那么费劲了，所以很容易让人看出是单源最短路径问题。 题目已经给定了源点和终点，所以用源点直接套 Dijkstra 算法即可得到其到终点的最短路径。 但这个题目的难点在于要根据题目给定的选解方式来确定最优解，即： 路径最短 最便宜 所以需要修改一下 Dijkstra 算法，具体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* notes: this problem is similar to the Advanced Level 1030. */#include &lt;iostream&gt;using namespace std;const int inf = 0x3fffffff;const int maxn = 500 + 5;int n, m, src, dst, G[maxn][maxn], cost[maxn][maxn];int d[maxn], c[maxn];bool vis[maxn] = &#123;false&#125;;void dijkstra(int src) &#123; fill(d, d + maxn, inf); d[src] = 0; c[src] = 0; for(int i = 0; i &lt; n; i++) &#123; int v = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; d[j] &lt; min) &#123; v = j; min = d[j]; &#125; &#125; if(v == -1) return; vis[v] = true; for(int w = 0; w &lt; n; w++) &#123; if(!vis[w] &amp;&amp; G[v][w] != inf) &#123; if(d[v] + G[v][w] &lt; d[w]) &#123; d[w] = d[v] + G[v][w]; c[w] = c[v] + cost[v][w]; &#125; else if(d[v] + G[v][w] == d[w]) &#123; if(c[v] + cost[v][w] &lt; c[w]) c[w] = c[v] + cost[v][w]; &#125; &#125; &#125; &#125;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2] &gt;&gt; cost[v1][v2]; G[v2][v1] = G[v1][v2], cost[v2][v1] = cost[v1][v2]; &#125; dijkstra(src); cout &lt;&lt; d[dst] &lt;&lt; ' ' &lt;&lt; c[dst]; return 0;&#125;/*samples:in:4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20out:3 40*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_06-图（上）]]></title>
    <url>%2F2020%2F08%2F27%2FZJU-DS-06-%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是图？如何表示和实现？图又有那些基本的性质？常见的应用有哪些？ 什么是图图常用来建立多对多的关系，如社交网络等。那么用什么概念来说明这些关系呢？答案就是“顶点”跟“边”。图的构成只有两种：顶点和边，二者即是用来表示关系的概念。 顶点一个图内肯定不止一个顶点（Vertex），所以一般用 Ｖ 来表示顶点集合 边同样，一个图内肯定不止一条边（Edge），所以一般用 E 来表示边的集合。需要注意的是，图分为有向图与无向图，所以边在这两种图中分别称作有向边（单行线，如$&lt;v_1, v_2&gt;$）与无向边（$(v1, v2)$）。 另外，在图内是不考虑重边和自回路的。 基本术语与图相关的基本术语有很多，碰见一个记录一个： 无向图，图内所有的边都是无向边，对应的，若图内所有的边都是有向边，那这个图就是有向图 每一条边上赋予权值后，那么称这个图叫做“网络”，这个概念与互联网络是不一样的 完全图，图内所有顶点，任意两个顶点之间都有边 连通，如果从 V 到 W 存在一条（无向）路径，则称 V 和 W 是连通的 路径，V 到 W 的路径是一系列顶点${V, V_1, V_2, \dots, V_n, W}$的集合，其中任一对相邻顶点间都有图中的边。路径的长度是路径种的边数（如果带权，则是所有边的权重和）。如果 V 到 W 之间的所有顶点都不同，则称简单路径 回路，起点等于终点的路径 连通图，图中任意两顶点均连通 连通分量，无向图的极大连通子图，其中“极大”包含下面两个意思： 极大顶点数：再加一个顶点就不连通了 极大边数：包含子图种所有顶点相连的所有边 有向图中顶点 V 和 W 之间存在双向路径，则称 V 和 W 是强连通的 强连通图，有向图中任意两顶点均强连通 强连通分量，有向图的极大强连通子图 弱连通图，如果一个非强连通图，将其中所有的有向边改为无向边，得到的图为连通图，这样的图称为弱连通图 图的抽象数据类型描述类型名称：图（Graph）数据对象集：$G(V, E)$由一个非空的有限顶点集$V$和一个有限边集合$E$组成。操作集：最大堆$H ∈ MaxHeap$，元素$item ∈ ElementType$，主要操作有： Graph Create()，建立并返回空图 Graph InsertVertex(Graph G, Vertex v)，将 v 插入 G Graph InsertEdge(Graph G, Edge e)，将 e 插入 G void DFS(Graph G, Vertex v)，从顶点 v 出发深度优先遍历图 G void BFS(Graph G, Vertex v)，从顶点 v 出发宽度优先遍历图 G void ShortestPath(Graph G, Vertex v, int Dist[])，计算图 G 中顶点 v 到任意其他顶点的最短距离 void MST(Graph G)，计算图 G 的最小生成树 图的表示图的表示有多种方法，按照所要解决的问题的性质，用符合问题情况的表示方法来表示图，在解决问题是可以事半功倍，下面只介绍两种常见的表示方法。 邻接矩阵邻接矩阵本质上就是一个二维数组，用数组下标$0-N-1$代表$N$个顶点的编号，数组的元素的值表示两个顶点之间是否有边（若是网络，那么直接将数组元素的值修改为对应的权值即可），即有： $G[i][j] =\begin{cases}1&amp; 若&lt;v_i, v_j&gt;是G中的边\\0&amp; 否则\end{cases}$值得注意的是，无向图的邻接矩阵一定是对称的。也就是说，无向图的邻接矩阵只需要存储一半即可。要解决这个问题，需要用到矩阵的压缩存储知识。 使用邻接矩阵表示图的优点有以下几点： 直观、简单、便于理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（这里的度的概念与树是类似的，从该顶点发出的边数为“出度”，指向该点的边数为“入度”） 无向图：对应行（或列）非 0 元素的个数 有向图：对应行非 0 元素的个数是“出度”，对应列非 0 元素的个数是“入度” 邻接矩阵的缺点如下： 存储稀疏图（顶点多边很少）时有大量无效元素，极大浪费空间，但存储稠密图（特别是完全图）很合算 统计稀疏图中的边数效率很低 邻接表由于邻接矩阵表示稀疏图浪费空间，为了解决这个问题对应出现的就是邻接表。 在邻接表中，$G[N]$为指针数组，对应矩阵每一行一个链表，只存非 0 元素，注意邻接表的表示并不唯一。 邻接表的特点： 方便找任一顶点的所有“邻接点” 节约稀疏图的空间，需要 N 个头指针 和 2E 个结点（每个结点至少 2 个域） 方便计算无向图任一顶点的度和有向图任一顶点的出度，但计算有向图任一顶点的入度比较麻烦，需要构造“逆邻接表”（存储指向自己的边）才能方便的计算入度 不便于检查任意一对顶点是否存在边 图的遍历图里面遍历的概念与树是一致的，图的基本遍历方法有两种：深度优先搜索（Depth First Search，DFS）和广度优先搜索（Breath First Search，BFS）。根据应用场景的不同，两种遍历算法在不同场景下解决问题的难易程度也不一样。 DFSDFS 算是树的先序遍历的推广，其伪码算法为：123456void DFS(Vertex V) &#123; visited[V] = true; // 此结点标记为已访问 for( V 的每个邻接点 W) &#123; if(!visited[W]) DFS(W); &#125;&#125; 根据图的存储结构的不同，DFS 的时间复杂度也不同： 使用邻接表存储，时间复杂度为：$O(N + E)$ 使用邻接矩阵存储，时间复杂度为：$O(N^2)$ BFSBFS 算是树的层序遍历的推广，其伪码算法为：12345678910111213void BFS(Vertex V) &#123; visited[V] = true; Enqueu(V, Q); while(!Isempty(Q)) &#123; V = Dequeue(Q); for(V 的每个邻接点 W) &#123; if(!visited[W]) &#123; visited[W] = true; Enqueue(W, Q); &#125; &#125; &#125;&#125; 同样，其时间复杂度也分两种情况： 使用邻接表存储，时间复杂度为：$O(N+E)$ 使用邻接矩阵存储，时间复杂度为：$O(N^2)$ Homework06-1 列出连通集题目意思很明确，给定一个无向图，分别用 DFS 和 BFS列出其所有的连通集（其实就是连通分量，忘记是啥了，可以重新看下上面的概念）即可。之前姥姥在课上讲过，按照 DFS 的遍历过程，一个最外层的 DFS 的调用，就相当于访问了这个图的一个连通集。那么使用 DFS 在访问每个连通集是顺便输出当前所处连通集的所有元素即可，同理，BFS 也是一样的。 由于姥姥讲了图的两种存储方法，继续按部就班的按照姥姥给定的代码接着往下写： 邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* notes: The adjacency list is built by head pointer, so the traversal sequences is not same as sample output.Actually, the adjacency list is not unique, so the traversal sequences are also not unique.You can use the sort function to get the same result. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct AdjVNode* PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; WeightType Weight; PtrToAdjVNode Next;&#125;;typedef struct Vnode&#123; PtrToAdjVNode FirstEdge; DataType Data;&#125; AdjList[MaxVertexNum];typedef struct GNode* PtrToGNode;struct GNode&#123; int Nv; int Ne; AdjList G; &#125;;typedef PtrToGNode LGraph;LGraph CreateGraph(int VertexNum) &#123; Vertex V; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; Graph-&gt;G[V].FirstEdge = NULL; &#125; return Graph;&#125;void InsertEdge(LGraph Graph, Edge E) &#123; PtrToAdjVNode NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph() &#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125; void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; PtrToAdjVNode W; Visit(S); Visited[S] = true; for(W = Graph-&gt;G[S].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) DFS(Graph, W-&gt;AdjV, Visit, Visited); &#125;&#125;void BFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; Vertex V; Visit(S); Visited[S] = true; Queue[++rear] = S; while(front &lt; rear) &#123; V = Queue[++front]; PtrToAdjVNode W; for(W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) &#123; Visit(W-&gt;AdjV); Visited[W-&gt;AdjV] = true; Queue[++rear] = W-&gt;AdjV; &#125; &#125; &#125;&#125;void ListComponents(LGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; LGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/*samples:in:8 60 70 12 04 12 43 5out:&#123; 0 2 4 1 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 2 1 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 邻接矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode &#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct GNode* PtrToGNode;struct GNode &#123; int Nv; int Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];&#125;;typedef PtrToGNode MGraph;MGraph CreateGraph(int VertexNum) &#123; Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; Graph-&gt;G[V][W] = INFINITY; &#125; &#125; return Graph;&#125;void InsertEdge(MGraph Graph, Edge E) &#123; Graph-&gt;G[E-&gt;V1][E-&gt;V2] = 1; Graph-&gt;G[E-&gt;V2][E-&gt;V1] = 1;&#125;MGraph BuildGraph() &#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125;bool IsEdge(MGraph Graph, Vertex V, Vertex W) &#123; return Graph-&gt;G[V][W] &lt; INFINITY ? true : false;&#125;void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(MGraph Graph, Vertex V, void (*Visit)(Vertex), int Visited[]) &#123; Visit(V); Visited[V] = true; Vertex W; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) DFS(Graph, W, Visit, Visited); &#125;&#125;void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; // use a simple queue Vertex V, W; Visit(S); Visited[S] = true; Queue[++rear] = S; //enqueue while(front &lt; rear) &#123; V = Queue[++front]; //dequeue for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) &#123; Visit(W); Visited[W] = true; Queue[++rear] = W; &#125; &#125; &#125;&#125;void ListComponents(MGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; MGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/* simple method: use 2-dimensional array represent adjcent matrix#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10 + 5;const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void dfs(int node) &#123; visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[node][i] != inf) dfs(i); &#125;&#125;void bfs(int node) &#123; queue&lt;int&gt; q; cout &lt;&lt; node &lt;&lt; ' '; visited[node] = true; q.push(node); while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[front][i] != inf) &#123; cout &lt;&lt; i &lt;&lt; ' '; visited[i] = true; q.push(i); &#125; &#125; &#125;&#125;void listcomponents() &#123; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; dfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; bfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125;&#125;int main() &#123; init(); cin &gt;&gt; nv &gt;&gt; ne; for(int i = 0; i &lt; ne; i++) &#123; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; G[v1][v2] = G[v2][v1] = 1; &#125; listcomponents(); return 0;&#125;*//*some samples:in:8 60 70 12 04 12 43 5out:&#123; 0 1 4 2 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 1 2 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 06-2 Saving James Bond - Easy Version这道题目是难度降低后的简单版，按照姥姥给定的思路来写即可，这里使用 C++ 的部分功能来写可能会比较方便（用纯 C 也可以胜任，可能会稍微麻烦），如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node&#123; double x, y;&#125; coords[maxn];int n;double d;bool visited[maxn] = &#123;false&#125;;bool firstjump(int v) &#123; return sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) - 7.5 &lt;= d;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125; bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool DFS(int v) &#123; visited[v] = true; bool flag = false; if(issafe(v)) return true; else &#123; for(int w = 0; w &lt; n; w++) &#123; if(!visited[w] &amp;&amp; jump(v, w)) &#123; flag = DFS(w); if(flag) break; &#125; &#125; &#125; return flag;&#125;void save007() &#123; bool flag = false; for(int v = 0; v &lt; n; v++) &#123; if(!visited[v] &amp;&amp; firstjump(v)) &#123; flag = DFS(v); if(flag) break; &#125; &#125; flag ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int v = 0; v &lt; n; v++) &#123; cin &gt;&gt; coords[v].x &gt;&gt; coords[v].y; &#125; save007(); return 0;&#125;/*sample:in:25 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12out:Yesin:4 13-12 1212 12-12 -1212 -12out:No*/ 06-3 六度空间由于六度空间理论姥姥已经介绍过了，所以题目意思理解起来比较容易，按照姥姥的讲解，只需要稍稍修改 BFS 算法就可以了，但注意最后边界条件的设置要好好理解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define maxn 1005const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;int BFS(int v) &#123; memset(visited, false, sizeof(visited)); visited[v] = true; int Queue[maxn], front = -1, rear = -1; Queue[++rear] = v; int count = 1, level = 0, last = v, tail; while(front &lt; rear) &#123; int first = Queue[++front]; for(int w = 1; w &lt;= nv; w++) &#123; if(!visited[w] &amp;&amp; G[first][w] != inf) &#123; Queue[++rear] = w; visited[w] = true; tail = w; count++; &#125; &#125; if(first == last) &#123; level++; last = tail; &#125; if(level == 6) break; &#125; return count;&#125;void sds() &#123; for(int i = 1; i &lt;= nv; i++) &#123; int count = BFS(i); printf("%d: %.2lf%%\n", i, (double)count / nv * 100.0); &#125;&#125;int main() &#123; init(); scanf("%d %d", &amp;nv, &amp;ne); int v1, v2; for(int i = 0; i &lt; ne; i++) &#123; scanf("%d %d", &amp;v1, &amp;v2); G[v1][v2] = G[v2][v1] = 1; &#125; sds(); return 0;&#125;/*samples:in:10 91 22 33 44 55 66 77 88 99 10out:1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扒谱记录 - 秋柳]]></title>
    <url>%2F2020%2F08%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-%E7%A7%8B%E6%9F%B3%2F</url>
    <content type="text"><![CDATA[前段时间，朋友突然给我发了他比较喜欢的民谣 ——《秋柳》。正巧他自己在吹口琴，所以想试着扒扒谱子，结果谱子扒完后，让我给他看看。我转尔一想，直接自己扒了比对算了。不过，网上估计也有对应的简谱。 原曲： 自扒谱：123 212 1(6)(5)123 335 532123 212 1(6)(5)123 212 1(7)1345 532234 444 323345 321165 132 171()：降八度 扒的比较简陋，日后在做一张简谱吧。]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_05-树（下）]]></title>
    <url>%2F2020%2F05%2F03%2FZJU-DS-05-%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本讲将会在二叉树结构的基础上在介绍另外三种特殊的结构：堆、哈夫曼树和集合，快来学习吧！ Heap在了解对之前先来考虑一下“优先队列”的问题。 所谓优先队列，即取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，可以用数组、链表、有序数组、有序链表、树等来实现。 如果使用平衡二叉树来实现，插入不难实现，但是删除操作会存在一个问题，那就是，多次删除操作后，树的两边会变得不均衡，如果在来旋转调整就会降低效率，于是考虑让最大值成为根结点（大根堆），每次删除只需要删除根结点即可，这样就不会影响树的高度了。堆有两个特性（满足特性才能称堆，否则不行）： 结构性：用数组表示的完全二叉树 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）。 最大堆（MaxHeap），也称大根堆，根为最大值 最小堆（MinHeap），也称小根堆，根为最小值 堆的抽象数据类型描述类型名称：最大堆（MaxHeap）数据对象集：完全二叉树，每个结点元素值不小于其子结点的元素值操作集：最大堆$H ∈ MaxHeap$，元素$item ∈ ElementType$，主要操作有： MaxHeap Create(int MaxSize)，创建一个空的最大堆 Boolean IsFull(MaxHeap H)，判断最大堆H是否已满 Insert(MaxHeap H, ElementType item)，将元素item插入最大堆H Boolean IsEmpty(MaxHeap H)，判断最大堆H是否为空 ElementType DeleteMax(MaxHeap H)，返回H中最大元素（高优先级） 堆的实现C 语言下的堆定义可以如下：123456typedef struct HeapStruct *MaxHeap;struct HeapStruct&#123; ElementType *Data; int Size; int Capacity;&#125;; 最大堆初始化（建立空堆）12345678MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125; 判断堆满123bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125; 判断堆空123bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125; 插入由于堆的实现是基于完全二叉树的思想，插入元素的时候直接放在最后就好。但是要注意为了保证树的结构符合最大堆的特性，所以需要将子结点与父结点比较，如果子结点比父结点大，就将子结点与父结点互换。1234567891011121314bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125; 删除对大根堆而言，删除就是删除最大值元素（也就是堆顶）。删除了堆顶后，直接将最后一个元素放到堆顶显然无法保证堆的结构性，所以还需要对此时的堆做调整。123456789101112131415161718ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125; 直接建堆上面提到的建堆方法实际上是将元素一个个的插入到堆中，时间复杂度为：$O(NLogN)$。 可以使用下面的思路来建堆： 将 N 个元素按输入顺序存入，先满足完全二叉树的特性 调整各结点位置，以满足最大堆的有序特性。 叶子结点无须调整，所以只需依次调整所有非叶结点即可，调整的思路与删除结点时调整堆的结构的思路一致。另外，为了使得代码简洁，可以将结点下移的操作独立封装出来，代码如下：123456789101112131415161718void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; 尽管从代码上看时间复杂度好像是$O(N^2)$，但实际情况的时间复杂度是$O(NLogN)$。 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef int ElementType;typedef struct HNode *Heap;struct HNode&#123; ElementType *Data; int Size; int Capacity;&#125;;typedef Heap MaxHeap;#define MaxData 1000MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125;bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125;#define ERROR -1bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125;ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125;void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MaxHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n'); &#125;int main() &#123; MaxHeap H = Createheap(10); Insert(H, 10); Insert(H, 5); Insert(H, 20); Insert(H, 30); Insert(H, 15); Insert(H, 18); Printheap(H); return 0;&#125; 最小堆最小堆的结构与最大堆的结构区别只在于根结点值比叶结点都小，本质上还是一棵完全二叉树。所以，最小堆的插入、删除和直接建堆的代码略有差异，但思路都是一致的。 插入前面介绍最大堆的时候已经知道了，每向堆中插入一个结点就需要调整堆的结构，调整这个操作可以独立封装起来，这样可以使得代码更加简洁。整体代码如下：123456789101112131415161718void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125; 删除注意最小堆中删除操作的 Percdown 函数与最大堆是有区别的，主要在于当叶结点小于根节点时，才需要将根结点下移（而此时最大堆刚好就是合适的位置）。12345678910111213141516171819202122void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125; 直接建堆直接建堆的思路一致，不同的只是最小堆的 Percdown 函数与最大堆不同，但是可以发现 Buildheap 这个函数没有变化，这其实就是将 Percdown 独立封装起来的好处。1234567891011121314151617void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap Createheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * MAXN); H-&gt;Size = 0; H-&gt;Capacity = Maxsize; return H;&#125; bool Isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Isempty(MinHeap H) &#123; return H-&gt;Size == 0;&#125;void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MinHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; MinHeap H = Createheap(5); Insert(H, 46); Insert(H, 23); Insert(H, 26); Insert(H, 24); Insert(H, 10); Printheap(H); Deletemin(H); Printheap(H); return 0;&#125; Huffman Tree编码问题是计算机学科内十分重要的问题，而哈夫曼树就是为了解决编码的问题而产生的。与之类似的问题还有判定树和搜索树如何构造最优的问题，而所谓最优，即是查找树效率最高。 首先，哈夫曼树是一种很特殊的二叉树（没错，它是二叉树），它有 N 个叶子结点，若该树的带权路径长度（WPL）达到最小，称这样的二叉树为哈夫曼树（Huffman Tree），也叫最优二叉树。 那么，什么是带权路径长度（WPL，Weighted Path Length of Tree）呢？ 设二叉树有 N 个叶子结点，每个叶子结点带有权值$w_k$，从根结点到每个叶子结点的长度为$l_k$，则每个叶子结点的带权路径长度之和：$WPL = \sum_{k=1}^n w_k l_k$。也就是说，哈夫曼树实际上就是指 WPL 最小的树。 构造构造哈夫曼树的方法也比较简单，每次把权值最小的两棵二叉树合并即可。 由于每次建树都需要选出权值最小的结点，所以在代码实现过程中，借助最小堆来找出权值最小的结点比较方便快捷。 这里偷个懒，直接用何头给出的代码：12345678910111213141516171819typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman(MinHeap H) &#123; int i; HuffmanTree T; BuildMinHeap(H); for(i = 1; i &lt; H-&gt;Size; i++) &#123; T = malloc(sizeof(struct TreeNode)); T-&gt;Left = Deletemin(H); T-&gt;Right = Deletemin(H); T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; Insert(H, T); &#125; T = DeleteMin(H); // insert new root node return T;&#125; 特点由于哈夫曼树构造方法的特殊性，它具有以下几个特点： 没有度为 1 的结点 n 个叶子结点的哈夫曼树共有 $2n-1$ 个结点 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树 对同一组权值${w_1, w_2, w_3, \dots, w_n}$，是存在不同构的两棵哈夫曼树，但注意其 WPL 是一定是一样且最小的 记好这些特点，算法笔试题可能会遇见。 编码如前所言，哈夫曼树的出现是为了解决编码问题，那么具体解决了那些问题呢？ 哈夫曼树解决的编码问题就是避免了在进行不等长编码时的可能会产生的二义性。所谓二义性就是指同一串编码，解释结果会有不同。根据哈夫曼树的结构，如果用字符代表叶结点，左右分支分别代表 0 和 1，用根结点到每个叶结点的路径方向代表每个字符的编码，可以很神器的发现，各种字符编码组合都不会产生二义性。 此时，对每个字符所编的码也叫做前缀码（即任何字符的编码都不是另一字符编码的前缀）。实际上而言，当所有字符都处在叶结点时，就不会产生非前缀码。 按照哈夫曼树进行的编码，还有一个优点，那就是代价最小，比起等长编码要节省了大量的空间。 这就是哈夫曼树所解决的编码问题。 Set这里集合的概念与数学上集合的概念基本一致，但实际经常用到的集合叫做“并查集”，其实就是集合的并和查两个操作。PS：学完整套课程之后，回过头会发现，集合更像是后面要学的“图”，但其中一些概念又与树联系密切。 利用静态数组存储集合较为方便，借用一下何头的代码：1234typedef struct &#123; ElementType Data; int Parent;&#125; SetType; 查找查找某个元素所在的集合，要先找到这个结点的位置，然后在从下往上依次查找根结点，代码如下：1234567int Find(SetType S[], ElementType X) &#123; int i; for(i = 0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++) if(i &gt;= MaxSize) return -1; // not find the element for(; S[i].Parent &gt;= 0; i = S[i].Parent); return i; // return the root static pointer&#125; 并两个集合的并运算需要在查找操作的基础上实现，先分别找到两个集合的根结点，再将其中一个根结点的父结点指针设置成另一个根结点的数组下标，假设两个集合内分别有元素 $X_1$ 和 $X_2$，代码如下：123456void Union(SetType S[], ElementType X1, ElementType X2) &#123; int Root1, Root2; Root1 = Find(S, X1); Root2 = Find(S, X2); if(Root1 != Root2) S[Root2].Parent = Root1;&#125; 按照上面的思路，当不断的并入新集合时，可能会产生树不断增高的情况，这样会导致查找的效率降低，一种可行的办法就是将小集合并入大集合。但这样做的效率仍然不高，不过后面姥姥会交给我们路径压缩和按秩归并的方法。 Homework05-7 堆中的路径题目意思很明确，利用题目给定的一串数字建立最小堆，然后对任意给定的下标 i，打印 H[i] 到根结点的路径即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap initheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * (Maxsize + 1)); H-&gt;Capacity = Maxsize; H-&gt;Size = 0; return H;&#125;bool isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool insert(MinHeap H, int data) &#123; if(isfull(H)) return false; else &#123; int i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &gt; data &amp;&amp; i &gt; 1; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = data; &#125;&#125;void Printpath(MinHeap H, int index) &#123; for(; index &gt;= 1; index /= 2) &#123; printf("%d", H-&gt;Data[index]); if(index != 1) putchar(' '); &#125; putchar('\n');&#125; int main() &#123; int i, n, m, temp; scanf("%d %d", &amp;n, &amp;m); MinHeap H = initheap(n); for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); insert(H, temp); &#125; for(i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;temp); Printpath(H, temp); &#125; return 0;&#125;/*samples:in:5 346 23 26 24 105 4 3out:24 23 1046 23 1026 10*/ 05-8 File Transfer这道题与老师上课讲的连网问题很类似，但是要看清楚题目中I C S分别代表的含义。 I代表输入连接，就相当于将两个元素并成一个集合；C代表检查两个元素是否在一个集合；S代表停止测试。 根据题目的测试样例，我们得现构造集合，然后在判断元素是否在同一个集合内。当然了，一开始所有的元素都是一个独立的集合，只有当“输入连接”后两个元素才算是处于同一个集合。 明白以上原则后，按照题目要求来进行输出即可。 另外，姥姥出这道题的目的就是为了给大家介绍路径压缩与按秩归并，不用这两种方法，显然不能 AC。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10005typedef int Set[MAXN];typedef int SetType;void init(Set S) &#123; int i; for(i = 0; i &lt; MAXN; i++) &#123; S[i] = -1; &#125;&#125;void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125;SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125;int main() &#123; Set set; init(set); int i, n, c1, c2; scanf("%d%*c", &amp;n); char act; while((act = getchar()) != 'S') &#123; scanf("%d %d%*c", &amp;c1, &amp;c2); int root1, root2; root1 = Find(set, c1); root2 = Find(set, c2); if(act == 'C') &#123; if(root1 == root2 &amp;&amp; (root1 &gt; 0 || root2 &gt; 0)) printf("yes\n"); else printf("no\n"); &#125; else if(act == 'I') &#123; Union(set, root1, root2); &#125; &#125; int cnt = 0; for(i = 1; i &lt;= n; i++) &#123; if(set[i] &lt; 0) cnt++; &#125; if(cnt == 1) printf("The network is connected.\n"); else printf("There are %d components.\n", cnt); return 0;&#125; 按秩归并姥姥讲解的按秩归并有两种方法，关键取决于如何理解“秩”，可以将其认为是树高，也可以认为是树结点的个数。但两者有一个共同点，那就是将小规模的树并到大规模的树上。123456789void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125; 路径压缩路径压缩所解决的问题是尽可能的降低树的高度，这样就会使得其查找效率提高。 在之前介绍的查找操作中，每次需要先找到叶结点在去找根结点，找到了之后并不对集合（也就是查找树）的结构做出优化。但路径压缩借助递归，每找到一个结点，就将它直接挂在根结点的下面，这样当找到目标结点的根结点时，这棵查找树的高度就是 2 了，极大的提高了下次查找时的效率。1234SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125; 05-9 Huffman Codes题目大意就是给定字符出现的频率，判断给定的测试样例是否是最优解，但要注意最优解可能并不是由哈夫曼树构成的。 当初做这个题时，想方设法的偷懒，非常不情愿建哈夫曼树，结果最后还真找到了 AC 的方法。 虽然不建哈夫曼树，但是 WPL 还是需要计算出来用来判定是否最优的。那么如何计算 WPL 呢？对，继续偷懒，直接用 C++ STL 里面的优先队列（其实就是最小堆），核心思路就是哈夫曼树的 WPL 也等于除了根结点以外，全部结点的权值之和。这种计算方法与老师上课讲的是完全不同了，利用这种思路，可以很简单的计算出一棵哈夫曼树的 WPL，而且还不用建树。 有了最优解的 WPL 后，只需要在计算出每个样例的 WPL，并比对是否一致即可知道样例是否正确。 明白以上问题后，基本已经解决这道题目了。不过还有一个地方要注意，对于非前缀码且 WPL 相同的样例，就不是正确结果了。所以，在计算样例的 WPL 后，还需要判断样例中是否有非前缀码的存在，如果有，那就不是正确结果，需判定为 No。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int maxn = 65 + 5;int hashTable[128] = &#123;0&#125;;bool issubstr(string a, string b) &#123; int flag = true; for(int i = 0; i &lt; b.length(); i++) &#123; if(b[i] != a[i]) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; int n; cin &gt;&gt; n; char ch; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch; cin &gt;&gt; hashTable[ch]; q.push(hashTable[ch]); &#125; int wpl = 0; while(q.size() &gt; 1) &#123; int n1, n2, n; n1 = q.top(); q.pop(); n2 = q.top(); q.pop(); n = n1 + n2; q.push(n); wpl += n; &#125; int m; cin &gt;&gt; m; while(m--) &#123; string codes[maxn]; int wpl_tmp = 0; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch &gt;&gt; codes[i]; wpl_tmp += codes[i].length() * hashTable[ch]; &#125; bool prefix = false; for(int i = 0; i &lt; n; i++) &#123; string str_tmp = codes[i]; for(int j = 0; j &lt; n; j++) &#123; if(str_tmp != codes[j] &amp;&amp; issubstr(codes[j], str_tmp)) &#123; prefix = true; break; &#125; &#125; if(prefix) break; &#125; bool repetition = false; for(int i = 0; i &lt; n - 1; i++) &#123; string str_tmp = codes[i]; if(str_tmp == codes[i + 1]) &#123; repetition = true; break; &#125; &#125; if(wpl_tmp == wpl &amp;&amp; !prefix &amp;&amp; !repetition) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_05_01-测试赛]]></title>
    <url>%2F2020%2F05%2F03%2FPAT-05-01-%E6%B5%8B%E8%AF%95%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[本来这原文中应该在昨天就发出来的，于是乎，偷了一下懒，就到今天了...废话不多说直接看题！ 7-1 knuth 洗牌法Knuth 洗牌法是生成 { 1, 2, …, n } 的一个随机重排列的算法。与每次反复随机生成一个数字，直到获得一个不重复的新数字的算法不同，Knuth 洗牌法从原始序列 { 1, 2, …, n } 开始，逐次洗牌。洗牌的方法是从左到右，每轮从没确定的数字中随机抽取一个数，把它放到确定的位置上。例如令 n 等于 4。我们从 { 1, 2, 3, 4 } 开始。记 i 到 N 之间的随机抽牌数为 random(i,N)。假设我们生成的随机数序列 random(i,4) (i=1, 2, 3, 4) 为 { 2, 4, 3, 4 }。则 Knuth 洗牌法是这样执行的： random(1,4) = 2; 将位置 1 与位置 2 的数字交换，得到 { 2, 1, 3, 4 } random(2,4) = 4; 将位置 2 与位置 4 的数字交换，得到 { 2, 4, 3, 1 } random(3,4) = 3; 将位置 3 与位置 3 的数字交换，得到 { 2, 4, 3, 1 } random(4,4) = 4; 将位置 4 与位置 4 的数字交换，得到 { 2, 4, 3, 1 } 现给定随机抽牌数字序列，请你输出 Knuth 洗牌法的结果序列。输入格式：输入在第一行中给出一个正整数 N（≤ 1000）。随后一行给出 N 个随机抽牌数字，数字间以空格分隔。题目保证第 i 个数在 i 到 N 之间。输出格式：在第一行中输出 Knuth 洗牌法的结果序列。数字间必须以 1 个空格分隔，行首尾不得有多余空格。 Input12107 4 4 5 10 6 9 9 10 10 Output17 4 2 5 10 6 9 1 3 8 Analysis题目字太多了，不知道是不是姥姥故意这样，来迷惑人，隐藏题意。 其实这个题目就是让你交换数字（算是简单模拟），以样例为例：第一次，处于第一位的数字与处于第七位的数字交换；以第一次得到的结果序列为初始序列，交换处于第二位的数字和处于第四位的数字；依次类推即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; seq[i] = i; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++) &#123; int tmp = seq[i], random; cin &gt;&gt; random; seq[i] = seq[random]; seq[random] = tmp; &#125; for(int i = 1; i &lt;= n - 1; i++) &#123; cout &lt;&lt; seq[i] &lt;&lt; ' '; &#125; cout &lt;&lt; seq[n]; return 0;&#125; 7-2 三阶幸福数对一个十进制数的各位数字做一次立方和，称作一次迭代。如果一个十进制数能通过 h 次迭代得到 1，就称该数为三阶幸福数，迭代的次数 h 称为幸福度。例如 1579 经过 1 次迭代得到 1198，2 次迭代后得到 1243，3 次迭代后得到 100，最后得到 1。则 1579 是幸福数，其幸福度为 4。另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 97 迭代得到 1072、352、160、217、352、…… 可见 352 到 217 形成了死循环，所以 97 就不幸福，而 352 就是它最早遇到的循环点。本题就要求你编写程序，判断一个给定的数字是否有三阶幸福。 输入在第一行给出一个不超过 100 的正整数 N，随后 N 行，每行给出一个不超过 104 的正整数。 对于每一个输入的数字，如果其是三阶幸福数，则在一行中输出它的幸福度；否则输出最早遇到的循环点。 Input123431579971 Output12343520 Analysis这个题目本质上其实是个数字游戏...按照题目给定的“游戏规则”来处理就行了，由于需要判断数字是否“幸福”，借助哈希表无疑是最快捷、方便的选择。 Code下面是当时写的代码，有点乱见谅，这段代码其实用到的思想都是 C 里面的东西，将 cin 和 cout 换成 scanf 和 printf 说不定还能快点呢。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100000 + 5;int hashtable[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; hashtable[i] = 0; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; while(n--) &#123; int num, degree = 0; cin &gt;&gt; num; init(); if(num == 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int tmp = num; while(1) &#123; int digit, res = 0; hashtable[tmp] = 1; while(tmp) &#123; digit = tmp % 10; res += pow(digit, 3); tmp /= 10; &#125; degree++; hashtable[res]++; if(res == 1) &#123; cout &lt;&lt; degree &lt;&lt; endl; break; &#125; else if(hashtable[res] == 2) &#123; cout &lt;&lt; res &lt;&lt; endl; break; &#125; tmp = res; &#125; &#125; return 0;&#125; 7-3 三阶幸福数据香港《南华早报》2019年7月15日文章，上海严格的垃圾分类新规令不少居民抓狂。这催生出大量帮助找出正确分类答案的App和小程序。目前仅微信上就至少有280种与垃圾处理有关的App，在苹果应用商店也达130种。支付宝表示，已有60多家独立App开发商申请为该平台提供类似服务。本题就请你现场实现一个简单的垃圾分类小助手。 输入首先给出官方分类指南中每种物品的归属。在一行中给出一个正整数 N（≤10​5≤10​5 \le10​^5≤10​5​​），即物品数量；随后 N 行，每行给出一个物品名称（长度不超过 10 的、由小写英文字母和下划线组成的字符串）和该物品所属的分类（1 代表干垃圾、2 代表湿垃圾、3 代表可回收物、4 代表有害垃圾）。题目保证所有物品名称无重复。随后每行给出一个查询物品的名称（格式与指南物品名称相同）。最后一行给出结束符 #，表示查询终止，这一行不需要查询。 对每个查询的物品，在一行中给出其所属分类：Gan laji 代表干垃圾；Shi laji 代表湿垃圾；Ke Hui Shou 代表可回收物；You Hai laji 代表有害垃圾。如果查询的物品不在指南中，则输出 ? 表示不知道。 Input12345678910114bao_zhi 3dian_chi 4dan_ke 2bei_ke 1dan_kedian_chiren_zhabao_zhibei_ke# Output12345Shi lajiYou Hai laji?Ke Hui ShouGan laji Analysis考试时，做这个题只想到了 map，没想到 unordered map，单纯只用 map，3分，unordered map，AC。感觉损失惨重... 另外，能不用 cin 和 cout，还是尽量不用... Code下面是当时用 map 写的代码：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; rab2id;int main() &#123; int n, id; cin &gt;&gt; n; string str; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; id; rab2id[str] = id; &#125; while(cin &gt;&gt; str &amp;&amp; str != "#") &#123; if(rab2id[str] == 1) &#123; cout &lt;&lt; "Gan laji\n"; &#125; else if(rab2id[str] == 2) &#123; cout &lt;&lt; "Shi laji\n"; &#125; else if(rab2id[str] == 3) &#123; cout &lt;&lt; "Ke Hui Shou\n"; &#125; else if(rab2id[str] == 4) &#123; cout &lt;&lt; "You Hai laji\n"; &#125; else cout &lt;&lt; "?\n"; &#125; return 0;&#125; 下面是 AC 的代码（如果不想那么多 if-else，也可以利用字符串数组来输出）：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; rab2id;char s[20]; int main() &#123; int n, id; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", s, &amp;id); rab2id[s] = id; &#125; while(scanf("%s", s) != EOF) &#123; string str(s); if(str == "#") &#123; break; &#125; else if(rab2id[str] == 1) &#123; printf("Gan laji\n"); &#125; else if(rab2id[str] == 2) &#123; printf("Shi laji\n"); &#125; else if(rab2id[str] == 3) &#123; printf("Ke Hui Shou\n"); &#125; else if(rab2id[str] == 4) &#123; printf("You Hai laji\n"); &#125; else printf("?\n"); &#125; return 0;&#125; 总结三道 20 分的题目，应该就是乙级 20 分题目的难度？ 可能是我太久没有写代码的缘故了，第一道题目被迷惑了挺久的，原本应该十几分钟就搞定的，结果好像快半个小时才搞定... 第二道题目果然解决起来就快了许多（稍微熟悉了一点），不过意外的是没想到有这么多测试点... 第三道题目只想到了 map 无疑是个败笔，不过也反映了自己忘记了太多东西了...😱而且面对这种卡超时的题目，莫名的有点虚。 反正三道题目都不难就是了，没全部 AC，该检讨。特别是最后一题，几分钟就拿到了 3 分，后面 40 分钟都阵亡了... PS：前两道题都是一次 AC]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_04-树（中）]]></title>
    <url>%2F2020%2F05%2F01%2FZJU-DS-04-%E6%A0%91%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前面学习了树的基本术语、性质，以及二叉树的形态、遍历方法等，这次会继续学习两种“新”二叉树 Binary Search Tree定义二叉搜索树（BST，Binary Search Tree），也成为二叉排序树或二叉查找树。二叉搜索树：前提得是一棵二叉树，可以为空；如果不为空，满足以下性质： 非空左子树的所有键值小于其根结点的键值 非空右子树的所有键值大于其根节点的键值 左、右子树都是二叉搜索树 特别函数二叉搜索树本质上还是二叉树，所以其抽象数据类型描述与二叉树是一致的，但操作集存在差异，多了几个特别函数： Position Find(ElementType X, BinTree BST)，从二叉搜索树BST中查找元素X，返回其所在结点的地址 Position FindMin(BinTree BST)，从二叉搜索树BST中查找并返回最小元素所在结点的地址 Position FindMax(BinTree BST)，从二叉搜索树BST中查找并返回最大元素所在结点的地址 BinTree Insert(ElementType X, BinTree BST)，向二叉搜索树中插入结点 BinTree Delete(ElementType X, BinTree BST)，在二叉搜索树中删除结点 下面以二叉树的链式存储结构为准，完成几个常用的特别函数。 查找查找函数的实现思路比较直接，按照二叉搜索树的性质，比根结点小则在左子树中查找，比根节点大则在右子树中查找，循环这个过程即可。 递归123456Position Find(ElementType X, BinTree BST) &#123; if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(X, BST-&gt;Right); else if(X &lt; BST-&gt;Data) return Find(X, BST-&gt;Left); else return BST;&#125; 非递归12345678Position IterFind(ElementType X, BinTree BST) &#123; while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else return BST; &#125; return NULL;&#125; 查找最值有了前面查找的思路后，根据 BST 的性质，直接查找最值的函数也很容易得到。 递归1234567891011Position FindMax(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else FindMin(BST);&#125;Position FindMin(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else FindMin(BST);&#125; 非递归12345678910111213Position FindMax(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Right) BST = BST-&gt;Right; &#125; return BST;&#125;Position FindMin(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Left) BST = BST-&gt;Left; &#125; return BST;&#125; 插入插入的关键在于先确定好插入的位置，既然要确定位置，那么就可以借助查找的思路。 递归1234567891011BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST;&#125; 非递归123456789101112131415161718192021222324BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125; 删除删除的思路与插入的思路也类似，还是需要先找删除的位置。但是针对删除结点的不同（叶结点和非叶结点），需要分别考虑。如果删除的是叶结点，那么可以直接删除；但若删除非叶结点，就需要在删除这个结点后，用另一结点替代被删除结点，这样才不会使链式结构断裂。 对于度为 1 的被删除结点，另一结点直接使用其子结点即可；对于度为 2 的被删除结点，另一结点可以用其右子树的最小元素或者其左子树的最大元素，之所要用这两个结点，因为这两个结点一定是叶结点，可以直接拿掉。123456789101112131415161718192021222324252627BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125; Balanced Tree平衡二叉树需要引入平衡因子的概念，其解决了二叉搜索树中出现“单枝树”而导致查找效率过低的树形结构问题。 平衡因子（Balance Factor，BF）：$BF(T) = h_l - h_r$，其中$h_l$和$h_r$分别为树 T 的左右子树高度。 定义平衡二叉树（Balanced Tree，也叫 AVL 树）:空树，或者任何一结点左右子树高度差的绝对值不超过 1，即$|BF(T)| \le 1$。 调整平衡二叉树的结构调整情况有以下四种情况，关键在于观察离破坏者最近的被破坏者和破坏者之间的位置关系。但是要注意有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子。RRLLLRRLRR旋转（虽然叫 RR 旋转，但是实际过程是左旋），破坏者位于被破坏者的右子树的右子树下。 12345678Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LL旋转（虽然叫 LL 旋转，但是实际过程是右旋），破坏者位于被破坏者的左子树的左子树下。 12345678Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LR旋转（与名称一致，先左旋后右旋），破坏者位于被破坏者的左子树的右子树下。 1234Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;RL旋转（与名称一致，先右旋后左旋），破坏者位于被破坏者的右子树的左子树下。 1234Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125; Homework04-4 是否同一棵二叉搜索树这道题与树的同构有点像，下面的代码包含两种做法： 构造两棵树，判断两棵树是否一致 只构造一棵树，判断给定序列顺序是否与树的结点序列一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* method 1: use recursion to judge two trees is same or not */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;PtrToTNode createnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct TNode)); t-&gt;left = t-&gt;right = NULL; t-&gt;data = data; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = createnode(data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); return root;&#125;bool issame(Tree root1, Tree root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if((!root1 &amp;&amp; root2) &amp;&amp; (root1 &amp;&amp; !root2)) return false; else &#123; if(root1-&gt;data != root2-&gt;data) return false; else return issame(root1-&gt;left, root2-&gt;left) &amp;&amp; issame(root1-&gt;right, root2-&gt;right); &#125;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l; scanf("%d", &amp;n); while(n) &#123; scanf("%d", &amp;l); Tree root1 = NULL; int i, data; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root1 = insert(root1, data); &#125; while(l--) &#123; Tree root2 = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root2 = insert(root2, data); &#125; if(issame(root1, root2)) printf("Yes\n"); else printf("No\n"); destorytree(root2); &#125; scanf("%d", &amp;n); if(n == 0) destorytree(root1); &#125; return 0;&#125;/* method 2: constitute a tree, check the path of visiting everynodes is sameor not #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct node&#123; int flag, data; struct node *left, *right;&#125;;typedef struct node* Tree;typedef struct node* PtrToTNode;PtrToTNode newnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct node)); t-&gt;data = data; t-&gt;flag = 0; t-&gt;left = t-&gt;right = NULL; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = newnode(data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); return root;&#125;Tree buildtree(int n) &#123; int i, data; Tree root = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; return root;&#125;bool check(Tree root, int data) &#123; if(root-&gt;flag) &#123; if(data &lt; root-&gt;data) return check(root-&gt;left, data); else if(data &gt; root-&gt;data) return check(root-&gt;right, data); else return false; &#125; else &#123; if(data == root-&gt;data) &#123; root-&gt;flag = 1; return true; &#125; else return false; &#125;&#125;bool judge(Tree root, int n) &#123; int i, data; bool flag = false; scanf("%d", &amp;data); if(data != root-&gt;data) flag = true; else root-&gt;flag = 1; for(i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;data); if(!flag &amp;&amp; !check(root, data)) flag = 1; &#125; return !flag;&#125;void reset(Tree root) &#123; if(root-&gt;left) reset(root-&gt;left); if(root-&gt;right) reset(root-&gt;right); root-&gt;flag = 0;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l, i; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;l); Tree root = buildtree(n); while(l--) &#123; if(judge(root, n)) printf("Yes\n"); else printf("No\n"); reset(root); &#125; destorytree(root); &#125; return 0;&#125; */ 04-5 Root of AVL Tree这道题就是何老师讲的平衡二叉树的四种旋转方式，题目一次将四种旋转方式全部考察到了，出的很好。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data, height; struct TNode *lchild, *rchild;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int getheight(Tree root) &#123; if(!root) return -1; else return root-&gt;height;&#125;Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125;Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;Tree insert(Tree root, int data) &#123; if(!root) &#123; root = (Tree)malloc(sizeof(struct TNode)); root-&gt;lchild = root-&gt;rchild = NULL; root-&gt;data = data; root-&gt;height = 0; &#125; else if(data &gt; root-&gt;data) &#123; root-&gt;rchild = insert(root-&gt;rchild, data); if(getheight(root-&gt;rchild) - getheight(root-&gt;lchild) == 2) &#123; if(data &gt; root-&gt;rchild-&gt;data) root = RRrotate(root); else root = RLrotate(root); &#125; &#125; else if(data &lt; root-&gt;data) &#123; root-&gt;lchild = insert(root-&gt;lchild, data); if(getheight(root-&gt;lchild) - getheight(root-&gt;rchild) == 2) &#123; if(data &lt; root-&gt;lchild-&gt;data) root = LLrotate(root); else root = LRrotate(root); &#125; &#125; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return root;&#125;int main() &#123; int i, n, data; scanf("%d", &amp;n); Tree root = NULL; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; printf("%d", root-&gt;data); return 0;&#125; 04-6 Complete Binary Search Tree这道题很有难度，要对完全二叉树、二叉查找树及二叉树的遍历有较深的理解才能解出来，不过解不出来也没事，姥姥后面会讲。123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1005int n, tree[maxn], seq[maxn], inde = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); tree[root] = seq[inde++]; inorder(2 * root + 1);&#125;int cmp(const void *a, const void *b) &#123; return (*(int*)a - *(int*)b);&#125;int main() &#123; scanf("%d", &amp;n); int i; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;seq[i]); &#125; qsort(seq, n, sizeof(seq[0]), cmp); inorder(1); for(i = 1; i &lt;= n; ++i) &#123; printf("%d", tree[i]); if(i &lt; n) printf(" "); &#125; return 0;&#125; 04-7 二叉搜索树的操作集这道题目是用来测试二叉搜索树常用操作的，可以尝试多种不同的写法来提交来验证是否正确。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT );void InorderTraversal( BinTree BT );BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST = NULL; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Insert(BST, X); &#125; printf("Preorder:"); PreorderTraversal(BST); printf("\n"); MinP = FindMin(BST); MaxP = FindMax(BST); scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); Tmp = Find(BST, X); if (Tmp == NULL) printf("%d is not found\n", X); else &#123; printf("%d is found\n", Tmp-&gt;Data); if (Tmp==MinP) printf("%d is the smallest key\n", Tmp-&gt;Data); if (Tmp==MaxP) printf("%d is the largest key\n", Tmp-&gt;Data); &#125; &#125; scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Delete(BST, X); &#125; printf("Inorder:"); InorderTraversal(BST); printf("\n"); return 0;&#125;void PreorderTraversal( BinTree BT ) &#123; if(!BT) return; printf("%d ", BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void InorderTraversal( BinTree BT ) &#123; if(!BT) return; InorderTraversal(BT-&gt;Left); printf("%d ", BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST; */ /* method 2: use loop */ if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125;Position Find( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) return Find(BST-&gt;Left, X); else return BST; */ /* method 2: use loop*/ while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else break; &#125; return BST;&#125;Position FindMin( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Left) BST = BST-&gt;Left; return BST;&#125;Position FindMax( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else return FindMax(BST-&gt;Right); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Right) BST = BST-&gt;Right; return BST;&#125;/*samples:in:105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3out:Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_03-树（上）]]></title>
    <url>%2F2020%2F04%2F01%2FZJU-DS-03-%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是树？如何表示和实现？树又有什么样性质？常见的应用有哪些？ 引言在了解树之前，先了解一下树在生活中的应用，比如：人类社会的家谱、社会组织结构和图书信息管理。这类信息结构都有一个共同点，那就是内部的不同事物之间都具有层次关系。 查找查找是计算机中的基础操作，所谓基础，即是指查找操作广泛使用在计算机的各个应用，优秀的查找算法对于提高程序查找效率很有帮助。 查找：根据某个给定关键字 K ，从集合 R 中找出关键字与K相同的记录，查找可以分为两类： 静态查找：集合中记录是固定的，没有插入和删除操作，只有查找 动态查找：集合中记录是动态变化的，除查找操作外，还可能会有插入和删除操作 下面仅就静态查找展开讨论。 静态查找静态查找的方法，根据存储结构的不同有着多种多样的方法，下面以数组为例来展开讨论。 顺序查找利用数组下标来作为循环的边界，也可以通过“哨兵”的设计技巧来避免使用下标作为边界值，具体而言，即当前下标的数组值与哨兵的值相等时，跳出循环，代码如下：123456int SequentialSearch(StaticTable *Tbl, ElementType K) &#123; int i; Tbl-&gt;ElementType[0] = K; for(i = Tbl-&gt;Length; Tbl-&gt;ElementType[i] != K; i--); return i;&#125; 显然，顺序查找算法的时间复杂度为$O(n)$。 二分查找二分查找在第一周的作业题中已经见过了。实际上，二分查找是有前提的： 序列有序 存储在数组中 在有序的基础下，假若要查找值X，分别设置left、mid、right三个下标值。每次时，查找mid = (left + right)/2，如若array[mid] &gt; X，则有mid = right - 1，如若array[mid] &lt; X，则有mid = left + 1，当left &lt;= right这个条件不成立时，跳出循环。 注意：每次更新的left和right不能为mid。 二分查找的过程实际上可以构造出一棵二分查找判定树，而在这棵判定树上，每个结点需要查找的次数刚好为该节点所在的层数。也就是说，查找成功时的查找次数不会超过判定树的深度，从而可以得到，n 个结点的判定树的深度为$[log_{2}n] + 1$，这里就又有了一个新的概念 — ASL, Average Search Length，平均查找次数（也叫平均查找长度，后面单独讲查找时会再次遇到） ,可得：$ASL = (4 \times 4 + 4 \times 3 + 2 \times 2 + 1) \div 11 = 3$。 代码如下：123456789101112int BinarySearch(StaticTable *Tbl, ElementType K) &#123; int left, right, mid, NotFound = -1; left = 1; right = Tbl-&gt;Length; while(left &lt;= right) &#123; mid = (left + right) / 2; if(K &lt; Tbl-&gt;ElementType[mid]) right = mid - 1; else if(K &gt; Tbl-&gt;ElementType[mid]) left = mid + 1; else return mid; &#125; return NotFound;&#125; 二分查找的时间复杂度前面已经分析过了是$O(logN)$。 树定义树（Tree）：n（n≥0）个结点构成的有限集合，当n=0时，称为空树，对于任何一棵非空树，它具备以下性质： 树中有一个称为“根（root）”的特殊节点，用r表示 其余结点可分为m（m＞0）个互不相交的有限集$T_1, T_2, \ldots, T_m$，其中每个集合本身又是一棵树，称为原来树的“子树（SubTree）”。注意： 子树不能相交 除了根节点，每个节点有且仅有一个父节点 一棵N个节点的树有N-1条边 树是保证连通且边数最少的一种连接方式 基本术语与树相关的基本术语如下： 结点的度（Degree）：结点的子树个数 树的度：树的所有结点中最大的度数 叶结点（Leaf）：度为 0 的结点 父结点（Parent）：有子树的结点是其子树的的根结点的父结点 子结点（Child）：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子结点，子结点也称为孩子结点 兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点 路径和路径长度：从结点 $n_1$ 到 $n_k$ 的路径为一个结点序列 $n_1, n_2, \ldots, n_k, n_i$ 是 $n_{i+1}$ 的父结点，路径所包含的个数为路径的长度。 祖先结点（Ancestor）：沿树根到某一结点路径上所有结点都是这个结点的祖先结点 子孙结点（Descendant）：某一结点的子树中的所有结点都是这个结点的子孙 结点的层次（Level）：规定根节点在1层，其他任一结点的层数是其父结点层数加1 树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度 表示树的表示方法有多种，因需要表示其中的逻辑关系，一般会用链表实现，数组无法表示其中的逻辑关系。 儿子-兄弟表示法利用两个指针来保存逻辑关系，即：FirstChild指针用来保存第一个孩子结点的地址，NextSibling指针用来保存下一个兄弟结点的地址。这样，每个结点需要 2 个指针域，一棵树共有 $n-1$ 条边，这样浪费的指针域个数为 $2n - (n-1) = n+1$。 二叉树表示法二叉树简言之就是度为2的树，但相较度为 2 的树而言，二叉树的子树有左右之分。一般而言，所有能用儿子-兄弟表示法表示的树都可以用二叉树来表示，只需将儿子-兄弟表示法得到的树旋转 45° 即可得对应的二叉树。 二叉树前面提到过了用二叉树来表示树，但实际上二叉树自身也具有十分独特的性质。 定义二叉树T：一个有穷的结点集合。这个集合可以为空（空二叉树），若不为空，则它是由根结点和称为其左子树$T_L$和右子树$T_R$的两个不相交的二叉树组成。二叉树有五种基本形态：空树、单结点树、左子树为空的树、右子树为空的树和左右子树都不空的树。 注意：二叉树与普通度为2的树的区别在于，二叉树的子树有左右之分。 特殊二叉树（题目中也可能会出现）： 斜二叉树（Skewed Binary Tree）：只有左（右）子树，形状上呈现一边倒的样子，类似链表 完美二叉树（Perfect Binary Tree），也叫满二叉树（Full Binary Tree）：除了叶结点外，每一个结点都有两个儿子结点 完全二叉树（Complete Binary Tree）：有n个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中位置相同。 性质二叉树的几个重要性质： 一个二叉树第 i 层的最大结点数为：$2^{i-1}, i \ge 1$。 深度为 k 的二叉树有最大结点树为：$2^k-1, k \ge 1$。 对任何非空二叉树T，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0 = n_2 + 1$，这个结论可证明。 二叉树抽象数据类型描述类型名称：二叉树数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成。操作集：BT ∈ BinTree，Item∈ ElementType，重要操作有： Boolean IsEmpty(BinTree BT)，判别BT是否为空 void Traversal(BinTree BT)，遍历，按照某顺序访问每个结点 BinTree CreatBinTree()，创建一个二叉树。 常见的遍历方法有： void PreOrderTraversal(BinTree BT)，先序遍历，根→左→右 void InOrderTraversal(BinTree BT)，中序遍历，左→根→右 void PostOrderTraversal(BinTree BT)，后序遍历，左→右→根 void LevelOrderTraversal(BinTree BT)，层次遍历，从上到下，从左到右 二叉树的顺序存储结构二叉树顺序存储一般直接使用（结构）数组实现，而完全二叉树直接用一维数组即可实现，也易于操作。对于使用数组表示的完全二叉树而言，可以通过结点的序号（数组的下标）中的规律来帮助反映结点之间的父子（逻辑）关系，具体如下： 非根结点（序号$i＞1$）的父结点的序号是$\lfloor i/2 \rfloor$ 结点（序号为$i$）的左孩子结点的序号是$2i$，若$2i \geqslant n$，否则没有左孩子 结点（序号为$i$）的左孩子结点的序号是$2i+1$，若$2i+1 \geqslant n$，否则没有右孩子 一般结构的二叉树也可以采用这种结构，但是会造成空间的浪费，因为数组中也存储了空结点。 二叉树的链式存储结构定义如下：123456struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree; 二叉树的遍历二叉树的遍历既可以直接用递归的思想完成，也可以借助栈来构造非递归的遍历算法。尽管递归的缺点很明显，但好在易于理解，且形式简单，一般而言都是用递归来遍历二叉树。不过从学习的角度来讲，多探究一下没有任何坏处，所以下面的内容也给出非递归的算法。注：下面的代码有部分是 C++ 的内容，但并没有特别难于理解地方。 先序遍历遍历过程：访问根结点 → 先序遍历其左子树 → 先序遍历其右子树1234567891011121314151617181920212223void preorder(Tree root) &#123; /* method 1: use recursion if(!root) return; cout &lt;&lt; root-&gt;data &lt;&lt; ' '; preorder(root-&gt;left); preorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; &#125; 中序遍历遍历过程：先序遍历其左子树 → 访问根结点 → 先序遍历其右子树1234567891011121314151617181920212223void inorder(Tree root) &#123; /* method 1: use recursion if(!root) return; inorder(root-&gt;left); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; inorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;right; &#125; &#125;&#125; 后序遍历遍历过程：先序遍历其左子树 → 先序遍历其右子树 → 访问根结点后序遍历的非递归算法其实有很多，这里举两个例子，分别使用了 2 个栈和 1 个栈来完成，使用双栈的思路较为直观一些，建议动手模拟一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void postorder(Tree root) &#123; /* method 1: use recursion if(!root) return; postorder(root-&gt;left); postorder(root-&gt;right); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; */ /* method 2: use loop and two stacks stack&lt;PtrToTNode&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; root = st2.top(); st2.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; &#125; */ /* method 3: use loop and one stack */ stack&lt;PtrToTNode&gt; st; PtrToTNode pre = NULL, cur = NULL; st.push(root); while(!st.empty()) &#123; cur = st.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur) &#123; if(cur-&gt;left != NULL) st.push(cur-&gt;left); else if(cur-&gt;right != NULL) st.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre) &#123; if(cur-&gt;right != NULL) &#123; st.push(cur-&gt;right); &#125; &#125; else &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; st.pop(); &#125; pre = cur; &#125;&#125; 层序遍历遍历过程：从第一层开始，从左往右依次访问每个结点。层序遍历一般用队列实现，也可以使用栈来实现。层序遍历一般采用迭代（循环）的思想来实现。123456789101112void levelorder(Tree root) &#123; queue&lt;PtrToTNode&gt; q; q.push(root); while(!q.empty()) &#123; PtrToTNode front = q.front(); q.pop(); cout &lt;&lt; front-&gt;data &lt;&lt; ' '; if(front-&gt;left) q.push(front-&gt;left); if(front-&gt;right) q.push(front-&gt;right); &#125; cout &lt;&lt; endl;&#125; 作业03-1 树的同构按照这道题目给定的数据形式，用静态链表的方式表示树，解起题来会比较方便（正如姥姥前面说过：合适的数据结构能够帮助我们解决问题），当然也可以动脑子想一想怎么用指针来解决。另外，在判断树是否同构时要注意问题考虑全面（读题仔细），理解递归的含义，“同构其实并没有要求树的结构完全一致，只要求结点分布一致即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 15struct TNode&#123; char data; int left, right;&#125; T1[maxn], T2[maxn];void init() &#123; int i; for(i = 0; i &lt; maxn; i++) &#123; T1[i].left = T1[i].right = T2[i].left = T2[i].right = -1; &#125;&#125;int buildtree(struct TNode T[]) &#123; int i, n; scanf("%d%*c", &amp;n); char data, lc, rc; bool isRoot[maxn] = &#123;false&#125;; for(i = 0; i &lt; n; i++) &#123; scanf("%c %c %c%*c", &amp;data, &amp;lc, &amp;rc); T[i].data = data; if(lc != '-') &#123; T[i].left = lc - '0'; isRoot[lc - '0'] = true; &#125; if(rc != '-') &#123; T[i].right = rc - '0'; isRoot[rc - '0'] = true; &#125; &#125; int root = -1; for(i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; return root;&#125;bool Isomorphic(int root1, int root2) &#123; if(root1 == -1 &amp;&amp; root2 == -1) return true; if((root1 == -1 &amp;&amp; root2 != -1) || (root1 != -1 &amp;&amp; root2 == -1)) return false; if(T1[root1].data != T2[root2].data) return false; if(T1[root1].left == -1 &amp;&amp; T2[root2].left == -1) &#123; return Isomorphic(T1[root1].right, T2[root2].left); &#125; if((T1[root1].left != -1 &amp;&amp; T2[root2].left != -1) &amp;&amp; (T1[T1[root1].left].data == T2[T2[root2].left].data)) &#123; return Isomorphic(T1[root1].left, T2[root2].left) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].right); &#125; else return Isomorphic(T1[root1].left, T2[root2].right) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].left);&#125;int main() &#123; init(); int root1 = buildtree(T1); int root2 = buildtree(T2); if(Isomorphic(root1, root2)) printf("Yes"); else printf("No"); return 0;&#125;/*some samples:in:00out: Yes*/ 03-2 List Leaves题目要求找一棵树中的所有叶子结点（无孩子），顺序是从上到下，从左到右。如果要访问所有叶子结点，那么肯定少不了树的遍历。进而可以想到，题目要求的输出顺序与层序遍历的输出顺序是一致的。所以可以借助层序遍历的代码来构造输出叶子结点的算法。由于层序遍历需要用到队列，直接用 C++ 的 STL 内的 Queue。根据题目的形式，还是用静态链表的方法来表示树。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 20;struct node&#123; int left, right;&#125; Tree[maxn];bool isRoot[20] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;void levelorder(int root) &#123; queue&lt;int&gt; q; q.push(root); bool flag = true; while(!q.empty()) &#123; int tmp = q.front(); q.pop(); if(Tree[tmp].left == -1 &amp;&amp; Tree[tmp].right == -1) &#123; if(flag) &#123; cout &lt;&lt; tmp; flag = false; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; tmp; &#125; &#125; if(Tree[tmp].left != -1) q.push(Tree[tmp].left); if(Tree[tmp].right != -1) q.push(Tree[tmp].right); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; char c1, c2; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; c1 &gt;&gt; c2; if(c1 != '-') &#123; isRoot[c1 - '0'] = true; Tree[i].left = c1 - '0'; &#125; if(c2 != '-') &#123; isRoot[c2 - '0'] = true; Tree[i].right = c2 - '0'; &#125; &#125; int root; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; levelorder(root); return 0;&#125; 03-3 Tree Traversals Again题目考察二叉树的先序、中序和后序遍历（一道题目考到了树的三种遍历方法）。 题目背景是二叉树中序遍历的非递归算法的入、出栈顺序，实际上，入栈顺序就是先序序列，出栈顺序就是中序序列。这样可以使用先序序列和中序序列构造树，进而在通过后序遍历来输出后序序列。那么如何表示树呢？由于本题给定的数据并没有给出树的具体结构，实际上用链式结构或者顺序结构的复杂度都是一样的。 不过此题也可以不用构造树，直接通过递归来得到后序序列。不过不是那么好理解，建议手动模拟一下，笔试中也有类似的题目，思路本质上是一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* method 1: Do not build a tree. use recursion */#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5; int in[maxn], pre[maxn], post[maxn], n;void solve(int preL, int inL, int postL, int n) &#123; if(n == 0) return; if(n == 1) &#123; post[postL] = pre[preL]; return; &#125; int root = pre[preL], i; post[postL + n - 1] = root; for(i = 0; i &lt; n; i++) &#123; if(in[inL + i] == root) break; &#125; int L = i, R = n - L - 1; solve(preL + 1, inL, postL, L); solve(preL + L + 1, inL + L + 1, postL + L, R);&#125;int main() &#123; string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; solve(0, 0, 0, n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if(i != n - 1) putchar(' '); &#125; return 0;&#125;/* method 2: use static tree #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5;struct node&#123; int left, right; int data;&#125; Tree[maxn];int in[maxn], pre[maxn], n;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;int buildtree(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) return -1; Tree[preL].data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) break; &#125; int numLeft = k - inL; Tree[preL].left = buildtree(preL + 1, preL + numLeft, inL, k - 1); Tree[preL].right = buildtree(preL + numLeft + 1, preR, k + 1, inR); return preL;&#125;int num = 0;void postorder(int root) &#123; if(root == -1) return; postorder(Tree[root].left); postorder(Tree[root].right); cout &lt;&lt; Tree[root].data; if(num &lt; n - 1) cout &lt;&lt; ' '; num++;&#125;int main() &#123; init(); string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; buildtree(0, n - 1, 0, n - 1); postorder(0); return 0;&#125;*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_02-线性结构]]></title>
    <url>%2F2020%2F02%2F12%2FZJU-DS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是线性结构？如何表示和实现？有哪些线性结构？对应的有什么样性质？常见的应用有哪些？ Linear List在介绍线性表之前，何老师先介绍了线性表的一个应用实例 —— 一元多项式及其运算。而关于一元多项式的表示方法，老师介绍了三种方法： 数组（顺序存储结构）直接表示，数组下标对应未知数 x 的指数，数组元素的值对应各项的系数，但对于某些特殊的多项式，此法会有较多的空间浪费。 结构数组（顺序存储结构）表示非零项，将一个多项式看成是一个指数与系数的二元组的集合，多项式的每一项需按照指数大小有序存储。 链表存储非零项，链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域和一个指针域。 上述三种方法中，利用数组表示是易于实现的，但是不易设计与多项式相关的加减操作。而使用链表来表示十分灵活，且易于实现对应操作。从这可以看出，同一个问题可以有不同的表示（存储）方法；存在一类共性问题，即：有序线性序列的组织和管理。由此可以引出线性表的概念：由同类型数据元素构成有序序列的线性结构，具备以下三个特点： 表中元素个数称为线性表的长度 线性表没有元素时，称为空表 表起始位置称表头，表结束位置称表尾 线性表的抽象数据类型描述类型名称：线性表（List）数据对象集：线性表是$n(≥0)$个元素构成的有序序列操作集：线性表$L ∈ List$，整数$i$表示位置，元素$X ∈ ElementType$，主要操作： List MakeEmpty()，初始化一个空线性表 ElementType FindKth(int K, List L)，根据位序K，返回相应元素 int Find(ElementType X, List L)，在线性表L中查找X的第一次出现为止 void Insert(ElementType X, int i, List L)，在位序i前插入一个新元素X void Delete(int i, List L)，删除指定位序i的元素 int Length(List L)，返回线性表L的长度n 线性表的顺序存储实现顺序表的顺序存储实现利用数组来连续存储空间顺序存放线性表的各元素，C 语言版本的定义（后文的代码都是 C 语言的）如下：1234567typedef int ElementType;typedef int Position; /*note here! */typedef struct LNode* List; /* struct LNode * = List */struct LNode&#123; ElementType Data[MAXSIZE]; /* #define MAXSIZE 100 */ Position Last; /* the length of list */&#125;; 初始化（建立空表）按照上面的定义，我们可以写出建立空表的操作。123456List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; /*use -1 to represent that the list is blank */ return L;&#125; 查找前面一讲中，我们已经学会了二分查找，那么二分查找是否能在此处应用呢？要注意的是，二分查找的前提条件有两个： 顺序存储和数据有序。 这里我们采用按照顺序从前往后查找的方法来编写这个操作，需要将被查找的数据元素和所查找的线性表交给函数。当然，如果线性表是全局变量，那么可以不用传入线性表，这里假设线性表是在main函数中声明的。12345678Position Find(ElementType X, List L) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return -1; /*can't find the element*/ else return i; /*return the index of this element*/&#125; 那么该如何计算查找成功的平均比较次数呢？假设有 n 个元素，如果第一个元素就是我们要查找的元素，那么此时查找成功的比较次数就是 1 次；继而可知当第二个元素就是我们要查找的元素时，查找成功的比较次数就是 2 次；从而我们可以知道对于 n 个元素的线性表查找成功的比较次数就是：$(1 + 2 + ... + n) / n = (1 + n) / 2$。这说明这种思路的查找算法的平均时间性能是$O(n)$。 插入在直接上手写插入操作之前需要想一想插入操作的几种情况：表头、表中和表尾。针对这三种不同的情况，我们可以发现只有当在表尾插入的时候才不需要将元素移动；同时，在每一次插入操作时，由于线性表可能已经满了，那么插入操作就会失败了，这也是需要考虑的情况，接着，我们来写一下代码。12345678910111213141516void Insert(ElementType X, int i, List PtrL) &#123; int j; if(PtrL-&gt;Last == MAXSIZE - 1) &#123; printf("The list is full.\n"); return; &#125; if(i &lt; 1 || i &gt; PtrL-&gt;Last + 2) &#123; printf("The position of the insertion is not valid.\n"); return; &#125; for(j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; PtrL-&gt;Data[i - 1] = X; PtrL-&gt;Last++;&#125; 从上述代码可以看出： 由于线性表的顺序存储结构借助了数组，所以当数组下标为$MAXSIZE - 1$时，表示线性表已满。 当插入位置 i 小于 1 或者大于PtrL-&gt;Last + 2时，插入位置就是不合法的。之所以大于PtrL-&gt;Last + 2不合法是因为，当PtrL-&gt;Last == MAXSIZE - 2时，PtrL-&gt;Last + 2 == MAXSIZE，那么 i 就大于了MAXSIZE，那就超出范围了。这里要区分好两个概念：插入位置和存储位置。插入位置是人为规定且从 1 开始的（符合人的思考习惯），而存储位置是从 0 开始的，因为数组下标是从 0 开始的。后面的移动操作也是基于这个前提来编写的。 所插入位置后的全部元素需要向后移动。 删除有了插入操作的基础，删除操作就比较容易了，因为我们只需先找到要删除的元素，然后将此元素后的所有元素向前移动一个位置即可，但是要注意表为空的情况，代码如下：123456789101112void Delete(int P, List PtrL) &#123; Position i; if(P &lt; 1 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXSIZE 10#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; return L;&#125;Position Find(List L, ElementType X) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return ERROR; else return i;&#125;bool Insert(List L, ElementType X, Position P) &#123; Position i; if(L-&gt;Last == MAXSIZE - 1) &#123; printf("Sequence List is full!\n"); return false; &#125; if(P &lt; 1 || P &gt; L-&gt;Last + 2) &#123; printf("The inserting position is illegal!\n"); return false; &#125; for(i = L-&gt;Last; i &gt;= P - 1; i--) &#123; L-&gt;Data[i + 1] = L-&gt;Data[i]; &#125; L-&gt;Data[P - 1] = X; L-&gt;Last++; return true;&#125;bool Delete(List L, Position P) &#123; Position i; if(P &lt; 0 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125;void Print(List L) &#123; if(L-&gt;Last == -1) printf("The Sequence List is empty!\n"); else &#123; int i = 0; while(i &lt; L-&gt;Last) &#123; printf("%d, ", L-&gt;Data[i]); i++; &#125; printf("%d\n", L-&gt;Data[i]); &#125;&#125;int main() &#123; List Sqlist = MakeEmpty(); bool flag = Insert(Sqlist, 11, 0); printf("flag = %d\n", flag); Insert(Sqlist, 22, 1); Insert(Sqlist, 33, 2); Insert(Sqlist, 44, 3); Print(Sqlist); bool del_flag = Delete(Sqlist, 2); printf("del_flag = %d\n", del_flag); Print(Sqlist); &#125; 线性表的链式存储实现线性表的链式存储实现就是大家熟知的链表了，学过 C 语言的同学可能已经学会了如何构造、使用链表等。相比顺序表而言，链表的最突出的一个特点就是不再要求顺序存储了，也就是说，链表中的各个元素在内存中的位置是不一定相邻的。先看一下链表的定义：123456789#define ERROR NULLtypedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List; 这里使用不同的关键词来表示指向链表的指针，这样在后面的各种操作中可以区分各个指针的作用，让读代码的人更加易于从单词意思来理解代码。 初始化（建立空表）链表建立空表的基本方法有头插法和尾插法，使用不同的方法建立链表可以得到不同的效果，可以方便我们解决问题，以下代码以带头结点的单链表为说明对象。 求表长链表不同于顺序表，顺序表的表厂是限定的，但是链表的长度是无限的（假设内存无限），所以自然就会有求链表表长的问题产生。解决这个问题的最直观的思路也就是将链表遍历（从头结点访问到尾结点）一遍即可，代码如下：123456789int GetLength(List L) &#123; List p = L-&gt;Next; /*Let's say the linked list has head node. */ int length = 0; while(p) &#123; p = p-&gt;Next; length++; &#125; return length;&#125; 查找链表的查找有两种情况，分别是：按序号查找和按值查找。这两种查找方法思路比较简单，本质上都是对链表进行遍历。 按序号查找12345678910List FindKth(int K, List PtrL) &#123; List p = PtrL; int i = 1; while(p != NULL &amp;&amp; i &lt; K) &#123; p = p-&gt;Next; i++; &#125; if(i == K) return p; else return NULL;&#125; 按值查找123456Position Find(ElementType X, List L) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125; 插入往链表中插入一个结点，那么就需要先构造一个新的结点，然后再将这个新的结点插入到链表中。那么，如何进行插入呢？ 假如要插入到第 i 个位置，那么就必须先要找到第 i - 1 个位置，然后再将这个新结点插入到第 i - 1 个结点的后面。另外，此处链式结构的指针应用一直是让初学者头疼的问题。但实际上，分析这类问题时，都有一个原则：必须要先让新结点指向后面的结点，才能再让前面的结点指向新结点。这点其实也不难理解，假如让前面的结点先指向新结点，那么后面的结点就丢失了，因为指向后面的结点的唯一指针（即前面结点的指针）已经指向了新结点。话说起来是很拗口且不那么直观，建议用笔在纸上画一画。 按照不同的查找方法，也可以给出不同的插入方法。 按序号插入1234567891011121314151617181920bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125; 按值插入1234567891011121314151617bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125; 删除由于我们已经明确了查找的方式，所以删除操作可以简化一些了，只要确保指向被删除元素的指针正确传给删除函数即可。12345678910111213141516bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define ERROR NULL#define MAXSIZE 10typedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List;Position Find(List L, ElementType X) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125;Position FindKth(List L, int k) &#123; PtrToLNode p = L; int i = 0; while(p &amp;&amp; i &lt; k) &#123; i++; p = p-&gt;Next; &#125; if(i == k) return p; else return NULL;&#125;List MakeEmpty() &#123; List L = (List)malloc(sizeof(struct LNode)); L-&gt;Next = NULL; return L;&#125;PtrToLNode CreateLNode(int value) &#123; PtrToLNode t = (PtrToLNode)malloc(sizeof(struct LNode)); t-&gt;Next = NULL; t-&gt;Data = value; return t;&#125;bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125;bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125;bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125;void Print(List L) &#123; if(L-&gt;Next == NULL) printf("The link list is empty!\n"); else &#123; L = L-&gt;Next; while(L-&gt;Next != NULL) &#123; printf("%d, ", L-&gt;Data); L = L-&gt;Next; &#125; printf("%d\n", L-&gt;Data); &#125;&#125;int main() &#123; List L = MakeEmpty(); PtrToLNode t = CreateLNode(11); L-&gt;Next = t; Print(L); int ins_flag = Insert_1(L, 22, Find(L, 11)); printf("ins_flag = %d\n", ins_flag); Print(L); Insert_1(L, 33, Find(L, 22)); Insert_1(L, 44, Find(L, 33)); Print(L); int del_flag = Delete(L, Find(L, 33)); printf("del_flag = %d\n", del_flag); Print(L); printf("/*--------------------*/\n"); Insert_2(L, 55, 3); Print(L); Insert_2(L, 8, 2); Print(L); printf("%d\n", Insert_2(L, 9, 10)); Print(L); return 0;&#125; Generalized List关于广义表的含义，何老师的 PPT 里面说的比较清楚了，即: 广义表是线性表的推广 对于广义表而言，n 个元素都是基本的单元素 广义表中，这些元素不仅可以是单元素也可以是另一个广义表 其实说白了，广义表是个大集合，囊括了线性表这个小集合。 关于多重链表，其实是广义表的一种应用，也即线性表中的每一个“结点”，又是一个线性表。多重链表多应用与于树（线索二叉树等）和图（十字链表等）这类复杂的数据结构，当然，树和图也可以不采用多重链表来存储。 Stack堆栈（Stack），具有一定操作约束的线性表，只在一端（栈顶，Top）做插入、删除操作。插入数据：入栈（Push）删除数据：出栈（Pop）后入先出：Last In First Out（LIFO） 堆栈的抽象数据类型描述类型名称：堆栈（Stack）数据对象集：一个有0个或多个元素的有穷线性表操作集：长度为MaxSize的堆栈S ∈ Stack，堆栈元素item ∈ ElementType，主要操作： Stack CreateStack(int MaxSize)，生成空堆栈，其最大长度为MaxSize int IsFull(Stack S, int MaxSize)，判断堆栈S是否已满 void Push(Stack S, ElementType item)，将元素item压入堆栈 int IsEmpty(Stack S)，判断堆栈S是否为空 ElementType Pop(Stack S)，删除并返回栈顶元素 栈的顺序存储实现栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，C 语言版本的定义如下：12345678910#define MAXSIZE 10 /*store the maximum number of data*/#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;typedef struct SNode *Stack; 初始化（建立空栈）1234567Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125; 判断栈满123bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125; 判断栈空123bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125; 入栈由于顺序栈是由数组存储，而数组有大小，当数组没有空间的时候就无法进行入栈操作，所以在入栈操作之前就必须要判断栈是否满了。123456789bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125; 出栈与入栈操作类似，当栈为空时，显然无法进行出栈操作。12345678ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125; 求栈内元素个数123int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct SNode&#123; ElementType *Data; Position Top; int MaxSize;&#125;;typedef struct SNode *Stack;Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125;bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125;bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125;bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125;ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125;int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125;int main() &#123; Stack S = Createstack(5); Pop(S); printf("S.size = %d\n", Getsize(S)); int push_flag = Push(S, 11); Push(S, 22); Push(S, 33); int x = Pop(S); printf("push_flag = %d, x = %d\n", push_flag, x); printf("S.size = %d\n", Getsize(S)); Push(S, 33); Push(S, 44); Push(S, 55); Push(S, 66); printf("S.size = %d\n", Getsize(S)); return 0;&#125; 栈的链式存储结构实现栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行，注意栈顶指针 top 只能在链表的表头。1234567typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack; 初始化（建立空栈）123456Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; 入栈由于链栈是通过申请内存构造结点的，所以理论上不存在栈满的情况（内存满了就不能分配空间了）。1234567bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125; 判断栈空尽管链栈不用判断栈满，但是在进行出栈操作时需要判断栈是否为空。123bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125; 出栈1234567891011121314ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125; 求栈内元素个数12345678int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack;Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125;bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125;bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125;ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125;int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125;int main() &#123; Stack S = Createstack(); Pop(S); printf("S.size = %d\n", Getsize(S)); Push(S, 11); Push(S, 22); Push(S, 33); printf("S.top = %d\n", Pop(S)); Push(S, 33); Push(S, 44); Push(S, 55); printf("S.size = %d\n", Getsize(S)); return 0;&#125; Queue队列也是具有一定操作约束的线性表（与堆栈类似），只能在一端插入，而在另一端删除。数据插入：入队列（AddQ）数据删除：出队列（DeleteQ）先来先服务，先进先出，First In First Out，FIFO 队列的抽象数据类型描述类型名称：队列（Queue）数据对象集：一个有0个或多个元素的有穷线性表操作集：长度为MaxSize的队列Q ∈ Queue，队列元素item ∈ ElementType，主要操作： Queue CreatQueue(int MaxSize)，生成长度为MaxSize的空队列 int IsFullQ(Queue Q, int MaxSize)，判断队列Q是否已满 void AddQ(Queue Q, ElementType item)，将数据元素item插入队列Q中 int IsEmptyQ(Queue Q)，判断队列Q是否为空 ElementType DeleteQ(Queue Q)，将对头数据元素从队列中删除并返回 队列的顺序存储实现队列的顺序存储实现与顺序栈的实现方式相同，还是需要借助一个数组来存储元素。但与栈不同的是队列需要有队头（front）指针和队尾（rear）指针，定义如下：12345678typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; 初始化（建立空队列）1234567Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125; 判断队空123bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125; 判断队满123bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125; 入队为了更好的利用数组，采取循环队列的设计方法，借助取余运算刚好可以满足要求，出队时同理。12345678910bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125; 出队123456789ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125; 求队列中元素个数123int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125;bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125;ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125;int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125;void print(Queue q) &#123; int i; for(i = 0; i &lt; 5; i++) &#123; printf("%d ", q-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); printf("%d\n", Getsize(q)); Addq(q, 22); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 33); Addq(q, 44); Addq(q, 55); print(q); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); Addq(q, 66); x = Deleteq(q); x = Deleteq(q); Addq(q, 66); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); return 0;&#125; 队列的链式存储实现队列的链式存储实现要比链栈的实现稍微复杂一点，需要有一个单独的队列结构（包含队头指针和队尾指针）来指向队列，定义如下：123456789101112typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; 初始化（建立空队列）123456Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125; 求队列中元素个数123456789int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125; 判断队空123bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125; 判断队满由于上述定义设置的有MaxSize，默认链队列是有最大空间的，所以需要判断队列是否为满。1234bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125; 入队12345678910111213141516bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125; 出队123456789101112131415ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125;ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125;int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125;bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); Addq(q, 11); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); Addq(q, 22); Addq(q, 33); Addq(q, 44); Addq(q, 55); Addq(q, 66); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); return 0;&#125; Homework02-1 两个有序链表序列的合并此题考察链表的合并操作，注意链表有序且给定链表带头结点，要求合并后链表为非递减序列，所以需要对每一个结点值进行比较，代码如下（其中函数体为需要提交的代码）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read();void Print( List L );List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;List Read() &#123; int i, n, temp; scanf("%d", &amp;n); List L, p; L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = temp; t-&gt;Next = NULL; p-&gt;Next = t; p = t; &#125; return L;&#125;void Print( List L ) &#123; PtrToNode p = L-&gt;Next; if(!p) &#123; printf("NULL\n"); return; &#125; while(p-&gt;Next != NULL) &#123; printf("%d ", p-&gt;Data); p = p-&gt;Next; &#125; printf("%d\n", p-&gt;Data);&#125;List Merge( List L1, List L2 ) &#123; PtrToNode p, p1 = L1-&gt;Next, p2 = L2-&gt;Next; L1-&gt;Next = L2-&gt;Next = NULL; List L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;Data &lt; p2-&gt;Data) &#123; p-&gt;Next = p1; p = p1; p1 = p1-&gt;Next; &#125; else &#123; p-&gt;Next = p2; p = p2; p2 = p2-&gt;Next; &#125; &#125; if(p1) p-&gt;Next = p1; if(p2) p-&gt;Next = p2; return L;&#125; 02-2 一元多项式的乘法与加法运算这道题的何老师已经讲过了，按照何老师给的思路，补全所有代码即可（最底下提供了几组测试用例）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct PolyNode* Polynomial;typedef struct PolyNode* PtrToPolyNode;struct PolyNode &#123; int coef, expon; struct PolyNode *link;&#125;;PtrToPolyNode CreateNode(int c, int e) &#123; PtrToPolyNode t = (PtrToPolyNode)malloc(sizeof(struct PolyNode)); t-&gt;coef = c, t-&gt;expon = e; t-&gt;link = NULL; return t;&#125;Polynomial ReadPoly() &#123; int n, c, e; scanf("%d", &amp;n); Polynomial P, p; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; if(n == 0) &#123; PtrToPolyNode t = CreateNode(0, 0); p-&gt;link = t; &#125; else &#123; while(n--) &#123; scanf("%d %d", &amp;c, &amp;e); PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; &#125; return P;&#125;void Print(Polynomial P) &#123; if(P-&gt;link == NULL) &#123; printf("0 0\n"); return; &#125; else &#123; P = P-&gt;link; while(P-&gt;link != NULL) &#123; printf("%d %d ", P-&gt;coef, P-&gt;expon); P = P-&gt;link; &#125; printf("%d %d\n", P-&gt;coef, P-&gt;expon); &#125;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2 = P2-&gt;link; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;expon == p2-&gt;expon) &#123; int e = p1-&gt;expon, c = p1-&gt;coef + p2-&gt;coef; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else if(p1-&gt;expon &gt; p2-&gt;expon) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; else &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; &#125; while(p1 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; while(p2 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; return P;&#125;Polynomial Multi(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; while(p1) &#123; p2 = P2-&gt;link; while(p2) &#123; int c = p1-&gt;coef * p2-&gt;coef; int e = p1-&gt;expon + p2-&gt;expon; p = P; while(p-&gt;link != NULL &amp;&amp; p-&gt;link-&gt;expon &gt; e) p = p-&gt;link; if(p-&gt;link != NULL) &#123; if(p-&gt;link-&gt;expon == e) &#123; int ctmp = p-&gt;link-&gt;coef + c; if(ctmp == 0) &#123; PtrToPolyNode tmp = p-&gt;link; p-&gt;link = tmp-&gt;link; free(tmp); &#125; else &#123; p-&gt;link-&gt;coef = ctmp; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; p2 = p2-&gt;link; &#125; p1 = p1-&gt;link; &#125; return P;&#125;int main() &#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PS = Add(P1, P2); PP = Multi(P1, P2); Print(PP); Print(PS); return 0;&#125;/*some samples:in:1 -1 11 1 1out:-1 20 0in:2 -1 1 2 01 1 1out:-1 2 2 12 0in:2 1 1 1 02 1 1 -1 0out:1 2 -1 02 1in:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1out:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0in:1 0 03 1 3 1 2 1 1out:0 01 3 1 2 1 1in:2 2 0 0 03 3 2 2 1 1 0out:6 2 4 1 2 03 2 2 1 3 0in:01 10 0out:0 010 0*/ 02-3 Reversing Linked List此题题意比较直接，但是测试点比较多，要考虑全面。推荐使用静态链表的方法解题，这样耗时较少。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#define maxn 100005int addr[maxn], address[maxn], data[maxn], next[maxn];void reverse(int A[], int left, int right) &#123; for(; left &lt; right; left++, right--) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125;&#125;int main() &#123; int src, n, k, m; scanf("%d %d %d", &amp;src, &amp;n, &amp;k); m = n; int tmp_add, tmp_data, tmp_next; while(m--) &#123; scanf("%d %d %d", &amp;tmp_add, &amp;tmp_data, &amp;tmp_next); address[tmp_add] = tmp_add; next[tmp_add] = tmp_next; data[tmp_add] = tmp_data; &#125; int len = 1, i, j, tmp = src; addr[0] = src; while(src != -1) &#123; addr[len++] = next[src]; src = next[src]; &#125; for(i = 0, j = k; j &lt;= len - 1; i = j, j += k) &#123; reverse(addr, i, j - 1); &#125; for(i = 0; i &lt; len - 2; i++) &#123; src = addr[i]; printf("%05d %d %05d\n", src, data[src], addr[i + 1]); &#125; printf("%05d %d -1\n", address[addr[i]], data[addr[i]]); return 0;&#125;/*some samples:in:00100 6 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:68237 6 9999999999 5 0000000000 4 3321833218 3 1230912309 2 0010000100 1 -1in:00100 6 300000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:33218 3 1230912309 2 0010000100 1 6823768237 6 9999999999 5 0000000000 4 -1in:00100 6 100000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:00100 1 1230912309 2 3321833218 3 0000000000 4 9999999999 5 6823768237 6 -1in:00100 5 300000 4 9999900100 1 1230933218 3 0000099999 5 -112309 2 33218out:33218 3 1230912309 2 0010000100 1 0000000000 4 9999999999 5 -1in:00100 9 200000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 3321833333 7 2222244444 8 1111103333 9 02222out:12309 2 0010000100 1 0000000000 4 3321833218 3 6823768237 6 9999999999 5 -1in:00100 3 200100 1 -111111 2 2222233333 3 44444out:00100 1 -1*/ 02-4 Pop Sequence本题考察栈的相关知识，本质上是模拟栈的相关操作，推荐使用 C++ 自带的 STL 模板里面的 Stack ，可以直接拿来使用，但需要先了解一下用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];int main() &#123; int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; bool flag = true; while(k--) &#123; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; bool flag = true; int i = 1, j = 1; while(j &lt;= n + 1) &#123; if(st.size() &gt; m) &#123; flag = false; break; &#125; if(!st.empty()) &#123; if(st.top() == seq[i]) &#123; st.pop(); i++; &#125; else st.push(j++); &#125; else st.push(j++); &#125; if(flag &amp;&amp; st.size() == 1) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; /*some samples:in:5 7 15 6 4 3 7 2 1out:YESsome sample:in:2 4 41 2 3 42 1 3 41 2 4 33 1 2 4out:YESYESYESNO*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_01-基本概念]]></title>
    <url>%2F2020%2F02%2F11%2FZJU-DS-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此篇系列博文是博主自己在 MOOC 上自学浙江大学数据结构课程时的笔记，每一讲都有对应的笔记，对应一篇博文。虽然之前上课时就做好了笔记，但对很多知识点的理解比较浅显，现在回过头来整理，希望会有所启发。另外，自学之路难免会有错误，欢迎看到文章的同学不吝赐教。另外，题解代码在 Github 上的地址：201909_MOOC_DS_ChenYue What is Data Structure何谓数据结构？按照姥姥的讲解，没有特定的数据结构的定义。不过，通过课上姥姥举的一些例子，可以得出：数据结构就是数据对象在计算机中的组织方式。具体而言，数据对象包含： 逻辑结构：第一次学数据结构的人可能会对这个概念有点懵，如果已经掌握了一门程序设计语言，并且具备了一定的水平的话，理解起来还是比较容易的。这里举个例子，比如律诗的逻辑结构就是：首联、颔联、颈联和尾联。 物理存储结构：可以暂时理解为硬盘之类的存储器的结构。 当然，也可以使用抽象数据类型（Abstract Data Type）来描述数据结构，包括： 数据对象集：简而言之就是由数据组成的集合。 数据集合相关联的操作集：处理这些数据对象的操作方法。 其中，抽象的含义是：描述数据类型的方法不依赖于具体实现，与存放数据的机器无关，与数据存储的物理结构无关，与实现操作的算法和编程语言均无关。 抽象数据类型其实就是面向对象程序设计语言中的“类（Class）”的含义。要注意，数据对象必定与一系列加在上面的操作是相关联。也就是说，单独存在的数据对象或操作集是无法被称之为数据结构的。而在数据结构中，完成相关操作集所用的方法就是算法（Algorithm）。 其实，数据结构本身就是一个逻辑的概念。 What is Algorithm算法包含以下几个要素： 一个有限指令集 接受一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须：有充分明确的目标，不可以有歧义，并且计算机能处理的范围之内，另外，描述应不依赖于任何一种计算机语言以及具体的实现手段。 Measure for Algorithm时间复杂度（$S(n)$）：根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们有生之年都等不到运行结果。 空间复杂度（$T(n)$）：根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致内存超限，造成程序的非正常中断。 在分析一般算法的效率时，我们经常关注下面两种复杂度： 最坏情况复杂度（worst） 平均复杂度（average） Complexity Expression复杂度的渐进表示法：$ T(n) = O(f(n)) $表示存在常数$C&gt;0$，$n_0$使得当$n ≥ n_0$时，有$T(n) ≤ C * f(n)$； $ T(n) = Ω(g(n)) $表示存在常数$C&gt;0$，$n_0$使得当$n ≥ n_0$时，有$T(n) ≥ C * g(n)$； $ T(n) = θ(h(n)) $表示同时有$ T(n)=O(h(n)) $和$ T(n)=Ω(h(n)) $； 过大的上界和下界对于分析算法的“好”和“坏”，没有意义，所以一般取值是我们能找到的、最大和最小的那个上界和下界。 当问题的规模为$n$时，不同量级的时间复杂度的关系为：$log n &lt; n &lt; n*log n &lt; n^2 &lt; n^3 &lt; 2^n &lt; n!$ Complexity Analysis对算法进行复杂度的分析是衡量一个算法“好”与“坏”的基本方法，关于这方面有以下一些窍门： 若两段算法分别有复杂度$T_1(n) = O(f_1(n))$和$T_2(n) = O(f_2(n))$，则： $T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))$ $T_1(n) \times T_2(n) = O(f_1(n) \times f_2(n))$ 若$T(n)$是关于$n$的$k$阶多项式，那么$T(n) = θ(n^k)$ 一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度 if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大 平时在做到一些题目的时候会遇到要分析时间复杂度的习题，可以从上述的角度入手。不过一般而言，第四条用的要多一些。 Demo Codeexample 2 题目：写程序实现一个函数 PrintN ，使得传入一个正整数为 N 的参数后，能顺序打印从 1 到 N 的全部正整数。 学过一门程序设计语言的同学，应该不会觉得有困难，因为直接利用循环从 1 数到 N 即可完成这个需求。但是，可能会有部分同学会对递归不熟悉，好在老师也给出了代码。123456789101112131415161718192021222324#include &lt;stdio.h&gt;void PrintN(int n) &#123; // method 1: use loop for(int i = 1; i &lt;= n; i++) &#123; printf("%d\n", i); &#125;&#125;/*void PrintN(int n) &#123; // method 2: use recursion if(n) &#123; PrintN(n - 1); printf("%d\n", n); &#125;&#125;*/int main() &#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125; example 3 题目：写程序计算给定多项式在给定点 x 处的值。 处理这个题有两种方法，所以可以顺便比较一下两种方法运行的时间长短。由于计算机的运行速度较快，仅运行一次无法看出差异，所以需要多执行几次。计算时间需要借助 C 语言的库函数，而这些库函数的声明在time.h这个头文件中。由于姥姥又给出了代码，又可以偷懒了~下面给出代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7double f1(int n, double a[], double x) &#123; int i; double p = a[0]; for(i = 1; i &lt;= n; i++) &#123; p += (a[i] * pow(x, i)); &#125; return p;&#125;double f2(int n, double a[], double x) &#123; int i; double p = a[n]; for(i = n; i &gt; 0; i--) &#123; p = a[i - 1] + x * p; &#125; return p;&#125; int main() &#123; int i; double a[MAXN]; for(i = 0; i &lt; MAXN; i++) a[i] = (double)i; start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f1(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks1 = %f\n", (double)(stop - start)); printf("duration1 = %6.2e\n", duration); start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f2(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks2 = %f\n", (double)(stop - start)); printf("duration2 = %6.2e\n", duration); return 0;&#125;/*result:ticks1 = 1969.000000duration1 = 1.97e+000ticks2 = 284.000000duration2 = 2.84e-001*/ 从上面代码的结果可以看出，采用不同计算方法的代码运行时间竟然相差了几乎 7 倍！ Maximum Subsequence Sum 题目：最大子列和问题 最大子列和的问题是很经典的动态规划（DP, dynamic programming）问题，这是博主后来查阅资料了解到的。既然姥姥将这道题当作例题放在第一讲，应该也有她的道理，何况她还介绍了这么多不用动规思路的解题方法呢。从题目出发，我们可以大致得到这道题的答题代码框架：123456789101112131415#include &lt;stdio.h&gt;int MaxSubseqsum(int a[], int k) &#123;&#125;int main(int argc, char const *argv[]) &#123; int i, K; scanf("%d", &amp;K); int arr[K]; for(i=0; i&lt;K; i++) &#123; scanf("%d", &amp;arr[i]); &#125; printf("%d\n", MaxSubseqsum(arr, K)); return 0;&#125; 下面来看看各种不同的解法： directly calculating easy version直接暴力求解的思路较为直观，利用三重循环，将每一个数构成的序列全部枚举一遍，如果符合条件且满足最大，就更新结果。循环结束后，得到最后结果。1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j, k; for(i=0; i&lt;N; i++) &#123; for(j=i; j&lt;N; j++) &#123; ThisSum = 0; for(k=i; k&lt;=j; k++) &#123; ThisSum += a[k]; &#125; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; directly calculating advanced version继续按照暴力求解的思路进行计算，可以发现：对于相同的 i ，不同的 j ，只要在 j - 1 次循环的基础上累加 1 项即可，而不需要再从 1 一直加到 i。这样的话，就可以节省一层for循环的运行时间了，代码如下：123456789101112int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j; for(i=0; i&lt;N; i++) &#123; ThisSum = 0; for(j=i; j&lt;N; j++) &#123; ThisSum += a[j]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; divide and conquer这道题还可以采用分治法来解决，不过不是那么容易理解，但根本在于要把握此法中边界的概念，并且要注意最终结果是 3 种情况下的最大值。123456789101112131415161718192021222324252627282930313233343536373839404142int MaxSubseqsum(int a[], int N) &#123; /*use same interface*/ return DivideAndConquer(a, 0, N-1);&#125;int DivideAndConquer(int a[], int left, int right) &#123; int MaxLeftSum, MaxRightSum; /*save the result of left and right subsequence */ int MaxLeftBorderSum, MaxRightBorderSum; /*save the result of each subsequence*/ int LeftBorderSum, RightBorderSum; int center, i; if(left == right) &#123; if(a[left] &gt; 0) return a[left]; else return 0; &#125; /*divide*/ center = (left + right) / 2; /*use recursion to get the result*/ MaxLeftSum = DivideAndConquer(a, left, center); MaxRightSum = DivideAndConquer(a, center+1, right); /*get the result of left subsequence*/ MaxLeftBorderSum = 0, LeftBorderSum = 0; for(i=center; i&gt;=left; i--) &#123; LeftBorderSum += a[i]; if(LeftBorderSum &gt; MaxLeftBorderSum) MaxLeftBorderSum = LeftBorderSum; &#125; /*get the result of right subsequence*/ MaxRightBorderSum = 0, RightBorderSum = 0; for(i=center+1; i&lt;=right; i++) &#123; RightBorderSum += a[i]; if(RightBorderSum &gt; MaxRightBorderSum) MaxRightBorderSum = RightBorderSum; &#125; return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);&#125;int Max3(int a, int b, int c)&#123; return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;&#125; online processing比起上面的几种方法，在线处理就简单粗暴了许多，一趟循环下来就完事了，但不是那么好理解，最好根据测试样例手动模拟一遍。此法之所以快的原因在于，一旦出现了序列出现了负数，负数并不能使结果变大，反而使结果变小了。那么这种情况就不是符合条件的结果了，直接舍弃，这样就不用做多余的计算了，这和“剪枝”有点相似。而所谓“在线”，意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解。1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for(i=0; i&lt;N; i++) &#123; ThisSum += a[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; &#125; &#125; return MaxSum;&#125; Homework此课程的作业题目全部都放在 PTA 的习题集内，按照姥姥给的邀请码就可以进入题目集做题啦。 01-1 最大子列和问题这道题被姥姥当成了应用实例进行讲解，可以直接使用姥姥给的代码，稍加修改一下就可以直接 AC 了。不过，根据这道题给定的一些条件，需要对一些数据做一些处理。这里，我们偷下懒，直接使用在线处理思路的代码进行解题，代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int f(int array[], int N) &#123; int ThisSum = 0, MaxSum = 0; int i; for(i = 0; i &lt; N; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; else if(ThisSum &lt; 0) ThisSum = 0; &#125; return MaxSum;&#125;int main() &#123; int k, i; scanf("%d", &amp;k); for(i = 0; i &lt; k ; i++) &#123; scanf("%d", &amp;array[i]); &#125; printf("%d", f(array, k)); return 0;&#125;/*samples:in:6-2 11 -4 13 -5 -2 out:20*/ 01-2 Maximum Subsequence Sum这道题是上面题目的升级版，要求给出最佳结果的左端点和右端点的下标。需要注意的是这道题目的输出要求比较多，要当心一点。此题还是利用在线处理的思路进行求解，代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int main() &#123; int k, i; scanf("%d", &amp;k); bool flag = false; for(i = 1; i &lt;= k; i++) &#123; scanf("%d", array + i); if(array[i] &gt;= 0) flag = true; &#125; if(!flag) &#123; printf("0 %d %d\n", array[1], array[k]); // all the numbers are negative &#125; else &#123; int left = 1, right = k, temp_left = 1; int ThisSum = 0, MaxSum = -1; // MaxSum need to be initialized as a negative number for(i = 1; i &lt;= k; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) &#123; // update max value, the left index and right index MaxSum = ThisSum; left = temp_left; right = i; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; printf("%d %d %d\n", MaxSum, array[left], array[right]); &#125; return 0;&#125; 01-3 二分查找这道题目介绍的算法算是十分基础入门的算法了，对于学过一门程序设计语言的同学来说，要解决应该不会有什么困难。不过，可能会有部分同学会对 PTA 上此类题目的做题方法有所疑惑。其实，这种函数题就是让你写个函数，然后系统会自动的将你提交的这段函数代码嵌入到题目的代码之中运行，继而判断结果是否正确。要注意这类题目对函数接口和一些关键词的定义，不要搞错了。笔者做这类题目时，都是直接把所有代码全部拷贝下来，然后把缺失的代码全部按照题意写出来，然后再单独的提交题目要求的那个函数代码，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */&#125;;List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */Position BinarySearch( List L, ElementType X );int main() &#123; List L; ElementType X; Position P; L = ReadInput(); scanf("%d", &amp;X); P = BinarySearch( L, X ); printf("%d\n", P); return 0;&#125;List ReadInput() &#123; List L = (List)malloc(sizeof(struct LNode)); int n, t, i; scanf("%d", &amp;n); for(i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;L-&gt;Data[i]); &#125; L-&gt;Last = i; return L;&#125;Position BinarySearch( List L, ElementType X ) &#123; int left = 1, right = L-&gt;Last, mid, flag = 0; while(left &lt;= right) &#123; mid = (left + right) / 2; if(L-&gt;Data[mid] == X) &#123; flag = 1; break; &#125; else if(L-&gt;Data[mid] &lt; X) left = mid + 1; else right = mid - 1; &#125; if(flag) return mid; else return NotFound;&#125;/*some samples:in:512 31 55 89 10131out:2in:326 78 23331out:0in:426 78 88 23388out:3in:426 78 88 23378out:2*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice]]></title>
    <url>%2F2019%2F06%2F30%2FPAT-Advanced-Level-Practice%2F</url>
    <content type="text"><![CDATA[Intro从入门到入土系列之 PAT 甲级 题库快乐🤣启动。长期更新ing~ 1001 A+B FormatAnalysis题目意思比较简单，给俩数，相加算结果，然后输出的时候每三位一个,隔开，并且负数得在开头输出-。 按照题目给出的数字范围：$-10^6 \le a,\ b \le 10^6$，所以可以直接使用int型变量进行相加，然后在输出之前在做数位拆分即可。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int MAXN = 10;int main(int argc, char const *argv[]) &#123; int a, b, sum; scanf("%d %d", &amp;a, &amp;b); sum = a + b; if(sum &lt; 0) &#123; putchar('-'); sum = -sum; &#125; int len = 0, num[MAXN]; if(sum == 0) &#123; num[len++] = sum; &#125; while(sum) &#123; num[len++] = sum % 10; sum /= 10; &#125; for(int i = len - 1; i &gt;= 0; i--) &#123; printf("%d", num[i]); if(i &gt; 0 &amp;&amp; i % 3 == 0) &#123; putchar(','); &#125; &#125; return 0;&#125; 贴个 C++ 用字符串处理的思路：1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; '-'; c = -c; &#125; string str = to_string(c), tmp; int cnt = 0; for(int i = str.length() - 1; i &gt;= 0; i--) &#123; tmp.push_back(str[i]); cnt++; if(cnt == 3) &#123; if(i != 0) tmp += ','; cnt = 0; &#125; &#125; reverse(tmp.begin(), tmp.end()); cout &lt;&lt; tmp; return 0;&#125; 不过换个思路，这个题还能更简单：12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; '-'; c = -c; &#125; if(c &gt;= 1000000) printf("%d,%03d,%03d", c / 1000000, c % 1000000 / 1000, c % 1000); else if(c &gt;= 1000) printf("%d,%03d", c / 1000, c % 1000); else printf("%d", c); return 0;&#125; 1002 A+B for PolynomialsAnalysis此题是 ZJU 数据结构课程里面的例题了，而且还只是一半的内容，算法思想不难（毕竟只是初中数学的水平，我丢😅），先按照链表来做吧，后面在看看能不能尝试其他方法。一开始偷懒没有将结果构造成一个新的链表，发现测试点5无法通过，改了一会，还是不选择偷懒了... Codemethod 1用链表做比较繁琐，不过可以锻炼一下链表的基本操作。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*test point 5, like this:2 1 2.4 0 3.23 2 2.4 1 2.4 0 -3.2*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct Polynode* Polynomial;struct Polynode &#123; int expo; double coef; Polynomial link;&#125;;Polynomial ReadPoly();Polynomial Add(Polynomial P1, Polynomial P2);void Print(Polynomial PP);int GetNum(Polynomial P);void Attach(double c, int e, Polynomial *pRear);int main(int argc, char const *argv[]) &#123; Polynomial P1 = ReadPoly(); Polynomial P2 = ReadPoly(); Polynomial PP = Add(P1, P2); int number = GetNum(PP); if(number) &#123; printf("%d ", number); Print(PP); &#125; else &#123; printf("%d\n", number); &#125; return 0;&#125;Polynomial ReadPoly() &#123; int K; scanf("%d", &amp;K); Polynomial P, rear; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;link = NULL; rear = P; int e; double c; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;rear); &#125; return P;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial p1 = P1-&gt;link, p2 = P2-&gt;link, p, rear; p = (Polynomial)malloc(sizeof(struct Polynode)); p-&gt;link = NULL; rear = p; double sum; while(p1 &amp;&amp; p2) &#123; int temp = p1-&gt;expo - p2-&gt;expo; if(temp &gt; 0) &#123; Attach(p1-&gt;coef, p1-&gt;expo, &amp;rear); p1 = p1-&gt;link; &#125; else if(temp == 0) &#123; sum = p1-&gt;coef + p2-&gt;coef; if(sum) &#123; Attach(sum, p1-&gt;expo, &amp;rear); &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else &#123; Attach(p2-&gt;coef, p2-&gt;expo, &amp;rear); p2 = p2-&gt;link; &#125; &#125; if(p1) &#123; rear-&gt;link = p1; &#125; if(p2) &#123; rear-&gt;link = p2; &#125; return p;&#125;void Print(Polynomial PP) &#123; Polynomial P = PP-&gt;link; while(P) &#123; if(P-&gt;link == NULL) &#123; printf("%d %.1lf\n", P-&gt;expo, P-&gt;coef); &#125; else &#123; printf("%d %.1lf ", P-&gt;expo, P-&gt;coef); &#125; P = P-&gt;link; &#125;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P-&gt;link; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;coef = c; P-&gt;expo = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125; 用 C++ 的特性，简化一下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;typedef struct Node* List;typedef struct Node* PtrtoNode;struct Node &#123; int exp; double coe; PtrtoNode next; Node() &#123; next = nullptr; &#125; Node(int _exp, double _coe) &#123; exp = _exp; coe = _coe; next = nullptr; &#125;&#125;;List createlist(int node_num) &#123; int exp; double coe; List head = new Node; List L = head; while(node_num--) &#123; scanf("%d %lf", &amp;exp, &amp;coe); head-&gt;next = new Node(exp, coe); head = head-&gt;next; &#125; head = L; L = L-&gt;next; delete(head); return L;&#125;int main() &#123; int k, exp; double coe; scanf("%d", &amp;k); List L, L1, L2; L1 = createlist(k); scanf("%d", &amp;k); L2 = createlist(k); L = new Node; List tmp = L; while(L1 &amp;&amp; L2) &#123; if(L1-&gt;exp == L2-&gt;exp) &#123; if(L1-&gt;coe + L2-&gt;coe != 0) &#123; L-&gt;next = new Node(L1-&gt;exp, L1-&gt;coe + L2-&gt;coe); L = L-&gt;next; &#125; L1 = L1-&gt;next; L2 = L2-&gt;next; &#125; else if(L1-&gt;exp &gt; L2-&gt;exp) &#123; L-&gt;next = L1; L1 = L1-&gt;next; L = L-&gt;next; &#125; else &#123; L-&gt;next = L2; L2 = L2-&gt;next; L = L-&gt;next; &#125; &#125; if(L1) L-&gt;next = L1; if(L2) L-&gt;next = L2; L = tmp-&gt;next; delete(tmp); tmp = L; int cnt = 0; while(tmp) &#123; if(tmp-&gt;coe != 0) cnt++; tmp = tmp-&gt;next; &#125; printf("%d", cnt); if(cnt) &#123; while(L) &#123; printf(" %d %.1lf", L-&gt;exp, L-&gt;coe); L = L-&gt;next; &#125; &#125; return 0;&#125; method 2实际上，这个题拿数组做，简单了不止一点半点😂。123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;void readp(int nums, double *poly) &#123; int exp; double coe; for(int i = 0; i &lt; nums; i++) &#123; scanf("%d %lf", &amp;exp, &amp;coe); poly[exp] = coe; &#125;&#125;int main() &#123; double L1[1005] = &#123;0&#125;, L2[1005] = &#123;0&#125;, L[1005] = &#123;0&#125;; int k1, k2, exp; double coe; scanf("%d", &amp;k1); readp(k1, L1); scanf("%d", &amp;k2); readp(k2, L2); int cnt = 0; for(int i = 0; i &lt; 1005; i++) &#123; L[i] = L1[i] + L2[i]; if(L[i] != 0) cnt++; &#125; printf("%d", cnt); if(cnt) &#123; for(int i = 1000; i &gt;= 0; i--) &#123; if(L[i] != 0) printf(" %d %.1lf", i, L[i]); &#125; &#125; return 0;&#125; 1003 EmergencyAnalysis题目大意是给定几个城市之间的地图，城市之间的路有相应的权值，然后给定起始城市和终点城市，问从起始城市到达终点城市的路径有几条，并且这些路径上点权之和最大是多少。 由于题目的实际意义，构造好的图一定是一个无向图，借助 Dijkstra 算法或 Bellman-Ford 算法可以解决这两个问题。 路径条数和点权和的最大值，分别使用一个数组来统计即可。 CodeDijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 510;const int INF = 1000000000;int n, m, st, ed, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;;bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, INF); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = INF; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != INF) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; //update the distance of each node w[v] = w[u] + weight[v]; // update the 'hands' num[v] = num[u]; // update the path for a new reachable node &#125; else if(d[u] + G[u][v] == d[v]) &#123; /*only one path can count the 'hands', so the w[v] will be covered by the sum of last node and its own 'hands' */ if(w[u] + weight[v] &gt; w[v]) &#123; w[v] = w[u] + weight[v]; &#125; //but the number of path is not only num[v] += num[u]; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v; fill(G[0], G[0] + maxv * maxv, INF); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v]; G[v][u] = G[u][v]; &#125; dijkstra(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; Bellman-Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct node &#123; int v, dis; node(int _v, int _dis) : v(_v), dis(_dis) &#123;&#125; // constructor&#125;;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, weight[maxv];int num[maxv] = &#123;0&#125;, w[maxv] = &#123;0&#125;, d[maxv];vector&lt;node&gt; Adj[maxv];set&lt;int&gt; pre[maxv];bool bellmanford(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; num[s] = 1; w[s] = weight[s]; for(int i = 0; i &lt; n - 1; i++) &#123; for(int u = 0; u &lt; n; u++) &#123; for(int j = 0; j &lt; Adj[u].size(); j++) &#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) &#123; // more optimal solution d[v] = d[u] + dis; w[v] = w[u] + weight[v]; num[v] = num[u]; pre[v].clear(); // attention: pre[v] must be clear firstly pre[v].insert(u); // save the precursor &#125; else if(d[u] + dis == d[v]) &#123; if(w[v] &lt; w[u] + weight[v]) &#123; // update the maximum w[v] = w[u] + weight[v]; &#125; pre[v].insert(u); // other shortest path also need save num[v] = 0; // the number of shortest path has been changed set&lt;int&gt;::iterator it; for(it = pre[v].begin(); it != pre[v].end(); it++) &#123; num[v] += num[*it]; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; Adj[u].push_back(node(v, dis)); Adj[v].push_back(node(u, dis)); &#125; bellmanford(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; 1004 Counting LeavesAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, child, seq, maxDepth = -1;int leaves[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(Node[front].depth &gt; maxDepth) &#123; maxDepth = Node[front].depth; &#125; if(Node[front].child.size() != 0) &#123; for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; q.push(child); &#125; &#125; else &#123; leaves[Node[front].depth]++; &#125; &#125; &#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); for(int i = 1; i &lt;= maxDepth; i++) &#123; cout &lt;&lt; leaves[i]; if(i &lt; maxDepth) cout &lt;&lt; ' '; &#125; return 0;&#125; 1005 Spell It RightAnalysis题目意思很简单，给一个数字，计算出这个数字每一位上的数字之和，然后用英文的方式分别输出这个和的每一位数字（好吧，有点绕😅）。 与乙级题库的1002很类似，考察数位拆分吧，比较简单。 Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int MAXN = 100 + 5;char NumberTable[11][10] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",&#125;;int main(int argc, char const *argv[]) &#123; char num[MAXN]; int sum = 0; scanf("%s", num); char *p = num; while(*p != '\0') &#123; sum += *p++ - '0'; &#125; int temp = sum, mask = 1; while(temp &gt; 9) &#123; temp /= 10; mask *= 10; &#125; while(mask) &#123; printf("%s", NumberTable[sum / mask]); if(mask &gt; 9) &#123; putchar(' '); &#125; sum %= mask; mask /= 10; &#125; putchar('\n'); return 0;&#125; 贴个 C++ 版：1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, string&gt; num2english = &#123;&#123;0, "zero"&#125;, &#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;, &#123;4, "four"&#125;, &#123;5, "five"&#125;, &#123;6, "six"&#125;, &#123;7, "seven"&#125;, &#123;8, "eight"&#125;, &#123;9, "nine"&#125;&#125;;int main() &#123; string str; cin &gt;&gt; str; int sum = 0; for(int i = 0; i &lt; str.length(); i++) &#123; sum += str[i] - '0'; &#125; str = to_string(sum); for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; num2english[str[i] - '0']; if(i != str.length() - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 再补个用 dfs 输出的办法：123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, string&gt; num2english = &#123;&#123;0, "zero"&#125;, &#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;, &#123;4, "four"&#125;, &#123;5, "five"&#125;, &#123;6, "six"&#125;, &#123;7, "seven"&#125;, &#123;8, "eight"&#125;, &#123;9, "nine"&#125;&#125;;void dfs(int n) &#123; if(n / 10 == 0) &#123; cout &lt;&lt; num2english[n % 10]; return; &#125; dfs(n / 10); cout &lt;&lt; ' ' &lt;&lt; num2english[n % 10];&#125;int main() &#123; string str; cin &gt;&gt; str; int sum = 0; for(int i = 0; i &lt; str.length(); i++) &#123; sum += str[i] - '0'; &#125; dfs(sum); return 0;&#125; 1006 Sign in and Sign OutAnalysis题目意思很简单，最先去机房的人开门，最晚出机房的人关门，用学号代替人名，输出最早来和最晚走的人的学号即可。分析输入数据，1个字符串，6个整型数字，每3个数字为一个时间点，分别代表到来和离开的时间点，既然要找的只是最早和最晚的两个时间点，那么每次寻找时，只要去比较一个时间点即可。最早来的时间初始化为一天中最后晚的时间（23:59:59），最晚走的时间初始化为一天中最早的时间（00:00:00），注意要分开比较，不能用if-else哦。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;struct person&#123; char ID_number[20]; int start_hh, start_mm, start_ss, end_hh, end_mm, end_ss;&#125; first, last, temp;void Init();bool Earliest(person a, person b);bool Latest(person a, person b);int main(int argc, char const *argv[]) &#123; Init(); int M; scanf("%d", &amp;M); while(M--) &#123; scanf("%s %d:%d:%d %d:%d:%d", temp.ID_number, &amp;temp.start_hh, \ &amp;temp.start_mm, &amp;temp.start_ss, &amp;temp.end_hh, &amp;temp.end_mm, &amp;temp.end_ss); if(Earliest(temp, first)) &#123; first = temp; &#125; if(Latest(temp, last)) &#123; last = temp; &#125; &#125; printf("%s %s\n", first.ID_number, last.ID_number); return 0;&#125;void Init() &#123; first.start_hh = 23; first.start_mm = first.start_ss = 59; last.end_hh = last.end_mm = last.end_ss = 0;&#125;bool Earliest(person a, person b) &#123; if(a.start_hh != b.start_hh) return a.start_hh &lt;= b.start_hh; else if(a.start_mm != b.start_mm) return a.start_mm &lt;= b.start_mm; else return a.start_ss &lt;= a.start_ss;&#125;bool Latest(person a, person b) &#123; if(a.end_hh != b.end_hh) return a.end_hh &gt;= b.end_hh; else if(a.end_mm != b.end_mm) return a.end_mm &gt;= b.end_mm; else return a.end_ss &gt;= b.end_ss;&#125; 实际上，可以直接使用字符串进行比较得到符合条件的值：123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main() &#123; int m; cin &gt;&gt; m; string early, late, earliest, latest, tmp, come, leave; cin &gt;&gt; early &gt;&gt; earliest &gt;&gt; latest; late = early; m--; while(m--) &#123; cin &gt;&gt; tmp &gt;&gt; come &gt;&gt; leave; if(come &lt; earliest) &#123; early = tmp; earliest = come; &#125; if(leave &gt; latest) &#123; late = tmp; latest = leave; &#125; &#125; cout &lt;&lt; early &lt;&lt; ' ' &lt;&lt; late; return 0;&#125; 1007 Maximum Subsequence SumAnalysisCodeDP123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int maxn = 10010;int a[maxn], dp[maxn];int s[maxn] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; bool flag = false; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if(a[i] &gt;= 0) flag = true; &#125; if(flag == false) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; a[n - 1]; &#125; else &#123; dp[0] = a[0]; for(int i = 1; i &lt; n; i++) &#123; if(dp[i - 1] + a[i] &gt; a[i]) &#123; dp[i] = dp[i - 1] + a[i]; s[i] = s[i - 1]; &#125; else &#123; dp[i] = a[i]; s[i] = i; &#125; &#125; int k = 0; for(int i = 1; i &lt; n; i++) &#123; if(dp[i] &gt; dp[k]) &#123; k = i; &#125; &#125; cout &lt;&lt; dp[k] &lt;&lt; ' ' &lt;&lt; a[s[k]] &lt;&lt; ' ' &lt;&lt; a[k]; &#125; return 0;&#125; Online-Processing1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxk = 10010;int main(int argc, char *argv[]) &#123; int k, arr[maxk] = &#123;0&#125;; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ThisSum = 0, MaxSum = -1; int left = 0, right = k - 1, temp_left = 0; for(int i = 0; i &lt; k; i++) &#123; ThisSum += arr[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; right = i; left = temp_left; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; if(MaxSum &lt; 0) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; else cout &lt;&lt; MaxSum &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; return 0;&#125; 1008 ElevatorAnalysis题目大意是给定电梯移动和等待的时长，再按照题目给定的停留顺序，计算出电梯在这个过程中需要的总时间。以样例为例： 初始为0层，到2层，时长为：$2 \times 6 = 12\ s$，再加上等待的$5s$，总计$17s$ 从2层到3层，时长为：$1 \times 6 = 6\ s$，再加上等待的$5s$，总计$11s$ 从3层到1层，时长为：$2 \times 4 = 8\ s$，再加上等待的$5s$，总计$13s$ 合计为：$17 + 11 + 13 = 41\ s$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int n, array[105] = &#123;0&#125;; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; int total = 0, last = 0; for(int i = 0; i &lt; n; i++) &#123; if(array[i] == last) &#123; total += 5; &#125; else if(array[i] &gt; last) &#123; total += ((array[i] - last) * 6 + 5); &#125; else &#123; total += ((last - array[i]) * 4 + 5); &#125; last = array[i]; &#125; printf("%d\n", total); return 0;&#125; 1009 Product of PolynomialsAnalysis此题也是 ZJU 数据结构课程里面的例题，算是另一半了，与 1002 是类似的，只不过 1002 是加法，这个是乘法，还是先用链表做吧。 Codemethod 1链表做法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct PolyNode *Polynomial;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial *pRear);Polynomial ReadPoly();Polynomial Mult(Polynomial P1, Polynomial P2);void PrintPoly(Polynomial P);int Compare(int a, int b);int GetNum(Polynomial P);int main(int argc, char const *argv[])&#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PP = Mult(P1, P2); int numbers = GetNum(PP); if(numbers) &#123; printf("%d ", numbers); PrintPoly(PP); &#125; else &#123; printf("%d\n"); &#125; return 0;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125;Polynomial ReadPoly() &#123; Polynomial P, Rear, t; int e, K; double c; scanf("%d", &amp;K); P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t = P; P = P-&gt;link; free(t); return P;&#125;Polynomial Mult(Polynomial P1, Polynomial P2) &#123; Polynomial P, Rear, t1, t2, t; int e; double c; if(!P1 || !P2) return NULL; t1 = P1; t2 = P2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(t1) &#123; t2 = P2; Rear = P; while(t2) &#123; e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) &#123; Rear = Rear-&gt;link; &#125; if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if(Rear-&gt;link-&gt;coef + c) &#123; Rear-&gt;link-&gt;coef += c; &#125; else &#123; t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; &#125; t2 = P; P = P-&gt;link; free(t2); return P;&#125;void PrintPoly(Polynomial P) &#123; int flag = 0; while(P) &#123; if(!flag)&#123; flag = 1; &#125; else &#123; printf(" "); &#125; printf("%d %.1lf", P-&gt;expon, P-&gt;coef); P = P-&gt;link; &#125; printf("\n");&#125;int Compare(int a, int b) &#123; return a &gt; b ? 1 : a == b ? 0 : -1;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125; 用 C++ 的特性简化一下，删除不需要的部分：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;using namespace std;typedef struct Node* List;typedef struct Node* PtrtoNode;struct Node &#123; int exp; double coe; PtrtoNode next; Node() &#123; next = nullptr; &#125; Node(int _exp, double _coe) &#123; exp = _exp; coe = _coe; next = nullptr; &#125;&#125;;List createlist(int node_num) &#123; int exp; double coe; List head = new Node; List L = head; while(node_num--) &#123; scanf("%d %lf", &amp;exp, &amp;coe); head-&gt;next = new Node(exp, coe); head = head-&gt;next; &#125; head = L; L = L-&gt;next; delete(head); return L;&#125;int main() &#123; int k; scanf("%d", &amp;k); List L1 = createlist(k); scanf("%d", &amp;k); List L2 = createlist(k); List L = new Node, rear, t1 = L1, t2 = L2, t; rear = L; int exp_tmp; double coe_tmp; while(t1) &#123; t2 = L2; rear = L; while(t2) &#123; exp_tmp = t1-&gt;exp + t2-&gt;exp; coe_tmp = t1-&gt;coe * t2-&gt;coe; while(rear-&gt;next &amp;&amp; rear-&gt;next-&gt;exp &gt; exp_tmp) &#123; rear = rear-&gt;next; &#125; if(rear-&gt;next &amp;&amp; rear-&gt;next-&gt;exp == exp_tmp) &#123; if(rear-&gt;next-&gt;coe + coe_tmp) rear-&gt;next-&gt;coe += coe_tmp; else &#123; t = rear-&gt;next; rear-&gt;next = t-&gt;next; delete(t); &#125; &#125; else &#123; t = new Node(exp_tmp, coe_tmp); t-&gt;next = rear-&gt;next; rear-&gt;next = t; rear = rear-&gt;next; &#125; t2 = t2-&gt;next; &#125; t1 = t1-&gt;next; &#125; t = L; L = L-&gt;next; delete(t); int cnt = 0; t = L; while(t) &#123; cnt++; t = t-&gt;next; &#125; printf("%d", cnt); if(cnt) &#123; t = L; while(t) &#123; printf(" %d %.1lf", t-&gt;exp, t-&gt;coe); t = t-&gt;next; &#125; &#125; return 0;&#125; method 2数组做法：12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;void readp(int nums, double *poly) &#123; int exp; double coe; for(int i = 0; i &lt; nums; i++) &#123; scanf("%d %lf", &amp;exp, &amp;coe); poly[exp] = coe; &#125;&#125;int main() &#123; double L1[1005] = &#123;0&#125;, L2[1005] = &#123;0&#125;, L[2010] = &#123;0&#125;; int k1, k2, exp; double coe; scanf("%d", &amp;k1); readp(k1, L1); scanf("%d", &amp;k2); readp(k2, L2); for(int i = 0; i &lt; 1001; i++) &#123; for(int j = 0; j &lt; 1001; j++) &#123; exp = i + j; coe = L1[i] * L2[j]; L[exp] += coe; &#125; &#125; int cnt = 0; for(int i = 0; i &lt;= 2000; i++) &#123; if(L[i] != 0) cnt++; &#125; printf("%d", cnt); for(int i = 2000; i &gt;= 0; i--) &#123; if(L[i] != 0) printf(" %d %.1lf", i, L[i]); &#125; return 0;&#125; 1010 RadixAnalysis这个题的题意说的比较模糊，所以不太好寻找思路。先分析一下题目意思，给定N1，N2，tag和radix四个数字；若当tag为1时，radix的值就是N1的进制数，tag为2时，radix的值就是N2的进制数（一般针对这种情况，最好交换下N1和N2的值，再统一处理）。 紧接着，题目要求判断N1和N2是否相等，由于题目给定的两个数字的进制不相同，所以还必须要转换后进行判断。与其这样，不如直接将能确定进制的那个数转化为十进制数，然后与另一个数的每一个不同的进制单位下转换为十进制数后值进行比较，若相等，则这两个数相等（只要在一种进制单位下，两个数相等，那么在其他任意进制单位下，这两个数不管如何变化都是相等的）。 明白题意后，就得开始打码了。由于题目给定的radix没有限制范围，所以转换后的十进制数是有可能溢出的（long long也会），所以使用字符串来存储数字。 紧接着，按照前面的思路，先构造字符0 - 9和a - z的十进制数对应表，方便调用。另外，不管tag的值如何，对N1和N2进行处理，默认N1是进制确定的数。在开始对N2进行进制转换之前，要先确定其可能的进制范围，这个结果就是：以其字符最大值为下界，N1的十进制数值为上界。在这个进制范围内，一个一个去枚举显然是很慢的，所以使用二分法是一个很不错的选择。 注意： 使用二分法时，只需要找到满足条件：与N1的十进制数相等的数即可，此时得返回进制数。 针对数据的溢出情况，一旦结果为负，就可以判断为溢出，此时N2在这个进制下的转换出来的十进制数肯定是大于N1的十进制数的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL Map[256];LL inf = (1LL &lt;&lt; 63) - 1;void Init() &#123; for(char c = '0'; c &lt;= '9'; c++) &#123; Map[c] = c - '0'; &#125; for(char c = 'a'; c &lt;= 'z'; c++) &#123; Map[c] = c - 'a' + 10; &#125;&#125;LL ConvertNum10(char *a, LL radix, LL t) &#123; LL ret = 0; for(int i = 0; a[i] != '\0'; i++) &#123; ret = ret * radix + Map[a[i]]; if(ret &lt; 0 || ret &gt; t) &#123; ret = -1; break; &#125; &#125; return ret;&#125;int cmp(char *N2, LL radix, LL t) &#123; int len = strlen(N2); LL num = ConvertNum10(N2, radix, t); if(num &lt; 0) return 1; if(t &gt; num) return -1; else if(t == num) return 0; else return 1;&#125;LL BinarySearch(char *N2, LL left, LL right, LL t) &#123; LL mid; while(left &lt;= right) &#123; mid = (left + right) / 2; int flag = cmp(N2, mid, t); if(flag == 0) return mid; else if(flag == -1) left = mid + 1; else right = mid - 1; &#125; return - 1;&#125; int FindLargestDigit(char *N2) &#123; int ans = -1, len = strlen(N2); for(int i = 0; i &lt; len; i++) &#123; if(Map[N2[i]] &gt; ans) &#123; ans = Map[N2[i]]; &#125; &#125; return ans + 1;&#125;char N1[20], N2[20], temp[20];int tag, radix;int main(int argc, char const *argv[]) &#123; Init(); scanf("%s %s %d %d", N1, N2, &amp;tag, &amp;radix); if(tag == 2) &#123; strcpy(temp, N1); strcpy(N1, N2); strcpy(N2, temp); &#125; LL t = ConvertNum10(N1, radix, inf); LL low = FindLargestDigit(N2); LL high = max(low, t) + 1; LL ans = BinarySearch(N2, low, high, t); if(ans == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%lld\n", ans); &#125; return 0;&#125; 1011 World Cup BettingAnalysis题目意思很明确，三局比赛，给出每局的赔率，默认每次都赌对，问怎样买收益最多。很简单，每次买赔率最大的就好啦~然后还有一个麻烦的地方，就是要输出每局赔率最大的是哪一种局，即：获胜（Win）、平局（Tie）和失败（Lose），先保存每次的下标，然后写个函数转换一下就好了。至于收益的计算方法，按照题目给定的公式算就好了。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;char change(int index);int main(int argc, char const *argv[]) &#123; double Bet[3][3], Profit = 0.0; for(int i = 0; i &lt; 3; i++) &#123; scanf("%lf %lf %lf", &amp;Bet[i][0], &amp;Bet[i][1], &amp;Bet[i][2]); &#125; int max_index[3]; double max[3] = &#123;0.0&#125;; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; if(max[i] &lt; Bet[i][j]) &#123; max[i] = Bet[i][j]; max_index[i] = j; &#125; &#125; &#125; Profit = (max[0] * max[1] * max[2] * 0.65 - 1.0) * 2.0; printf("%c %c %c %.2lf\n", change(max_index[0]), change(max_index[1]), change(max_index[2]), Profit); return 0;&#125;char change(int index) &#123; char ret; switch(index) &#123; case 0: ret = 'W'; break; case 1: ret = 'T'; break; case 2: ret = 'L'; break; &#125; return ret;&#125; 贴一个简化版：12345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; double turns[3][3], max, maxproduct = 1.0; char ans[3]; for(int i = 0; i &lt; 3; i++) &#123; max = -1000; for(int j = 0; j &lt; 3; j++) &#123; scanf("%lf", &amp;turns[i][j]); if(max &lt; turns[i][j]) &#123; max = turns[i][j]; if(j == 1) ans[i] = 'T'; else if(j == 2) ans[i] = 'L'; else ans[i] = 'W'; &#125; &#125; maxproduct *= max; &#125; double maxprofit = 0.0; maxprofit = (maxproduct * 0.65 - 1) * 2; for(int i = 0; i &lt; 3; i++) &#123; printf("%c ", ans[i]); &#125; printf("%.2lf", maxprofit); return 0;&#125; 1012 The Best RankAnalysis给出每个学生的各科成绩，计算其平均分，并根据他们的成绩进行排序；然后查找指定学号的学生的成绩，输出其排名最优的成绩和科目名称。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000 + 5;struct student &#123; int id, grade[4];&#125; stu[MAXN];char course[4] = &#123;'A', 'C', 'M', 'E'&#125;;int Rank[10000000][4] = &#123;0&#125;;int now;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d %d", &amp;stu[i].id, &amp;stu[i].grade[1], &amp;stu[i].grade[2], &amp;stu[i].grade[3]); stu[i].grade[0] = (stu[i].grade[1] + stu[i].grade[2] + stu[i].grade[3]) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, cmp); Rank[stu[0].id][now] = 1; for(int i = 1; i &lt; N; i++) &#123; if(stu[i].grade[now] == stu[i - 1].grade[now]) &#123; Rank[stu[i].id][now] = Rank[stu[i - 1].id][now]; &#125; else &#123; Rank[stu[i].id][now] = i + 1; &#125; &#125; &#125; int query; while(M--) &#123; scanf("%d", &amp;query); if(Rank[query][0] == 0) &#123; printf("N/A\n"); &#125; else &#123; int k = 0; for(int j = 0; j &lt; 4; j++) &#123; if(Rank[query][j] &lt; Rank[query][k]) &#123; k = j; &#125; &#125; printf("%d %c\n", Rank[query][k], course[k]); &#125; &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade[now] &gt; b.grade[now];&#125; 重新写了一下，求每个学生的各科排名时，不再开那么大的数组了，但是会有额外的查找时间开销（也能 AC）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; string id; int grade[4]; int rank[4];&#125; stu[2005];char species[5] = "ACME";int now;int main() &#123; int N, M, c, m, e; cin &gt;&gt; N &gt;&gt; M; string str; for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; str &gt;&gt; c &gt;&gt; m &gt;&gt; e; stu[i].id = str; stu[i].grade[1] = c, stu[i].grade[2] = m, stu[i].grade[3] = e; stu[i].grade[0] = (c + m + e) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, [](student a, student b)&#123; return a.grade[now] &gt; b.grade[now]; &#125;); stu[0].rank[now] = 1; for(int j = 1; j &lt; N; j++) &#123; if(stu[j].grade[now] == stu[j - 1].grade[now]) stu[j].rank[now] = stu[j - 1].rank[now]; else stu[j].rank[now] = j + 1; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; str; int index = -1; for(int i = 0; i &lt; N; i++) &#123; if(stu[i].id == str) &#123; index = i; break; &#125; &#125; if(index == -1) cout &lt;&lt; "N/A" &lt;&lt; endl; else &#123; int k = 0; for(int i = 1; i &lt; 4; i++) &#123; if(stu[index].rank[i] &lt; stu[index].rank[k]) k = i; &#125; cout &lt;&lt; stu[index].rank[k] &lt;&lt; ' ' &lt;&lt; species[k] &lt;&lt; endl; &#125; &#125; return 0;&#125; 1013 Battle Over CitiesAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* method 1: use union-find set*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];int father[maxn];bool vis[maxn];int n, m, k;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = faB; &#125;&#125;void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; father[i] = i; vis[i] = false; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; int currentPoint; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; init(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; int u = i, v = G[i][j]; if(u == currentPoint || v == currentPoint) continue; Union(u, v); &#125; &#125; int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i == currentPoint) continue; int fa_i = findFather(i); if(vis[fa_i] == false) &#123; block++; vis[fa_i] = true; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;/*method 2: use DFS#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];bool vis[maxn] = &#123;false&#125;;int currentPoint;int n, m, k;void dfs(int v) &#123; if(v == currentPoint) return; vis[v] = true; for(int i = 0; i &lt; G[v].size(); i++) &#123; if(vis[G[v][i]] == false) &#123; dfs(G[v][i]); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; memset(vis, false, sizeof(vis)); int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i != currentPoint &amp;&amp; vis[i] == false) &#123; dfs(i); block++; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;*/ 1015 Reversible PrimesAnalysis题目大意是给定两个整数N、D，N是十进制下的整数，D是进制数，判断N和将N转换为D进制下的数是否都是素数。若是，输出Yes，反之输出No。 考察进制转换和素数的判断。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;int Reverse(int number, int radix) &#123; int a[32], temp = number, count = 0, ret = 0; while(temp) &#123; a[count++] = temp % radix; temp /= radix; &#125; for(int i = 0; i &lt; count; i++) &#123; ret = ret * radix + a[i]; &#125; return ret;&#125;bool isPrime(int n) &#123; if(n &lt;= 1 || (n % 2 == 0 &amp;&amp; n != 2)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[]) &#123; int n, d; while(1) &#123; scanf("%d", &amp;n); if(n &lt; 0) break; scanf("%d", &amp;d); if(isPrime(n) &amp;&amp; isPrime(Reverse(n, d))) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125; 贴个 C++ 版：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;bool isprime(int n) &#123; if(n &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true; &#125;&#125;int main() &#123; int n, d; while(true) &#123; cin &gt;&gt; n; if(n &lt; 0) break; cin &gt;&gt; d; if(!isprime(n)) cout &lt;&lt; "No" &lt;&lt; endl; else &#123; vector&lt;int&gt; digits; int tmp = n; while(tmp) &#123; int r = tmp % d; digits.push_back(r); tmp /= d; &#125; tmp = 0; for(int i = 0; i &lt; digits.size(); i++) &#123; tmp = tmp * d + digits[i]; &#125; if(isprime(tmp)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125; return 0;&#125; 1016 Phone BillsAnalysis先分析一下输入，包含名称、时间和状态，其中名称和状态是以字符串的形式输入的，而时间则是十进制数字。这里要立刻反应过来，不能用题目字符串来表示状态，应该换成数字来表示。至于，最开始输入的费率表，使用一个整型数组来存储，使用的时候进行调用就好。 接下来，需要对输入的数据进行排序，优先级最大的排序依据就是名称，按照字典序来排列，注意字符串需要用strcmp函数来进行比较；其次，相同名称的元素按照时间的先后进行排列就好了。 接着再来看输出，首先要输出的是客户的名称和其话费账单所处的月份；第二行开始输出客户的话费账单的开始时间和结束时间，然后输出当前账单的总时长和费用，注意费用为浮点型；所有账单都输出完毕后，最后一行输出客户总话费。 大致清楚之后，如何去计算话费呢？根据题目，输入的每一项必须是配对的on-line和off-line才能组成一个合法的账单，并且必须要是连续、相邻的才能是一对（这个条件很重要）。读懂这个条件后，计算时间就比较简单了，让开始时间一直增加到结束时间，统计好分钟数既可得到经历的时间，然后计算总费用。注意，给定的费率是cents/minute，最后得转化为dollar，除以100即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct record&#123; char name[25]; int month, day, hour, minute; bool status;&#125; rec[MAXN], temp;int rate[25] = &#123;0&#125;;bool cmp(record a, record b);void get_time(int on, int off, int &amp;time, int &amp;money);int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; 24; i++) &#123; scanf("%d", rate + i); &#125; int N; scanf("%d", &amp;N); char line[10]; for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d:%d:%d:%d", rec[i].name, &amp;rec[i].month, &amp;rec[i].day, &amp;rec[i].hour, &amp;rec[i].minute); scanf("%s", line); if(!strcmp(line, "on-line")) &#123; rec[i].status = true; &#125; else &#123; rec[i].status = false; &#125; &#125; sort(rec, rec + N, cmp); int on = 0, off, next; while(on &lt; N) &#123; int needPrint = 0; next = on; // fint the next customer, and check the current customer has paired 'on-line' and 'off-line' or not while(next &lt; N &amp;&amp; strcmp(rec[next].name, rec[on].name) == 0) &#123; if(needPrint == 0 &amp;&amp; rec[next].status == true) &#123; needPrint = 1; &#125; else if(needPrint == 1 &amp;&amp; rec[next].status == false) &#123; needPrint = 2; &#125; next++; &#125; //the current customer has not paired 'on-line' and 'off-line', skip this customer if(needPrint &lt; 2) &#123; on = next; continue; &#125; //calculate the money for current customer int Total = 0; printf("%s %02d\n", rec[on].name, rec[on].month); while(on &lt; next) &#123; //find the paired 'on-line' and 'off-line' while(on &lt; next - 1 &amp;&amp; !(rec[on].status == true &amp;&amp; rec[on + 1].status == false)) &#123; on++; &#125; off = on + 1; if(off == next) &#123; on = next; break; &#125; printf("%02d:%02d:%02d ", rec[on].day, rec[on].hour, rec[on].minute); printf("%02d:%02d:%02d ", rec[off].day, rec[off].hour, rec[off].minute); int time = 0, money = 0; get_time(on, off, time, money); Total += money; printf("%d $%.2lf\n", time, money / 100.0); on = off + 1; &#125; printf("Total amount: $%.2lf\n", Total / 100.0); &#125; return 0;&#125;bool cmp(record a, record b) &#123; if(strcmp(a.name, b.name)) return strcmp(a.name, b.name) &lt; 0; else if(a.month != b.month) return a.month &lt; b.month; else if(a.day != b.day) return a.day &lt; b.day; else if(a.hour != b.hour) return a.hour &lt; b.hour; else return a.minute &lt; b.minute;&#125;void get_time(int on, int off, int &amp;time, int &amp;money) &#123; temp = rec[on]; while(temp.day &lt; rec[off].day || temp.hour &lt; rec[off].hour || temp.minute &lt; rec[off].minute) &#123; time++; money += rate[temp.hour]; temp.minute++; if(temp.minute &gt;= 60) &#123; temp.minute = 0; temp.hour++; &#125; if(temp.hour &gt;= 24) &#123; temp.hour = 0; temp.day++; &#125; &#125;&#125; 1018 Public Bike ManagementAnalysis题目背景类似现在的共享单车，这种公共设施服务有一个管理中心，本题叫做 Public Bike Management Center，简称 PMBC，而这个 PMBC 会调整每个停靠站点的自行车数目从而达到“完美”状态，这种“完美”状态是指停靠数量为该站点最大容量的一半。 题目给定各个站点距离 PMBC 的距离、每个停靠站点当前的停靠数量和需要投放自行车的站点，要求输出完成投放工作需要携带的最小自行车数目、完成投放工作的最短路径和剩余带回的车数，注意路径中的站点如果不是完美状态，也需要调整为完美状态。 题目的第一要求是最短路径，借助 Dijkstra 算法可以解决这个问题，再利用动态数组保存好每一条最短路径，然后借助 DFS 来计算题目要求的所携带的最小自行车数目及剩余带回的车数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int Cmax, n, m, sp, G[maxv][maxv], weight[maxv];int d[maxv], minneed = inf, minremain = inf;bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path; void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt;= n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt;= n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt;= n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); int need = 0, remain = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; if(weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; if(remain + weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; need += abs(remain + weight[id]); remain = 0; &#125; &#125; &#125; if(need &lt; minneed) &#123; minneed = need; minremain = remain; path = tempath; &#125; else if(need == minneed &amp;&amp; remain &lt; minremain) &#123; minremain = remain; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; Cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] -= Cmax / 2; //preprocessing: make it 'perfect' &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); dfs(sp); cout &lt;&lt; minneed &lt;&lt; ' '; for(int i = path.size() - 1; i &gt;=0; i--) &#123; cout &lt;&lt; path[i]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; ' ' &lt;&lt; minremain; return 0;&#125; 1019 General Palindromic NumberAnalysis此题属于结合了进制转换和回文序列判断的混合题目。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;bool PalindromicNum(long long *digits, long long count);int main(int argc, char const *argv[]) &#123; long long N, b, count = 0, digits[50] = &#123;0&#125;; scanf("%lld %lld", &amp;N, &amp;b); while(N) &#123; digits[count++] = N % b; N /= b; &#125; count--; if(PalindromicNum(digits, count)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(; count &gt; 0; count--) &#123; printf("%lld ", digits[count]); &#125; printf("%lld\n", digits[count]); return 0;&#125;bool PalindromicNum(long long *digits, long long count) &#123; bool flag = true; int i, j; if(count % 2 == 0) &#123; i = j = count / 2; &#125; else &#123; i = count / 2; j = i + 1; &#125; for(; i &gt;= 0 &amp;&amp; j &lt;= count; i--, j++) &#123; if(digits[i] != digits[j]) &#123; flag = false; break; &#125; &#125; return flag;&#125; 贴个 C++ 版，简化了一下回文的判断过程：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; if(n == 0) &#123; cout &lt;&lt; "Yes\n" &lt;&lt; 0; &#125; else &#123; vector&lt;int&gt; digits; while(n) &#123; digits.push_back(n % k); n /= k; &#125; int size = digits.size(); bool flag = true; for(int i = 0; i &lt; size / 2; i++) &#123; if(digits[i] != digits[size - i - 1]) &#123; flag = false; break; &#125; &#125; if(flag) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; for(int i = size - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; digits[i]; if(i &gt; 0) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; 1020 Tree TraversalsAnalysis题目大意，给定两个树的中序遍历和后序遍历，求其层次遍历。 此题属于树的常规题型，思路是利用中序遍历和后序遍历建树，然后再借助 BFS 进行层次遍历，并输出层次遍历序列。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50;struct node &#123; int data; node *lchild; node *rchild;&#125;;int pre[maxn], in[maxn], post[maxn];int n;node *create(int postL, int postR, int inL, int inR) &#123; if(postL &gt; postR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = post[postR]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == post[postR]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(postL, postL + numLeft - 1, inL, k - 1); root-&gt;rchild = create(postL + numLeft, postR - 1, k + 1, inR); return root;&#125;int num = 0;void BFS(node *root) &#123; queue&lt;node*&gt; q; q.push(root); while(!q.empty()) &#123; node *now = q.front(); q.pop(); printf("%d", now-&gt;data); num++; if(num &lt; n) printf(" "); if(now-&gt;lchild != NULL) q.push(now-&gt;lchild); if(now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node *root = create(0, n - 1, 0, n - 1); BFS(root); return 0;&#125; 1022 Digital LibraryAnalysis题目背景是数字图书馆的检索功能，要求大致模拟一下这个功能。 按照题目的要求，输出书名时，需要按序输出，比起构造新的数据结构后使用sort函数来完成这项操作，不如直接借助set。而在查询时，是通过字符串来进行的查询，使用map建立映射后，就可以类似散列一样进行查询。 综合上述的两种需求后，好在map是支持string向set的映射的，所以直接使用即可。 由于关键字key是一个一个给出的，所以需要一个一个输入并统计，依据cin或scanf输入字符串的特性，可以很方便的单个读入，并使用getchar读取回车符结束循环。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; mpTitle, mpAuthor, mpKey, mpPub, mpYear;void query(map&lt;string, set&lt;int&gt; &gt; &amp;mp, string &amp;str) &#123; if(mp.find(str) == mp.end()) printf("Not Found\n"); else &#123; for(set&lt;int&gt;::iterator it = mp[str].begin(); it != mp[str].end(); it++) &#123; printf("%07d\n", *it); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, m, id, type; string title, author, key, pub, year; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;id); char c = getchar(); getline(cin, title); mpTitle[title].insert(id); getline(cin, author); mpAuthor[author].insert(id); while(cin &gt;&gt; key) &#123; mpKey[key].insert(id); c = getchar(); if(c == '\n') break; &#125; getline(cin, pub); mpPub[pub].insert(id); getline(cin, year); mpYear[year].insert(id); &#125; string temp; cin &gt;&gt; m; while(m--) &#123; scanf("%d: ", &amp;type); getline(cin, temp); cout &lt;&lt; type &lt;&lt; ": " &lt;&lt; temp &lt;&lt; endl; if(type == 1) query(mpTitle, temp); else if(type == 2) query(mpAuthor, temp); else if(type == 3) query(mpKey, temp); else if(type == 4) query(mpPub, temp); else query(mpYear, temp); &#125; return 0;&#125; 查询函数可以写的简单点：12345678void query(map&lt;string, set&lt;int&gt;&gt;&amp; mp, string &amp;tmp) &#123; if(!mp.count(tmp)) printf("Not Found\n"); else &#123; for(auto &amp;i: mp[tmp]) &#123; printf("%07d\n", i); &#125; &#125;&#125; 这个题的难点不在算法的设计上，而是在对数据的处理上。为了能更简单的完成这个事情，就需要对 STL 容器、输入输出函数及其他 API 的用法很熟悉。 1023 Have Fun with NumbersAnalysis题目大意是给一个不超过20位的整数，将这个整数翻倍后，判断组成这个新整数的所有数字是否与原来的数字相同。若是，输出Yes；反之，输出No。注意，无论是否符合都需要输出翻倍后的新数字。 由于题目明确说了给定的数字位数不超过20位，但是long long只能到19位，所以直接使用数组来存储数字，然后利用数组来模拟乘以2。 然后判断两个数字的所有位数字的出现次数是否一致即可（利用散列的思想会比较方便）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int Compare(int *original, int *now, int number);int main(int argc, char const *argv[]) &#123; char Num[22]; int original[22], now[22], original_occurrence[10] = &#123;0&#125;, now_occurrence[10] = &#123;0&#125;; scanf("%s", Num); char *p = Num; int i = 0, j, k, temp = 0, flag = 0; //conver the string to an array(int) while(*p != '\0') &#123; original[i++] = *p++ - '0'; &#125; //count the occurrence of the original number for(j = 0; j &lt; i; j++) &#123; original_occurrence[original[j]]++; &#125; //imitate multiplication for(k = 0, j = i - 1; j &gt;= 0; j--, k++) &#123; now[k] = (original[j] * 2 + temp) % 10; temp = original[j] * 2 / 10; &#125; if(temp) &#123; now[k] = temp; &#125; else &#123; k -= 1; &#125; //count the new number for(j = 0; j &lt;= k; j++) &#123; now_occurrence[now[j]]++; &#125; flag = Compare(original_occurrence, now_occurrence, 10); //print if(flag) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(j = k; j &gt; 0; j--) &#123; printf("%d", now[j]); &#125; printf("%d\n", now[j]); return 0;&#125;int Compare(int *original, int *now, int number) &#123; int i, j, ret = 1; for(i = 0; i &lt; number; i++) &#123; if(original[i] != now[i]) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 贴个 C++ 版：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string num; cin &gt;&gt; num; vector&lt;int&gt; n, dn; for(int i = num.size() - 1; i &gt;= 0; i--) &#123; n.push_back(num[i] - '0'); &#125; int carry = 0; for(int i = 0; i &lt; n.size(); i++) &#123; dn.push_back((2 * n[i] + carry) % 10); carry = 2 * n[i] / 10; &#125; if(carry &gt; 0) dn.push_back(carry); string ans; for(int i = dn.size() - 1; i &gt;= 0; i--) &#123; ans.push_back(dn[i] + '0'); &#125; sort(n.begin(), n.end()); sort(dn.begin(), dn.end()); if(n == dn) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; cout &lt;&lt; ans; return 0;&#125; 本来还想更偷懒用long double直接算的，但是在存 20 位数时，long double这个数据类型已经开始有误差了，所以最后一个测试点过不去，可惜了。按理说，long double能存相当大的数了，不应该才 20 位就开始出现误差啊？ 1024 Palindromic NumberAnalysis题目大意是给定一个数字，判断是否为回文数字，并进行一系列操作。另外，给定一个上限次数，当给定的数不是回文数字时，令其加上将其逆置后的数字，在进行判断是否为会问数字，若是，则输出这个数字和变换次数，反之，则继续直至超过上限次数。注意，即便超过了上限次数，依然要变换过程中最后的数字。 解决此题需要解决下面3个子问题： 回文数字的判定 数字逆置 数字相加 题目要求数字的范围不超过$10^{10}$，可以使用long long，但这会使得将数字逆置的这个步骤非常麻烦，所以直接使用数组来存储数字，并模拟数字之间的加法。另外这样还有一个好处，就是在判断是否是回文数字时，可以直接对数组进行判断。使用long long会溢出，直接用字符串就好，别想着偷鸡了。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign &#123; int d[200], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign reversebign(bign a) &#123; int temp; for(int i = 0; i &lt; a.len / 2; i++) &#123; temp = a.d[i]; a.d[i] = a.d[a.len - i - 1]; a.d[a.len - i - 1] = temp; &#125; return a;&#125;bign add(bign a, bign b) &#123; bign c; int carry = 0; for(int i = 0; i &lt; a.len || i &lt; b.len; i++) &#123; int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10; carry = temp / 10; &#125; if(carry != 0) &#123; c.d[c.len++] = carry; &#125; return c;&#125;bool isPalindromic(bign a) &#123; for(int i = 0; i &lt;= a.len / 2; i++) &#123; if(a.d[i] != a.d[a.len - 1 - i]) return false; &#125; return true;&#125;void print(bign a) &#123; for(int i = a.len - 1; i &gt;= 0; i--) &#123; printf("%d", a.d[i]); &#125; putchar('\n');&#125;int main(int argc, char const *argv[]) &#123; char str[150]; int times, count = 0; scanf("%s %d", str, &amp;times); bign a = change(str), rev; while(times--) &#123; if(isPalindromic(a)) &#123; break; &#125; else &#123; rev = reversebign(a); a = add(a, rev); count++; &#125; &#125; print(a); printf("%d", count); return 0;&#125; 贴个 C++ 版：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool ispalindromic(string &amp;num) &#123; int left = 0, right = num.length() - 1; while(left &lt; right) &#123; if(num[left] != num[right]) return false; left++, right--; &#125; return true;&#125;int main() &#123; int k; string num, tmp; cin &gt;&gt; num &gt;&gt; k; int i; reverse(num.begin(), num.end()); for(i = 0; i &lt; k; i++) &#123; if(ispalindromic(num)) break; tmp = num; reverse(tmp.begin(), tmp.end()); int carry = 0; for(int i = 0; i &lt; num.length(); i++) &#123; int t = (num[i] + tmp[i] + carry - 2 * '0'); num[i] = t % 10 + '0'; carry = t / 10; &#125; if(carry) num.push_back(carry + '0'); &#125; reverse(num.begin(), num.end()); cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; (i == k ? k : i); return 0;&#125; 1025 PTA RankingAnalysis此题考察排序，直接调用库里的排序函数来帮助完成排序就好了。注意： 一个地点内的所有数据输入完了之后，本地排名就可以完成了 每个数据在在输入的时候就可以顺便对其进行地点编号 最终排名必须要在本地排名之后才能进行 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char id[15]; int score; int location_number; int local_rank;&#125; stu[30010];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, K, num = 0; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;K); for(int j = 0; j &lt; K; j++) &#123; scanf("%s %d", stu[num].id, &amp;stu[num].score); stu[num].location_number = i; num++; &#125; sort(stu + num - K, stu + num, cmp); stu[num - K].local_rank = 1; //get local rank for(int j = num - K + 1; j &lt; num; j++) &#123; if(stu[j].score == stu[j - 1].score) &#123; stu[j].local_rank = stu[j - 1].local_rank; &#125; else &#123; stu[j].local_rank = j + 1 - (num - K); &#125; &#125; &#125; printf("%d\n", num); sort(stu, stu + num, cmp); //get final rank int r = 1; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].score != stu[i - 1].score) &#123; r = i + 1; &#125; printf("%s ", stu[i].id); printf("%d %d %d\n", r, stu[i].location_number, stu[i].local_rank); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.id, b.id) &lt; 0;&#125; 1027 Colors in MarsAnalysis考察进制转换的题目，10进制转换为13进制，与转换10进制转换为16进制是类似的，代码可能写的不太好看，嘿嘿~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;char Change(int number);int Transfer(char *dst, int number, int dex);int main(int argc, char const *argv[]) &#123; int R, G, B, index = 1; scanf("%d %d %d", &amp;R, &amp;G, &amp;B); char color[10] = "#00000000"; index = Transfer(color, R, index); index = Transfer(color, G, index); index = Transfer(color, B, index); color[index] = '\0'; puts(color); return 0;&#125;int Transfer(char *dst, int number, int index) &#123; int mask = 1, temp = number; while(temp &gt; 12) &#123; temp /= 13; mask *= 13; &#125; temp = number; if(mask &gt; 1) &#123; while(mask) &#123; dst[index++] = Change(temp / mask); temp %= mask; mask /= 13; &#125; &#125; else &#123; index++; dst[index++] = Change(temp); &#125; return index;&#125;char Change(int number) &#123; char ret; if(0 &lt;= number &amp;&amp; number &lt;= 9) &#123; ret = number + '0'; &#125; else &#123; ret = number - 10 + 'A'; &#125; return ret;&#125; 贴个 C++ 直接用 map 打表的方法：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;map&lt;int, string&gt; marscolors;char num2char(int num) &#123; char ret = '0'; if(0 &lt;= num &amp;&amp; num &lt;= 9) ret += num; else ret = 'A' + num - 10; return ret;&#125;int main() &#123; marscolors[0] = "00"; for(int i = 1; i &lt; 169; i++) &#123; int tmp = i; string s; while(tmp) &#123; s += num2char(tmp % 13); tmp /= 13; &#125; if(i &lt; 13) s += "0"; reverse(s.begin(), s.end()); marscolors[i] = s; &#125; int red, green, blue; cin &gt;&gt; red &gt;&gt; green &gt;&gt; blue; cout &lt;&lt; "#" &lt;&lt; marscolors[red] &lt;&lt; marscolors[green] &lt;&lt; marscolors[blue]; return 0;&#125; 1028 List SortingAnalysis考察排序，用输入的数字表示以元素的某一项进行排序，直接把类别数字用全局变量代替，然后在cmp函数中直接使用即可，注意字符串需要用strcmp函数进行比较。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char id[10], name[15]; int grade;&#125; stu[MAXN];int N, C;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;C); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].id, stu[i].name, &amp;stu[i].grade); &#125; sort(stu, stu + N, cmp); for(int i = 0; i &lt; N; i++) &#123; printf("%s %s %d\n", stu[i].id, stu[i].name, stu[i].grade); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(C == 1) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; else if(C == 2) &#123; int temp = strcmp(a.name, b.name); if(temp != 0) return temp &lt; 0; else return strcmp(a.id, b.id) &lt; 0; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return strcmp(a.id, b.id) &lt; 0; &#125;&#125; 贴个 C++ 版：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string id, name; int grade;&#125; stu[maxn];bool cmp1(student a, student b) &#123; if(a.name != b.name) return a.name &lt; b.name; else return a.id &lt; b.id;&#125;int n, c;bool cmp(student a, student b) &#123; if(c == 1) return a.id &lt; b.id; else if(c ==2) &#123; if(a.name != b.name) return a.name &lt; b.name; else return a.id &lt; b.id; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return a.id &lt; b.id; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; c; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].name &gt;&gt; stu[i].grade; &#125; sort(stu, stu + n, cmp); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; stu[i].id &lt;&lt; ' ' &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].grade &lt;&lt; endl; &#125; return 0;&#125; 1029 MedianAnalysis题目大意是给定两个递增序列，求这两个序列合并后的中位数。 明确了什么是中位数之后，解决这个问题的方法就有很多了。超级无脑的做法就是直接把其中一个序列拼接在另外一个序列后面，排个序，然后直接输出其中位数就好了。但是注意到题目的Memory Limit: 1.5 MB，说明题目对内存有要求，简单直接的做法可能导致Memory Limit Exceeded的错误。 那么就需要想办法优化空间了，题目给定的两个序列，按照上述的思路，就需要三个数组（两个存给定的，一个存合并后的），能不能少用一个或两个呢？答案是肯定的，其实可以不用完全合并，而只需要模拟这个合并操作的过程，并在这个过程中，按照顺序来统计是否枚举到了那个中位数（根据数组下标的初始值，中位数的位置是可以直接算出来的）即可。 不过，很可惜，道高一尺魔高一丈，这个题更新（2018年3月之后？）了测试样例，最后一个测试用例还是无法通过，并且还是MLE的错误。 这就得靠在线处理了，在读入第二个序列时，将每次读入的数字存在一个变量内，每次需要统计第一个序列中有多少数字小于它，然后根据这一点来计算出这个数字在合并后的序列中所处的位置，并与中位数的位置进行比较，然后来决定是否输出。在读入第二个序列的过程中存在两种情况： 数字存在第一个序列内，并且此时可以确定中位数必定比当前读入的数字小 数字存在第二个序列内，就是当前读入的数字 针对上述两种情况，统计到中位数后直接输出即可，但是要注意，若是第二个序列的数字比第一个序列少很多（或者小很多等极端情况），那么中位数依然还是在第一个序列内，所以还是得在第一个序列内找。 Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 200000 + 10;int seq[MAXN];int main(int argc, char const *argv[]) &#123; int n1, n2, temp, count = 0; scanf("%d", &amp;n1); for(int i = 1; i &lt;= n1; i++) &#123; scanf("%d", &amp;seq[i]); &#125; seq[n1 + 1] = 0x7fffffff; scanf("%d", &amp;n2); int median = (n1 + n2 + 1) / 2, i = 1; for(int j = 1; j &lt;= n2; j++) &#123; scanf("%d", &amp;temp); while(seq[i] &lt; temp) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; count++; if(count == median) printf("%d", temp); &#125; while(i &lt;= n1) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; return 0;&#125; 现在这个题的内存限制已经改成64 MB了，可以直接排序了😂：1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr; int n, tmp; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; sort(arr.begin(), arr.end()); int pos = arr.size() % 2 == 1 ? arr.size() / 2 : arr.size() / 2 - 1; cout &lt;&lt; arr[pos]; return 0;&#125; 1030 Travel PlanAnalysis题目大意是给定一个旅游地图，每个结点之间的边，包含两个属性值：距离和花销。然后，给定起点和终点，要求输出二者之间的最短路径的总距离和对应的花销，若存在相同总距离的最短路径，此时需输出最小的花销值。 由于题目已经说明输入数据不存在负数，且只有一个起点，问题就变成了不存在负环的图的单源最短路径问题。所以可以直接使用 Dijkstra 算法进行求解。由于需要输出对应的最短路径，所以可以在 Dijkstra 算法求解最短路径的过程中，顺便利用一个数组来保存最优路径，之后再利用 DFS 来正序输出路径；当然，也可以利用动态数组保存所有的路径，之后再利用 DFS 遍历每条路径，来求解花销值最小的路径。 CodeDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, s, t, G[maxv][maxv], cost[maxv][maxv];int d[maxv], c[maxv], pre[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, inf); // do not forget initialize the distance array for(int i = 0; i &lt; n; i++) pre[i] = i; d[s] = 0; c[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; pre[v] = u; // save the precursor &#125; else if(d[u] + G[u][v] == d[v]) &#123; if(c[u] + cost[u][v] &lt; c[v]) &#123; // more optimized result c[v] = c[u] + cost[u][v]; pre[v] = u; &#125; &#125; &#125; &#125; &#125;&#125; void dfs(int v) &#123; if(v == s) &#123; cout &lt;&lt; v &lt;&lt; ' '; return; &#125; dfs(pre[v]); cout &lt;&lt; v &lt;&lt; ' ';&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(s); dfs(t); cout &lt;&lt; d[t] &lt;&lt; ' ' &lt;&lt; c[t]; return 0;&#125; Dijkstra + DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, G[maxv][maxv], cost[maxv][maxv];int d[maxv], mincost = inf; // mincost need to be initialized to 'inf' bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); // do not forget clear pre[v].push_back(u); &#125; else if(d[u] + G[u][v] == d[v]) &#123; pre[v].push_back(u); // save other shortest path &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == st) &#123; tempath.push_back(v); int tempcost = 0; for(int i = tempath.size() - 1; i &gt; 0; i--) &#123; int id = tempath[i], idNext = tempath[i - 1]; tempcost += cost[id][idNext]; &#125; if(tempcost &lt; mincost) &#123; path = tempath; mincost = tempcost; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(st); dfs(ed); for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; path[i] &lt;&lt; ' '; &#125; cout &lt;&lt; d[ed] &lt;&lt; ' ' &lt;&lt; mincost; return 0;&#125; 1031 Hello World For UAnalysis这道题属于打印图形类的题目，题眼大概就是找到图形输出的规律了，所以读题得仔细一点。不过，很巧地是，这道题目，用来找规律的那个条件不是很明显，可能还不太容易看懂（可能我英语渣~），就是这个条件$n_1 = n_3 = max \lbrace{k | k \le n_2\ for\ all\ 3 \le n_2 \le N}\rbrace \ with \ n_1 + n_2 + n3 - 2 = N$了。意思大致是：$n_1 = n_3 \le k$，而$k$这个数是得严格小于等于$n_2$，而$n_2$的取值范围为：$[3, N]$，另外还有一个条件$n_1 + n_2 + n_3 - 2 = N$。 另外，$n_1$是指最左边一列“字符串”的长度，$n_2$是指底部“字符串”的长度，$n_3$是指最右边一列“字符串”的长度，$N$就是严格意义上的字符串长度了。 事实上，$n_1 = n_3 = (N + 2) / 3$，然后求得$n_2$即可开始打印输出了😒。 可以直接打印输出，不过还要找些小规律（折磨你😆），如第一行输出的是字符串第一个字符和最后一个字符；先输出第一个字符，然后输出空格，接着在输出最后一个字符即可。也可以先把每一个字符放到二维数组内，利用空格初始化二维数组，然后在指定位置放入字符，最后输出即可。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n1, n2, n3, N; char str[85]; scanf("%s", str); N = strlen(str); n1 = n3 = (N + 2) / 3; //get n1 and n3 first n2 = N + 2 - 2 * n1; //use the condition: n1 + n2 + n3 - 2 = N for(int i = 0; i &lt; n1; i++) &#123; if(i == n1 - 1) &#123; //print the last line for(int j = i; j &lt;= N - i - 1; j++) &#123; printf("%c", str[j]); &#125; &#125; else &#123; printf("%c", str[i]); for(int j = 0; j &lt; n2 - 2; j++) &#123; putchar(' '); &#125; printf("%c", str[N - i - 1]); &#125; putchar('\n'); &#125; return 0;&#125; 贴个 C++ 版，没有用公式求 n1, n2, n3：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int n1, n2 = 3, n3, len = str.length(); while(true) &#123; int diff = len - n2; if(diff % 2 == 0) &#123; n1 = n3 = diff / 2; if(n2 &gt; n1) break; &#125; n2++; &#125; int i, j; for(i = 0, j = len - 1; i &lt; n1 &amp;&amp; j &gt; len - n3 - 1; i++, j--) &#123; cout &lt;&lt; str[i]; for(int k = 0; k &lt; n2 - 2; k++) cout &lt;&lt; ' '; cout &lt;&lt; str[j] &lt;&lt; endl; &#125; while(i &lt;= j) cout &lt;&lt; str[i++]; return 0;&#125; 1032 SharingAnalysis题目大意是使用链表存储英文字符时，因为英文字符存在相同的后缀，所以公共后缀只存储一次，然后让不同且具有这个公共后缀单词的最后一个不属于这个后缀的字母的next指向公共后缀的第一个字母即可，这样就可以节约一定的存储空间了。 按照题目背景，题目要求找出具有两个单词的公共后缀的第一个字母的地址并输出，若不存在，则输出-1。直观的做法是，遍历第一个链表，同时遍历第二个链表，找到二者中具有相同address的元素，输出即可，此时的时间复杂度为：$O(n^2)$。 按照题目给定的形式，使用静态链表来处理问题，接着上面的思考，若在遍历第一个链表时，给其每一个结点都加上一个标志位；接着在遍历第二个链表时，就可以直接判断第二个链表的结点的标志位是否与第一个链表结点的标志位相同，若相同，则这个结点就是二者公共后缀的第一个字母了，就可以输出了，这样时间复杂度就降为：$O(n)$了。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125; node[maxn];int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int head1, head2, n; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); int address, next; char data; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;address, &amp;data, &amp;next); node[address].next = next; node[address].data = data; &#125; int p; for(p = head1; p != -1; p = node[p].next) &#123; node[p].flag = true; &#125; for(p = head2; p != -1; p = node[p].next) &#123; if(node[p].flag == true) break; &#125; if(p != -1) &#123; printf("%05d\n", p); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1033 To Fill or Not to FillAnalysis此题考察贪心算法，如何进行“贪心”得从结果和题意上去分析。 依据结果，每次经过一个加油站时，需要将当前加油站与小车从当前加油站能到达的每个加油站的油价进行比较，若存在油价更低的加油站，那么就加刚好能到达那个加油站的油量，否则就加满。所以需要将加油站按照离杭州的距离从小到大进行排列，并假设目的地离杭州的距离为输入距离，油价为0（这样做的目的是为了方便比较，不用处理特殊情况）。然后，开始模拟小车从起点出发。 当第一个加油站离杭州的距离不为0时，说明小车无法出城，直接输出The maximum travel distance = 0.00即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 500 + 5;const int INF = 1000000000;struct station &#123; double price, dis;&#125; sta[MAXN];bool cmp(station a, station b);int main(int argc, char const *argv[]) &#123; double cmax, d, davg; int N; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[N].price = 0; sta[N].dis = d; sort(sta, sta + N, cmp); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, capacity = 0, max = cmax * davg; while(now &lt; N) &#123; int k = -1; double priceMin = INF; for(int i = now + 1; i &lt;= N &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; priceMin) &#123; priceMin = sta[i].price; k = i; if(priceMin &lt; sta[now].price) &#123; break; &#125; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(priceMin &lt; sta[now].price) &#123; if(capacity &lt; need) &#123; ans += (need - capacity) * sta[now].price; capacity = 0; &#125; else &#123; capacity -= need; &#125; &#125; else &#123; ans += (cmax - capacity) * sta[now].price; capacity = cmax - need; &#125; now = k; &#125; if(now == N) &#123; printf("%.2lf\n", ans); &#125; else &#123; printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; &#125; return 0;&#125;bool cmp(station a, station b) &#123; return a.dis &lt; b.dis;&#125; 重新写了一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 500 + 5;struct station &#123; double price, dis;&#125; sta[maxn];int main() &#123; double cmax, d, davg; int n; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[n].dis = d, sta[n].price = 0; sort(sta, sta + n, [&amp;](station a, station b) &#123; return a.dis &lt; b.dis; &#125;); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, tank = 0, max = cmax * davg; while(now &lt; n) &#123; int k = -1; double minprice = DBL_MAX; for(int i = now + 1; i &lt;= n &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; minprice) &#123; minprice = sta[i].price; k = i; if(minprice &lt; sta[now].price) break; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(minprice &lt; sta[now].price) &#123; if(tank &lt; need) &#123; ans += (need - tank) * sta[now].price; tank = 0; &#125; else tank -= need; &#125; else &#123; ans += (cmax - tank) * sta[now].price; tank = cmax - need; &#125; now = k; &#125; if(now == n) printf("%.2lf\n", ans); else printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; return 0;&#125; 1034 Head of a GangAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2010;const int INF = 1000000000;map&lt;int, string&gt; intTostring;map&lt;string, int&gt; stringToint;map&lt;string, int&gt; Gang;int G[maxn][maxn] = &#123;0&#125;, weight[maxn] = &#123;0&#125;;int n, k, numPerson = 0;bool visited[maxn] = &#123;false&#125;;void DFS(int nowVisit, int &amp;head, int &amp;numMember, int &amp;totalValue) &#123; numMember++; visited[nowVisit] = true; if(weight[nowVisit] &gt; weight[head]) &#123; head = nowVisit; &#125; for(int i = 0; i &lt; numPerson; i++) &#123; if(G[nowVisit][i] &gt; 0) &#123; totalValue += G[nowVisit][i]; G[nowVisit][i] = G[i][nowVisit] = 0; if(visited[i] == false) &#123; DFS(i, head, numMember, totalValue); &#125; &#125; &#125;&#125;void DFSTrave() &#123; for(int i = 0; i &lt; numPerson; i++) &#123; if(visited[i] == false) &#123; int head = i, numMember = 0, totalValue = 0; DFS(i, head, numMember, totalValue); if(numMember &gt; 2 &amp;&amp; totalValue &gt; k) &#123; Gang[intTostring[head]] = numMember; &#125; &#125; &#125;&#125;int change(string s) &#123; if(stringToint.find(s) != stringToint.end()) &#123; return stringToint[s]; &#125; else &#123; stringToint[s] = numPerson; intTostring[numPerson] = s; return numPerson++; &#125;&#125;int main(int argc, char const *argv[]) &#123; int w; string s1, s2; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = change(s1); int id2 = change(s2); weight[id1] += w; weight[id2] += w; G[id1][id2] += w; G[id2][id1] += w; &#125; DFSTrave(); cout &lt;&lt; Gang.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator it; for(it = Gang.begin(); it != Gang.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; 1035 PasswordAnalysis题目看着臭长臭长的，其实比较简单，就是有些小小的细节... 先分析输入格式，给个N代表N组数据，然后每一组数组按照name password的格式来给出，都是字符串，由于输出时后要同等输出，所以方便起见定义一个结构体来保存这些数据；再者，由于最后得先输出被修改的数量，所以得先把数据都存储下来，才能在输出数量后，在输出修改的信息。 再看输出格式，若有修改，就输出修改的数量，然后每行紧接着每个结构体内的信息；若没有修改，就输出There are N accounts and no account is modified，注意这里的细节，当N为1时，得输出There is 1 account and no account is modified，这两句英文在N为1和其他数时使用的Be动词不一样（老师出题很严谨的，🤣英语要学好，哈哈~）。 其他就没什么了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;const int MAXN = 1000 + 5;struct info &#123; char name[12], password[12]; int flag;&#125; Info[MAXN];int main(int argc, char const *argv[]) &#123; int N, count = 0; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s", Info[i].name, Info[i].password); char *p = Info[i].password; while(*p != '\0') &#123; if(*p == '1') &#123; *p = '@'; Info[i].flag = 5; &#125; else if(*p == '0') &#123; *p = '%'; Info[i].flag = 5; &#125; else if(*p == 'l') &#123; *p = 'L'; Info[i].flag = 5; &#125; else if(*p == 'O') &#123; *p = 'o'; Info[i].flag = 5; &#125; p++; &#125; if(Info[i].flag != 5) &#123; count++; &#125; &#125; if(count == N) &#123; if(count == 1) printf("There is %d account and no account is modified\n", count); else printf("There are %d accounts and no account is modified", count); &#125; else &#123; printf("%d\n", N - count); for(int i = 0; i &lt; N; i++) &#123; if(Info[i].flag == 5) &#123; printf("%s %s\n", Info[i].name, Info[i].password); &#125; &#125; &#125; return 0;&#125; 贴个 C++ 版本的：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int m, cnt = 0; cin &gt;&gt; m; string account, password; vector&lt;vector&lt;string&gt;&gt; ans; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; account &gt;&gt; password; bool flag = false; for(int j = 0; j &lt; password.length(); j++) &#123; switch(password[j]) &#123; case '1': password[j] = '@'; flag = true; break; case '0': password[j] = '%'; flag = true; break; case 'l': password[j] = 'L'; flag = true; break; case 'O': password[j] = 'o'; flag = true; break; default: break; &#125; &#125; if(flag) &#123; ans.push_back(&#123;account, password&#125;); cnt++; &#125; &#125; if(!cnt) &#123; if(m &lt;= 1) cout &lt;&lt; "There is " &lt;&lt; m &lt;&lt; " account"; else cout &lt;&lt; "There are " &lt;&lt; m &lt;&lt; " accounts"; cout &lt;&lt; " and no account is modified"; &#125; else &#123; cout &lt;&lt; cnt &lt;&lt; endl; for(int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i][0] &lt;&lt; ' ' &lt;&lt; ans[i][1] &lt;&lt; endl; &#125; &#125; return 0;&#125; 太麻烦了，这个题... 1036 Boys vs GirlsAnalysis题目意思很简单，找出女生中分最高的，男生中分最低的，分别输出他们的姓名、学号和分数之差即可，由于最后需要的两个结果可能没有出现，利用两个标记来记录状态，然后根据4种不同的状态，分别对应输出即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;struct student&#123; char name[15]; char id[15]; char gender; int grade;&#125; Fhighest, Mlowest, temp;void Init();bool Highest(student a, student b);bool Lowest(student a, student b);int main(int argc, char const *argv[]) &#123; Init(); int N; bool Fflag = false, Mflag = false; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %c %s %d", temp.name, &amp;temp.gender, temp.id, &amp;temp.grade); if(temp.gender == 'F') &#123; if(Highest(temp, Fhighest)) &#123; Fhighest = temp; Fflag = true; &#125; &#125; else if(temp.gender == 'M') &#123; if(Lowest(temp, Mlowest)) &#123; Mlowest = temp; Mflag = true; &#125; &#125; &#125; if(!Fflag &amp;&amp; !Mflag) &#123; printf("Absent\nAbsent\nNA\n"); &#125; else if(Fflag &amp;&amp; !Mflag) &#123; printf("%s %s\nAbsent\nNA\n", Fhighest.name, Fhighest.id); &#125; else if(!Fflag &amp;&amp; Mflag) &#123; printf("Absent\n%s %s\nNA\n", Mlowest.name, Mlowest.id); &#125; else &#123; printf("%s %s\n%s %s\n%d\n", Fhighest.name, Fhighest.id, Mlowest.name, Mlowest.id, Fhighest.grade - Mlowest.grade); &#125; return 0;&#125;void Init() &#123; Fhighest.grade = -1; Mlowest.grade = 100;&#125;bool Highest(student a, student b) &#123; return a.grade &gt;= b.grade;&#125;bool Lowest(student a, student b) &#123; return a.grade &lt;= b.grade;&#125; 贴个 C++ 版：12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string malename, femalename, maleid, femaleid, name, clas, maleclass, femaleclass; char gender; int grade, highest = -1, lowest = 101; while(n--) &#123; cin &gt;&gt; name &gt;&gt; gender &gt;&gt; clas &gt;&gt; grade; if(gender == 'M') &#123; if(grade &lt; lowest) &#123; lowest = grade; malename = name; maleclass = clas; &#125; &#125; if(gender == 'F') &#123; if(grade &gt; highest) &#123; highest = grade; femalename = name; femaleclass = clas; &#125; &#125; &#125; if(highest &lt; 0) cout &lt;&lt; "Absent\n"; else cout &lt;&lt; femalename &lt;&lt; ' ' &lt;&lt; femaleclass &lt;&lt; endl; if(lowest &gt; 100) cout &lt;&lt; "Absent\n"; else cout &lt;&lt; malename &lt;&lt; ' ' &lt;&lt; maleclass &lt;&lt; endl; if(lowest &gt; 100 || highest &lt; 0) cout &lt;&lt; "NA\n"; else cout &lt;&lt; highest - lowest; return 0;&#125; 1037 Magic CouponAnalysis这道题考察贪心算法，题目要求输出可以得到的最大钱数。注意这段话：print in a line the maximum amount of money you can get back的表述，所以只需要得到能得到的最大值就可以了，不需要统计负数的情况所以只需要统计收钱的情况，付钱的情况不用统计了。若只统计一张券乘以一件商品价格的结果为正数的情况，就分为两种： 券值为正，商品价格为正，面值最大的券需要乘以价格最高的商品，就能得到最大的结果。 券值为负，商品价格为负，面值最小（负数）的券需要乘以价格最低（负数）的商品，就能得到最大的结果。 利用两个数组来分别存储券值和商品价格，按照大小排序后，开始相乘，计算最终结果。注意，升序和降序不影响结果，但需要两种情况需要分开处理。 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int Nc, Np, coupon[MAXN] = &#123;0&#125;, product[MAXN] = &#123;0&#125;; scanf("%d", &amp;Nc); for(int i = 0; i &lt; Nc; i++) &#123; scanf("%d", &amp;coupon[i]); &#125; scanf("%d", &amp;Np); for(int i = 0; i &lt; Np; i++) &#123; scanf("%d", &amp;product[i]); &#125; sort(coupon, coupon + Nc); sort(product, product + Np); int i = 0, j, ans = 0; while(i &lt; Nc &amp;&amp; i &lt; Np &amp;&amp; coupon[i] &lt; 0 &amp;&amp; product[i] &lt; 0) &#123; ans += coupon[i] * product[i]; i++; &#125; i = Nc - 1; j = Np - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; coupon[i] &gt; 0 &amp;&amp; product[j] &gt; 0) &#123; ans += coupon[i] * product[j]; i--, j--; &#125; printf("%d\n", ans); return 0;&#125; 贴个 C++ 版：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c1, p1;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; c2, p2;int main() &#123; int nc, np, tmp; cin &gt;&gt; nc; for(int i = 0; i &lt; nc; i++) &#123; cin &gt;&gt; tmp; if(tmp &lt; 0) c1.push(tmp); if(tmp &gt; 0) c2.push(tmp); &#125; cin &gt;&gt; np; for(int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; tmp; if(tmp &lt; 0) p1.push(tmp); if(tmp &gt; 0) p2.push(tmp); &#125; long long ans = 0; while(!c1.empty() &amp;&amp; !p1.empty()) &#123; int ctmp = c1.top(); c1.pop(); int ptmp = p1.top(); p1.pop(); ans += ctmp * ptmp; &#125; while(!c2.empty() &amp;&amp; !p2.empty()) &#123; int ctmp = c2.top(); c2.pop(); int ptmp = p2.top(); p2.pop(); ans += ctmp * ptmp; &#125; cout &lt;&lt; ans; return 0;&#125; 粗略分析一下，堆的时间复杂度应该优于排序，同样需要 $O(n)$ 的存储空间，不过极端情况下，二者应该差不多。另外，其实可以在最后的结果ans这里挖坑，故意弄成溢出的情况，因为题目只说了保证给的数组不超过 $2^{30}$。 1038 Recover the Smallest NumberAnalysis题目会给一些数字，要求将给定的所有数字“拼接”起来，最终得到一个组合数，这个数字要比按照其他方式组合得到的结果小。 由于不能打乱给定的每个数字的数位顺序，所以一般会想到直接按照字典序比较每个数字的大小，然后让小的的在前面，大的在后面。但要注意，如果数字32, 321，按字典序大小排列后的组合数是32321，此时存在更小的结果32132，所以不能单纯的按照这种思路进行。 对于32, 321这两个数字而言，按照上面的结果：32132 &lt; 32321，从字符串的角度出发，假设a = 32, b = 321，则有ba &lt; ab，这样就可以在两个数中找出“拼接”出的最小数了。按照这种思路，对每一个数字（以字符串形式存储）都这样排序，最后逐个输出的结果就是题目要求的最小数字了。 确定要用字符串了后，直接使用STL内的string类可以很方便的对字符串进行操作。 注意，当输入的全部为0时，需要特判输出0。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;string str[MAXN];bool cmp(string a, string b);int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += str[i]; &#125; while(ans.size() != 0 &amp;&amp; ans[0] == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.size() == 0) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans; &#125; return 0;&#125;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125; 又写了一遍：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;string&gt; strs; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n ; i++) &#123; string tmp; cin &gt;&gt; tmp; strs.push_back(tmp); &#125; sort(strs.begin(), strs.end(), [](string &amp;a, string &amp;b) &#123; return a + b &lt; b + a; &#125;); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += strs[i]; &#125; while(ans.length() != 0 &amp;&amp; *ans.begin() == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.length() == 0) cout &lt;&lt; "0"; else cout &lt;&lt; ans; return 0;&#125; 这个题的贪心策略就是局部最优，然后达到的全局最优。 1039 Course List for StudentAnalysis题目大意是给定课程数目和每门课程参加的学生姓名，当用学生姓名查找时，输出该名学生所有的课程。 根据题目要求，需要保存每名学生的选课信息，课程都是用数字代替的，所以使用数组就可以满足需求。由于需要按序输出每名学生的课程编号，所以需要对每名学生的课程编号进行排序；并且，还需要先输出该名学生选课的总数。综合考虑后，使用vector来保存数据比较合适。另外为了便于查找，采用散列的思想，将学生的姓名转换为数字，作为下标来保存数据。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010;const int M = 26 * 26 * 26 * 10 + 1;vector&lt;int&gt; selectCourse[M];int getID(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) &#123; id = id * 26 + (name[i] - 'A'); &#125; id = id * 10 + (name[3] - '0'); return id;&#125;int main(int argc, char const *argv[]) &#123; char name[5]; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; int course, x; scanf("%d %d", &amp;course, &amp;x); for(int j = 0; j &lt; x; j++) &#123; scanf("%s", name); int id = getID(name); selectCourse[id].push_back(course); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%s", name); int id = getID(name); sort(selectCourse[id].begin(), selectCourse[id].end()); printf("%s %d", name, selectCourse[id].size()); for(int j = 0; j &lt; selectCourse[id].size(); j++) &#123; printf(" %d", selectCourse[id][j]); &#125; putchar('\n'); &#125; return 0;&#125; 现在时间限制放宽到了600ms，所以可以放心大胆的用 map、cin 和 cout 了：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;unordered_map&gt; #include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;unordered_map&lt;string, vector&lt;int&gt;&gt; stu;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; string name; while(k--) &#123; int cid, amount; cin &gt;&gt; cid &gt;&gt; amount; for(int i = 0; i &lt; amount; i++) &#123; cin &gt;&gt; name; stu[name].push_back(cid); &#125; &#125; while(n--) &#123; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; ' ' &lt;&lt; stu[name].size(); sort(stu[name].begin(), stu[name].end()); for(int &amp;i: stu[name]) &#123; cout &lt;&lt; ' ' &lt;&lt; i; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1040 Longest Symmetric StringAnalysis题目大意是给定一个字符串，找出其中的最长回文子串。此题并没有设置超时测试点，直接使用暴力解法可以过。不过，这类最长公共子串（Longest Palindromic Substring）的题目，还有另外一种思路——动态规划。 CodeViolent Solution123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;bool palindrome(char *s1, char *s2) &#123; bool flag = true; for(; s1 &lt; s2; s1++, s2--) &#123; if(*s1 != *s2) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main(int argc, char const *argv[]) &#123; char str[maxn]; fgets(str, maxn, stdin); char *p1, *p2; int max_len = 0, temp; for(p1 = str; *p1 != '\0'; p1++) &#123; for(p2 = p1 + 1; *p2 != '\0'; p2++) &#123; if(*p1 == *p2) &#123; temp = p2 - p1; if(temp &lt;= max_len) continue; else if(palindrome(p1, p2)) max_len = temp; &#125; &#125; &#125; printf("%d", max_len + 1); return 0;&#125; DP123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;char str[maxn];int dp[maxn][maxn];int main(int argc, char const *argv[]) &#123; fgets(str, maxn, stdin); int len = strlen(str), ans = 1; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; len; i++) &#123; dp[i][i] = 1; if(i &lt; len - 1) &#123; if(str[i] == str[i + 1]) &#123; dp[i][i + 1] = 1; ans = 2; &#125; &#125; &#125; for(int l = 3; l &lt;= len; l++) &#123; for(int i = 0; i + l - 1 &lt; len; i++) &#123; int j = i + l - 1; if(str[i] == str[j] &amp;&amp; dp[i + 1][j - 1] == 1) &#123; dp[i][j] = 1; ans = l; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 Be UniqueAnalysis根据题目要求，最先猜到只出现一次的数字就赢了，所以得先按照顺序读入每个数，同时统计每个数字的出现次数。然后再按照输入顺序，检查每个数字的出现次数，若出现一次即为赢的那个数字。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int N, Num[MAXN] = &#123;0&#125;, times[MAXN] = &#123;0&#125;; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Num[i]); times[Num[i]]++; &#125; int i; for(i = 0; i &lt; N; i++) &#123; if(times[Num[i]] == 1) &#123; printf("%d", Num[i]); break; &#125; &#125; if(i == N) &#123; printf("None"); &#125; return 0;&#125; 1042 Shuffling MachineAnalysis根据题目的例子，读懂题目，注意仅在一个数组内交换元素会 WA ，要用两个数组进行倒换才能得到正确的结果。当然，也可以在每次倒换完成之后，将得到的序列直接放到结果数组中，这样就不用在判断了。 需要输出的字符串可以先写个循环输出，然后从黑框框中复制粘贴要初始化的二维数组中。如果不想这么干也可以只保存符号信息，也就是1char cards[6] = "SHCDJ"; 这样，数组中数字跟卡片类型下标的对应关系就是index = (arr[i] - 1) % 13，那序号呢？实际上也是差不多的，也就是(arr[i] - 1) % 13 + 1，所以就可以得到第二个版本的代码。 Codeversion 112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;char playcards[55][5] = &#123; " ", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "J1", "J2",&#125;;int main() &#123; int k, arr[55], brr[55], order[55], flag = 1; cin &gt;&gt; k; for(int i = 1; i &lt;= 54; i++) &#123; cin &gt;&gt; order[i]; brr[i] = i; &#125; while(k--) &#123; if(flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; arr[order[i]] = brr[i]; &#125; flag = 0; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; brr[order[i]] = arr[i]; &#125; flag = 1; &#125; &#125; if(!flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[arr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[brr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; version 2123456789101112131415161718192021222324#include &lt;cstdio&gt;int k, shuffle[55], tmp1[55], tmp2[55];char cards[5] = &#123;'S', 'H', 'C', 'D', 'J'&#125;;int main() &#123; scanf("%d", &amp;k); for(int i = 1; i &lt;= 54; i++) &#123; scanf("%d", &amp;shuffle[i]); tmp2[i] = i; &#125; for(int i = 1; i &lt;= k; i++) &#123; for(int i = 1; i &lt;= 54; i++) &#123; tmp1[shuffle[i]] = tmp2[i]; &#125; for(int i = 1; i &lt;= 54; i++) &#123; tmp2[i] = tmp1[i]; &#125; &#125; for(int i = 1; i &lt;= 54; i++) &#123; printf("%c%d", cards[(tmp1[i] - 1) / 13] , (tmp1[i] - 1) % 13 + 1); if(i != 54) printf(" "); &#125; return 0;&#125; 1043 Is It a Binary Search TreeAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int data; node *left, *right; &#125;;void insert(node *&amp;root, int data) &#123; if(root == NULL) &#123; root = new node; root-&gt;data = data; root-&gt;left = root-&gt;right = NULL; return; &#125; if(data &lt; root-&gt;data) insert(root-&gt;left, data); else insert(root-&gt;right, data);&#125;void preorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preorder(root-&gt;left, vi); preorder(root-&gt;right, vi);&#125;void preordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preordermirror(root-&gt;right, vi); preordermirror(root-&gt;left, vi);&#125;void postorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postorder(root-&gt;left, vi); postorder(root-&gt;right, vi); vi.push_back(root-&gt;data);&#125;void postordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postordermirror(root-&gt;right, vi); postordermirror(root-&gt;left, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, preM, post, postM;int main(int argc, char const *argv[]) &#123; int n, data; node *root = NULL; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); origin.push_back(data); insert(root, data); &#125; preorder(root, pre); preordermirror(root, preM); postorder(root, post); postordermirror(root, postM); if(origin == pre) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if(i &lt; post.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else if(origin == preM) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; postM.size(); i++) &#123; cout &lt;&lt; postM[i]; if(i &lt; postM.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else &#123; cout &lt;&lt; "NO\n"; &#125; return 0;&#125; 1044 Shopping in MarsAnalysis先分析题目输入，第一行给定两个数字，第一个数字代表一条“链”上钻石的数量，第二个数字则代表需要支付的钱；第二行依次给出“链”上每颗钻石的对应的价值（用于支付）。 然后，题目要求从这条“链”中找出能刚好用于支付（钻石的价值和与待支付的钱相等）的“钻石序列”，当然，若是没有完全相等的情况，找出刚好大于待支付的钱的钻石序列，也是可以的。 将本体的题意抽象出来就是，给定一个序列，找出这个序列中连续子序列和刚好大于或等于给定数字的所有子序列（如果有相等的情况，就不需要再找大于的情况）。 按照这样的思路，可以使用一个sum数组来保存连续的子序列和（每次累加即可），这样在i和j之间的子序列和就是sum[j] - sum[i - 1]，这个思想与 1046 是一致的。这样，要做的事情就是从sum这个数组中找出满足条件的序列了。同时注意到，由于sum数组是累加得出的，所以一定是严格递增的，也就可以使用二分查找来找这个值。 注意题目的条件：It is guaranteed that the total value of diamonds is sufficient to pay the given amount.，说明肯定会有解，那么对应的也就只有两种情况： 能找到相等的序列，此时由于序列本身就是严格递增的 只能找到刚好大于给定值的序列，此时需要用一个变量nearS来保存刚好大于给定值的连续子序列和 找到合理的值后，按照这个值输出即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int sum[MAXN];int n, S, nearS = 100000000 + 10;int UpperBound(int L, int R, int x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;S); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;sum[i]); sum[i] += sum[i - 1]; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + S); if(sum[j - 1] - sum[i - 1] == S) &#123; nearS = S; break; &#125; else if(j &lt;= n &amp;&amp; sum[j] - sum[i - 1] &lt; nearS) &#123; nearS = sum[j] - sum[i - 1]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + nearS); if(sum[j - 1] - sum[i - 1] == nearS) &#123; printf("%d-%d\n", i, j - 1); &#125; &#125; return 0;&#125;int UpperBound(int L, int R, int x) &#123; int left = L, right = R, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(sum[mid] &gt; x) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 原来使用二分 + 前缀和的思路做的，现在又写了一下，思路是滑动窗口 + 前缀和：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; ans1, ans2;const int maxn = 100000 + 5;int arr[maxn];long long prefixsum[maxn];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; prefixsum[1] = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; prefixsum[i + 1] = prefixsum[i] + arr[i]; &#125; int left = 1, right = 2, minimum = 1000; while(left &lt;= n) &#123; while(right &lt;= n + 1) &#123; if(prefixsum[right] - prefixsum[left] &lt; m) right++; else if(prefixsum[right] - prefixsum[left] == m) &#123; if(right &gt; left) ans1.push_back(&#123;left, right - 1&#125;); else if(right == left) ans1.push_back(&#123;left - 1, right - 1&#125;); break; &#125; else if(prefixsum[right] - prefixsum[left] &gt; m) &#123; int tmp = prefixsum[right] - prefixsum[left] - m; if(tmp &lt; minimum) &#123; ans2.clear(); minimum = tmp; if(right &gt; left) ans2.push_back(&#123;left, right - 1&#125;); else if(right == left) ans2.push_back(&#123;left - 1, right - 1&#125;); &#125; else if(tmp == minimum) &#123; if(right &gt; left) ans2.push_back(&#123;left, right - 1&#125;); else if(right == left) ans2.push_back(&#123;left - 1, right - 1&#125;); &#125; break; &#125; &#125; left++; &#125; if(ans1.size() != 0) &#123; sort(ans1.begin(), ans1.end()); for(auto p: ans1) &#123; cout &lt;&lt; p.first &lt;&lt; '-' &lt;&lt; p.second &lt;&lt; endl; &#125; &#125; else &#123; sort(ans2.begin(), ans2.end()); for(auto p: ans2) &#123; cout &lt;&lt; p.first &lt;&lt; '-' &lt;&lt; p.second &lt;&lt; endl; &#125; &#125; return 0;&#125; 这个题的测试用例中没有 0 的存在...弱了不少 1045 Favorite Color StripeAnalysis题目大意：用不同的数字表示不同的颜色，一共有 220 种颜色，给定一串数字序列，作为 Eva 喜欢的颜色种类（越靠后越喜欢），然后在给定一串数字序列。现在从中挑出 Eva 喜欢的所有数字，并且要求按照给定的顺序进行排列，求出这个最大的长度。 如果直接使用暴力解法，定会超时，要想完美解决这个问题，思考的方向有两个，但都包含了动态规划（Dynamic Programming）的思想： 从最长非递减序列的角度思考 从最长公共子串的角度思考 CodeLIS123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int stripe[maxn], hashTable[maxc], dp[maxn];int main(int argc, char const *argv[]) &#123; int n, m, x; cin &gt;&gt; n &gt;&gt; m; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; hashTable[x] = i; &#125; int l, num = 0; cin &gt;&gt; l; for(int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; stripe[num++] = hashTable[x]; &#125; int ans = -1; for(int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for(int j = 0; j &lt; i; j++) &#123; if(stripe[j] &lt;= stripe[i] &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; &#125; &#125; ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans; return 0;&#125; LCS123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int A[maxc], B[maxn], dp[maxc][maxn];int main(int argc, char const *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; A[i]; &#125; int l; cin &gt;&gt; l; for(int i = 1; i &lt;= l; i++) &#123; cin &gt;&gt; B[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; dp[i][0] = 0; &#125; for(int j = 1; j &lt;= l; j++) &#123; dp[0][j] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= l; j++) &#123; int Max = max(dp[i - 1][j], dp[i][j - 1]); if(A[i] == B[j]) &#123; dp[i][j] = Max + 1; &#125; else &#123; dp[i][j] = Max; &#125; &#125; &#125; cout &lt;&lt; dp[m][l]; return 0;&#125; 1046 Shortest DistanceAnalysis题目意思很明确，给你一个“环”形地图，问你从这里到那里怎么走最近。根据题目意思，一般都有两种走法，一种顺着环走，一种逆着环走，找出二者的最小值即可。 一般而言，我们分别找出其中两次的值，进行比较后输出最小值即可。不过由于地名是按照数字给出的，可能会出现起始点的数字大于终点的情况，此时最好交换二者的值，或者分情况讨论。 另外，还可以发现，如果求出了一种走法，那么按照环形地图的特点，利用总距离减去求得的不就得到另一种走法的距离了吗？ 把握住上面的点后，可以通过 0 和 1 两个测试点了，第三个测试点会因为超时无法通过。 在仔细分析一下，如果一开始用一个数组Dis[MAXN]，按照顺序表示1号地点到达其他地点的距离，那么对于每一次查询的start和end，其距离就是Dis[end - 1] - Dis[start - 1]。以样例为例，可以得到数组（下标从1开始）Dis[6] = {0, 1, 3, 7, 21, 30}，此时如果要计算5到2的距离，根据思路就是：Dis[5 - 1] - Dist[2 - 1] = 21 - 1 = 20，这就是按顺序方向从2到5的距离。 此法恐怖之极在于原本时间复杂度为 $O(n)$ 的查找一下子就变为 $O(1)$ 了。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int M, N, Exits[MAXN] = &#123;0&#125;, Dis[MAXN], Sum_D = 0, src, dst; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Exits[i]); Sum_D += Exits[i]; Dis[i] = Sum_D; &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d %d", &amp;src, &amp;dst); if(src &gt; dst) &#123; swap(src, dst); &#125; int temp = Dis[dst - 1] - Dis[src - 1]; printf("%d\n", temp &lt; (Sum_D - temp) ? temp : (Sum_D - temp)); &#125; return 0;&#125; 1047 Student List for CourseAnalysis此题与1039的题目背景完全一样，输入与输出正好相反，思路也是类似的。只是本题，不需要在利用散列了。 这个题也可以用string来做，但是耗费的时间会长一些，用数字来代替字符串的比较会方便快捷很多。不过这个题，用string也可以过。 Codeuse number123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40010;const int maxc = 2510;char name[maxn][5];vector&lt;int&gt; course[maxc];bool cmp(int a, int b) &#123; return strcmp(name[a], name[b]) &lt; 0;&#125;int main(int argc, char const *argv[]) &#123; int n, k, c, courseID; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name[i], &amp;c); for(int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;courseID); course[courseID].push_back(i); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; printf("%d %d\n", i, course[i].size()); sort(course[i].begin(), course[i].end(), cmp); for(int j = 0; j &lt; course[i].size(); j++) &#123; printf("%s\n", name[course[i][j]]); &#125; &#125; return 0;&#125; use string1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int K = 2500 + 5;vector&lt;string&gt; course[K];int main() &#123; int n, k, course_num; scanf("%d %d", &amp;n, &amp;k); char name[5]; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name, &amp;course_num); for(int j = 0; j &lt; course_num; j++) &#123; int course_id; scanf("%d", &amp;course_id); course[course_id].push_back(name); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; sort(course[i].begin(), course[i].end()); printf("%d %d\n", i, course[i].size()); for(int j = 0; j &lt; course[i].size(); j++) &#123; cout &lt;&lt; course[i][j] &lt;&lt; '\n'; &#125; &#125; return 0;&#125; 1048 Find CoinsAnalysis给定硬币种类和面值，按照题目要求输出和与题目相等两枚硬币，要求V1的面值小于等于V2。在输入时，利用散列的思路，先将每一枚硬币的个数统计下来。然后，利用sort将面值按升序排序，这样方便查找。输出时注意以下几点： V1和V2相等时，要判断这枚硬币时候是否有两枚 当V1和V2相等时，就已经是题目要求的最后一种情况了，若这种情况都不合条件，就没必要再继续查找下去了，所以使用一个标识flag来协助输出 注意所使用数组的下标，以免调用sort时出错 只要V1最小的那一组就行了，所以要在循环内调用break Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int main(int argc, char const *argv[]) &#123; int N, M, coins[MAXN]; scanf("%d %d", &amp;N, &amp;M); int value[MAXN] = &#123;0&#125;; for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;coins[i]); value[coins[i]]++; &#125; sort(coins + 1, coins + N + 1); int i, v1, v2; bool flag = false; for(i = 1; i &lt;= N; i++) &#123; v1 = coins[i]; v2 = M - v1; if(value[v1] &amp;&amp; value[v2]) &#123; if(v1 == v2 &amp;&amp; value[v1] != 2) &#123; break; &#125; printf("%d %d", v1, v2); flag = true; break; &#125; &#125; if(!flag) &#123; printf("No Solution"); &#125; return 0;&#125; 有了 C++ 的 map 就不需要在排序了：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, tmp; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; ht; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; ht[tmp]++; &#125; bool flag = false; for(auto it = ht.begin(); it != ht.end(); it++) &#123; int diff = m - it-&gt;first; if(diff == it-&gt;first) &#123; if(it-&gt;second &gt;= 2) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;first; flag = true; break; &#125; &#125; else &#123; if(ht.count(diff)) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; diff; flag = true; break; &#125; &#125; &#125; if(!flag) cout &lt;&lt; "No Solution"; return 0;&#125; 再贴个二分的思路：12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr.begin(), arr.end()); bool flag = false;; for(auto v1 = arr.begin(); v1 != arr.end(); v1++) &#123; auto v2 = lower_bound(arr.begin(), arr.end(), m - *v1); if(v1 != v2 &amp;&amp; *v1 + *v2 == m) &#123; cout &lt;&lt; *v1 &lt;&lt; ' ' &lt;&lt; *v2; flag = true; break; &#125; &#125; if(!flag) cout &lt;&lt; "No Solution"; return 0;&#125; 1049 Counting OnesAnalysis题意很简单，给定一个数字 n，算出从 1 到 n 所有的数字中 1 的个数和。 Code这个题原来的时间限制是 10 ms，现在改成了 400 ms，所以直接暴力也能有 22 分。不过要想拿到满分，需要从数学的角度来分类讨论一下。对于一个数的每一位数字 $mid$ 而言： 若 $mid$ 为 0，要使 $mid$ 一定能取到 1，那么其左边的数字只能取 $[0, n / 10 ^ {k+1} - 1]$，其中 k 是右边数字的位数，而其右边的数则可以取到 $[0, 10^k - 1]$，那么总共能取到的数字就是 $n / 10 ^ {k+1} \times 10^k$。 若 $mid$ 为 1，其左边的数字只能取 $[0, n / 10 ^ {k+1}]$，其中 $k$ 是右边数字的位数。此时，当左边数字取 $[0, n / 10 ^ {k+1} - 1]$ 时，右边数字可以取 $[0, 10 ^ k - 1]$；当左边数字取 $n / 10 ^ {k+1}$ 时，右边数字只能取 $[0, n \% 10^{k}]$。那么总共能取到的数字就是 $n / 10 ^ {k+1} \times 10^k + n % 10^{k} + 1$。 若 $mid$ 大于 1，左边能取到的数字就是 $[0, n / 10 ^ {k+1}]$，右边能取到的数字就是 $[0, 10 ^ k - 1]$，那么总共能取到的数字就是 $(n / 10 ^ {k+1} + 1) \times 10^k$。 所有数字中 1 的个数就是依次拆分数位分类讨论后的总和。12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int n, ans = 0; cin &gt;&gt; n; int mask = 1, left, mid, right; while(n / mask != 0) &#123; left = n / (mask * 10); mid = n / mask % 10; right = n % mask; if(mid == 0) ans += left * mask; else if(mid == 1) ans += left * mask + right + 1; else ans += (left + 1) * mask; mask *= 10; &#125; cout &lt;&lt; ans; return 0;&#125; 这个题思路不是那么好想。 1050 String SubtractionAnalysis利用散列的思想来处理，先遍历第一个字符串统计其中所有字符的出现次数（也可以只用true或false来区分），然后遍历第二个字符串，将同时出现在两个字符串内的字符的次数标记为0，然后按照第一个字符串的顺序，输出标记不是0的字符即可。 Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int times[128] = &#123;0&#125;; char *p = str2; while(*p != '\0') &#123; times[*p++] = 1; &#125; p = str1; while(*p != '\0') &#123; if(!times[*p]) &#123; putchar(*p); &#125; p++; &#125; return 0;&#125; 1051 Pop SequenceAnalysis题目大意是给定一个栈的容量、出战序列长度和可能的出栈序列，判断在当前栈的长度下，出栈序列是否合法，若是，输出YES，反之，输出NO。 按照题目的要求模拟栈的操作即可，使用 C++ 的stack容器可以很方便的完成这个需求。 注意每次判断要让栈清空，不然会影响判断。不过与其反复清空栈，不如直接新建一个。 Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 5;int seq[maxn] = &#123;0&#125;;int main() &#123; int n, m, k, tmp; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; while(k--) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; int index = 1; bool flag = true; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; st.push(i); if(st.size() &gt; m) &#123; flag = false; break; &#125; while(!st.empty() &amp;&amp; st.top() == seq[index]) &#123; st.pop(); index++; &#125; &#125; if(st.empty() &amp;&amp; flag) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; 1052 Linked List SortingAnalysis题目背景是属于链表的应用，实际是模拟链表的操作，使用静态链表模拟较为方便。 静态链表需要借助散列的概念，借助结构数组，使用题目给定的地址对应数组的下标，可以较为方便的存储结点值和下一个元素的地址。 题目要求的排序可以使用sort函数来完成，此时要注意由于题目可能会输入无效结点，所以需要增加一个flag来判断是否属于无效结点，这样sort函数才能将有效结点按序排好，并将无效结点排在最后一个有效结点的后面。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct Node &#123; int address, data, next; bool flag;&#125; node[maxn];bool cmp(Node a, Node b) &#123; if(a.flag == false || b.flag == false) &#123; return a.flag &gt; b.flag; &#125; else &#123; return a.data &lt; b.data; &#125;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int n, begin, address; scanf("%d %d", &amp;n, &amp;begin); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int count = 0, p = begin; while(p != -1) &#123; node[p].flag = true; count++; p = node[p].next; &#125; if(count == 0) &#123; printf("0 -1"); &#125; else &#123; sort(node, node + maxn, cmp); printf("%d %05d\n", count, node[0].address); for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) &#123; printf("%05d %d %05d\n", node[i].address, node[i].data, node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", node[i].address, node[i].data); &#125; &#125; &#125; return 0;&#125; 1053 Path of Equal WeightAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1054 The Dominant ColorAnalysis题目大意是给定一个矩阵，找出其中超过矩阵一半元素个数的值。题目保证测试样例中会有答案，也就是说，有一半的矩阵元素都是同一个数字，那么毫无疑问，这个元素的出现次数一定是这个矩阵所有元素出现次数的最大值，所以直接查找最大值即可。 由于像素点是由0-24位数字字符组成，所以需要将矩阵内元素当作字符串对待，同时需要建立与次数的唯一映射，使用 C++ 的map容器可以很方便的完成这个操作。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; color;int main(int argc, char const *argv[]) &#123; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; temp = n * m; getchar(); while(temp--) &#123; string s; cin &gt;&gt; s; color[s]++; &#125; temp = n * m; map&lt;string, int&gt;::iterator max = color.begin(); map&lt;string, int&gt;::iterator it = color.begin(); for(; it != color.end(); it++) &#123; if(it-&gt;second &gt; max-&gt;second) &#123; max = it; &#125; &#125; cout &lt;&lt; max-&gt;first; return 0;&#125; 用 C++11 标准写简单一点：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; ht;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tmp; ht[tmp]++; &#125; &#125; int ans, condition = (m * n) / 2; for(auto &amp;p: ht) &#123; if(p.second &gt; condition) ans = p.first; &#125; cout &lt;&lt; ans; return 0;&#125; 1055 The World’s RichestAnalysis先按照题目要求排好序，然后按照题目给定的年龄区间进行输出，注意没有符合的输出时，需要输出None。 此时，考虑到题目给的条件$M (\le 100)$，说明对于同一个年龄的数据，最多只输出100项。所以可以新建一个数组，然后按照排好序的序列，顺序保存每个年龄的数据，但只保存100个，这样在查找的时候能极大的节约时间。 尽管这道题在甲级题库内的时间限制是500ms，考试的时候说不定就是200ms了，要注意用最优解法。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int Age[MAXN] = &#123;0&#125;;struct people&#123; char name[10]; int age, worth;&#125; peo[MAXN], valid[MAXN];bool cmp(people a, people b);int main(int argc, char const *argv[]) &#123; int N, K; scanf("%d %d", &amp;N, &amp;K); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", peo[i].name, &amp;peo[i].age, &amp;peo[i].worth); &#125; sort(peo, peo + N, cmp); int validNum = 0; for(int i = 0; i &lt; N; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; valid[validNum++] = peo[i]; &#125; &#125; int M, Amin, Amax; for(int i = 1; i &lt;= K; i++) &#123; bool flag = false; scanf("%d %d %d", &amp;M, &amp;Amin, &amp;Amax); printf("Case #%d:\n", i); for(int j = 0; j &lt; validNum &amp;&amp; M; j++) &#123; if(Amin &lt;= valid[j].age &amp;&amp; valid[j].age &lt;= Amax) &#123; printf("%s %d %d\n", valid[j].name, valid[j].age, valid[j].worth); M--; flag = true; &#125; &#125; if(!flag) &#123; printf("None\n"); &#125; &#125; return 0;&#125;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return strcmp(a.name, b.name) &lt; 0;&#125; 贴个 C++ 版：12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct people &#123; string name; int age, worth;&#125; peo[maxn], output[maxn]; int Age[maxn] = &#123;0&#125;;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; peo[i].name &gt;&gt; peo[i].age &gt;&gt; peo[i].worth; &#125; sort(peo, peo + n, cmp); int index = 0; for(int i = 0; i &lt; n; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; output[index++] = peo[i]; &#125; &#125; int M, amin, amax; for(int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cin &gt;&gt; M &gt;&gt; amin &gt;&gt; amax; int cnt = M; for(int i = 0; i &lt; index; i++) &#123; if(amin &lt;= output[i].age &amp;&amp; output[i].age &lt;= amax) &#123; cout &lt;&lt; output[i].name &lt;&lt; ' ' &lt;&lt; output[i].age &lt;&lt; ' ' &lt;&lt; output[i].worth &lt;&lt; endl; if(--cnt == 0) break; &#125; &#125; if(cnt == M) cout &lt;&lt; "None" &lt;&lt; endl; &#125; return 0;&#125; cin 和 cout 确实比 scanf 和 printf 慢了许多... 1056 Mice and RiceAnalysis题目背景是一个叫做 Mice and Rice 的游戏，根据题目的描述可以知道，体重数字最大的老鼠就是胜利的老鼠，并且在本题中，老鼠之间的比赛需要分组进行，分组大小会给出。注意all the mice left will be put into the last group是指，由于可能存在最后一组老鼠少于分组大小的情况，默认将剩余的老鼠全部加入到下一轮比赛中。依次进行每一轮比赛，直至最后得到冠军老鼠，并输出所有老鼠的排名。 按照题目的意思，题目一开始会给定老鼠总数和分组大小，所以可以直接得到这一轮的分组数；同理，每一轮的分组数都可以这样得到。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;struct mouse&#123; int weight; int r;&#125; mouse[maxn];int main(int argc, char const *argv[]) &#123; int np, ng, order; scanf("%d %d", &amp;np, &amp;ng); for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;mouse[i].weight); &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;order); q.push(order); &#125; int temp = np, group; while(q.size() != 1) &#123; if(temp % ng == 0) group = temp / ng; else group = temp / ng + 1; for(int i = 0; i &lt; group; i++) &#123; int k = q.front(); for(int j = 0; j &lt; ng; j++) &#123; if(i * ng + j &gt;= temp) break; int front = q.front(); if(mouse[front].weight &gt; mouse[k].weight) &#123; k = front; &#125; mouse[front].r = group + 1; q.pop(); &#125; q.push(k); &#125; temp = group; &#125; mouse[q.front()].r = 1; for(int i = 0; i &lt; np; i++) &#123; printf("%d", mouse[i].r); if(i &lt; np - 1) putchar(' '); &#125; return 0;&#125; 1058 A+B in HogwartsAnalysis题目意思很简单，给你两个在霍格沃茨本地使用的货币数量，加起来就好。就跟生活中$100 + 150 = 250$块一样哈。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;struct money&#123; int g, k, s;&#125; A, B, Result;int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;A.g, &amp;A.s, &amp;A.k, &amp;B.g, &amp;B.s, &amp;B.k); Result.g = A.g + B.g; Result.k = A.k + B.k; Result.s = A.s + B.s; if(Result.k &gt;= 29) &#123; Result.s += (Result.k / 29); Result.k %= 29; &#125; if(Result.s &gt;= 17) &#123; Result.g += (Result.s / 17); Result.s %= 17; &#125; printf("%d.%d.%d\n", Result.g, Result.s, Result.k); return 0;&#125; 贴个简单版：k1 和 k2 的和可能会超过 int 的范围，所以要使用 long long。1234567891011121314#include &lt;cstdio&gt;int main() &#123; long long g1, s1, k1, g2, s2, k2; scanf("%lld.%lld.%lld %lld.%lld.%lld", &amp;g1, &amp;s1, &amp;k1, &amp;g2, &amp;s2, &amp;k2); k1 += s1 * 29 + g1 * 29 * 17; k2 += s2 * 29 + g2 * 29 * 17; k1 += k2; g1 = k1 / 29 / 17; s1 = k1 / 29 % 17; k1 = k1 % 29; printf("%lld.%lld.%lld\n", g1, s1, k1); return 0;&#125; 1059 Prime FactorsAnalysis题目大意是给定一个正整数，用质数对其进行分解，也即质因子分解。 既然需要用到质数，与其一个一个的判断，不如一开始先将素数表打印好，此题给定的数为long int，则素数表为$10^5$即可。 接着定义一个结构体数组，保存质因子和其个数。对于long int型的数而言，2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29就已经溢出了，所以结构体数组的大小取10以上即可。 从小到大枚举质因子，如果能整除给定的数，就进入循环，让这个数不断的整除它，从而计算这个质因子的数目。注意，n = 1时，需要特判输出1=1。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100010;bool isPrime(int n) &#123; if(n &lt;= 1) return false; int sqr = sqrt(n); for(int i = 2; i &lt;= sqr; i++) &#123; if(n % i == 0) return false; &#125; return true;&#125;int prime[maxn], pNum = 0;void filterPrime() &#123; for(int i = 1; i &lt; maxn; i++) &#123; if(isPrime(i) == true) &#123; prime[pNum++] = i; &#125; &#125;&#125;struct factor&#123; int x, cnt;&#125; fac[11];int main(int argc, char const *argv[]) &#123; filterPrime(); int n, num = 0; scanf("%d", &amp;n); if(n == 1) printf("1=1"); else &#123; printf("%d=", n); int sqr = sqrt(n); for(int i = 0; i &lt; pNum &amp;&amp; prime[i] &lt;= sqr; i++) &#123; if(n % prime[i] == 0) &#123; fac[num].x = prime[i]; fac[num].cnt = 0; while(n % prime[i] == 0) &#123; fac[num].cnt++; n /= prime[i]; &#125; num++; &#125; if(n == 1) break; &#125; if(n != 1) &#123; fac[num].x = n; fac[num++].cnt = 1; &#125; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0) putchar('*'); printf("%d", fac[i].x); if(fac[i].cnt &gt; 1) &#123; printf("^%d", fac[i].cnt); &#125; &#125; &#125; return 0;&#125; 贴个 C++ 版的模拟做法：1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;map&lt;long long, int&gt; factors;bool isprime(long long n) &#123; if(n &lt;= 1) return false; else &#123; for(long long i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true; &#125;&#125;int main() &#123; long long n, tmp, sqr; scanf("%lld", &amp;n); printf("%lld=", n); if(n == 1) printf("%lld", n); else &#123; tmp = n; sqr = sqrt(n); for(long long fa = 2; fa &lt;= sqr; fa++) &#123; if(tmp == 1) break; if(isprime(fa)) &#123; while(tmp % fa == 0) &#123; factors[fa]++; tmp /= fa; &#125; &#125; &#125; if(factors.size() == 0) printf("%lld", n); else &#123; auto it = factors.begin(); while(it != factors.end()) &#123; printf("%lld", it-&gt;first); if(it-&gt;second != 1) printf("^%d", it-&gt;second); it++; if(it != factors.end()) printf("*"); &#125; &#125; &#125; return 0;&#125; 同样，一个数的最大因子不会超过它的算术平方根，所以循环边界直接用就好了。有了 map 之后，就可以很方便的统计质因子和对应的个数。 1060 Are They EqualAnalysis这道题考察字符串处理，使用STL内的string容器，并调用其中的一些方法，会十分方便。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string s, int &amp;e);int main(int argc, char const *argv[]) &#123; string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if(s3 == s4 &amp;&amp; e1 == e2) &#123; cout &lt;&lt; "YES 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; " 0." &lt;&lt; s4 &lt;&lt; "*10^" &lt;&lt; e2 &lt;&lt; endl; &#125; return 0;&#125;string deal(string s, int &amp;e) &#123; unsigned int k = 0; while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); &#125; if(s[0] == '.') &#123; s.erase(s.begin()); while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); e--; &#125; &#125; else &#123; while(k &lt; s.length() &amp;&amp; s[k] != '.') &#123; k++; e++; &#125; if(k &lt; s.length()) &#123; s.erase(s.begin() + k); &#125; &#125; if(s.length() == 0) &#123; e = 0; &#125; int num = 0; k = 0; string res; while(num &lt; n) &#123; if(k &lt; s.length()) &#123; res += s[k++]; &#125; else &#123; res += '0'; &#125; num++; &#125; return res;&#125; 1061 DatingAnalysis这道题与乙级题库的1014是一样的，不难，就是有些地方好像说的不太明确，比如，星期这个信息必须得是属于 $[A, G]$ 的大写字母才能可以进行判断... Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;char *Week[7] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1062 Talent and VirtueAnalysis此题与乙级题库 1015 一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student &#123; char id[10]; int scoreD, scoreC, sumDC, flag;&#125; stu[MAXN];int N, L, H, M = 0;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumDC = stu[i].scoreD + stu[i].scoreC; if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L) &#123; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= L) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else &#123; stu[i].flag = 4; &#125; M++; &#125; else &#123; stu[i].flag = 5; &#125; &#125; printf("%d\n", M); sort(stu, stu + N, cmp); for(int i = 0; i &lt; M; i++) &#123; printf("%s %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumDC != b.sumDC) return a.sumDC &gt; b.sumDC; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return strcmp(a.id, b.id) &lt; 0;&#125; 1063 Set SimilarityAnalysis题目大意是给定若干个集合，给出两个集合的“相似程度”。这里的“相似程度”是指两个集合交集的元素个数除以两个集合并集的元素个数的百分比，且没有重复元素。 按照题目背景，使用 STL 的set来处理这个问题比较方便，优点如下： set在存储数据时，会自动去除重复数据 set内元素的个数，可以直接使用set.size()得到 查找set内元素时，直接使用set.find(elements)即可 使用set读入所有输入数据后，开始查询。每次查询需要得到一个百分比，所以就需要求两个集合交集的元素个数和并集的元素个数。 具体方法是：遍历其中一个集合，令totalNum为另一个集合的元素个数，sameNum为相同元素的个数（初始化为0）。此时在另一个集合中查找当前遍历的集合中的元素，若存在，则sameNum++，反之则totalNum++，遍历结束后，需要的数字就算好了，接着相除得到百分比即可输出。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int MAXN = 50 + 5;set&lt;int&gt; st[MAXN];void compare(int x, int y) &#123; int totalNum = st[y].size(), sameNum = 0; for(set&lt;int&gt;::iterator it = st[x].begin(); it != st[x].end(); it++) &#123; if(st[y].find(*it) != st[y].end()) sameNum++; else totalNum++; &#125; printf("%.1lf%\n", sameNum * 100.0 / totalNum);&#125;int main(int argc, char const *argv[]) &#123; int n, m, k, temp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;m); for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;temp); st[i].insert(temp); &#125; &#125; scanf("%d", &amp;k); while(k--) &#123; int s1, s2; scanf("%d %d", &amp;s1, &amp;s2); compare(s1, s2); &#125; return 0;&#125; 写简单一点：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;set&gt; using namespace std;const int maxn = 50 + 5;set&lt;int&gt; st[maxn];int main() &#123; int n, m, k; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for(int j = 0; j &lt; m; j++) &#123; int tmp; cin &gt;&gt; tmp; st[i].insert(tmp); &#125; &#125; cin &gt;&gt; k; while(k--) &#123; int set1, set2, nc = 0, nt; cin &gt;&gt; set1 &gt;&gt; set2; nt = st[set2].size(); for(auto &amp;tmp: st[set1]) &#123; if(st[set2].count(tmp)) nc++; else nt++; &#125; printf("%.1lf%%\n", nc * 100.0 / nt); &#125; return 0;&#125; 1064 Complete Binary Search TreeAnalysis题目大意是给定结点个数和结点值，建立一颗完全二叉排序树（CBT），根据名称，可以知道这类树既有完全二叉树的性质，又有二叉排序树的性质。 经过上面的分析，使用结构数组建树就十分方便，对完全二叉树而言，数组的下标即代表结点之间的关系，所以直接使用整型数组即可，并且在数组的顺序就是层次遍历的序列。接着要解决的问题就是将结点值赋给结点，根据二叉排序树的性质，利用中序遍历即可完成这个需求。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int n, number[maxn], CBT[maxn], index = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); CBT[root] = number[index++]; inorder(root * 2 + 1);&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(1); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; CBT[i]; if(i &lt; n) cout &lt;&lt; ' '; &#125; return 0;&#125; 1065 A+B and C (64bit)Analysis这道题算是乙级题目1011 A+B 和 C的加强版了，题目给定的数据范围是$(-2^{63}, 2^{63})$，正好是64位带符号整型的数据范围，下面来分析可能出现的各种情况（只用对A和B之和分析就好）： A和B之和仍然在$(-2^{63}, 2^{63})$之内，可以直接与C进行判断 A和B之和大于$2^{63}$，此时会发生正溢出，且其值的范围为：$[-2^{63}, -2]$（溢出进位，符号为从0变为1，所以为负，剩下63位构成的数字就在这个范围内了）。 A和B之和小于$-2^{63}$，此时会发生负溢出，其值范围为：$[0, 2^{63})$（原理类似） 对应上述三种情况，按照实际规则进行比大小即可。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 以上是原来未更新测试数据之前的 AC 代码，现在只能拿到 16 分了，最后一个测试点无法通过。究其原因，其实是这个题目又开始玩文字游戏了，C 的范围是 $(2^{-63}, 2^{63})$，但 A 和 B 不是的，也就是说 A 和 B 的位数可能要超过 9223372036854775807。从这里开始，这个题考察的内容就不再是对数据溢出的判断了，那考察什么？考察的是cin和scanf 从输入流获取输入的差别，也不知道这样改是为了什么😓。至于cin和scanf有什么区别，得单独写文章总结，现在贴出 AC 的代码（其实就只是换掉了cin而已）：12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 看到这里，一上来就用cin的人，估计要被气吐血了。按照出题人的意图和这道题的分值而言，考察了溢出的相关知识就可以了。这样改了之后，还需要对库函数有一定的了解。当然，直接上来就用scanf的，当我没说。但针对这道题而言，还有一种做法，那就是选用更高精度的数据类型 long double，如下：1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; long double a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 在 C++11 标准中测试，long double的数据类型占了 16 个字节，能表示相当大的数了。 1066 Root of AVL TreeAnalysis题目大意给定一棵树的结点个数，再给定各个结点的值，建立一颗平衡二叉树（AVL），然后输出结点的值即可。 由于题目需要建立 AVL 树，依据 AVL 树的性质，每个结点的平衡因子绝对值不能大于1，所以在插入每个结点时，需要对树进行调整，使其满足 AVL 树的性质。 AVL 树失衡的情况总共有4种：LL、LR、RR 和 RL 四种，会根据每种情况做对应的旋转即可。注意每次插入结点时都需要检查树是否失衡，这样能够及时调整。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 25;struct node &#123; int v, height; node *left, *right;&#125; *root;int n;node *newnode(int v) &#123; node *Node = new node; Node-&gt;v = v; Node-&gt;height = 1; Node-&gt;left = Node-&gt;right = NULL; return Node;&#125;int getheight(node *root) &#123; if(root == NULL) return 0; return root-&gt;height;&#125;void updateheight(node *root) &#123; root-&gt;height = max(getheight(root-&gt;left), getheight(root-&gt;right)) + 1;&#125;int getbalancefactor(node *root) &#123; return getheight(root-&gt;left) - getheight(root-&gt;right);&#125;void leftRotation(node *&amp;root) &#123; node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; updateheight(root); updateheight(temp); root = temp;&#125;void rightRotation(node *&amp;root) &#123; node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; updateheight(root); updateheight(temp); root = temp;&#125;void insert(node *&amp;root, int v) &#123; if(root == NULL) &#123; root = newnode(v); return; &#125; if(v &lt; root-&gt;v) &#123; insert(root-&gt;left, v); updateheight(root); if(getbalancefactor(root) == 2) &#123; if(getbalancefactor(root-&gt;left) == 1) &#123; rightRotation(root); &#125; else if(getbalancefactor(root-&gt;left) == -1) &#123; leftRotation(root-&gt;left); rightRotation(root); &#125; &#125; &#125; else &#123; insert(root-&gt;right, v); updateheight(root); if(getbalancefactor(root) == -2) &#123; if(getbalancefactor(root-&gt;right) == -1) &#123; leftRotation(root); &#125; else if(getbalancefactor(root-&gt;right) == 1) &#123; rightRotation(root-&gt;right); leftRotation(root); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int value; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; insert(root, value); &#125; cout &lt;&lt; root-&gt;v; return 0;&#125; 1067 Sort with SwapAnalysis这道题考察贪心，参杂了一些模拟。 对待贪心类的题目，必须得找准贪心的策略，不然就没法解题了，得仔细观察样例。假设数字都存储在数组中，按照题目的说明，可以发现：0值每次交换的对象都是下标值与其本身值不一样的数字。所以，每次将0值与具有上述特点的值交换即可；但要注意，若0的下标为0时，算法就无法继续进行了，此时需要特别处理下，将0与当前值最小且具有上述特点的数字直接进行交换。 这时可以发现，如果从数组头部开始向后查找这样的数字，就会有很多已经排好的数被遍历到。为了避免这样的情况，需要将当前值最小且具有上述特点的数字保存在一个变量内，这样下次查找时直接从这个数字开始就可以避免重复查找的情况了。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int pos[MAXN];int main(int argc, char const *argv[]) &#123; int n, ans = 0; scanf("%d", &amp;n); int left = n - 1, num; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); pos[num] = i; if(num == i &amp;&amp; num != 0) &#123; left--; &#125; &#125; int k = 1; while(left &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; left--; &#125; &#125; printf("%d\n", ans); return 0;&#125; 贴个 C++ 版：123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn = 100000 + 5;int arr[maxn];unordered_map&lt;int, int&gt; numandindex;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; numandindex[arr[i]] = i; &#125; int index0 = numandindex[0], i = 0; while(true) &#123; if(index0 == 0) &#123; for(; i &lt; n; i++) &#123; if(arr[i] != i) break; &#125; if(i != n) &#123; numandindex[arr[i]] = 0; numandindex[0] = i; &#125; else break; &#125; int index = numandindex[index0]; swap(arr[index0], arr[index]); cnt++; index0 = index; &#125; cout &lt;&lt; cnt; return 0;&#125; 本质上是下标在交换，所以用一个 map 来建立数组元素与对应下标的映射，这样理解起来会清楚一些。 1069 The Black Hole of NumbersAnalysis此题与乙级题库的1019一样 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1070 MooncakeAnalysis此题与乙级题库的1020类似（好像只是数据不一样），考察贪心。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; ans += cake[i].sell; D -= cake[i].store; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125;bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1071 Speech PatternsAnalysis题目要求输入一句话，输出其中出现次数最长的字符串，字符串只能包含0-9、A-Z和a-z内的字符，其他字符均被认为是字符串之间的分隔符。 先将字符串整行读入，在逐个拆分出每个单词，并利用map来建立字符串（string）与次数（int）之间的映射，每统计到相同的字符串，次数加1。 输出时，遍历map，找出其中出现次数最多的字符串即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; mp;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; if('a' &lt;= c &amp;&amp; c &lt;= 'z') return true; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') return true; return false;&#125;int main(int agrc, char const *argv[]) &#123; map&lt;string, int&gt; count; string str; getline(cin, str); int i = 0; while(i &lt; str.length()) &#123; string word; while(i &lt; str.length() &amp;&amp; check(str[i]) == true) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] += 32; &#125; word += str[i]; i++; &#125; if(word != "") &#123; if(count.find(word) == count.end()) count[word] = 1; else count[word]++; &#125; while(i &lt; str.length() &amp;&amp; check(str[i]) == false) &#123; i++; &#125; &#125; string ans; int max = 0; for(map&lt;string, int&gt;::iterator it = count.begin(); it != count.end(); it++) &#123; if(it-&gt;second &gt; max) &#123; max = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; max; return 0;&#125; 写简单一点：1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string, int&gt; stringcnt;const int maxn = 1048576 + 10;int main() &#123; string str, tmp; getline(cin, str); int maxcnt = 0; for(int i = 0; i &lt; str.length(); i++) &#123; if(isalnum(str[i])) &#123; if(isupper(str[i])) str[i] = tolower(str[i]); tmp.push_back(str[i]); &#125; if(!isalnum(str[i]) || i == str.length() - 1) &#123; if(tmp != "") &#123; stringcnt[tmp]++; maxcnt = max(maxcnt, stringcnt[tmp]); &#125; tmp.clear(); &#125; &#125; for(auto &amp;p: stringcnt) &#123; if(p.second == maxcnt) &#123; cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second; break; &#125; &#125; return 0;&#125; 以为可以直接用空格字符作为单词的分隔符，结果仔细一看Here a &quot;word&quot; is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.，也就是说题目没说一定会用空格来分隔单词，这样就没法利用 cin 和 scanf 自动按空格读入特性了，只能获取一行后逐个提取出来。最后一个单词的结尾也可能是字母、数字，所以也要统计在内，测试点 4 应该是这样。 1072 Gas StationAnalysis题目大意是给定若干个源点和固定点，求这些源点到所有固定点距离最小的源点，如果存在相同解，就输出平均距离最小的源点。 按照题目大意，可以将题目描述抽象为图，接着利用 Dijkstra 算法就可以求解源点到固定点的最短距离；由于题目给定的源点有多个，所以要使用多次 Dijkstra 算法，所以每次执行算法之前需要将用到的bool数组初始化为false。然后，按照题目条件来判断或筛选最优解。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1020;const int inf = 0x3fffffff;int n, m, k, ds, G[maxv][maxv];int d[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; memset(vis, false, sizeof(vis)); //do not forget initializing this array fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n + m; i++) &#123; int u = -1, min = inf; for(int j = 1; j &lt;= n + m; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 1; v &lt;= n + m; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int getid(char str[]) &#123; //tranfer the id of gas station int len = strlen(str), id = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != 'G') id = id * 10 + (str[i] - '0'); &#125; if(str[0] == 'G') return n + id; else return id;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;ds); int u, v, w; char city1[5], city2[5]; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 0; i &lt; k; i++) &#123; scanf("%s %s %d", city1, city2, &amp;w); u = getid(city1); v = getid(city2); G[v][u] = G[u][v] = w; &#125; double ansdis = -1, ansavg = inf; int ansid = -1; for(int i = n + 1; i &lt;= n + m; i++) &#123; double mindis = inf, avg = 0; dijkstra(i); //every station should execute this dijkstra for(int j = 1; j &lt;=n; j++) &#123; if(d[j] &gt; ds) &#123; //this solution does not fit the problem mindis = -1; break; &#125; if(d[j] &lt; mindis) mindis = d[j]; //cal minimum of distance avg += 1.0 * d[j] / n; //calculate the average &#125; if(mindis == -1) continue; if(mindis &gt; ansdis) &#123; //more optimal solution ansid = i; ansdis = mindis; ansavg = avg; &#125; else if(mindis == ansdis &amp;&amp; avg &lt; ansavg) &#123; //more optimal solution ansid = i; ansavg = avg; &#125; &#125; if(ansid == -1) printf("No Solution\n"); else &#123; printf("G%d\n", ansid - n); printf("%.1lf %.1lf\n", ansdis, ansavg); &#125; return 0;&#125; 1073 Scientific NotationAnalysis此题与乙级题库的1024一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int Epos, exp = 0; for(Epos = 1; Num[Epos] != 'E'; Epos++); for(int i = Epos + 2; Num[i] != '\0'; i++) &#123; exp = exp * 10 + Num[i] - '0'; &#125; if(Num[0] == '-') &#123; putchar(Num[0]); &#125; if(exp == 0) &#123; for(int i = 1; Num[i] != 'E'; i++) &#123; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '-') &#123; printf("0."); for(int i = exp - 1; i &gt; 0; i--) &#123; putchar('0'); &#125; for(int i = 1; Num[i] != 'E'; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '+') &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == exp + 2 &amp;&amp; Epos - 3 != exp) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; exp - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; putchar('\n'); return 0;&#125; 1074 Reversing Linked ListAnalysis此题与乙级题库的1025一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node&#123; int address, data, next; int order;&#125; Node[maxn];bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125; int head, n, k, address; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].data, &amp;Node[address].next); Node[address].address = address; &#125; int p = head, count = 0; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) &#123; printf("-1\n"); &#125; else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1075 PAT JudgeAnalysis考察排序，题目说明比较多，要仔细读题。关键是输入数据的处理，处理后要达到便于排序（与题目一致）和输出的效果。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;struct user&#123; int id, score[6], sum, perfect; bool flag;&#125; us[MAXN];int N, K, M;int full[6] = &#123;0&#125;;bool cmp(user a, user b);void Init();int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;K, &amp;M); Init(); for(int i = 1; i &lt;= K; i++) &#123; scanf("%d", full + i); &#125; int uid, pid, score_ob; for(int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;uid, &amp;pid, &amp;score_ob); if(score_ob != -1) &#123; us[uid].flag = true; &#125; if(score_ob == -1 &amp;&amp; us[uid].score[pid] == -1) &#123; us[uid].score[pid] = 0; &#125; if(score_ob == full[pid] &amp;&amp; us[uid].score[pid] &lt; full[pid]) &#123; us[uid].perfect++; &#125; if(score_ob &gt; us[uid].score[pid]) &#123; us[uid].score[pid] = score_ob; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] != -1) &#123; us[i].sum += us[i].score[j]; &#125; &#125; &#125; sort(us + 1, us + N + 1, cmp); int r = 1; for(int i = 1; i &lt;= N &amp;&amp; us[i].flag == true; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) &#123; r = i; &#125; printf("%d %05d %d", r, us[i].id, us[i].sum); for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] == -1) &#123; printf(" -"); &#125; else &#123; printf(" %d", us[i].score[j]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void Init() &#123; for(int i = 1; i &lt;= N; i++) &#123; us[i].id = i; us[i].sum = 0; us[i].perfect = 0; us[i].flag = false; memset(us[i].score, -1, sizeof(us[i].score)); &#125;&#125; 重新写了一下，整体思路不变：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 5;struct student &#123; int id, grade[6], cnt; bool flag;&#125; stu[maxn];int perfect[6], n, k, m;bool cmp(student a, student b) &#123; if(a.grade[0] != b.grade[0]) return a.grade[0] &gt; b.grade[0]; else if(a.cnt != b.cnt) return a.cnt &gt; b.cnt; else return a.id &lt; b.id; &#125;void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; stu[i].id = i; stu[i].cnt = 0; stu[i].flag = false; memset(stu[i].grade, -1, sizeof(stu[i].grade)); stu[i].grade[0] = 0; &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); Init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", &amp;perfect[i]); &#125; int id, grade, pronum; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;pronum, &amp;grade); if(grade != -1) stu[id].flag = true; if(grade == -1 &amp;&amp; stu[id].grade[pronum] == -1) stu[id].grade[pronum] = 0; if(grade == perfect[pronum] &amp;&amp; stu[id].grade[pronum] &lt; perfect[pronum]) stu[id].cnt++; if(grade &gt; stu[id].grade[pronum]) stu[id].grade[pronum] = grade; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(stu[i].grade[j] &gt; 0) stu[i].grade[0] += stu[i].grade[j]; &#125; &#125; sort(stu + 1, stu + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; stu[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; stu[i].grade[0] != stu[i - 1].grade[0]) rank = i; printf("%d %05d %d", rank, stu[i].id, stu[i].grade[0]); for(int j = 1; j &lt;= k; j++) &#123; if(stu[i].grade[j] == -1) printf(" -"); else printf(" %d", stu[i].grade[j]); &#125; putchar('\n'); &#125; return 0;&#125; 1076 Forwards on WeiboAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;struct node &#123; int id; int layer;&#125;;vector&lt;node&gt; Adj[maxn];bool inq[maxn] = &#123;false&#125;;int BFS(int s, int L) &#123; int numFoward = 0; queue&lt;node&gt; q; node start; start.id = s; start.layer = 0; q.push(start); inq[start.id] = true; while(!q.empty()) &#123; node top = q.front(); q.pop(); int u = top.id; for(int i = 0; i &lt; Adj[u].size(); i++) &#123; node next = Adj[u][i]; next.layer = top.layer + 1; if(inq[next.id] == false &amp;&amp; next.layer &lt;= L) &#123; q.push(next); inq[next.id] = true; numFoward++; &#125; &#125; &#125; return numFoward;&#125;int main(int argc, char const *argv[]) &#123; node user; int n, L, numFollow, idFollow; cin &gt;&gt; n &gt;&gt; L; for(int i = 1; i &lt;= n; i++) &#123; user.id = i; cin &gt;&gt; numFollow; for(int j = 0; j &lt; numFollow; j++) &#123; cin &gt;&gt; idFollow; Adj[idFollow].push_back(user); &#125; &#125; int numQuery, s; cin &gt;&gt; numQuery; while(numQuery--) &#123; memset(inq, false, sizeof(inq)); cin &gt;&gt; s; int numFoward = BFS(s, L); cout &lt;&lt; numFoward &lt;&lt; endl; &#125; return 0;&#125; 1077 KuchiguseAnalysis本题的实质是在求字符串的最长相同后缀，从后遍历字符串比较麻烦，所以采取先逆转字符串，然后从前遍历的做法，这样就会方便许多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 256 + 5;char str[100][MAXN];void Reverse(char *s);int main(int argc, char const *argv[]) &#123; int N, minLen = 256, ans = 0; scanf("%d", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) &#123; fgets(str[i], MAXN, stdin); int len = strlen(str[i]); if(len &lt; minLen) minLen = len; Reverse(str[i]); &#125; for(int i = 0; i &lt; minLen; i++) &#123; char c = str[0][i]; bool same = true; for(int j = 1; j &lt; N; j++) &#123; if(c != str[j][i]) &#123; same = false; break; &#125; &#125; if(same) &#123; ans++; &#125; else &#123; break; &#125; &#125; if(ans &gt; 1) &#123; for(int i = ans - 1; i &gt;= 0; i--) &#123; putchar(str[0][i]); &#125; &#125; else &#123; puts("nai"); &#125; return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 贴个 C++ 版：1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, minlen = 0x3fffffff; cin &gt;&gt; n; getchar(); vector&lt;string&gt; strs; for(int i = 0; i &lt; n; i++) &#123; string tmp; getline(cin, tmp); reverse(tmp.begin(), tmp.end()); strs.push_back(tmp); if(tmp.length() &lt; minlen) minlen = tmp.length(); &#125; string ans; bool flag = false; for(int i = 0; i &lt; minlen; i++) &#123; char tmp = strs[0][i]; for(int j = 1; j &lt; n; j++) &#123; if(strs[j][i] != tmp) &#123; flag = true; break; &#125; &#125; if(flag) break; ans += tmp; &#125; reverse(ans.begin(), ans.end()); if(ans != "") cout &lt;&lt; ans; else cout &lt;&lt; "nai"; return 0;&#125; 1078 HashingAnalysis题目大意是用线性探测的方法，构造哈希表，用平方探测的办法解决冲突。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXM = 10005;bool isPrime(int n) &#123; if(n &lt;= 1 || (n != 2 &amp;&amp; n % 2 == 0)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int nearPrime(int n) &#123; while(!isPrime(n)) n++; return n;&#125;int hashTable[MAXM] = &#123;0&#125;; int main(int argc, char const *argv[]) &#123; int m, n, temp, index; scanf("%d %d", &amp;m, &amp;n); m = nearPrime(m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); index = temp % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); &#125; else &#123; int step; for(step = 1; step &lt; m; step++) &#123; index = (temp + step * step) % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); break; &#125; &#125; if(step &gt;= m) &#123; printf("-"); &#125; &#125; if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 1079 Total Sales of SupplyAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1080 Graduate AdmissionAnalysis这个题相当麻烦，基本思想是排序 + 贪心。排序的规则很简单，第一判断依据是总分（不用与题目的计算公式一致），第二排序依据是 Ge 这个分数，顺序为非增序。排序的问题比较容易解决，难点在学校挑选学生上。具体而言，整个录取过程是一个贪心的过程。首先按照分数，将每位学生的排名求出。然后根据排名，按照每位学生的选择，依次进行录取。之所以说是贪心，是因为以前面的选择优先（也就是第一志愿优先的规则），前面选择的学校名额不足时就顺排到后面的学校。由于题目还要求，对于排名相同且选择相同学校的，学校应该扩额录取。所以需要记录下，在不超过限额的情况，每个学校能录取的最后一名的名次，并与后面的学生进行比较，如果排名相同，就得录取。最后还有一点，学校的录取名单需要按照 id 非降序排序。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 40000 + 5;struct student&#123; int ge, gi, sum; int r, id; int cho[6];&#125; stu[MAXN];struct school&#123; int quota; int stuNum; int id[MAXN]; int lastAdmit;&#125; sch[110];bool cmpStu(student a, student b);bool cmpID(int a, int b);int main(int argc, char const *argv[]) &#123; int N, M, K; scanf("%d %d %d", &amp;N, &amp;M, &amp;K); for(int i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;sch[i].quota); sch[i].stuNum = 0; sch[i].lastAdmit = -1; &#125; for(int i = 0; i &lt; N; i++) &#123; stu[i].id = i; scanf("%d %d", &amp;stu[i].ge, &amp;stu[i].gi); stu[i].sum = stu[i].ge + stu[i].gi; for(int j = 0; j &lt; K; j++) &#123; scanf("%d", &amp;stu[i].cho[j]); &#125; &#125; sort(stu, stu + N, cmpStu); for(int i = 0; i &lt; N; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) &#123; stu[i].r = stu[i - 1].r; &#125; else &#123; stu[i].r = i; &#125; &#125; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; K; j++) &#123; int choice = stu[i].cho[j]; int num = sch[choice].stuNum; int last = sch[choice].lastAdmit; if(num &lt; sch[choice].quota || (last != -1 &amp;&amp; stu[i].r == stu[last].r)) &#123; sch[choice].id[num] = i; sch[choice].lastAdmit = i; sch[choice].stuNum++; break; &#125; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; if(sch[i].stuNum &gt; 0) &#123; sort(sch[i].id, sch[i].id + sch[i].stuNum, cmpID); for(int j = 0; j &lt; sch[i].stuNum; j++) &#123; printf("%d", stu[sch[i].id[j]].id); if(j &lt; sch[i].stuNum - 1) &#123; printf(" "); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmpStu(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;bool cmpID(int a, int b) &#123; return stu[a].id &lt; stu[b].id;&#125; 贴个 C++ 版：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40000 + 5;struct student &#123; int ge, gi, id, rank; int sum; int choices[6];&#125; stu[maxn];int n, m, k;int quota[105] = &#123;0&#125;;int lastrank[105] = &#123;0&#125;;bool cmp(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; quota[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].ge &gt;&gt; stu[i].gi; stu[i].sum = stu[i].ge + stu[i].gi; stu[i].id = i; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; stu[i].choices[j]; &#125; &#125; sort(stu, stu + n, cmp); stu[0].rank = 1; for(int i = 1; i &lt; n; i++) &#123; if(stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) stu[i].rank = stu[i - 1].rank; else stu[i].rank = i + 1; &#125; vector&lt;vector&lt;int&gt;&gt; ans(105); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; int school = stu[i].choices[j]; if(quota[school] != 0) &#123; ans[school].push_back(stu[i].id); quota[school]--; lastrank[school] = stu[i].rank; break; &#125; else &#123; if(stu[i].rank == lastrank[school]) &#123; ans[school].push_back(stu[i].id); break; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int size = ans[i].size(); if(size == 0) &#123; cout &lt;&lt; endl; continue; &#125; else &#123; sort(ans[i].begin(), ans[i].end()); cout &lt;&lt; ans[i][0]; for(int j = 1; j &lt; size; j++) &#123; cout &lt;&lt; ' ' &lt;&lt; ans[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1081 Rational SumAnalysis题目大意是给定N个a/b形式的分数，a为分子，b为分母，求这N个分数的和再输出。 给定的分数只有两种情况：真分数和假分数，不存在带分数，但输出要输出带分数，并且是最简形式。化简的目的其实题目考察求最大公约数，利用欧几里得算法即可求得两个数的最大公约数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct fraction &#123; long long up, down;&#125; Fraction;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; long long d = gcd(abs(result.up), result.down); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;void printResult(Fraction result) &#123; Fraction r = Reduction(result); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125;&#125;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); Fraction ans, temp; ans.up = 0; ans.down = 1; while(N--) &#123; scanf("%lld/%lld", &amp;temp.up, &amp;temp.down); ans = Add(ans, temp); &#125; printResult(ans); return 0;&#125; 贴个 C++ 版，把加法运算、化简和输出操作都封装起来：123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;struct Fraction &#123; long long up, down; void reduction() &#123; if(this-&gt;down &lt; 0) &#123; this-&gt;up = - this-&gt;up; this-&gt;down = - this-&gt;down; &#125; if(this-&gt;up == 0) this-&gt;down = 1; else &#123; long long d = gcd(abs(this-&gt;up), this-&gt;down); this-&gt;up /= d; this-&gt;down /= d; &#125; &#125; void Add(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down + this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Print() &#123; if(this-&gt;down == 1) printf("%lld", this-&gt;up); else if(abs(this-&gt;up) &gt; this-&gt;down) &#123; printf("%lld %lld/%lld", this-&gt;up / this-&gt;down, abs(this-&gt;up) % this-&gt;down, this-&gt;down); &#125; else printf("%lld/%lld", this-&gt;up, this-&gt;down); printf("\n"); &#125;&#125;;int main() &#123; int n; scanf("%d", &amp;n); Fraction ans, tmp; ans.down = 1, ans.up = 0; while(n--) &#123; scanf("%lld/%lld", &amp;tmp.up, &amp;tmp.down); ans.Add(tmp); &#125; ans.Print(); return 0;&#125; 1082 Read Number in ChineseAnalysis将数字按每4位一组分割为不同的组，若是 9 位数，则有三组分别为：个位组、万位组和亿位组，然后针对每一组单独进行判断。对每一小组而言，要注意1001只能输出为yi Qian ling yi而不是yi Qian ling ling yi，即有累积的0时，只能输出一个ling。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;char NumberTable[10][10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu", &#125;;char Digit[5][10] = &#123; "Shi", "Bai", "Qian", "Wan", "Yi", &#125;;int main(int argc, char const *argv[]) &#123; char Num[15]; scanf("%s", Num); int len = strlen(Num), left = 0, right = len - 1; if(Num[0] == '-') &#123; printf("Fu"); left++; &#125; while(left + 4 &lt;= right) &#123; right -= 4; &#125; while(left &lt; len) &#123; bool flag = false, isPrint = false; while(left &lt;= right) &#123; if(left &gt; 0 &amp;&amp; Num[left] == '0') &#123; flag = true; &#125; else &#123; if(flag == true) &#123; printf(" ling"); flag = false; &#125; if(left &gt; 0) printf(" "); printf("%s", NumberTable[Num[left] - '0']); isPrint = true; if(left != right) &#123; printf(" %s", Digit[right - left - 1]); &#125; &#125; left++; &#125; if(isPrint == true &amp;&amp; right != len - 1) &#123; printf(" %s", Digit[(len - 1 - right) / 4 + 2]); &#125; right += 4; &#125; return 0;&#125; 1083 List GradesAnalysis自定义结构体，输入数据后调用sort函数按照降序排序，然后根据题目给定的区间顺序输出符合这个区间内的元素即可。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char name[15], id[15]; int grade;&#125; stu[MAXN];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, grade1, grade2; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].id, &amp;stu[i].grade); &#125; scanf("%d %d", &amp;grade1, &amp;grade2); sort(stu, stu + N, cmp); bool flag = false; for(int i = 0; i &lt; N; i++) &#123; if(grade1 &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= grade2) &#123; printf("%s %s\n", stu[i].name, stu[i].id); flag = true; &#125; &#125; if(!flag) &#123; printf("NONE\n"); &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade &gt; b.grade;&#125; 贴个 C++ 版：1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string name, id; int grade;&#125; stu[maxn];int n;int main() &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].name &gt;&gt; stu[i].id &gt;&gt; stu[i].grade; &#125; sort(stu, stu + n, [](student a, student b) &#123; return a.grade &gt; b.grade; &#125;); int left, right, cnt = 0; cin &gt;&gt; left &gt;&gt; right; for(int i = 0; i &lt; n; i++) &#123; if(left &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= right) &#123; cout &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].id &lt;&lt; endl; cnt++; &#125; &#125; if(!cnt) cout &lt;&lt; "NONE" &lt;&lt; endl; return 0;&#125; 1084 Broken KeyboardAnalysis遍历字符串，找出第一个字符串中出现过，但第二个字符串中未出现的字符即可，字母不区分大小写，但字符串内有空格和数字，用_表示，注意不能输出小写字母，且重复的字符只输出一次。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;int main(int argc, char const *argv[]) &#123; char str1[85], str2[85]; scanf("%s %s", str1, str2); bool HashTable[128] = &#123;false&#125;; for(int i = 0; str1[i] != '\0'; i++) &#123; int j = 0; char c1 = str1[i]; for(; str2[j] != '\0'; j++) &#123; char c2 = str2[j]; if(islower(c1)) c1 = toupper(c1); if(islower(c2)) c2 = toupper(c2); if(c1 == c2) break; &#125; if(str2[j] == '\0' &amp;&amp; HashTable[c1] == false) &#123; printf("%c", c1); HashTable[c1] = true; &#125; &#125; putchar('\n'); return 0;&#125; 1085 Perfect SequenceAnalysis此题与乙级题库的1030一样。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;long long n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%lld %lld", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1086 Tree Traversals AgainAnalysis题目大意是给定用栈模拟二叉树中序遍历的入栈、出栈顺序，现在要求输出这个二叉树后序遍历序列。 根据题目给定的入栈、出栈序列，可以得到二叉树的先序遍历序列和后序遍历序列，根据这两个序列建树，然后再后序遍历这个二叉树即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int data; node *lchild; node *rchild;&#125;;int n, pre[50], in[50], order;stack&lt;int&gt; st;node *create(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(preL + 1, preL + numLeft, inL, k - 1); root-&gt;rchild = create(preL + numLeft + 1, preR, k + 1, inR); return root;&#125;int num = 0;void postorder(node *root) &#123; if(root == NULL) return; postorder(root-&gt;lchild); postorder(root-&gt;rchild); printf("%d", root-&gt;data); if(num &lt; n - 1) &#123; printf(" "); &#125; num++;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); char str[5]; int x, preIndex = 0, inIndex = 0; for(int i = 0; i &lt; 2 * n; i++) &#123; scanf("%s", str); if(strcmp("Push", str) == 0) &#123; scanf("%d", &amp;x); pre[preIndex++] = x; st.push(x); &#125; else &#123; in[inIndex++] = st.top(); st.pop(); &#125; &#125; node *root = create(0, n - 1, 0, n - 1); postorder(root); return 0;&#125; 1087 All Roads Lead to RomeAnalysis题目背景是旅游的路线图，要求按照条件求出最短路径及特定的值。 题目首先要求出的是从起点到终点的最短路径，由于不存在负环，所以可以直接使用 Dijkstra 算法求得；同时注意到，题目要求的某些特殊值与对应的路径可以在求解最短路时，一并求出，只不过需要使用多个数组而已。按照这样的思路，对题目要求的值增加对应的数组，并在求解最最短路的过程中写清楚这些条件之间的层次关系即可。 当然了，本题也可以使用 Dijkstra 算法先求出所有的最短路径，然后再利用 DFS 来求出符合条件的最优解和对应的值。 CodeDijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;, pt[maxv] = &#123;0&#125;, pre[maxv];bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v] = u; num[v] = num[u]; w[v] = w[u] + weight[v]; pt[v] = pt[u] + 1; &#125; else if(d[v] == d[u] + G[u][v]) &#123; num[v] += num[u]; if(w[v] &lt; w[u] + weight[v]) &#123; w[v] = w[u] + weight[v]; pre[v] = u; pt[v] = pt[u] + 1; &#125; else if(w[v] == w[u] + weight[v]) &#123; double uavg = 1.0 * (w[u] + weight[v]) / (pt[u] + 1); double vavg = 1.0 * w[v] / pt[v]; if(uavg &gt; vavg) &#123; pt[v] = pt[u] + 1; pre[v] = u; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; cout &lt;&lt; index2city[v]; return; &#125; dfs(pre[v]); cout &lt;&lt; "-&gt;" &lt;&lt; index2city[v];&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; city2index[city1] = i; index2city[i] = city1; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1], v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; cout &lt;&lt; num[rom] &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; w[rom] &lt;&lt; ' ' &lt;&lt; w[rom] / pt[rom] &lt;&lt; endl; dfs(rom); return 0;&#125; Dijkstra + DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], numpath = 0, maxw = 0;double maxavg = 0;bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); numpath++; int tempw = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; tempw += weight[id]; &#125; double tempavg = 1.0 * tempw / (tempath.size() - 1); if(tempw &gt; maxw) &#123; maxw = tempw; maxavg = tempavg; path = tempath; &#125; else if(tempw == maxw &amp;&amp; tempavg &gt; maxavg) &#123; maxavg = tempavg; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; index2city[i] = city1; city2index[city1] = i; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1]; v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; dfs(rom); cout &lt;&lt; numpath &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; maxw &lt;&lt; ' ' &lt;&lt; (int)maxavg &lt;&lt; endl; for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; index2city[path[i]]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; return 0;&#125; 1088 Rational ArithmeticAnalysis此题与乙级题库的1034一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b);struct Fraction&#123; ll up, down;&#125; a, b;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /=d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void showResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); //add showResult(a); printf(" + "); showResult(b); printf(" = "); showResult(Add(a, b)); putchar('\n'); //minu showResult(a); printf(" - "); showResult(b); printf(" = "); showResult(Minu(a, b)); putchar('\n'); //mult showResult(a); printf(" * "); showResult(b); printf(" = "); showResult(Mult(a, b)); putchar('\n'); //divide showResult(a); printf(" / "); showResult(b); printf(" = "); if(b.up == 0) printf("Inf"); else showResult(Divide(a, b)); return 0;&#125; ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125; 贴个 C++ 版，把基本运算全都封装起来：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;struct Fraction &#123; long long up, down; void reduction() &#123; if(this-&gt;down &lt; 0) &#123; this-&gt;up = - this-&gt;up; this-&gt;down = - this-&gt;down; &#125; if(this-&gt;up == 0) this-&gt;down = 1; else &#123; long long d = gcd(abs(this-&gt;up), this-&gt;down); this-&gt;up /= d; this-&gt;down /= d; &#125; &#125; void Add(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down + this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Minu(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down - this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Mult(Fraction b) &#123; this-&gt;up = this-&gt;up * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Div(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down; this-&gt;down = this-&gt;down * b.up; this-&gt;reduction(); &#125; void printResult() &#123; this-&gt;reduction(); if(this-&gt;up &lt; 0) printf("("); if(this-&gt;down == 1) printf("%lld", this-&gt;up); else if(abs(this-&gt;up) &gt; this-&gt;down) &#123; printf("%lld %lld/%lld", this-&gt;up / this-&gt;down, abs(this-&gt;up) % this-&gt;down, this-&gt;down); &#125; else &#123; printf("%lld/%lld", this-&gt;up, this-&gt;down); &#125; if(this-&gt;up &lt; 0) printf(")"); &#125;&#125;;int main() &#123; Fraction res, a, b; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); res = a; a.printResult(); printf(" + "); b.printResult(); printf(" = "); res.Add(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" - "); b.printResult(); printf(" = "); res.Minu(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" * "); b.printResult(); printf(" = "); res.Mult(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" / "); b.printResult(); printf(" = "); if(b.up == 0) printf("Inf"); else &#123; res.Div(b); res.printResult(); &#125; printf("\n"); return 0;&#125; 1089 Insert or MergeAnalysis此题与乙级题库的1035一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 10;int ori[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;bool InsertionSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;ori[i]); tempOri[i] = ori[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertionSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = ori[i]; &#125; MergeSort(); &#125; return 0;&#125; 1090 Highest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;struct node &#123; double data; vector&lt;int&gt; child;&#125; Node[maxn];int n, num = 0;double p, r, maxDepth = 0;void DFS(int index, int depth) &#123; if(Node[index].child.size() == 0) &#123; if(depth &gt; maxDepth) &#123; maxDepth = depth; num = 1; &#125; else if(depth == maxDepth) &#123; num++; &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; DFS(Node[index].child[i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100; int root, parent; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;parent); if(parent != -1) &#123; Node[parent].child.push_back(i); &#125; else &#123; root = i; &#125; &#125; DFS(root, 0); printf("%.2lf %d\n", p * pow(1 + r, maxDepth), num); return 0;&#125; 1091 Acute StrokeAnalysis题目的背景大概是计算体积之和吧... 根据题目输入数据的形式和题目大意，思路是借助 BFS 对三维数组进行遍历，计算出每一个薄片（slice）中为“1”的个数，如果大于题目给定的T，则当前这个薄片内“1”的个数就可以认为是这个薄片的“急性脑卒中”区的体积。那么，依次遍历每个薄片即可得到最终结果。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, z;&#125; Node;int n, m, slice, T;int pixel[1290][130][61];bool inqueue[1290][130][61];int X[6] = &#123;0, 0, 0, 0, 1, -1&#125;;int Y[6] = &#123;0, 0, 1, -1, 0, 0&#125;;int Z[6] = &#123;1, -1, 0, 0, 0, 0&#125;;bool judge(int x, int y, int z) &#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0 || z &gt;= slice || z &lt; 0) return false; if(pixel[x][y][z] == 0 || inqueue[x][y][z] == true) return false; return true;&#125;int BFS(int x, int y, int z) &#123; int tot = 0; queue&lt;node&gt; Q; Node.x = x, Node.y = y, Node.z = z; Q.push(Node); inqueue[x][y][z] = true; while(!Q.empty()) &#123; node top = Q.front(); Q.pop(); tot++; for(int i = 0; i &lt; 6; i++) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; int newZ = top.z + Z[i]; if(judge(newX, newY, newZ)) &#123; Node.x = newX, Node.y = newY, Node.z = newZ; Q.push(Node); inqueue[newX][newY][newZ] = true; &#125; &#125; &#125; if(tot &gt;= T) return tot; else return 0;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;slice, &amp;T); for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; scanf("%d", &amp;pixel[x][y][z]); &#125; &#125; &#125; int ans = 0; for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; if(pixel[x][y][z] == 1 &amp;&amp; inqueue[x][y][z] == false) &#123; ans += BFS(x, y, z); &#125; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1092 To Buy or Not to BuyAnalysis与乙级题库的1039一样。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1093 Count PAT’sAnalysis与乙级题库的1040一样。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') leftNumP[i]++; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt; 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; 贴个 C++ 版：123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int pcnt = 0, tcnt = 0; for(char &amp;ch: str) &#123; if(ch == 'T') tcnt++; &#125; int ans = 0; for(char &amp;ch: str) &#123; if(ch == 'A') &#123; ans += tcnt * pcnt; ans %= 1000000007; &#125; else if(ch == 'P') pcnt++; else tcnt--; &#125; cout &lt;&lt; ans; return 0;&#125; 1094 The Largest GenerationAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, seq, child;int Depth[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; Depth[Node[1].depth]++; while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; Depth[Node[child].depth]++; q.push(child); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); int max = -1, l = 1; for(int i = 0; i &lt; maxn; i++) &#123; if(Depth[i] &gt; max) &#123; max = Depth[i]; l = i; &#125; &#125; cout &lt;&lt; Depth[l] &lt;&lt; ' ' &lt;&lt; l &lt;&lt; endl; return 0;&#125; 1095 Cars on CampusAnalysis这又是一道相当麻烦的排序题，和 1016 很像，有些地方又比 1016 简单一点。首先要注意的事情是，如何把题目的一些条件简化，比如时间全部简化成秒，这样排序时就可以直接按照秒数的大小进行排序了。不过，对于这个题而言，第一排序依据是plate_number，然后才是时间。排序完成后，需要将所有合法的记录对挑出来，作为后面查询每个时间内停车场内车辆数据的依据，也就是相邻的两个记录组成一对，plate_number相同，一个是in，另外一个是out。此时，可以顺便把每辆车的停车时间和最长的停车时间算出来，每辆车的停车时间可以借助 map 来统计。接着就是查询的过程，因为题目规定了给定的查询时间是从小到大的。所以，在查询前，先对合法记录按时间排序。然后，设置一个变量 now，从头开始进行遍历，遇到in的记录，当前车辆数就加 1，遇到out的记录，就减一，这样就只用遍历一次所有的合法记录。最后就是输出停车时间与最长停车时间相等的车牌号和总时间了。两个字：麻烦~🙃 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 10;struct car &#123; char pnum[8], status[5]; int time;&#125; all[maxn], valid[maxn];int n, k, validcnt = 0;map&lt;string, int&gt; parktime; bool cmpbypnumandtime(car a, car b) &#123; if(strcmp(a.pnum, b.pnum) != 0) return strcmp(a.pnum, b.pnum) &lt; 0; else return a.time &lt; b.time;&#125;bool cmpbytime(car a, car b) &#123; return a.time &lt; b.time;&#125;int time2int(int hh, int mm, int ss) &#123; return hh * 3600 + mm * 60 + ss; &#125;int main() &#123; scanf("%d %d", &amp;n, &amp;k); int hh, mm, ss; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d:%d:%d %s", all[i].pnum, &amp;hh, &amp;mm, &amp;ss, all[i].status); all[i].time = time2int(hh, mm, ss); &#125; sort(all, all + n, cmpbypnumandtime); int maxtime = -1; for(int i = 0; i &lt; n - 1; i++) &#123; if(!strcmp(all[i].pnum, all[i + 1].pnum) &amp;&amp; !strcmp(all[i].status, "in") &amp;&amp; !strcmp(all[i + 1].status, "out")) &#123; valid[validcnt++] = all[i]; valid[validcnt++] = all[i + 1]; int intime = all[i + 1].time - all[i].time; if(parktime.count(all[i].pnum) == 0) &#123; parktime[all[i].pnum] = 0; &#125; parktime[all[i].pnum] += intime; maxtime = max(maxtime, parktime[all[i].pnum]); &#125; &#125; sort(valid, valid + validcnt, cmpbytime); int now = 0, numcar = 0; for(int i = 0; i &lt; k; i++) &#123; scanf("%d:%d:%d", &amp;hh, &amp;mm, &amp;ss); int time = time2int(hh, mm, ss); while(now &lt; validcnt &amp;&amp; valid[now].time &lt;= time) &#123; if(!strcmp(valid[now].status, "in")) numcar++; else numcar--; now++; &#125; printf("%d\n", numcar); &#125; for(auto it = parktime.begin(); it != parktime.end(); it++) &#123; if(it-&gt;second == maxtime) printf("%s ", it-&gt;first.c_str()); &#125; printf("%02d:%02d:%02d", maxtime / 3600, maxtime % 3600 / 60, maxtime % 60); return 0;&#125; 1096 Consecutive FactorsAnalysis题目大意是给定一个整数，找出其最长的因子序列并要求连续因子尽可能小，以样例为例，630=3*5*6*7，所以其连续因子序列为5*6*7，长度为 3 且此为其最长连续因子序列。 Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[]) &#123; ll n; scanf("%lld", &amp;n); ll sqr = sqrt(n), ansI = 0, ansLen = 0; for(ll i = 2; i &lt;= sqr; i++) &#123; ll temp = 1, j = i; while(1) &#123; temp *= j; if(n % temp != 0) break; if(j - i + 1 &gt; ansLen) &#123; ansI = i; ansLen = j - i + 1; &#125; j++; &#125; &#125; if(ansLen == 0) &#123; printf("1\n%lld\n", n); &#125; else &#123; printf("%lld\n", ansLen); for(ll i = 0; i &lt; ansLen; i++) &#123; printf("%lld", ansI + i); if(i &lt; ansLen - 1) putchar('*'); &#125; &#125; return 0;&#125; 贴个 C++ 暴力模拟的解法：123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int anslen = 0; vector&lt;int&gt; ans; for(int i = 2; i &lt;= sqrt(n); i++) &#123; int len = 0, j = i; long long t = 1; vector&lt;int&gt; tmp; while(true) &#123; tmp.push_back(j); t *= j; if(n % t == 0) len++; else break; if(len &gt; anslen) &#123; anslen = len; ans = tmp; &#125; j++; &#125; &#125; if(anslen == 0) cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; n; else &#123; cout &lt;&lt; anslen &lt;&lt; endl; for(int i = 0; i &lt; anslen; i++) &#123; cout &lt;&lt; ans[i]; if(i &lt; anslen - 1) cout &lt;&lt; '*'; &#125; &#125; return 0;&#125; 因为是从小到大枚举因子的，所以如果是符合条件的最终解，那么一定满足因子是最小的。实际上，这个题还可以从滑动窗口的角度来思考。 1097 Deduplication on a Linked ListAnalysis题目大意：给定一串链表的各个结点，删除其中重复的结点，并将删除的结点重新组成一个链表。然后，先输出原链表删除结点后的新链表，紧接着在输出由所删除的结点构成的链表。 使用静态链表来处理这个问题，先默认初始化链表内的所有结点全部为无效结点，即置为2 * maxn，然后将链表内所有结点根据地址存储。紧接着，遍历链表，使用一个bool数组来记录结点是否出现过，对于没有出现的合法结点，从0开始编号，出现过的结点，从maxn开始编号。最后，使用sort函数根据order来排序，就可以将结点按序分为删除结点后的链表、新链表和无效结点三部分，在输出即可。 注意要使用%05d来输出地址位数较少的结点。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;const int Table = 2 * maxn;struct node&#123; int address, next, key; int order;&#125; Node[maxn];bool isExist[Table] = &#123;false&#125;;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = 2 * maxn; &#125; int n, head, address; scanf("%d %d", &amp;head, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].key, &amp;Node[address].next); Node[address].address = address; &#125; int countValid = 0, countRemoved = 0, p = head; while(p != -1) &#123; if(!isExist[abs(Node[p].key)]) &#123; isExist[abs(Node[p].key)] = true; Node[p].order = countValid++; &#125; else &#123; Node[p].order = maxn + countRemoved++; &#125; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); int count = countValid + countRemoved; for(int i = 0; i &lt; count; i++) &#123; if(i != countValid - 1 &amp;&amp; i != count - 1) &#123; printf("%05d %d %05d\n", Node[i].address, Node[i].key, Node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", Node[i].address, Node[i].key); &#125; &#125; return 0;&#125; 1098 Insertion or Heap SortAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int origin[maxn], tempori[maxn], changed[maxn];int n;bool isSame(int A[], int B[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;bool showArray(int A[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", A[i]); if(i &lt; n) putchar(' '); &#125; putchar('\n');&#125;bool insertSort() &#123; bool flag = false; for(int i = 2; i &lt;= n; i++) &#123; if(i != 2 &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; sort(tempori, tempori + i + 1); if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void downAdjust(int low, int high) &#123; int i = low, j = 2 * i; while(j &lt;= high) &#123; if(j + 1 &lt;= high &amp;&amp; tempori[j + 1] &gt; tempori[j]) &#123; j = j + 1; &#125; if(tempori[j] &gt; tempori[i]) &#123; swap(tempori[j], tempori[i]); i = j; j = i * 2; &#125; else &#123; break; &#125; &#125;&#125;void heapSort() &#123; bool flag = false; for(int i = n / 2; i &gt;= 1; i--) &#123; downAdjust(i, n); &#125; for(int i = n; i &gt; 1; i--) &#123; if(i != n &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; swap(tempori[i], tempori[1]); downAdjust(1, i - 1); if(flag == true) &#123; showArray(tempori); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;origin[i]); tempori[i] = origin[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(insertSort()) &#123; printf("Insertion Sort\n"); showArray(tempori); &#125; else &#123; printf("Heap Sort\n"); for(int i = 1; i &lt;= n; i++) &#123; tempori[i] = origin[i]; &#125; heapSort(); &#125; return 0;&#125; 1099 Build A Binary Search TreeAnalysis题目大意给定一颗二叉排序树（BST），输出这棵树的层次序列。 根据题目输入数据的形式，利用结构数组建树比较方便。建树之后，中序遍历这棵树，将按升序排好的结点值序列，按照顺序赋给每个结点，这样每个结点的值就符合 BST 的性质了，接着层次遍历，输出其序列即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int data; int left, right; &#125; Node[maxn];int n, number[maxn], index = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].left); Node[root].data = number[index++]; inorder(Node[root].right);&#125;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int front = q.front(); q.pop(); cout &lt;&lt; Node[front].data; if(num &lt; n - 1) &#123; cout &lt;&lt; ' '; num++; &#125; if(Node[front].left != -1) q.push(Node[front].left); if(Node[front].right != -1) q.push(Node[front].right); &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int lchild, rchild; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; lchild &gt;&gt; rchild; Node[i].left = lchild, Node[i].right = rchild; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(0); levelorder(0); return 0;&#125; 1100 Mars NumbersAnalysis此题与乙级题库的1044一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const*argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); string s; while(n--) &#123; string str; getline(cin, str); if('0' &lt;= str[0] &amp;&amp; str[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; str.length(); i++) &#123; num = num * 10 + (str[i] - '0'); &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[str] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1101 Quick SortAnalysis此题与乙级题库的1045一样。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int n, array[MAXN], leftmax[MAXN], rightmin[MAXN], pivot[MAXN]; int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftmax[0] = array[0]; for(int i = 1; i &lt; n; i++) &#123; leftmax[i] = max(leftmax[i - 1], array[i - 1]); &#125; rightmin[n - 1] = 0x3fffffff; for(int i = n - 2; i &gt;= 0; i--) &#123; rightmin[i] = min(rightmin[i + 1], array[i + 1]); &#125; int count = 0; for(int i = 0; i &lt; n; i++) &#123; if(leftmax[i] &lt;= array[i] &amp;&amp; array[i] &lt;= rightmin[i]) &#123; pivot[count++] = array[i]; &#125; &#125; printf("%d\n", count); for(int i = 0; i &lt; count; i++) &#123; printf("%d", pivot[i]); if(i &lt; count - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1102 Invert a Binary TreeAnalysis题目大意是给定一个二叉树，反转这个二叉树并输出反转后的二叉树的中序序列和层序序列。 本题使用结构数组建树比较方便，并且反转时直接交换每个结点的左右孩子指针即可。然后再利用中序遍历和层序遍历，输出对应的序列。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int data; int lchild, rchild;&#125; Node[15]; int n;bool isRoot[15] = &#123;false&#125;;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;node&gt; q; q.push(Node[root]); while(!q.empty()) &#123; node top = q.front(); q.pop(); printf("%d", top.data); if(num &lt; n - 1) &#123; printf(" "); num++; &#125; if(top.lchild != -1) q.push(Node[top.lchild]); if(top.rchild != -1) q.push(Node[top.rchild]); &#125; putchar('\n');&#125;int num2 = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].lchild); printf("%d", Node[root].data); if(num2 &lt; n - 1) &#123; printf(" "); num2++; &#125; inorder(Node[root].rchild);&#125;int getroot() &#123; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; ret = i; break; &#125; &#125; return ret;&#125;void invert() &#123; int i = 0; for(int i = 0; i &lt; n; i++) &#123; swap(Node[i].lchild, Node[i].rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); getchar(); char left, right; for(int i = 0; i &lt; n; i++) &#123; scanf("%c %c", &amp;left, &amp;right); getchar(); if(left != '-') &#123; Node[i].lchild = left - '0'; isRoot[left - '0'] = true; &#125; else Node[i].lchild = -1; if(right != '-') &#123; Node[i].rchild = right - '0'; isRoot[right - '0'] = true; &#125; else Node[i].rchild = -1; Node[i].data = i; &#125; int root = getroot(); invert(); levelorder(root); inorder(root); return 0;&#125; 1103 Integer FactorizationAnalysis题目大意，给定三个数N、K和P，将N表示为K个因子的P次方的连加。注意题目的要求： 因子之和必须最大 因子序列按字典序最大 由于存在多解的情况，本题需要借助 DFS 来搜索所有解，找到符合条件的最优解，对于上述两个题目的要求，其对应的解决方法： 使用全局变量，记录每个解和其因子和，选择因子和最大的为最优解 将因子的P次方依次算好存储在数组中，然后从后往前枚举即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, k, p, maxFacsum = -1;vector&lt;int&gt; fac, ans, temp;int power(int x) &#123; int ret = 1; for(int i = 0; i &lt; p; i++) &#123; ret *= x; &#125; return ret;&#125;void init() &#123; int i = 0, temp = 0; while(temp &lt;= n) &#123; fac.push_back(temp); temp = power(++i); &#125;&#125;void DFS(int index, int nowK, int sum, int facSum) &#123; if(sum == n &amp;&amp; nowK == k) &#123; if(facSum &gt; maxFacsum) &#123; ans = temp; maxFacsum = facSum; &#125; return; &#125; if(sum &gt; n || nowK &gt; k) return; if(index - 1 &gt;= 0) &#123; temp.push_back(index); DFS(index, nowK + 1, sum + fac[index], facSum + index); temp.pop_back(); DFS(index - 1, nowK, sum, facSum); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;p); init(); DFS(fac.size() - 1, 0, 0, 0); if(maxFacsum == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%d = %d^%d", n, ans[0], p); for(int i = 1; i &lt; ans.size(); i++) &#123; printf(" + %d^%d", ans[i], p); &#125; &#125; return 0;&#125; 1104 Sum of Number SegmentsAnalysis此题与乙级题库的1049一样。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; int i = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1106 Lowest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;vector&lt;int&gt; child[maxn];int tot = 0, n, minDepth = maxn;double p, r;void DFS(int index, int depth) &#123; if(child[index].size() == 0) &#123; if(depth &lt; minDepth) &#123; minDepth = depth; tot = 1; &#125; else if(depth == minDepth) &#123; tot++; &#125; return; &#125; for(int i = 0; i &lt; child[index].size(); i++) &#123; DFS(child[index][i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100.0; int num, subchild; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf("%d", &amp;subchild); child[i].push_back(subchild); &#125; &#125; DFS(0, 0); double ans = p * pow(1 + r, minDepth); printf("%.4lf %d", ans, tot); return 0;&#125; 1107 Social ClustersAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int father[maxn], isroot[maxn] = &#123;0&#125;, hobby[maxn] = &#123;0&#125;;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = father[faB]; &#125;&#125;void init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main(int argc, char const *argv[]) &#123; int n, k, h; scanf("%d", &amp;n); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d:", &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;h); if(hobby[h] == 0) &#123; hobby[h] = i; &#125; Union(i, hobby[h]); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; isroot[findFather(i)]++; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; if(isroot[i] != 0) &#123; ans++; &#125; &#125; printf("%d\n", ans); sort(isroot + 1, isroot + n + 1, cmp); for(int i = 1; i &lt;= ans; i++) &#123; printf("%d", isroot[i]); if(i &lt; ans) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简易指南]]></title>
    <url>%2F2019%2F06%2F23%2FGit%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[IntroGit 是一个开源的分布式版本控制系统，而 Github 则是目前全球最大的开源社区，那么何谓“版本控制”？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，使用Git可以对任何类型的文件进行版本控制。 不同于本地版本控制系统和集中式版本控制系统，分布式版本控制系统的优点在于其对文件丢失风险的规避能力。简而言之，分布式版本控制系统中的每个客户端，都具有完整的文件，即原始仓库的镜像。 Basic Conception在开始直接使用 Git 之前，得先了解一下 Git 内的基本概念🧐，了解这些概念会更好的理解 Git 的工作方式和原理。 Snapshots, Not Differences如标题所言，（记录）快照，而不是差异。不同于其他版本控制系统的差异比较，Git 会将文件视作“快照”，每次提交更新后，Git 会对之前的文件制作一个快照并保存这个快照的索引，也就是说，Git 会将更新后的文件替换掉之前文件，同时，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件（快照）。 Nearly Every Operation Is Local在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。因为，在本地保存着这个项目文件的镜像，你可以离线进行提交，并在网络状态良好的时候，在推送到主服务器上。 The Three StatesGit 有三种状态，本地仓库内的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。已提交已修改已暂存数据已经安全的保存在本地数据库中。修改了文件，但还没保存到数据库中。对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录及暂存区域。 Git 仓库工作目录暂存区域Git 用来保存项目的元数据和对象数据库的地方，从其他计算机克隆仓库时，拷贝的就是这里的数据。对项目的某个版本独立提取出来的内容，这些从 Git 仓库的压缩数据中提取出来的文件，放在磁盘上供用户使用或修改。暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，有时也被称作“索引”。 基本的 Git 工作流程如下： 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库内 How to useGit 有多种使用方式，可以使用原生的命令行模式（推荐），也可以使用 GUI 模式，但只有在命令行模式下，才可以执行 Git 的所有命令。 Installing Git针对不同的操作系统，Git 的安装方法也不相同，对于现在比较成熟的 Git 而言，不同安装方式所带来的功能上的差异已经不是那么明显。对于Windows用户而言，在 Git 官网上下载后安装即可。其他方式这里不再做过多介绍。 First-Time Git Setup安装好了 Git 之后，需要对 Git 环境做定量的定制化操作，每台计算机上只用配置一次，程序升级时会保留配置信息，也可以在任何时候再次通过运行命令来修改它们。 User Identity当安装完 Git 后应该做的第一件事就是设置你的用户名称与邮件地址，后面的每一次提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。12$ git config --global user.name "Bachzart"$ git config --global user.email "whistlesilp@gmail.com" 如果使用了--global选项，那么该命令只需要运行一次，因为之后无论做任何事情，Git 都会使用那些信息。若像针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有--global选项的命令来配置。 User Editor用户信息设置完毕后，可以配置默认文本编辑器，当 Git 需要你输入信息时会调用它。如果未配置，Git 会使用操作系统默认的文本编辑器。1$ git config --gloabl core.editor emacs Checking如何检查 Git 配置信息呢？可以使用如下命令来列出在当前目录下 Git 能找到的所有配置信息。1$ git config --list 可以得到如下所示结果：12345678910111213141516171819core.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslcainfo=D:/Git/Git/mingw64/ssl/certs/ca-bundle.crthttp.sslbackend=openssldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecredential.helper=manageruser.name=Bachzartuser.email=whistlesilp@gmail.com Getting HelpGit 自带有说明文档，可以直接使用以下三个命令查找指定命令的使用说明，或百度、google。123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 若想获得config命令的手册，执行1$ git help config Summary上面的内容介绍了 Git 是什么，Git 和其他版本控制系统的区别和基本用法等，接下来就开始使用吧~ Basic Usage在熟悉了 Git 的基本概念和用法后，就可以开始使用了。 Getting a Git Repository获取 Git 项目仓库的方法有两种： 在现有项目或目录下导入所有文件到 Git 中 从一个服务器克隆现有的 Git 仓库 Initializing a Repository in an Existing Directory如果只想在本地通过 Git 来进行版本控制，那么在bash内进入到想要建立仓库的目录，通过以下命令就可以建立一个仓库了。1$ git init 此时，在这个本地目录下会自动产生一个“.git”的目录，这个就是 Git 管理信息的目录，在 Windows 下默认隐藏。 Cloning an Existing Repository如果只是想获取一份网络上（或局域网服务器）已存在的 Git 仓库的拷贝，那么可以使用以下命令来将仓库克隆到本地。1$ git clone https://github.com/example 上述命令的格式为git clone [url]，https://github.com/example这个url并不是真正的存在，这里只做说明使用。 此时在当前目录下会创建一个“example”的目录，并在这个目录下初始化一个.git目录，从远程仓库拉取下所有数据放入.git目录，然后从中读取最新版本的文件拷贝。如果想重命名克隆下来的本地仓库的名字，可以使用如下命令：1$ git clone https://github.com/example myexample Local Repository前面已经提到了如何在本地创建 Git 仓库，现在来使用一下 Git 的部分功能。 Checking the Status of Local Reposity要查看当前目录下哪些文件处于什么状态，可以使用git status。以在本地新建的仓库为例，当使用git status命令时，会出现如下结果：1234$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track) 根据显示的英文的含义，可以得知当前目录下，没有文件，也无法进行提交，可以使用git add命令来跟踪文件。 Tracking a new file现在，在仓库内创建一个新的test.c文件，在使用git status命令来查看当前目录的状态。123456789$ git statusOn branch masterNo commits yetUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.cnothing added to commit but untracked files present (use "git add" to track) 此时，在Untracked files下面，出现了test.c文件，这意味着 Git 在之前的快照（提交）中没有这些文件（实际上，目前还没有一次提交）。Git不会自动将文件纳入跟踪范围，所以需要使用git add [file name]命令来跟踪指定文件，如下所示：12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c 此时，可以看到Changes to be committed这行下，存在new file: test.c，就说明test.c文件是已暂存状态（staged）了。另外，git add命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 Staging Modified Files紧接上面的步骤，若此时，修改了已暂存的test.c文件，此时使用git status命令，会看到如下结果：123456789101112On branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.cChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: test.c 这实际上就是 Git 的版本控制机制的特点—保存文件的快照而不是差异。也即是说，现在 Git 暂存区域内存储的文件是仍未修改的test.c，要暂存这次更新，需要再次使用git add命令来完成暂存，如下所示：12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c git status命令的输出十分详细，使用git status -s或git status --short可以得到更加紧凑的信息：1234$ git status -sA change.cAM test.c?? test.exe 新添加的未跟踪文件前面有??标记，新添加到暂存区域的文件前面有A标记，修改过的文件前面有M标记；当然，M的有两个可能的出现位置，出现在右边的M表示该文件被修改了但是还没放入暂存区，出现在左边的M表示该文件被修改并放入了暂存区。例如，上面的状态显示test.c文件在工作区被修改了，还未放入暂存区。 Ignoring Files一般总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表，通常这类文件都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。此时，可以创建一个名为.gitignore的文件，列出要忽略的文件模式。12345$ vim .gitignore*.[oa]*~*.exe*.txt .gitignore文件的格式规范如下： 所有空行或者以#开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配 匹配模式可以以/开头防止递归 匹配模式可以以/结尾指定目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号!取反 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式，比如*就可以匹配零个或多个任意字符。 TIPS：GitHub有一个十分详细的针对数十种项目及语言的.gitignore文件列表，可以访问 https://github.com/github/gitignore 获取更多帮助。 Viewing Changesgit status命令输出的信息只对文件所处的状态进行了展示，可能觉得模糊，如果想知道具体改了什么地方，可以使用git diff命令。git diff命令会回答两个问题： 当前做的那些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ git diff会通过文件补丁的格式在相应栏下显示具体哪些行发生了改变。现在修改test.c文件，在文件中加入如下一行：test.c12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0;&#125; 接下来，使用git diff命令查看修改的部分：12345678910111213$ git diffdiff --git a/test.c b/test.cindex e0e5171..8642431 100644--- a/test.c+++ b/test.c@@ -3,5 +3,6 @@ int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0; &#125;\ No newline at end of file 可以看到，Git 回显了文件更新区域的信息以及对应的更新内容，而此时，git diff比较的是工作目录中当前文件（未暂存）和暂存区域快照（已暂存）之间的差异，也就是修改之后还没暂存起来的变化内容。 使用git diff --cached/git diff --staged可以查看已暂存的将要添加到下次提交里的内容。123456789101112131415$ git diff --cacheddiff --git a/test.c b/test.cnew file mode 100644index 0000000..e0e5171--- /dev/null+++ b/test.c@@ -0,0 +1,7 @@+#include &lt;stdio.h&gt;++int main(int argc, char const *argv[]) &#123;+ printf("Hello Git!\n");+ printf("I want to change this file.\n");+ return 0;+&#125;\ No newline at end of file 注意到上面并没有printf(&quot;Test git diff!\n&quot;);，那是因为，更新后的test.c文件并没有暂存。另外，git diff只能显示尚未暂存的改动，而不是自上次提交（commit）以来所作的所有改动。 Committing Changes现在的暂存区与已经摸熟了，可以来愉快的提交了😊，不过正式使用仓库的时候，提交之前最好看看有没有什么记录没有暂存起来，可以先用git status命令看下，是不是都已暂存起来了，然后运行提交命令：1$ git commit 提交后，会跳入到 vi/vim 编辑器界面（不同系统可能不一致），基本上都是默认的提交消息，保存在.git目录下的COMMIT_EDITMSG文件内，开头的空行用来键入提交说明，其他#开头的都是注释，去掉与否取决于个人，也可以使用如下命令来简化提交：123456$ git commit -m "Test Commit"[master (root-commit) 88ba107] Test Commit 3 files changed, 18 insertions(+) create mode 100644 .gitignore create mode 100644 change.c create mode 100644 test.c 注意，master表示当前提交是在master分支进行的提交，88ba107就是本次提交的完整 SHA-1 校验和，下面的信息表示本次提交中，有多少文件修订过，多少行添加和修改过。 使用git commit -a可以跳过提交之前先使用git add暂存文件（这些文件必须已经被暂存过）的步骤而直接提交。 Removing Files要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域），然后提交。可以使用git rm命令完成此项工作，并连带的从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行git status时就会在“Changes not staged for commit”部分（也就是未暂存清单）看到该文件的删除记录了。例如，在Test目录下，删除change.c文件，使用git status命令可以看到：123456789$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: change.cno changes added to commit (use "git add" and/or "git commit -a") 然后还需在运行git rm记录此次移除文件的操作：12345678$ git rm change.crm 'change.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: change.c 这样下一次提交时，该文件就不再纳入版本管理了。 如果将文件保留在磁盘内，但是并不想让 Git 继续跟踪，可以使用--cached选项，如下所示：12345678910111213$ git rm --cached update.crm 'update.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: update.cUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) update.c 接着使用git commit命令提交后update.c文件就不在仓库内，但仍在磁盘上了。 Moving FilesGit 很聪明，一条移动文件的命令就能重命名文件并保留相同异名文件的状态，如下：1$ git mv file_from file_to 上述命令与下面三条命令类似：123$ mv file_from file_to$ git rm file_from$ git add file_from 使用一条命令干三件事，很棒吧~]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数的求法]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%B4%A0%E6%95%B0%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义介绍如何求素数之前，首先得明白素数是什么？所谓素数（也叫质数），是指大于1，且只能被1和其本身整除的数（此定义与合数的定义相对）。 简便求法在对时间复杂度没有要求的情况下，直接从定义出发，利用循环，一直做取余运算，就可以很容易的得到判断一个数字是否为素数的算法，具体如下：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1) &#123; flag = false; &#125; else &#123; for(i = 2; i &lt; number; i++) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 很明显，因为借助了一层循环，所以时间复杂度$O(n)$，优点就是十分容易理解了。 结合数学知识的优化在理解了简便求法之后，来稍微思考一下，偶数能被2整除，所以肯定不是素数，如果一开始先判断number是不是偶数，然后在从 3 开始判断number是否能被奇数整除，如此一来，整个循环次数就是$(n - 3) / 2 + 1$（奇数每次增加2，所以分母为2）了，当$n$较大的时候，这个值是趋近于$n / 2$的。接着来改写一下代码：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 相比简便求法，将总体时间缩短了一半，时间复杂度是$O(n/2)$。 实际上，循环区间可以缩减为$[3, \sqrt{number})$（此处的数学证明就不多说了😁，可以简单想一下，一个数$n$，对于$x &lt;= n$，如果$n$能整除$x$，则$n$也一定能整除$n/x$，这两个数中必定有一个大于等于$\sqrt{n}$），具体如下：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i * i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 上述代码块中用i * i来代表平方根的写法较为常见，这样此算法的时间复杂度就为$O(\sqrt{n})$。但是，i * i这种写法，会溢出，最好就使用sqrt函数。 转换思路按照之前的做法，无论i的值是素数还是合数，都对number进行了整除的运算。实际上，判断number是否为素数，只需要在i的值为素数的情况下，判断number是否能被i整除即可，若能整除则不是素数，反之则是。在进行上述计算的过程中，需要提前准备一张素数表来帮助计算，具体如下：1234567891011bool Is_Prime(int number, int Prime[], int NumOfPrime) &#123; bool flag = true; int i; for(i = 0; i &lt; NumOfPrime; i++) &#123; if(a % Prime[i] == 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; 在计算的数据较大的情况下，无法直接给定素数表，需要边判断边更新，这样会消耗掉一定的时间，所以上述算法的实际时间复杂度$O(n) ∈ (\sqrt{n}, n/2)$，但此法很适合需要构造素数表并求和的场景。 紧接着刚才的思路，以2为例，在判断出其为素数后，其倍数$4、6、8、10...$就是非素数了，那么一次性将这些数字标记为非素数，也可以提高效率，这就是“筛选法”构造素数表，具体如下：1234567891011121314bool IsPrime[NumOfPrime];for(i = 2; i &lt; NumOfPrime; i++) &#123; IsPrime[NumOfPrime] = 1;&#125;void Get_Prime() &#123; int x, i; for(x = 2; x &lt; MaxNum; x++) &#123; if( IsPrime[x] ) &#123; for(i = 2; i * x &lt; MaxNum; i++) &#123; IsPrime[i*x] = 0; &#125; &#125; &#125;&#125; 粗略分析代码，可知此算法时间的复杂度为$O(n * loglog{n})$，之所以是这个时间复杂度，是因为一次性计算出了$[0, MaxNum)$这个区间内的所有素数，此算法实际效果较好，对于需要构造素数表的情况很方便。 扩展上面介绍的“筛选法”，其实是古希腊数学家埃拉托色尼（Eratosthenes，274 B.C ~ 194 B.C）提出的一种筛选法，也称埃氏筛法。实际上，结合利用素数表来判断素数的思路，对于合数而言，如果其只要被其最小质因子整除，即可判断其不是素数。那么去掉这部分重复计算的过程，不就可以提高效率了吗？以16为例，在埃氏筛法中，$x = 2$时，筛选掉了$4、6、8、10...$，当$x = 3$时，又重复计算了$6、12...$等数。接着来修改下代码：123456789101112bool Number[MaxNum];memset(Number, true, sizeof(Number));int Prime[MaxNum], count = 0;for(i = 2; i &lt; MaxNum; i++) &#123; if( Number[i] ) &#123; Prime[count++] = i; for(j = 1; j &lt;= num &amp;&amp; i * Prime[j] &lt;= n; j++) &#123; Number[i * Prime[j]] = false; if(i % Prime[j] == 0) break; &#125; &#125;&#125; 上述代码的时间复杂度为$O(n)$（计算过程暂不深究），所以此种筛法也叫线性筛法，不过提升效率的代价就是多余的空间开销了，一般而言的优化都是用空间换时间这样的思路。]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Prime</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨夜杂思]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%9B%A8%E5%A4%9C%E6%9D%82%E6%80%9D%2F</url>
    <content type="text"><![CDATA[是夜，窗外的雨声淅淅沥沥的下着，心里想着自己这段时间的生活，不由得有了些感慨，毕竟又是一年逝去了。 See the sky about the rain - Neil YoungYour browser does not support the audio tag. 雨，原来我是很讨厌的。因为，下雨就意味着要打伞，会嫌麻烦，而且还会淋湿。更甚者，若是雨下的太大，一旦把鞋打湿了，那滋味可就不好受了。不过，即便如此，现在的我，于雨，是喜欢的。 每当下雨之时，我总会有这样的想法：是谁又在独自伤心？惹得老天爷陪她（他）一起哭？。最初萌生这个想法的时间，是自己的高中阶段，具体无法记清是那个年级了，只知道那是一个傍晚，下课后大家都去吃饭了，正巧那天我心中有事，就在教室发呆，等回过神来的时候，才发现还得去吃饭，毕竟晚上还得上课。于是下楼，出去才发现下雨了，想也没想，迈着步子就往前走，走着走着，突然发现，好像没那么大，于是原先的疾步成了漫步，紧接着，脑中就冒出了这个想法，回过神来才发现，我怎么会有这样的想法？因烦事僵直的嘴角，此时有了微微上扬的弧度，心中不免乐观了起来。至此之后，每当下雨的时候，在其他人都抱怨下雨地滑、淋湿之类的时候，我总会在心中想，到底是谁又在伤心呢？希望老天爷的雨可以抚慰住她（他）受伤的心...后来每当自己心情不好的时候，总看看天上是否有雨，像是要得到安慰的孩子一样，不过好在，自己是被满足的。 现在又一年的五月最后的日子了，面临即将到来的六月，心中不免有些不舍，时光好像又趁着自己不注意溜走了。曾经感叹时间过的太慢的自己，现在已经成了感叹时光的“老人”。是从什么时候开始，自己的心没有当初的那份“年轻”了呢？好像连自己这个变化也记不清了，这个问题揭开来看，感觉自己有点可悲呐。以为自己是按照自己的方向前行，但却连自己的转折点都不清楚，那也就意味着多年来的自己依然是一个被动的选择者？诶，不对，有句话，不是叫时间总是在不经意间改变了大家吗？这应该是“常理”，不是我可抗的...吧？说这么多，其实结果如何，心中所思，答案早已不变。 窗外的雨声好像小了些，从窗户的细缝中有凉风吹进来，微微拂起了窗帘，是来提醒我该睡觉了吗？好像又是在自我安慰呢（囧），大半夜隔壁竟然还有杀猪一样的笑声传出来，是什么事情让他们这么兴奋？算了，没有兴趣去了解，现在的自己只想专注到自己的事情上。 指甲还有一两周就长出来了，这样我又可以做手指操了。糟糕，笔记本好像要没电了，这次就先写到这里吧，滚去睡觉ing。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用库函数]]></title>
    <url>%2F2019%2F05%2F24%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Intro最近发现一个问题，做题的时候，不管有的没的，要用的函数全靠自己写，写来写去也懒得去管到底有没有那个库函数了…这样不太好，日后还不是得把自己累死，还是得善于利用东西才行（又为自己偷懒找借口🤣）。于是，这篇文章就用来记录C中常用的一些库函数，以免日后又忘记了。 stdlib.hstdlib.h即standard library标准库头文件，这个头文件内有很多有用的工具函数。 qsortqsort函数是C语言自带的排序函数，采用排序方法是快速排序，其声明位于头文件stdlib.h中，貌似快速排序是实际使用效果最好的几种排序方法之一。 Function Prototype函数原型如下：1void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *)); 参数说明：basenumsizecomparebase指向数组的起始地址，通常会传入一个数组名num表示该数组元素的个数size表示数组中每个元素的大小（字节数）(*compare)(const void*, const void*)为指向比较函数的函数指针，决定了排序顺序 Compare Functionqsort函数声明中的compare参数是一个指针，指向一个比较两个元素的函数。比较函数的原型应该是int compare(const void *a, const void *b);，注意这个函数的形参是const void *型，也就是说，是不限制参数指针类型的，并且，返回值是int型的。qsort函数在使用compare函数指针调用compare比较函数时，传入的实参是没有限定指针类型的。一般而言，compare函数按照下面的代码来写：123456int compare(const void *a, const void *b)&#123; if(*(int*)a &lt; *(int*)b) return -1; if(*(int*)a == *(int*)b) return 0; if(*(int*)a &gt; *(int*)b) return 1;&#125; 从上面的代码可以看出，指针a和b在传入到compare比较函数内后，先进行了指针类型的强转操作，然后再分别对强转后的a和b指针进行解引用，并做差来判断*a和*b的大小，根据三种不同的情况返回三个值，分别对应以下三种情况：-101(*a)所指向元素会被排在*(b)所指向元素之前(*a)所指向元素和*(b)所指向元素之间顺序不确定(*a)所指向元素会被排在*(b)所指向元素之后 Examples对普通int型数组进行排序时：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(const void *a, const void *b)&#123; return (*(int*)a - *(int*)b);&#125;int main(int argc, char const *argv[])&#123; int i, array[8] = &#123;30, 52, 11, 29, 58, 3, 88, 60&#125;; qsort(array, 8, sizeof(array[0]), compare); for(i=0; i&lt;8; i++) &#123; printf("%d ", array[i]); &#125; return 0;&#125;/*Print: 3 11 29 30 52 58 60 88if '(*(int*)b - *(int*)a)' replaces '(*(int*)a - *(int*)b)'then Print: 88 60 58 52 30 29 11 3*/ 对其他类型的数组而言，使用方法也大致如此，对字符串数组（即二维字符数组）使用时，可以将比较函数这样写：1234int compare(const void *a, const void *b)&#123; return (strcmp((char*)a, (char*)b));&#125; 配合strcmp函数使用就会很方便。另外，快速排序是不稳定的排序算法，对于结构体而言，当两个元素的值相等时，经过快速排序后，其相对位置可能发生了改变，这就导致结构体排序完成之后，输出结果不对（但是序列有序无误），为了避免这种情况，需要在结构体内新增一个标记位，当两个结构体值相等时，比较标志位的大小，从而保持二者相对位置不发生改变。 ctype.hctype.h这个头文件全称应该是character type吧，因为其内部定义了一批 C 语言字符分类函数，用于测试字符是否属于特定的字符类别。这些函数实现起来都不难，再重复造轮子就有点划不来了。 在 C 语言中，对于一个字符变量而言，其本质依然是整型变量，所以下面函数形参类型就直接用int了。换句话来讲，这些函数的实现原理应该就是直接与 ASCII 码进行比较。 isalpha这个函数用于判断传入的字符是否是字母（包含大小写）。函数原型：1int isalpha(int ch); 若传入的字符是字母，则返回非零，若不是则返回0。 isdigit这个函数用于判断传入的字符是否是罗马数字（0-9）。函数原型：1int isdigit(int ch); 若传入的字符是数字，则返回非零，若不是则返回0。 isxdigit这个函数用于判断传入的字符是否是十六进制字符（0-9、A-Z、a-z）。函数原型：1int isxdigit(int ch); 若传入的字符是十六进制字符，则返回非零，若不是则返回0。 islower这个函数用于判断传入的字符是否是小写字母（a-z）。函数原型：1int islower(int ch); 若传入的字符是小写字母，则返回非零，若不是则返回0。 isupper这个函数用于判断传入的字符是否是大写字母（A-Z）。函数原型：1int isupper(int ch); 若传入的字符是大写字母，则返回非零，若不是则返回0。 tolower这个函数用于将传入的字符转换为小写字母。函数原型：1int tolower(int ch); 返回值为所传入字符变量的小写字母。 toupper这个函数用于将传入的字符转换为大写字母。函数原型：1int tolower(int ch); 返回值为所传入字符变量的大写字母。 isalnum这个函数用于判断传入的字符是否是字母或数字。函数原型：1int isalnum(int ch); 若传入的字符是字母或数字，则返回非零，若不是则返回0。 string.hstrcpy这个函数用于拷贝字符串。函数原型：1char *strcpy(char *dest, char *src); 需要注意的是 dest 数组必须要足够大，不然可能会造成缓冲溢出的情况。 math.hceil返回不小于 x 的最小整数（向上取整），函数原型：1double ceil(double x); floor返回不大于 x 的最大整数（向下取整），函数原型：1double floor(double x); round返回 x 的四舍五入整数值，函数原型：1double round(double x);]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言里爬过的“坑”]]></title>
    <url>%2F2019%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E9%87%8C%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Intro那是一个下着大雨的夜晚，室外急促的雨声正好映衬着室内紧张的气氛，快，只剩下最后一个BUG了！终于在大半个小时之后解决了，仔细一看，原来是之前碰到过一次的问题了...心中不免想到，要是上次有好好记录就好了。于是，就动了整理这篇Blog的心思啦~此Blog会长期不定时更新，记录下自己在跟老爷子C玩耍的过程中，碰到的一些坑爹之处（菜请轻喷，嘿嘿）~ scanf 关于scanf先说一点，scanf函数是带返回值的，有的编译器会忽略掉这个返回值（没有告警产生），但是实际上是存在的，切记。 scanf这个函数给用户留下的坑，实际上不是它的返回值，而是这个函数对用户能向其输入的东西的规定（😓说了一大堆让人听不懂的话...）。换句话说，也就是scanf自身对输入流中的数据的获取的机制可能会让用户“坑爹”。对于C语言而言，在读取键盘输入的数据时，一般是带缓存的数据输入，需要按回车键才能完成该“行”数据的输入确定。而scanf对这个回车确认符并不进行处理，回车符会留在输入缓存区中。因此，在下一个“字符”操作函数（getchar()、scanf(&quot;%c&quot;, &amp;x)、gets(s)等）运行时，会读到这个回车确认符。另外，在读取数值型数据或字符串（注意这里没有字符变量）时，scanf会从第一个非空白字符（空白字符指：回车、空格、TAB等）开始读取，自动忽略前面的空白字符，而遇到空白字符结束该类型数据的输入。因此，对于这个回车确认符（空白字符）的处理，需要看下一个输入的数据类型是什么，如果是字符类，那就需要消除掉这个回车确认符，处理办法有多种方式，下面介绍3种方法：Method 1Method 2Method 3使用fflush(stdin)命令强制刷新输入缓存，丢弃缓存中的数据，注意此种方法在windows下使用有效，linux无效，因为Linux没有fflush。 12345int a;char c;scanf(“%d”, &amp;a);fflush(stdin); //clear the ‘enter’ charscanf(“%c”, &amp;c);回车符也是字符，可以使用getchar();来吃掉这个回车符号。 12345int a;char c;scanf(“%d”, &amp;a);getchar(); //clear the ‘enter’ charscanf(“%c”, &amp;c);利用scanf函数的一些机制，如：scanf(&quot;%d%*c&quot;, &amp;i)，%*c表示读一个字符，并不赋值给任何变量。 123int a;char c;scanf(“%d%*c%c”, &amp;a, &amp;c); 另外，关于scanf还有一个比较有特点的地方，就是无法读入空格字符，所以包含空格字符的字符串就得使用gets或者fgets函数来读入了。还有一个就是&amp;的使用。注意，除了读入字符串外，其他都需要使用&amp;，估计这是不少新手会犯的错误了😀，问题是不会编译不报错也不警告，偶尔不仔细，老手都要找半天... ifif关键字可不“坑”，“坑”的是使用它的人（又黑自己一把...😂），if一般和else及else if配合使用（也可以单独使用），一般用法如下：123456789101112131415/*if-else*/if(expression)&#123; statement1;&#125;else&#123; statement2;&#125;/*if-else if-else*/if(expression)&#123; statement1;&#125;else if(expression)&#123; statement2;&#125;else&#123; statement3;&#125; 上述内容，读懂很容易，但问题其实就在这个expression上，这个表达的值会影响if这类语句的判断。众所周知，expression为true执行statement1，为false则执行statement2，else if同理。所以严格上讲，if认为的true是非0（其他语句，如while的条件判断机制应该也是这样），啥意思？就是说，不管expression的值是1还是-1，if都是认为是true（建议尝试），所以，可别看到表达式的值是负数，就认为条件不成立了。 parameter passing这里所介绍的参数传递主要是针对C语言内的函数。众所周知，C的函数采用的是值传递的方式，也即传入到函数内的参数，不管传入的值如何修改，依然不会改变main或其他函数内变量的值，要想改变有多种方式，这里简单介绍三种，具体如下：Way 1Way 2Way 3使用全局变量利用函数返回值，形如：a = abs(a);这样的使用方法使用指针，利用&amp;传入变量地址，修改指针指向的地址保存的值，如：*p = x;的用法如果只是介绍这些，那太简单了，这里想要说明的是指针在函数参数传递过程中的变化。如果一个函数的参数中存在指针，并且这个函数内会改变传入这个指针的指向（如：链表遍历），针对这种情况，C依然遵循值传递的规则，也就是说，即便指针被传入函数中了，它也不会改变这个指针在main或其他函数中的指向，具体请看下面的代码：1234567891011121314#include &lt;stdio.h&gt;void f(int *a);int main(int argc, char const * argv[])&#123; int *A; printf("%p\n", A); f(A); printf("%p\n", A); return 0;&#125;void f(int *a)&#123; a++;&#125; 上述这段代码的两次输出结果是一致的，也即指针也是遵循值传递的原则的。 typedef关于typedef的用法，这里不做过多介绍，只收集一下平常见到的使用方法。 为基本数据类型定义新的类型名1typedef int Data; 上述代码的作用能达到的效果就是int和Data等价，也即int a;和Data a;是两种相同的写法，此种方法在跨平台移植和作有意义的类型名时很方便。 为自定义结构类型定义类型名称注意说法，为自定义结构类型定义类型名称，注意只是类型名称哦，下面是一般的使用方法。1234typedef struct point&#123; int x, y;&#125; Point; 如果需要为结构定义指针，需要换一种方法：12345typedef struct LNode *List;struct LNode&#123; int Data; List Next;&#125;; 不过一般而言，标准的写法是下面这种：12345struct LNode&#123; int Data; struct LNode *Next;&#125;;typedef struct LNode *List; 两种写法都是编译通过的（No Warnings），究竟怎么写，就是智者见智的事情了。 为数组定义类型名称12typedef int int_array[10];int_array array; 按照上述代码， array就是一个容量为10的整型数组了。 为指针定义名称123456/*odinary pointer*/typedef char* Pchar;/*function pointer*/typedef int *(*Pfun)(int, char *);Pfun a[5]; //Pfun a[5] &lt;==&gt; int *(*a[5])(int, char *); 上述代码中，int *(*a[5])(int, char *)实际上是定义了一个返回值为int*的函数指针数组，函数的有两个，分别是int和char *。 two-dimensional arrayC语言中实际上并没有严格意义上的二维数组（其他程序设计语言可能也是如此？），因为物理内存的地址是连续且一块一块的，那C语言是如何去保存二维数组和寻址的呢？ 按照上述的思路，先来总结一下二维数组的特点。很明显，二维数组包含三个参数：行（Row）、列（Column）和需要存的数据（Data），既然前面已经说过了物理内存是连续分布的，那毫无疑问，二维数组中的 Data 依然是连续的存储在物理内存中的，这个现象是不是在哪见过？没错，就是一维数组；接着，如何去寻址呢？这个问题其实可以用二维数组的行和列来解决，假设总行数为R，总列数为C，找第2行，第3列的元素，按照顺序存储的规则，实际上对应元素的下标（下标从0开始）应该是2 * C + 3，一般化就是i * C + j。举个实例，按照如下的矩阵：$$\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6\\7 &amp; 8 &amp; 9\\10 &amp; 11 &amp; 12\\\end{matrix}$$C语言编译器要提取8这个元素，整个矩阵是4行3的，若行、列下标从0开始，行、列循环变量分别为i、j，那么8这个元素对应的下标（i = 2, j = 2）就是i * C + j = 2 * 3 + 2 = 8，实际上也就是从左往右依次按序数下来的结果。 character二维数组也有字符二维数组和整型二维数组，字符二维数组的使用会简单点，咱先从简单的来。字符二维数组实际上很容易理解，可以把二维数组想象成一根一根“辣条”（别说你没吃过...囧），这一根根“辣条”，每一根都是一个一维字符数组（其实就是一个字符串啦~）。1char str[3][5]; 上面这行代码的意思是声明一个字符串数组，这个字符串数组的容量大小是3，每个字符串能存储的最大长度是4（因为\0也要占一位），也可以按照下面的方法初始化：123char str[3][5] = &#123;"str1", "str2", "str3"&#125;; 之所以分开三行写，是因为想展示出一条一条的样子（笑ing），这是可以直接输出的哦~ 如果你指针学的不错的话，你一定会发现str[0]、str[1]和str[2]其实就是分别指向这三个字符串的指针。 所以，字符串数组还可以这样声明和初始化：123char *str[3] = &#123;"str1", "str2", "str3"&#125;; 严格上来讲，char *str[3]其实声明了一个指针数组，这个指针数组有3个字符型指针变量，分别指向三个字符串。其中的每个指针变量，其实可以当作每个字符串的头指针来用。 number明白了字符二维数组后，数字型的二维数组理解起来就简单了。首先，它不再是“辣条”了，他是单独一个一个的，不过存储方式依然是顺序存储的，二维数组的逻辑结构，其实就是上面提到过的矩阵。不过它的容量计算很简单，也就是行列之积了。 how to use如何使用这类二维数组，我们考虑三个方面的应用：输入、输出和传递。 input and output懂了输入，其实也就会输出了，那就只介绍输入了（偷懒😜）。 对于字符串数组（这样叫其实更合适也更易于理解），与普通一维数组一样，若有多个输入，则使用循环，逐个读入即可。 对于数字型二维数组，先输入行，还是先输入列取决于实际应用，由于不仅要输入行，还需要输入列，所以得使用二重循环搞定。 function parameter transfer 二维数组作为函数参数传递的过程就是个有点玄乎的过程了，不过切记一点，数组传递到函数中的都是指针。 字符串数组传递时，有两种使用方法，分别如下：Character 1Character 21void fun(char (*str)[5], int n);1void fun(char str[][5], int n); 上述的这两种方法有一个共同点，也即需要给定每个字符串的长度。 数字型二维数组的传递与字符串数组的传递类似：Number 1Number 21void fun(int (*array)[5], int n);1void fun(int array[][5], int n); bool早期的C标准内其实是没有bool类型的，原先一直存在于C++中，后来在C99标准发布的时候，加入了bool类型。 在使用bool类型时，需要引入头文件stdlib.h，用法如下：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool func(int a) &#123; if(a &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main(int argc, char const *argv[]) &#123; printf("func(-1) = %d, func(1) = %d, func(0) = %d\n", func(-1), func(1), func(0)); return 0;&#125;/*Result:func(-1) = 0, func(1) = 1, func(0) = 1*/ 明显可以看出此时false = 0, true = 1。 若无法引入头文件stdbool.h时，该如何继续优雅的使用bool类型呢？ 一般而言，有两种方法：typedef#define1typedef enum&#123;false, true&#125; bool;利用typedef和enum关键字构造枚举。123#define bool int#define false 0#define true 1使用宏定义直接定义（C99就是这样干的，可以看看stdbool.h头文件的内容）。 operator关于C语言运算符的问题，实际上就是不同运算符之间优先级（precedence）的问题，这部分问题，主要是针对应试吧，生产环境中大概写个测试程序就能得出结论了吧~ 优先级 运算符 结合性 1 () 从左到右 2 !、+、-、++、– 从右到左（单目+、-） 3 *、/、% 从左到右 4 +、- 从左到右 5 &lt;、&lt;=、&gt;、&gt;= 从左到右 6 ==、!= 从左到右 7 &amp;&amp; 从左到右 8 &#124;&#124; 从左到右 9 =、+=、-=、*=、/=、%= 从左到右 注意：上述表格第二行中，“单目+、-”指的即是正负号。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[房屋装修之“坑”]]></title>
    <url>%2F2019%2F05%2F15%2F%E8%A3%85%E4%BF%AE%2F</url>
    <content type="text"><![CDATA[引子这几天家里的房子在装修，看着母亲那么忙碌和操心的样子，于是便趁着自己偷懒的时间，回去协助一下母亲，并顺便收拾点自己之前的“家当”—— 就是书和写过的笔记了。 何谓装修说起装修，我对这个名词的概念略微有点模糊，得在这个词前面加点啥来帮助理解和想象，比如：房子装修。仔细来讲，装修又称装潢或装饰，是指在一定区域和范围内进行的，包括水电施工、墙体、地板、天花板、景观等所实现的，依据一定设计理念和美观规则形成的一整套施工方案和设计方案。一般而言，针对不同的环境，有着不同的装修方案和风格，酒店和商场的装修方案和风格就大不相同，而这是由这些场所的职能所确定的，必须要满足大众化的认知，即装修能被大众所接受、理解，进而达到喜欢。装修，需要施工，依据施工的对象（水电、墙体、地板、天花板等），对应的工人师傅也可以分为：木工、水电工、瓦工、油工，而您家住的房子的“外观”就是由这些人，一步一步来完成的。 如何“装修”看着上面的大标题，之所以加上引号的原因在于，对于房主（买房的人）而言，如何装修呢，其实就是花钱找人干活罢了，毕竟咱又不会和水泥、做木工的。嗯，既然是要花钱，那咱这钱得花的在“点”上才行，至于会不会被坑，这就得找对人了。那么回到正题，就目前市场而言，房子装修的方式（和师傅的“商务”合作方式😂）大概有两种： 包工包料，也即“包干”（这种宣传手段随处可见…）包工不包料，材料需要主人购买，师傅只负责干活了 那么，按照以上的两种方式，也有不同的优点和缺点，包工包料最直接的优点就是，客官您给钱就成，一切师傅替您搞定。这种方式，得看找的师傅的人品了，要不然给您偷点工、减点料，房子住个一年半载就返工的，那可正是有的受了，当然了，要是您钱给的足，那当咱没说这话。不过，对于一般家庭而言，多少还是会考虑到综合预算及性价比等方面的。所以呢，选择这种方式的，一般会找亲戚或关系特别铁的“哥们”（亲朋好友）。对于另外一种方式而言，那就意味着房主又得想办法找人，又得想办法去找渠道购买合格的材料（劳心啊😝）。先不说找人干活得找个靠谱的人，单单只从购买材料的角度讲，房主若不是相关行业内的人士，在购买这些材料的时候，会比较困难。首先，不知道购买那个型号、那个品牌的材料，不过这个问题可以通过去询问雇佣的师傅来解决。紧接着的问题，就是购买的渠道和“识货”的本领了，购买渠道略带风险，不然买到次品或假货就难受了，当然如若能自己分辨假货，那最好不过了（需要经验）。其实，在整个装修过程中，仅仅只注意上面的内容还不够，从一开始确定装修的时候，有点需要确定的就是，装修的顺序了！一般而言，可以大概按照下面这个顺序来进行： 主体改造 → 水电 → 瓦工 → 木工 → 油工 → 灯饰 → 清洁 → 验收当然了，不同地区的装修市场的装修顺序可能不是一致的，但大体上是一样的，不然的话，不同手艺的师傅无法配合干活的。 装修之“坑”俗话说的好：吃一堑长一智所谓的装修之“坑”，“坑”在什么地方呢？还能在哪…钱呗，正所谓，无商不奸，东西卖给你，商家哪能不赚钱呢，是吧。不过话说回来，咱还是那个态度，赚钱可以，价格合理公道，质量优良耐用，该付的钱咱照样给（哇，好无力的感脚~）。不过呢，不同地区的市场可能在某些地方上有所差异。就拿前几天，咱碰到的一个“坑爹”的事情为例。 起因家中房子装修，需要安装防盗网，于是便找人去做了，但没有提前把价格谈好（这个是真的烦，以后做事之前一定得先把这些利益关系处理好）。 安装做好之后，即进行安装，整个过程中一切OK。 问题由于在做之前，没有谈好价格的问题，从而导致，最后在结账的时候，成了“糊涂账”，造成了一种公说公有理，婆说婆有理的局面，手动捂脸ing。 问题成因之所以会存在这个问题，咱得先明确这个防盗网的议价规则，按照我这边本地的市场，防盗网是按照$X元/m^2$的价格来计算的，而防盗网的结构是下面这种结构：接下来的问题是按照这个结构，如何计算这个物体所占的面积（$m^2$），恰巧问题就出在这里了。 计算方式按照之前的思路，防盗门窗面积的计算方法其实有两种： 逐面计算，累加得结果逐面平铺，计算整体，减去不存在面，即得结果 具体而言，可以参照下图进行计算：从图中可以分别知道两种方法对应的计算方法： $1.\ S_{sum} = S_1 + S_2 + S_3 + S_4 + S_5$$2.\ S_{sum} = S - 4 \times S_1$ 只要尺寸量的是正确的，两种方法皆可计算出防盗门窗的真实面积，商家采用的是第二种方法，不过没有减去那4块不存在的面积，而这也就导致按照这两种方法计算出来的结果相差了大概10个$m^2$左右，与单价一合计，差值还是比较大的。如果是存在的面积计算在内，还可以理解，但那4块面积是不存在的，不存在还算进去，那不是无中生有吗？于是去找商家理论，结果被告知是市场规则、行业规则（总之就是不让价），这不是摆明了坑人么？后来，又了解到，据说如果是给亲朋好友做，是得减去那四个不存在的面积的，如果不是亲朋好友，那就歇菜了（😂，果然是无商不奸）。 解决方式磨嘴皮子磨嘴皮子磨嘴皮子…没有啥捷径哈~ 总结还是那句话，做事之前，千万要处理好利益关系。不过话说回来，商家这确实有点“坑”人，明里来说材料贵即可，还玩这些“花招”，真是“兵不厌诈”？更何况只是简单的小学数学😂！哎，这也就欺负一下常年在外打工挣钱的和文化水平不高的人，恰巧正好是咱们父亲、母亲那一辈人。另外，从这些事情也可以看出，家装这个行业的水也是足够深的哈，先不说材料可能会搞鬼了，光着算账都着实让人觉着坑爹😑，都不知道该说啥好了。类似的问题，在木工、瓦工等装修过程中同样存在（其他行业估计也这样），所以，吃一堑长一智，这话记住准没错~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>Interior Finish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇葩的国内BGP业务架构]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%A5%87%E8%91%A9%E7%9A%84%E5%9B%BD%E5%86%85BGP%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Intro国内存在BGP业务，但是实际上并不是严格意义上的BGP，而是通过模拟来构建的“静态BGP”；之所以是这样的情况，原因是运营商和政策…打住，扯远了，我什么都不知道🤫。反正客户需要就做😂，本着先做先完事，隐患日后再说的原则（笑ing），好歹算是捯饬出来一个。 Static BGP Brief Description与BGP相关的原理内容在这里不介绍了（咱也不太懂🤣），具体说下做这玩意的前因后果吧，这部分内容就当“侃大山”吧🤔。 国内运营商三巨头：中国电信、中国移动、中国联通，这三家国企想必大家都比较熟（tao）知（yan）；而与这三家运营商互联的方式呢，一律全部都是采用静态互联的方式；之所以采用静态互联，也不是因为动态技术不成熟等之类的缘由，其实就是简单且易控制，直接放给你就完事，想控制直接修改配置就好，其实还有一个点，那就是采用动态后，对某些网络提供商而言会比较“不公平”，动态路由收敛可是选择延迟最小、损耗最低的线路的。具体嘛，咱也别太深究，是这么个规定，大环境是这样，咱改变不了，遵守就行了。话在说回来，按照这样的环境，对于网络提供商和运营商接入的路由器而言就只能保证一个线路的方向了（单、多线无法与BGP共存），那BGP又是从何谈起的呢？还有其他的双线、三线之类的业务又是怎么做的？ 得嘞，咱还是先从单线业务说起吧，这没啥难度的，单线业务，给服务器配一个IP完事，没啥说的。这类业务的特点就是—不管你用源IP去访问什么地址，都是从一个线路出去的，比如，源IP电信的，那你出局就是电信线路，源IP联通的，出局就是联通线路。 在说双线业务，单线业务配一个IP，那双线业务不就配两个IP完事吗？(⊙﹏⊙)，对了一半；双线业务的确需要配置两个IP，但是并不是配置两个IP就完事了，还需要在服务器上导入去往各个地址段的路由。什么鬼？服务器还能加路由，还真能加😓，这如果要说，又要牵扯到一些东西，嗯，别急，给你娓娓道来。 咱先不说怎么去加路由，咱先介绍下国内的网络环境。首先得明确IP地址这个玩意在大网环境内是唯一存在的（私网地址你就折腾去吧），换句话说，三大运营商是拥有只属于自己的IP地址的（什么？你也想要属于自己的IP地址？自己去找管理IP的组织去买吧，多少钱？嘿嘿，自己去问。），并且这些地址在国内的大网环境下是唯一的。这样就会产生一个问题，既然联通的地址只属于联通，那电信用户如何去访问联通的地址呢？答案就是运营商之间做了互联，至于是动态的还是静态的，这个，嘿嘿，不是咱讨论的范围，在有互联的前提下，电信用户也就可以去访问联通的地址啦。好，这个问题明白了，咱在来看看另外一个现象，不知道各位看官有没有留意过，网络游戏总会有一些网通区、电信区等，如果电信用户已经可以访问联通地址了，那么运营商都做成全网可以互相访问不就得了，那这样还搞这些区干毛？诶，这个其实是有点讲究的，嘿嘿。答案就是，如果你是联通用户，你选择网通区进行游戏，你会觉得网速非常快。你问为啥？因为网通区的游戏服务器IP肯定也是联通的IP，这样在本运营商内部进行访问的时候，那不就是在“内网”里面进行数据交互了吗？都没跑到“公网”上去，速度肯定快啊😂。其他也同理，这也是为啥有人会说中国的网络实际上是一个大的局域网，特别是被Great Firewall of China禁掉一些国际IP后🙊。 好了，在回到加路由的问题上来，咱已经知道给服务器配置两个IP了（现在应该也知道为啥要搞这种双线机器了吧，手动笑哭），那加路由怎么加呢？对于一个IP地址而言，如果要和其他子网通信，必须存在网关，利用网关来接收、发送数据包，双线机器两个IP，肯定也有两个网关啊，服务器能同时配置两个网关？答案是不能，那ta niang的怎么办呢？答案是写路由啊（为了引出你来，写了这么多字，手酸啊🙃）。以配置了联通、电信的地址的双线机器为例，访问联通地址使用联通网关，访问电信地址使用电信网关，这样就可以啦，就可以愉快的访问按指定线路访问指定的运营商的IP地址啦。 写到这里，网络工程师可能会有问题了，路由器、交换机上怎么去配置多个网关（子网划分），并且做到不同线路的出局呢？ 当然了，对于网络工程师而言，这里还需要考虑一个问题，双线机器有几个网卡，假如有多个网卡，那很简单，不同的网卡做通不同的数据就好啦，那一个网卡怎么办？ 首先，先来解决多个网关的问题，服务器如何去配置，运维工程师自有妙计，咱不去管它；路由器、交换机如何配置呢？以华为设备为例，配置过程大概如下：1234[R1]vlan 10[R1-vlan10]interface vlanif 10[R1-Vlanif10]ip address 10.0.254.1 24[R1-Vlanif10]ip address 10.0.253.1 24 sub 完事后是这样：12345#interface Vlanif10 ip address 10.0.254.1 255.255.255.0 ip address 10.0.253.1 255.255.255.0 sub# 这样就把两个不同网段的数据做到一个vlan下了。 咱们在看出局的问题，出局需要借助一个叫PBR, Policy Based Routing的玩意，嘿嘿，厂商真会玩，是跟运营商偷偷商量好了是吧。具体如何去做，要视具体的网络架构和环境去做（自己去百度😝）。 好，双线业务大致就是这样了，对应的三线业务，就不用我说了吧，嘿嘿，不过网络提供商可能会用“BGP”地址来代替多线业务配置的多个IP地址来避免IP地址的浪费（但据说“BGP”地址贵啊，不过，这是商务的事情，商务自有商务的一套）。 回过头来看一下，双线、三线业务需要做的配置还是比较多的，不管是服务器还是路由器，不也是累的一逼吗？有没有什么能一次性搞定，而且三网内都跟跑“内网”一样呢？诶，运营商又出马了：觉得麻烦是不是，好，我给你们减负（真是这样么？运营商会这么好心？），我们现在能提供一种“BGP”的产品，这类地址具有能从三网线路独立访问的特性。什么意思呢？也就是说各个运营商的用户访问这些“BGP”地址的时候能用自身运营商的线路去访问，而不需要跨运营商。所达到的效果其实是和三线业务一样的，只不过会方便很多（对客户而言，IP配置一个，服务器也不用写路由，嗨啊），但是一样需要前期把路由器上的配置都做好啊啊啊，还是好麻烦啊。 后来，人们给这种“BGP”地址一个洋气的名字，就叫做Static BGP🤣。 好，故事到此结束🤣。 Static BGP Routing下面就进入正题啦。具体架构就按照下面这个图吧~ 又弄了一张图，两张图结合一起看，对比来看，容易一些（据说是TX的网络部门大牛画的）。 Basic Connection底层互联，使用静态互联即可，但这需要底层的传输网络足够健壮、稳定。保证二层传输网络健壮性技术主要有VCS、ERPS等，这些都属于二层无环路保护协议，具体如何配置，在自行研究。现在就以二层已经配置好了保护协议为例，给出两台路由器的静态互联IP信息来协助配置BGP。 R1-CM-Access1234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# R2-BGP-Router1234!interface ve 925 ip address 10.0.254.1/30! 单向测试一下：BGP-Router1ping 10.0.254.1 source 10.254.0.2 BGP Config下面介绍BGP的相关配置，以与一个运营商接入的情况为例，其中CM-Access为华为设备，BGP-Router为博科设备。与运营商接入的设备配置比较简单，咱只用做好BGP连接就好了。R1-CM-Access12345678910111213&lt;R1&gt;system-view[R1]bgp 9527 //建立BGP进程，设置AS号为9527[R1-bgp]router-id x.x.x.x //设置router-id，一般为环回接口地址[R1-bgp]peer 10.0.254.1 as-number 35129 //设置BGP对等体[R1-bgp]peer 10.0.254.1 description BGP-Router //添加该对等体的描述信息[R1-bgp]peer 10.0.254.1 enable //建立和BGP对等体的TCP连接[R1-bgp-af-ipv4]import-route static //导入静态路由[R1-bgp-af-ipv4]quit[R1-bgp]quit[R1]ip route-static ..... //写入移动运营商路由[R1]ip route-static ...[R1]quit&lt;R1&gt;save //保存配置 BGP核心路由器R2的配置相比R1要多很多了，并且是在有意识的进行配置。R2-BGP-Router1234567891011121314151617181920212223242526272829R2#configure terminalR2(config)#router bgpR2(config-bgp)#local-as 35129 //设置本地AS号R2(config-bgp)#neighbor 10.0.254.2 remote-as 9527 //设置BGP对等体R2(config-bgp)#neighbor 10.0.254.2 soft-reconfiguration inbound //开启对等体流入路由软刷新R2(config-bgp)#neighbor 10.0.254.2 description CM-Access //添加该对等体的描述信息R2(config-bgp)#show ip bgp summary //检查BGP对等体之间的状态是否为EstablishedR2(config-bgp)#neighbor 10.0.254.2 shutdown //检查正常则先关闭TCP连接R2(config-bgp)#exitR2(config)#ip prefix-list Private_Deny seq 5 deny 0.0.0.0/8 le 32 //创建前缀列表R2(config)#ip prefix-list Private_Deny seq 10 deny 10.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 15 deny 172.16.0.0/12 le 32 R2(config)#ip prefix-list Private_Deny seq 20 deny 192.168.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 25 deny 127.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 30 deny 169.254.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 35 deny 192.0.2.0/24 le 32 R2(config)#ip prefix-list Private_Deny seq 40 deny 224.0.0.0/3 le 32 R2(config)#ip prefix-list Private_Deny seq 45 deny 172.160.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 50 permit 0.0.0.0/0 le 32R2(config)#router bgpR2(config-bgp)#neighbor 10.0.254.2 prefix-list Private_Deny in //拒绝私网地址等流入R2(config-bgp)#redistribute connected //重分布发直连路由R2(config-bgp)#redistribute static //重分布发静态路由R2(config-bgp)#default-information-origina //重分布发默认路由R2(config-bgp)#no neighbor 10.0.254.2 shutdown //打开BGP对等体之间的TCP连接R2(config-bgp)#show ip bgp routes //查看从BGP对等体获取到的路由信息R2(config-bgp)#exitR2(config)#exitR2#write-memory //保存配置 CM-Access和BGP-Router之间的EBGP建立好后，相互之间会自动学习路由，其他运营商对接的情况也可以这样来做。按照这样的思路做好之后，是否就完事了呢？这个得从需求上看，其实主要分两种情况： BGP-Router和ISP-Access包含单线、多线及BGP功能 BGP-Router和ISP-Access只用作BGP线路 一般而言，对于第二种情况，上述的做法已经完事了，但对于一家企业而言，设备的可利用性可能是越高越好的，这样对应的成本就越低（领导：节约成本啊，我可都是血汗钱，23333）。所以，如何去将单线、多线及BGP功能全部承载在这个架构中呢？答案是使用VRF，利用VRF来建立BGP线路的EBGP连接，这样对于BGP业务就可以在单个VRF内实现了，而其他的业务也在不同的VRF内实现即可。另外，而对于各个ISP-Access设备，CT-Access向EBGP内重分布默认路由，其他ISP-Access向EBGP重分布明细静态路由，CT-Access需要拒绝（使用ip-prefix list完成即可）从BGP-Router学习到的CM明细路由和CU明细路由等，否则就会影响单线及多线业务的默认出局。同时，为了保证单、多线业务，其他ISP-Access也都需要写入默认路由，但不能重分布到EBGP内，避免造成环路和路由错乱。 Summary按照这样的架构实现的Static BGP结构比较简单，不需要Traffic-Policy等之类的技术来配合实现，控制起来也比较简单，直接放静态路由就好，至于从BGP-Router到BGP-Access之间的稳定性，这个也可以用Static with BFD的方式来实现，或者纯依靠底层传输网的健壮性。不过有个问题在于，这样做好之后，BGP-Router就只能用作BGP地址的出口网关路由器了，当然根据设备的功能特性，强行要使用某某功能，依然可以用VRF等实现，但这样就会使得设备的功能变得繁杂，在操作的时，误操作或其他BUG就会影响到整个BGP网络架构的稳定性。另外，这个架构的优点其实很直观，就是简单，易于排障（网络架构在不失健壮性的基础下，越简单越好，真理啊😭），并且不同运营商的路由表易于维护。缺点就是，对底层传输网的稳定性要求比较高。但是，如果是跨区域的BGP业务的话，又会面临新的问题：难道每个地方都搞一台BGP核心路由器吗？那在内网里，这些地址又如何互相访问呢？]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFD基础配置方法]]></title>
    <url>%2F2019%2F03%2F29%2FBFD%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroBFD常用于多线静态路由的检测和自动切换，在没有使用其他动态协议的情况下，若网络出现故障，可以使用BFD达到故障线路和正常线路的路由切换效果。当然，BFD依然可以和其他协议配合使用（MPLS也可以），这里只介绍BFD和静态路由的配合使用，在不同的应用场景内把握好BFD本身的作用机制，从而达到使用者想要达到的效果即可。另外，一般的动态协议收敛速度比较慢，为秒级，BFD可以将收敛时间降低到毫秒级。 BFD Brief Description一般而言，BFD需要设置的参数不多，大致包含：source ip、destination ip、multiplier、min_rx、interval，各个参数只要设置好了，设备之间的BFD连接都配置OK，那么BFD连接就可以UP了。不同设备可能对这些名词的叫法不一致，但是差不多都是这些“词”。 Source IPBFD的源IP，本端设备设置本端IP即可。 Destination IPBFD的目的IP，本端设备设置对端IP即可。 Multiplier允许BFD连接报文失效的最大个数，例如设置为5，那么用于这个BFD连接的Control packet一旦失效超过5个，这条BFD路径连接就会down，类似ping测试丢包超过5个。 Min_rxBFD检测报文的接收周期。 intervalBFD检测报文的发送周期。 TipsBFD检测的时间周期设置，是一个很有意思的东西。假设总体性能的指标是要求链路检测上的时间不要超过150ms，这样可以设置BFD的hello报文周期为50ms，连续丢失3个报文即认为链路失效。如果换个思路，我们设置BFD的hello报文周期为30ms，连续丢失5个报文即认为链路失效，这样准确度会更高些且依然可以达到指标。但是需要路由器支持设置30ms这个时间。 BFD Connectiong下面开始配置。注：R1为博科设备，R2为华为设备 Basic Connection底层互联采用静态的方式，直接给出R1和R2互联的三层接口配置。R11234!interface ve 925 ip address 10.0.254.1/30! R21234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# BFD Config接下来开始配置BFD。R1123456R1#configure terminalR1(config)#interface ve 925R1(config-vif-ve-925)#bfd interval 500 min-rx 500 multiplier 5 //设置参数R1(config-vif-ve-925)#exitR1(config)#ip route static-bfd 10.0.254.2 10.0.254.1 //开启bfdR1(config)#ip route 192.168.1.0/24 10.0.254.2 bfd //为静态路由绑定bfd R21234567&lt;R2&gt;system-view[R2]bfd to-r1 bind peer-ip 10.0.254.1 interface vlanif925 source-ip 10.0.254.1 auto //设置bfd[R2-bfd-session-to-r1]detect-multiplier 5 //设置参数[R2-bfd-session-to-r1]min-tx-interval 500[R2-bfd-session-to-r1]min-rx-interval 500[R2-bfd-session-to-r1]quit[R2]ip route-static 192.168.2.0 24 10.0.254.1 track bfd-session to-r1 //为静态路由绑定bfd 配置好了之后，BFD就正式启动了，并且此时R1访问192.168.1.0/24网段的路由是与R1和R2之间的BFD绑定在一起的，R2访问192.168.2.0/24网段的路由也是与R1和R2之间的BFD绑定在一起的。 ManagementR1可以使用show bfd neighbors命令来检查BFD连接是否正常；R2可以使用display bfd session all来检查BFD连接是否正常；当然了，不同设备还有很多其他的简捷命令来方便管理。配合使用需要查设备的手册，但是需要设置的参数是一样的，这就很NICE了。所以，不管动态协议是啥，使用BFD实现的功能是与其他不相关的。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPLS基础配置方法]]></title>
    <url>%2F2019%2F03%2F27%2FMPLS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroMPLS，Multi-Protocol Label Switching，全称多协议标记交换，是一种标记机制的包交换技术，通过简单的2层交换来集成IP Routing的控制。MPLS究竟是不是路由协议，究竟工作在第几层，在这里，不做探讨，以下内容只介绍其基础的配置，并衔接ISIS基础配置这篇文章。 以下配置命还是以博科设备为例 Network Information贴出R1和R2的部分配置信息协助构建ISIS + MPLS。R1123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.10/30!interface ve 922 ip router isis ip address 10.0.254.14/30!!interface loopback 1 ip router isis ip address 169.254.254.1/32!ip router-id 169.254.254.1!router isis net 49.0001.0000.0000.1000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! R2123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.9/30!interface ve 922 ip router isis ip address 10.0.254.13/30!!interface loopback 1 ip router isis ip address 169.254.254.2/32!ip router-id 169.254.254.2!router isis net 49.0002.0000.0000.2000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! MPLS Brief Description简要说明一下MPLS中的某些组成部分，其余的部分不在赘述了😴。 Network Components就像BGP对等体一样，MPLS内也包含一些概念，依次如下： P网络：提供商网络P路由器：部署MPLS/IP网络环境的路由器PE路由器：提供商网络的边界路由器，提供VPN终端客户连接和服务CE路由器：客户的路由器，用做客户网络和提供商网络之间的网关C网络：客户的网络 MPLS-Interface用于建立path的三层接口，注意，是三层接口。 LSPLSP, Label Switched Path，标签交换路径，即到达同一目的地址的报文在MPLS网络中经过的路径。这玩意，就是流量的“方向”了。 LDPLDP, Label Distribution Protocol，标签分发协议，这玩意是路由器在构建MPLS标签转发表时遵守的规则，MPLS的标签转发表的建立就是靠这玩意。 VPLSVPLS，Virtual Private Lan Service，这玩意其实并只是MPLS所有的东西，按照不同的信令协议，也有不同的应用方法（BGP-l2vpn），这里所介绍的VPLS本质上是基于IP/MPLS的L2VPN技术（其实是现在用的最多的也就是MPLS下的VPLS了😂）。不过，这玩意还有个更加通俗的理解方式，那就是运营商给客户的“业务网”。 MPLS Config想要MPLS能正常使用，需要做的路由器配置其实并不是很多，大体上就包括：mpls-interface、path和lsp这些。以下的配置步骤可作为参考：R11234567891011121314151617181920212223242526272829R1#configure terminalR1(config)#router mpls //启用mplsR1(config-mpls)#ldp //进入ldp协议R1(config-mpls-ldp)#load-sharing 8 //设置lsp的能支持的最大路径条数为8R1(config-mpls-ldp)#exitR1(config-mpls)#path To-R2-1 //创建pathR1(config-mpls-path-To-R2-1)#strict 10.0.254.9 //指定这条路径的下一个节点是10.0.254.9R1(config-mpls-path-To-R2-1)#exitR1(config-mpls)#path To-R2-2R1(config-mpls-path-To-R2-2)#strict 10.0.254.13R1(config-mpls-path-To-R2-2)#exitR1(config-mpls)#mpls-interface ve921 //将ve 921这个三层接口启用到mpls中R1(config-mpls-if-ve-921)#ldp-enable //开启此接口ldp功能R1(config-mpls-if-ve-921)#exitR1(config-mpls)#mpls-interface ve922R1(config-mpls-if-ve-922)#ldp-enableR1(config-mpls-if-ve-922)#exitR1(config-mpls)#lsp To-R2-1 //创建标签转发路径R1(config-mpls-lsp-To-R2-1)#to 169.254.254.2 //设置标签转发路径的出口路由器地址R1(config-mpls-lsp-To-R2-1)#primary-path To-R2-1 //设置主路径R1(config-mpls-lsp-To-R2-1)#secondary-path To-R2-2R1(config-mpls-lsp-To-R2-1)#enableR1(config-mpls-lsp-To-R2-1)#lsp To-R2-2R1(config-mpls-lsp-To-R2-2)#to 169.254.254.2R1(config-mpls-lsp-To-R2-2)#primary-path To-R2-2R1(config-mpls-lsp-To-R2-2)#secondary-path To-R2-1R1(config-mpls-lsp-To-R2-2)#enableR1(config-mpls-lsp-To-R2-2)#exitR1(config-mpls)#write memory R21234567891011121314151617181920R2#configure terminalR2(config)#router mplsR2(config-mpls)#path To-R1-1R2(config-mpls-path-To-R1-1)#strict 10.0.254.10R2(config-mpls-path-To-R1-1)#path To-R1-2R2(config-mpls-path-To-R1-2)#strict 10.0.254.14R2(config-mpls-path-To-R1-2)#exitR2(config-mpls)#lsp To-R1-1R2(config-mpls-lsp-To-R1-1)#to 169.254.254.1R2(config-mpls-lsp-To-R1-1)#primary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#enableR2(config-mpls-lsp-To-R1-1)#lsp To-R1-2R2(config-mpls-lsp-To-R1-2)#to 169.254.254.1R2(config-mpls-lsp-To-R1-2)#primary-path To-R1-2R2(config-mpls-lsp-To-R1-2)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-2)#enableR2(config-mpls-lsp-To-R1-2)#exitR2(config-mpls)#exitR2(config)#write memory 上面贴出的是完整的配置过程，但是实际上两台设备的配置顺序是人为自定的，不过需要说明的是，一旦创建了path，使用show mpls routes命令时，就可以看到mpls的标签转发表了。其次，创建lsp时可以不指定primary-path和secondary-path，此时lsp会默认使用mpls内存在且up的path（已连接的路径），并且lsp一旦创建后设备会自动生成一个tunnel用于传输数据，这个可以不用管；之所以创建primary-path和secondary-path，实质上是为了手动调度流量比较方便。另外，在修改lsp时，必须要先disable这条lsp（先关闭这条路径）才可以进行修改（博科的设备是这样）。还有，使用router-id来作为出口PE路由器的地址，十分方便。当然了，不同厂商设所支持的MPLS扩展功能可能不一样的（厂商特色，23333），但是基本上都是一样的。 VPLSMPLS网络构建好了之后，创建VPLS就很简单啦。可以按照下面的脚本进行执行。R112345678910R1#configure terminalR1(config)#router mpls //进入mpls协议R1(config)#vpls Test911 911 //创建vplsR1(config-mpls-vpls-Test911)#vpls-peer 169.254.254.2 load-balance //添加vpls peerR1(config-mpls-vpls-Test911)#vlan 911 //创建vpls vlanR1(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/x //透传到汇聚端口R1(config-mpls-vpls-Test911-vlan-911)#exitR1(config-mpls-vpls-Test911)#exitR1(config-mpls)#exitR1(config)#write memory //保存配置 R212345678910R2#configure terminalR2(config)#router mplsR2(config)#vpls Test911 911R2(config-mpls-vpls-Test911)#vpls-peer 169.254.254.1R2(config-mpls-vpls-Test911)#vlan 911R2(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/xR2(config-mpls-vpls-Test911-vlan-911)#exitR2(config-mpls-vpls-Test911)#exitR2(config-mpls)#exitR2(config)#write memory 创建好了之后，可以使用show mpls vpls来查看vpls peer是否up，如果up，则创建成功，反之，则不成功，需要检查配置。 Summary总的来说，MPLS和VPLS的创建还是十分简单的，难点在于，骨干网节点过多的网络环境中，实现MPLS的流量调度工程，做这个事情一定要思路清晰才行。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISIS基础配置方法]]></title>
    <url>%2F2019%2F03%2F27%2FISIS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroISIS也是IGP路由协议族中一员，与OSPF十分类似，OSPF主要用于园区网，ISIS主要用于骨干网。注：本文内所有命令，均已博科设备(与Cisco类似)为例。 ISIS Brief Description简短说明一下，ISIS中的一些需要注意的地方，可能不清晰和完全，欢迎一起交流。 ISIS NET提示：这部分内容不要深究🤣，不知道为啥会这么冗杂，可能是因为ISIS是为OSI设计的，而OSI用的是NSAP格式的地址吧，XD，建议点开链接结合图片一起看。 ISIS的NET(网络实体名)采用的格式一种叫做NSAP的“格式”(Network Service Access Point)，其形式有点像IP地址加端口号的形式，如:169.254.254.1:80，以NET为49.0001.0000.0000.0001.00为例，49.0001是Area ID，长度可变；0000.0000.0001是System ID，长度不变；00是N-SEL，长度不变，这个类似于TCP/IP中的端口。 如果换一种标识的方法，那么49就是IDP，用AFI和IDI来标识；0001就是Area，System ID和N-SEL不变，此时，Area、System ID和N-SEL合称为DSP。 注：对于同一台路由器而言，在有多个ISIS Area连接的情况下，Area ID不同，但是System ID必须相同对于不同路由器而言，System ID一定不能相同不同路由器的domain要相同，这样ISIS才可以互联常用的NET设置为：49.0001.0000.0000.1000.00，这个算是最短且符合要求的长度了 ISIS RoutingISIS的路由获取方式与OSPF是十分类似的，包含IP地址的发布、静态路由的导入、路由的重分配等等，但ISIS的路由是拥有Level（路由等级）这个属性的，一般而言，工业上使用的设备都是是支持Level 1/2（路由等级为1或2）的路由，但这个实际上是可以设置的（设备可以设置对特定等级路由不加表）。另外，骨干网上使用的ISIS其实只参与了不同机房的核心路由器之间的互联，并没有通过ISIS跨机房传递本地的IP路由信息，而这部分功能是通过MPLS来完成的，当然MPLS的构建也可以和其他的动态路由协议配合完成。不同等级的路由特性如下：Level 1Level 2只能允许在一个area内路由允许在一个domain内路由，只含Level 1的路由器若要到达另外一个area，需要转发到离它“最近”的含Level 2路由的路由器。下面介绍的内容是利用ISIS来构建骨干网的实践场景。 Basic Connetion与OSPF的配置类似，ISIS的配置依然需要先在两台设备上配置好静态互联IP。本次实验采用vlan 921和vlan 922来作为两台设备的互联vlan，使用10.0.254.8/30和10.0.254.12/30作为两对互联IP(两条线路)。配置好后的部分配置如下：R21234567!interface ve 921 ip address 10.0.254.9/30!interface ve 922 ip address 10.0.254.13/30! R11234567!interface ve 921 ip address 10.0.254.10/30!interface ve 922 ip address 10.0.254.14/30! 设备之间的vlan透传，自己去传吧，注意别成环了就行。配置好了之后，测试一下。R2#12ping 10.0.254.10 source 10.0.254.9ping 10.0.254.13 source 10.0.254.14 R1#12ping 10.0.254.9 source 10.0.254.10ping 10.0.254.13 source 10.0.254.14 ISIS Config下面介绍ISIS相关的配置，不同厂商的命令和开启方式可能不一样，但大部分功能是一致的。按照以下的脚本来配置即可：R112345678910111213141516R1#configure terminalR1(config)#router isis //进入isis协议，进入后，会提示先设置netR1(config-isis-router)#net 49.0001.0000.0000.1000.00 //设置netR1(config-isis-router-ipv4u)#address-family ipv4 unicast //开启isis的ipv4单播功能R1(config-isis-router-ipv4u)#maximum-paths 8 //设置最大路径，不同设备不一致R1(config-isis-router-ipv4u)#exit //退出R1(config)#ip router-id 169.254.254.1 //设置router-idR1(config)#interface loopback 1 //进入环回接口R1(config-lbif-1)#ip address 169.254.254.1/32 //设置环回接口IP为router-idR1(config-lbif-1)#ip router isis //开启isis功能R1(config-lbif-1)#interface ve 921 //进入三层虚拟接口R1(config-vif-921)#ip router isisR1(config-vif-921)#interface ve 922R1(config-vif-922)#ip router isisR1(config-vif-922)#exitR1(config)#write memory R2路由器的配置过程与R1是相似的，但是需要注意的是，R2的net将设置为49.0002.0000.0000.2000.00，router-id将设置为169.254.254.2，对应的环回地址接口的IP设置为169.254.254.2/32。设置好后执行命令show isis routes来检查ISIS是否正常学习路由。R1/R212R1#show isis routesR2#show isis routes 按照之前的配置思路，此时可以在R2中看到以下路由信息：R112345678910111213Total number of IS-IS routes: 3Destination Mask Cost Type Tag Flags10.0.254.8 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 10.0.254.12 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 169.254.254.1 255.255.255.255 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 对应的R1也会有类似的路由信息，这里不在赘述了。 Summary到这里，R1和R2之间的ISIS互联就建立好了，也就是说骨干网现在已经建立好了，现在就可以在ISIS之上在来构建其他的网络配置了。整个过程，与OSPF的基础构建过程很类似，大部分动态路由协议都支持用密钥的方式来允许建立连接，ISIS也不例外的，但需要设备支持且通信双方都已知密钥，当然，BFD依然可以用在ISIS中（合理结合使用会使得ISIS的路由收敛速度更快），但这需要设备支持，并且要查阅设备手册，找到其具体配置方法。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brocade VDX VCS配置方法]]></title>
    <url>%2F2019%2F03%2F19%2FBrocade-VDX-VCS%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroductionVCS全称叫做VCS矩阵部署模式，是将多台VDX系列任意型号的物理交换机设备通过万兆或者40G任意拓扑互联形成一个矩阵，进行统一配置、管理、监控(套话)。注意： 只能用10G或者40G链路实现，也就是说只能用物理接口（port-channgel可以试试）去实现，但是好在可以使用多条10G链路，且流量是负载均衡的。 所有物理交换机的软件(就是系统版本)必须一致 需手动设定VCS集群的IP号码，集群唯一的编号，从1-8192 需手动设定VCS集群内部物理交换机rbridge-id编号，，该编号唯一，从1-239 部署完VCS配置后会清空物理交换机内部已有的配置 Configuration下面介绍大致配置。 Physical Interface物理接口的配置基本都是一致的，所以以一个端口为例即可。1234567#interface TenGigabitEthernet 1/0/1 des xxxx //描述信息 fabric isl enable //设置称为VCS的fabric isl port fabric trunk enable //设置端口的模式为trunk no shutdown //开启端口# 若不想设置此接口为VCS矩阵互联的ISL接口，需要配置以下命令在接口上：12fabric neighbor-discovery disableno fabric isl enable 检查互联端口正常之后，即可以开始下一步操作。 Set VCS Cluster Number利用console口进入到每台VDX后，执行命令：vcs vcsid X rbridge-id Y logical-chassis enableX代表VCS集群ID编号，是整个集群内部唯一的编号；Y代表VCS集群内部每一台VDX交换机的编号，也就是rbridge-id，用于标识集群内部每一台VDX交换机，同时也是作为接口编号的第一位，比如TenGigabitEthernet 1/0/1中的1就是rbridge-id 1，后面的1就是第一个端口。 注意，一旦执行这条命令，待VDX自动重启后，所有在VCS集群内的VDX就在逻辑上成为一台了；理论上而言，我们只需要操作一台就可以完成对所有设备的配置了，此时，VCS的模式是Logical Chassis。VDX的VCS模式是Fabric Cluster，所以我们只需设置vcs vcsid X rbridge-id Y就好。 若选择使用Logical Chassis模式，默认情况下是，机器重启后，先启动完成的机器为管理员，若想指定某台机器，则执行命令：logical-chassis principal-priority 1其中，1是rbridge-id。VCS集群内部的principal切换命令：logical-chassis principal switchover Management And SummaryVCS矩阵集群常用的检查命令：1234567show vcs detailshow fabric allshow fabric islshow fabric islports rbridge-id 1/2/3...show fabric trunkreload rbridge-id 1/2/3... #重启rbridge-id为1/2/3...的某个交换机vcs replace rbridge-id x #需要更换和替换rbridge-id时，可以先替换掉，需要系统支持 默认情况下，在VCS创建之后，用户管理员操作任何配置都不需要执行保存的动作，因为系统会自动保存。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F03%2F14%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[IntroPTA基础编程题目集好歹算是写完了，买了紫书，多多少少算是休息了三四天吧，现在也该重新开始新的旅程(受虐😤)了。PTA基础编程题目集因为按照PTA网站的格式，在Blog中给出了题目的内容、输入输出样例、要求等信息，嗯，写的十分详细(水文)，洋洋洒洒的好几万字呢(凑字数)，哈哈。说到底是自己整理的累，别人看的也累。所以，在本篇Blog中就不在给出其他信息了，只给出代码和分析吧。题目信息，请点击：PAT (Basic Level) Practice。不过，想来各位看官应该也只有在看到题目摸头、挠头的时候，才会来看这里的内容吧，这也就更加没有显示题目信息的必要了。嗯，就按照这样的想法来做吧。 话说，在Basic Level内好像只有编程题哦。 Classification这部分内容是自己做完题目之后，回过头再来看这些题目时做的，所以也算是总结性的内容，建议刷题的时候，一次性将一个类型的题目全部做完。 模拟 题号 名称 分值 备注 1001 害死人不偿命的(3n+1)猜想 15 - 1008 数组元素循环右移问题 20 - 1011 A+B 和 C 15 - 1012 数字分类 20 - 1016 部分A+B 15 - 1018 锤子剪刀布 20 - 1019 数字黑洞 20 - 1026 程序运行时间 15 四舍五入 1031 查验身份证 15 - 1035 插入与归并 25 - 1045 快速排序 25 - 1046 划拳 15 - 1053 住房空置率 20 - 1055 集体照 25 - 1061 判断题 15 - 1066 图像过滤 15 - 1067 试密码 20 - 1068 万绿丛中一点红 20 - 1069 微博转发抽奖 20 - 1071 小赌怡情 15 - 1077 互评成绩计算 20 四舍五入 1086 就不告诉你 15 - 1089 狼人杀-简单版 20 - 1091 N-自守数 15 - 1096 大美数 15 求因数 1097 矩阵行平移 20 - 1101 B是A的多少倍 15 - 1103 缘分数 20 - 1106 2019数列 15 - 字符串处理 题号 名称 分值 备注 1002 写出这个数 20 - 1006 换个格式输出整数 15 - 1009 说反话 20 - 1014 福尔摩斯的约会 20 - 1021 个位数统计 15 - 1024 科学计数法 20 - 1048 数字加密 20 - 1052 卖个萌 20 - 1054 求平均值 20 sscanf 1057 数零壹 20 2 进制转换 1058 选择题 20 1073 1073 多选题常见计分法 20 1058 1076 Wifi密码 15 - 1078 字符串压缩与解压 20 - 1081 检查密码 15 - 1084 外观数列 20 - 1093 字符串A+B 20 字符串的并集 1094 谷歌的招聘 20 素数判断 1109 擅长C 20 - 数学 题号 名称 分值 备注 1003 我要通过！ 20 找规律 1007 素数对猜想 20 素数 1010 一元多项式求导 25 求导 1013 数素数 20 素数 1017 A除以B 20 大数除法 1034 有理数四则运算 20 分数运算 1040 有几个PAT 25 找规律 1049 数列的片段和 20 注意误差 1051 复数乘法 15 注意误差 1056 组合数的和 15 模拟也可以 1060 爱丁顿数 25 - 1062 最简分数 20 分数运算 1063 计算谱半径 20 复数求模 1079 延迟的回文数 20 大数加法、回文数判断 1082 射击比赛 20 点的距离公式、查找最值 1088 三人行 20 多元方程求可能解 1099 性感素数 20 素数 1104 天长地久 20 素数、最大公约数、排序 查找 题号 名称 分值 备注 1004 成绩排名 20 - 1028 人口普查 20 string 1030 完美数列 25 binary search or two pointer 1032 挖掘机技术哪家强 20 - 1041 考试座位号 20 - 1059 C语言竞赛 20 - 1065 单身狗 25 set &amp; map 1072 开学寄语 20 - 1090 危险品装箱 set - 1092 最好吃的月饼 20 find max 1100 校庆 25 find &amp; sort 1102 教超冠军卷 20 find max 1107 老鼠爱大米 20 find max 散列 题号 名称 分值 备注 1005 继续(3n+1)猜想 25 - 1029 旧键盘 20 string 1033 旧键盘打字 20 string 1038 统计同成绩学生 20 - 1039 到底买不买 20 - 1042 字符统计 20 - 1043 输出PATest 20 - 1047 编程团体赛 20 查找最大值 1064 朋友数 20 - 1083 是否存在相等的差 20 - 1087 有多少不同的值 20 数学 1108 String复读机 20 - 排序 题号 名称 分值 备注 1015 德才论 25 - 1080 MOOC期终成绩 25 注意计算 1085 PAT单位排行 25 - 1095 解码PAT准考证 25 - 贪心 题号 名称 分值 备注 1020 月饼 25 - 1023 组个最小数 20 - 1070 结绳 25 排名的处理 1098 岩洞施工 20 - 进制转换 题号 名称 分值 备注 1022 D进制的A+B 20 - 1037 在霍格沃茨找零钱 20 - 1044 火星数字 20 map 1074 宇宙无敌加法器 20 字符串处理 链表 题号 名称 分值 备注 1025 反转链表 25 - 1075 链表元素分类 25 - 1105 链表合并 25 - 1110 区块反转 25 - 图形输出 题号 名称 分值 备注 1027 打印沙漏 20 - 1036 跟奥巴马一起编程 15 - 1050 螺旋矩阵 25 - 1001 害死人不偿命的(3n+1)猜想Analysis题目比较简单，按照题目给出的算法去构造计算过程即可，count++其实只在最后写一句就可以了。 Code12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, count = 0; cin &gt;&gt; n; while(n != 1) &#123; if(n % 2 == 1) n = 3 * n + 1; n /= 2; count++; &#125; cout &lt;&lt; count; return 0;&#125; 1002 写出这个数Analysis这个题目20分呢，不过不难，嘻嘻，就是比较麻烦，看着题目中的话：这里保证$n$小于$10^{100}$，好像看到了出题人“善意”的微笑一样呢(wo zhen xiang da si ni~)。大致思路，先要算出每个数位上数字的总和，然后再将结果进行数位拆分输出一位一位的数字就好了。对于输入的数字串，可以用单字符的形式来处理，也可以从字符串的角度去处理，另外注意做数位拆分时的个位数，注意0的拼音是ling不是lin。 继续分析一下题目条件，“保证$n$小于$10^{100}$这个条件好像还有点猫腻？小于$10^{100}$那能取到的最大的数不就是$10^{100} - 1$了？而且这个数的每一位都是 9，总共 99 位，也就是说，最后得到的各位数字之和肯定不会大于$9 \times 100 = 900$，最多也不会超过三位数了，这是个好消息！明确了这点后，数位拆分的过程就简单了；另外，需要输出的字符串，可以单独放在二维数组内，利用能到的数位代替下标，来输出就很方便了！ Codeversion 1按照上述的两种思路得到的 AC 分别代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; char c; int num, sum=0; while((c=getchar()) != '\n') &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; num = c - '0'; sum+=num; &#125; else continue; &#125; /* method 1: int digit, temp=sum, mask=1; while(temp &gt; 9) &#123; temp/=10; mask*=10; &#125; temp=sum; do &#123; digit = temp / mask; temp %= mask; mask /= 10; switch(digit) &#123; case 0:printf("ling");break; case 1:printf("yi");break; case 2:printf("er");break; case 3:printf("san");break; case 4:printf("si");break; case 5:printf("wu");break; case 6:printf("liu");break; case 7:printf("qi");break; case 8:printf("ba");break; case 9:printf("jiu");break; &#125; if(mask == 0) printf("\n"); else printf(" "); &#125; while(mask &gt; 0); */ /*method 2:*/ char num2chi[][6] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; int unit, tens, hundred; unit = sum % 10; tens = sum / 10 % 10; hundred = sum / 100; if(sum &gt; 100) printf("%s %s %s\n", num2chi[hundred], num2chi[tens], num2chi[unit]); else if (10 &lt; sum &amp;&amp; sum &lt; 100) printf("%s %s\n", num2chi[tens], num2chi[unit]); else printf("%s\n", num2chi[unit]); return 0;&#125; version 2这个题还可以借助 C++ 自带的一些工具函数。123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string num[10] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for(int i = 0; i &lt; s.length(); i++) &#123; sum += (s[i] - '0'); &#125; s = to_string(sum); for(int i = 0; i &lt; s.length(); i++) &#123; if(i != 0) cout &lt;&lt; ' '; cout &lt;&lt; num[s[i] - '0']; &#125; return 0;&#125; 1003 我要通过！Analysis这个题目是真的坑，光是理解题意就得花不少时间，第一眼看到条件 3 估计会把人给弄懵逼。但实际上，这个题目其实算是个找规律的题目，先理解一下这 3 个条件： 条件 1 很直接 xPATx这类字符串都是答案正确 aPbTc正确，那么aPbATca也是正确的。就样例而言，AAPATAA是正确的，原因是符合xPATx；而AAPAATAAAA正确是因为AAPATAA正确且也符合aPbATca，此时有a = AA, b = A, c = AA。同理，APAAATAA中a = A, b = AA, c = A，那么aPbTc就是APAATA，这个字符串是不符合xPATx的，所以错误。 理解题意之后，就可以进一步找规律了。首先，可以发现xPATx是所有正确答案的根源，因为它可以通过变换成为其他字符串。假设 x 是 P 左边的 A 的个数， y 是 P 和 T 中间 A 的个数，z 是 T 右边 A 的个数。那么，可以得到以下规律： P 和 T 的个数一定是 1，A 的个数不定，但其他字符个数一定是 0 y &gt;= 1 为了确保aPbTca经过变换后符合xPATx，b每次只能增加 1 个 A，也即，y 每次只能增加 1，c中 A 的个数则一定是 x 的倍数。同样地，不管如何变换，x 是不变的，每次 y 增加 1，就会让 z 增加 x（可以结合上面条件 3 中的例子分析）。按照这样的规律，可以利用循环判断当y = 1时，z 和 x 是否相等来确定答案是否正确。若以aPbATca为模板，可以得到z = x + x * (y - 1)这个一般性的式子，这样就可以省去循环。 发现这些规律后，这个题目基本上就清晰了。 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); while(n--) &#123; char str[105]; scanf("%s", str); int len = strlen(str); int num_p = 0, num_t = 0, other = 0; int pos_p = -1, pos_t = -1; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') &#123; num_p++; pos_p = i; &#125; else if(str[i] == 'T') &#123; num_t++; pos_t = i; &#125; else if(str[i] != 'A') other++; &#125; if(num_p != 1 || num_t != 1 || other != 0 || pos_t - pos_p &lt;= 1) &#123; printf("NO\n"); continue; &#125; int x = pos_p, y = pos_t - pos_p - 1, z = len - pos_t - 1; if(z - x * (y - 1) == x) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 1004 成绩排名Analysis这道题比较简单，算是查找吧，定义好结构体进行处理就好，注意最大、最小值得分开判断，而不是只用if-else就完事大吉。 Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef struct Stu &#123; char name[12]; char number[12]; int grade;&#125; students;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); int i=0; students stu, max, min; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); max = min = stu; for(i=1; i&lt;n; i++) &#123; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); /*online processing, find the minimum and maximum when inputing. */ if(stu.grade &lt; min.grade) min = stu; if(stu.grade &gt; max.grade) max = stu; &#125; printf("%s %s\n%s %s\n", max.name, max.number, min.name, min.number); return 0;&#125; 1005 继续(3n+1)猜想Analysis按照1001的思路，对输入的每个数进行模拟，开辟一个bool数组来记录某个数字是否出现，出现则将下标为其值的bool量置为true，由于每个数在模拟中可能会出现不同的数字，最好还是每个数字都模拟一下。另外，由于最后需要从小到大输出，所以将输入数字序列按从大到小排序后，在进行输出。特别要注意，数组的大小一定要开到 10000，可能出现的最大数是会超过 1000 的，不然测试点 4 会出现溢出的错误。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;int main(int argc, char const *argv[]) &#123; int K, Num[105] = &#123;0&#125;, temp; bool times[MAXN] = &#123;false&#125;; scanf("%d", &amp;K); for(int i = 0; i &lt; K; i++) &#123; scanf("%d", &amp;Num[i]); temp = Num[i]; while(temp != 1) &#123; if(temp % 2 == 1) &#123; temp = 3 * temp + 1; &#125; temp /= 2; times[temp] = true; &#125; &#125; sort(Num, Num + K); bool flag = true; for(int i = K - 1; i &gt;= 0; i--) &#123; if(!times[Num[i]]) &#123; if(flag) &#123; printf("%d", Num[i]); flag = false; &#125; else &#123; printf(" %d", Num[i]); &#125; &#125; &#125; return 0;&#125; 1006 换个格式输出整数Analysis水题一道，题目已经说了给一个不超过3位的正整数 n &lt; 1000，做好数位拆分后，挨个输出即可。 Code1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, num, unit, tens, hundred; scanf("%d", &amp;num); unit = num % 10; tens = num / 10 % 10; hundred = num / 100; for(i=0; i&lt;hundred; i++) &#123; printf("B"); &#125; for(i=0; i&lt;tens; i++) &#123; printf("S"); &#125; for(i=1; i&lt;=unit; i++) &#123; printf("%d", i); &#125; printf("\n"); return 0;&#125; 1007 素数对猜想Analysis这道题要稍微理解一下题目意思，乍一看，可能会没明白题目的意思。关键的条件：存在无穷多对相邻且差为2的素数，也即是说，对于题目给定的$N = 20$而言，在$2 - 20$之间，必然存在相邻且差为2的素数对！而题目的问题是：计算不超过$N$的满足猜想的素数对的个数，那么直接进行计算就好了。至于如何判断素数，这就是老生常谈的问题了，方法很多。 这个题目没有超时的测试点，不用想的太复杂。 Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef enum&#123; false, true&#125; bool;bool IsPrime(int n);int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d", &amp;N); for(i = 2; i &lt;= N - 2; i++) &#123; if(IsPrime(i) &amp;&amp; IsPrime(i + 2)) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;bool IsPrime(int n) &#123; bool flag = true; if(n &lt;= 1 || n % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(n); i+=2) &#123; if(n % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 1008 数组元素循环右移问题Analysis本题的解答方法较多，首先需要对移动次数$M$进行处理，分别对应两种情况，$M &gt;= N$和$M &lt; N$，使用取余运算即可。下面介绍一下各种方法： 不移动，先输出指定位置，再输出余下位置即可 利用队列，移动的过程正好对应队列出一次队，再入一次队 采用移位算法reverse 函数，大致过程（以样例为例）： 12345n = 6, m = 2, move 3 turns-&gt; 1 2 3 4 5 6 - start-&gt; 6 5 4 3 2 1-&gt; 5 6 4 3 2 1-&gt; 5 6 1 2 3 4 - end 移位算法reverse 函数的大致代码：1234567void reverse(int *array, int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = array[i]; array[i] = array[start + end - i]; array[start + end - i] = temp; &#125;&#125; Codedirect output12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; for(int i = n - m; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; for(int i = 0; i &lt; n - m; i++) &#123; cout &lt;&lt; a[i]; if(i != n - m - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; use queue12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt; q; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; m %= n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q.push(temp); &#125; for(int i = 0; i &lt; n - m; i++) &#123; temp = q.front(); q.pop(); q.push(temp); &#125; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); if(q.size() != 0) cout &lt;&lt; ' '; &#125; return 0;&#125; reverse function1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn = 110;void Reverse(int a[], int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = a[i]; a[i] = a[end + start - i]; a[end + start - i] = temp; &#125;&#125;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; Reverse(a, 0, n - m - 1); Reverse(a, n - m, n - 1); Reverse(a, 0, n - 1); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 使用 C++ 就不用自己实现 reverse 函数了，这里先逆置前面的元素，再逆置后面的元素，最后整体逆置，具体如下：123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; reverse(a, a + n - m); reverse(a + n - m, a + n); reverse(a, a + n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 1009 说反话Analysis这个题如果单纯的处理字符串的话，会比较麻烦。不过若是使用二维数组（字符串数组）就很简单了，利用的是scanf无法读入带空格的字符串的特性。同理，使用 cin 也可以做到同样的事情，输出的时候实际上是栈的思想。 Codeversion 1123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int count = 0; char Str[85][85], c; while(1) &#123; scanf("%s", Str[++count]); c = getchar(); if(c == '\n') &#123; break; &#125; &#125; for(; count &gt; 1; count--) &#123; printf("%s ", Str[count]); &#125; puts(Str[count]); return 0;&#125; version 2原来没有从字符串的角度来做，现在再来从字符串处理的角度来做一下：123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string str, res; getline(cin, str); for(int i = str.length() - 1; i &gt;= 0; i--) &#123; int j = i - 1; for(; j &gt; 0; j--) &#123; if(str[j] == ' ') break; &#125; if(j &gt;= 0 &amp;&amp; str[j] == ' ') res += str.substr(j + 1, i - j) + ' '; else res += str.substr(0, i + 1); i = j; &#125; cout &lt;&lt; res; return 0;&#125; 要注意的点就是可能会存在字符串前面有多个空格的情况。 1010 一元多项式求导Analys题目大意较为明确，但感觉有些东西没说明白...注意的地方大致如下： 因为没说输入什么时候结束，所以只能手动使用 Windows 下的Ctrl + Z来结束输入，判题系统建在 Linux 上，应该自动使用的Ctrl + D，这两个操作都表示EOF，所以得使用!= EOF来作为输入结束的标志 常数项求导后为0，需要输出为0 0，这应该是题目最后一个条件的提示了 可能出现指数为负的项，输出顺序是指数递降的，这里用链表就很无脑，因为输入绝对是指数递降的，那么求导完后，也绝对是指数递降的，直接输出即可 这道题也可以用链表来做，求导的过程会复杂一些。 Codeuse linked list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node* List;typedef struct node&#123; int coef, expo; List next;&#125; Node;List CreateList(void);void Derivation(List L);void Print(List L);int main(int argc, char const *argv[]) &#123; List L = CreateList(); Derivation(L); Print(L); return 0;&#125; List CreateList(void) &#123; List L = (List)malloc(sizeof(Node)), rear; L-&gt;next = NULL; rear = L; int c, e; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; List temp_node = (List)malloc(sizeof(Node)); temp_node-&gt;next = NULL; rear-&gt;next = temp_node; rear = temp_node; temp_node-&gt;coef = c; temp_node-&gt;expo = e; &#125; return L;&#125;void Print(List L) &#123; List Temp = L-&gt;next; int flag = 1; while(Temp) &#123; if(flag) &#123; printf("%d %d", Temp-&gt;coef, Temp-&gt;expo); flag = 0; &#125; else &#123; if(Temp-&gt;coef != 0) &#123; printf(" %d %d", Temp-&gt;coef, Temp-&gt;expo); &#125; &#125; Temp = Temp-&gt;next; &#125; putchar('\n');&#125;void Derivation(List L) &#123; List p = L-&gt;next; while(p) &#123; if(p-&gt;expo) &#123; p-&gt;coef = p-&gt;coef * p-&gt;expo; p-&gt;expo--; &#125; else &#123; p-&gt;coef = 0; &#125; p = p-&gt;next; &#125;&#125; use array123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, items[1005] = &#123;0&#125;, c, e, count = 0; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; items[e] = c; &#125; items[0] = 0; for(i = 1; i &lt;= 1000; i++) &#123; items[i - 1] = items[i] * i; items[i] = 0; if(items[i - 1] != 0) &#123; count++; &#125; &#125; if(count == 0) printf("0 0\n"); else &#123; for(i = 1000; i &gt;= 0; i--) &#123; if(items[i]) &#123; printf("%d %d", items[i], i); count--; if(count != 0) &#123; putchar(' '); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125; 1011 A+B和CAnalysis由于题目限定了输入数据范围为$[-2^{31}, 2^{31}]$，本题可以有两种解法： 直接使用long long，避免使用int带来的溢出 依旧使用int，但是需要做溢出处理，包括正溢出和负溢出两种情况 Codeuse long long1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &gt; c) cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; &#125; return 0;&#125; use int1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; //positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; //negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; //normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1012 数字分类Analysis按照题目要求，依次求出所有数字，但在输出的时候要注意，$A_2$的结果可能是 0 ，此时$A_2$是存在的，要输出0，而不是N，类似的有$A_4$。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;int main() &#123; int n, temp, a[6] = &#123;0&#125;, sign = 1, count = 0, flag = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;temp); int remain = temp % 5; if(remain == 0 &amp;&amp; temp % 2 == 0) a[1] += temp; if(remain == 1) &#123; a[2] += sign * temp; sign = -sign; flag = 1; &#125; if(remain == 2) a[3]++; if(remain == 3) &#123; a[4] += temp; count++; &#125; if(remain == 4 &amp;&amp; temp &gt; a[5]) &#123; a[5] = temp; &#125; &#125; if(a[1]) printf("%d ", a[1]); else printf("N "); if(flag) printf("%d ", a[2]); else printf("N "); if(a[3]) printf("%d ", a[3]); else printf("N "); if(a[4]) printf("%.1lf ", (double)a[4] / count); else printf("N "); if(a[5]) printf("%d", a[5]); else printf("N"); return 0;&#125; 1013 数素数Analysis素数相关的题目好像已经是老生常谈的题型了，注意不要超时。关于素数的求法，可以看这里：素数的求法 Code非筛法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX 15000bool IsPrime(int number);int main(int argc, char const *argv[]) &#123; int M, N, Prime[MAX]; scanf("%d %d", &amp;M, &amp;N); int i, count = 2; Prime[1] = 2; for(i = 3; i &lt;= 105000; i++) &#123; if( IsPrime(i) ) &#123; Prime[count++] = i; &#125; &#125; count = 0; for(; M &lt; N; M++) &#123; printf("%d", Prime[M]); count++; if(count % 10 == 0) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; printf("%d\n", Prime[M]); return 0;&#125; bool IsPrime(int number) &#123; bool flag = true; if(number &lt;= 1 || number % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(number); i+=2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 筛法1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 1000001;int prime[MAXN], pNum = 0;bool p[MAXN] = &#123;false&#125;;void filterPrime(int n) &#123; for(int i = 2; i &lt; MAXN; i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; if(pNum &gt;= n) break; for(int j = i + i; j &lt; MAXN; j += i) &#123; p[j] = true; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int m, n, count = 0; scanf("%d %d", &amp;m, &amp;n); filterPrime(n); for(int i = m; i &lt;= n; i++) &#123; printf("%d", prime[i - 1]); count++; if(count % 10 != 0 &amp;&amp; i &lt; n) putchar(' '); else putchar('\n'); &#125; return 0;&#125; 1014 福尔摩斯的约会Analysis这个题目的细节处理，真是...太太太麻烦啦~大致分析一下： 字符相同的时候才能判断是否输出 星期判断必须是大写字母，且必须属于 $[A, G]$ 这个范围内（测试点4），用取余不是更好么？ 时间单位需要用0来补全2位 特别要注意的就这些，其他的再仔细读读题目就OK了~ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char Week[7][5] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1015 德才论Analysis这道题一开始做的时候还想了挺久的，而且还没想出来，下面来分析一下。 使用库函数sort来完成排序的基本操作就不说了，大概得注意两个点： 总分需要计算出来作为排序的依据，这个是题目明确说明的 题目给的考生种类很多，为了排序方便可以给这些考生分类，数字越大等级越低（或反之） 能注意到这两个点，题目基本就可以完成了。所以，以后在遇到类似的题目，就提前分好类吧。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; int id, scoreD, scoreC, sumCD, flag;&#125; stu[MAXN];bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumCD != b.sumCD) return a.sumCD &gt; b.sumCD; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return a.id &lt; b.id;&#125;int N, L, H, M = 0;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d", &amp;stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumCD = stu[i].scoreC + stu[i].scoreD; if(stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreC &gt;= L) &#123; M++; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &lt; H) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else stu[i].flag = 4; &#125; else &#123; stu[i].flag = 5; &#125; &#125; sort(stu, stu + N, cmp); printf("%d\n", M); for(int i = 0; i &lt; M; i++) &#123; printf("%d %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125; 1016 部分A+BAnalysis根据题目的要求进行计算即可，从字符串或者数字的角度都可以得到解决方法。 Codeuse string123456789101112131415161718#include &lt;iostream&gt;using namespace std;int getnum(char *str, char D) &#123; int ret = 0; char *p = str; for(; *p != '\0'; p++) &#123; //loop condition also can use str[i] != '\0' if(*p == D) &#123; ret = ret * 10 + (*p - '0'); &#125; &#125; return ret;&#125;int main() &#123; char A[12], B[12], a, b; scanf("%s %c %s %c", A, &amp;a, B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; use int12345678910111213141516#include &lt;iostream&gt;using namespace std;int getnum(int A, int a) &#123; int ret = 0; do&#123; if(A % 10 == a) ret = ret * 10 + a; A /= 10; &#125; while(A &gt; 0); return ret;&#125;int main() &#123; int A, B, a, b; scanf("%d %d %d %d", &amp;A, &amp;a, &amp;B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; 1017 A除以BAnalysis此题考察大整数运算，其中A为大整数，B为int类型的整数，计算这两个数的商和余数。此类型的题目，需要使用数组来保存大整数，并用数组来模拟题目要求做的运算。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign&#123; int d[1005], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign divide(bign a, int b, int &amp;r) &#123; bign c; c.len = a.len; for(int i = a.len - 1; i &gt;= 0; i--) &#123; r = r * 10 + a.d[i]; if(r &lt; b) c.d[i] = 0; else &#123; c.d[i] = r / b; r %= b; &#125; &#125; while(c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) &#123; c.len--; &#125; return c;&#125;int main(int argc, char const *argv[]) &#123; char str[1005]; int b, r = 0; cin &gt;&gt; str &gt;&gt; b; bign a = change(str), c; c = divide(a, b, r); for(int i = c.len - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; c.d[i]; &#125; cout &lt;&lt; ' ' &lt;&lt; r ;; return 0;&#125; 1018 锤子剪刀布Analysis题目大意就是剪刀石头布的游戏规则，对应 9 种情况，进行模拟即可，注意输出赢的次数最多且字典序最小的解。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;char gesture(int *a) &#123; int index = 1; char ges = '\0'; for(int i = 1; i &lt;= 3; i++) &#123; if(a[i] &gt; a[index]) index = i; &#125; switch(index) &#123; case 1: ges = 'B'; break; case 2: ges = 'C'; break; case 3: ges = 'J'; break; &#125; return ges;&#125;int main() &#123; int n, tie = 0, win = 0, ar[4] = &#123;0&#125;, br[4] = &#123;0&#125;; cin &gt;&gt; n; char a, b; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if(a == b) tie++; else if(a == 'C' &amp;&amp; b == 'J') &#123; win++; ar[2]++; &#125; else if(a == 'J' &amp;&amp; b == 'B') &#123; win++; ar[3]++; &#125; else if(a == 'B' &amp;&amp; b == 'C') &#123; win++; ar[1]++; &#125; else if(b == 'C' &amp;&amp; a == 'J') &#123; br[2]++; &#125; else if(b == 'J' &amp;&amp; a == 'B') &#123; br[3]++; &#125; else if(b == 'B' &amp;&amp; a == 'C') &#123; br[1]++; &#125; &#125; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; n - tie - win &lt;&lt; endl; cout &lt;&lt; n - tie - win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; cout &lt;&lt; gesture(ar) &lt;&lt; ' ' &lt;&lt; gesture(br); return 0;&#125; 1019 数字黑洞Analysis题目大意是给定一个四位数字，拆分出其各位数后，能得到一个最大值和最小值，二者相减后，会得到一个新数字。重复这个过程，最后差会一直等于6174。所以，当差为6174时，就停止循环。 按照下面的代码思路，每次必须要将保存各位数字的数组初始化为0，否则会有错误（因为数组有四个元素参与了运算）。另外，需要输出前导 0。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1020 月饼Analysis这是道考察贪心算法的题目，题目要求输出的最大收益，实际上就是对应单价最高的月饼卖出后的总收益。若单价最高的月饼的贮存量不满足市场需求，按照剩余的市场需求量继续卖单价第二高的月饼。所以，需要计算出每种月饼的单价，再对其进行排序，接着按照题目要求计算总收益，最后在输出。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125;int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; D -= cake[i].store; ans += cake[i].sell; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125; 1021 个位数统计Analysis以字符串的形式读入题目给定的数字，再利用散列的思想，统计各个数字出现的次数，继而输出。 Code123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 1005int main(int argc, char const *argv[]) &#123; char num[MAXN]; int i, digit[10]=&#123;0&#125;; scanf("%s", num); char *p; p = num; while(*p) &#123; digit[*p - '0']++; p++; &#125; for(i=0; i&lt;10; i++) &#123; if(digit[i] != 0) printf("%d:%d\n", i, digit[i]); &#125; return 0;&#125; 1022 D进制的A+BAnalysis进制转换的常规题型，利用取余运算获取到转换进制的每一位，然后从高位往地位输出即可，注意输入0 0 8时特判，输出为0。 Code1234567891011121314151617181920#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; long long A, B, D, digit[50] = &#123;0&#125;, count = 0; scanf("%lld %lld %lld", &amp;A, &amp;B, &amp;D); A += B; while(A) &#123; digit[count++] = A % D; A /= D; &#125; if(count) &#123; for(count--; count &gt;= 0; count--) &#123; printf("%d", digit[count]); &#125; &#125; else &#123; printf("0"); &#125; putchar('\n'); return 0;&#125; 1023 组个最小数Analysis输出第一个数字时，不能输出0，所以直接从数字1开始遍历，存在则输出，然后个数减1，并跳出循环；接着在输出剩下的数字，此时0是可以被直接输出的，所以从数字0开始遍历（也是从小到大的规律），将每一个数字全部输出完后，再开始输出下一个数字。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int count[10] = &#123;0&#125;; for(int i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;count[i]); &#125; //print the first number for(int i = 1; i &lt; 10; i++) &#123; if(count[i]) &#123; printf("%d", i); count[i]--; break; &#125; &#125; //print the rest of numbers for(int i = 0; i &lt; 10; i++) &#123; while(count[i]) &#123; printf("%d", i); count[i]--; &#125; &#125; return 0;&#125; 1024 科学计数法Analysis题目意思比较明确，科学记数法转换成正常的数字，要把指数提取出来，在指数为正、负或零时，分别对应不同的情况。 Codeversion 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int Getexpon(char *s, int Epos);int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int count = 0, expo, Epos = 0, len = strlen(Num); for(; Num[Epos] != 'E'; Epos++); if(Num[0] == '-') putchar(Num[0]); expo = Getexpon(Num, Epos); if(expo &gt; 0) &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; Epos - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; Num[Epos] = '\0'; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; Epos; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125;int Getexpon(char *s, int Epos) &#123; int ret = 0, flag = 1, i = Epos + 1; if(s[i] == '-') &#123; flag = -1; &#125; i++; for(; s[i] != '\0'; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; return ret * flag;&#125; version 2这个题如果利用了 scanf 的格式化串就会有奇效，使用%[^E]E%d可以直接将指数读出来，%[^E]与%s是类似的，但是会一直读取，直到读到E这个字符。如果要用 scanf 读取一行，那么就是%[^&#39;\n&#39;]了。scanf 还有很多其他的用法，参考链接：scanf 格式化字符串详解。回到这道题，这样上面的代码就可以简单一点了。12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int main(int argc, char const *argv[]) &#123; char Num[MAXN]; int count = 0, expo, len; scanf("%[^E]E%d", Num, &amp;expo); len = strlen(Num); if(Num[0] == '-') putchar(Num[0]); if(expo &gt; 0) &#123; for(int i = 1; i &lt; len; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; len - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (len - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; len; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125; 1025 反转链表Analysis题目大意：给定一个单链表，每 k 个结点进行逆置，若最后剩下小于 k 个结点，则不需逆置，输出逆置后的链表。 对待此类题目，还是使用静态链表的思路来处理。先默认结构数组内的结点全部为无效结点，再按照地址逐个输入每个结点。然后，利用第一个结点的地址遍历链表，将合法结点的order改为链表结点的顺序，再利用sort函数将合法结点全部排在结构数组的左端，非法结点则在右端。 接着，再开始逆置输出。对于具有 n 个合法结点的链表，按照 k 来逆置，则其必可被分为 n/k 个子块来分别逆置。由于是逆置，所以需要将每一个子块倒着输出。但这一块的最后一个需要输出的结点需要分开考虑，因为其next已经变成了下一个块的最后一个结点（这里说的是初始顺序）的地址了。针对每次输出的最后这个结点的位置有三种情况： 若当前输出的块不是最后一个整块，那么其next就是(i + 2) * K - 1结点（也就是下一个整块的最后一个结点）的地址 若当前输出的块是最后一个整块，且是最后一个整块的最后一个结点，那么其next即为-1 若当前输出的块是最后一个整块，但其后面还有小于K的结点个数，所以其next最后“尾巴”的第一个结点的地址，即(i + 1) * K号结点，然后再将剩余结点输出即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node &#123; int address, data, next; int order;&#125; Node[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; init(); int n, k, head, address; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n ; i++) &#123; cin &gt;&gt; address; cin &gt;&gt; Node[address].data &gt;&gt; Node[address].next; Node[address].address = address; &#125; int count = 0, p = head; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) printf("-1\n"); else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1026 程序运行时间Analysis给定的是整数，但是要求四舍五入，又知题目给定的除数是 100 ，给被除数加上 50 后，就可以模拟出四舍五入的效果。 Code123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int c1, c2, c; scanf("%d %d", &amp;c1, &amp;c2); c = (c2 - c1 + 50) / 100; printf("%02d:%02d:%02d", c / 3600, c / 60 % 60, c % 60); return 0;&#125; 1027 打印沙漏Analysis这种打印图像的题目，需要找找规律。 以样例为例，只看图像一半，从中心开始出发，就是$a_1 = 1, a_2 = 3, a_3 = 5$的等差数列，按照这种思路的话，需要打印的图像其实就是两个等差数列，只不过第二个等差数列没有首项，只有两项$a_1 = 3, a_2 = 5$，但这并不影响计算，当作两个相同的等差数列计算好后，减去多余的部分即可。 从而有：$2S_n - 1= 2 \times \frac{3 \times (1 + 5)}2 = 17$，这就是需要打印出来的符号数量，而此时的层数为3（其实也是等差数列的项数）。 下面再来进行输出，注意每行要先输出空格，在输出字符，最后一行输出未使用的字符数。使用绝对值，能简化一半的代码量，看着很清爽~ Code123456789101112131415161718192021#include &lt;cstdio&gt;#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))int main(int argc, char const *argv[]) &#123; int N, layers; char c; scanf("%d %c", &amp;N, &amp;c); for(layers = 1; 2 * layers * layers - 1 &lt;= N; layers++); layers--; for(int i = 0; i &lt; 2 * layers - 1; i++) &#123; for(int j = 0; j &lt; layers - ABS(layers - i - 1) - 1; j++) &#123; putchar(' '); &#125; for(int k = 0; k &lt; 2 * ABS(layers - i - 1) + 1; k++) &#123; putchar(c); &#125; putchar('\n'); &#125; printf("%d\n", N - 2 * layers * layers + 1); return 0;&#125; 1028 人口普查Analysis这道题如果在处理日期上面没有经验的话，就很难受...一开始在判断日期合法性的时候，想到了全部转化为天数，光是转换天数，还有平闰年的区分，感觉又是一道题了🤔，这应该不是姥姥想让答题者干的活。事实证明，确实想歪了😂，对于这类日期的判断，从年这个数字开始逐个进行比较即可（参考下面的代码），同时注意不要用if-else来得到最年长和年轻的人就好，要分开判断。 Codeuse sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;struct citizen&#123; int year, month, day; char name[7];&#125; youngest, oldest, left, right, temp;void Init();bool Less(citizen a, citizen b);bool More(citizen a, citizen b);int main(int argc, char const *argv[]) &#123; Init(); int N, valid = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d/%d/%d", temp.name, &amp;temp.year, &amp;temp.month, &amp;temp.day); if(Less(temp, right) &amp;&amp; More(temp, left)) &#123; valid++; if(More(temp, youngest)) &#123; youngest = temp; &#125; if(Less(temp, oldest)) &#123; oldest = temp; &#125; &#125; &#125; if(valid) &#123; printf("%d %s %s\n", valid, oldest.name, youngest.name); &#125; else &#123; printf("0\n"); &#125; return 0;&#125;void Init() &#123; left.year = youngest.year = 1814; right.year = oldest.year = 2014; youngest.month = oldest.month = left.month = right.month = 9; youngest.day = oldest.day = left.day = right.day = 6;&#125;bool Less(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &lt;= b.year; else if(a.month != b.month) return a.month &lt;= b.month; else return a.day &lt;= b.day;&#125;bool More(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &gt;= b.year; else if(a.month != b.month) return a.month &gt;= b.month; else return a.day &gt;= b.day;&#125; use string这个题，一旦用 string 容器来处理，就非常简单。123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; string name, birth, maxname, minname, maxbirth = "1814/09/06", minbirth = "2014/09/06"; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; birth; if("1814/09/06" &lt;= birth &amp;&amp; birth &lt;= "2014/09/06") &#123; cnt++; if(maxbirth &lt;= birth) &#123; maxbirth = birth; maxname = name; &#125; if(minbirth &gt;= birth) &#123; minbirth = birth; minname = name; &#125; &#125; &#125; cout &lt;&lt; cnt; if(cnt) cout &lt;&lt; ' ' &lt;&lt; minname &lt;&lt; ' ' &lt;&lt; maxname; return 0;&#125; 实际上，用 strcmp 函数也能完成这样的功能。 1029 旧键盘Analysis遍历字符串，找出第一个字符串中出现过，但第二个字符串中未出现的字符即可，字母不区分大小写，但字符串内有空格和数字，用_表示空格（也就是说，可能坏掉的键盘一共有 37 个），注意不能输出小写字母，且重复的字符只输出一次。这个题还可以用散列的思想来做，会更加简单直接。 Codetraverse string12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cctype&gt;void levelup(char *str);int main(int argc, char const *argv[]) &#123; char str1[85], str2[85], Result[40]; scanf("%s %s", str1, str2); levelup(str1); levelup(str2); int count = 0; for(int i = 0; str1[i] != '\0'; i++) &#123; char temp = str1[i]; bool flag = true; for(int j = 0; str2[j] != '\0'; j++) &#123; if(temp == str2[j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; int k = 0; for(k = 0; k &lt; 40; k++) &#123; if(temp == Result[k]) &#123; break; &#125; &#125; if(k == 40) &#123; Result[count++] = temp; &#125; &#125; &#125; Result[count] = '\0'; puts(Result); return 0;&#125;void levelup(char *str) &#123; char *p = str; while(*p != '\0') &#123; if(islower(*p)) &#123; *p = toupper(*p); &#125; p++; &#125;&#125; use string.find()上面代码做的事情，完全可以用 find 函数替代，如下：1234567891011121314#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s1, s2, ans; cin &gt;&gt; s1 &gt;&gt; s2; for(int i = 0; i &lt; s1.length(); i++) &#123; if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos) &#123; ans += toupper(s1[i]); &#125; &#125; cout &lt;&lt; ans; return 0;&#125; 实际上，strstr 函数也可以完成同样的功能。 hash12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxn 85char A[maxn], B[maxn];int hashtable[128] = &#123;0&#125;;int main() &#123; scanf("%s %s", A, B); for(int i = 0; i &lt; strlen(B); i++) &#123; if('a' &lt;= B[i] &amp;&amp; B[i] &lt;= 'z') hashtable[B[i] - 32]++; else hashtable[B[i]]++; &#125; for(int i = 0; i &lt; strlen(A); i++) &#123; if('a' &lt;= A[i] &amp;&amp; A[i] &lt;= 'z') &#123; if(!hashtable[A[i] - 32]) &#123; printf("%c", A[i] - 32); hashtable[A[i] - 32]++; &#125; &#125; else if(!hashtable[A[i]]) &#123; printf("%c", A[i]); hashtable[A[i]]++; &#125; &#125; return 0;&#125; 1030 完美数列Analysis题目大意是给一堆数字，这些数字以任意个数和顺序组成序列，使得这个数列的最大、最小值存在这样的关系：$M\ \le\ m \times p$，并要求这个数列包含的数字数量要尽可能的多。 看到题目一般会想到先将序列排序，然后找出其中的最大值，再从小到大枚举每一个数字，直到不满足关系时，退出循环，下标之差即是结果，但这这种思路实际上只把题目的输入数据当作了一个数列来处理（此时提交可得 20 分）。若这个数列还存在比$m \times p$小的数，按照这样的思路就无法让数字数量增加了（因为最大值已经限定了）。举个与样例相同的例子，唯一不同是总数字有 20 个，前 10 个数字与样例一样，后 10 个全是 1，这种思路得到的结果还是 8。但实际上，那 10 个 1 可以跟别的数字构成$M \le m \times p$的关系。 继续深入思考，对有序序列而言，按照题目要求，就需要以当前数字为左端点，然后找到符合要求的最大的右端点值（此时这个右端点值的下标最大，因为下标差越大，数字数量就越多）。按照这样的思路依次枚举每个数字就可以得到最终结果，此算法的时间复杂度为$O(n^2)$。 如何能将查找右端点值过程缩短一点呢？注意到数组已经被排好序了，所以可以使用二分查找来做这件事。此时，问题就演变为：从一个数的后面所有数中，找出刚好满足 $M\ \le\ m \times p$ 这个条件的数字，其中$M$和$m$分别为第一个数字与查找到的数字组成的数列的最大和最小值，这样时间复杂度就是$O(nlogn)$了。注意，由于 p 与数字都是不超过$10^9$的数，但相乘就溢出了，所以需要转换成 long long。 Codeuse binarysearch123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; // you can also use upper_bound function // int j = upper_bound(Num + i + 1, Num + n, (long long)Num[i] * p) - Num; int j = BinarySearch(i, (long long)Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; use two pointer实际上，这个题还可以用双指针的思想来找右端点的下标，如下：123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int i = 0, j = 0, ans = 1; while(i &lt; n &amp;&amp; j &lt; n) &#123; while(j &lt; n &amp;&amp; Num[j] &lt;= (long long)Num[i] * p) &#123; ans = max(ans, j - i + 1); j++; &#125; i++; &#125; printf("%d", ans); return 0;&#125; 1031 查验身份证Analysis题目不难，就是要认真读题，根据题目要求进行计算即可，略微有点麻烦，别马虎。 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;char idnum[20];int weight[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;char check[12] = &#123;'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'&#125;;int main() &#123; int n, invalid = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", idnum); int z = 0, flag = 1; for(int i = 0; i &lt; 17; i++) &#123; if(!('0' &lt;= idnum[i] &amp;&amp; idnum[i] &lt;= '9')) &#123; printf("%s\n", idnum); invalid++; flag = 0; break; &#125; z = z + (idnum[i] - '0') * weight[i]; &#125; if(flag) &#123; z %= 11; if(check[z] != idnum[17]) &#123; printf("%s\n", idnum); invalid++; &#125; &#125; &#125; if(!invalid) printf("All passed\n"); return 0;&#125; 1032 挖掘机技术哪家强Analysis这道题很简单，用数组简单模拟一下处理数据，然后查找最大值就好了，注意最后一个大数据的测试点。 Code12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 100005int main(int argc, char const *argv[]) &#123; int i, Num, Max = 0, N, School_Num[MAXN] = &#123;0&#125;, temp; scanf("%d", &amp;N); while(N--) &#123; scanf("%d %d", &amp;Num, &amp;temp); School_Num[Num] += temp; &#125; for(i = 0; i &lt; MAXN; i++) &#123; if(Max &lt; School_Num[i]) &#123; Num = i; Max = School_Num[i]; &#125; &#125; printf("%d %d\n", Num, Max); return 0;&#125; 1033 旧键盘打字Analysis与 1029 正好相反的一道题目，要注意的点： 不区分大小写，只要是第一个字符串出现过的字母，第二个字符串在输出时，无论大小写，都不能输出。 上档键坏了，尽管某个字母按键没坏，但是也不能输出这个字母的大写了。 第一个字符串可能是空串。 strlen可能会超时。 scanf无法读入测试点 2 的空串，所以要用fgets。 Codehash123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; bool brokenkey[128] = &#123;false&#125;; fgets(str2, MAXN, stdin); fgets(str1, MAXN, stdin); for(int i = 0; str2[i] != '\0'; i++) &#123; brokenkey[str2[i]] = true; if(isupper(str2[i])) brokenkey[str2[i] + 32] = true; &#125; for(int i = 0; str1[i] != '\0'; i++) &#123; if(!brokenkey[str1[i]]) &#123; if(isupper(str1[i]) &amp;&amp; brokenkey['+']) continue; printf("%c", str1[i]); &#125; &#125; return 0;&#125; use string.find()这个题一样可以用 find 函数来完成，如下：123456789101112131415161718#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s1, s2, ans; getline(cin, s1); getline(cin, s2); for(int i = 0; i &lt; s1.length(); i++) &#123; s1[i] = tolower(s1[i]); &#125; for(int i = 0; i &lt; s2.length(); i++) &#123; if(s1.find(s2[i]) == string::npos) &#123; if(!isupper(s2[i])) cout &lt;&lt; s2[i]; else if(s1.find('+') == string::npos &amp;&amp; s1.find(tolower(s2[i])) == string::npos) cout &lt;&lt; s2[i]; &#125; &#125; return 0;&#125; 1034 有理数运算Analysis题目大意是给定2个a/b形式的分数，a为分子，b为分母，求这2个分数的和、差、积、商，再输出。 给定的分数只有两种情况（形式上）：真分数和假分数，不存在带分数，但输出要输出带分数，并且是最简形式。化简的目的其实是题目在考察求最大公约数，利用欧几里得算法即可求得两个数的最大公约数。 注意： 除数为0时，需要输出Inf 负数需要使用()括起来 这种题，建议都用这种模板做。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Fraction &#123; ll up, down;&#125; f1, f2;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void printResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;f1.up, &amp;f1.down, &amp;f2.up, &amp;f2.down); //add printResult(f1); printf(" + "); printResult(f2); printf(" = "); printResult(Add(f1, f2)); putchar('\n'); //minu printResult(f1); printf(" - "); printResult(f2); printf(" = "); printResult(Minu(f1, f2)); putchar('\n'); //mult printResult(f1); printf(" * "); printResult(f2); printf(" = "); printResult(Mult(f1, f2)); putchar('\n'); //divide printResult(f1); printf(" / "); printResult(f2); printf(" = "); if(f2.up == 0) printf("Inf"); else printResult(Divide(f1, f2)); return 0;&#125; 1035 插入与归并Analysis题目的意思比较明确，给定两个序列，判断属于哪一种排序，然后输出这个序列在这种排序下的下一轮排序结果。 对给定的初始序列，按照插入排序的过程进行模拟，每轮排序都与给定的中间序列进行比较，如果相同就属于Insertion Sort，否则就是Merge Sort了。 在整个排序和比较的过程中，先进行比较，在需要输出的时候就不需要再进行依次排序操作，可以减少一部分的代码量。另外，重新写归并排序比较麻烦，直接使用sort函数来模拟归并排序的过程就比较方便，要注意sort函数每次只能排指定间隔内的数字。所以采用min(i + step, n)的写法避免最后一次排序时元素个数低于归并间隔的情况，即再最后一次排序过程中，只排剩下的元素。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 5;int origin[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125; putchar('\n');&#125;bool InsertSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag == true) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;origin[i]); tempOri[i] = origin[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = origin[i]; &#125; MergeSort(); &#125; return 0;&#125; 1036 跟奥巴马一起编程Analysis这种打印图形类的题目主要是在找输出的位置，注意题目给定的是字符变量C，而不是C字符。 Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int N, i, j; char C; scanf("%d %c", &amp;N, &amp;C); /*actually, you just need to find the place you want print */ for(i = 0; i &lt; (N + 1) / 2; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(i == 0 || i == (N - 1) / 2 || j == 0 || j == N - 1) putchar(C); else putchar(' '); &#125; putchar('\n'); &#125; return 0;&#125; 1037 在霍格沃茨找零钱Analysis题目意思很直观就是找零钱了，只不过度量单位不一样，在计算的时候，按照给定的量进行计算即可。注意由于，本题中钱的形式有三样，所以在计算前得先判断大小，然后让大的减小的，这样计算起来就很简单了；另外，相等的时候要特判输出0.0.0。 这个题目直接先全部转换成 Knut 然后再进行计算，得到结果后再转换回来会更简单一些。 Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;struct money &#123; int g, s, k;&#125; P, A, Result;bool Bigger(money a, money b);money Substract(money big, money small);int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;P.g, &amp;P.k, &amp;P.s, &amp;A.g, &amp;A.k, &amp;A.s); if(Bigger(P, A)) &#123; Result = Substract(P, A); if(!Result.g &amp;&amp; !Result.k &amp;&amp; !Result.s) printf("0.0.0\n"); else printf("-%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; else &#123; Result = Substract(A, P); printf("%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; return 0;&#125;bool Bigger(money a, money b) &#123; if(a.g != b.g) return a.g &gt;= b.g; else if(a.k != b.k) return a.k &gt;= b.k; else return a.s &gt;= b.s;&#125;money Substract(money big, money small) &#123; money ret; if(big.s &gt;= small.s) &#123; ret.s = big.s - small.s; &#125; else &#123; ret.s = big.s + 29 - small.s; big.k--; &#125; if(big.k &gt;= small.k) &#123; ret.k = big.k - small.k; &#125; else &#123; ret.k = big.k + 17 - small.k; big.g--; &#125; ret.g = big.g - small.g; return ret;&#125; version 2123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;int change2knut(int g, int s, int k) &#123; int res = k; s = s + g * 17; res = res + s * 29; return res;&#125;int main() &#123; int g, s, k, p, a; scanf("%d.%d.%d", &amp;g, &amp;s, &amp;k); p = change2knut(g, s, k); scanf("%d.%d.%d", &amp;g, &amp;s, &amp;k); a = change2knut(g, s, k); int ans = a - p; if(ans == 0) printf("0.0.0\n"); else &#123; int flag = 1; if(ans &lt; 0) &#123; ans = -ans; flag = 0; &#125; k = ans % 29; s = (ans / 29) % 17; g = ans / 29 / 17; if(!flag) printf("-"); printf("%d.%d.%d\n", g, s, k); &#125; return 0;&#125; 1038 统计同成绩学生Analysis考察基本散列的思想，将输入的分数值作为数组下标，每次查找的时间复杂度就变为了：$O(1)$。 Code123456789101112131415161718#include &lt;cstdio&gt;int grade[101] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int N, K, temp; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;temp); grade[temp]++; &#125; scanf("%d", &amp;K); while(K--) &#123; scanf("%d", &amp;temp); printf("%d", grade[temp]); if(K &gt; 0) putchar(' '); &#125; return 0;&#125; 1039 到底买不买Analysis将字符常量作为下标散列在统计次数的数组中，就可以很方便的统计珠子的个数了。买与不买对应两种情况： 买，多余的珠子数目就是两个字符串的长度之差 不买，遍历统计次数的数组，找到第二个字符串中出现次数比第一个字符串中出现次数多的字符，并记录下其差值。 Codeversion 112345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; version 2其实这个题，完全可以只用一个 hash 数组来完成，如下：12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int hashtb[256] = &#123;0&#125;;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for(int i = 0; i &lt; a.length(); i++) &#123; hashtb[a[i]]++; &#125; int less = 0; for(int i = 0; i &lt; b.length(); i++) &#123; if(hashtb[b[i]] &gt; 0) hashtb[b[i]]--; else less++; &#125; if(less) cout &lt;&lt; "No " &lt;&lt; less; else cout &lt;&lt; "Yes " &lt;&lt; a.length() - b.length(); return 0;&#125; 1040 有几个PATAnalysis题目大意是给定一个只含P、A、T三个字母的字符串，按照PAT的顺序，在不改变字符串内字符排列顺序的前提下，最多能有几个PAT这样的子串。 按照题目要求，最容易想到的思路就是利用三个循环暴力枚举所有可能的出现情况，然后统计符合要求的情况，最后在输出。但这样会超时，所以需要换个思路。 对于字符串中确定位置的每一个A而言，其能够与P、T组成PAT的个数，等于其左边P的个数乘以其右边T的个数。那么，这个问题就变成了，遍历字符串时，累加每一个A的左边P的个数与右边T的个数的乘积。 那么，如何才能较快的获得P的个数呢？可以使用一个数组一次性计算出字符串中每一个字符串左边P的个数。直接从左至右遍历字符串，如果当前位是P，那么此位置的数目就是前一位的数目加1；如果当前位不是P，那么此位置的数目就是前一位的数目。 解决了P的问题，T怎么办呢？定义一个变量，从右往左遍历字符串，现在只考虑两种情况： 当前字符为T，变量加 1。 当前字符为A，统计此位置A能组成的子串PAT的数目（计算时别忘了取余），再累加。 遍历结束后，就可以直接输出总数目了。 Codeversion 11234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt; const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') &#123; leftNumP[i]++; &#125; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt;= 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; version 2实际上，要求 A 左边 P 的个数其实完全可以不用数组，如果不用数组，那么如何计算 PAT 的个数呢？答案就是，先把 T 的个数求出来。按照上面的思路，把 T 的个数求出来后，每遇到 P 就记录 P 的个数，遇到 T 也记录 T 的个数，遇到 A 就计算 PAT 的个数，但是要减去记录的 T 的个数，因为这个 T 的个数是当前 A 前面的 T 的个数，二者的差才是当前 A 后面的个数，最后别忘了取余。12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MOD 1000000007const int maxn = 100000 + 10;char str[maxn];int main() &#123; scanf("%s", str); int len = strlen(str), P_cnt = 0, t_cnt = 0, T_cnt = 0; long long sum = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'T') T_cnt++; &#125; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') P_cnt++; else if(str[i] == 'T') t_cnt++; else if(str[i] == 'A') &#123; T_cnt -= t_cnt; t_cnt = 0; sum = (sum + (P_cnt * T_cnt)) % MOD; &#125; &#125; printf("%d", sum); return 0;&#125; 参考链接：1040. 有几个PAT（25）-PAT乙级真题 version 3这个题其实还有更直观的思路： 每个 A 对应的 PA 组合是 A 之前 P 的数量。 每个 T 对应的 PAT 组合是 T 之前所有 A 对应的 PA 组合数量的累加。 所有 PAT 组合数量是所有 T 对应的 PAT 组合数量的累加。 从而，就可以得到：123456789101112131415#include &lt;iostream&gt;#define mod 1000000007using namespace std;int main() &#123; int p = 0, pa = 0, pat = 0; char c; while((c = getchar()) != EOF &amp;&amp; c != '\n') &#123; if(c == 'P') p++; if(c == 'A') pa = (pa + p) % mod; if(c == 'T') pat = (pat + pa) % mod; &#125; cout &lt;&lt; pat; return 0;&#125; 参考链接：PAT Basic 1040. 有几个PAT (25) (C语言实现) 1041 考试座位号Analysis由于最后要输出准考证号，所以每次输入都必须保存输入的准考证号等信息。这样的话，使用结构体数组无疑是一种很方便的选择，之后再遍历结构体数组输出符合条件的信息即可， Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct examinee_info&#123; char number[17]; int test_seat; int exam_seat;&#125; Examinee_Info[1005];int main(int argc, char const *argv[]) &#123; int N, M, i, temp; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", Examinee_Info[i].number, &amp;Examinee_Info[i].test_seat, &amp;Examinee_Info[i].exam_seat); &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;temp); for(i = 0; i &lt; N; i++) &#123; if(temp == Examinee_Info[i].test_seat) &#123; printf("%s %d\n", Examinee_Info[i].number, Examinee_Info[i].exam_seat); &#125; &#125; &#125; return 0;&#125; 1042 字符统计Analysis利用数组统计每个英文字符（不区分大小写）的出现次数，直接使用字符变量（ASCII 码值）作为下标会很方便，同时得到出现的最大次数。输出时，遍历统计次数的数组，只输出字典序最小的字母即可。 Code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 1000 + 5;int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); int times[27] = &#123;0&#125;, maxtimes = -1; for(int i = 0; str[i] != '\0'; i++) &#123; char c1 = str[i]; if(isalpha(c1)) &#123; if(isupper(c1)) c1 = tolower(c1); times[c1 - 'a']++; if(times[c1 - 'a'] &gt; maxtimes) &#123; maxtimes = times[c1 - 'a']; &#125; &#125; &#125; for(int i = 0; i &lt; 27; i++) &#123; if(maxtimes == times[i]) &#123; printf("%c %d\n", i + 'a', times[i]); break; &#125; &#125; return 0;&#125; 1043 输出PATestAnalysis先统计字符串中PATest这六个字符的出现次数，然后依次输出PATest，注意当其中某个字符输出完后，仍然要保持PATest这个顺序来输出字符。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int MAXN = 10000 + 5;char PATest[10] = "PATest";int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['P'] || times['A'] || times['T'] || times['e'] || times['s'] || times['t']) &#123; for(p = PATest; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1044 火星数字Analysis题目给出了火星上的数位规则，要求将十进制数转换为火星数字并输出。尽管火星上每一位数输出的形式不一样，但其本质是13进制的，所以按照这个规则进行即可。 由于整个范围的数字有169个，所以提前将所有需要输出的数字全部打印好，之后直接输出比较好。为此，需要借助 C++ 的string和map，来分别建立数字对应字符串、字符串对应数字的映射数组。 注意：输入13时，需要输出tam，而不是tam tret。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const *argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); //get the extra ' ' from stdin while(n--) &#123; string s; getline(cin, s); if('0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; s.length(); i++) &#123; num = num * 10 + s[i] - '0'; &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[s] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; //string concatenation string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1045 快速排序Analysis题目的背景是快速排序算法内的一些概念，已经给出了描述，所以但不影响读题。依据题目的例子，可以得到主元的特点： 主元左边的数字全部比它小，即最大值小于它 主元右边的数字全部比它大，即最小值大于它 按照上述分析，依次枚举数组内每一个元素，如果每次都去查找当前元素的最值，会很耗时间。所以，要换一个角度去思考问题。 定义一个数组，一次性将所有数字左边的最小值全部计算出来，每次枚举时，就只用和前一个数字最左边的最小值进行比较，找最大值时同理。 最后在遍历一次数组，找出符合条件的数后直接输出即可。 Codeversion 1这种记录“状态”的写法，很有用。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;const int INF = 0x3fffffff;int array[MAXN], leftMax[MAXN], rightMin[MAXN];int ans[MAXN], num = 0;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftMax[0] = 0; for(int i = 1; i &lt; N; i++) &#123; leftMax[i] = max(leftMax[i - 1], array[i - 1]); &#125; rightMin[N - 1] = INF; for(int i = N - 2; i &gt;= 0; i--) &#123; rightMin[i] = min(rightMin[i + 1], array[i + 1]); &#125; for(int i = 0; i &lt; N; i++) &#123; if(leftMax[i] &lt; array[i] &amp;&amp; rightMin[i] &gt; array[i]) &#123; ans[num++] = array[i]; &#125; &#125; printf("%d\n", num); for(int i = 0; i &lt; num; i++) &#123; printf("%d", ans[i]); if(i &lt; num - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; version 2一般而言，这个题最容易想到的思路应该就是排序，排序之后，如果元素位置没有改变就可以确定这个元素是主元。但实际上，这种思路其实只确定了一个条件，那就是这个元素右边必然没有元素小于它，换句话讲，就是这个元素右边最小值大于它，这可以从反证法的角度来证明。那么，剩下要解决的问题就是，这个元素的左边的最大值是否小于它，这个判断也很简单。具体如下：12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, arr[maxn] = &#123;0&#125;, tmp[maxn], ans[maxn] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; tmp[i] = arr[i]; &#125; sort(tmp, tmp + n); int cnt = 0, max = 0; for(int i = 1; i &lt;= n; i++) &#123; if(arr[i] == tmp[i] &amp;&amp; max &lt; arr[i]) ans[cnt++] = arr[i]; if(arr[i] &gt; max) max = arr[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; if(cnt) &#123; for(int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; ans[i]; if(i != cnt - 1) cout &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 1046 划拳Analysis注意读题，理解题目意思后就好办了。另外注意，输家罚一杯酒，甲若输了，甲喝一杯，乙不喝；同赢或同输都不喝。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a, b, c, d, countA = 0, countB = 0; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if(a + c == b &amp;&amp; a + c == d) continue; // all win else if(a + c != b &amp;&amp; a + c != d) continue; // all lose else if(a + c == b) countB++; // A win else countA++; // B win &#125; cout &lt;&lt; countA &lt;&lt; ' ' &lt;&lt; countB; return 0;&#125; 1047 编程团体赛Analysis统计每支队伍的总分，然后找出总分的最大值，即可得到冠军队的编号。然后，输出冠军队的编号和总成绩。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int N, team, score[1010] = &#123;0&#125;, eachScore, maxteam = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%d-%*d %d", &amp;team, &amp;eachScore); score[team] += eachScore; if(team &gt; maxteam) &#123; maxteam = team; &#125; &#125; int maxscore = -1, index = 0; for(int i = 1; i &lt;= maxteam; i++) &#123; if(score[i] &gt; maxscore) &#123; maxscore = score[i]; index = i; &#125; &#125; printf("%d %d", index, maxscore); return 0;&#125; 1048 数字加密Analysis题目意思简单，做法也不难，就是有陷阱🤩，即：若是B的位数少于加密密钥的位数，需要假设B的当前位上的数字是0然后参与计算（注意奇偶位不同）即可。 一开始偷懒，以为短就短吧，只加密到需要加密的位数就行了，结果有两个测试点无法通过，看来还是题意理解的不够深入。 另外，由于输入后，数字的个位在字符串最后一位，所以需要逆置一下。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100 + 5;char change[14] = "0123456789JQK";void Reverse(char *s);int main(int argc, char const *argv[]) &#123; char A[MAXN], B[MAXN], Result[MAXN]; scanf("%s %s", A, B); Reverse(A); Reverse(B); int i, lenA = strlen(A), lenB = strlen(B), len; len = lenA &gt; lenB ? lenA : lenB; for(i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? A[i] - '0' : 0; int numB = i &lt; lenB ? B[i] - '0' : 0; if(i % 2 == 0) &#123; int sum = numA + numB; Result[i] = change[sum % 13]; &#125; else &#123; int diff = numB - numA; if(diff &lt; 0) &#123; diff += 10; &#125; Result[i] = change[diff]; &#125; &#125; Result[i] = '\0'; Reverse(Result); puts(Result); return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1049 数列的片段和Analysis题目大意是给定一个数列，计算其所有按序排列的子列和，直接做会超时，需要找规律。列举出$N$分别取3、4、5时，其和（$Sum$）情况如下： $N$ $Sum$ 3 $3 \times a_1 + 4 \times a_2 + 3 \times a_3$ 4 $4 \times a_1 + 6 \times a_2 + 6 \times a_3 + 4 \times a_4$ 5 $5 \times a_1 + 8 \times a_2 + 9 \times a_3 + 8 \times a_4 + 5 \times a_5$ 于是可以推出规律为：首项和尾项乘以项数相加，中间每项其左、右两边项数之积（包含它自身）。 修正测试数据后，在系数相乘的过程中，会出现溢出的情况，解决办法是用long long来代替double，再除以 1000 来得到最后的结果。 Codeversion 1.0123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(int i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; version 2.0123456789101112131415#include &lt;cstdio&gt;const int maxn = 100000 + 5;int n; int main() &#123; scanf("%d", &amp;n); double tmp; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%lf", &amp;tmp); ans += (long long)(tmp * 1000) * (long long)i * (long long)(n - i + 1); &#125; printf("%.2lf\n", ans/1000.0); return 0;&#125; 1050 螺旋矩阵Analysis这个题是个比较中等的模拟题，类似的题目其实有很多，难点在于输出顺序的确定，也就是数组的下标对应关系。先将给定的数字降序排列，然后一个一个读到矩阵中。此时，设置 4 个变量，分别代表上边界、下边界、左边界和右边界，这样就可以用 4 个循环按照题目要求的顺序放入对应的数字了。注意，最后一个数字要单独处理。单独处理并不是说每种情况最后一个数字都是这样处理，而是为了避免某些情况会陷入死循环中。比如当 n 取 9 时，最后一个数字如果不单独处理就会死循环。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;int N, num[MAXN], m, n, matrix[MAXN][MAXN];bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;num[i]); &#125; if(N == 1) &#123; printf("%d", num[0]); return 0; &#125; sort(num, num + N, cmp); m = (int)ceil(sqrt(N * 1.0)); while(N % m != 0) m++; n = N / m; int i = 1, j = 1, now = 0; int U = 1, D = m, L = 1, R = n; while(now &lt; N) &#123; while(now &lt; N &amp;&amp; j &lt; R) &#123; matrix[i][j] = num[now++]; j++; &#125; while(now &lt; N &amp;&amp; i &lt; D) &#123; matrix[i][j] = num[now++]; i++; &#125; while(now &lt; N &amp;&amp; j &gt; L) &#123; matrix[i][j] = num[now++]; j--; &#125; while(now &lt; N &amp;&amp; i &gt; U) &#123; matrix[i][j] = num[now++]; i--; &#125; U++, D--, L++, R--; i++, j++; if(now == N - 1) &#123; matrix[i][j] = num[now++]; &#125; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; printf("%d", matrix[i][j]); if(j &lt; n) printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; 1051 复数乘法Analysis此题不难，属于“纸老虎”，不过找特殊情况很是烦人的😅~注意计算得到的小于 -0.01 的会被保留 2 位有效数字的printf输出成-0.00。 Code12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(int argc, char const *argv[]) &#123; double R1, P1, R2, P2, R, P; scanf("%lf %lf %lf %lf", &amp;R1, &amp;P1, &amp;R2, &amp;P2); R = R1 * R2 * (cos(P1) * cos(P2) - sin(P1) * sin(P2)); P = R1 * R2 * (cos(P1) * sin(P2) + sin(P1) * cos(P2)); //prevent to print "-0.00" if(-0.01 &lt; R &amp;&amp; R &lt; 0) R = 0.0; if(-0.01 &lt; P &amp;&amp; P &lt; 0) P = 0.0; printf("%.2lf", R); if(P &gt;= 0) &#123; printf("+%.2lfi\n", P); &#125; else &#123; printf("-%.2lfi\n", fabs(P)); &#125; return 0;&#125; 1052 卖个萌Analysis这个题有点坑爹，题意也不算难理解，就是按照给定的输入样例，可能无法得到给定的输出样例，总是给人感觉好像做错了。实际上，样例内有些字符的不是 ASCII 编码，所以没法正常的输出。所以，真要是在考试的时候遇到这样的情况，只能通过字符的个数来猜，有没有获得需要的字符。 明白了以上情况后，再回到这道题上，可以发现，题目想让我们做的事情，本质上就是将字符拼在一起，然后输出就行了。要输出的字符是题目给定的，可能会给不存在的字符，这时输出Are you kidding me? @\/@即可。另外，还有几个注意点： 要输出\必须使用&quot;\\&quot;，也就是转义。 不存在某种字符时，直接输出Are you kidding me? @\/@。 由于给定的字符串有空格的存在，所以使用getline来直接读取一行字符串。 别忘记了还要给最终结果加括号：(和)。 Codeversion 1这个版本是自己写的，利用vector&lt;char&gt;来储存处理字符，代码写的比较繁琐，很多其实都是重复的部分。写的时候，想的是能 AC 就行了，之后再改，结果现在也懒得改了，奏这样吧。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;char&gt; hands[11], eyes[11], mouth[11], emo;string temp;int arr[6];int main() &#123; for(int i = 1; i &lt;= 3; i++) &#123; getline(cin, temp); int j, k, cnt = 1; if(i == 1) &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; hands[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; else if(i == 2) &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; eyes[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; else &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; mouth[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; &#125; int k, tmp; cin &gt;&gt; k; while(k--) &#123; bool flag = true; emo.clear(); for(int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; arr[i]; &#125; if(hands[arr[0]].size() == 0 || eyes[arr[1]].size() == 0 || mouth[arr[2]].size() == 0 \ || eyes[arr[3]].size() == 0 || hands[arr[4]].size() == 0) &#123; printf("Are you kidding me? @\\/@\n"); continue; &#125; for(vector&lt;char&gt;::iterator it = hands[arr[0]].begin(); it != hands[arr[0]].end(); it++) &#123; emo.push_back(*it); &#125; emo.push_back('('); for(vector&lt;char&gt;::iterator it = eyes[arr[1]].begin(); it != eyes[arr[1]].end(); it++) &#123; emo.push_back(*it); &#125; for(vector&lt;char&gt;::iterator it = mouth[arr[2]].begin(); it != mouth[arr[2]].end(); it++) &#123; emo.push_back(*it); &#125; for(vector&lt;char&gt;::iterator it = eyes[arr[3]].begin(); it != eyes[arr[3]].end(); it++) &#123; emo.push_back(*it); &#125; emo.push_back(')'); for(vector&lt;char&gt;::iterator it = hands[arr[4]].begin(); it != hands[arr[4]].end(); it++) &#123; emo.push_back(*it); &#125; for(int i = 0; i &lt; emo.size(); i++) &#123; cout &lt;&lt; emo[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; version 2这个版本来自：1052. 卖个萌 (20)-PAT乙级真题，用的是vector&lt;string&gt;，本质上与自己的思路是一样的，不过代码清爽了许多。123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;vector&lt;string&gt; &gt; v; for(int i = 0; i &lt; 3; i++) &#123; string s; getline(cin, s); vector&lt;string&gt; row; int j = 0, k = 0; while(j &lt; s.length()) &#123; if(s[j] == '[') &#123; while(k++ &lt; s.length()) &#123; if(s[k] == ']') &#123; row.push_back(s.substr(j+1, k-j-1)); break; &#125; &#125; &#125; j++; &#125; v.push_back(row); &#125; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if(a &gt; v[0].size() || b &gt; v[1].size() || c &gt; v[2].size() || d &gt; v[1].size() || e &gt; v[0].size() || a &lt; 1 || b &lt; 1 || c &lt; 1 || d &lt; 1 || e &lt; 1) &#123; cout &lt;&lt; "Are you kidding me? @\\/@" &lt;&lt; endl; continue; &#125; cout &lt;&lt; v[0][a-1] &lt;&lt; "(" &lt;&lt; v[1][b-1] &lt;&lt; v[2][c-1] &lt;&lt; v[1][d-1] &lt;&lt; ")" &lt;&lt; v[0][e-1] &lt;&lt; endl; &#125; return 0;&#125; version 3这个版本来自：PAT Basic 1052. 卖个萌 (20)（C语言实现），利用scanf的特性来直接得到想要的东西，这个操作很精彩，还有 3 维数组的使用，也需要学习一下。就根本来讲，用 3 维的vector&lt;char&gt;应该也可以得到这样的效果。1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int N, m[5]; char c, symbols[3][10][5] = &#123;0&#125;; for(int symbol = 0; symbol &lt; 3; symbol++) for(int index = 0; (c = getchar()) != '\n'; ) if(c == '[') scanf("%[^]]", symbols[symbol][index++]); scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; for(int i = 0; i &lt; 5; i++) scanf("%d", m + i); if(m[0] &gt; 0 &amp;&amp; m[0] &lt;= 10 &amp;&amp; *symbols[0][--m[0]] &amp;&amp; m[1] &gt; 0 &amp;&amp; m[1] &lt;= 10 &amp;&amp; *symbols[1][--m[1]] &amp;&amp; m[2] &gt; 0 &amp;&amp; m[2] &lt;= 10 &amp;&amp; *symbols[2][--m[2]] &amp;&amp; m[3] &gt; 0 &amp;&amp; m[3] &lt;= 10 &amp;&amp; *symbols[1][--m[3]] &amp;&amp; m[4] &gt; 0 &amp;&amp; m[4] &lt;= 10 &amp;&amp; *symbols[0][--m[4]]) printf("%s(%s%s%s)%s\n", symbols[0][m[0]], symbols[1][m[1]], symbols[2][m[2]], symbols[1][m[3]], symbols[0][m[4]]); else puts("Are you kidding me? @\\/@"); &#125; return 0;&#125; 1053 住房空置率Analysis按照题目给定的条件进行计算即可，但要注意第二个条件需要观察期 K 大于给定阈值 D。另外，还需注意浮点数的计算和百分号的输出。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;int N, D;double e;int main() &#123; scanf("%d %lf %d", &amp;N, &amp;e, &amp;D); int empty = 0, possible = 0, tmp = N; while(tmp--) &#123; int k, half = 0; scanf("%d", &amp;k); double days[k]; for(int i = 0; i &lt; k; i++) &#123; scanf("%lf", &amp;days[i]); if(days[i] &lt; e) half++; &#125; if(half &gt; k / 2) &#123; if(k &gt; D) empty++; else possible++; &#125; &#125; printf("%.1lf%% %.1lf%%\n", possible * 100.0 / N, empty * 100.0 / N); return 0;&#125; /*in:5 0.5 106 0.3 0.4 0.5 0.2 0.8 0.610 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.111 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1out:40.0% 20.0%in:3 0.5 1010 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1out:66.7% 33.3%in:1 0.5 1011 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1out:0.0% 100.0%in:1 0.5 106 0.3 0.4 0.5 0.2 0.8 0.6out:0.0% 0.0%in:2 0.5 1010 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.7out:100.0% 0.0%*/ 1054 求平均值Analysis这是一道字符串处理题，首先是对数字合法的判断，非法的输入包含下面几点： 数值范围超过了$[-1000, 1000]$。 输入中含有非数字或小数点字符。 输入中含有多个小数点字符。 有效数字超过了 2 位。 按照上面的标准判断是否合法即可，提取出数值也比较容易，负号一定出现在str[0]；计算小数，只需记录好小数点后数字的个数，最终结果在除以pow(10, dec)即可。另外还需要注意一下题目中的陷阱，如果只有一个有效数字，得输出The average of 1 number is Y，里面的number没有s。 Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;char str[100];double num;bool getnum(char *str) &#123; num = 0.0; bool flag = false; int i = 0, dec = 0, pnum = 0; if(str[i] == '-') &#123; for(i++; str[i] != '\0'; i++) &#123; if(flag) dec++; if(str[i] == '.') &#123; pnum++; flag = true; &#125; else if(pnum &gt; 1 || '9' &lt; str[i] || str[i] &lt; '0' || dec &gt; 2) return false; if('0' &lt;= str[i] &amp;&amp; str[i] &lt;= '9') num = num * 10 + str[i] - '0'; &#125; num = num / pow(10, dec) * -1; &#125; else &#123; for(; str[i] != '\0'; i++) &#123; if(flag) dec++; if(str[i] == '.') &#123; pnum++; flag = true; &#125; else if(pnum &gt; 1 || '9' &lt; str[i] || str[i] &lt; '0' || dec &gt; 2) return false; if('0' &lt;= str[i] &amp;&amp; str[i] &lt;= '9') num = num * 10 + str[i] - '0'; &#125; num = num / pow(10, dec); &#125; if(-1000.0 &lt;= num &amp;&amp; num &lt;= 1000.0) return true; else return false;&#125;int main() &#123; int n, valid = 0; double sum = 0.0; scanf("%d", &amp;n); while(n--) &#123; scanf("%s", str); if(getnum(str)) &#123; sum += num; valid++; &#125; else &#123; printf("ERROR: %s is not a legal number\n", str); &#125; &#125; if(valid &gt; 1) printf("The average of %d numbers is %.2lf\n", valid, sum / valid); else if(valid == 1) printf("The average of %d number is %.2lf\n", valid, sum / valid); else printf("The average of 0 numbers is Undefined\n"); return 0;&#125; /*in:75 -3.2 aaa 9999 2.3.4 7.123 2.35out:ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38in:2aaa -9999out:ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefinedin:11000out:The average of 2 number is 1000.00*/ version 2这个题一旦用 sscanf 和 sprintf 来处理输出的字符串，就会非常简单，sscanf 是从字符串中读入指定格式的数据放到变量中，sprintf 是将变量中的数据按照指定的格式放到字符串中，如下：1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int n, valid = 0; double sum = 0.0, tmp = 0.0; scanf("%d", &amp;n); char a[50], b[50]; while(n--) &#123; scanf("%s", a); sscanf(a, "%lf", &amp;tmp); sprintf(b, "%.2lf", tmp); int flag = 0; for(int j = 0; j &lt; strlen(a); j++) &#123; if(a[j] != b[j]) flag = 1; &#125; if(flag || tmp &lt; -1000 || tmp &gt; 1000) &#123; printf("ERROR: %s is not a legal number\n", a); continue; &#125; else &#123; sum += tmp; valid++; &#125; &#125; if(valid == 1) printf("The average of 1 number is %.2lf\n", sum); else if(valid &gt; 1) printf("The average of %d numbers is %.2lf\n", valid, sum / valid); else printf("The average of 0 numbers is Undefined\n"); return 0;&#125; 1055 集体照Analysis这个题参考了1055. 集体照 (25)-PAT乙级真题的思路。主要有两个难点： 题意的理解 排队过程的模拟 分开来看： 首先要明确题目是站在拍照者（就是排队的人）的角度来描述的，排多少排，每排多少人数，这些题目都交代的很清晰，多出来的人全部排在最后一排。显然，如果每排$N/K$个人，那么，最后一排的人数就是$N/K + N\%K$，这样就可以把多出来的人全部排下。如果下标从 1 开始，那么中间位置（最高的人）就是$m/2 + 1$，下标从 0 开始，就是$m/2$。中间人选好后，接着以其为轴开始交替排其他人。就描述中的例子而言，5人身高为 190、188、186、175、170，首先得到的序列是x x 190 x x，按照身高非增序（降序）先右边（假设你是最高的人）排一个可以得到x 188 190 x x，再按照身高顺序左边排一个可以得到x 188 190 186 x，然后再排右边，就是175 188 190 186 x，最后再排左边就可以得到175 188 190 186 170了。 按照上面的分析要模拟排队的过程，首先就需要将身高与人名（字典序升序）进行排序，这个问题很容易解决，构造结构体，然后排序即可。然后再来排队，首先从输出样例可以看出，输出的第一排实际上是整个队伍的最后一排。换句话说，第一行输出的是人数最多，身高最高的一排，那么这一排的人数就是$N/K + N\%K$，其他排的人数就是$N/K$。people 数组和 queue 数组的下标都是从 0 开始的，身高最高的人就排在m/2。接着站在拿相机的人的视角，再来排中间人的左边，queue 这个数组就得从j = m/2 - 1开始，people 数组的下标就要从i = t + 1，因为要还要排右边所以不要改动t的值，再排下一个人，queue 数组的下标就是j--，people 数组的下标就是i = i + 2，因为另一个人要排在右边，所以要跳一个人。同理，排右边的时候，queue 数组从j = m/2 + 1开始，people 数组的下标从i = t + 2开始，再排下一个人时，queue 数组下标就变为j++，people 数组下标就变为i = i + 2。每次循环，只排了当前排的人的数目。Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 10;struct human&#123; char name[10]; int height;&#125; people[maxn], queue[maxn];int n, k, m;bool cmp(human a, human b)&#123; if(a.height != b.height) return a.height &gt; b.height; else return strcmp(a.name, b.name) &lt; 0;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; people[i].name &gt;&gt; people[i].height; &#125; sort(people, people + n, cmp); int t = 0, row = k; while(row) &#123; if(row == k) m = n / k + n % k; else m = n / k; queue[m / 2] = people[t]; // left int j = m / 2 - 1; for(int i = t + 1; i &lt; t + m; i = i + 2) &#123; queue[j--] = people[i]; &#125; // right j = m / 2 + 1; for(int i = t + 2; i &lt; t + m; i = i + 2) &#123; queue[j++] = people[i]; &#125; // print cout &lt;&lt; queue[0].name; for(int i = 1; i &lt; m; i++) &#123; cout &lt;&lt; ' ' &lt;&lt; queue[i].name; &#125; cout &lt;&lt; endl; t = t + m; row--; &#125; return 0;&#125; 1056 组合数的和Analysis题目不难，读懂题目之后直接做就可以了，也没有设置超时数据。不过，仔细观察一下可以发现，每个数都被当做n-1次十位，这样得话，就可以直接计算了。 Codeversion 11234567891011121314151617#include &lt;cstdio&gt;int main() &#123; int n, arr[15], sum = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; sum = sum + (arr[i] * 10 * (n - 1)); for(int j = 0; j &lt; n; j++) &#123; if(j != i) sum += arr[i]; &#125; &#125; printf("%d", sum); return 0; &#125; version 2再深入思考一下，假设一共 3 项为 a、b、和 c，就有：$(a + b + c) \times 10 \times (3 - 1) + (b + c + a + c + a + b) = (a + b + c) \times (3 - 1) \times 11$，把其中的项数换成 n 就可以得到一般化公式：$sum = 11(N - 1)\sum_{i=1}^Na_i$。那么，就可以得到下面的代码：123456789101112#include &lt;cstdio&gt;int main() &#123; int n, arr, sum = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr); sum += arr; &#125; printf("%d", sum * (n - 1) * 11); return 0; &#125; 1057 数零壹Analysis先得到整数 N，然后再做进制转换，分别记录下 0 和 1 的个数。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int maxn = 100000 + 5;char str[maxn];long long sum = 0;int main() &#123; fgets(str, maxn, stdin); for(int i = 0; str[i] != '\0'; i++) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') sum = sum + str[i] - 'A' + 1; if('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'z') sum = sum + str[i] - 'a' + 1; &#125; long long tmp = sum; int one = 0, zero = 0; while(tmp != 0)&#123; int i = tmp % 2; if(i) one++; else zero++; tmp /= 2; &#125; printf("%d %d", zero, one); return 0;&#125; 这个题如果对数在计算机内的存储形式比较了解的话，完全可以不用取余来做，直接利用位运算得到结果，如下：1234for(; tmp; tmp &gt;&gt;= 1) &#123; if(tmp &amp; 1) one++; else zero++;&#125; 1058 选择题Analysis题目意思比较直观，根据题目的描述可以判断出这是一道字符串处理相关的题目。题目描述的内容比较多，为了储存数据方便，构造一个新的结构体比较好。另外，strcmp这个函数只有字符串相同的时候才会输出 0；利用scanf输入时，需要用getchar来接受末尾的回车符或者是空格，当然，scanf的格式化串%*c也可以直接吞掉后面的一个字符。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1000 + 5;const int maxm = 100 + 5;struct question &#123; char answer[6]; int score, c1, c2;&#125; que[maxm];char str[1005];int n, m, times[maxm] = &#123;0&#125;;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d %d %d", &amp;que[i].score, &amp;que[i].c1, &amp;que[i].c2); char c; getchar(); int j; for(j = 0; j &lt; que[i].c2; j++) &#123; scanf("%c%*c", &amp;que[i].answer[j]); &#125; que[i].answer[j] = '\0'; &#125; for(int i = 1; i &lt;= n; i++) &#123; fgets(str, 1005, stdin); char ans[6]; int score = 0, ti, qnum = 1; for(int j = 0; str[j] != '\0'; j++) &#123; if(str[j] == '(') &#123; int k, tmp = 0; for(k = j + 1; str[k] != ')'; k++) &#123; if('0' &lt;= str[k] &amp;&amp; str[k] &lt;= '9') &#123; ti = str[k] - '0'; &#125; if('a' &lt;= str[k] &amp;&amp; str[k] &lt;= 'z') &#123; ans[tmp++] = str[k]; &#125; &#125; ans[tmp] = '\0'; j = k + 1; if(ti != que[qnum].c2 || strcmp(que[qnum].answer, ans) != 0) times[qnum]++; else score += que[qnum].score; qnum++; &#125; &#125; printf("%d\n", score); &#125; int max = times[0]; for(int i = 1; i &lt;= m; i++) &#123; if(max &lt; times[i]) max = times[i]; &#125; if(max) &#123; printf("%d", max); for(int i = 1; i &lt;= m; i++) &#123; if(max == times[i]) printf(" %d", i); &#125; &#125; else printf("Too simple"); return 0;&#125; 1059 C语言竞赛Analysis参赛者的 ID 跟排名是一次性给出的，可以直接用排名当作下标来保存 ID。要区分是否查询过了，可以设置一个 bool 数组，查询过的元素就标记为true。这个题有 2 个测试点是卡时间的，C 语言的strcmp和 C++ 的string可能无法通过，所以直接使用 map 就行了。 Codeuse char[]123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;const int maxn = 10000 + 5;char stu[maxn][6];int n, k;bool check[maxn] = &#123;false&#125;;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", stu[i]); &#125; scanf("%d", &amp;k); char str[6]; while(k--) &#123; scanf("%s", str); int rank = 1; bool flag1 = false; for(; rank &lt;= n; rank++) &#123; if(strcmp(str, stu[rank]) == 0) &#123; flag1 = true; break; &#125; &#125; printf("%s: ", str); if(flag1) &#123; if(!check[rank]) &#123; if(rank == 1) printf("Mystery Award\n"); else if(isprime(rank)) printf("Minion\n"); else printf("Chocolate\n"); check[rank] = true; &#125; else printf("Checked\n"); &#125; else printf("Are you kidding?\n"); &#125; return 0;&#125; use string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;bool check[maxn] = &#123;false&#125;;int n, k;string str[maxn];bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; str[i]; &#125; cin &gt;&gt; k; string s; while(k--)&#123; cin &gt;&gt; s; int rank = 1; bool flag = false; for(; rank &lt;= n; rank++) &#123; if(s == str[rank]) &#123; flag = true; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; ": "; if(flag) &#123; if(!check[rank]) &#123; if(rank == 1) cout &lt;&lt; "Mystery Award"; else if(isprime(rank)) cout &lt;&lt; "Minion"; else cout &lt;&lt; "Chocolate"; check[rank] = true; &#125; else cout &lt;&lt; "Checked"; &#125; else cout &lt;&lt; "Are you kidding?"; cout &lt;&lt; endl; &#125; return 0;&#125; use map123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;map&lt;string, int&gt; stu;int n, k;bool check[maxn] = &#123;false&#125;;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; cin &gt;&gt; n; string str; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; str; stu[str] = i; &#125; cin &gt;&gt; k; while(k--) &#123; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; ": "; map&lt;string, int&gt;::iterator it = stu.find(str); if(it == stu.end()) cout &lt;&lt; "Are you kidding?"; else &#123; if(!check[it-&gt;second]) &#123; if(it-&gt;second == 1) cout &lt;&lt; "Mystery Award"; else if(isprime(it-&gt;second)) cout&lt;&lt; "Minion"; else cout&lt;&lt; "Chocolate"; check[it-&gt;second] = true; &#125; else cout &lt;&lt; "Checked"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1060 爱丁顿数Analysis这道题参考了1060. 爱丁顿数(25)-PAT乙级真题。总感觉这个题有点像脑筋急转弯😓...首先要明确的是，E 可能并不是给出来的数，能确定的就是 E 肯定要小于天数。以6 7 6 9 3这组数据为例，这组数据的 E 应该等于 4，也即连续 4 天骑车超过 4 英里（6、7、6、9）。理解这个点了后，设置数组下标从 1 开始（假设是第一天）。先将所给序列降序排序，然后让ans = 0，遍历数组，每存在一个num[p] &gt; p的数（就是骑车的公里数大于天数的这类数），就让ans++，最后结果就是所求 E。PS：自己做的时候，排完序，拿到 13 分，就没思路了，主要是不明白 E 可能并不是数组中的数，应该多思考一下。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, num[maxn] = &#123;0&#125;;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); &#125; sort(num + 1, num + n + 1, cmp); int ans = 0, p = 1; while(ans &lt;= n &amp;&amp; num[p] &gt; p) &#123; ans++; p++; &#125; printf("%d", ans); return 0;&#125; 1061 判断题Analysis题目稍微有点绕，大致意思就像老师改卷一样，正确打勾，错误打叉，然后把对的题目的分数加到一起，从而得到每位学生的总分。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int maxn = 100 + 5;const int maxm = 100 + 5;int scores[maxm] = &#123;0&#125;, ans[maxm] = &#123;0&#125;;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;scores[i]); &#125; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;ans[i]); &#125; while(n--) &#123; int gre = 0, tmp; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;tmp); if(tmp == ans[i]) gre += scores[i]; &#125; printf("%d\n", gre); &#125; return 0;&#125; 1062 最简分数Analysis这个题有两个思路，一种是直接从分数的角度思考，另外一种是从小数的角度思考，分开来看： 从分数的角度思考，那么就要求出两个分母和题目给定的分母，这 3 个数的最小公倍数。以这个数作为公共分母，然后再从小的分子开始遍历，找出分母为 k 的最简分数即可。从分数的角度思考，一定要明确思路，不然容易被绕糊涂。 从小数的角度思考就简单一点了，先将给定的分数转化为小数，然后从 1 到 k 遍历所有分数（题目给定的数据肯定没有大于 1 的假分数，这个其实很容易猜到），满足不能与 k 约分（即没有最小公约数）并在给定范围内的数即为所求的解。 Codeuse fraction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int lcm(int a, int b) &#123; int tmp = gcd(a, b); return a * b / tmp;&#125;int main() &#123; int n1, m1, n2, m2, k; scanf("%d/%d %d/%d %d", &amp;n1, &amp;m1, &amp;n2, &amp;m2, &amp;k); int t1 = lcm(m1, m2); int t2 = lcm(t1, k); if(n1 &gt; n2) &#123; int tmp = n1; n1 = n2; n2 = tmp; &#125; int left = n1 * t2 / m1, right = n2 * t2 / m2, tmp = t2 / k; bool flag = true; for(int i = left + 1; i &lt; right; i++) &#123; if(i % tmp == 0 &amp;&amp; gcd(i / tmp, k) == 1) &#123; if(flag) &#123; printf("%d/%d", i / tmp, k); flag = false; &#125; else &#123; printf(" %d/%d", i / tmp, k); &#125; &#125; &#125; return 0;&#125;/*in:7/18 13/20 12out:5/12 7/12in:7/18 19/20 12out:5/12 7/12 11/12in:1/8 7/8 8out:3/8 5/8in:1/8 7/8 2out:1/2in:1/18 13/20 12out:1/12 5/12 7/12in:1/2 3/4 8out:5/8in:1/10 1/2 5out:1/5 2/5*/ use decimals参考：PAT乙级练习题 1062 最简分数 (20 point(s))123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int hasCommonDivisor(int i, int k) &#123; for (int j = 2; j &lt;= i; ++j) &#123; if (i % j == 0 &amp;&amp; k % j == 0) &#123; return 1; &#125; &#125; return 0;&#125;int main() &#123; int N1, M1, N2, M2, K; scanf("%d/%d %d/%d %d", &amp;N1, &amp;M1, &amp;N2, &amp;M2, &amp;K); double d1 = N1 * 1.0 / M1; double d2 = N2 * 1.0 / M2; if (d1 &gt; d2) &#123; double tmp = d1; d1 = d2; d2 = tmp; &#125; int isFirst = 1; for (int i = 1; i &lt;= K; i++) &#123; if (!hasCommonDivisor(i, K)) &#123; double di = i * 1.0 / K; if (di &gt; d1 &amp;&amp; di &lt; d2) &#123; if(isFirst)&#123; printf("%d/%d", i, K); isFirst = 0; &#125;else&#123; printf(" %d/%d", i, K); &#125; &#125; &#125; &#125; return 0;&#125; 1063 计算谱半径Analysis输出结果是浮点数，那么直接用浮点数就好了，避免可能会出现的误差，也可以直接用pow函数，就可以省去判断正负了直接乘就行。 Code123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int n; scanf("%d", &amp;n); double rep, imp, pradius = 0.0, tmp; while(n--) &#123; scanf("%lf %lf", &amp;rep, &amp;imp); tmp = sqrt(rep * rep + imp * imp); if(tmp &gt; pradius) pradius = tmp; &#125; printf("%.2lf", pradius); return 0;&#125; 1064 朋友数Analysis这个题只需要统计可能的“朋友数”即可，利用散列，统计“朋友数”出现的次数即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;int times[40] = &#123;0&#125;;int main() &#123; int n; scanf("%d", &amp;n); char num[6]; while(n--) &#123; scanf("%s", num); int tmp = 0, digit = 0, len = strlen(num); for(int i = len - 1; i &gt;= 0; i--) &#123; if(isdigit(num[i])) tmp += num[i] - '0'; &#125; times[tmp]++; &#125; int cnt = 0; for(int i = 0; i &lt; 40; i++) &#123; if(times[i] &gt; 0) cnt++; &#125; printf("%d\n", cnt); bool flag = true; for(int i = 0; i &lt; 40; i++) &#123; if(times[i] &gt; 0) &#123; if(flag) &#123; printf("%d", i); flag = false; &#125; else printf(" %d", i); &#125; &#125; return 0;&#125; /*in:10123 899 51 998 27 33 36 12 0 0out:50 3 6 9 26*/ 1065 单身狗Analysis利用 map 建立夫妻关系的映射，同时利用 set，保存这些非单身狗（莫名戳中笑点😂）和派对总人数。然后利用夫妻关系，找出派对中夫妻双方只出席了一方的单身狗；接着再利用保存的非单身狗信息，确定剩下本来就是单身狗的人。PS：直接用 map 和 set 也能过 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, string&gt; couples;set&lt;string&gt; peo, sdog, notdog;int n, m;int main() &#123; cin &gt;&gt; n; string hs_tmp, wi_tmp, people; while(n--) &#123; cin &gt;&gt; hs_tmp &gt;&gt; wi_tmp; couples[hs_tmp] = wi_tmp; notdog.insert(hs_tmp), notdog.insert(wi_tmp); &#125; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; people; peo.insert(people); &#125; for(unordered_map&lt;string, string&gt;::iterator it = couples.begin(); it != couples.end(); it++) &#123; hs_tmp = it-&gt;first, wi_tmp = it-&gt;second; if(peo.find(hs_tmp) != peo.end() &amp;&amp; peo.find(wi_tmp) == peo.end()) sdog.insert(hs_tmp); else if(peo.find(hs_tmp) == peo.end() &amp;&amp; peo.find(wi_tmp) != peo.end()) sdog.insert(wi_tmp); &#125; for(set&lt;string&gt;::iterator it = peo.begin(); it != peo.end(); it++) &#123; if(notdog.find(*it) != notdog.end()) continue; else sdog.insert(*it); &#125; cout &lt;&lt; sdog.size() &lt;&lt; endl; set&lt;string&gt;::iterator it = sdog.begin(); for(int i = 0; i &lt; sdog.size(); i++) &#123; cout &lt;&lt; *it; if(i &lt; sdog.size() - 1) cout &lt;&lt; ' '; it++; &#125; return 0;&#125; 1066 图像过滤Analysis这道题的意思，其实就是图像的灰度化处理（当然这里的比较简单）。Matlab 内有直接进行此种操作的图像处理函数，可以直接调用。注意 N 和 M 的最大值，最后一个测试点是最大值测试。 这个题其实开不开数组都可以。 Code12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define MAXN 500#define MAXM 500int main(int argc, char const *argv[]) &#123; int r, c, M, N, A, B, gray_value; scanf("%d %d %d %d %d", &amp;M, &amp;N, &amp;A, &amp;B, &amp;gray_value); int image_array[MAXM][MAXN]; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; scanf("%d", &amp;image_array[r][c]); if(A &lt;= image_array[r][c] &amp;&amp; image_array[r][c] &lt;= B) &#123; image_array[r][c] = gray_value; &#125; &#125; &#125; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; printf("%03d", image_array[r][c]); if(c == N-1) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125; 1067 试密码Analysis这个题看着简单，其实有一点细节信息： 正确的密码不包含空格，错误的密码就会包含了，这是 AC 这道题目的关键。 #不被认为输入，#...#也不被认为是输入。 Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; string password, str; int N; cin &gt;&gt; password &gt;&gt; N; int attempt = 1; bool flag = false; getchar(); while(1) &#123; getline(cin, str); if(str == "#") break; if(str == password &amp;&amp; attempt &lt;= N) &#123; cout &lt;&lt; "Welcome in" &lt;&lt; endl; break; &#125; if(str != password &amp;&amp; attempt &lt;= N) &#123; cout &lt;&lt; "Wrong password: " &lt;&lt; str &lt;&lt; endl; if(attempt == N)&#123; cout &lt;&lt; "Account locked" &lt;&lt; endl; break; &#125; &#125; attempt++; &#125; return 0;&#125; 1068 万绿丛中一点红Analysis题意不难理解，但是有点细节需要注意： 选出来的点一定要是唯一存在的。 选出来的点与其相邻的八个点的色差的绝对值一定要大于 TOL。 输入是列、行，输出也是。 Codeversion 1这段代码是自己写的，一开始没想到竟然能开这么大的数组，之所以下标从 1 开始是为了与题目保持一致，也可以避免判断时越界访问。实际上，数组下标是可以为负的，下标从 0 开始也能 AC ，但这段代码就不那么严谨了，题目的测试数据可能也不是那么严谨。123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef long long LL;const int maxn = 1000 + 5;const int maxm = 1000 + 5;LL M, N, TOL, image[maxm][maxn] = &#123;0&#125;;int times[18000000] = &#123;0&#125;;int main() &#123; scanf("%lld %lld %lld", &amp;M, &amp;N, &amp;TOL); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%lld", &amp;image[i][j]); times[image[i][j]]++; &#125; &#125; LL x, y, cnt = 0; x = y = 1; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; LL t = image[i][j]; if(times[image[i][j]] == 1 &amp;&amp; abs(t - image[i - 1][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i - 1][j]) &gt; TOL &amp;&amp; abs(t - image[i - 1][j + 1]) &gt; TOL &amp;&amp; abs(t - image[i][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i][j + 1]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j + 1]) &gt; TOL ) &#123; x = j, y = i; cnt++; &#125; &#125; &#125; if(cnt == 1) printf("(%lld, %lld): %lld", x, y, image[y][x]); else if(cnt &gt; 1) printf("Not Unique"); else printf("Not Exist"); return 0;&#125; version 2这段代码参考：1068 万绿丛中一点红 （20 分），其中判断是否唯一的函数做了限定，这样进行判断的点一定是数组内的点。1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int image[1005][1005];map&lt;int, int&gt; isappear; int dd[8][2] = &#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125;;int m, n, tol;bool isonly(int x, int y) &#123; for(int i = 0; i &lt; 8; i++) &#123; int xx = x + dd[i][0]; int yy = y + dd[i][1]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; image[x][y] - image[xx][yy] &gt;= -tol &amp;&amp; image[x][y] - image[xx][yy] &lt;= tol) return false; &#125; return true;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; image[i][j]; isappear[image[i][j]]++; &#125; &#125; int cnt = 0, x = 0, y = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(isappear[image[i][j]] == 1 &amp;&amp; isonly(i, j)) &#123; cnt++; x = j + 1, y = i + 1; &#125; &#125; &#125; if(cnt == 1) cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "): " &lt;&lt; image[y - 1][x - 1]; else if(cnt &gt; 1) cout &lt;&lt; "Not Unique"; else cout &lt;&lt; "Not Exist"; return 0;&#125; 1069 微博转发抽奖Analysis用 map 来表示是否中过奖，只要没有人中奖就输出Keep going...，如果不用vector&lt;string&gt;也可以用char str[][]。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;string&gt; acc;map&lt;string, int&gt; done;int main() &#123; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; string str; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str; acc.push_back(str); &#125; vector&lt;string&gt;::iterator it = acc.begin(); if(s &gt; m) &#123; cout &lt;&lt; "Keep going..."; &#125; else &#123; for(int i = s - 1; i &lt; m; i += n) &#123; str = *(it + i); if(done[str] == 0) &#123; cout &lt;&lt; str &lt;&lt; endl; done[str]++; &#125; else &#123; for(i++; i &lt; m; i++) &#123; str = *(it + i); if(done[str] == 0) &#123; done[str]++; cout &lt;&lt; str &lt;&lt; endl; break; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1070 结绳Analysis这是道考察贪心的题目，明确了思想之后就比较简单，没明确就有点折磨人。从题目的来看，无法看出需要使用每一根绳子，按照样例，容易让人想到的直接选取两个最长的绳子结成一个就好了。实际上，这也是自己一开始想到的贪心思想，认为头两次分别找当前备选绳段中的最长段，结成一段就完事了。事实上需要将每根绳段都用上，并且结绳次数越多，绳段就会被对折的越短。换句话说，需要先对折短绳段，然后再对折长绳段。按照这样的思路，要求每次挑选的绳段尽可能短，这就是这个题的贪心思想。 Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 5;int num[maxn] = &#123;0&#125;;int main() &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; &#125; sort(num, num + n); int res = num[0]; for(int i = 1; i &lt; n; i++) &#123; res = (res + num[i]) / 2; &#125; cout &lt;&lt; res; return 0;&#125; 1071 小赌怡情Analysis这道题的题目比较长，耐心一点，仔细读完，按照题目给定的四种情况的处理方式来写代码，应该就 OK 了，注意输光后（筹码x &lt;= 0），就可以直接退出了。还有一点，题目给的输出中 total 前要有 1 个空格，但是样例是 2 个空格。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int T, K, n1, b, t, n2, remains; scanf("%d %d", &amp;T, &amp;K); remains = T; while(K--) &#123; scanf("%d %d %d %d", &amp;n1, &amp;b, &amp;t, &amp;n2); if(remains &lt;= 0) &#123; printf("Game Over.\n"); break; &#125; if(t &gt; remains) &#123; printf("Not enough tokens. Total = %d.\n", remains); continue; &#125; if((n1 &gt; n2 &amp;&amp; b == 0) || (n1 &lt; n2 &amp;&amp; b == 1)) &#123; remains += t; printf("Win %d! ", t); &#125; else &#123; remains -= t; printf("Lose %d. ", t); &#125; printf("Total = %d.\n", remains); &#125; return 0;&#125; 1072 开学寄语Analysis用set来保存被缴物品信息，用vector&lt;string&gt;来保存含有被缴物品的学生物品信息，重复遍历一次就可以输出被缴物品信息了。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int n, m;const int maxn = 1000 + 5;vector&lt;string&gt; stu[maxn];set&lt;string&gt; ban;int main() &#123; cin &gt;&gt; n &gt;&gt; m; string str, name; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str; ban.insert(str); &#125; int snum = 0, bnum = 0, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; tmp; for(int j = 0; j &lt; tmp; j++) &#123; cin &gt;&gt; str; if(ban.find(str) != ban.end()) &#123; stu[i].push_back(str); bnum++; &#125; &#125; if(stu[i].size() != 0) &#123; cout &lt;&lt; name &lt;&lt; ":"; snum++; for(vector&lt;string&gt;::iterator it = stu[i].begin(); it != stu[i].end(); it++) &#123; cout &lt;&lt; " " &lt;&lt; *it; &#125; cout &lt;&lt; endl; &#125; &#125; cout &lt;&lt; snum &lt;&lt; ' ' &lt;&lt; bnum &lt;&lt; endl; return 0;&#125; 1073 多选题常见计分法Analysis这个题相当坑，很费时间，本质上是跟 1058 一样的题目，但是处理起来要麻烦的多。因为最终要输出选项的错误次数，很直接就会想到逐个比较，所以用 set 来保存正确答案。至于选项的错误次数，就交给一个二维数组来保存。题目所给的每个选择题的选项个数这个信息，基本上无用。接着就是一些细节了： 非正确选项选了算错误，漏选的正确选项也算在错误选项内 题目最后要求输出的错误次数，不是题目的错误次数，而是这个选项的错误次数 由于有()、空格的存在，字符串的空间最好开大一点 自己在第二个细节的地方卡了很久，后来终于反应过来是自己题意理解错了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int maxm = 100 + 5;set&lt;char&gt; answer[maxm];int que[maxm] = &#123;0&#125;, wrong_opt[maxm][6] = &#123;0&#125;;double scores[maxm] = &#123;0.0&#125;;char stu[10005];int main() &#123; int n, m, tmp; char ctmp; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%lf %d %d%*c", &amp;scores[i], &amp;que[i], &amp;tmp); for(int j = 0; j &lt; tmp; j++) &#123; scanf("%c%*c", &amp;ctmp); answer[i].insert(ctmp); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int qnum = 1; double sum = 0.0; fgets(stu, 10005, stdin); for(int j = 0; stu[j] != '\0'; j++) &#123; if(stu[j] == '(') &#123; bool isappear[6] = &#123;false&#125;, flag = true; tmp = stu[++j] - '0'; if(tmp &gt; answer[qnum].size()) flag = false; for(j++; stu[j] != ')'; j++) &#123; if(stu[j] == ' ') continue; else &#123; ctmp = stu[j]; if(answer[qnum].find(ctmp) == answer[qnum].end()) &#123; flag = false; wrong_opt[qnum][ctmp - 'a']++; &#125; isappear[ctmp - 'a'] = true; &#125; &#125; set&lt;char&gt;::iterator it = answer[qnum].begin(); for(; it != answer[qnum].end(); it++) &#123; if(!isappear[*it - 'a']) wrong_opt[qnum][*it - 'a']++; &#125; if(flag &amp;&amp; tmp == answer[qnum].size()) sum += scores[qnum]; else if(flag &amp;&amp; tmp &lt; answer[qnum].size()) sum += (scores[qnum] / 2.0); qnum++; &#125; &#125; printf("%.1lf\n", sum); &#125; int max = wrong_opt[1][0]; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt; 5; j++) &#123; max = max &gt; wrong_opt[i][j] ? max : wrong_opt[i][j]; &#125; &#125; if(max == 0) &#123; printf("Too simple\n"); &#125; else &#123; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt; 5; j++) &#123; if(max == wrong_opt[i][j]) &#123; printf("%d %d-%c\n", max, i, j + 'a'); &#125; &#125; &#125; &#125; return 0;&#125; 1074 宇宙无敌加法器Analysis这个题目，自己的思路比较复杂，需要注意两个特殊点： 结果是 0 时，也要输出 0。 超过 20 位后的计算按十进制进行计算，要判断 20 位之后的计算是否存在进位。 Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 20 + 5;char tab[maxn], num1[maxn], num2[maxn];int ans[maxn] = &#123;0&#125;, digit[10] = &#123;10, 0, 2, 3, 4, 5, 6, 7, 8, 9&#125;;void sreverse(char *str) &#123; int len = strlen(str); for(int i = 0; i &lt; len / 2; i++) &#123; char tmp = str[i]; str[i] = str[len - i - 1]; str[len - i - 1] = tmp; &#125;&#125;int main() &#123; scanf("%s\n%s\n%s", tab, num1, num2); sreverse(num1), sreverse(num2), sreverse(tab); int tmp, carry = 0, i; for(i = 0; num1[i] != '\0' &amp;&amp; num2[i] != '\0'; i++) &#123; tmp = num1[i] + num2[i] - 2 * '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i] = tmp; &#125; while(num1[i] != '\0') &#123; tmp = num1[i] - '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i++] = tmp; &#125; while(num2[i] != '\0') &#123; tmp = num2[i] - '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i++] = tmp; &#125; if(carry != 0) ans[i] = carry; while(ans[i] == 0) i--; if(i &lt; 0) printf("0"); else &#123; for(int j = i; j &gt;= 0; j--) &#123; printf("%d", ans[j]); &#125; &#125; return 0;&#125;/*in:3052706203415out:7201in:221111out:110in:087717out:96in:222222222222222222221111111111111111111100000000000000000001out:100000000000000000000in:222222222222222222221111111111111111111110000000000000000001out:110000000000000000000in:22222222222222222222211111111111111111111110000000000000000001out:410000000000000000000in:2222222222222222222288000000000000000000008800000000000000000000out:17600000000000000000000*/ version 2这个思路参考：1074. 宇宙无敌加法器(20)-PAT乙级真题从这个思路可以获得一点收获： 这类题目，都可以先扩展成最长的字符串后再进行计算 与其分情况判断 carry 是否为 0，不如直接用除法来获得 string 类的初始化用法，以及其运算符的用法 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main() &#123; string s, s1, s2, ans; int carry = 0, flag = 0; cin &gt;&gt; s &gt;&gt; s1 &gt;&gt; s2; ans = s; string ss1(s.length() - s1.length(), '0'); s1 = ss1 + s1; string ss2(s.length() - s2.length(), '0'); s2 = ss2 + s2; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; int mod = s[i] == '0' ? 10 : (s[i] - '0'); ans[i] = (s1[i] + s2[i] - 2 * '0' + carry) % mod + '0'; carry = (s1[i] + s2[i] - 2 * '0' + carry) / mod; &#125; if(carry != 0) ans = '1' + ans; for(int i = 0; i &lt; ans.size(); i++) &#123; if(ans[i] != '0' || flag == 1) &#123; flag = 1; cout &lt;&lt; ans[i]; &#125; &#125; if(flag == 0) cout &lt;&lt; 0; return 0;&#125; 1075 链表元素分类Analysis按照题目意思，从最后输出的结果上来看，特定区间内的结点的相对位置实际上并没有发生改变，就是一开始输入的顺序，所以给每个结点设置一个 order 来记录位置。除此之外，这个 order 还可以用来去除无效结点。然后，用 sort 排序除去无效的结点，再挑出符合条件的结点，输出就行了，注意一下最后一个结点的 next 是 -1。 老实说，这个题用排序做，感觉有点投机取巧，因为压根就没有做题目要求的事情，但依然可以 AC 。 如果一本正经的从链表的角度思考，那么需要遍历链表，然后挑出符合条件的结点，同样需要 3 个循环来完成。挑出结点的步骤，建议重新弄一个结构体数组来完成，同样的，仅仅挑出结点就行了，不需要再修改next和address了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct Node &#123; int address, data, next; int order;&#125; node[maxn], nod[maxn];bool cmp(Node a, Node b) &#123; return a.order &lt; b.order;&#125;int main() &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].order = maxn; &#125; int begin, n, k, address; scanf("%d %d %d", &amp;begin, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int p = begin, count = 0; while(p != -1) &#123; node[p].order = count++; p = node[p].next; &#125; sort(node, node + maxn, cmp); n = count; count = 0; for(int i = 0; i &lt; n; i++) &#123; if(node[i].data &lt; 0) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(0 &lt;= node[i].data &amp;&amp; node[i].data &lt;= k) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(node[i].data &gt; k) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) printf("%05d %d %05d\n", nod[i].address, nod[i].data, nod[i + 1].address); else printf("%05d %d -1\n", nod[i].address, nod[i].data); &#125; return 0;&#125; 1076 Wifi密码Analysis为了促进学生学习，这题也真是难为老师了，哈哈~此题不难，不过需要细心一点，输入的格式是确定好了的。如果每次输入利用字符来做处理，则需要注意回车符\n不要被输入函数获取到了（测试点2就是这样）。可以按照字符串的思路去处理，并且循环进行的次数可能会少一些。这个题发现了一个有点意思的思路：PAT Basic 1076. Wifi密码 (15) (C语言实现)。 Code1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 105int Wifi_Password[4] = &#123;1, 2, 3, 4&#125;;int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d%*c", &amp;N); char Answers[MAXN], temp, flag; for(i = 0; i &lt; 4 * N; i++) &#123; scanf("%c-%c%*c", &amp;temp, &amp;flag); if(flag == 'T') &#123; Answers[count++] = temp; &#125; &#125; for(i = 0; i &lt; count; i++) &#123; printf("%d", Wifi_Password[Answers[i] - 'A']); &#125; putchar('\n'); return 0;&#125; 1077 互评成绩计算Analysis题意很明确，唯一的坑点在四舍五入上。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main() &#123; int n, m, tea_score; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tea_score); int sum = 0, valid = 0, tmp, max = -1, min = m + 1; for(int j = 0; j &lt; n - 1; j++) &#123; scanf("%d", &amp;tmp); if(0 &lt;= tmp &amp;&amp; tmp &lt;= m) &#123; sum += tmp; valid++; if(tmp &gt; max) max = tmp; if(tmp &lt; min) min = tmp; &#125; &#125; double ans = (double)(sum - max - min) / (valid - 2); printf("%d\n", (int)((ans + tea_score) / 2 + 0.5)); &#125; return 0;&#125; 1078 字符串压缩与解压AnalysisC、D 分别对应压缩与解压两种模式，分开进行就可以了，空格与字母的处理方式是一样的。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;char str[2005], mode;int main() &#123; scanf("%c%*c", &amp;mode); fgets(str, 2005, stdin); if(mode == 'C') &#123; for(int i = 0; str[i] != '\0'; i++) &#123; char tmp = str[i]; int count = 1, j; for(j = i + 1; str[j] == tmp; j++) &#123; count++; &#125; if(count == 1) printf("%c", tmp); else printf("%d%c", count, tmp); i = --j; &#125; &#125; else if(mode == 'D') &#123; for(int i = 0; str[i] != '\0'; i++) &#123; int count = 0, j; if(isdigit(str[i])) &#123; count = str[i] - '0'; for(j = i + 1; isdigit(str[j]); j++) &#123; count = count * 10 + str[j] - '0'; &#125; for(int k = 0; k &lt; count; k++) &#123; printf("%c", str[j]); &#125; i = j; &#125; else printf("%c", str[i]); &#125; &#125; return 0;&#125; 1079 延迟的回文数Analysis这个题主要在考察回文数的判断和大数加法，从数组下标 0 开始保存数的低位。这样会好算一点。另外，注意个位数也是回文数。 数组逆置的函数可以借助 C++ 的 reverse 函数完成。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cctype&gt;const int maxn = 1000 + 5;int num[maxn] = &#123;0&#125;, temp[maxn] = &#123;0&#125;;bool ispalindromic(int *a, int count) &#123; if(count == 1) return true; for(int i = 0; i &lt; count / 2; i++) &#123; if(a[i] != a[count - i - 1]) return false; &#125; return true;&#125;void shownum(int *a, int count) &#123; for(int i = count - 1; i &gt;= 0; i--) &#123; printf("%d", a[i]); &#125;&#125;void arr_reverse(int *a, int *b, int count) &#123; for(int i = 0; i &lt; count; i++) &#123; a[i] = b[count - i - 1]; &#125;&#125;int main() &#123; char c; int count = 0; while((c = getchar()) != '\n') &#123; temp[count++] = c - '0'; &#125; arr_reverse(num, temp, count); int times = 0; while(times++ &lt; 10) &#123; if(ispalindromic(num, count)) &#123; shownum(num, count); printf(" is a palindromic number.\n"); break; &#125; else &#123; shownum(num, count); printf(" + "); shownum(temp, count); int carry = 0, tmp; for(int i = 0; i &lt; count; i++) &#123; tmp = num[i]; num[i] = (tmp + temp[i] + carry) % 10; carry = (tmp + temp[i] + carry) / 10; &#125; if(carry) num[count++] = carry; printf(" = "); shownum(num, count); printf("\n"); arr_reverse(temp, num, count); &#125; &#125; if(times &gt;= 10) printf("Not found in 10 iterations.\n"); return 0;&#125; 1080 MOOC期终成绩Analysis需要处理的数据太多，直接构造一个新的结构体。开始读入数据之前，全部默认为没有考试的状态（全部置为 -1，输出的时候就可以直接输出了），然后读入数据，计算最终成绩，第一顺序是成绩递减，第二顺序是学号递增。因为每次考试的成绩是分别给出的，所以为了在处理下一次考试的数据时找到对应的学生，所以需要用 map 建立学生学号与下标的对应关系。另外，计算最终成绩需要四舍五入。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string name; int gp, gmt, gf, g;&#125; stu[maxn];map&lt;string, int&gt; name2num;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; stu[i].g = stu[i].gf = stu[i].gmt = stu[i].gp = -1; &#125;&#125;bool cmp(student a, student b) &#123; if(a.g != b.g) return a.g &gt; b.g; else return a.name &lt; b.name;&#125;int main() &#123; init(); int p, m, n, count = 0, tmp; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n; string str; for(int i = 0; i &lt; p; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; stu[count].name = str; stu[count].gp = tmp; name2num[str] = count++; &#125; map&lt;string, int&gt;::iterator it; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; it = name2num.find(str); if(it == name2num.end()) &#123; stu[count].gmt = tmp; stu[count].name = str; name2num[str] = count++; &#125; else stu[it-&gt;second].gmt = tmp; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; it = name2num.find(str); if(it == name2num.end()) &#123; stu[count].gf = tmp; stu[count].name = str; name2num[str] = count++; &#125; else stu[it-&gt;second].gf = tmp; &#125; int a, b; for(int i = 0; i &lt; count; i++) &#123; if(stu[i].gp &lt; 200) continue; else &#123; a = stu[i].gmt, b = stu[i].gf; if(a &lt;= b) stu[i].g = b; else stu[i].g = (int)((a * 0.4 + b * 0.6) + 0.5); &#125; &#125; sort(stu, stu + count, cmp); for(int i = 0; i &lt; count; i++) &#123; if(stu[i].g &gt;= 60) &#123; cout &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].gp &lt;&lt; ' ' &lt;&lt; stu[i].gmt \ &lt;&lt; ' ' &lt;&lt; stu[i].gf &lt;&lt; ' ' &lt;&lt; stu[i].g &lt;&lt; endl; &#125; &#125; return 0;&#125; 1081 检查密码Analysis此题的难点在于情况的分类，无论输入的“密码”是否合法，首先判断长度是否不小于6，紧接着，判断是否有非法字符，继而确认有无数字，最后确认有无字母。注意可能会输入带空格的字符串（测试点2）。因为gets函数无法在用了，可以使用fgets来读入一行，或者 C++ 的getline。如果用fgets，要注意它会把最后的回车也读到字符串内，所以长度要减一。 Codeversion 1这是原来写的版本。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define MaxLength 85int Validity_Check(char *password);char Result[5][100] = &#123; "Your password is tai duan le.", "Your password is tai luan le.", "Your password needs shu zi.", "Your password needs zi mu.", "Your password is wan mei.",&#125;;int main(int argc, char const *argv[]) &#123; int flag, N; char Password[MaxLength]; scanf("%d%*c", &amp;N); while(N--) &#123; gets(Password); //notice the space flag = Validity_Check(Password); puts(Result[flag]); &#125; return 0;&#125;int Validity_Check(char *password) &#123; int ret = 4, len = strlen(password), i; int num_flag, alpha_flag, invalid_flag; num_flag = alpha_flag = invalid_flag = 0; if(len &gt;= 6) &#123; for(i = 0; i &lt; len; i++) &#123; if( isdigit(password[i]) ) &#123; num_flag = 1; &#125; else if( isalpha(password[i]) ) &#123; alpha_flag = 1; &#125; else if(password[i] == '.') &#123; continue; &#125; else &#123; invalid_flag = 1; &#125; &#125; if(invalid_flag) &#123; ret = 1; &#125; else if(!num_flag) &#123; ret = 2; &#125; else if(!alpha_flag) &#123; ret = 3; &#125; &#125; else &#123; ret = 0; &#125; return ret;&#125; version 2这是后来写的版本。1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char str[85];int n;int main() &#123; scanf("%d%*c", &amp;n); while(n--) &#123; fgets(str, 85, stdin); if(strlen(str) - 1 &lt; 6) &#123; printf("Your password is tai duan le.\n"); continue; &#125; bool flag1, flag2, flag3; flag1 = flag2 = flag3 = false; for(int i = 0; str[i] != '\0'; i++) &#123; if(isalpha(str[i])) flag2 = true; else if(isdigit(str[i])) flag3 = true; else if(str[i] == '.' || str[i] == '\n') continue; else flag1 = true; &#125; if(flag1) printf("Your password is tai luan le.\n"); else if(flag2 &amp;&amp; !flag3) printf("Your password needs shu zi.\n"); else if(!flag2 &amp;&amp; flag3) printf("Your password needs zi mu.\n"); else printf("Your password is wan mei.\n"); &#125; return 0;&#125; 1082 射击比赛Analysis因为最终要输出的是编号，所以需要保存编号信息，这样的话，不如用一个新的结构体来保存需要的信息。另外，在计算离靶心的距离的时候，不需要四舍五入。 其实这个题，即便没有用 sqrt 将真正的距离算出来，也是可以 AC 的。如果设置非常相近的两组解（大概只有小数部分有几位差），可能就能卡掉很多代码了。 Code1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;struct athlete&#123; char id[5]; int x, y, dis; &#125; ath[maxn];bool cmp(athlete a, athlete b) &#123; return a.dis &lt; b.dis;&#125;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", ath[i].id, &amp;ath[i].x, &amp;ath[i].y); ath[i].dis = sqrt(ath[i].x * ath[i].x + ath[i].y * ath[i].y); &#125; sort(ath, ath + n, cmp); printf("%s %s", ath[0].id, ath[n - 1].id); return 0;&#125; 1083 是否存在相等的差Analysis这个题比较简单，借着这个题，想了想 map 能不能从大到小排列，查了下资料还真的可以。需要注意的点就是，只有重复的数才输出，换句话说，就是出现次数大于等于 2。不过，这个题，其实直接开一个很大的数组就可以了。 Codeuse map1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct cmp &#123; bool operator()(const int k1, const int k2) &#123; return k1 &gt; k2; &#125;&#125;;map&lt;int, int, cmp&gt; mp;int main() &#123; int n, tmp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;tmp); mp[abs(tmp - i)]++; &#125; for(map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123; if(it-&gt;second &gt;= 2) printf("%d %d\n", it-&gt;first, it-&gt;second); &#125; return 0;&#125; use array1234567891011121314151617#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;int n, appear[maxn] = &#123;0&#125;, tmp;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; appear[abs(tmp - i)]++; &#125; for(int i = 9999; i &gt;= 0; i--) &#123; if(appear[i] &gt; 1) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; appear[i] &lt;&lt; endl; &#125; return 0;&#125; 1084 外观数列Analysis按照题目给的过程模拟，字符串数组一定要开大一点。 Code1234567891011121314151617181920212223#include &lt;cstdio&gt;char str1[100005], str2[100005];int n;int main() &#123; scanf("%s %d", str1, &amp;n); for(int i = 1; i &lt; n; i++) &#123; int len = 0; for(int j = 0; str1[j] != '\0'; j++) &#123; str2[len++] = str1[j]; int count = 1, k; for(k = j + 1; str1[k] == str1[j]; k++) count++; str2[len++] = count + '0'; j = --k; &#125; str2[len] = '\0'; for(int j = 0; j &lt;= len; j++) &#123; str1[j] = str2[j]; &#125; &#125; printf("%s", str1); return 0;&#125; 1085 PAT单位排行Analysis很常规的排序题，用 map 建立学校名字与数组下标的对应关系，每读入一个分数就统计一个考生。计算学校排名时，要注意先按照学校总分排序后，再进行排名。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 100000 + 5;struct school&#123; string name; int sum_score, A, B, T, rank, men;&#125; sch[maxn];map&lt;string, int&gt; sch_name2num;bool cmp(school a, school b) &#123; if(a.sum_score != b.sum_score) return a.sum_score &gt; b.sum_score; else if(a.men != b.men) return a.men &lt; b.men; else return a.name &lt; b.name;&#125;void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; sch[i].sum_score = sch[i].A = sch[i].B = sch[i].T = sch[i].men = 0; sch[i].rank = maxn; &#125;&#125;int main() &#123; Init(); int n, score, count = 0; cin &gt;&gt; n; string stu_name, sch_name; while(n--) &#123; cin &gt;&gt; stu_name &gt;&gt; score &gt;&gt; sch_name; for(int i = 0; i &lt; sch_name.length(); i++) &#123; sch_name[i] = tolower(sch_name[i]); &#125; if(sch_name2num.find(sch_name) == sch_name2num.end()) &#123; sch[count].name = sch_name; sch_name2num[sch_name] = count++; &#125; if(stu_name[0] == 'B') &#123; sch[sch_name2num[sch_name]].B += score; &#125; else if(stu_name[0] == 'A') &#123; sch[sch_name2num[sch_name]].A += score; &#125; else if(stu_name[0] == 'T') &#123; sch[sch_name2num[sch_name]].T += score; &#125; sch[sch_name2num[sch_name]].men++; &#125; for(int i = 0; i &lt; count; i++) &#123; sch[i].sum_score = (int)(sch[i].B / 1.5 + sch[i].A + sch[i].T * 1.5); &#125; sort(sch, sch + count, cmp); sch[0].rank = 1; cout &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; sch[0].rank &lt;&lt; ' ' &lt;&lt; sch[0].name &lt;&lt; ' ' &lt;&lt; sch[0].sum_score &lt;&lt; ' ' &lt;&lt; sch[0].men &lt;&lt; endl; for(int i = 1; i &lt; count; i++) &#123; if(sch[i].sum_score == sch[i - 1].sum_score) sch[i].rank = sch[i - 1].rank; else sch[i].rank = i + 1; cout &lt;&lt; sch[i].rank &lt;&lt; ' ' &lt;&lt; sch[i].name &lt;&lt; ' ' &lt;&lt; sch[i].sum_score &lt;&lt; ' ' &lt;&lt; sch[i].men &lt;&lt; endl; &#125; return 0;&#125; 1086 就不告诉你Analysis水题一道，注意$700$，不要倒着输出为$007$了。 Codeversion 1123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int A, B, Product, temp, digit, result = 0; scanf("%d %d", &amp;A, &amp;B); Product = A * B; temp = Product; while(temp) &#123; digit = temp % 10; temp /= 10; result = result * 10 + digit; &#125; printf("%d\n", result); return 0;&#125; version 21234567891011121314151617#include &lt;cstdio&gt;char ans[10];int main() &#123; int A, B, C, len = 0; scanf("%d %d", &amp;A, &amp;B); C = A * B; do&#123; ans[len++] = C % 10 + '0'; C /= 10; &#125; while(C != 0); ans[len] = '\0'; char *p = ans; while(*p == '0') p++; puts(p); return 0;&#125; 1087 有多少不同的值Analysis出现过的数，只统计一次。 Codeversion 1123456789101112131415#include &lt;cstdio&gt;const int maxn = 20000 + 5;int appear[maxn] = &#123;0&#125;;int main() &#123; int N, n, ans = 0; scanf("%d", &amp;N); for(n = 1; n &lt;= N; n++) &#123; appear[n / 2 + n / 3 + n / 5]++; &#125; for(n = 0; n &lt;= maxn; n++) &#123; if(appear[n]) ans++; &#125; printf("%d", ans); return 0;&#125; version 2如果从数学的角度思考，随着 N 的增大，计算结果也会依次增大，所以一开始的值是最小的，这样就可以不用散列，只用变量记录当前计算的值，如果比之前的小，就算是不同的值了，如下：123456789101112#include &lt;cstdio&gt;int main() &#123; int N, n, ans = 0, m = -1; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; n = i / 2 + i / 3 + i / 5; if(n &gt; m) ans++; m = n; &#125; printf("%d", ans); return 0;&#125; 1088 三人行Analysis这个题有点像鸡兔同笼的问题，实际上就是多元方程求可能解。唯一的坑点在于，丙的值可能是个小数。另外，要以甲的最大解为准，可以从大到小进行枚举。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cmath&gt;int m, x, y, a, b, tmp, i, j;double c, k;void print(double t) &#123; if(m &lt; t) printf(" Cong"); else if(m == t) printf(" Ping"); else printf(" Gai");&#125;int main() &#123; scanf("%d %d %d", &amp;m, &amp;x, &amp;y); bool flag = false; for(i = 10; i &lt;= 99; i++) &#123; tmp = i; j = tmp % 10 * 10 + tmp / 10; k = abs(i - j) * 1.0 / x; if(j == y * k) &#123; flag = true; a = i, b = j, c = k; &#125; &#125; if(flag) &#123; printf("%d", a); print(a), print(b), print(c); &#125; else printf("No Solution"); return 0;&#125; 1089 狼人杀-简单版Analysis这个题想了很久，没什么思路，感觉很怪，后来看了一下别人的代码，发现是一道模拟题（其实跟上一题的模拟思路很像）。做法就是按照序号从小到大不断的假设 2 个人是狼人，判断是否符合条件。如果符合，那就输出这个解后直接退出程序；如果没找到，就输出 No Solution 。参考：1089 狼人杀-简单版 (20 分)PAT 1089 狼人杀-简单版（20 分）- 乙级 PS：这个题的难点不在于问题的复杂性，在于对实际问题的抽象能力。 Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100 + 5;int fact[maxn] = &#123;0&#125;, iswolf[maxn], lie[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;fact[i]); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; iswolf[i] = 1; &#125; iswolf[i] = iswolf[j] = -1; int index = 0; for(int k = 1; k &lt;= n; k++) &#123; if(fact[k] * iswolf[abs(fact[k])] &lt; 0) lie[index++] = k; &#125; if(index == 2 &amp;&amp; iswolf[lie[0]] + iswolf[lie[1]] == 0) &#123; printf("%d %d\n", i, j); return 0; &#125; &#125; &#125; printf("No Solution"); return 0;&#125; 1090 危险品装箱Analysis这个题如果不用 STL 的话，确实有点麻烦，一旦用了 STL 就很简单了。先将危险品信息统计好，然后在遍历货物清单上的每一件物品，判断货物清单上是否有不相容的物品即可。考虑到题目可能会给重复的数据，所以用 SET 来处理数据就可以自动去重了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int maxn = 100000 + 5;set&lt;int&gt; pairs[maxn], stuff;int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; int tmp_a, tmp_b; cin &gt;&gt; tmp_a &gt;&gt; tmp_b; pairs[tmp_a].insert(tmp_b), pairs[tmp_b].insert(tmp_a); &#125; while(m--) &#123; cin &gt;&gt; k; stuff.clear(); for(int i = 0; i &lt; k; i++) &#123; int tmp; cin &gt;&gt; tmp; stuff.insert(tmp); &#125; bool flag = false; for(set&lt;int&gt;::iterator it1 = stuff.begin(); it1 != stuff.end(); it1++) &#123; int tmp1 = *it1; if(pairs[tmp1].size() == 0) continue; else &#123; for(set&lt;int&gt;::iterator it2 = pairs[tmp1].begin(); it2 != pairs[tmp1].end(); it2++) &#123; int tmp2 = *it2; if(stuff.find(tmp2) != stuff.end()) &#123; flag = true; break; &#125; &#125; &#125; if(flag) break; &#125; if(flag) cout &lt;&lt; "No\n"; else cout &lt;&lt; "Yes\n"; &#125; return 0;&#125; 1091 N-自守数Analysis注意读题，判断一个数是否自守，就是用这个数的最后几位构成的数字与原数字比较是否相等即可，而“最后几位”就是原数字的位数了，能得到这个细节（题目中的这些细节，真是叫人又爱又恨）后，这个题目就很简单了。要得到最后几位构成的数字，直接用这个数对应的整数取余即可（比如，8 对应 10，88 对应 100，依次类推）。本来以为，使用int可能会有测试点不过，结果没有，没设置大数的测试点么？嘿嘿，逃过一劫~ Codeversion 112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool Judge_Automorphic(int test_number, int original_number);int main(int argc, char const *argv[]) &#123; int M, N, K, each_item; bool flag; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;K); flag = false; for(N = 1; N &lt; 10; N++) &#123; each_item = N * K * K; if( Judge_Automorphic(each_item, K) ) &#123; flag = true; break; &#125; &#125; if(flag) &#123; printf("%d %d\n", N, each_item); &#125; else &#123; puts("No"); &#125; &#125; return 0;&#125;bool Judge_Automorphic(int test_number, int original_number) &#123; bool flag = false; int mask = 1, temp; temp = original_number; while(temp) &#123; temp /= 10; mask *= 10; &#125; temp = test_number; temp %= mask; if(temp == original_number) &#123; flag = true; &#125; return flag;&#125; version 212345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; int n, k, m, digit, tmp; scanf("%d", &amp;m); while(m--) &#123; scanf("%d", &amp;k); tmp = k, digit = 1; while(tmp != 0) &#123; tmp /= 10; digit *= 10; &#125; bool flag = false; for(n = 1; n &lt; 10; n++) &#123; tmp = n * k * k; if(tmp % digit == k) &#123; flag = true; break; &#125; &#125; if(flag) printf("%d %d\n", n, tmp); else printf("No\n"); &#125; return 0;&#125; 1092 最好吃的月饼Analysis统计所有月饼的销量，找到最大值输出即可。 Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int maxn = 1000 + 5;int sales[maxn] = &#123;0&#125;;int main() &#123; int n, m, tmp; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;tmp); sales[j] += tmp; &#125; &#125; int max = sales[1]; for(int i = 2; i &lt;= n; i++) &#123; if(max &lt; sales[i]) max = sales[i]; &#125; printf("%d\n", max); bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(max == sales[i]) &#123; if(flag) &#123; printf("%d", i); flag = false; &#125; else printf(" %d", i); &#125; &#125; return 0;&#125; 1093 字符串A+BAnalysis分别遍历两个字符串，每输出一个字符，就将这个字符标记为已出现，下次就不在输出了。 Code123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;bool isappear[256] = &#123;false&#125;;int main() &#123; string a, b; getline(cin, a); getline(cin, b); for(int i = 0; i &lt; a.length(); i++) &#123; if(!isappear[a[i]]) &#123; cout &lt;&lt; a[i]; isappear[a[i]] = true; &#125; &#125; for(int i = 0; i &lt; b.length(); i++) &#123; if(!isappear[b[i]]) &#123; cout &lt;&lt; b[i]; isappear[b[i]] = true; &#125; &#125; return 0;&#125; 1094 谷歌的招聘Analysis唯一要注意的点就是，最终要输出的不是数，而是字符串。 Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;bool isprime(int a) &#123; if(a &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; return true;&#125;char num[1005];int main() &#123; int l, k; scanf("%d %d%*c", &amp;l, &amp;k); scanf("%s", num); bool flag = false; for(int i = 0; i + k &lt;= l; i++) &#123; int number = 0; for(int j = i; j &lt; i + k; j++) &#123; number = number * 10 + num[j] - '0'; &#125; if(isprime(number)) &#123; for(int j = i; j &lt; i + k; j++) &#123; printf("%c", num[j]); &#125; flag = true; break; &#125; &#125; if(!flag) printf("404"); return 0;&#125; 1095 解码PAT准考证Analysis这个题给的信息很多，按照不同的统计要求，分别利用对应的信息来处理，本质上还是排序题，所以处理的方法基本上是差不多的，只是有些地方要注意一下： 测试点 3 是卡时间的，要用 unordered_map，并且排序函数要使用引用的写法，这样更快。 指令 3，每次不同考场的人数统计完成后要重置为 0，以免又有指令 3 查询导致叠加。 指令 2 存在总分为 0 的情况，所以不要用分数来当作判断条件，这也是自己犯的错误。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn = 10000 +5;struct student &#123; char level; string id, exam_room, exam_date; int score;&#125; stu[maxn];struct examroom &#123; string roomid; int men;&#125; examro[maxn];bool cmp1(student &amp;a, student &amp;b) &#123; if(a.level != b.level) return a.level &lt; b.level; else if(a.score != b.score) return a.score &gt; b.score; else return a.id &lt; b.id;&#125;bool cmp2(examroom &amp;a, examroom &amp;b) &#123; if(a.men != b.men) return a.men &gt; b.men; else return a.roomid &lt; b.roomid;&#125;void Init_examro() &#123; for(int i = 0; i &lt; maxn; i++) &#123; examro[i].roomid.resize(10); examro[i].men = 0; &#125;&#125;int main() &#123; int n, m, mode; string md, tmp; tmp.resize(15); scanf("%d %d%*c", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; scanf("%c%s %d%*c", &amp;stu[i].level, tmp.c_str(), &amp;stu[i].score); stu[i].exam_room = tmp.substr(0, 3); stu[i].exam_date = tmp.substr(3, 6); stu[i].id = tmp; &#125; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; mode &gt;&gt; md; bool flag = false; printf("Case %d: %d %s\n", i, mode, md.c_str()); if(mode == 1) &#123; sort(stu, stu + n, cmp1); for(int i = 0; i &lt; n; i++) &#123; if(md[0] == stu[i].level) &#123; printf("%c%s %d\n", stu[i].level, stu[i].id.c_str(), stu[i].score); flag = true; &#125; &#125; &#125; else if(mode == 2) &#123; int sum = 0, men = 0; for(int i = 0; i &lt; n; i++) &#123; if(md == stu[i].exam_room) &#123; sum += stu[i].score; men++; &#125; &#125; if(men) &#123; printf("%d %d\n", men, sum); flag = true; &#125; &#125; else if(mode == 3) &#123; int count = 0; unordered_map&lt;string, int&gt; room2num; Init_examro(); for(int i = 0; i &lt; n; i++) &#123; if(md == stu[i].exam_date) &#123; if(room2num.find(stu[i].exam_room) == room2num.end()) &#123; room2num[stu[i].exam_room] = count++; examro[room2num[stu[i].exam_room]].roomid = stu[i].exam_room; &#125; examro[room2num[stu[i].exam_room]].men++; &#125; &#125; sort(examro, examro + count, cmp2); for(int i = 0; i &lt; count; i++) &#123; printf("%s %d\n", examro[i].roomid.c_str(), examro[i].men); flag = true; &#125; &#125; if(!flag) cout &lt;&lt; "NA" &lt;&lt; endl; &#125; return 0;&#125; 1096 大美数Analysis这个题刚开始读的时候，感觉有点怪，仔细一想，15 分的题，应该不会设置一些难过的测试点。事实也是这样，直接用暴力枚举就可以了。注意： N 是除数，4 个因数之和是被除数。 1 与 N 本身也是因数。 Code多写判断语句和缩短循环条件是为了减少执行次数，加快运行时间，就本题而言，实际提升了 1 ms😂。1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;const int maxn = 10000 + 5;int factor[maxn] = &#123;1&#125;; int main() &#123; int k, n; scanf("%d", &amp;k); while(k--) &#123; int cnt = 1; scanf("%d", &amp;n); for(int i = 2; i &lt;= n; i++) &#123; if(n % i == 0) factor[cnt++] = i; &#125; if(cnt &lt; 4) printf("No\n"); else &#123; bool flag = false; for(int i = 0; i &lt; cnt - 3; i++) &#123; for(int j = i + 1; j &lt; cnt - 2; j++) &#123; for(int k = j + 1; k &lt; cnt - 1; k++) &#123; for(int l = k + 1; l &lt; cnt; l++) &#123; if((factor[i] + factor[j] + factor[k] + factor[l]) % n == 0) &#123; printf("Yes\n"); flag = true; goto out; &#125; &#125; &#125; &#125; &#125; out: if(!flag) printf("No\n"); &#125; &#125; return 0;&#125; 1097 矩阵行平移Analysis考察二维数组的概念和一维数组元素后移的操作，注意要先后移在改值。 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;int matrix[105][105] = &#123;0&#125;, n, k, x;;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;x); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; int s = 1; for(int i = 1; i &lt;= n; i+=2) &#123; for(int j = n - s; j &gt;= 1; j--) &#123; matrix[i][j + s] = matrix[i][j]; &#125; for(int j = 1; j &lt;= s; j++) &#123; matrix[i][j] = x; &#125; if(s == k) s = 1; else s++; &#125; for(int i = 1; i &lt;= n; i++) &#123; int sum = 0; for(int j = 1; j &lt;= n; j++) &#123; sum += matrix[j][i]; &#125; printf("%d", sum); if(i != n) printf(" "); &#125; return 0;&#125; 1098 岩洞施工Analysis这个题自己一开始想歪了，总是把注意力集中在相同横坐标的点的纵坐标之差得大于 1，才能放入管道。然后又考虑不同横坐标下的点的纵坐标之差要达到多少才合适。实际上，只需要考虑顶部点的最低点与底部点的最高点的纵坐标之差就可以了。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;int main() &#123; int n, tmp, up_low = 1005, down_high = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); if(up_low &gt; tmp) up_low = tmp; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); if(down_high &lt; tmp) down_high = tmp; &#125; tmp = up_low - down_high; if(tmp &gt; 0) printf("Yes %d", tmp); else printf("No %d", 1 - tmp); return 0;&#125;/*in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 2 3 3 2 1 2 3out:Yes 1in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 4 3 2 1 2 3out:No 1in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 5 3 2 1 2 3out:No 2in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 6 3 2 1 2 3out:No 3*/ 1099 性感素数Analysis注意：性感素数是一对一对存在的，测试点 3 就给的是不符合条件的 n，但是与 n-6 构成了一对性感素数。那么，按照要求输出的就是大于 n 的最小性感素数。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; int n; scanf("%d", &amp;n); if(isprime(n) &amp;&amp; isprime(n - 6)) printf("Yes\n%d", n - 6); else if(isprime(n) &amp;&amp; isprime(n + 6)) printf("Yes\n%d", n); else &#123; while(n++) &#123; if(isprime(n) &amp;&amp; isprime(n - 6) || isprime(n) &amp;&amp; isprime(n + 6)) break; &#125; printf("No\n%d", n); &#125; return 0;&#125; 1100 校庆Analysis利用 set 存储校友信息，读入参加校庆的人员信息后，在 set 中查找，是否是校友，统计校友个数。因为最终要输出的结果是最年长的人，所以需要按照出生日期进行分类排序（校友与非校友），默认将校友放在前面，输出会方便一些。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;set&lt;string&gt; xiaoyou;struct guest&#123; string id, birth; int flag;&#125; g[maxn];bool cmp(guest a, guest b) &#123; if(a.flag != b.flag) return a.flag &gt; b.flag; else return a.birth &lt; b.birth;&#125;int main() &#123; string tmp; int n, m; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; xiaoyou.insert(tmp); &#125; int count = 0; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; g[i].id; g[i].birth = g[i].id.substr(6, 8); if(xiaoyou.find(g[i].id) != xiaoyou.end()) &#123; count++; g[i].flag = 1; &#125; &#125; sort(g, g + m, cmp); cout &lt;&lt; count &lt;&lt; endl &lt;&lt; g[0].id; return 0;&#125; 1101 B是A的多少倍Analysis这个题差点想歪了从字符串的角度做，实际上直接从数的角度做更简单，因为位数 d 是给定的。 Code123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int a, d, tmp, digit = 0, b; scanf("%d %d", &amp;a, &amp;d); tmp = a; while(tmp != 0) &#123; tmp /= 10; digit++; &#125; tmp = a % (int)pow(10, d); b = tmp * pow(10, digit - d) + a / pow(10, d); printf("%.2lf", b * 1.0 / a);&#125; 1102 教超冠军卷Analysis结构体存储信息，找出符合条件的最大值即可。 Code12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;const int maxn = 10000 + 5;struct test&#123; char id[9]; int price, amount, sum;&#125; te[maxn]; int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", te[i].id, &amp;te[i].price, &amp;te[i].amount); te[i].sum = te[i].price * te[i].amount; &#125; int max_amount = te[0].amount, max_sum = te[0].sum, index1 = 0, index2 = 0; for(int i = 1; i &lt; n; i++) &#123; if(max_amount &lt; te[i].amount) &#123; max_amount = te[i].amount; index1 = i; &#125; if(max_sum &lt; te[i].sum) &#123; max_sum = te[i].sum; index2 = i; &#125; &#125; printf("%s %d\n%s %d\n", te[index1].id, max_amount, te[index2].id, max_sum); return 0;&#125; 1103 缘分数Analysis按照题目要求模拟即可，注意 2 个地方： 多数相乘的过程中可能会溢出，所以直接使用long long比较好。 sqrt的返回值强转后会丢掉小数，只取整数部分，所以需要判断平方相等是否成立。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef long long LL;int main() &#123; LL m, n, a, b, c, tmp; scanf("%lld %lld", &amp;m, &amp;n); bool flag = false; for(; m &lt;= n; m++) &#123; a = m; tmp = a * a * a - (a - 1) * (a - 1) * (a - 1); c = sqrt(tmp); if(c * c != tmp) continue; else &#123; for(b = 1; b &lt; c; b++) &#123; if(c == b * b + (b - 1) * (b - 1)) &#123; flag = true; printf("%lld %lld\n", a, b); &#125; &#125; &#125; &#125; if(!flag) printf("No Solution\n"); return 0;&#125; 1104 天长地久Analysis这个题需要一定的数学能力，不然拿不到满分，注意以下几点： 最终输出的结果需要按照 n 或 A 的递增顺序输出，所以需要排序，使用 set 是最方便的。 直接暴力枚举会超时，需要排除掉一些特殊情况，分 3 种情况考虑： A 的个位数是 1-8，此时 $gcd(m, n)$ 就只可能是 1，不满足条件。 A 的个位数是 9，以 1009 为例，其各位数字之和为 10，加 1 后是 1010，各位数字之和为 2，相差 8，而 $gcd(11, 2$ 就是 1 了。实际上可以发现，$m = n + 9 - 1 = n + 8$，从而可以得到，$gcd(m, n) = gcd(n + 8, n) = gcd(n, (n + 8) \% n) = gcd(n, 8)$，所以，这种情况下，公约数只可能取 1、2、4、8，也不满足条件。 A 的十位数和个位数都是 9，那么按照上面的思路就有 $m = n + 9 + 9 - 1$（当然也可以理解成 $n = m - 9 - 9 + 1$，因为再多的 9 也只有 1 个进位，这样解释可能更易于理解），从而 $gcd(m, n) = gcd(n, 17)$，公约数可能取 1、17，17 是满足条件的。现在就知道了，A 的尾数必须至少有 2 位 9 才满足条件，那就直接从尾数为 99 的数开始遍历，每次加 100 即可。 这个题需要动点脑筋才能拿满分，算是有点难但又不是太难的那种题，最主要的是怎么把思路往数学上想。另外，素数的判定，数位求和，公约数求法，这些小考点也要会才行，还有 set 和 pair 的用法也得会，不然再来排序的话，可能又会产生其他的问题。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;set&lt;pair&lt;int, int&gt;&gt; res;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;int digitsum(int a) &#123; int res = 0; while(a != 0) &#123; res = res + a % 10; a /= 10; &#125; return res;&#125;int main() &#123; int N, n, k, m, tmp, g; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; printf("Case %d\n", i); scanf("%d %d", &amp;k, &amp;m); tmp = pow(10, k); bool flag = false; for(int j = 99 + pow(10, k - 1); j &lt; tmp; j += 100) &#123; if(digitsum(j) == m) &#123; n = digitsum(j + 1); g = gcd(m, n); if(g &gt; 2 &amp;&amp; isprime(g)) &#123; res.insert(make_pair(n, j)); flag = true; &#125; &#125; &#125; if(!flag) printf("No Solution\n"); else &#123; set&lt;pair&lt;int, int&gt;&gt;::iterator it = res.begin(); for(; it != res.end(); it++) &#123; printf("%d %d\n", it-&gt;first, it-&gt;second); &#125; res.clear(); &#125; &#125; return 0;&#125; 1105 链表合并Analysis题目保证没有空链表，但是没保证一定没有无效结点，所以直接将需要处理的链表放到新链表里面，并记录好有效结点的个数。虽然题目要求短的链表进行逆序，但实际上，也不是非得逆序，用栈存一下，再输出就行。按照长链表输出 2 个，短链表输出 1 个的过程交替输出，此时要考虑 3 种情况： 输出长链表要求输出的第一个结点，这个结点可能是长链表的最后一个结点，也可能不是。 输出长链表要求输出的第二个结点，这个结点可能是要输出的最后一个结点，也可能不是。如果不是，那么这个结点的 next 需要输出短链表下一个要输出的结点的地址。 输出短链表的结点，这个结点可能是短链表的最后一个结点但不是要输出结点的最后一个结点。如果不是，那就意味着长链表还有结点没有输出完，i 就要减 1。 PS：下面这段代码的很多地方的判断条件其实可以换成其他的，比如i != n - 1可以换成lrev.size() != 0。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int maxn = 100000 + 5;struct node &#123; int address, data, next;&#125; L[maxn], L1[maxn], L2[maxn];stack&lt;node&gt; lrev;int newlist(int head, node *l) &#123; int p = head, count = 0; while(p != -1) &#123; l[p].address = p, l[p].data = L[p].data, l[p].next = L[p].next; p = L[p].next; count++; &#125; return count;&#125;void printlist(int head1, int head2, int n1, int n2, node *l1, node *l2) &#123; int p = head1, n = n1 + n2, count = 0; while(p != -1) &#123; lrev.push(l1[p]); p = l1[p].next; &#125; p = head2; node tmp; for(int i = 0; i &lt; n; i++) &#123; if(count == 0) &#123; if(l2[p].next != -1) printf("%05d %d %05d\n", l2[p].address, l2[p].data, l2[p].next); else printf("%05d %d -1\n", l2[p].address, l2[p].data); p = l2[p].next; count++; &#125; else if(count == 1) &#123; if(i == n - 1) printf("%05d %d -1\n", l2[p].address, l2[p].data); else &#123; if(!lrev.empty()) &#123; tmp = lrev.top(); printf("%05d %d %05d\n", l2[p].address, l2[p].data, tmp.address); &#125; else &#123; printf("%05d %d %05d\n", l2[p].address, l2[p].data, l2[p].next); &#125; &#125; p = l2[p].next; count++; &#125; else if(count == 2) &#123; if(!lrev.empty()) &#123; tmp = lrev.top(); lrev.pop(); if(i != n - 1) printf("%05d %d %05d\n", tmp.address, tmp.data, l2[p].address); else printf("%05d %d -1\n", tmp.address, tmp.data); &#125; else i--; count = 0; &#125; &#125;&#125;int main() &#123; int p, head1, head2, n, n1, n2; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;p); scanf("%d %d", &amp;L[p].data, &amp;L[p].next); L[p].address = p; &#125; n1 = newlist(head1, L1); n2 = newlist(head2, L2); if(n1 &lt; n2) printlist(head1, head2, n1, n2, L1, L2); else printlist(head2, head1, n2, n1, L2, L1); return 0;&#125;/*in:00100 01000 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1out:01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1in:01000 00100 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1out:01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1in:00100 01000 602233 2 3489100100 6 -134891 3 1008601000 1 0223300033 5 -110086 4 00033out:01000 1 0223302233 2 0010000100 6 3489134891 3 1008610086 4 0003300033 5 -1*/ 1106 2019数列Analysis这个题有点像斐波那契数列，不过比较简单。另外，写代码的时候没看到“题外话”（神经太大条了），总结的时候看到了，勾起了好奇心，试着用反证法尝试了一下，未得解。百度了一下，发现是这样的规律：以前 20 项为例，最终得到的数列是： 2 0 1 9 2 2 4 7 5 8 4 4 1 7 6 8 2 3 9 2从奇偶性的角度来看就是： 偶 偶 奇 奇 偶 偶 偶 奇 奇 偶 偶 偶 奇 奇 偶 偶 偶 奇 奇 偶就可以发现，奇偶性的排列是按照“偶偶偶奇奇”的顺序不断重复的，而对比 2018，1 这个数字的两侧都是偶数，所以它就不可能出现在这个数列中，但这好像并不是在证明，而是在验证😂。 Code123456789101112131415#include &lt;cstdio&gt;const int maxn = 1000 + 5;int arr[maxn] = &#123;0, 2, 0, 1, 9&#125;;int main() &#123; int n, tmp; scanf("%d", &amp;n); for(int i = 5; i &lt;= n;i++) &#123; tmp = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4]; arr[i] = tmp % 10; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", arr[i]); &#125; return 0;&#125; 1107 老鼠爱大米Analysis这个题没什么说的，可以读入所有数据后在输出，也可以边读入边输出，只要测试的结果与样例一致就行，可以使用 PTA 自带的自定义测试功能进行测试。 Code123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int n, m, tmp, max2 = -1; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; int max1 = -1; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;tmp); if(max1 &lt; tmp) max1 = tmp; &#125; printf("%d", max1); if(i != n - 1) printf(" "); if(max1 &gt; max2) max2 = max1; &#125; printf("\n%d", max2); return 0;&#125; 1108 String复读机Analysis这个题也比较直观，想着是不是能把代码写的简单一点，结果发现，好像这样就已经很简单、直观、易于理解了。 好吧，确实可以改短一点，不过，version 1 确实是最直观且易于理解的。 Codeversion 11234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;char str[10005];int times[6] = &#123;0&#125;;int main() &#123; scanf("%s", str); for(int i = 0; str[i] != '\0'; i++) &#123; if(str[i] == 'S') times[0]++; else if(str[i] == 't') times[1]++; else if(str[i] == 'r') times[2]++; else if(str[i] == 'i') times[3]++; else if(str[i] == 'n') times[4]++; else if(str[i] == 'g') times[5]++; &#125; while(times[0] || times[1] || times[2] || times[3] || times[4] || times[5]) &#123; if(times[0]) &#123; printf("S"); times[0]--; &#125; if(times[1]) &#123; printf("t"); times[1]--; &#125; if(times[2]) &#123; printf("r"); times[2]--; &#125; if(times[3]) &#123; printf("i"); times[3]--; &#125; if(times[4]) &#123; printf("n"); times[4]--; &#125; if(times[5]) &#123; printf("g"); times[5]--; &#125; &#125; return 0;&#125; version 2这个题其实与 1043 一样，所以可以按照同样的思路改写一下，如下：1234567891011121314151617181920212223#include &lt;cstdio&gt;char str[10005];int times[128] = &#123;0&#125;;char String[10] = "String";int main() &#123; scanf("%s", str); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['S'] || times['t'] || times['r'] || times['i'] || times['n'] || times['g']) &#123; for(p = String; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1109 擅长CAnalysis这个题有点麻烦，写完之后，感觉用 3 维数组好像比 2 维数组麻烦。整个模拟过程不是很难，难的是保持题目要求的格式，要注意以下几个地方： 除了大写英文字符外，其他的字符都是“分隔符”。 多余字符可能出现在开头（测试点 1）。 多余字符可能出现在结尾。 多余字符可能出现在中间。 多余字符可能会连续出现多个。 PS：这个题的输出太长了，自己编测试样例都不是很好编，不得不吐槽下。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cctype&gt;char words[26][7][7], str[10000];int word_index[10000] = &#123;0&#125;;int main() &#123; for(int i = 0; i &lt; 26; i++) &#123; for(int j = 0; j &lt; 7; j++) &#123; scanf("%s", words[i][j]); &#125; &#125; getchar(); fgets(str, 10000, stdin); int count = 0; for(int i = 0; str[i] != '\0'; i++) &#123; if(isupper(str[i])) &#123; word_index[count++] = str[i] - 'A'; &#125; else &#123; word_index[count++] = -1; while(!isupper(str[i]) &amp;&amp; str[i] != '\0') i++; i--; &#125; &#125; int i, j, k; while(word_index[i] == -1) i++; for(; i &lt; count; i++) &#123; for(j = 0; j &lt; 7; j++) &#123; printf("%s", words[word_index[i]][j]); for(k = i + 1; word_index[k] != -1; k++) &#123; printf(" %s", words[word_index[k]][j]); &#125; printf("\n"); &#125; i = k; if(i &lt; count - 1) printf("\n"); &#125; return 0;&#125; 1110 区块反转Analysis这个题跟B1025是一样的题，唯一的差别就是输出要求不太相同，大致思路基本一致。注意以下几个地方： 可能会有无效结点，读入数据后，需要先遍历链表，排序剔除掉无效结点，并保存有效结点的个数。 输出末尾结点数小于 k 的块时，如果要输出链表最后一个结点，其 next 需要输出第 (i - 1) * k 个结点的地址（也就是下一个要输出的块的第一个结点的地址）。 输出结点数等于 k 且不是最后一块时，如果要输出当前块的最后一个结点，其 next 需要输出第 (i - 1) * k 个结点的地址（也就是下一个要输出的块的第一个结点的地址）。 输出结点数等于 k 且是最后一块时，如果输出的是最后一个结点，其 next 需要输出 -1。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct node &#123; int addr, data, next; int order;&#125; L[maxn];void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; L[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main() &#123; Init(); int head, n, k, tmp; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); scanf("%d %d", &amp;L[tmp].data, &amp;L[tmp].next); L[tmp].addr = tmp; &#125; int p = head, count = 0; while(p != -1) &#123; L[p].order = count++; p = L[p].next; &#125; sort(L, L + maxn, cmp); n = count; for(int i = n / k; i &gt;= 0; i--) &#123; int j = i * k; if(i == n / k) &#123; for(; j &lt; n; j++) &#123; if(j == n - 1) printf("%05d %d %05d\n", L[j].addr, L[j].data, L[(i - 1) * k].addr); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; else &#123; if(i != 0) &#123; for(; j &lt; (i + 1) * k; j++) &#123; if(j == (i + 1) * k - 1) printf("%05d %d %05d\n", L[j].addr, L[j].data, L[(i - 1) * k].addr); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; else &#123; for(; j &lt; k; j++) &#123; if(j == k - 1) printf("%05d %d -1\n", L[j].addr, L[j].data); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; &#125; &#125; return 0;&#125; Summary算上今天，一共大概花了大约 80 个小时的时间，把原来做过的和没做过的题都做了一遍。感觉乙级的题目还是比较基础的，有些题目设置的卡点，其实没有太多的必要？不过，尽可能的减少自己写的程序的 bug 也是应该的。 有时候一道题有思路，但却没拿到满分是件很痛苦的事情。不过，感觉花时间 debug 带来的提升，可能会比花时间学习别人的思路带来的提升更大。当然，成就感也会更大，这就好比玩游戏刷副本被人带和自己单刷的感觉吧。 接下来该做的事情，就是再回过头看看这些题目蕴含的思想了。还有就是，有没有什么更快捷、方便、简单且易于理解的其他解法了。 总之，要做且能做事情还有很多...]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA基础编程题目集]]></title>
    <url>%2F2019%2F02%2F20%2FPTA%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Intro此Blog用来记录自己的”PTA基础编程题目集之旅(受虐)”。每道题目包含输入(输出)样例、输入(输出)说明、思路分析及得到AC的源码。所有AC代码已上传到GitHub上，点击PTA-Basical-Programming-problem-set即可获取。 Programming7-1 厘米换算英尺英寸如果已知英制长度的英尺$foot$和英寸$inch$的值，那么对应的米是$(foot+inch/12)×0.3048$。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。 Input Specification输入在一行中给出1个正整数，单位是厘米。 Output Specification在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。 Sample Input &amp; Sample Output Input 1:170 Output 1:5 6 Analysis这道题目乍一看挺简单的，其实也有点绕(题目有点迷😒)。首先，要明确题目需要我们得到的结果是：给出的厘米对应换算为英尺、英寸的长度，也就是说，存在这样一个关系：$170CM≈5foot6inch$(题目只要求整数)，就好比是$103=20×5+3$，而我们要的值就是这个5和3。明白这个之后，就会发现，单纯的将$1foot=12inch$这个条按题目给的方程带入计算是得不出结果的，那么可以先求大的单位($foot$)的值，那么小单位($inch$)的值就是剩下的差了。接下来，还得找$foot$和$CM$的数值关系(这里也可以直接百度)，依据$(foot+inch/12)×0.3048$，这个式子计算结果的单位是$M$，而左边$(foot+inch/12)$的单位是$foot$，所以就可以知道：$1foot=30.48CM$，这样我们就可以直接算出正确的$foot$值了。 Code1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int foot,inch,centimeters; scanf("%d", &amp;centimeters); // centimeters = 170; foot = centimeters / 30.48; inch = centimeters / 2.54 - 12*foot; printf("%d %d\n", foot, inch); return 0;&#125; 7-2 然后是几点有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。 Input Specification输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。 Output Specification输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。 Sample Input &amp; Sample Output Input 1:1120 110 Output 1:1310 Analysis简单题，求出总的分钟值，然后求出小时的值，在按照题目要求输出即可。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int start_time,waste_time; scanf("%d %d", &amp;start_time, &amp;waste_time); // start_time = 1120; waste_time = 110; int hours,minutes; minutes = start_time/100*60 + start_time%100 + waste_time; hours = minutes/60; minutes -= hours*60; printf("%d\n", hours*100+minutes); return 0;&#125; 7-3 逆序的三位数程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。 Input Specification每个测试是一个3位的正整数。 Output Specification输出按位逆序的数。 Sample Input &amp; Sample Output Input 1:123 Output 1:321 Analysis这道题目很简单，考察数位拆分，在题目告诉已知3位数的情况下，可以直接进行数位拆分(一般题目都不会给输入数字的位数，而只给范围)；并且题目也已经给出了要注意的地方：700逆序后不能是007。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; scanf("%d", &amp;n); // n=700; int units,tens,hundred; units=n%10; tens=n/10%10; hundred=n/100; printf("%d\n", units*100+tens*10+hundred); return 0;&#125; 7-4 BCD解密BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。 Input Specification输入在一行中给出一个$[0, 153]$范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。 Output Specification输出对应的十进制数。 Sample Input &amp; Sample Output Input 1:18 Output 1:12 Analysis简单题，题目给的提示很明显，单独出去十进制数的个位和十位后，直接组合计算即可得到。 Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int BCD; scanf("%d", &amp;BCD); // BCD=18; int units,tens; units=BCD%16; tens=BCD/16; printf("%d\n", tens*10+units); return 0;&#125; 7-5 表格输出本题要求编写程序，按照规定格式输出表格。 Input Specification本题目没有输入。 Output Specification要求严格按照给出的格式输出下列表格：123456789------------------------------------Province Area(km2) Pop.(10K)------------------------------------Anhui 139600.00 6461.00Beijing 16410.54 1180.70Chongqing 82400.00 3144.23Shanghai 6340.50 1360.26Zhejiang 101800.00 4894.00------------------------------------ Analysis送分题，直接原样输出即可。 Code1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf("------------------------------------\n"); printf("Province Area(km2) Pop.(10K)\n"); printf("------------------------------------\n"); printf("Anhui 139600.00 6461.00\n"); printf("Beijing 16410.54 1180.70\n"); printf("Chongqing 82400.00 3144.23\n"); printf("Shanghai 6340.50 1360.26\n"); printf("Zhejiang 101800.00 4894.00\n"); printf("------------------------------------\n"); return 0;&#125; 7-6 混合类型数据格式化输入本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。 Input Specification输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。 Output Specification在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。 Sample Input &amp; Sample Output Input:2.12 88 c 4.7 Output:c 88 2.12 4.70 Analysis按题目要求输入输出即可。 Code12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float a1,a2; int b; char c; scanf("%f %d %c %f", &amp;a1, &amp;b, &amp;c, &amp;a2); printf("%c %d %.2f %.2f\n", c, b, a1, a2); return 0;&#125; 7-7 12-24小时制编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间。 Input Specification输入在一行中给出带有中间的:符号（半角的冒号）的24小时制的时间，如12:34表示12点34分。当小时或分钟数小于10时，均没有前导的零，如5:6表示5点零6分。提示：在scanf的格式字符串中加入:，让scanf来处理这个冒号。 Output Specification在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串AM或表示下午的字符串PM。如5:6 PM表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的12:00就是12小时制的12:0 PM；而0点被认为是第二天的时间，所以是0:0 AM。 Sample Input &amp; Sample Output Input:21:11 Output:9:11 PM Analysis根据输出格式进行输出即可，注意中午12点被认为是PM；输入只需注意:即可。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int hours,minutes; scanf("%d:%d", &amp;hours, &amp;minutes); // hours = 21, minutes = 11; if(hours == 12)&#123; printf("%d:%d PM\n", hours, minutes); &#125;else if(hours &lt; 12)&#123; printf("%d:%d AM\n", hours, minutes); &#125;else&#123; printf("%d:%d PM\n", hours-12, minutes); &#125; return 0;&#125; 7-8 超速判断模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示Speeding，否则显示OK。 Input Specification输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。 Output Specification在一行中输出测速仪显示结果，格式为：Speed: V - S，其中V是车速，S是Speeding、或者是OK。 Sample Input &amp; Sample Output Input 1:40 Output 1:Speed: 40 - OK Input 2:75 Output 2:Speed: 75 - Speeding Analysis根据题目要求直接输出即可。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int speed; scanf("%d", &amp;speed); // speed=75; if(speed &gt; 60)&#123; printf("Speed: %d - Speeding\n", speed); &#125;else&#123; printf("Speed: %d - OK\n", speed); &#125; return 0;&#125; 7-9 用天平找小球三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。 Input Specification输入在一行中给出3个正整数，顺序对应球A、B、C的重量。 Output Specification在一行中输出唯一的那个不一样的球。 Sample Input &amp; Sample Output Input:1 1 2 Output:C Analysis根据题目条件，如果要输出唯一的那个不一样的球，其实就只有三种情况，直接输出就好。 Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,C; scanf("%d %d %d", &amp;A, &amp;B, &amp;C); // A=1, B=1, C=2; if(A != B &amp;&amp; A != C) printf("A\n"); if(B != A &amp;&amp; B != C) printf("B\n"); if(C != A &amp;&amp; C != B) printf("C\n"); return 0;&#125; 7-10 计算工资某公司员工的工资计算方法如下：一周内工作时间不超过40小时，按正常工作时间计酬；超出40小时的工作时间部分，按正常工作时间报酬的1.5倍计酬。员工按进公司时间分为新职工和老职工，进公司不少于5年的员工为老职工，5年以下的为新职工。新职工的正常工资为30元/小时，老职工的正常工资为50元/小时。请按该计酬方式计算员工的工资。 Input Specification输入在一行中给出2个正整数，分别为某员工入职年数和周工作时间，其间以空格分隔。 Output Specification在一行输出该员工的周薪，精确到小数点后2位。 Sample Input &amp; Sample Output Input 1:5 40 Output 1:2000.00 Input 2:3 50 Output 2:1650.00 Analysis根据题目条件，针对不同情况计算工资即可，实质为分段函数求值。 Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int years,hours; float wage; scanf("%d %d", &amp;years, &amp;hours); // years=3, hours=50; if(years &gt;= 5)&#123; if(hours &gt; 40)&#123; wage = 50*40 + 1.5*50*(hours - 40); &#125;else&#123; wage = 50*hours; &#125; &#125;else&#123; if(hours &gt; 40)&#123; wage = 30*40 + 1.5*30*(hours - 40); &#125;else&#123; wage = 30*hours; &#125; &#125; printf("%.2f\n", wage); return 0;&#125; 7-11 分段计算居民水费为鼓励居民节约用水，自来水公司采取按用水量阶梯式计价的办法，居民应交水费$y$（元）与月用水量$x$（吨）相关：当$x$不超过15吨时，$y=4x/3$；超过后，$y=2.5x−17.5$。请编写程序实现水费的计算。 Input Specification输入在一行中给出非负实数$x$。 Output Specification在一行输出应交的水费，精确到小数点后2位。 Sample Input &amp; Sample Output Input 1:12 Output 1:16.00 Input 2:16 Output 2:22.50 Analysis根据题目条件，针对不同情况计算水费即可，实质为分段函数求值。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int x; scanf("%d", &amp;x); // x=16; float water_fee; if(x &lt;= 15)&#123; water_fee = 4.0*x/3; &#125;else&#123; water_fee = 2.5*x - 17.5; &#125; printf("%.2f\n", water_fee); return 0;&#125; 7-12 两个数的简单计算器本题要求编写一个简单计算器程序，可根据输入的运算符，对2个整数进行加、减、乘、除或求余运算。题目保证输入和输出均不超过整型范围。 Input Specification输入在一行中依次输入操作数1、运算符、操作数2，其间以1个空格分隔。操作数的数据类型为整型，且保证除法和求余的分母非零。 Output Specification当运算符为+、-、*、/、%时，在一行输出相应的运算结果。若输入是非法符号（即除了加、减、乘、除和求余五种运算符以外的其他符号）则输出ERROR。 Sample Input &amp; Sample output Input 1:-7 / 2 Output 1:-3 Input 2:3 &amp; 6 Output 2:ERROR Analysis针对不同的情况使用switch语句分别处理即可。 Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int a, b; char c; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); switch(c)&#123; case '+': printf("%d\n", a + b);break; case '-': printf("%d\n", a - b);break; case '*': printf("%d\n", a * b);break; case '/': printf("%d\n", a / b);break; case '%': printf("%d\n", a % b);break; default : printf("ERROR\n"); &#125; return 0;&#125; 7-13 日K蜡烛图股票价格涨跌趋势，常用蜡烛图技术中的K线图来表示，分为按日的日K线、按周的周K线、按月的月K线等。以日K线为例，每天股票价格从开盘到收盘走完一天，对应一根蜡烛小图，要表示四个价格：开盘价格Open（早上刚刚开始开盘买卖成交的第1笔价格）、收盘价格Close（下午收盘时最后一笔成交的价格）、中间的最高价High和最低价Low。 如果Close&lt;Open，表示为BW-Solid（即“实心蓝白蜡烛”）；如果Close&gt;Open，表示为R-Hollow（即“空心红蜡烛”）；如果Open等于Close，则为R-Cross（即“十字红蜡烛”）。如果Low比Open和Close低，称为Lower Shadow（即“有下影线”），如果High比Open和Close高，称为Upper Shadow（即“有上影线”）。请编程序，根据给定的四个价格组合，判断当日的蜡烛是一根什么样的蜡烛。 Input Specification输入在一行中给出4个正实数，分别对应Open、High、Low、Close，其间以空格分隔。 Output Specification在一行中输出日K蜡烛的类型。如果有上、下影线，则在类型后加上with 影线类型。如果两种影线都有，则输出with Lower Shadow and Upper Shadow。 Sample Input &amp; Sample output Input 1:5.110 5.250 5.100 5.105 Output 1:BW-Solid with Lower Shadow and Upper Shadow Input 2:5.110 5.110 5.110 5.110 Output 2:R-Cross Input 3:5.110 5.125 5.112 5.126 Output 3:R-Hollow Analysis先判断图形类型，在判断是否包含影线；按照下面的代码的思路，需要将既有下影线又有上影线的情况放在第一位进行判断。 Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float open,high,low,close; scanf("%f %f %f %f", &amp;open, &amp;high, &amp;low, &amp;close); if(close &lt; open)&#123; printf("BW-Solid"); &#125;else if(close == open)&#123; printf("R-Cross"); &#125;else&#123; printf("R-Hollow"); &#125; if(low &lt; open &amp;&amp; low &lt; close &amp;&amp; high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Lower Shadow and Upper Shadow\n"); &#125;else if(high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Upper Shadow\n"); &#125;else if(low &lt; open &amp;&amp; low &lt; close)&#123; printf(" with Lower Shadow\n"); &#125;else&#123; printf("\n"); &#125; return 0;&#125; 7-14 求整数段和给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 Input Specification输入在一行中给出2个整数A和B，其中$−100≤A≤B≤100$，其间以空格分隔。 Output Specification首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum=X的格式输出全部数字的和X。 Sample Input &amp; Sample output Input:-3 8 Output: -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 Analysis考察格式输出和求和，输出时注意格式即可，最好将数字和换行分开输出。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,i,sum; scanf("%d %d", &amp;A, &amp;B); // A=1, B=5; for(i=0, sum=0; A&lt;=B; A++, i++) &#123; if(i%5 == 0 &amp;&amp; i != 0) printf("\n"); printf("%5d", A); sum+=A; &#125; printf("\nSum = %d\n", sum); return 0;&#125; 7-15 计算圆周率根据下面关系式，求圆周率的值，直到最后一项的值小于给定阈值。${\pi\over2}=1+{1\over3}+{2!\over{3×5}}+{3!\over{3×5×7}}+{\cdots}+{n!\over{3×5×7×{\cdots}×(2×n+1)}}$ Input Specification输入在一行中给出小于1的阈值。 Output Specification在一行中输出满足阈值条件的近似圆周率，输出到小数点后6位。 Sample Input &amp; Sample output Input:0.01 Output:3.132157 Analysis本题比较直观，但需要细心一点。先分析一下给出的关系式的规律，左边常量，我们只看右边就行；假设右边项数是从1开始的，那么$a_1=1$，$a_2={1\over3}$，$a_3={2!\over3×5}$，…，把$a_1$和$a_2$换个写法就是$a_1={0!\over1}$、$a_2={1!\over{1×3}}$，这下就可以看出规律了，与后面的通项公式是一致的。如果首项的分子从0开始，那么就无法通过循环自动完成阶乘的计算了（或者单独写一个阶乘函数，这样就能从0开始取值了），所以我们直接从$a_1$开始计算，让$\pi$的初始值就为1.0；输出结果时，别忘记了要乘上2倍。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float pi=1.0,denominator=3.0,member=1.0,each_item=0.0,i=2.0; float threshold; scanf("%f", &amp;threshold); // threshold=0.01; do&#123; each_item = member/denominator; pi+=each_item; member*=i; denominator*=(2*i+1); i++; &#125;while(each_item &gt; threshold); printf("%.6f\n", 2*pi); return 0;&#125; 7-16 求符合给定条件的整数集给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。 Input Specification输入在一行中给出A。 Output Specification输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。 Sample Input &amp; Sample output Input:2 Output:234 235 243 245 253 254324 325 342 345 352 354423 425 432 435 452 453523 524 532 534 542 543 Analysis按照题目的意思，将需要输出的三位数，分别输出即可；也可以直接输出一个百位数，但是那样需要计算，会稍微麻烦一点。按照下面的代码，当不同位的数字存在相同的时候，就用continue;语句跳出本次循环，i==j的判断也可以在第三层循环内做，即：改为k==j || k==i || i==j，但当i==j的时候就会运行多次判断了。 Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,i,j,k,count; scanf("%d", &amp;A);// A=2; count=0; for(i=A; i&lt;A+4; i++) &#123; for(j=A; j&lt;A+4; j++)&#123; if(i == j) continue; else&#123; for(k=A; k&lt;A+4; k++) &#123; if(k==j || k==i) continue; else&#123; printf("%d%d%d", i, j, k); count++; if(count%6 == 0) printf("\n"); else printf(" "); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 7-17 爬动的蠕虫一条蠕虫长1寸，在一口深为N寸的井的底部。已知蠕虫每1分钟可以向上爬U寸，但必须休息1分钟才能接着往上爬。在休息的过程中，蠕虫又下滑了D寸。就这样，上爬和下滑重复进行。请问，蠕虫需要多长时间才能爬出井？这里要求不足1分钟按1分钟计，并且假定只要在某次上爬过程中蠕虫的头部到达了井的顶部，那么蠕虫就完成任务了。初始时，蠕虫是趴在井底的（即高度为0）。 Input Specification输入在一行中顺序给出3个正整数N、U、D，其中D&lt;U，N不超过100。 Output Specification在一行中输出蠕虫爬出井的时间，以分钟为单位。 Sample Input &amp; Sample output Input:12 3 1 Output:11 Analysis找规律，先要明确”蚯蚓”整个爬行的过程，在第一分钟会爬行U寸，第二分钟会下滑D寸，第二分钟完后，蚯蚓一共的爬行距离就是U-D，第三分钟的时候，蚯蚓爬行U寸，总距离是2*U-D，第四分钟就是2*U-2*D…。可以发现，U和D的系数之和就是当前的时刻，找到这个规律之后就好办了。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,U,D; scanf("%d%d%d", &amp;N, &amp;U, &amp;D); // N=12, U=3, D=1; int i,j,times; for(i=1, j=0; N&lt;=100; i++, j++) &#123; if(i*U - j*D &gt;= N)&#123; times = i+j; break; &#125; &#125; printf("%d\n", times); return 0;&#125; 7-18 二分法求多项式单根二分法求函数根的原理为：如果连续函数$f(x)$在区间$[a,b]$的两个端点取值异号，即$f(a)f(b)&lt;0$，则它在这个区间内至少存在1个根$r$，即$f(r)=0$。二分法的步骤为：检查区间长度，如果小于给定阈值，则停止，输出区间中点$(a+b)/2$；否则如果$f(a)f(b)&lt;0$，则计算中点的值$f((a+b)/2)$；如果$f((a+b)/2)$正好为0，则$(a+b)/2$就是要求的根；否则如果$f((a+b)/2)$与$f(a)$同号，则说明根在区间$[(a+b)/2,b]$，令$a=(a+b)/2$，重复循环；如果$f((a+b)/2)$与$f(b)$同号，则说明根在区间$[a,(a+b)/2]$，令$b=(a+b)/2$，重复循环。本题目要求编写程序，计算给定3阶多项式$f(x)=a_3x^3+a_2x^2+a_1x+a_0$在给定区间$[a,b]$内的根。 Input Specification输入在第1行中顺序给出多项式的4个系数$a_3$、$a_2$、$a_1$、$a_0$，在第2行中顺序给出区间端点$a$和$b$。题目保证多项式在给定区间内存在唯一单根。 Output Specification在一行中输出该多项式在该区间内的根，精确到小数点后2位。 Sample Input &amp; Sample Output Input:3 -1 -3 1-0.5 0.5 Output:0.33 Analysis二分法求多项式单根，所依据的原理其实是函数的零点性质：函数零点两边的函数值是异号的，所以零点两边函数值的乘积小于0。明白这个原理之后，我们按照题目给的算法进行计算即可；既然题目已经给出了函数式，可以直接封装成一个专门求值的函数，函数的系数就用全局变量来保存即可，这样代码的主体就很清晰；f(left)和f(right)这两个函数值为0的情况是单独的，并不能用if-else组成对立关系，注意题目对精度的要求是小数点后2位，所以左端点和右端点的差值要大于0.01，若没有这个条件，提交时会超时。 Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;float a3,a2,a1,a0;float Cal_polynomial(float n);int main(int argc, char const *argv[])&#123; float left,right,mid; scanf("%f %f %f %f %f %f", &amp;a3, &amp;a2, &amp;a1, &amp;a0, &amp;left, &amp;right); while(Cal_polynomial(left) * Cal_polynomial(right) &lt;= 0 &amp;&amp; (right-left) &gt; 0.01) &#123; if(Cal_polynomial(left) == 0)&#123; printf("%.2f\n", left); return 0; &#125; if(Cal_polynomial(right) == 0)&#123; printf("%.2f\n", right); return 0; &#125; mid=(left+right)/2; if(Cal_polynomial(left) * Cal_polynomial(mid) &gt; 0)&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; printf("%.2f\n", (right+left)/2); return 0;&#125;float Cal_polynomial(float n)&#123; float ret=0.0; ret = a3*n*n*n + a2*n*n + a1*n + a0; return ret;&#125; 7-19 支票面额一个采购员去银行兑换一张y元f分的支票，结果出纳员错给了f元y分。采购员用去了n分之后才发觉有错，于是清点了余额尚有2y元2f分，问该支票面额是多少？ Input Specification输入在一行中给出小于100的正整数n。 Output Specification在一行中按格式y.f输出该支票的原始面额。如果无解，则输出No Solution。 Sample Input &amp; Sample Output Input 1:23 Output 1:25.51 Input 2:22 Output 2:No Solution Analysis本题乍一看挺懵逼的😓，其实是道数学题。多读几遍题目，可以列出方程：100*f+y-n=200*y+2*f(这里的元、分应该就是RMB中的单位了)，化简得：98*f-199*y=n，依题意，n&lt;100且n&gt;0，说明98*f-199*y&gt;0，这里需要放缩一下，即：98*f-199*y ≈ 100*f-200*y = f-2*y &gt; 0，就是f&gt;2*y了，而f在本题中的单位是分，所以0&lt;f&lt;100(能想到的唯一解释…)，所以就得到：0&lt;f&lt;100, 0&lt;y&lt;50，这就是循环的条件。有点坑爹~ Code12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int y,f,n,flag=0; scanf("%d", &amp;n); // n=23; for(y=0; y&lt;50; y++) &#123; for(f=0; f&lt;100; f++) &#123; if(98*f - 199*y == n)&#123; printf("%d.%d\n", y, f); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-20 打印九九口诀表下面是一个完整的下三角九九口诀表：1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 本题要求对任意给定的一位正整数N，输出从11到NN的部分口诀表。 Input Specification输入在一行中给出一个正整数N（1≤N≤9）。 Output Specification输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。 Sample Input &amp; Sample output Input:4 Output:12341*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 Analysis分析一下，九九乘法表的组成，两个值和这两个值的乘积，从这里，应该可以想到双重循环；在仔细观察一下样例，组后的项中的因子等于输入样例的N值的，所以可以推断，因子的值是小于等于N的；另外，还可以发现，第二个因子的值是小于等于第一个因子的值的；按照以上的思路，在注意一下输出格式，就可以拿下这道题了，注意输出的格式，换行可以放在第二层循环内执行，条件改为j == i即可。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,i,j; scanf("%d", &amp;N); // N=4; for(i=1; i&lt;=N; i++) &#123; for(j=1; j&lt;=i; j++)&#123; printf("%d*%d=%-4d", j, i, i*j); &#125; if(j-1 == i)&#123; printf("\n"); &#125; &#125; return 0;&#125; 7-21 求特殊方程的正整数解本题要求对任意给定的正整数N，求方程$X^2​+Y^2=N$的全部正整数解。 Input Specification输入在一行中给出正整数N（≤10000） Output Specification输出方程$X^2+Y^2=N$的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出No Solution。 Sample Input &amp; Sample Output Input 1:884 Output 1:10 2820 22 Input 2:11 Output 2:No Solution Analysis此题不难，看题目形式也是道数学题，大致分析一下，N = X^2+Y^2 &gt;= 2*x*y，既有2*x*y &lt;= N &lt;= 10000，化简得xy &lt;= 5000，又知N的最大值是10000，开方是100，而X和Y的平方之和小于等于N，所以X和Y都不大于100；依据题目的要求，需要按照X递增的顺序进行输出，所以直接以Y为最大值，X从最小开始取值就可以了（也有其他做法）。之所以写break;的原因是：在这道题目中，当X和N确定后，Y也是确定的，同理Y和N确定后，X也是确定的了。 Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N; scanf("%d", &amp;N);// N=884; int X,Y,flag=0; for(Y=100; Y&gt;0; Y--) &#123; for(X=1; X&lt;=Y; X++) &#123; if(X*X + Y*Y == N &amp;&amp; (X*Y) &lt;= 5000)&#123; printf("%d %d\n", X, Y); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-22 龟兔赛跑乌龟与兔子进行赛跑，跑场是一个矩型跑道，跑道边可以随地进行休息。乌龟每分钟可以前进3米，兔子每分钟前进9米；兔子嫌乌龟跑得慢，觉得肯定能跑赢乌龟，于是，每跑10分钟回头看一下乌龟，若发现自己超过乌龟，就在路边休息，每次休息30分钟，否则继续跑10分钟；而乌龟非常努力，一直跑，不休息。假定乌龟与兔子在同一起点同一时刻开始起跑，请问T分钟后乌龟和兔子谁跑得快？ Input Specification输入在一行中给出比赛时间T（分钟）。 Output Specification在一行中输出比赛的结果：乌龟赢输出@_@，兔子赢输出^_^，平局则输出-_-；后跟1空格，再输出胜利者跑完的距离。 Sample Input &amp; Sample output Input:242 Output:@_@ 726 Analysis这道题的难点在如何计算兔子在T时间内跑过的距离。先看乌龟，乌龟在T时间内跑过的距离比较简单，因为乌龟是不会休息的，所以其距离就是其速度和T的乘积；而兔子会休息，并且是每隔10分钟确认比乌龟快后休息，所以，需要在每个以10分钟为时间间隔的时间点进行判断，与之而来的另外一个问题就是兔子不是休息10分钟，而是休息30分钟，所以，还需要一个表示兔子仍然在休息的标志位，这个标志位会在乌龟前进，兔子休息时，自动减少。当减少到0时，兔子会再次确认是否超过乌龟。输出结果时，注意平局的时候也要输出跑完的距离；并且时间要从0时刻开始，即时间区间为$[0,T-1]$，若区间为$[1,T]$，尽管区间长度时一致的，在30分钟时，兔子的距离就是81，乌龟的距离就是90了，但实际上应该是相等的，即平局。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int rabbit_dis=0,turtle_dis=0,rabbit_spd=9,turtle_spd=3,T; scanf("%d", &amp;T); // T=30; int i,rabbit_on=1,break_times=0; for(i=0; i&lt;T; i++) &#123; if(i%10 == 0)&#123; if(rabbit_dis &gt; turtle_dis &amp;&amp; break_times == 0)&#123; rabbit_on=0; break_times=30; &#125;else&#123; rabbit_on=1; &#125; &#125; if(rabbit_on &amp;&amp; break_times == 0)&#123; rabbit_dis+=rabbit_spd; &#125; turtle_dis+=turtle_spd; if(break_times)&#123; break_times--; &#125; &#125; if(turtle_dis &gt; rabbit_dis)&#123; printf("@_@ %d\n", turtle_dis); &#125;else if(turtle_dis == rabbit_dis)&#123; printf("-_- %d\n", turtle_dis); &#125;else&#123; printf("^_^ %d\n", rabbit_dis); &#125; return 0;&#125; 7-23 币值转换输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 Input Specification输入在一行中给出一个不超过9位的非负整数。 Output Specification在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 Sample Input &amp; Sample output Input 1:813227345 Output 1:iYbQdBcScWhQdBeSf Input 2:6900 Output 2:gQjB Analysis这道题有点难😑，借鉴了一下ccDLIyy的思路，并修改了其中一些代码。如果本题只是将输入的数字的每一位拆分出来的话，就十分简单，但是还需要按照中文习惯输出这些数字的读法，就比较麻烦了。首先，需要一个数组来单独存放每一位数，因为，如果不这样，就无法对中文习惯进行判断了(即当前位上的数字非0，前一位或者后一位为0的情况下，此时的读法)；按照这个思路，不妨直接用数组建立起数字和字母的映射关系，这样后面调用也方便一些(不得不说，这个想法很高明也很省事)；另外，在写代码之前，先大概分析一下平常我们都这些数字的读法：23108是读作二万三千一百零八，813227345是读作八亿一千三百二十二万七千三百四十五，从这里，可以看出，万是在数字位数大于等于5的时候才会输出，而亿是在数字位数大于等于9的时候才会输出，在每四位内，进行输出的格式字符都是十、百和千，所以，需要根据位数进行不同情况的判断。另外，在下面的代码中对于100000001这种情况输出的结果是一亿零零零一，对于10这种情况输出的结果是一十。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;char num2letter[11]="abcdefghij";char units[4]="QBS";void exchange(int num[], int n);int main(int argc, char const *argv[])&#123; char number[10]; scanf("%s", number); int i,len=strlen(number); int num[9]=&#123;0&#125;; for(i=0; i&lt;len; i++)&#123; num[i]=number[i] - '0'; &#125; if(len &lt;= 4)&#123; exchange(num, len-1); &#125;else if(len &lt;= 8)&#123; exchange(num, len-5); printf("W"); exchange(num+len-4, 3); &#125;else&#123; printf("%cY", num2letter[num[0]]); exchange(num+1, 3); if(num[1]!=0 &amp;&amp; num[2]!=0 &amp;&amp; num[3]!=0 &amp;&amp; num[4]!=0)&#123; printf("W"); &#125; if(num[len-4] == 0)&#123; printf("%c", num2letter[0]); &#125; exchange(num+5, 3); &#125; return 0;&#125;void exchange(int num[], int n)&#123; int index = 0; while(num[index] == 0)&#123; index++; &#125; if(num[index-1] == 0 &amp;&amp; index != 0)&#123; printf("%c", num2letter[0]); &#125; while(index &lt;= n) &#123; if(num[index] != 0 &amp;&amp; index &lt;= n)&#123; if(index != n)&#123; printf("%c%c", num2letter[num[index]], units[4-n-1+index]); &#125;else&#123; printf("%c", num2letter[num[index]]); &#125; &#125;else if(num[index] == 0 &amp;&amp; num[index+1] != 0 &amp;&amp; index &lt;= n-1)&#123; printf("%c", num2letter[0]); &#125; index++; &#125;&#125; 7-24 约分最简分式分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 Input Specification输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。提示：在scanf的格式字符串中加入/，让scanf来处理这个斜杠。 Output Specification在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如5/6表示6分之5。 Sample Input &amp; Sample output Input:66/120 Output:11/20 Analysis这道题比较简单，只要知道分子/分母约分到最简形式直接除以二者的最大公约数即可。所以，直接求最大公约数即可，使用辗转相除法或更相减损法皆可，递归与否也皆可。 Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int gcd(int a, int b);int main(int argc, char const *argv[])&#123; int member,denominator; scanf("%d/%d", &amp;member, &amp;denominator); // member=66, denominator=120; printf("%d/%d\n", member/gcd(member, denominator), denominator/gcd(member, denominator)); return 0;&#125;int gcd(int a, int b)&#123; if(a &gt; b) return gcd(b, a); int temp; while(a) &#123; temp=b%a; b=a; a=temp; &#125; return b; /* other method: use recursion. return a==0?b:gcd(b%a, a); */&#125; 7-25 念数字输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下：123456789100: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu Input Specification输入在一行中给出一个整数，如：1234。提示：整数包括负数、零和正数。 Output Specification在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如yi er san si。 Sample Input &amp; Sample output Input:-600 Output:fu liu ling ling Analysis此题不难，只需对注意负数和输出的格式即可；可以直接当作字符处理，也可以用数位拆分的思路来做，可能稍微会麻烦一点；可以使用指针，也可以不使用指针。 Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char num[100]; scanf("%s", num); char *p = num; if(*p == '-')&#123; printf("fu "); p++; &#125; for(; *p != '\0'; p++) &#123; switch(*p) &#123; case '0': printf("ling");break; case '1': printf("yi");break; case '2': printf("er");break; case '3': printf("san");break; case '4': printf("si");break; case '5': printf("wu");break; case '6': printf("liu");break; case '7': printf("qi");break; case '8': printf("ba");break; case '9': printf("jiu");break; default: continue; &#125; if(*(p+1) == '\0') printf("\n"); else printf(" "); &#125; return 0;&#125; 7-26 单词长度你的程序要读入一行文本，其中以空格分隔为若干个单词，以.结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如it&#39;s算一个单词，长度为4。注意，行中可能出现连续的空格；最后的.不计算在内。 Input Specification输入在一行中给出一行文本，以.结束提示：用scanf(&quot;%c&quot;,...);来读入一个字符，直到读到.为止。 Output Specification在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 Sample Input &amp; Sample Output Input:It’s great to see you here. Output:4 5 2 3 3 4 Analysis本题不难，对每一个单词的字符进行遍历即可，每次扫描到空格，就跳过，一旦扫描到下一个单词的第一个字母，就输出上一个单词的长度。注意格式，空句子不需要输出0，直接输出\n即可。 Code123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int length=0,flag=0; char ch; while((ch=getchar()) != '.') &#123; if(ch != ' ')&#123; if(length &gt; 0 &amp;&amp; flag &gt; 0)&#123; printf("%d ", length); length=0; &#125; length++; flag=0; &#125; if(ch == ' ') flag++; &#125; if(length &gt; 0) printf("%d\n", length); else printf("0\n"); return 0;&#125; 7-27 冒泡法排序将N个整数按从小到大排序的冒泡排序法是这样工作的：从头到尾比较相邻两个元素，如果前面的元素大于其紧随的后面元素，则交换它们。通过一遍扫描，则最后一个元素必定是最大的元素。然后用同样的方法对前N−1个元素进行第二遍扫描。依此类推，最后只需处理两个元素，就完成了对N个数的排序。本题要求对任意给定的K（&lt;N），输出扫描完第K遍后的中间结果数列。 Input Specification输入在第1行中给出N和K（1≤K&lt;N≤100），在第2行中给出N个待排序的整数，数字间以空格分隔。 Output Specification在一行中输出冒泡排序法扫描完第K遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。 Sample Input &amp; Sample Output Input:6 22 3 5 1 6 4 Output:2 1 3 4 5 6 Analysis此题不难，算是帮助熟悉冒泡排序算法的题吧，按照题目给出的算法，使用两层循环，直接进行处理即可。注意，按照题目的要求，在交换两个相邻的元素的时候，只能交换整个数组内的元素。另外，按照下面的代码，如果不加条件j+1 &lt; N，将6排到最后面后，数字6仍然会和其下一位进行交换。或者不加条件j+1 &lt; N，就需要将第二层循环的条件改为j&lt;N-i Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); int array[105]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%d", &amp;array[i]); &#125; for(i=0; i&lt;K; i++) &#123; int temp=0; for(j=0; j&lt;N; j++) /*j&lt;N -&gt; j&lt;N-i-1*/ &#123; if(array[j] &gt; array[j+1] &amp;&amp; j+1 &lt; N)&#123; /*delete the "&amp;&amp; j+1 &lt; N"*/ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; if(i == N-1) printf("%d\n", array[i]); else printf("%d ", array[i]); &#125; return 0;&#125; 7-28 猴子选大王一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第1号开始报数，每轮从1报到3，凡报到3的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？ Input Specification输出在一行中给一个正整数N(≤1000)。 Output Specification在一行中输出当选猴王的编号。 Sample Input &amp; Sample Output Input:11 Output:7 Analysis这道题，属于“套路题”，实质是“约瑟夫环”问题；以下的代码介绍了三种方法：回溯法(严格意义上也许不是)、递归和迭代，分别参考了liuxuquan_、Little_Sword和d4shman的代码。感觉使用回溯法是最容易理解的，对于使用递归和迭代的方法，原理是一样的，理解一种了，另外一种也就没问题了；好像还可以通过其他的方式来做，这里暂时先不深究。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define maxn 1005int josephus_recursion(int n, int m);int main(int argc, char const *argv[])&#123; /* method 1: use backtracking int N; scanf("%d", &amp;N); // N=11; int i,monkey_array[maxn]=&#123;0&#125;; for(i=1; i&lt;=N; i++)&#123; monkey_array[i]=i; &#125; int j,k,temp; for(i=N; i&gt;=1; i--) &#123; for(j=1; j&lt;=3; j++)&#123; temp=monkey_array[1]; for(k=1; k&lt;=i; k++)&#123; monkey_array[k]=monkey_array[k+1]; &#125; monkey_array[i]=temp; &#125; &#125; printf("%d\n", monkey_array[1]); */ /* method 2: use recursion int N; N=11; if(!N) return 0; int result = josephus_recursion(N,3); printf("%d\n", result+1); */ /* method 3: use iteration*/ int i,N,result=0; scanf("%d", &amp;N); for(i=2; i&lt;=N; i++) &#123; result=(result + 3)%i; &#125; printf("%d\n", result+1); return 0;&#125;int josephus_recursion(int n, int m)&#123; if(n == 1) return 0; else return (josephus_recursion(n-1, m)+m)%n;&#125; 7-29 删除字符串中的子串输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 Input Specification输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 Output Specification在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 Sample Input &amp; Sample Output Input:Tomcat is a male ccatatcat Output:Tom is a male Analysis本题不是特别难，不过还是要仔细想一想。对需要删除的字符串进行遍历，比对字符串序列，如果不是子串，就进行下一次循环，若是子串，就将子串后的字符序列前移，然后修改字符串的长度，并让字符串最后一位为\0，这样就删除掉了子串；重复遍历即可删除所有子串。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s1[85],s2[85]; gets(s1); gets(s2); int len1=strlen(s1),len2=strlen(s2); int i,k; for(k=0; k&lt;len1; k++) &#123; for(i=0; i&lt;len1; i++) &#123; if(s1[i] == s2[0])&#123; int temp=i,flag=1,j; for(i+=1,j=1; j&lt;len2; i++,j++) &#123; if(s1[i] != s2[j])&#123; flag=0; break; &#125; &#125; if(!flag)&#123; i=temp; &#125;else&#123; for(j=temp; i&lt;len1; j++,i++) &#123; s1[j]=s1[i]; &#125; len1=len1-len2; s1[len1]='\0'; &#125; i=temp; &#125; &#125; &#125; printf("%s\n", s1); return 0;&#125; 7-30 字符串的冒泡排序我们已经知道了将N个整数按从小到大排序的冒泡排序法。本题要求将此方法用于字符串序列，并对任意给定的K（&lt;N），输出扫描完第K遍后的中间结果序列。 Input Specification输入在第1行中给出N和K（1≤K&lt;N≤100），此后N行，每行包含一个长度不超过10的、仅由小写英文字母组成的非空字符串。 Output Specification输出冒泡排序法扫描完第K遍后的中间结果序列，每行包含一个字符串。 Sample Input &amp; Sample Output Input:6 2bestcateastafreeday Output:bestacatdayeastfree Analysis本题不是特别难，但也需要细细想一想，另外感觉题干一开始没说清楚怎样认为一个字符串“大”或“小”，其实就是首字母在字母表顺序来决定大小，若首字母相同则比较首字母后的字母的顺序，依次类推；了解了这些后，可以发现，输入样例中的字符串构成的序列就是2 3 5 1 6 4，而输出样例的序列就是2 1 3 4 5 6，这个与7-27 冒泡法排序是一致的。解决这个问题的主要思路其实是利用二维数组存储每一个子字符串，进行比较后排序即可。主要该注意的点：abcd和acbd这种前一个或几个字母是相同的子字符串的比较，巧合的是，strcmp函数正好可以处理这样的情况👍，所以，直接使用strcmp函数比较后，在用strcpy函数互换字符串即可（类似整型变量的换值）；strcmp和strcpy这两个函数可以自己写；C++好像自带了应对这种字符串排序需求的处理函数，直接调用即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;string.h&gt;char* mycpy(char* dst, char* src);int mycmp(char const *s1, char const *s2);int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); char str[N][11]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%s", str[i]); &#125; char temp[11]; char *p=temp; for(i=1; i&lt;=K; i++) &#123; for(j=0; j&lt;N-i; j++) &#123; if(mycmp(str[j], str[j+1]) &gt; 0)&#123; mycpy(p, str[j]); mycpy(str[j], str[j+1]); mycpy(str[j+1], temp); &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; printf("%s\n", str[i]); &#125; return 0;&#125;char* mycpy(char *dst, char *src)&#123; char* ret = dst; while(*src) &#123; *dst++ = *src++; &#125; *dst = '\0'; return ret;&#125;int mycmp(char const *s1, char const *s2)&#123; while(*s1 == *s2 &amp;&amp; *s1 != '\0') &#123; s1++; s2++; &#125; return *s1-*s2;&#125; 7-31 字符串循环左移输入一个字符串和一个非负整数N，要求将字符串循环左移N次。 Input Specification输入在第1行中给出一个不超过100个字符长度的、以回车结束的非空字符串；第2行给出非负整数N。 Output Specification在一行中输出循环左移N次后的字符串。 Sample Input &amp; Sample Output Input:Hello World!2 Output:llo World!He Analysis本题不难，熟悉字符数组的存储方式的话做起来会感觉比较容易。主要思路是按照题目给的移动次数，将需要移动的字符按移动顺序放到一个新的字符数组内，将原来的字符数组的剩余字符前移，然后再将新的字符数组内的字符复制回老的字符数组内即可。注意当移动的次数大于字符串的长度时，要取余处理，比如，字符串长度为5，要移动9次，实际上移动的次数就是9%5=4。也可以只使用一个字符数组，先输出移动后的后半段字符，在输出前半段字符，最后换行即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int mylen(char const *s1);int main(int argc, char const *argv[])&#123; char str1[105]; char str2[105]; gets(str1); int N,i=1; scanf("%d", &amp;N); char* p=str1; char* q=str2; int len=mylen(p); for(p+=(N%len); *p != '\0'; p++, q++) &#123; *q=*p; &#125; p=str1; for(i=1; i&lt;=(N%len); i++, p++, q++) &#123; *q=*p; &#125; *q='\0'; printf("%s\n", str2); /* method 2: use one char_array int i=0,len=mylen(str); char* p=str; printf("%s", p+(N%len); p=str; for(; i&lt;(N%len); i++,p++) &#123; printf("%c", *p); &#125; printf("\n"); */ return 0;&#125;int mylen(char const *s1)&#123; int len=0; while(*s1) &#123; s1++; len++; &#125; return len;&#125; 7-32 说反话-加强版给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 Input Specification测试输入包含一个测试用例，在一行内给出总长度不超过500000的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用若干个空格分开。 Output Specification每个测试用例的输出占一行，输出倒序后的句子，并且保证单词间只有1个空格。 Sample Input &amp; Sample Output Input:Hello World Here I Come Output:Come I Here World Hello Analysis本题本质上而言，不是特别的复杂，但也需要仔细去琢磨一些细节，以下的代码参考了qq_37729102的代码，且文章之内做了很多细节说明；大致的思路，就是从后往前遍历字符串，空格跳过，扫描到非字符时，记录字符的个数(其实就是单词的长度了)，每扫描到下一个空格的时候，就输出前一个单词即可。由于第一个单词比较特殊，如果依然采取从后遍历的方法去输出第一个单词，这样就无法保证与题目格式的一致(换行符)，所以需要先记录第一个单词的首字母在字符数组中的下标，此时，若第一个单词的前面存在空格，跳过，若没有空格，那么循环变量为0后就自动跳出循环了，紧接着，再输出第一个单词就可以了。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 500005int main(int argc, char const *argv[])&#123; char str[maxn]; gets(str); int len=strlen(str); int i,j=0,char_cnt=0,next_flag=1,last_flag=1; for(i=0; i&lt;len; i++) &#123; if(str[i] != ' ')&#123; last_flag=i; break; &#125; &#125; for(i=len-1; i&gt;=0; i--) &#123; if(str[i] != ' ')&#123; next_flag=0; char_cnt++; &#125;else if(!next_flag)&#123; next_flag=1; for(j=i+1; j&lt;i+1+char_cnt; j++) &#123; printf("%c", str[j]); &#125; if(i+1 != last_flag) printf(" "); char_cnt=0; &#125; &#125; for(i=last_flag; i&lt;last_flag+char_cnt; i++) &#123; printf("%c", str[i]); &#125; printf("\n"); return 0;&#125; 7-33 有理数加法本题要求编写程序，计算两个有理数的和。 Input Specification输入在一行中按照a1/b1和a2/b2的格式给出两个分数形式的有理数，其中分子和分母全是整形范围内的正整数。 Output Specification在一行中按照a/b的格式输出两个有理数的和。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 Sample Input &amp; Sample Output Input 1:1/3 1/6 Output 2:1/2 Input 3:4/3 2/3 Output 4:2 Analysis本题算是7-24 约分最简分式的升级版了，题目不难，按照基本计算规则进行约分即可，实质上是对最大公约数和最小公倍数的理解、应用和计算吧。 Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int a1,b1,a2,b2; scanf("%d/%d %d/%d", &amp;a1, &amp;b1, &amp;a2, &amp;b2); int member,denominator,LCM,GCD; LCM=lcm(b1, b2); member=a1*LCM/b1 + a2*LCM/b2; denominator=LCM; GCD=gcd(member, denominator); if(denominator/GCD == 1)&#123; printf("%d\n", member/GCD); &#125;else&#123; printf("%d/%d\n", member/GCD, denominator/GCD); &#125; return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a);&#125;int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-34 通讯录的录入与显示通讯录中的一条记录包含下述基本信息：朋友的姓名、出生日期、性别、固定电话号码、移动电话号码。 本题要求编写程序，录入N条记录，并且根据要求显示任意某条记录。 Input Specification输入在第一行给出正整数N（≤10）；随后N行，每行按照格式姓名 生日 性别 固话 手机给出一条记录。其中姓名是不超过10个字符、不包含空格的非空字符串；生日按yyyy/mm/dd的格式给出年月日；性别用M表示“男”、F表示“女”；固话和手机均为不超过15位的连续数字，前面有可能出现+。在通讯录记录输入完成后，最后一行给出正整数K，并且随后给出K个整数，表示要查询的记录编号（从0到N−1顺序编号）。数字间以空格分隔。 Output Specification对每一条要查询的记录编号，在一行中按照姓名 固话 手机 性别 生日的格式输出该记录。若要查询的记录不存在，则输出Not Found。 Sample Input &amp; Sample Output Input:3Chris 1984/03/10 F +86181779452 13707010007LaoLao 1967/11/30 F 057187951100 +8618618623333QiaoLin 1980/01/01 M 84172333 100862 1 7 Output:LaoLao 057187951100 +8618618623333 F 1967/11/30Not Found Analysis本题不难，比较直接；直接用结构体构造出来保存通讯录的数据结构即可，然后再从这份通讯录内分别按顺序输出需要的信息即可。其实用二维数组应该也可以达到这样的效果，另外，对于生日这条记录，直接用字符串存储比较方便。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;typedef struct address_list&#123; char name[12]; char brith[12]; char gender; char landline[18]; char phone[18];&#125;address_list;int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); address_list list[N]; for(i=0; i&lt;N; i++) &#123; scanf("%s %s %c %s %s", list[i].name, list[i].brith, &amp;list[i].gender, list[i].landline, list[i].phone); getchar(); &#125; int K,j; scanf("%d", &amp;K); for(i=1; i&lt;=K; i++) &#123; int j,check_num=0,flag=0; scanf("%d", &amp;check_num); for(j=0; j&lt;N; j++) &#123; if(j == check_num)&#123; printf("%s %s %s %c %s\n", list[j].name, list[j].landline, list[j].phone, list[j].gender, list[j].brith); flag=1; &#125; &#125; if(!flag) printf("Not Found\n"); &#125; return 0;&#125; 7-35 有理数均值本题要求编写程序，计算N个有理数的平均值。 Input Specification输入第一行给出正整数N（≤100）；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。 Output Specification在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 Sample Input &amp; Sample Output Input 1:41/2 1/6 3/6 -5/10 Output 1:1/6 Input 2:24/3 2/3 Output 2:1 Analysis本题稍微复杂一点，不过大致思路还算简单；主要的思路就是依次将输入的分式相加，然后除以数量即可得到均值了。由于题目会给输入的分式的数目，所以可以提前定义好存储结构，然后在进行运算；注意每次运算完之后需要对分子分母进行化简，每次计算得到的分子member和分母denominator需要使用long long的类型来定义，否则会超出范围。分式的化简和相加主要依据最小公倍数和最大公约数来完成，最大公约数可以使用欧几里得算法，最小公倍数即为两个数的乘积除以两个数的最大公约数。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;typedef struct Fraction&#123; int a; int b;&#125;fraction;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); fraction fra[N]; for(i=0; i&lt;N; i++) &#123; scanf("%d/%d", &amp;fra[i].a, &amp;fra[i].b); &#125; int GCD=0, LCM=0; long long member=fra[0].a, denominator=fra[0].b; for(i=1; i&lt;N; i++) &#123; GCD=gcd(denominator, fra[i].b); LCM=denominator*fra[i].b/GCD; member=member*LCM/denominator + fra[i].a*LCM/fra[i].b; denominator=LCM; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; &#125; denominator*=N; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; if(denominator == 1) printf("%ld\n", member); else printf("%ld/%ld\n", member, denominator); return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a); &#125; int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-36 复数四则运算本题要求编写程序，计算2个复数的和、差、积、商。 Input Specification输入在一行中按照a1、b1、a2、b2的格式给出2个复数C1=a1+b1i和C2=a2+b2i的实部和虚部。题目保证C2不为0。 Output Specification分别在4行中按照(a1+b1i) 运算符 (a2+b2i) = 结果的格式顺序输出2个复数的和、差、积、商，数字精确到小数点后1位。如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。 Sample Input &amp; Sample Output Input 1:2 3.08 -2.04 5.06 Output 1:(2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i Input 2:1 1 -1 -1.01 Output 2:(1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 Analysis本题的计算方法比较简单，注意复数的*和/运算即可；此题比较麻烦的地方在于控制输出的格式，由于存在实部和虚部，所以需要分多种情况，这个就需要注意细节了。若用real代表实部，用imaginary代表虚部，就可以得到以下几种情况：real==0, imaginary==0、real==0, imaginary&gt;0、real==0, imaginary &lt; 0、real!=0, imaginary&gt;0、real!=0, imaginary&lt;0和real!=0, imaginary==0，根据这六种情况要分别输出结果中虚部前的+和-号；由于输入的数据是小数，在做判断时，得考虑四舍五入的情况，而在输出时，%lf会自动四舍五入；不要用flaot，因为数值可能会有损失，最好直接用double。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;math.h&gt;double a1,b1,a2,b2;void print_complex_number(double a, char c, double b);int main(int argc, char const *argv[])&#123; double real_part=0.0,imaginary_part=0.0; scanf("%lf %lf %lf %lf", &amp;a1, &amp;b1, &amp;a2, &amp;b2); real_part=a1 + a2; imaginary_part=b1 + b2; print_complex_number(real_part, '+', imaginary_part); real_part=a1 - a2; imaginary_part=b1 - b2; print_complex_number(real_part, '-', imaginary_part); real_part=a1*a2 - b1*b2; imaginary_part=a2*b1 + a1*b2; print_complex_number(real_part, '*', imaginary_part); real_part=(a1*a2 + b1*b2) / (a2*a2 + b2*b2); imaginary_part=(a2*b1 - a1*b2) / (a2*a2 + b2*b2); print_complex_number(real_part, '/', imaginary_part); return 0;&#125;void print_complex_number(double a, char c, double b)&#123; if(b1 &gt;= 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &gt;= 0 &amp;&amp; b2 &lt; 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &lt; 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else&#123; printf("(%.1lf%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125; if(fabs(a) &lt; 0.1 &amp;&amp; fabs(b) &lt; 0.1)&#123; printf("0.0\n"); return; &#125; int flag=0; if(fabs(a) &gt;= 0.1)&#123; printf("%.1lf", a); flag++; &#125; if(fabs(b) &gt;= 0.1)&#123; if(flag &amp;&amp; b &gt; 0.0)&#123; printf("+%.1lfi", b); &#125;else&#123; printf("%.1lfi", b); &#125; &#125; printf("\n");&#125; 7-37 整数分解为若干项之和将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 Input Specification每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 Output Specification按递增顺序输出$N$的所有整数分解式子。递增顺序是指：对于两个分解序列$N_1={n_1,n_2,⋯}$和$N_2={m_1,m_2,⋯}$，若存在$i$使得$n_1=m_1,⋯,n_i=m_i$，但是$n_{i+1} &lt; m_{i+1}$,则$N_1$序列必定在$N_2$序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 Sample Input &amp; Sample Output Input:7 Output:7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 Analysis以下代码参考了文之的代码；题目其实不难，也算是“套路题”的一种，采用了深度优先和递归的思想；文之博文内细节说的很清楚，这里暂时先不讨论（其实是自己看的似懂非懂😝）。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;void division(int i);int N;int s[31];int top=-1;int cnt=0;int sum=0;int main(int argc, char const *argv[])&#123; scanf("%d", &amp;N); division(1); return 0;&#125;void division(int i)&#123; if(sum == N)&#123; cnt++; printf("%d=", N); int k; for(k=0; k&lt;top; k++) &#123; printf("%d+", s[k]); &#125; if(cnt%4 == 0 || s[top] == N)&#123; printf("%d\n", s[top]); &#125;else&#123; printf("%d;", s[top]); &#125; return ; &#125; if(sum &gt; N)&#123; return ; &#125; int j; for(j=i; j&lt;=N; j++) &#123; s[++top]=j; sum+=j; division(j); sum-=j; top--; &#125;&#125; 7-38 数列求和-加强版给定某数字$A（1≤A≤9）$以及非负整数$N（0≤N≤100000）$，求数列之和$S=A+AA+AAA+⋯+AA⋯A（N个A）$。例如$A=1, N=3$时，$S=1+11+111=123$。 Input Specification输入数字$A$与非负整数$N$。 Output Specification输出其$N$项数列之和$S$的值。 Sample Input &amp; Sample Output Input:1 3 Output:123 Analysis这道题，不是特别难，其实这种类型的题目大体上算，大概又两种方法去解决；首先是比较直接的就是利用数组去模拟整个计算过程，其实质是用数组进行基本四则运算；另外一种方法就是数学，每一次数位的相加，其实是(A*(N-i) + carry，其中A是数位值，(N-i)是数位上的加的次数，carry是进位值，所以(A*(N-i) + carry的结果取余后才是这个数位真正的值。下面的代码中分别给出了用数组模拟的方法和数学方法，且数学方法理解起来不难，要能想到这样去解决的话，还需要积累。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#define maxn 100002int main(int argc, char const *argv[])&#123; /* method 1: use the array do analog computation, but Time Limit Exceeded int A,N,sum[maxn],num[maxn]; // scanf("%d %d", &amp;A, &amp;N); A=1, N=3; if(N == 0)&#123; printf("0\n"); &#125;else if(N == 1)&#123; printf("%d\n", A); &#125;else&#123; int i,j,temp,len,flag=0,carry=0; for(i=1; i&lt;=N; i++) &#123; num[i]=A; &#125; while(N) &#123; carry=0; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=A; &#125; for(i=1; i&lt;=N-1; i++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; for(j=i; j&lt;=N; j++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; while(carry) &#123; num[j++] = carry%10; carry/=10; len = j; flag = 1; &#125; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=0; &#125; N--; if(N == 1) break; &#125; if(flag)&#123; for(i=len; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=j; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; return 0; */ /* method 2: use the '%' */ int num[maxn]=&#123;0&#125;,i,j,carry,flag,A,N; scanf("%d%d", &amp;A, &amp;N); // A=9, N=4; if(N == 0) printf("0\n"); else if(N == 1) printf("%d\n", A); else&#123; carry=0, flag=0; for(i=0; i&lt;N; i++) &#123; num[i] = (A*(N-i) + carry)%10; carry = (A*(N-i) + carry)/10; &#125; while(carry) &#123; num[i++] = carry%10; carry = carry/10; flag = 1; &#125; if(flag == 1)&#123; for(i=N; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=N-1; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; &#125; Code-Completion6-1 简单输出整数本题要求实现一个函数，对给定的正整数N，打印从1到N的全部正整数。 Function interface definitionvoid PrintN ( int N );其中N是用户传入的参数。该函数必须将从1到N的全部正整数顺序打印出来，每个数字占1行。 Test procedure case123456789101112#include &lt;stdio.h&gt;void PrintN ( int N );int main ()&#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:3 Output:123 Analysis热身题🧐。 Code123456void PrintN(int N)&#123; int i; for(i=1;i&lt;=N;i++)&#123; printf("%d\n",i); &#125;&#125; 6-2 多项式求值本题要求实现一个函数，计算阶数为n，系数为a[0]…a[n]的多项式$f(x)=\sum_{i=0}^n(a[i]×xi)$在x点的值。 Function interface definitiondouble f( int n, double a[], double x );其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main()&#123; int n, i; double a[MAXN], x; scanf("%d %lf", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(“%lf”, &amp;a[i]); printf("%.1f\n", f(n, a, x)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:2 1.11 2.5 -38.7 Output:-43.1 Analysis直接按照公式求值即可，注意直接算有测试点会超时，可用提取公因式的办法来解决。 Code123456789101112double f( int n, double a[], double x ) &#123; int i; double sum=0,X=x; if(n == 0) &#123; sum=a[0]*1.0; &#125; else &#123; sum=a[n]*X + a[n-1]; for(i=n-2; i&gt;=0; i--) &#123; sum=sum*X + a[i]; &#125; &#125; return sum; 6-3 简单求和本题要求实现一个函数，求给定的N个整数的和。 Function interface definitionint Sum ( int List[], int N );其中给定整数存放在数组List[]中，正整数N是数组元素个数。该函数须返回N个List[]元素的和。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main ()&#123; int List[MAXN], N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%d", &amp;List[i]); printf("%d\n", Sum(List, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312 34 -5 Output:41 Analysis基础求和，很简单。 Code123456789int Sum ( int List[], int N )&#123; int i,ret=0; for(i=0; i&lt;N; i++) &#123; ret+=list[i]; &#125; return ret;&#125; 6-4 求自定类型元素的平均本题要求实现一个函数，求N个集合元素S[]的平均值，其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Average( ElementType S[], int N );其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素的平均值，其值也必须是ElementType类型。 Test procedure case1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Average(S, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:13.77 Analysis基础求平均值，很简单。 Code12345678910ElementType Average( ElementType S[], int N )&#123; ElementType sum=0; int i=0; for(; i&lt;N; i++) &#123; sum+=S[i]; &#125; return sum/N;&#125; 6-5 求自定类型元素的最大值本题要求实现一个函数，求N个集合元素S[]中的最大值，其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Max( ElementType S[], int N );其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素中的最大值，其值也必须是ElementType类型。 Test procedure case1234567891011121314151617#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Max(S, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:34.00 Analysis基础求最大值，也很简单。 Code12345678910ElementType Max( ElementType S[], int N )&#123; int i=0; ElementType max=S[i]; for(; i&lt;N; i++) &#123; if(max &lt; S[i]) max = S[i]; &#125; return max;&#125; 6-6 求单链表结点的阶乘和本题要求实现一个函数，求单链表L结点的阶乘和。这里默认所有结点的值非负，且题目保证结果在int范围内。 Function interface definitionint FactorialSum( List L );其中单链表List的定义如下：123456typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */ Test procedure case1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf("%d", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf("%d", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf("%d\n", FactorialSum(L)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:35 3 6 Output:846 Analysis链表求阶乘，本质上是对链表的遍历操作，对链表而言，注意判空条件可以写成L或者L-&gt;Next。 Code123456789101112131415int FactorialSum( List L )&#123; int fac_sum=0,i,fac; while(L) &#123; fac=1; for(i=1; i &lt;=L-&gt;Data ; i++) &#123; fac*=i; &#125; fac_sum+=fac; L=L-&gt;Next; &#125; return fac_sum;&#125; 6-7 统计某类完全平方数本题要求实现一个函数，判断任一给定整数N是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。 Function interface definitionint IsTheNumber ( const int N );其中N是用户传入的参数。如果N满足条件，则该函数必须返回1，否则返回0。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf("%d %d", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf("cnt = %d\n", cnt); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:105 500 Output:cnt = 6 Analysis这个题看着有点烦，其实也很简单，哈哈，出题者给出了#define &lt;math.h&gt;（感谢）这个条件后，对数字的操作就很简单了（不过自己写sqrt，应该也能搞定😉），注意sqrt这个函数的返回类型是double，所以需要强制类型转换(int)sqrt(n)；现在就只用去判断这个数中各数位数字出现次数至少出现2次即可。测试程序中传入函数的参量是int，所以，数组长度用11就好了。 Code123456789101112131415161718int IsTheNumber ( const int N )&#123; int ret=0,digit[11]=&#123;0&#125;; if( ((int)sqrt(N)) * ((int)sqrt(N) ) == N)&#123; int i,j,temp=N; for(i=0; temp; temp/=10, i++) &#123; digit[temp%10]++; &#125; for(j=0; j&lt;10; j++)&#123; if(digit[j] &gt;= 2)&#123; ret=1; break; &#125; &#125; &#125; return ret;&#125; 6-8 简单阶乘计算本题要求实现一个计算非负整数阶乘的简单函数。 Function interface definitionint Factorial( const int N );其中N是用户传入的参数，其值不超过12。如果N是非负整数，则该函数必须返回N的阶乘，否则返回0。 Test procedure case123456789101112#include &lt;stdio.h&gt;int Factorial( const int N );int main()&#123; int N, NF; scanf("%d", &amp;N); NF = Factorial(N); if (NF) printf("%d! = %d\n", N, NF); else printf("Invalid input\n"); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:5 Output:5! = 120 Analysis基本阶乘计算，注意$0!=1$即可。 Code12345678910111213int Factorial( const int N )&#123; int i,ret=1; if(N &lt; 0) return 0; else if(N == 0) return ret; else&#123; for(i=1; i&lt;=N; i++) &#123; ret*=i; &#125; &#125; return ret;&#125; 6-9 统计个位数字本题要求实现一个函数，可统计任一整数中某个位数出现的次数。例如-21252中，2出现了3次，则该函数应该返回3。 Function interface definitionint Count_Digit ( const int N, const int D );其中N和D都是用户传入的参数。N的值不超过int的范围；D是$[0, 9]$区间内的个位数。函数须返回N中D出现的次数。 Test procedure case123456789101112#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf("%d %d", &amp;N, &amp;D); printf("%d\n", Count_Digit(N, D)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:-21252 2 Output:3 Analysis考察数位拆分，注意如果是复数，需要先转换为其绝对值即可。 Code12345678910111213141516171819202122232425int Count_Digit ( const int N, const int D )&#123; int times=0,n; if(N &lt; 0) n = -N; else&#123; n=N; if(n == 0 &amp;&amp; D == 0)&#123; return 1; &#125; &#125; int mask=1,temp=n; do&#123; temp/=10; mask*=10; &#125;while(temp &gt; 9); temp = n; int digit; do&#123; digit = temp/mask; temp%=mask; mask/=10; if(digit == D) times++; &#125;while(mask &gt; 0); return times;&#125; 6-10 阶乘计算升级版本题要求实现一个打印非负整数阶乘的函数。 Function interface definitionvoid Print_Factorial ( const int N );其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出$N!$的值，否则打印“Invalid input”。 Test procedure case1234567891011#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main()&#123; int N; scanf("%d", &amp;N); Print_Factorial(N); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:15 Output:1307674368000 Analysis很明显是个大数问题，利用数组来模拟乘法计算即可，注意每一次进位的处理，感觉数组模拟乘法要比加法容易一些😧。 Code12345678910111213141516171819202122232425262728293031void Print_Factorial ( const int N )&#123; if(N &lt; 0)&#123; printf("Invalid input\n"); &#125;else if(N == 0)&#123; printf("1\n"); &#125;else&#123; int carry=0,i,j,k=1,temp,num[3000]=&#123;0&#125;; num[0]=1; for(i=2; i&lt;=N; i++) &#123; for(j=0; j&lt;k; j++) &#123; temp = num[j]*i + carry; num[j] = temp%10; carry = temp/10; &#125; while(carry) &#123; num[k]=carry%10; carry/=10; k++; &#125; &#125; for(i=k-1; i&gt;0 ;i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;&#125; 6-11 求自定类型元素序列的中位数本题要求实现一个函数，求N个集合元素A[]的中位数，即序列中第$⌊N/2+1⌋$大的元素。其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Median( ElementType A[], int N );其中给定集合元素存放在数组A[]中，正整数N是数组元素个数。该函数须返回N个A[]元素的中位数，其值也必须是ElementType类型。 Test procedure case12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main ()&#123; ElementType A[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;A[i]); printf("%.2f\n", Median(A, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:12.30 Analysis注意题目的描述，求的是中位数，而$⌊N/2+1⌋$这里是向下取整哦。也即是说，按照题目的要求，要先给传入函数的数组进行排序，然后再输出其中第$⌊N/2+1⌋$大的数，而此时对于数组（从0开始）而言下标就是N/2；明白这个之后，还有排序的问题要解决，如何排序呢？排序算法很多，冒泡排序和插入排序都有一个测试用例无法通过，所以这里使用希尔排序。举个希尔排序的简单例子，对于a[3]={3, 1, 2}这个序列而言，希尔排序会有一个增量d，并按照这个增量d来进行排序，d初始化为3(个数)/2=1，那么第一次希尔排序，就会对a[0]=3和a[0+d]=2这两个数字进行排序，由于不存在a[2]，所以a[1]不会参与排列；第二次循环时，检查已经有序就会跳出循环了。 Code123456789101112131415161718192021ElementType Median( ElementType A[], int N )&#123; int i,j; ElementType temp; int d; for(d=N/2; d&gt;0; d/=2) &#123; for(i=d; i&lt;N; i++) &#123; temp=A[i]; for(j=i; j&gt;=d; j-=d) &#123; if(temp &lt; A[j-d])&#123; A[j] = A[j-d]; &#125;else break; &#125; A[j]=temp; &#125; &#125; return A[N/2]; &#125; 6-12 判断奇偶性本题要求实现判断给定整数奇偶性的函数。 Function interface definitionint even( int n );其中n是用户传入的整型参数。当n为偶数时，函数返回1；n为奇数时返回0。注意：0是偶数。 Test procedure case123456789101112131415#include &lt;stdio.h&gt;int even( int n );int main()&#123; int n; scanf("%d", &amp;n); if (even(n)) printf("%d is even.\n", n); else printf("%d is odd.\n", n); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input 1:-6 Output 1:-6 is even. Input 2:5 Output 2:5 is odd. Analysis判断奇偶性直接对2取余就好，并且0是偶数，如果不确定的话可以手算一下。 Code1234int even(int n)&#123; if(n%2==0) return 1; else return 0;&#125; 6-13 折半查找给一个严格递增数列，函数int Search_Bin(SSTable T, KeyType k)用来二分地查找k在数列中的位置。 Function interface definitionint Search_Bin(SSTable T, KeyType k)其中T是有序表，k是查找的值。 Test procedure case123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct &#123; KeyType key; &#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable; void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) cin&gt;&gt;T.R[i].key; &#125;int Search_Bin(SSTable T, KeyType k);int main () &#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;"NOT FOUND"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125;/* 请在这里填写答案 */ Sample Input &amp; Sample Output Input 1:51 3 5 7 97 Output 1:4 Input 2:51 3 5 7 910 Output 2:NOT FOUND Analysis题目给出的测试程序是C++的语法，但是也没事，有C的功底看懂是没有太大问题的，不过实际上，因为，要写的只是函数，好像跟其他的好像也没啥关系，主要看懂有序表L的结构就好了。另一个，就是折半查找的算法了，大致思路就是利用左标记和右标记来遍历有序表，如果有符合条件的值就弹出即可。 Code1234567891011121314151617181920int Search_Bin(SSTable T, KeyType k)&#123; int serial_num=0,left,right=T.length,mid=1,j=1; while(j &lt;= T.length)&#123; mid=(left + right)/2; if(T.R[mid].key == k)&#123; serial_num = mid; break; &#125;else&#123; if(T.R[mid].key &lt; k)&#123; left = mid; &#125; if(T.R[mid].key &gt; k)&#123; right = mid; &#125; &#125; j++; &#125; return serial_num; &#125; Summary虽说是基础编程题目集，但是感觉里面有些题目还真不是特别好想，可能是我比较菜😂。尽管每道题目都给出了题目、输入（输出）样例、说明等，字数真是多啊，哈哈，有点水文的嫌疑。另外，关于每道题目的AC代码，已经全部被上传到GitHub上了，可以点击PTA-Basical-Programming-problem-set来获取源文件。]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Hexo搭建个性化博客]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Intro偶然看到别人用Hexo建立的个人Blog，觉得挺不错的，然后就开始动手折腾了。而此篇Blog就用来记录自己建立这个Blog的整个过程和一些细节吧，这样在出现问题的时候可以及时找到问题所在，也可以给其他人作为参考，持续更新ing(偷懒😴)。 Preparation在开始建立Blog之前，需要先安装三样东西：Node.js、Git和Hexo。以下过程均已Win10系统（Linux系统类似）为准。 Windows系统的文件目录分隔符是\，而不是Linux采用的/ Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 直接百度搜索Nodejs即可找到其官方下载页面，或者点击Node.js，直接下载64位安装windows安装程序即可。下载好之后，直接安装即可，可以修改默认的安装路径到你设定的磁盘文件夹下。 GitGit 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 与Node.js同样，我们直接百度搜索Git即可找到其官方下载页面，但是官方地址的下载速度很慢，不过好在Git并不大，不需要太长时间就可以下载好，或者点击下面的链接，直接下载。64-bit Git for Windows Setup64-bit Git for Windows Portable HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo比较简单，在CMD或者PowerShell键入npm install -g hexo-cli后运行即可。从这里可以看出，Hexo的安装其实是依赖Node.js的npm来进行的。 Checkout安装好了之后，需要检查是否能正常使用，在CMD或PowerShell内运行以下命令即可。~\hexo12345678910111213141516171819202122232425node -vgit versionhexo version#回显信息依次如下：v10.15.1git version 2.20.1.windows.1hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.1v8: 6.8.275.32-node.12uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 如果得到类似以上的结果，那么说明Node、Git和Hexo能够正常使用。 Setup安装完成Hexo后，我们就可以开始建站了。 Init - 初始化注：根据你选择存储的位置，可以在任意盘符和文件夹下运行以下命令，且均可在CMD或PowerShell内执行。 Hexo初始化的命令为：C:\Users\test&gt; hexo init &lt;folder name&gt;，以C:\Users\test为例，如果在这个路径执行上述命令后，会在test文件夹内生成一个名为folder name的文件夹，且这个文件夹内存储着与Hexo即将生成的静态页面相关的配置文件等。 然后，进入到这个文件夹cd &lt;folder name&gt;，在执行npm install。 初始化完成后，一般会弹出文件夹信息，如：~\hexo1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这些信息可以帮助我们快速熟悉Hexo的文件系统。 到这里，如果没有错误信息产生，Hexo的初始化就算完成了。 Generating - 生成 下面所有内容中代码块内运行的命令均是在上述Hexo初始化的文件夹下运行的。 接着上面的步骤，执行命令C:\Users\test\folder name&gt; hexo generate，此命令可以简写为hexo g，执行完这条命令后，Hexo会默认将source\_post文件夹下的.md文件生成为静态的.html文件，并在C:\Users\test\folder name下创建一个public文件夹，用来存放生成的静态页面文件。 Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。我们可以利用hexo generate --watch命令来使用这个功能。 当然，还可以与部署命令配合使用，如：~\hexo1234567hexo generate --deployhexo deploy --generate#上面的两条命令是等价的#简写hexo g -dhexo d -g Server - 服务器当服务器运行我们的网站进程后，远程的客户端才可以打开网站。下面，在介绍Hexo下服务器的相关命令和设置。 接着上面的步骤，执行命令C:\Users\test\folder name&gt; hexo server，此命令可以简写为hexo s，执行完这条命令后，Hexo的Blog页面会运行在http://Localhost:4000/，这个页面下，可以直接在浏览器内打开，打开后即可看到Hexo生成的Blog主页面了。 根据Hexo官网的说明，在之前的Hexo 3.0中，Hexo将服务器独立成了个别模块，需要先安装hexo-server才能使用。执行npm install hexo-server --save，等待安装完成后，执行hexo s即可。 在服务器启动期间，Hexo会监视文件变动并自动更新，无须重启服务器。所以，在写Blog的时候，可以直接在线查看。 执行hexo s -p &lt;port number&gt;，可以将页面运行在指定的本地端口。若执行hexo server -i x.x.x.x，可以将页面运行在指定的IP地址上，就只能通过指定的这个IP来访问站点了。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i 192.168.*.*作为参数，可能就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么也就无法通过公网来访问站点。 另外，在静态模式下，服务器只处理public文件夹内的文件，而不会处理文件变动，在执行时，应该先自行执行hexo generate，此模式通常用于生产环境（Production mode）下。 Deployment部署需要指定git repository（仓库），且需要对本机的Git进行配置。 或者直接使用服务器，如果服务器存在公网IP，那么执行hexo s后，就可以用服务器的公网IP去访问这个站点了。但是这样会有一个问题，当关闭服务器的远程连接之后，用hexo s命令产生的进程会关闭，这样就导致无法再访问了，可以使用hexo s &amp;命令来使进程在后台持续运行。 当需要关闭这个进程的时候，结束掉这个这个进程即可。 Git Setting - Git 配置这部分涉及Git的用法，建议去Baidu或Google查询一下Git的相关使用方法，这里放一个Git教程链接，号称史上最浅显易懂的Git教程，非广告。 Sign Up - 创建账号若没有Github账号，请去Github官网注册一个，填写好邮箱、用户名和密码，邮箱需要验证。 Creat Repositories - 创建仓库刚创建好的Github账号，系统会默认带你创建一个repo(repositories)，可以直接创建一个给Hexo用的仓库，也可以先创建一个测试repo来熟悉一下创建的流程。 注意： 新建的仓库名为username.github.io，这里的username是你的github账号名称，这样Hexo部署到Github上的静态页面，就可以通过http://username.github.io来进行访问了。 github创建的仓库可能不会立即生效，可能需要等待10-30分钟。 创建成功后，通过Hexo部署的静态页面文件就放到这里了。 SSH key - 配置SSH密钥SSH为Secure Shell的缩写，SSH是建立在应用层基础上的安全协议，是可靠的专为远程登录会话和其他网络服务提供安全性的协议。在使用github提交代码时，需要账户权限，直接使用用户名和密码不是一个安全的选择，正好Github上提供了ssh key相关的服务。 打开Git Bash，执行$ cd ~/.ssh，若提示No such file or directory，说明你未使用过ssh。若可以进入此目录(这里用目录是因为与Windows的文件夹概念区分开，因为Git Bash是Linux Shell)，则执行ls，查看当前目录下的文件，一般只有一个叫做known_hosts的文件，这个文件是你用ssh登录设备后生成的一些密钥信息。 继续在Git Bash中执行ssh-keygen -t rsa -C &quot;your email&quot;，这里的your email是你注册Github所使用的邮箱。然后连续3次回车，最终会生成一个名为id_rsa.pub的文件，用文本编辑器打开里面的内容后，复制好。然后，打开你的Github主页，进入个人设置，找到SSH and GPG keys，点击New SSH key，将复制的内容粘贴到key栏下，设置title后，点击Add SSH key即完成SSH key的配置。 别急，还没完，接着在Git Bash中运行ssh -T git@github.com，这里不需要修改邮箱，若提示信息为Are you sure you want to continue connecting (yes/no)?，输入yes后，将会提示Hi &#39;your github-id&#39;! You&#39;ve successfully authenticated, but Github does not provides shell access.，此时说明Git的SSH key已配置成功！ 紧接着，还需要配置：12$ git config --global user.name "username" # your github-id$ git config --global user.email "xxx@xx.com"# your email with github 以上两条命令的作用是，将你之后的每次在github上发起的提交都写入这些信息。对于git而言，使用了--global选项的命令，只需运行一次。另外，Git自带的git config还可以帮助我们设置Git的外观和行为的配置变量，进一步的信息，请参考Git官方文档内含中文翻译。 Hexo Config - Hexo 设置Hexo 的配置比较简单。 打开由 Hexo 初始化的博客文件夹，找到_config.yml文件，用文本编辑器打开，修改以下代码： ~\hexo\_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: + type: git+ repo: git@github.com:username/username.github.io.git+ branch: master 修改好后，保存即可。若不知道repo如何设置，请参照下图。 接着，我们还需要安装一个插件来为Hexo提供部署功能。打开 CMD ，执行npm install hexo-deployer-git --save，若提示Permisson denied (publickey).，则打开Git Bash再次执行此命令即可。注意这个步骤需要在博客本地的根目录下进行。 在部署到Github Pages的过程中，必须先执行hexo g生成静态页面之后，才可以执行hexo d后，会同时先默认执行Hexo g命令，因为Hexo部署到Github Pages上的文件需要Hexo先本地生成，而Hexo本地生成静态页面时，会在博客根目录下生成名为public的文件夹，并将生成好的静态页面文件全部放到这个文件夹下，继而再将这个文件夹内的文件全部部署到github上。 建议每次在运行hexo d之前，做好备份 Personalized Customization下面介绍有关Hexo的一些基础配置。 Change Themes - 修改主题Hexo默认的主题叫做landscape，外形中规中矩，但肯定满足不了大家的个性化需求，所以还需要更加个性化的主题才可以。 此Blog应用的主题为NexT，这款主题风格简约，设计精美，感谢作者IIssNan。 Download Themes - 下载主题下载NexT主题的方法很多，获取资源的途径也很多，推荐使用git来安装。- ~\hexo123&lt;!-- folder name为之前Hexo生成的文件夹 --&gt;$ cd &lt;folder name&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next git clone xxx这条命令属于git的应用范畴，是git的基本操作。另外，theme-next这条链接可以直接打开，是NexT官方的github repo，其上也介绍了如何安装和升级NexT。 Enable NexT - 启用主题对于Hexo而言，所有的主题启用模式都是一样的。当克隆/下载完成后，打开Hexo生成目录下的_config.yml文件，找到theme字段，将其值修改为next后，保存即可。~\hexo\_config.yml1theme: next 一般而言，在启用 next 主题后，页面会直接使用该主题，但不排除意外的情况，这时，可以使用hexo clean清楚缓存，并用hexo g重新生成新的页面。 Checkout - 验证在CMD下，执行hexo s，显示INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.后，打开链接http://localhost:4000/，即可看到效果。或者，可以执行hexo s --debug，这样在服务启动的过程中，如果由错误产生，命令行会自动输出这些异常信息，恰巧你碰到问题的话，这些信息可以帮助他人更好的定位错误。 当你看到与下图类似的效果时，说明已经成功安装NexT主题。 NexT Basic Setting - NexT 基本设置下面介绍与有关NexT的基本设置。 为方便起见，将Hexo生成的目录下的_config_yml称为站点配置文件，将next主题文件目录下的_config.yml称为主题配置文件 Scheme - 主题样式Scheme 是 NexT 提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。通过更改主题配置文件，可以达到切换Scheme的效果。在主题配置文件中，可以找到如下内容，将需要启用的Scheme前的注释#删除即可。~\hexo\themes\next\_config.yml12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 具体效果可自行尝试。 Language - 语言目前NexT支持的语言有多种，可在其languages文件夹下查看，这里的语言与页面上显示的项目的语言一致，设置为哪一种语言，就显示为哪一种语言。语言设定需要在站点配置文件中设置，在站点配置文件中，找到如下内容，将其值修改为NexT主题对应语言名称文件即可。~\hexo folder\_config.yml1language: zh-CN language:后的值必须要与NexT的语言文件名称一致，才能在页面上生效 Avatar Setting - 头像设置编辑主题配置文件，找到avatar设置部分，如：~\hexo\themes\next\_config.yml1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /uploads/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true 其中，url为头像的存放路径，rounded和opacity以及rotated为NexT主题下与头像相关的三个个性化功能选项，注释内容为说明。 以上内容属于NexT自带基础设置，更加个性化的设置需要从其他位置进行设置 Site Information - 站点信息站点信息包含的内容主要有标题、作者、介绍等，可以在站点配置文件中进行设置。编辑站点配置文件，找到如下部分：~\hexo\_config.yml123456title: examplesubtitle:description: author: examplelanguage: zh-CNtimezone: 以上内容分别对应：标题、副标题、介绍、作者、语言、时区，修改各个字段的值，即可完成修改。 language与上文中的语言设置是相同的description字段后面的值会被放在头像的下面timezone默认为本机所在时区，可设置为其他时区 Menu Setting - 菜单设置菜单配置包括三个部分，第一是菜单项的显示文本，第二是菜单项的链接，第三是菜单项对应的图标。 NexT使用的是Font Awesome提供的图标，Font Awesome提供了600+的图标，可以满足绝大的多数的场景，同时无须担心在Retina屏幕下图标模糊的问题。 编辑主题配置文件，找到如下部分：~\hexo\themes\next\_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要启用的菜单项前的注释#删除即可，||之前为目标页面的链接，||之后为对应的项目图标。在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的Font Awesome图标名字）的情况下，NexT会使用question icon作为图标。所以，值必须要与图标名称严格一致。 若此时没有为新开启的菜单项设置页面，点击打开时会出现Cannot GET /xxx/的错误 Sidebar Setting - 侧栏设置默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改主题配置文件中的sidebar字段来控制侧栏的行为。侧栏的设置主要包括两个部分，其一是侧栏的位置，其二是侧栏显示的时机。当然了，还包含一部分个性化设置。 设置侧栏的位置，修改sideba.position的值，如： ~\hexo\themes\next\_config.yml1234sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right 设置侧栏显示的时机，修改sidebar.display的值，如： ~\hexo\themes\next\_config.yml12345sidebar: display: post #display: always #display: hide #display: remove 额外的个性化设置，如： ~\hexo\themes\next\_config.yml12345678# Sidebar offset from top menubar in pixels (only for Pisces | Gemini).offset: 12# Back to top in sidebar.b2t: false# Scroll percent label in b2t button.scrollpercent: true# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true Summary - 小结到这里，NexT基本设置就完成了。可以发现，对于Hexo而言，与页面样式直接相关的内容都是存于主题文件中的，所以，我们直接修改主题配置文件就好了，但若某些主题缺少部分功能的设置，那么可能就需要第三方插件来完成了。 Custom with NexT - NexT 自定义 感谢以下博文：打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化Git Pages 使用指南 hexo的next主题个性化教程:打造炫酷网站 随着NexT版本的不断更新，原先需要用户自己实现的特效（往源码文件中添加代码），有一部分已经被大佬们内嵌到NexT主题内了，感谢他们。 网站页脚的红心及其动画效果修改如下代码部分：~\hexo\themes\next\_config.yml12345678910footer: # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 当然了，依然可以在Font Awesome找到你自己想要的图标进行替换。 开启RSS根据官方的说明，NexT中RSS有三个设置选项，存放在主题配置文件中： false：禁用RSS，不在页面上显示RSS连接 留空：使用Hexo生成的Feed链接，需要先安装hexo-generator-feed插件 具体的链接地址：适用于已经烧制过Feed的情形 以留空为例，先安装hexo-generator-feed插件。~\hexo1npm install hexo-generator-feed --save 安装完成后，设置站点配置文件，增加以下代码：~\hexo\_config.yml12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png 然后重新开启页面即可在侧栏看到RSS连接。 开启打赏打赏功能已经被集成在NexT主题中了，那么只需要放入我们的二维码，并开启相应的功能即可。修改主题配置文件：~\hexo\theme\next\_config.yml12345reward: enable: true comment: If it helps, would you?:P wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg 此时，刷新页面即可看到红色的打赏按钮，点击打开就能看到支付的二维码了。 关闭打赏文字的动画效果将鼠标指针放到二维码上面时会有一个问题：下面的字体会不断的抖动，若不喜欢可以将这个动画效果关闭。注释掉如下代码：~\hexo\themes\next\source\css\_common\components\post\post-reward.styl1234567/* close the roll of reward font#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 保存修改后即可生效。 启用本地搜索本地搜索功能依赖插件hexo-generator-searchdb，先安装插件：~\hexo1npm install hexo-generator-searchdb --save 然后编辑站点配置文件，增加以下代码：~\hexo fold\_config.yml12345search: path: search.xml field: post format: html limit: 10000 接着在主题配置文件中启用本地搜索功能：~\hexo\theme\next\_config.yml12local_search: enable: true 配置完成后，需要重新生成静态页面。 修改文章内链接文本样式添加如下代码：~\hexo\themes\next\source\css\_custom\custom.yml1234567891011// change the style of inner link.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 也可在~\hexo\themes\next\source\css\_common\components\post\post.styl这个文件内添加以上代码。 增加代码块复制功能此功能也被集成在NexT主题中了，修改以下代码，即可直接开启。~\hexo\themes\next\_config.yml123456codeblock: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true 添加代码块圆角增加以下代码：~\hexo\themes\next\source\css\_custom\custom.yml123// codeblocks with rounded rectangle.highlight &#123; border-radius: 18px;&#125;pre &#123; border-radius: 8px;&#125; 具体数值可自行设置，也可修改主题配置文件中如下代码：12345codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1- border_radius:+ border_radius: 8 修改单行代码颜色增加以下代码：~\hexo\themes\next\source\css\_custom\custom.yml12// the colour of single line codecode &#123; color: #ec7f00; &#125; 具体颜色可自行设置。 添加博文字数统计功能字数统计功能依赖插件hexo-symbols-count-time，先安装插件： ~\hexo1npm install hexo-symbols-count-time --save 然后编辑站点配置文件，增加以下代码：~\hexo\_config.yml12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 接着在主题配置文件中启用字数统计功能：~\hexo\theme\next\_config.yml123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275 awlwpmsuffixAverage Word Length(chars count in word). Default: 4 CN ≈ 2 EN ≈ 5 RU ≈ 6 Words Per Minute. Default: 275. Slow ≈ 200 Normal ≈ 275 Fast ≈ 350 If time to read less then 60 minutes, added suffix as string parameter. Default: mins. 设置页面显示的文章篇数NexT默认会对此进行配置，但如果需要更多个性化设置需要安装插件：~\hexo123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 然后在站点配置文件中，添加如下代码，注意Hexo 3以上的版本不允许配置文件存在重复的选项设置。因此最好先检查下站点配置文件中是否有存在上述同名的配置。如果存在，请将两者配置在一起。~\hexo\_config.yml12345678910111213141516# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# 全局分页，每页8篇文章index_generator: # 主页显示多少篇文章 per_page: 5archive_generator: # 归档页显示多少篇文章 per_page: 20 yearly: true monthly: truetag_generator: # 标签页显示多少篇文章 per_page: 10category_generator: per_page: 12 显示菜单栏的文章数量修改如下代码：- ~\hexo\themes\next\_config.yml12menu_settings: badges: true 开启评论和阅读统计功能NexT支持的阅读统计和评论功能较多，针对不同的插件，都进行了集成，用户需要在主题配置文件中开启用户自己指定的某一类功能；同时可能部分功能需要借助到其他第三方应用，所以用户还需要自己注册第三方应用并配置好这些第三方应用的功能。以基于leancloud的统计功能为例，需要用户自身注册leancloud的账号，并进行配置，这里给出官方链接——使用leancloud为next主题添加阅读量统计功能。 添加评论系统NexT内嵌支持的评论系统也有多种（这得感谢各位大大的奉献），与开启统计功能的方法一致。基于leancloud的阅读量统计功能配置完成后，leancloud内的资源依然可以用来统计评论记录，不过要配合Valine一起使用；Valine的基本配置方法可以参考链接——快速开始 | Valine。不过对于NexT而言，只需要在主题配置文件中开启Valine功能，并在Leancloud配置好针对评论的应用即可，而这部分内容可以从官方链接内找到答案。另外，需要注意一下的是，Valine的头像是基于Gravatar的，用户需要自己去Gravatar注册账号，并设置头像。 修改底部标签样式修改底部标签样式需要对整个页面的一些元素进行修改。修改如下代码：~\hexo\themes\next\layout\_marco\post.swig1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 即将rel=&quot;tag&quot;&gt;#后的#替换为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;即可。替换完后，需要重新生成页面。 添加侧栏链接侧栏链接的功能在NexT内可直接找到。修改如下代码：~\hexo\themes\next\_config.yml123456links_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com 添加侧栏社交图标修改如下代码部分：~\hexo\themes\next\_config.yml123456789101112social: GitHub: https://github.com/Bachzart || github E-Mail: mailto:whistlesilp@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 可自行添加自己需要的社交图标和链接。 修改网站的图标修改如下代码：~\Hexo\themes\next\_config.yml12345favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png+ small: /uploads/example_16px.png+ medium: /uploads/example_32px.png 开启右上角Github图标修改如下代码：~\Hexo\themes\next\_config.yml123456 # Follow me on GitHub banner in right-top corner. # Usage: `permalink || title` # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the title and aria-label name.- # github_banner: https://github.com/bachzart || Follow me on GitHub :)+ # github_banner: https://github.com/bachzart || Follow me on GitHub :) 修改博客内字体修改如下代码：~\Hexo\themes\next\_config.yml123456789font:- enable: false+ enable: true+ host: //fonts.loli.net global: external: true+ family:+ family: Noto Serif SC size:其中Noto Serif SC是思源宋体，另外在整个font设置项中还有很多其他的选项可以进行设置，不妨尝试一下。 添加顶部加载条修改如下代码：~\Hexo\themes\next\layout\_partials\head\head.swig12345678910111213141516171819 &lt;meta charset="UTF-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/&gt;+ &lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;+ &lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;+ &lt;style&gt;+ .pace .pace-progress &#123;+ background: #1E92FB; /*the color of strip*/+ height: 3px;+ &#125;+ .pace .pace-progress-inner &#123;+ box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*the color of shadow*/+ &#125;+ .pace .pace-activity &#123;+ border-top-color: #1E92FB; /*border-top-color*/+ border-left-color: #1E92FB; /*border-left-color*/+ &#125;+ &lt;/style&gt; &lt;meta name="theme-color" content=""/&gt; 开启文章底部版权声明修改如下代码：~\Hexo\themes\next\_config.yml1234creative_commons: license: by-nc-sa sidebar: false+ post: true如若解析完成后，显示http://yoursite.com/xxx.html，请修改如下代码：~\Hexo\_config.yml1234+ url: http://bachzart.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults:保存好后，重新生成即可。 添加 fancybox 插件fancybox2/3皆需要先安装才能使用，安装十分简单，可以参考fancybox3，先下载fancybox3文件：~\Hexo\themes\next1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 然后在主题配置文件中开启功能：~\Hexo\themes\next_config.yml1+ fancybox: true效果如下图： Writing Skills下面内容将开始介绍一些写作技巧。 Writing with NexTNexT主题自身扩展了很多方便写作的功能，既提高了文章的美感，又让作者更加容易的表达观点。 除了代码块外，其他引用方式内都可以尝试与 Markdown 语法的加粗、倾斜、删除线等功能进行嵌套使用，效果更佳 文本居中引用此标签将生成一个带上下分割线和双引号的引用，同时写在其内部的应用文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。使用方法如下：12345678&lt;!-- HTML方式：直接在 Markdown 文件中编写 HTML来调用&gt;&lt;!-- 其中 class=&quot;block-quote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;bla bla bla&lt;/blockquote&gt;&lt;!-- swig语法 --&gt;&#123;% centerquote %&#125;bla bla bla&#123;% endcenterquote %&#125;&lt;!-- 简写 --&gt;&#123;% cq %&#125;bla bla bla&#123;% endcq %&#125; 效果如下图：另外还有一种文本居中引用方法：12&lt;!-- HTML方式 --&gt;&lt;center&gt;**bla bla bla**&lt;/center&gt; 效果如下： bla bla bla 代码块的书写方法codeblock代码块用法如下：1234&lt;!-- swig语法 --&gt;&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 另一种形式的代码块使用六个反引号（正好一对）来包裹代码块，[language] [title] [url] [link text]这四个参数也写在首行，这两种方式书写时都没有[]。languagetitleurllink textlanguage是代码语言的名称，用来设置代码块颜色高亮，非必须title是顶部左边的说明，非必须url是顶部右边的超链接地址，非必须link text是超链接的名称，非必须如果需要对比功能，需要写lang：diff，并在相应的代码行首加上-和+即可，对应的颜色也是可以自定义的，修改如下代码：~\hexo\themes\next\source\css\_custom\custom.syl1234567// the diff style of codeblockpre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125; Note PluginNexT主题扩展了一种note插件，可以用来单独展示重点性或结论性内容，其配置信息保存在主题配置文件中，具体如下：123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 在书写时，在.md文件内直接插入以下代码即可：1234567&lt;!-- swig --&gt;&#123;% note %&#125;bla bla bla&#123;% endnote %&#125;&lt;!-- HTML --&gt;&lt;div class=&quot;note&quot;&gt;&lt;p&gt;bla bla bla&lt;/p&gt;&lt;/div&gt; 效果如下： bla bla bla 另外，note后添加default/primary/info/success/warning/danger，可以展示不同的标签栏，分别如下： bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla 设置note xx no-icon可以不显示图标，效果如下： 更多使用方法，可以访问Note-Docs。 Button PluginButton插件的使用也很简单，在主题配置文件中可开启，同样直接在.md文件内插入以下代码：123&#123;% button url, text, icon [class], [title] %&#125;&lt;!-- Tag Alias --&gt;&#123;% btn url, text, icon [class], [title] %&#125; 1如：&#123;% btn #, Text %&#125; 效果如下： Text 更多使用方法，可以访问Button-Docs。 Tabs PluginTabs插件在主题配置文件中的配置如下：1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 5 使用方法如下：1234567891011&#123;% tabs First unique name %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果如下：First unique name 1First unique name 2First unique name 3This is Tab 1.This is Tab 2.This is Tab 3. 更多使用方法，可以访问Tabs-Docs。 Label PluginLabel插件在主题配置文件中的配置如下：12# Label taglabel: true 使用方法如下：12345&#123;% label primary@Text %&#125;&#123;% label success@Text %&#125;&#123;% label info@Text %&#125;&#123;% label warning@Text %&#125;&#123;% label danger@Text %&#125; 效果如下：TextTextTextTextText更多使用方法，可以访问Label-Docs。 图片的引用方法图片的引用方法如下：123&#123;% fullimage /url [@lazy], [alt], [title], [size] %&#125;&lt;!-- Tag Alias --&gt;&#123;% fi /url [@lazy], [alt], [title], [size] %&#125; 使用方法如下：1&#123;% fi /my_photo_gallery/test_github.png, test text, test text %&#125; 效果如下图： 更多使用方法，可以访问Full Image-Docs。 Markdown Grammar参见 Markdown 语法快速指南 Mathjax Grammar参见 Mathjax 语法快速指南]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
