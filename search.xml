<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ã€Šå¤ªèªæ˜Žã€‹å­¦ä¹ ç¬”è®°]]></title>
    <url>%2F2024%2F04%2F09%2F%E3%80%8A%E5%A4%AA%E8%81%AA%E6%98%8E%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[è¿™æ®µæ—¶é—´æŠŠã€Šå¤ªèªæ˜Žã€‹è¿™é¦–æ­Œå¥½å¥½çš„å­¦ä¹ äº†ä¸‹ï¼Œè®°ä¸€ç‚¹è‡ªå·±çš„ç¬”è®°~ ï¼ˆæ’ä¸€å¼ é™ˆè€å¸ˆçš„ä¸“è¾‘å°é¢ðŸ˜‰ï¼‰ å‰å¥é¦–å…ˆæ˜¯å‰å¥éƒ¨åˆ†ï¼Œä¸»è¦æœ‰ä¸¤ç‚¹ï¼š ä»Ž E å¤§ä¸‰å’Œå¼¦å¼€å§‹ï¼ŒåŽé¢è·Ÿäº†ä¸¤ä¸ªåŒéŸ³ï¼Œåˆ†åˆ«æ˜¯ #G+E å’Œ #F+Aï¼Œè¿™ä¸¤ç»„åŒéŸ³å¯ä»¥ç†è§£ä¸º E å’Œå¼¦å’Œ #Fm å’Œå¼¦ï¼Œä¹Ÿå°±æ˜¯ â… å’Œ â…¡mã€‚åŽé¢åˆè·Ÿç½‘ä¸Šçš„è°±å­æ¯”å¯¹äº†ä¸‹ï¼Œå‘çŽ°ç½‘ä¸Šçš„è°±å­æŠŠè¿™ä¸¤ä¸ªåŒéŸ³éƒ½æ˜¯è®°æˆäº† #G+B å’Œ #F+Aï¼Œä¹Ÿå°±æ˜¯ #Gm å’Œå¼¦å’Œ #Fm å’Œå¼¦ï¼Œå¯¹åº” â…¢m å’Œ â…¡mï¼Œè‡ªå·±åˆä»”ç»†å¬äº†ä¸‹ï¼Œæ„Ÿè§‰å¥½åƒä¹Ÿè¯´çš„è¿‡åŽ»ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯æˆ‘çš„è€³æœµåªèƒ½å¬åˆ° #G è¿™ä¸ªéŸ³çš„ç¼˜æ•…ðŸ˜‚ã€‚ æ•´ä¸ªå‰å¥éƒ¨åˆ†ä¸­ï¼Œä¸æ–­é‡å¤ç€ä½ŽéŸ³ E å¼¦ï¼ˆ6 å¼¦ç©ºå¼¦ï¼‰çš„æ¼”å¥ï¼Œè¿™é‡Œå…¶å®žå¯ä»¥ç†è§£æˆ Bassï¼Œæ›´èƒ½å‡¸æ˜¾å‡ºåŒéŸ³çš„æ—‹å¾‹ã€‚ ä¸»æ­Œä¸»æ­Œéƒ¨åˆ†ï¼Œæ‹†å¼€æ¥ç†è§£ã€‚ ç¬¬ä¸€éƒ¨åˆ†ç¬¬ä¸€ä¸ªéƒ¨åˆ†çš„å’Œå£°è¿›è¡Œæ˜¯ E -&gt; Eaug -&gt; E6 -&gt; E7ï¼Œè¿™å››ä¸ªå’Œå¼¦çš„ç»„æˆéŸ³åˆ†åˆ«æ˜¯ï¼š å’Œå¼¦ ç»„æˆéŸ³ï¼ˆé¦–è°ƒï¼‰ ç»„æˆéŸ³ï¼ˆå›ºå®šè°ƒï¼‰ E 1ã€3ã€5 Eã€#Gã€B Eaug 1ã€3ã€#5 Eã€#Gã€#B(C) E6 1ã€3ã€5ã€6 Eã€#Gã€Bã€#C E7 1ã€3ã€5ã€b7 Eã€#Gã€Bã€D è§‚å¯Ÿè¿™äº›å’Œå¼¦çš„ç»„æˆéŸ³ï¼Œå¯¹æ¯”ä¸€ä¸‹æ‰€å¼¹å¥çš„éŸ³ç¬¦ï¼Œå…¶å®žåœ¨è¿™æ®µè¿›è¡Œä¸­éšè—ç€ä¸€æ¡æ—‹å¾‹çº¿ï¼š5 -&gt; #5 -&gt; 6 -&gt; b7ï¼ˆä¹Ÿå³ï¼šB -&gt; #B(C) -&gt; #C -&gt; Dï¼‰ï¼Œä»”ç»†è§‚å¯Ÿä¸‹ï¼Œå¯ä»¥å‘çŽ°è¿™äº›éŸ³å‘ˆåŠéŸ³çš„å…³ç³»å‘é«˜é€’è¿›ã€‚åŒæ—¶æ¢ä¸ªè§’åº¦ï¼Œå¯ä»¥ç†è§£æˆè¿™å››ä¸ªå°èŠ‚åœ¨ä¸æ–­çš„æ”¹å˜ E è¿™ä¸ªä¸»å’Œå¼¦çš„ 5 éŸ³ã€‚è¿™ç§æŠ€å·§æœ‰ç‚¹ç±»ä¼¼ BASS LINE çš„ç¼–å†™æŠ€å·§ï¼Œä½†è¿™é‡Œå¹¶ä¸æ˜¯ BASS éŸ³ï¼Œå®žé™…ä¸Šï¼Œåœ¨ã€Šæ°‘è°£å‰ä»–è€ƒçº§æ•™ç¨‹ã€‹è¿™æœ¬ä¹¦çš„ç¬¬ä¸ƒç« æåˆ°è¿‡ï¼Œè¿™æ˜¯ä¸€ç§å«åšâ€œClichesâ€çš„æŠ€å·§ï¼Œå³åœ¨ä¸€ä¸ªå’Œå¼¦çš„æ ¹éŸ³æˆ–äº”éŸ³ä¸Šä»¥åŠéŸ³æˆ–çº§è¿›çš„æ–¹å¼ä½œä¸Šè¡Œæˆ–ä¸‹è¡Œã€‚ å¦å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªè¦æ³¨æ„çš„åœ°æ–¹ï¼šåœ¨æ¼”å¥ E6 å’Œå¼¦æ—¶ï¼Œå¹¶æ²¡æœ‰å¼¹è¯¥å’Œå¼¦çš„ 5 éŸ³ï¼Œå®žé™…å¼¹å¥çš„å…¶å®žæ˜¯ #Cm/E è¿™ä¸ªå’Œå¼¦ï¼Œä½†è¿™é‡Œç†è§£æˆ E6 å’Œå¼¦æ›´è´´åˆ‡ï¼Œä¹Ÿæ›´ä¾¿äºŽç†è§£ã€‚ ç¬¬äºŒéƒ¨åˆ†ç¬¬äºŒéƒ¨åˆ†çš„å’Œå£°è¿›è¡Œæ˜¯ï¼šA -&gt; Am -&gt; #Gm7 -&gt; #C7 -&gt; #Fm7 -&gt; #Fm7b5 -&gt; #Gm7 -&gt; #C7 -&gt; #Fm7 -&gt; B7sus4add9ï¼Œä»Žå’Œå¼¦çº§æ•°ç†è§£ï¼Œä¹Ÿå°±æ˜¯ï¼šâ…  -&gt; â… m -&gt; â…¢m7 -&gt; â…¥7 -&gt; â…¡m7 -&gt; â…¡m7b5 -&gt; â…¢m7 -&gt; â…¥7 -&gt; â…¡m7 -&gt; â…¤7sus4add9ã€‚ä¸»æ­Œéƒ¨åˆ†çš„ç»†èŠ‚å¾ˆå¤šï¼Œå±•å¼€å‡ ç‚¹ï¼š é¦–å…ˆæ˜¯ A -&gt; Am çš„è¿›è¡Œï¼Œè¿™é‡Œå¯ä»¥ç†è§£ä¸ºå€Ÿç”¨äº†åŒå e å°è°ƒçš„å››çº§å’Œå¼¦ Amï¼Œè¿™ç§å’Œå¼¦æ··åˆæˆ–è°ƒå¼çš„å†…è½¬çŽ°è±¡æˆ‘ä»¬å¯ä»¥ç§°å…¶ä¸ºå¹³è¡Œå¤§å°è°ƒäº’è½¬æˆ–å¹³è¡Œè°ƒå†…äº’æ¢ã€‚é‚£ä¸ºä»€ä¹ˆå¯ä»¥å€Ÿç”¨å‘¢ï¼Ÿä»Žç»„æˆéŸ³ä¸Šåˆ†æžï¼Œè¿™ä¸¤ä¸ªå’Œå¼¦å…¶å®žåªå·®äº†ä¸€ä¸ªéŸ³ã€‚åŒæ—¶ï¼Œåœ¨å®žé™…æ¼”å¥ä¸­ï¼Œ2 å¼¦ä¸Šæ¼”å¥çš„éŸ³ç¬¦æž„æˆä¸€ä¸ªçŸ­æš‚çš„åŠéŸ³ä¸‹è¡Œï¼Œè¿™ä¸Žå‰é¢æåˆ°çš„â€œClichesâ€æŠ€å·§æœ‰ç‚¹å¼‚æ›²åŒå·¥çš„æ„Ÿè§‰ðŸ˜‚ã€‚ #Gm7 æ˜¯ â…¢m7 å’Œå¼¦ï¼Œè€Œå‰é¢æåˆ°çš„ Am å…¶å®žåœ¨æ­Œæ›²ä¸­åº”å±žäºŽ â…£ çº§å’Œå£°ã€‚æ‰€ä»¥ï¼Œè¿™é‡Œ â…£ çº§å’Œå£°ä¸Ž â…¢m çš„è¡”æŽ¥å¹¶ä¸æ˜¯å¾ˆå’Œè°ï¼Œä½†ç”±äºŽå‰é¢çš„ A -&gt; Am è°ƒå¼å†…è½¬ï¼Œæ­¤æ—¶æ­£å¥½éœ€è¦è¿™æ ·ä¸€ä¸ªæŠŠæ­Œæ›²çš„è°ƒå¿«é€Ÿå¹¶å¼ºåŠ›çš„æ‰­è½¬åˆ° E å¤§è°ƒä¸Šæ¥çš„å’Œå¼¦ï¼Œé‚£ä¹ˆ #Gm7 åˆ™å®Œç¾Žçš„å®Œæˆäº†è¿™ä¸ªä»»åŠ¡ã€‚ å¤§å¤šæ•°çš„æµè¡Œæ­Œæ›²ä¸­ä¼šä½¿ç”¨ â…¢m -&gt; â…¥m -&gt; â…¡m -&gt; V çš„å’Œå£°èµ°å‘æ¥ä½¿æ­Œæ›²è¿›å…¥ä¸€ç§æ›´å©‰è½¬çš„è¡¨è¾¾ï¼Œå®žé™…æ˜¯åˆ©ç”¨äº† â…¢ çº§å’Œå£°çš„ç‰¹ç‚¹ï¼Œè¿™é¦–æ­Œæ‰€ä½¿ç”¨çš„ #Gm7 å’Œå¼¦ä¹Ÿæ˜¯å¦‚æ­¤ã€‚ #Fm7(â…¡) å¯ä»¥ä½œä¸º A(â…£) çš„ä»£æ›¿å’Œå¼¦ï¼Œå› ä¸º â…¡ å’Œ â…£ å…¶å®žåªå·®äº†ä¸€ä¸ªéŸ³ï¼šâ…¡(2, 4, 6) å’Œ â…£(4, 6, 1)ã€‚ #Fm7 -&gt; #Fm7b5ï¼Œä¹Ÿå¯ä»¥ç†è§£ä¸ºâ€œClichesâ€æŠ€å·§ã€‚ #C7 æ˜¯ #F å¤§è°ƒçš„å±ž 7 å’Œå¼¦ï¼Œåœ¨è¿™é‡Œä½œä¸ºâ€œæ¬¡å±žå’Œå¼¦â€ï¼ˆæ¬¡å±žå’Œå¼¦ä¹Ÿå±žäºŽä¸€ç§ç¦»è°ƒå’Œå¼¦ï¼Œå®ƒç»å¸¸è¢«ä½¿ç”¨åœ¨å¤§è°ƒï¼ˆæˆ–å°è°ƒï¼‰æ­Œæ›²çš„ â… ã€â…¡ã€â…¢ã€â…£ã€â…¤ çº§å’Œå¼¦ä¸­ï¼‰å‡ºçŽ°ï¼Œç›®çš„æ˜¯ä¸ºäº†è¡”æŽ¥ #Fm7 è¿™ä¸ª E å¤§è°ƒçš„ â…¡m7 å’Œå¼¦ã€‚ â€”â€” æŒç»­æ›´æ–°ingðŸ˜ª â€”â€”]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024_3_æœˆæ€»ç»“]]></title>
    <url>%2F2024%2F04%2F01%2F2024-3-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å¥½æ¶ˆæ¯ï¼Œè¿™å‘¨æ¸…æ˜ŽèŠ‚è¦æ”¾å‡äº†ðŸ˜‰ å¤ªèªæ˜Ž - é™ˆç»®è´žYour browser does not support the audio tag. è¿™æ®µæ—¶é—´ä¸€ç›´åœ¨ç»ƒä¹ è¿™é¦–æ­Œ~ å¤©æ°”é€æ¸å›žæš–äº†ï¼Œåˆåˆ°äº†ä¸‡ç‰©å¤è‹ã€é˜³å…‰æ˜Žåªšã€æ˜¥æš–èŠ±å¼€çš„å­£èŠ‚äº†~ðŸ˜‚ è¿˜æ˜¯è€è§„çŸ©ï¼Œå…ˆè¯´è¯´å·¥ä½œä¸Šçš„äº‹æƒ…ã€‚è¿™ä¸ªæœˆæœ‰ä¸€ä¸ªæ¯”è¾ƒé‡è¦çš„å•å­ï¼Œå±žäºŽæ˜¯é¢†å¯¼ç›´æŽ¥å‘è¯è¦åšçš„äº‹æƒ…äº†ï¼Œæ®è¯´è¿˜æ˜¯å¸¦æœ‰ ZZ è‰²å½©çš„ä»»åŠ¡ï¼ˆæˆ‘ï¼šðŸ˜¶...ï¼‰ã€‚è™½ç„¶å¿ƒé‡Œç•¥æ— è¯­ï¼Œä½†è¯¥å¹²çš„äº‹æƒ…å’±è¿˜æ˜¯æŒ‰éƒ¨å°±ç­çš„å¥½å¥½å¹²ðŸ˜‹ã€‚ä¸è¿‡ï¼Œå¥½åœ¨ä»£ç æœ¬èº«ä¸éœ€è¦åšå¤ªå¤šçš„ä¿®æ”¹ï¼ŒåŽŸå…ˆä»£ç çš„åŠŸèƒ½å°±å·²ç»å¾ˆå®Œå–„äº†ï¼ŒåŸºæœ¬ä¸Šæ»¡è¶³äº†ä¸šåŠ¡éœ€æ±‚ï¼Œè€Œæˆ‘åªæ˜¯ä¿®å¤äº†å…¶ä¸­æŸäº› bugï¼Œä»¥ç¡®ä¿èƒ½æ›´å¥½çš„è¾¾åˆ°ä¸šåŠ¡éœ€æ±‚ã€‚ è€å®žè®²ï¼Œæ‹¿çŽ°åœ¨çš„è‡ªå·±ä¸ŽåŽ»å¹´çš„è‡ªå·±ç›¸æ¯”ï¼Œç¡®å®žæœ‰å¾ˆå¤§çš„è¿›æ­¥ï¼Œè¿™ä¸€ç‚¹æ˜¯è‡ªå·±èƒ½åˆ‡èº«ä½“ä¼šåˆ°çš„ï¼Œä¹Ÿè®¸è¿™å°±æ˜¯ä¸€å¹´çš„è¿›æ­¥å§ã€‚ å…·ä½“æ¥è®²ï¼Œä¸ªäººè®¤ä¸ºä¸»è¦ä½“çŽ°åœ¨ä¸‰ä¸ªæ–¹é¢ï¼š å¯¹é¡¹ç›®çš„ç†Ÿæ‚‰ç¨‹åº¦ ä¸ªäººç¼–ç èƒ½åŠ›çš„æå‡ åˆ†æžã€è§£å†³é—®é¢˜çš„èƒ½åŠ› å¦å¤–ï¼Œä¸ªäººè®¤ä¸ºä»¥ä¸Šä¸‰ä¸ªæ–¹é¢ç›¸è¾…ç›¸æˆï¼ŒåŒç­‰é‡è¦ï¼Œå…±åŒæž„æˆäº†æˆ‘ä¸ªäººçš„ç»¼åˆèƒ½åŠ›ã€‚ å¥½äº†ï¼Œå…³äºŽå·¥ä½œæ–¹é¢çš„äº‹æƒ…å°±è¯´è¿™äº›ã€‚ ç¬¬äºŒä¸ªæ˜¯å­¦ä¹ ï¼Œè¿™ä¸ªæœˆçœ‹äº†ä¸€äº›è‰ºæœ¯å’Œå¿ƒç†ç›¸å…³çš„è¯¾ç¨‹ï¼Œå¯¹æŠ€æœ¯çŸ¥è¯†çš„å­¦ä¹ å°‘äº†äº›çƒ­å¿±ã€‚å°½ç®¡è¿™äº›éƒ½æ˜¯è®¡åˆ’å†…çš„äº‹æƒ…ï¼Œä½†æ˜¯è¿˜æ˜¯è§‰å¾—æœ‰ç‚¹å¿ƒç†ä¸é€‚ï¼ˆå› ä¸ºæ²¡æ—¶é—´å­¦ä¹ è®¡ç®—æœºå•¦~ï¼‰ï¼Œå¹¶ä¸”è§‰å¾—æ—¶é—´ä¸å¤Ÿç”¨å•Šã€‚ å¦å¤–ï¼Œã€Šç½ªä¸Žç½šã€‹ å·²ç»è¯»å®Œï¼Œå¹¶ä¸”ä¹Ÿå†™äº†ä¸€ç‚¹ä¹¦è¯„ã€‚æœ¬æ¥æ‰“ç®—è¿žç€ç»§ç»­å¼€å‘ï¼Œè¯»é»‘å¡žçš„ã€Šå¾·ç±³å®‰ã€‹å’Œã€Šæ‚‰è¾¾å¤šã€‹ï¼Œä½†ç›®å‰è¿›åº¦åªåˆ°äº†ã€Šå¾·ç±³å®‰ã€‹çš„ä¸€åŠï¼Œäº‰å–å››æœˆä»½ä¸¤æœ¬è¯»å®Œå§ã€‚å€¼å¾—ä¸€æçš„æ˜¯ï¼Œã€Šå¾·ç±³å®‰ã€‹è¿™æœ¬å°è¯´çš„è¯­è¨€çœŸå¦‚è¯—æ­Œä¸€èˆ¬ï¼Œä¼˜ç¾Žè€Œåˆå¯Œæœ‰å“²ç†ï¼Œæœ‰äº›åœ°æ–¹è®©äººä¸æ±‚ç”šè§£ï¼Œä¹Ÿè®¸æ˜¯éœ€è¦ä¸€å®šçš„é˜…åŽ†å§ã€‚ æœ€åŽå°±æ˜¯ç»ƒç´äº†ï¼Œå…¶å®žä¹Ÿå°±æ˜¯ä¸Šé¢æåˆ°çš„ã€Šå¤ªèªæ˜Žã€‹ï¼Œè¿™ä¸ªæœˆæ˜¯ç›˜è¿‡æ¥ç›˜è¿‡åŽ»ï¼Œå¼¹äº†å¾ˆå¤šéäº†ðŸ˜‚ã€‚ä¼´å¥å·²ç»ç”¨å¸¦è¿‡æ¥çš„å£°å¡å½•å¥½äº†ï¼Œè‡ªå·±ä»”ç»†å¬äº†ä¸‹ï¼Œè™½æœ‰ä¸€ç‚¹ç‘•ç–µï¼Œä½†åŸºæœ¬è¿˜ç®—æ»¡æ„ï¼Œä¸è¿‡æœ€å¥½è¿˜æ˜¯é‡å½•ä¸‹ã€‚ ç»†ç»†ç®—æ¥ï¼Œè¿™é¦–æ­Œå·²ç»ç»ƒäº†å¾ˆä¹…äº†ã€‚å¦‚æžœåªæ˜¯æŠŠè°±å­å­¦ä¼šï¼Œå…¶å®žå¾ˆå¿«å°±èƒ½ç»ƒå¥½ã€‚ é‚£ä¸ºå•¥è¿˜è¦åœç•™è¿™ä¹ˆä¹…å‘¢ï¼Ÿ ä¸€æ˜¯å¼¹å”±é…åˆè¿˜æ²¡ç»ƒå¥½ï¼Œhah~ðŸ˜;äºŒæ˜¯è¿™é¦–æ­Œçš„å‰ä»–ç¼–é…å¾ˆå€¼å¾—å­¦ä¹ ã€‚ ä»¥ä¸Šä¸¤æ–¹é¢çš„åŠŸå¤«éƒ½æ²¡åšåˆ°ä½ï¼ŒçœŸä¸èƒ½è¯´ç®—æ˜¯æŠŠè¿™é¦–æ­Œâ€œå­¦ä¼šâ€äº†ã€‚ å¥½äº†ï¼Œå°±è¿™äº›å§ã€‚ æœ€åŽï¼Œæ•´ä½“æ¥è®²ï¼Œä¸‰æœˆä»½æ˜¯è¿‡çš„æ¯”è¾ƒæ…µæ‡’ã€é—²æ•£çš„ä¸€ä¸ªæœˆðŸ˜‚ï¼Œå¯èƒ½æ˜¯è‡ªå·±æ‡ˆæ€ äº†å§ã€‚ä¸ºäº†æ”¹å˜è¿™æ ·çš„çŽ°çŠ¶ï¼Œå››æœˆä»½å¼€å§‹ä¹‹å‰ï¼Œè‡ªå·±ä¼šå…ˆåˆ—ä¸€ä¸ªæ¸…å•ï¼Œçœ‹çœ‹æœ‰å“ªäº›æ‹–äº†å¾ˆä¹…æ²¡æœ‰å¹²çš„äº‹æƒ…ï¼Œèµ¶ç´§åŽ»å¹²ä¸€æŠŠðŸ˜¤ã€‚ å°±é…±ï¼Œä¸‹ä¸ªæœˆè§~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2024_1-2æœˆæ€»ç»“]]></title>
    <url>%2F2024%2F02%2F25%2F2024-1-2%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä»Šå¤© SH ç«Ÿç„¶ä¸‹äº†ä¸€ä¼šå°é›ªï¼Œå¯æƒœæ²¡è¿‡å¤šä¹…å°±åŒ–å®Œäº†... æœˆåŠå¼¯ - å¼ å­¦å‹Your browser does not support the audio tag. è¿™é¦–æ­Œçš„æ—‹å¾‹çœŸå¥½ï¼Œä½†æˆ‘æœ€å–œæ¬¢çš„è¿˜æ˜¯ä¼´å¥ä¸­çš„å¼¦ä¹ï¼ˆåŒ…æ‹¬çŽ‰ç½®æµ©äºŒçš„ç‰ˆæœ¬ï¼‰ï¼Œåƒè¨€ä¸‡è¯­ç»˜æˆä¸€ç¼•ç¼•çš„æƒ…ä¸ï¼Œæ²¿ç€é¢¤åŠ¨çš„ç´å¼¦ä¸æ–­å€¾è¯‰... å¥½äº†ï¼Œå›žåˆ°æ­£é¢˜æ¥ï¼Œè¿™æ¬¡ä¸€ä¸‹å­å°†ä¸¤ä¸ªæœˆçš„æ€»ç»“æ”¾åœ¨ä¸€èµ·äº†ï¼Œä¸»è¦åŽŸå› æ˜¯è§‰å¾—è‡ªå·±æ¯æ¬¡å†™çš„è·Ÿæµæ°´è´¦ä¸€æ ·ï¼Œæ²¡ä»€ä¹ˆè¥å…»ï¼Œä¸å¦‚ä¸å†™äº†ï¼Œhah~ã€‚ä¸è¿‡ï¼Œè½¬å¤´ä¸€æƒ³ï¼Œä¹Ÿè®¸åªæ˜¯å› ä¸ºæ‡’...å¥½å§ðŸ˜‚ ä¸€ã€äºŒæœˆçš„å·¥ä½œå…¶å®žæ²¡ä»€ä¹ˆè¯´å¤´ï¼Œéƒ½æ˜¯æŒ‰éƒ¨å°±ç­çš„å·¥ä½œï¼Œæœ¬èº«åˆ°äº†å¹´æœ«ï¼Œå°±ä¸åº”è¯¥æœ‰å¤ªå¤šçš„äº‹æƒ…äº†ï¼Œå®¶å®¶æˆ·æˆ·éƒ½å¿™ç€è¿‡å¹´å‘¢ã€‚ å†æŠŠç›®å…‰æ”¾åˆ°å­¦ä¹ ä¸Šï¼Œä¸€æœˆä»½çœ‹äº†ä¸€äº› Java çš„è¯¾ç¨‹ï¼Œå¯æƒœæ²¡çœ‹å®Œï¼Œç›®å‰å‡†å¤‡æŽ¥ç€çœ‹ï¼Œå°½å¿«çœ‹å®Œå§ã€‚åŒæ—¶ï¼ŒäºŒæœˆè¿‡å®Œå¹´æ¥äº†ä¹‹åŽï¼Œåˆåœ¨ MOOC ä¸Šç»™è‡ªå·±é€‰äº†å¥½å‡ é—¨è¯¾ï¼Œå½“ç„¶äº†ï¼Œè¿™æ¬¡ä¸ä»…ä»…åªæœ‰è®¡ç®—æœºç±»çš„è¯¾ç¨‹ã€‚æ‰€ä»¥ï¼ŒæŽ¥ä¸‹æ¥çš„è®¡åˆ’ï¼Œå°±æ˜¯æŠŠè¿™äº›è¯¾ç¨‹å­¦å®Œã€‚ å¦å¤–ï¼Œè¿™ä¿©æœˆä¸€ç›´åœ¨çœ‹é™€æ€å¦¥è€¶å¤«æ–¯åŸºçš„ã€Šç½ªä¸Žç½šã€‹ï¼Œè¿™æ˜¯ä¸€æœ¬é•¿ç¯‡å°è¯´ã€‚åˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»è¯»äº†å¤§çº¦ç™¾åˆ†ä¹‹å…­åã€‚è€å®žè®²ï¼Œé•¿ç¯‡å°è¯´è¯»çš„æœ‰ç‚¹ç´¯ + æ— èŠï¼Œå¦‚æžœæ˜¯æ‚æ–‡è·ŸçŸ­ç¯‡ï¼Œæˆ‘ä¼°è®¡è¿™ä¿©æœˆæˆ‘èƒ½çœ‹å®Œå¥½å‡ æœ¬äº†ã€‚é™€æ°è¿™æœ¬ä¹¦å†™çš„ä¸é”™ï¼Œä½†æœ‰äº›åœ°æ–¹æ˜¯çœŸçš„åºŸè¯ï¼Œè€Œä¸”ä¿„å¼äººåå¾ˆé•¿ï¼Œä¸å¤ªå¥½è®°ï¼Œç”šè‡³è¿˜ä¼šæœ‰æ˜µç§°ã€‚æ€»ä¹‹ï¼Œå¾—å°½å¿«æŠŠè¿™æœ¬ä¹¦è¯»å®Œï¼ŒåŽ»å¹´ä¸€å…±æ‰è¯»å®Œä¹æœ¬ä¹¦ï¼Œå¾—èµ¶èµ¶è¿›åº¦ã€‚ðŸ˜  è¿˜æœ‰ç»ƒç´è®¡åˆ’ï¼Œè¿™ä¿©æœˆç»ƒçš„æ¯”è¾ƒå¤šï¼Œä¸€å…±æ‰’äº†ä¸‰å¼ è°±ï¼Œåšäº†ä¸€å¼ åŽŸæ¥æ‰’è¿‡çš„è°±ï¼Œä¸€å…±æ˜¯å››å¼ ã€‚ç›®å‰åœ¨ç»ƒä¹ çš„æ­Œæ›²æ˜¯é™ˆè€å¸ˆçš„ã€Šå¤ªèªæ˜Žã€‹ï¼Œä¸ºä»€ä¹ˆè¦ç»ƒè¿™é¦–æ­Œå‘¢ï¼Ÿå“ˆå“ˆï¼Œä¸€æ˜¯è¿™é¦–æ­Œè€æ˜¯å‡ºçŽ°åœ¨æˆ‘çš„ B ç«™é¦–é¡µï¼Œå¤©å¤©çœ‹è§ï¼Œæœ¬æ¥ä¸æƒ³ç»ƒä¹Ÿå˜å¾—æƒ³ç»ƒäº†ï¼›äºŒæ˜¯ï¼Œè¿™é¦–æ­Œæœ‰ç‚¹éš¾ï¼Œæ­£å¥½å¯ä»¥ç”¨æ¥å½“ä½œç»ƒä¹ æ›²ã€‚å®žé™…ä¸Šï¼Œã€Šå¤ªèªæ˜Žã€‹è¿™é¦–æ­Œç»ƒåˆ°çŽ°åœ¨ï¼Œå·²ç»å¿«å®Œäº†ï¼Œæ•´ä½“æ„Ÿè§‰ç»†èŠ‚å¾ˆå¤šï¼Œéƒ¨åˆ†å°èŠ‚çš„è¡”æŽ¥è¿˜éœ€è¦å†å¤šç»ƒç»ƒï¼Œè¿™é‡Œå°±ä¸å±•å¼€äº†ï¼Œå°½å¿«ç»ƒå®Œå§ã€‚ æœ€åŽå›žåˆ°ç”Ÿæ´»ä¸Šï¼Œä¸€ã€äºŒæœˆå¤©æ°”å†·äº†è®¸å¤šï¼Œä½†å¥½åœ¨è‡ªå·±æœ‰åšå¥½ä¿æš–ï¼Œåˆ°ç›®å‰ä½ç½®è¿˜æ²¡æœ‰è¿‡æ„Ÿå†’ã€æµæ¶•ç­‰ç—‡çŠ¶ã€‚è¿‡å¹´æœŸé—´ï¼Œè€è€å®žå®žçš„åœ¨å®¶ä¼‘æ¯ï¼Œå•¥ä¹Ÿæ²¡å¹²ï¼Œåƒå¸­æ²¡æœ‰åŽ»ï¼Œèµ°äº²æˆšä¹ŸåŸºæœ¬æ²¡æœ‰åŽ»ã€‚ä½†æ˜¯ï¼Œæ—¶é—´è¿˜æ˜¯è¿‡çš„å¾ˆå¿«ï¼Œå¥½åƒä¸Šä¸€ç§’è¿˜åœ¨å›žå®¶çš„ç«è½¦ä¸Šï¼Œä¸‹ä¸€ç§’å°±å·²ç»å›žæ¥ä¸Šç­äº†ã€‚ä¸è¿‡ï¼Œæ²¡äº‹ï¼Œå¾€åŽè§é¢çš„æ—¶é—´å¤šç€å‘¢ã€‚å¯æƒœçš„æ˜¯ï¼ŒåŽŸæœ¬æ‰“ç®—å›žå®¶å¥½å¥½åšå‡ é¡¿é¥­çš„ï¼Œç»“æžœä¸€é¡¿æ²¡åšï¼Œæƒ­æ„§å•Šï¼Œå“ˆå“ˆï¼Œå¾—æ‰¾æ—¶é—´æŠŠæ¯äº²çš„å‘³é“å­¦åˆ°æ‰‹é‡Œï¼Œä¸ç„¶ä»¥åŽè‡ªå·±æƒ³åƒçš„æ—¶å€™ï¼Œæ²¡å¾—åƒäº†ã€‚ å¥½äº†ï¼Œå°±è¯´è¿™ä¹ˆå¤šå§ã€‚ PSï¼šä¸€æœˆåº•å…¬å¸åƒå¹´é¥­çš„æ—¶å€™ï¼Œæˆ‘ç«Ÿç„¶ä¸­å¥–äº†ï¼Œè¿™æ˜¯äººç”Ÿç¬¬ä¸€æ¬¡ä¸­å¥–ï¼ðŸ¤£PPSï¼šæ¢äº†ä¸ªæ–°å¤´åƒ~]]></content>
  </entry>
  <entry>
    <title><![CDATA[2023_å¹´æœ«å°ç»“]]></title>
    <url>%2F2024%2F01%2F07%2F2023-%E5%B9%B4%E6%9C%AB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[çŽ°åœ¨æ˜¯ 2024 äº†å“¦ðŸŽ‰~ æˆ‘æƒ³è¦çš„æ„Ÿè§‰ - å¼ éœ‡å²³Your browser does not support the audio tag. çŽ°åœ¨æ˜¯ 2024 å¹´ç¬¬ä¸€å‘¨çš„å‘¨æ—¥ï¼Œæœ¬æ¥ï¼Œè¿™ç¯‡æ–‡ç« åº”è¯¥å‡ºçŽ°åœ¨å…ƒæ—¦é‚£å¤©çš„ï¼Œä½†æ˜¯é‚£å¤©å¿™ç€å¼¹ç´åŽ»äº†ï¼Œå°±ææµ…äº†ï¼ŒçŽ°åœ¨é‡æ–°å®Œæˆã€‚ é—²è¯å°‘è¯´ï¼Œèµ¶ç´§å›žå¤´çœ‹çœ‹ 2023 ä¸€å¹´åˆå¹²äº†é‚£äº›å‚»äº‹ðŸ˜‚ã€‚ 1 - 2 æœˆåŽ»å¹´çš„è¿™æ—¶å€™ï¼Œåˆšåˆšé˜³åº·ï¼Œå°±å›žåˆ°å…¬å¸ä¸Šç­äº†ã€‚å°½ç®¡å¯¹å·¥ä½œè¿˜ä¸æ˜¯å¾ˆç†Ÿæ‚‰ï¼Œä½†ä¹Ÿåœ¨æ…¢æ…¢çš„æŽ¨è¿›ä¸­ã€‚æ˜¥èŠ‚å‡æœŸï¼Œå°±æ˜¯å›žå®¶äº†ã€‚åˆ°å®¶åŽï¼Œåˆåœ¨å®¶çŸ­æš‚çš„åœç•™äº†å‡ å¤©ï¼Œåˆåƒåˆ°äº†å®¶é‡Œçš„å‘³é“ï¼Œå¾ˆæ€€å¿µã€‚ å›žåˆ° SH åŽï¼Œå°±ç»§ç»­ä¸Šç­ï¼Œè¿˜æœ‰æ‰¾æˆ¿å­ï¼Œè¿™ä¹‹é—´åˆå‘ç”Ÿäº†ä¸€ç³»åˆ—çš„äº‹æƒ…ï¼Œä½†å¥½åœ¨éƒ½å¹³ç¨³åº¦è¿‡äº†ã€‚ 3 - 4 æœˆè¿™ä¿©æœˆï¼Œç¨å¾®æœ‰ç‚¹å¿™ï¼Œå·¥ä½œåœ°ç‚¹ä¹Ÿæ¬åˆ°äº†å¦å¤–ä¸€ä¸ªå›­åŒºï¼Œæ­¤æ—¶æ­£å¥½èµ¶ä¸Šäº†æ—©æ¨±å¼€æ”¾ï¼Œæ–°å›­åŒºçš„æ¨±èŠ±ðŸŒ¸éšç€æ˜¥é£Žé£žèˆžåœ¨ç©ºä¸­ï¼Œååˆ†ç¾Žä¸½ã€‚ ä¹Ÿæ˜¯åœ¨è¿™ä¸ªæ—¶é—´æ®µï¼Œå¯¹å·¥ä½œä¸Šé¡¹ç›®çš„äº†è§£æ›´åŠ æ·±å…¥äº†ä¸€äº›ã€‚åŒæ—¶ï¼Œè¿™ä¿©æœˆè¿˜çœ‹å®Œäº† Tinyhttpd è¿™ä¸ªå¤è€è€Œåˆç»å…¸çš„å°é¡¹ç›®ï¼Œé‡æ–°æ¸©æ•…äº†ä¸‹ C è¯­è¨€ï¼Œå¹¶ä¸”é‡æ–°å¼€å§‹äº† Nand2tetris è¿™ä¸ªè¯¾ç¨‹ã€‚ 5 - 6 æœˆè¿™ä¿©æœˆï¼Œä¹Ÿæ¯”è¾ƒå¿™ï¼Œä½†å¥½åœ¨å·¥ä½œéƒ½æœ‰æƒŠæ— é™©çš„å®Œæˆäº†ã€‚ å”¯ä¸€è®©è‡ªå·±ä»‹æ€€çš„äº‹æƒ…å°±æ˜¯èº«ä½“ä¸èˆ’æœâ˜¹ï¼Œå°½ç®¡åŽé¢æœ‰æ‰€æ¢å¤ï¼Œä½†æ˜¯å¿ƒé‡Œå¾ˆçƒ¦ã€‚èº«ä½“å¥åº·çœŸçš„å¾ˆé‡è¦å•Šï¼Œå“ªæ€•åªæœ‰ä¸€ç‚¹ç‚¹ä¸èˆ’æœçš„æ„Ÿè§‰ï¼Œéƒ½å¾ˆçƒ¦äººï¼Œè®©äººå¿ƒç¥žä¸å®çš„ã€‚ å¥½æ¶ˆæ¯æ˜¯ï¼ŒNand2tetris ä¸ŠåŠéƒ¨åˆ†çš„é¡¹ç›®å·²ç»æ˜¯å…¨éƒ¨å®Œæˆäº†ï¼Œå¯¹åº”çš„ blog ä¹Ÿéƒ½å†™å®Œäº†ï¼Œç”šè‡³åˆ°å…­æœˆç»“æŸï¼Œè¿™ä¸ªè¯¾ç¨‹å·²ç»è¿›è¡Œåˆ°ç¬¬åç« äº†ï¼Œè¶Šå­¦è¶Šè§‰å¾—æœ‰è¶£ðŸ‘€ã€‚ åŒæ—¶ï¼Œè¿˜æŠŠåŽŸæ¥çœ‹è¿‡çš„ C++ è¯¾ç¨‹åˆçœ‹äº†ä¸€éï¼Œåˆæœ‰äº†ä¸€äº›ä¸ä¸€æ ·çš„æ”¶èŽ·ã€‚ 7 - 8 æœˆæš‘æœŸä¸ç®—å¾ˆå¿™ï¼Œä½†æ˜¯æ²¡æœ‰é•¿å‡æœŸï¼Œè¿˜æ˜¯ä¼šè§‰å¾—ä¸Šç­æ¯”è¾ƒç´¯ã€‚ è¿™ä¿©æœˆçœ‹äº†å¾ˆå¤š Linux/C ç›¸å…³çš„è§†é¢‘ï¼Œå­¦åˆ°äº†å¾ˆå¤šä¸œè¥¿ï¼Œç‰¹åˆ«æ˜¯å¯¹æŒ‡é’ˆçš„ç†è§£ã€‚ å¦å¤–ï¼Œå› ä¸ºå¤©æ°”çƒ­èµ·æ¥äº†ï¼Œè¿™ä¿©æœˆæ¸¸æ³³ðŸŠâ€çš„æ¬¡æ•°å¾ˆå¤šï¼Œæ¸¸çš„è¿˜æŒºå¼€ä¸‹çš„ï¼Œå“ˆå“ˆã€‚ä¸è¿‡ï¼Œè¿™ä¿©æœˆå¥½åƒæ¯”è¾ƒå°‘ç»ƒç´... 9 - 10 æœˆè¿™ä¿©æœˆå·¥ä½œä¸Šä¹Ÿä¸ç®—å¿™ï¼Œè¿˜æ˜¯æŒ‰éƒ¨å°±ç­çš„å®Œæˆæ—¥å¸¸ä»»åŠ¡ï¼Œå¦å¤–è¿˜æœ‰ä¸­ç§‹å’Œå›½åº†çš„ä¸¤ä¸ªé•¿å‡ï¼Œå“ˆå“ˆï¼Œä¸€å…±æ”¾äº† 8 å¤©ï¼Œå¾ˆèˆ’æœï¼Œå°±æ˜¯æ—¶å€™è°ƒä¼‘å¾ˆéš¾å—ðŸ˜‚ã€‚ è¿™ä¿©æœˆå¼€å§‹ä¸€é¡¹æ–°çš„è¿åŠ¨â€”â€”å°çƒðŸŽ±ï¼Œè¿˜æŒºæœ‰æ„æ€çš„ï¼Œå“ˆå“ˆã€‚å‰é¢å‡ ä¸ªæœˆçš„é”»ç‚¼ï¼Œå·²ç»æœ‰äº†ä¸€å®šçš„æ”¶èŽ·ï¼Œä½“é‡å¢žåŠ äº†å¤§æ¦‚ 3 - 4 å…¬æ–¤ï¼Œè™½ç„¶è¿˜æ˜¯ç˜¦ï¼Œå“ˆå“ˆã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œä¹æœˆè¯»å®Œäº†ã€ŠThe C Programming Languageã€‹è¿™æœ¬ä¹¦ï¼Œæ”¶èŽ·å¾ˆå¤šã€‚å¦å¤–ï¼Œè¿˜å¼€å§‹äº†ã€Šç»„æˆåŽŸç†ã€‹çš„å­¦ä¹ ã€‚ ç»ƒç´ä¹Ÿåœ¨ç»§ç»­... 11 æœˆå·¥ä½œä¸å¿™ï¼Œå“ˆå“ˆï¼Œæˆ‘å¥½åƒå…¨éƒ¨éƒ½æ˜¯ä¸å¿™...åªèƒ½è¯´æˆ‘æŒ£å¾—å¤ªå°‘ðŸ¤£ è¿™ä¸ªæœˆæŠŠ HIT ç»„æˆåŽŸç†çš„ä¸Šå†Œå·²ç»å­¦å®Œäº†ã€‚ è¶ç€åŒåä¸€ï¼Œè¿˜ç»™è‡ªå·±ä¹°äº†ä¸€äº›è¡£æœå’Œä¸€åŒéž‹å­ï¼Œç©¿èµ·æ¥è‡ªæˆ‘æ„Ÿè§‰è¿˜ä¸é”™ã€‚ 12 æœˆå·¥ä½œè¿˜æ˜¯ä¸å¿™ï¼Œå“ˆå“ˆå“ˆå“ˆðŸ˜‚ï¼ˆæˆ‘çœŸæ€•æˆ‘å¤±ä¸šï¼Œå§æ§½...ï¼‰ è¿™ä¸ªæœˆæœ‰ç‚¹éœ‰ï¼Œæœ¬æ¥æœˆåˆè¿˜è‡ªæˆ‘æé†’ä¸è¦è¢«æ”¯åŽŸä½“æ„ŸæŸ“äº†ï¼Œç»“æžœè¿˜æ˜¯è¢«ç”²æµæ„ŸæŸ“äº†...è€Œä¸”è¿™æ¬¡çš„ç—‡çŠ¶å’ŒåŽ»å¹´çš„æ–°å† å¾ˆåƒï¼ˆå¯¹æœ¬äººè€Œè¨€ï¼‰ï¼Œåˆšå¼€å§‹å—“å­è¿˜ç‰¹åˆ«ç—›ï¼Œè¯éƒ½è¯´ä¸å‡ºæ¥ï¼Œå“ŽðŸ˜”ã€‚ ä¸è¿‡çŽ°åœ¨å·²ç»æ˜¯å¥½äº†ï¼Œå°±æ˜¯æ„Ÿè§‰å—“å­è¿˜æ²¡å®Œå…¨æ¢å¤ï¼Œå”±æ­Œæ„Ÿè§‰æ€ªæ€ªçš„ï¼Œè€Œä¸”å¾ˆå®¹æ˜“èµ·ç—°ã€‚ ä¸è¿‡è¿™ä¸ªæœˆï¼Œæœ€å¼€å¿ƒçš„æ˜¯æœˆåº•å…ƒæ—¦å‡æœŸè·Ÿæœ‹å‹å° z ä¸€èµ·åŽ»æ³¡æ¾¡ï¼Œæ³¡çš„å¾ˆèˆ’æœï¼Œäº‹åŽåˆæ‰“äº†ä¸€ä¸ªå°æ—¶ä¹’ä¹“çƒå’Œä¸¤ä¸ªå°æ—¶å°çƒã€‚è¿™ä¸€ä¸ªå°æ—¶çš„ä¹’ä¹“çƒï¼Œæœ€è®©æˆ‘å¼€å¿ƒï¼Œçœ‹ç€é¢å‰çš„æœ‹å‹å° z æŒ¥èˆžä¹’ä¹“çƒæ‹çš„èº«å½±ï¼Œè„‘æµ·ä¸­æ²‰ç¡çš„è®°å¿†ä¸€ä¸‹å­å°±è¢«å”¤é†’äº†ã€‚æ›¾ç»ï¼Œåˆä¸­æ ¡å›­ä¹’ä¹“çƒå°æ˜¯æˆ‘ä»¬å‡ ä¸ªå°ä¼™ä¼´æœ€çˆ±çš„çŽ©ä¹åœºæ‰€ã€‚è€Œè„‘æµ·ä¸­çš„èº«å½±ä¹Ÿå¼€å§‹ä¸ŽçŽ°åœ¨é¢å‰çš„æœ‹å‹å° z å¼€å§‹é‡åˆåœ¨ä¸€èµ·ï¼Œæˆ‘ç”šè‡³ä¸å‡æ€ç´¢çš„å°†äºŒè€…çš„åŠ¨ä½œéƒ½é‡å åœ¨äº†ä¸€èµ·ã€‚åäº”å¹´å•Šï¼Œåäº”å¹´è¿‡åŽ»äº†ï¼Œä»–çš„åŠ¨ä½œç«Ÿç„¶è¿˜è·ŸåŽŸæ¥ä¸€è‡´ã€‚ è¿™ä¸€ä¸ªå°æ—¶æˆ‘çœŸçš„è¿‡çš„å¾ˆå¼€å¿ƒ...ðŸ˜Œ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” è¿™æ˜¯ä¸€æ¡åˆ†å‰²çº¿ â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€” ä¸‹é¢å†ç»Ÿè®¡ä¸€ä¸‹ 2023 è¯»è¿‡çš„ä¹¦å’Œç»ƒè¿‡çš„æ›²å­æˆ–æ­Œå§ ä¹¦ ðŸ“• ã€Šå±€å¤–äººã€‹ï¼Œç¬¬ä¸€æœ¬åŠ ç¼ªçš„ä¹¦ã€‚ ã€Šæ²‰é»˜çš„å¤§å¤šæ•°ã€‹ ã€Šä¹¡åœŸä¸­å›½ã€‹ï¼Œå¥½åƒè§£ç­”äº†å¿ƒä¸­çš„ä¸€äº›ç–‘æƒ‘ï¼Œä½†åˆæœ‰äº†æ–°çš„é—®é¢˜ðŸ˜‚ã€‚ ã€Šé»‘é“æ—¶ä»£ã€‹ ã€Šä¸€åªç‰¹ç«‹ç‹¬è¡Œçš„çŒªã€‹ ã€Šç™½é“¶æ—¶ä»£ã€‹ ã€Šé»„é‡‘æ—¶ä»£ã€‹ ã€ŠThe C Programming Languageã€‹ï¼Œä¸æ„§æ˜¯ C è¯­è¨€ä¹‹çˆ¶çš„ä¹¦ï¼Œæ„Ÿè§‰æ˜¯ä»Šå¹´å–œæ¬¢çš„ä¹¦äº†ðŸ¤”ã€‚ ã€Šæˆ‘ä¸Žåœ°å›ã€‹ï¼Œè¯»çš„æœ‰ç‚¹ç–¼ç—›... æ²¡åˆ°åæœ¬ï¼Œæœ‰ç‚¹å°‘äº†...ðŸ¤ æ­Œ Or æ›² ðŸŽµ ã€ŠOne more time, One more chanceã€‹ï¼ˆèƒ½æ‰¾åˆ°çš„ï¼Œä»Šå¹´æœ€å…ˆå¼€å§‹ç»ƒä¹ çš„æ›²ç›®è®°å½•ï¼Œå°±æ˜¯è¿™ä¸ªäº†ðŸ˜‚ï¼‰ï¼ŒA è°ƒï¼Œå±±å´Žå¤§å”çš„æ­Œï¼ˆä¹Ÿæ˜¯ã€Šæœˆäº®ä¸Žé«˜ä¸½èœã€‹å’Œã€Šç§’é€Ÿäº”åŽ˜ç±³ã€‹çš„æ’æ›²ï¼‰ï¼ŒæŒ‰åŽŸæ›²çš„ç¼–é…ç»ƒä¹ ï¼Œä¸»ã€å‰¯æ­Œçš„å’Œå¼¦è¿›è¡Œéƒ½ç»ƒå®Œäº†ï¼Œç»“å°¾ä¹‹å‰è¿˜æœ‰ä¸€ä¸ª bridge æ²¡ç»ƒã€‚å¦å¤–ï¼Œè¿˜ç»ƒä¹ äº†ä¸€ä¸‹ä¸»ã€å‰¯æ­Œçš„å”±æ³•ï¼Œè‡ªæˆ‘æ„Ÿè§‰è¿˜è¡Œï¼Œçªç„¶å‘çŽ°æ—¥æ–‡æ­Œçš„å’¬å­—å¥½åƒæ¯”è‹±æ–‡æ­Œå¥½æŽŒæ¡ä¸€ç‚¹ï¼ŸðŸ˜è¯è¯´ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯å› ä¸ºä¸‰å››æœˆä»½æ¨±èŠ±ðŸŒ¸ç››å¼€äº†ï¼Œæ‰€ä»¥é‚£æ—¶æƒ³ç»ƒä¹ è¿™ä¸ªðŸ™ˆã€‚ ã€ŠWind songã€‹ï¼ŒD è°ƒï¼Œç”¨çš„æ˜¯æŠ¼å°¾ã€ŠDramaticã€‹ä¸“è¾‘ç‰ˆæœ¬çš„è°±å­ï¼ˆæ®è¯´ä¸“é—¨ä¸ºæžå…‰å†™çš„æ›²å­ï¼‰ï¼Œåˆ°ç›®å‰ä¸ºæ­¢ï¼Œå·²ç»æ˜¯çº¯çº¯çš„è‚Œè‚‰è®°å¿†äº†ï¼ŒåŸºæœ¬å¿˜ä¸æŽ‰äº†ï¼Œå°±æ˜¯è¿˜æœ‰äº›ç»†èŠ‚å¤„ç†çš„ä¸å¥½ï¼Œå¾—å†ç»ƒç»ƒã€‚ ã€Šæˆ‘è¦ä½ ã€‹ï¼ŒA è°ƒï¼Œä»»ç´ æ±çš„æ­Œï¼Œç®€å•ä½†å¾ˆåŠ¨å¬ï¼Œåæ¶ˆæ¯ï¼šæŒ‡æ³•æ‰’äº†æ²¡è®°è°±ï¼ˆå·²ç»å¿˜çš„å·®ä¸å¤šäº†ðŸ˜‘ï¼‰ï¼Œå¥½æ¶ˆæ¯ï¼šå’Œå¼¦è¿›è¡Œæ‰’äº†ï¼Œè®°ä¸‹äº†ðŸ˜‹ã€‚ ã€ŠTychoã€‹ï¼ŒG è°ƒï¼Œç”¨çš„æ˜¯æŠ¼å°¾ã€ŠSTARTING POINTã€‹ä¸“è¾‘çš„è°±å­ï¼Œæ²¡ç»ƒå®Œï¼ŒåŽŸå› æ˜¯ç»ƒçš„æ—¶å€™æ€»è§‰å¾—æ²¡åŠ²ðŸ˜‚ã€‚ ã€ŠRomanceã€‹ï¼Œå¤å…¸å‰ä»–çš„å…¥é—¨æ›²ï¼ˆè™½ç„¶å…¥é—¨ï¼Œä½†æ˜¯ä¹Ÿæ˜¯é¦–åæ°”å¾ˆå¤§çš„å¤å…¸å‰ä»–æ›²å­ï¼‰ï¼Œe å°è°ƒè½¬ E å¤§è°ƒï¼Œé’¢å¼¦çš„å£°éŸ³ç¡®å®žæ²¡æœ‰å°¼é¾™å¼¦å¬èµ·æ¥æŸ”å’Œã€‚ ã€Šå¥¹æ¥å¬æˆ‘çš„æ¼”å”±ä¼šã€‹ï¼Œ#F è°ƒï¼Œæ­Œç¥žçš„æ­Œï¼Œå¬äº†å¾ˆå¤šéåŽŸæ›²ä¼´å¥ï¼Œå¾ˆæ„ŸåŠ¨ã€‚ç»ƒä¹ çš„è°±å­æ˜¯çŽ‹é¹°ä¹¦ä¸Šçš„ï¼Œå’Œå¼¦èµ°å‘å¤§è‡´æ˜¯å¿ å®žåŽŸæ›²ï¼Œå‰å¥å¾ˆåƒï¼ŒåŽŸæ›²é—´å¥æ˜¯ä¸¤æŠŠå‰ä»–å®Œæˆçš„ï¼Œè¿™é‡Œæ”¹ç¼–æˆä¸€æŠŠäº†ï¼Œå¬èµ·æ¥ä¹Ÿèƒ½æŽ¥å—ã€‚ ã€ŠFlightless Bird, American Mouthã€‹ï¼ŒbE è°ƒï¼Œã€Šæš®å…‰ä¹‹åŸŽã€‹çš„æ’æ›²ï¼Œæ‰’å®Œäº†åŽŸæ›²ä¸­å‰ä»–çš„å’Œå¼¦è¿›è¡Œå’Œä¸€äº›æŒ‡æ³•ç»†èŠ‚ï¼ˆå¤ªç®€å•ï¼Œæ²¡è®°è°±ï¼‰ï¼Œæ²¡æƒ³åˆ°å°±æ˜¯ç®€å•çš„ 1645ã€‚ ã€Šé£Žå¹éº¦æµªã€‹ï¼ŒD è°ƒï¼ŒæŽå¥çš„æ­Œï¼Œç”¨çš„æ˜¯è€å§šçš„ç®€æ˜“ç‰ˆè°±å­ï¼Œä½œä¸ºåˆšå¼€å§‹ç»ƒä¹ æ‹¨ç‰‡å¼¹å¥çš„ç»ƒä¹ æ›²ï¼ˆå› ä¸ºè§‰å¾—æ—‹å¾‹å¥½å¬ï¼‰ï¼Œå·²ç»äº¤ä½œä¸šäº†ã€‚ ã€Šå‰å‘ããªä¹™å¥³å¿ƒã€‹ï¼ŒC è°ƒï¼Œæ˜¯é¦–æ—¥ç³»é£Žæ ¼æ˜Žæ˜¾çš„ç®€å•å°æ›²å­ï¼ˆä¹Ÿæ˜¯ã€Šå£«å…µçªå‡»ã€‹çš„æ’æ›²ï¼Œä¸€å¬å°±å®¹æ˜“æƒ³èµ·æˆæ‰...ï¼‰ï¼Œçº¯çº¯çš„è‡ªå·±æ‰’è°±ï¼Œæ‰’å®Œäº†ä¸Žç½‘ä¸Šçš„å…¶ä»–ç‰ˆæœ¬æ¯”å¯¹äº†ä¸‹ï¼Œå‘çŽ°è‡ªå·±è€³æœµè¿˜æ˜¯ä¸å¤ªè¡ŒðŸ˜‚ï¼ˆæœ‰äº›ç»†èŠ‚è¿˜æ˜¯å¬ä¸å‡ºæ¥ï¼‰ã€‚åŽé¢åˆåˆ†æžäº†ä¸‹å’Œå£°è¿›è¡Œï¼Œå¢žè¿›äº†ä¸€ä¸‹è‡ªå·±è–„å¼±çš„ä¹ç†çŸ¥è¯†ï¼Œç›®å‰å·²ç»ç»ƒçš„å·®ä¸å¤šäº†ï¼Œå¯ä»¥å½•å½•çœ‹äº†ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_11_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F12%2F04%2F2023-11-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©å·²ç»æ˜¯ 12 æœˆ 4 æ—¥äº†... Wedding Bell - DEPAPEPEYour browser does not support the audio tag. æœ€è¿‘å¾ˆè¿·è¿™é¦–æ›²å­ï¼Œè™½ç„¶åŽŸæ¥å·²ç»å¬è¿‡å¾ˆå¤šéäº†ï¼ŒçœŸæƒ³æ‰¾ä¸ªäººä¸€èµ·å½•ä¸€ä¸‹è¿™ä¸ªæ›²å­...ðŸ˜¶ å¤©æ°”è¶Šæ¥è¶Šå†·äº†ï¼Œè¦æ³¨æ„ä¿æš–ï¼Œä¸è¦ç”Ÿç—…ï¼Œæœ€è¿‘æ˜¯æ”¯åŽŸä½“æ„ŸæŸ“çš„å¤šå‘æœŸï¼Œè¿˜æ˜¯è¦æˆ´å¥½å£ç½©ã€‚ä¸è¿‡è¯è¯´å›žæ¥ï¼Œä»Šå¹´å†¬å¤©ç¡®å®žè¦æ¯”åŽ»å¹´æš–å’Œä¸å°‘ï¼Œéš¾æ€ªä¹‹å‰çœ‹åˆ°çƒ­æœä¸Šè¯´ä»Šå¹´å†¬å¤©æ˜¯æœ€æš–å’Œçš„ï¼Œæ•´æŒºå¥½ðŸ˜‚ã€‚ å¥½äº†ï¼Œå›žåˆ°æ­£é¢˜ã€‚ å°±å·¥ä½œçš„æƒ…å†µè€Œè¨€ï¼Œåä¸€æœˆå¾ˆå¸¸è§„ï¼Œä¸å¿™ä¹Ÿä¸é—²ï¼Œæœ¬æœˆä¹Ÿæ˜¯æ­£å¸¸å¸¸è§„æŠ•äº§äº†ä¸€æ¬¡ã€‚æœ¬æ¥æ˜¯æœ‰å‡ ä¸ªå•å­çš„ï¼Œç»“æžœæžæ¥æžåŽ»ï¼Œèƒ½æ­£å¸¸æŠ•çš„å°±ä¸€ä¸ªäº†ï¼Œå…¶ä»–è¦ä¹ˆå»¶æœŸåˆ°åäºŒæœˆäº†ï¼Œè¦ä¹ˆå»¶æœŸåˆ°æ˜Žå¹´ä¸€æœˆäº†ðŸ˜‚ã€‚å•¥æ—¶å€™æŠ•ï¼Œæ˜¾ç„¶ä¸æ˜¯æˆ‘èƒ½å†³å®šçš„äº‹æƒ…ï¼Œæ‰€ä»¥å¬å®‰æŽ’å§~ä»”ç»†æƒ³æƒ³ï¼Œåä¸€æœˆç»“æŸäº†ï¼Œå°±æ„å‘³ç€è‡ªå·±é‡æ–°å‚åŠ å·¥ä½œæ•´æ•´ä¸€å¹´äº†ï¼Œæ—¶é—´çœŸçš„å¾ˆå¿«ï¼ˆä¸å¾—ä¸å†æ¬¡æ„Ÿæ…¨ï¼‰ã€‚è¿™ä¸€å¹´é‡Œï¼Œæœ‰å¾—æœ‰å¤±ï¼Œä½†ä¸å¯å¦è®¤çš„æ˜¯ï¼Œè‡ªèº«çš„æˆé•¿åˆå¢žå¤šäº†ä¸€ä»½ï¼Œå…·ä½“ä¼šåœ¨å¹´ç»ˆçš„æ€»ç»“è°ˆåˆ°ï¼Œè¿™é‡Œå…ˆä¸å†™äº†ã€‚ æŽ¥ç€ï¼Œä¸ªäººå­¦ä¹ æ–¹é¢ï¼ŒMOOC ä¸Š HIT çš„ç»„æˆåŽŸç†çš„ä¸ŠåŠéƒ¨åˆ†å·²ç»æ˜¯ç»“æŸäº†ï¼Œä½†æ˜¯ä¸‹éƒ¨åˆ†è¿˜æœ‰å…­ç« ï¼ŒæŒ‰ç…§è‡ªå·±ä¹‹å‰çš„è¿›åº¦ï¼Œä¼°è®¡æ˜¯éš¾ä»¥ç»“æŸäº†ã€‚æ‰€æœ‰çš„ä½œä¸šæäº¤æ—¥æœŸæ˜¯åœ¨è¿™ä¸ªæœˆçš„ 18 å·ï¼Œä¸è¡Œäº†ï¼Œåªèƒ½æƒ³åŠžæ³•çˆ†è‚ä¸€ä¸‹äº†ã€‚è¯•è¯•çœ‹ï¼Œè‡ªå·±èƒ½ä¸èƒ½æŒ‘æˆ˜æˆåŠŸã€‚ ç”Ÿæ´»æ–¹é¢çš„è¯ï¼Œå› ä¸ºå¤©æ°”å˜å†·äº†ï¼Œé”»ç‚¼ðŸ’ªä¹Ÿå‡å°‘äº†ï¼Œä½†ä¹Ÿå§‘ä¸”ç®—æ˜¯æ­£å¸¸æ°´å¹³å§ï¼Œå”¯ä¸€å‡å°‘çš„å°±æ˜¯äº”å…¬é‡Œæ…¢è·‘æœ‰æ°§å‡å°‘äº†å‡ æ¬¡ã€‚å…¶å®žé”»ç‚¼æ˜¯å¦å‡å°‘æ— æ‰€è°“ï¼Œä¸»è¦æ˜¯ä¸èƒ½é•¿èƒ–ï¼Œä¸èƒ½é•¿å¤šä½™çš„è‚‰ï¼Œå“ˆå“ˆðŸ˜ã€‚åƒåƒå–å–æ–¹é¢ä¹Ÿè¿˜è¡Œï¼Œç§‹å†¬å­£èŠ‚æ¯”è¾ƒå¹²ç‡¥ï¼Œå¹³å‡æ¯å‘¨è¦æ¶ˆè€—æŽ‰äº”ä¸ªæ¢¨ðŸï¼ˆå¹³å‡äº”å—ä¸€ä¸ªï¼Œç•¥è´µðŸ¤¨ï¼‰ï¼Œç”¨äºŽè¡¥å……èº«ä½“çš„æ°´åˆ†ã€‚è¿™ä¹ˆåšä¹‹åŽï¼Œè¿™ä¸ªç§‹å¤©å’Œå†¬å¤©ï¼Œå˜´å”‡æ²¡æœ‰å¹²è£‚è¿‡ï¼ŒæŒ‰ä»¥å¾€çš„æƒ…å†µï¼Œå¿…é¡»æ˜¯è¦æ¶‚å”‡è†æ‰è¡Œçš„ðŸ˜‚ã€‚å¦å¤–ï¼Œä¸Šä¸ªæœˆç»™è‡ªå·±ä¹°çš„ä¸€å †è¡£æœï¼Œæ•ˆæžœè¿˜ç®—ä¸é”™ðŸ˜Žã€‚ æœ€åŽå°±æ˜¯ï¼Œæˆ‘å¿ƒçˆ±çš„â€œåœŸçµç¶â€ðŸŽ¸äº†ã€‚ã€Šå¥¹æ¥å¬æˆ‘çš„æ¼”å”±ä¼šã€‹çš„ä¼´å¥ç®—æ˜¯ç»ƒå®Œäº†ï¼Œå¼¹å”±ç»“åˆè¿˜å·®å¾ˆå¤šã€‚å®žé™…ä¸Šï¼Œè‡ªæˆ‘æ„Ÿè§‰å…‰æ˜¯å”±å°±å·²ç»å·®å¾ˆå¤šäº†ï¼Œå“ˆå“ˆðŸ¤£ï¼Œæ…¢æ…¢ç»ƒå§ã€‚å¦å¤–ï¼Œè¿™ä¸ªæœˆæƒ³ç€è‡ªå·±è‡³å°‘è¦æ‰’ä¸‰åé¦–å„¿æ­Œè°±å­ï¼ˆåªæ˜¯ç®€è°±ï¼‰ï¼Œå¹¶åœ¨å‰ä»–ä¸Šå¼¹ç†Ÿï¼Œå½“ä½œè‡ªå·±çš„â€œé—­å…³ä¿®ç‚¼â€å§ï¼Œä¹‹æ‰€ä»¥æƒ³è¿™ä¹ˆåšçš„åŽŸå› æ˜¯è‡ªå·±è®¤è¯†åˆ°è¦é è€³æœµè€Œä¸æ˜¯çœ¼ç›æ¥å­¦ä¹ éŸ³ä¹äº†ã€‚æ€»ä¹‹ï¼ŒåŠ æ²¹å§ã€‚ å¥½äº†ï¼Œå·®ä¸å¤šäº†ï¼ŒåŠ æ²¹å¹²å§ã€‚ PSï¼šå¾—ç»™è‡ªå·±å†ä¹°ç‚¹è¡£æœæ‰è¡Œã€‚ðŸ˜]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_7]]></title>
    <url>%2F2023%2F11%2F13%2FHIT-CO-Week-7%2F</url>
    <content type="text"><![CDATA[ç»§ç»­å­¦ä¹ ä¸‹å†Œ... è¿™ä¸€ç« é‡ç‚¹åœ¨äºŽç†è§£ï¼Œè€Œæƒ³è¦åŠ æ·±ç†è§£å¯ä»¥ä»Žä¸¤ä¸ªæ–¹é¢å…¥æ‰‹ï¼šæ€»ç»“å’Œç»ƒä¹ ã€‚ æœ¬ç« çš„ä¸»è¦å†…å®¹æ˜¯ï¼šè®¡ç®—æœºä¸­æ•°çš„è¡¨ç¤ºã€è®¡ç®—æœºçš„è¿ç®—æ–¹æ³•å’Œè¿ç®—å™¨çš„è®¾è®¡ï¼Œå­¦ä¹ è¿™ä¸€ç« éœ€è¦æœ‰ç‚¹è€å¿ƒã€‚ æ— ç¬¦å·æ•°å’Œæœ‰ç¬¦å·æ•°æ— ç¬¦å·æ•°æ— ç¬¦å·æ•°æ¯”è¾ƒç®€å•ï¼Œå¯„å­˜å™¨çš„ä½æ•°ç›´æŽ¥åæ˜ äº†æ— ç¬¦å·æ•°çš„è¡¨ç¤ºèŒƒå›´ã€‚å®žé™…ä¸Šï¼Œæœ‰ C è¯­è¨€åŸºç¡€çš„è¯ï¼Œè¿™æ˜¯ä¸è¨€è€Œå–»çš„ï¼Œå°±ä¸å†èµ˜è¿°äº†ã€‚ å¯èƒ½ä¼šæœ‰äººæœ‰ç–‘é—®ï¼šä¸ºä»€ä¹ˆæ²¡æœ‰æ— ç¬¦å·å°æ•°ï¼Ÿå°±ç¬”è€…çš„ä¸ªäººç†è§£è€Œè¨€ï¼Œä¸€æ˜¯å› ä¸ºæ²¡æœ‰å¿…è¦åŽ»ä¸“é—¨ä½¿ç”¨æ— ç¬¦å·å°æ•°ï¼ŒäºŒæ˜¯å› ä¸ºå°æ•°åœ¨è®¡ç®—æœºä¸­çš„è¡¨ç¤ºæœ¬èº«å°±å¾ˆéº»çƒ¦äº†ï¼Œåœ¨åŠ ä¸Šæ— ç¬¦å·å·å°æ•°å°±æ›´éº»çƒ¦äº†ã€‚å½“ç„¶ï¼Œå…·ä½“çš„åŽŸå› åªèƒ½åŽ»é—®å½“åˆå‘æ˜Žè®¡ç®—æœºçš„é‚£å¸®è€å¤´å­äº†ã€‚ æœ‰ç¬¦å·æ•°æœ‰ç¬¦å·æ•°å°±æ¯”è¾ƒå¤æ‚äº†ï¼Œåˆ†ä¸ºæ•´æ•°å’Œå°æ•°ï¼Œä¸‹é¢è¦ä»‹ç»çš„å„ç§è¡¨ç¤ºæ³•éƒ½æ˜¯ä»Žè¿™ä¸¤ä¸ªæ–¹é¢å±•å¼€çš„ã€‚ æœºå™¨æ•°ä¸ŽçœŸå€¼é¦–å…ˆè¦æ˜Žç¡®çš„ä¸¤ä¸ªæ¦‚å¿µæ˜¯ï¼šæœºå™¨æ•°ä¸ŽçœŸå€¼ã€‚æ‰€è°“æœºå™¨æ•°ï¼Œç®€å•ç†è§£å°±æ˜¯è®¡ç®—æœºå†…å­˜å‚¨çš„æ•°ï¼Œè¿™ä¸ªæ•°è·ŸçŽ°å®žä¸­çš„æ•°æ˜¯å­˜åœ¨å·®å¼‚çš„ï¼›è€Œè¿™é‡Œçš„çœŸå€¼ä¸æ˜¯trueå’Œfalseï¼Œåªæ˜¯çŽ°å®žä¸­çš„æœ‰å¤§å°å’Œæ­£è´Ÿçš„æ•°ï¼Œå®ƒå¯ä»¥æ˜¯åè¿›åˆ¶çš„ä¹Ÿå¯ä»¥æ˜¯äºŒè¿›åˆ¶çš„ã€‚ ä»¥ä¸‹æ•°å­¦å®šä¹‰éƒ¨åˆ†ï¼Œ$x$ éƒ½ä¸ºçœŸå€¼ï¼Œ$n$ ä¸ºæ•´æ•°æˆ–å°æ•°çš„ä½æ•°ã€‚ åŽŸç è¡¨ç¤ºæ³•åŒ…å«ä¸¤ä¸ªéƒ¨åˆ†ï¼šæ•´æ•°å’Œå°æ•°ã€‚ æ•´æ•°é¦–å…ˆæ˜¯å®šä¹‰ï¼š$$[x]_åŽŸ =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\2^n-x &amp; 0 \geqslant x &gt; -2^n \\\end{cases}$$ æ¯”å¦‚ï¼š$x = +1110$ï¼Œ$[x]_åŽŸ = 0,1110$ï¼›$x = -1110$ï¼Œ$[x]_åŽŸ = 2^4 + 1110 = 1,1110$ã€‚å®žé™…ä¸Šï¼Œ$2^4$å…¶å®žå°±æ˜¯$10000$ï¼Œå†™æˆæŒ‡æ•°å½¢å¼æ›´è´´è¿‘å®šä¹‰ä¸­çš„å…¬å¼ï¼Œå¯åƒä¸‡åˆ«ä»¥ä¸ºæ˜¯æ–°ä¸œè¥¿ã€‚ æ³¨æ„ï¼šä¸Šè¿°é»˜è®¤æœºå™¨å­—é•¿æ˜¯ 5 ä½ï¼ˆåŽé¢çš„å†…å®¹ä¹Ÿéƒ½é»˜è®¤æœºå™¨å­—é•¿åœ¨åˆç†èŒƒå›´å†…ï¼‰ï¼Œé€—å·ç”¨æ¥éš”å¼€ç¬¦å·ä½å’Œæ•°å€¼éƒ¨åˆ†ã€‚ å°æ•°å®šä¹‰ï¼š$$[x]_åŽŸ =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\1-x &amp; 0 \geqslant x &gt; -1 \\\end{cases}$$ æ¯”å¦‚ï¼š$x = +0.1101$ï¼Œ$[x]_åŽŸ = 0.1101$ï¼›$x = -0.1101$ï¼Œ$[x]_åŽŸ = 1 - (-0.1101) = 1.1101$ã€‚ ä¸Žä¸Šè¿°ä¸€æ ·ï¼Œæœºå™¨å­—é•¿é»˜è®¤ä¸º 5 ä½ï¼Œå°æ•°ç‚¹ç”¨æ¥éš”å¼€ç¬¦å·ä½å’Œæ•°å€¼éƒ¨åˆ†ã€‚ æœ€åŽï¼Œè¿˜è¦æŠŠç‰¹æ®Šçš„ 0 å•ç‹¬æ‹¿å‡ºæ¥è®¨è®ºä¸‹ï¼ŒæŒ‰ç…§åŽŸç å°æ•°çš„å®šä¹‰ï¼Œæœ‰ï¼š+0ï¼š$x = +0.0000ï¼Œ[+0.0000]_åŽŸ = 0.0000$-0ï¼š$x = -0.0000ï¼Œ[-0.0000]_åŽŸ = 1.0000$åŒç†ï¼Œå¯¹äºŽæ•´æ•°ï¼Œå°±æœ‰ï¼š+0ï¼š$[+0]_åŽŸ = 0,0000$-0ï¼š$[-0]_åŽŸ = 1,0000$ç»¼ä¸Šï¼Œ+0å’Œ-0çš„åŽŸç ä¸åŒã€‚ è¡¥ç è¡¨ç¤ºæ³•è¡¥ç çš„æ¦‚å¿µæœ‰ç‚¹ç±»ä¼¼äºŽæ¨¡è¿ç®—ä¸­çš„è¡¥æ•°ï¼Œä¸å¤æ‚ï¼Œä½†æ˜¯æ—¥å¸¸ç”Ÿæ´»ä¸­ç”¨çš„ä¸å¤šã€‚ æ•´æ•°å®šä¹‰ï¼š$$[x]_è¡¥ =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\2^{n+1}+x &amp; 0 &gt; x \geqslant -2^n (mod\ 2^{n+1})\\\end{cases}$$ æ¯”å¦‚ï¼š$x = +1010$ï¼Œ$[x]_è¡¥ = 0,1010$ï¼›$x = -1011000$ï¼Œ$[x]_è¡¥ = 2^{7+1} + (-1011000) = 1,0101000$ã€‚ å°æ•°å®šä¹‰ï¼š$$[x]_è¡¥ =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\2+x &amp; 0 &gt; x \geqslant -1 (mod\ 2)\\\end{cases}$$ æ¯”å¦‚ï¼š$x = +0.1110$ï¼Œ$[x]_è¡¥ = 0.1110$ï¼›$x = -0.1100000$ï¼Œ$[x]_è¡¥ = 2 + (-0.1100000) = 1.0100000$ã€‚ å®žé™…ä¸Šï¼Œå…³äºŽè¡¥ç æœ‰ä¸€äº›è§„å¾‹ï¼š æ­£æ•°çš„è¡¥ç å°±æ˜¯å…¶æœ¬èº« è´Ÿæ•°çš„è¡¥ç å¯ç”¨å…¶åŽŸç é™¤ç¬¦å·ä½ï¼Œæ¯ä½å–åï¼Œæœ«ä½åŠ  1 æ±‚å¾— åŒæ ·ï¼Œè¡¥ç ä¹Ÿå­˜åœ¨ 0 è¿™ä¸ªç‰¹æ®Šæƒ…å†µï¼ŒæŒ‰ç…§è¡¥ç å°æ•°çš„å®šä¹‰ï¼š+0ï¼š$x = +0.0000ï¼Œ[+0.0000]_è¡¥ = 0.0000$-0ï¼š$x = -0.0000ï¼Œ[-0.0000]_è¡¥ = 1.0000$åŒç†ï¼Œå¯¹äºŽæ•´æ•°ï¼Œå°±æœ‰ï¼š+0ï¼š$[+0]_è¡¥ = 0,0000$-0ï¼š$[-0]_è¡¥ = 1,0000$ç»¼ä¸Šï¼Œ+0å’Œ-0çš„è¡¥ç ç›¸åŒã€‚ åç è¡¨ç¤ºæ³•æ•´æ•°å®šä¹‰ï¼š$$[x]_å =\begin{cases}0,x &amp; 2^n &gt; x \geqslant 0 \\(2^{n+1}-1)+x &amp; 0 &gt; x \geqslant -2^n (mod\ 2^{n+1}-1)\\\end{cases}$$ æ¯”å¦‚ï¼š$x = +1101$ï¼Œ$[x]_å = 0,1101$ï¼›$x = -1101$ï¼Œ$[x]_å = (2^{4+1}-1) - 1101 = 1,0010$ã€‚ å°æ•°å®šä¹‰ï¼š$$[x]_å =\begin{cases}x &amp; 1 &gt; x \geqslant 0 \\(2-2^{-n})+x &amp; 0 \geqslant x &gt; -1 (mod\ 2-2^{-n})\\\end{cases}$$ æ¯”å¦‚ï¼š$x = +0.1101$ï¼Œ$[x]_å = 0.1101$ï¼›$x = -0.1010$ï¼Œ$[x]_å = (2-2^{-4} - 0.1010) = 1.0101$ã€‚ åŒæ ·ï¼Œåç ä¹Ÿå­˜åœ¨ 0 è¿™ä¸ªç‰¹æ®Šæƒ…å†µï¼ŒæŒ‰ç…§åç å°æ•°çš„å®šä¹‰ï¼š+0ï¼š$x = +0.0000ï¼Œ[+0.0000]_è¡¥ = 0.0000$-0ï¼š$x = -0.0000ï¼Œ[-0.0000]_è¡¥ = 1.1111$åŒç†ï¼Œå¯¹äºŽæ•´æ•°ï¼Œå°±æœ‰ï¼š+0ï¼š$[+0]_è¡¥ = 0,0000$-0ï¼š$[-0]_è¡¥ = 1,1111$ç»¼ä¸Šï¼Œ+0å’Œ-0çš„åç ä¸åŒã€‚ å°ç»“æ€»ç»“ä¸€ä¸‹ä¸‰ç§æœºå™¨æ•°çš„è§„å¾‹ï¼š å¯¹äºŽæ­£æ•°ï¼ŒåŽŸç  = è¡¥ç  = åç  å¯¹äºŽè´Ÿæ•°ï¼Œç¬¦å·ä½ä¸º 1ï¼Œå…¶åŽŸç é™¤ç¬¦å·ä½å¤–æ¯ä½å–åï¼Œæœ«ä½åŠ  1 å¯å¾—è¡¥ç ï¼›å…¶åŽŸç é™¤ç¬¦å·ä½æ¯ä½å–åï¼Œå¯å¾—åç  ç§»ç è¡¨ç¤ºæ³•è¡¥ç æ— æ³•ç›´æŽ¥åˆ¤æ–­ä¸¤ä¸ªç¬¦å·ä¸åŒçš„æ•´æ•°çš„å¤§å°å…³ç³»ï¼Œç”±æ­¤äº§ç”Ÿçš„å°±æ˜¯ç§»ç ã€‚ç§»ç å®šä¹‰ï¼š$$[x]_ç§» =\begin{cases}2^n+x &amp; 2^n &gt; x \geqslant -2^n \\\end{cases}$$ æ¯”å¦‚ï¼š$x = 10100$ï¼Œ$[x]_ç§» = 2^5 + 10100 = 1,10100$ï¼›$x = -10100$ï¼Œ$[x]_ç§» = 2^5 - 10100 = 0,01100$ã€‚å®žé™…ä¸Šï¼Œç§»ç ä¸Žè¡¥ç åªå·®äº†ä¸€ä¸ªç¬¦å·ä½ï¼šæ­£æ•°çš„ç§»ç çš„ç¬¦å·ä½ä¸º 1ï¼Œè´Ÿæ•°çš„ç§»ç çš„ç¬¦å·ä½ä¸º 0ã€‚æœ€å°çœŸå€¼çš„ç§»ç ä¸ºå…¨ 0ï¼ŒåŒæ—¶+0å’Œ-0çš„ç§»ç ä¹Ÿæ˜¯ç›¸ç­‰çš„ï¼ˆä¸Žè¡¥ç ä¸€è‡´ï¼‰ã€‚ç§»ç çš„ç”¨é€”å°±æ˜¯ç”¨æ¥è¡¨ç¤ºæµ®ç‚¹æ•°çš„é˜¶ç ï¼Œè¿™æ ·å¯ä»¥å¾ˆæ–¹ä¾¿çš„åˆ¤æ–­æµ®ç‚¹æ•°é˜¶ç å¤§å°ã€‚ æ•°çš„å®šç‚¹è¡¨ç¤ºå’Œæµ®ç‚¹è¡¨ç¤ºå®šç‚¹è¡¨ç¤ºæŒ‰ç…§å°æ•°ç‚¹çš„ä½ç½®æœ‰ä¸¤ç§è¡¨ç¤ºæ–¹æ³•ï¼Œä¸€ç§æ˜¯å°æ•°ç‚¹åœ¨æ•°ç¬¦ä¹‹åŽï¼ˆå°æ•°å®šç‚¹æœºï¼‰ï¼Œå¦ä¸€ç§æ˜¯å°æ•°ç‚¹åœ¨æ•°å€¼ä¹‹åŽï¼ˆæ•´æ•°å®šç‚¹æœºï¼‰ï¼Œå…·ä½“å¦‚ä¸‹å›¾ï¼š æµ®ç‚¹è¡¨ç¤ºå¼•å…¥æµ®ç‚¹æ•°çš„ç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿ç§‘å­¦è®¡ç®—ï¼Œå…¶ä¸€èˆ¬å½¢å¼ä¸ºï¼š$$N = S \times r^j$$ å…¶ä¸­ï¼Œ$S$ ä¸ºå°¾æ•°ï¼Œæ˜¯æ•°çš„å°æ•°éƒ¨åˆ†ï¼Œå¯æ­£å¯è´Ÿï¼›$j$ ä¸ºé˜¶ç ï¼Œæ˜¯åŸºå€¼çš„æŒ‡æ•°éƒ¨åˆ†ï¼Œå¯æ­£å¯è´Ÿï¼›$r$ å°¾æ•°çš„åŸºå€¼ï¼Œä¹Ÿå°±æ˜¯è¿›åˆ¶æ•°ã€‚ å…·ä½“æ¥è®²ï¼Œåœ¨è®¡ç®—æœºå­˜å‚¨çš„æµ®ç‚¹æ•°åŒ…å«äº†äº”ä¸ªéƒ¨åˆ†ï¼Œå¦‚ä¸‹å›¾ï¼š æœ€åŽéœ€è¦æŒ‡å‡ºçš„æ˜¯æµ®ç‚¹æ•°çš„è¡¨ç¤ºèŒƒå›´ï¼Œå¦‚ä¸‹å›¾ï¼š æ³¨æ„ä¸Šå›¾ä¸­çš„èŒƒå›´ï¼Œå‘ç”Ÿä¸‹æº¢æ—¶ï¼ŒæŒ‰ç…§æœºå™¨é›¶å¤„ç†ï¼›å‘ç”Ÿä¸Šæº¢æ—¶ï¼ŒæŒ‰ç…§è®¡ç®—å‡ºé”™å¤„ç†ã€‚ æ€»ç»“æ€»ä½“æ¥è¯´ï¼Œè¿™ç« çš„å†…å®¹ä¸éš¾ï¼Œä½†æ˜¯å¾ˆç¹çï¼Œåªæ˜¯éœ€è¦åšå¥½åŒºåˆ†å’Œæ€»ç»“ã€‚ ç„¶åŽæ˜¯è¿™ä¸€ç« çš„æ€ç»´å¯¼å›¾ï¼š PSï¼šå…‰çœ‹å›¾çš„è¯ï¼Œå†…å®¹ç¡®å®žä¸å¤š...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_6]]></title>
    <url>%2F2023%2F11%2F04%2FHIT-CO-Week-6%2F</url>
    <content type="text"><![CDATA[åæœˆåº•åœ¨â€œæ‰“æ¸”â€ðŸ˜‚ï¼Œæ²¡æ€Žä¹ˆå­¦ä¹ ï¼Œè¦èµ¶ç´§æŠŠä¸Šéƒ¨åˆ†æžå®šï¼Œå¼€å§‹ä¸‹éƒ¨åˆ†ã€‚ è¿™å‘¨çš„å†…å®¹æ˜¯è¾“å…¥è¾“å‡ºç³»ç»Ÿï¼Œå†…éƒ¨ä¸ç®—å¤šï¼ŒåŠ æŠŠåŠ²ã€‚ æ¦‚è¿°æ—©æœŸé‡‡ç”¨åˆ†æ•£è¿žæŽ¥ï¼ŒCPU å’Œ I/O è®¾å¤‡ä¸²è¡Œå·¥ä½œï¼Œä¿¡æ¯ä¼ é€æŽ§åˆ¶æ–¹å¼é‡‡ç”¨ç¨‹åºæŸ¥è¯¢æ–¹å¼ï¼›ç„¶åŽæ˜¯æŽ¥å£æ¨¡å—å’Œ DMA é˜¶æ®µï¼Œæ­¤æ—¶ä¿¡æ¯ä¼ é€æŽ§åˆ¶æ–¹å¼é‡‡ç”¨æ€»çº¿è¿žæŽ¥ï¼ŒCPU å’Œ I/O è®¾å¤‡å¹¶è¡Œå·¥ä½œï¼Œé‡‡ç”¨ä¸­æ–­æ–¹å¼å’Œ DMA æ–¹å¼ï¼›å¾€åŽä¾æ¬¡æ˜¯å…·æœ‰é€šé“çš„é˜¶æ®µå’Œå…·æœ‰ I/O å¤„ç†æœºçš„é˜¶æ®µã€‚ I/O ç³»ç»Ÿç”±ä¸¤éƒ¨åˆ†ç»„æˆï¼šI/O è½¯ä»¶å’Œ I/O ç¡¬ä»¶ï¼Œå…¶ä¸­è½¯ä»¶åŒ…æ‹¬ I/O æŒ‡ä»¤ï¼ˆCPU æŒ‡ä»¤çš„ä¸€éƒ¨åˆ†ï¼‰å’Œé€šé“æŒ‡ä»¤ï¼ˆé€šé“è‡ªèº«çš„æŒ‡ä»¤ï¼‰ï¼Œç¡¬ä»¶åŒ…æ‹¬ I/O æŽ¥å£å’Œè®¾å¤‡æŽ§åˆ¶å™¨ã€‚ I/O è®¾å¤‡ä¸Žä¸»æœºçš„è”ç³»æ–¹å¼ä¸»è¦è€ƒè™‘ä»¥ä¸‹é—®é¢˜ï¼š I/O è®¾å¤‡çš„ç¼–å€æ–¹å¼ï¼šåˆ†ä¸ºç»Ÿä¸€ç¼–å€ï¼ˆç”¨å–æ•°ã€å­˜æ•°æŒ‡ä»¤ï¼‰å’Œä¸ç»Ÿä¸€ç¼–å€ï¼ˆæœ‰ä¸“é—¨çš„ I/O æŒ‡ä»¤ï¼‰ è®¾å¤‡é€‰å€ï¼šç”¨è®¾å¤‡é€‰æ‹©ç”µè·¯è¯†åˆ«æ˜¯å¦è¢«é€‰ä¸­ ä¼ é€æ–¹å¼ï¼šä¸²è¡Œæˆ–å¹¶è¡Œ è”ç»œæ–¹å¼ï¼šç«‹å³å“åº”ã€å¼‚æ­¥å·¥ä½œé‡‡ç”¨åº”ç­”ä¿¡å·æˆ–åŒæ­¥å·¥ä½œé‡‡ç”¨åŒæ­¥æ—¶æ ‡ I/O è®¾å¤‡ä¸Žä¸»æœºçš„ä¸‰ç§ç§è¿žæŽ¥æ–¹å¼ï¼šè¾å°„å¼è¿žæŽ¥ï¼ˆä¸ä¾¿äºŽå¢žåˆ è®¾å¤‡ï¼‰å’Œæ€»çº¿è¿žæŽ¥ï¼ˆä¾¿äºŽå¢žåˆ è®¾å¤‡ï¼‰ã€‚ æœ€åŽæ˜¯ I/O è®¾å¤‡ä¸Žä¸»æœºä¿¡æ¯ä¼ é€çš„ä¸‰ç§æŽ§åˆ¶æ–¹å¼ï¼š ç¨‹åºæŸ¥è¯¢æ–¹å¼ ç¨‹åºä¸­æ–­æ–¹å¼ DMA æ–¹å¼ ä¸‹é¢å†æ·±å…¥ä¸€ä¸‹ã€‚ I/O è®¾å¤‡I/O è®¾å¤‡ä¹Ÿå«å¤–éƒ¨è®¾å¤‡ï¼Œä¹Ÿå°±æ˜¯è¾“å…¥è¾“å‡ºè®¾å¤‡ï¼Œå¤§è‡´åˆ†ä¸ºä¸‰ç±»ï¼šäººæœºäº¤äº’è®¾å¤‡ï¼ˆé”®ç›˜ã€é¼ æ ‡ã€æ˜¾ç¤ºå™¨ï¼‰ã€è®¡ç®—æœºä¿¡æ¯å­˜å‚¨è®¾å¤‡ï¼ˆç£ç›˜ã€å…‰ç›˜ï¼‰å’Œæœº-æœºé€šä¿¡è®¾å¤‡ï¼ˆè°ƒåˆ¶è§£è°ƒå™¨ï¼Œä¹Ÿå°±æ˜¯åŽŸæ¥è¯´çš„å…‰çŒ«ï¼‰ï¼Œå‰©ä¸‹çš„å…·ä½“è®¾å¤‡å°±ä¸è¯´äº†ï¼Œä¸æ˜¯é‡ç‚¹ã€‚ I/O æŽ¥å£é¦–å…ˆåº”è¯¥æ˜Žç¡®çš„æ˜¯è®¾ç½®æŽ¥å£çš„ç›®çš„ï¼ˆåŠŸèƒ½ï¼‰ï¼š å®žçŽ°è®¾å¤‡çš„é€‰æ‹© å®žçŽ°æ•°æ®ç¼“å†²è¾¾åˆ°é€Ÿåº¦åŒ¹é… å®žçŽ°æ•°æ®ä¸²-å¹¶æ ¼å¼è½¬æ¢ å®žçŽ°ç”µå¹³è½¬æ¢ ä¼ é€æŽ§åˆ¶å‘½ä»¤ åæ˜ è®¾å¤‡çš„çŠ¶æ€ï¼ˆâ€œå¿™â€ã€â€œå°±ç»ªâ€ã€â€œä¸­æ–­è¯·æ±‚â€ï¼‰ æ€»çº¿è¿žæŽ¥æ–¹å¼çš„ I/O æŽ¥å£ç”µè·¯åŒ…æ‹¬ï¼šè®¾å¤‡é€‰æ‹©çº¿ã€æ•°æ®çº¿ã€å‘½ä»¤çº¿å’ŒçŠ¶æ€çº¿ï¼Œå„ä¸ªç»„æˆéƒ¨åˆ†ä¹Ÿæœ‰ç›¸å¯¹åº”çš„åŠŸèƒ½ï¼š åŠŸèƒ½ ç»„æˆ é€‰å€åŠŸèƒ½ è®¾å¤‡é€‰æ‹©ç”µè·¯ ä¼ é€å‘½ä»¤ å‘½ä»¤å¯„å­˜å™¨ã€å‘½ä»¤è¯‘ç å™¨ ä¼ é€æ•°æ® æ•°æ®ç¼“å†²å¯„å­˜å™¨ åæ˜ è®¾å¤‡çŠ¶æ€çš„åŠŸèƒ½ è®¾å¤‡çŠ¶æ€æ ‡è®°ï¼ˆå®Œæˆè§¦å‘å™¨ Dã€å·¥ä½œè§¦å‘å™¨ Bã€ä¸­æ–­è¯·æ±‚è§¦å‘å™¨ INTRã€å±è”½è§¦å‘å™¨ MASKï¼‰ I/O æŽ¥å£å¤§è‡´çš„åŸºæœ¬ç»„æˆå¦‚ä¸‹å›¾ï¼š I/O æŽ¥å£åˆ†ç±»æ–¹å¼æ¯”è¾ƒå¤šï¼Œè¿™é‡Œä¸èµ˜è¿°äº†ï¼Œéžé‡ç‚¹ã€‚ ç¨‹åºæŸ¥è¯¢æ–¹å¼ç¨‹åºæŸ¥è¯¢æ–¹å¼çš„æµç¨‹ä¸»è¦åˆ†ä¸¤ä¸ªéƒ¨åˆ†ï¼šæŸ¥è¯¢æµç¨‹å’Œç¨‹åºæµç¨‹ï¼Œè¿™é‡Œä¸è¯¦ç»†æè¿°äº†ï¼Œæ€»ä¹‹è®°ä½è¿™ç§æ–¹å¼æœ€å¤§çš„ç‰¹ç‚¹ï¼šä¸²è¡Œå·¥ä½œã€‚ ç¨‹åºä¸­æ–­æ–¹å¼ä¸­æ–­çš„æ¦‚å¿µï¼Œå¯ä»¥å‚è€ƒç™¾ç§‘â€”â€”ä¸­æ–­ã€‚å®žé™…ä¸Šï¼Œç®€å•ç†è§£èµ·æ¥å°±æ˜¯æ‰“æ–­ CPU çš„å·¥ä½œï¼Œæ‰§è¡Œå®Œæˆå…¶ä»–çš„æŒ‡ä»¤åŽï¼Œç»§ç»­æ‰§è¡ŒåŽŸæŒ‡ä»¤ã€‚ä»Žå®è§‚ä¸Šçœ‹ï¼ŒCPU å’Œå…¶ä»–è®¾å¤‡æ˜¯åœ¨å¹¶è¡Œå·¥ä½œã€‚ ç¨‹åºä¸­æ–­æ–¹å¼çš„æŽ¥å£ç”µè·¯ä¸»è¦ç”±ä¸­æ–­è¯·æ±‚è§¦å‘å™¨ã€ä¸­æ–­å±è”½è§¦å‘å™¨ã€æŽ’é˜Ÿå™¨ã€ä¸­æ–­å‘é‡åœ°å€å½¢æˆéƒ¨ä»¶ç­‰ç»„æˆï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š ä¸Šå›¾ä¸­ï¼Œå®Œæˆè§¦å‘å™¨ D å—è®¾å¤‡æœ¬èº«æŽ§åˆ¶ï¼›ä¸­æ–­å±è”½è§¦å‘å™¨ MASK ä¸º 1 æ—¶ï¼Œå±è”½ä¸­æ–­ä¿¡å·ï¼›ä¸­æ–­è¯·æ±‚è§¦å‘å™¨ INTR ä¸º 1 æ—¶ï¼Œè¡¨ç¤ºæœ‰ä¸­æ–­è¯·æ±‚ã€‚å¦å¤–ï¼ŒæŽ’é˜Ÿå™¨åˆ†ä¸ºè½¯ä»¶å’Œç¡¬ä»¶ï¼Œå…¶å†…éƒ¨çš„ä¸­æ–­è¯·æ±‚ä¼˜å…ˆçº§æŒ‰é™åºæŽ’åˆ—ã€‚ä¸­æ–­å‘é‡åœ°å€å¯ç”±ç¡¬ä»¶äº§ç”Ÿï¼Œä¹Ÿå¯ç”±è½¯ä»¶äº§ç”Ÿï¼Œè¿™ä¸ªåœ°å€å¯ä»¥ç†è§£ä¸ºè¦æ‰§è¡Œçš„ç¨‹åºçš„åœ°å€çš„åœ°å€ï¼Ÿ I/O ä¸­æ–­å¤„ç†è¿‡ç¨‹ï¼Œå¦‚ä¸‹å›¾ï¼š ä¸­æ–­æœåŠ¡ç¨‹åºçš„æµç¨‹ï¼š ä¿æŠ¤çŽ°åœºï¼šåŒ…æ‹¬ç¨‹åºæ–­ç”µçš„ä¿æŠ¤ï¼ˆä¸­æ–­éšæŒ‡ä»¤å®Œæˆï¼‰å’Œå¯„å­˜å™¨å†…å®¹çš„ä¿æŠ¤ï¼ˆè¿›æ ˆæŒ‡ä»¤ï¼‰ ä¸­æ–­æœåŠ¡ï¼šå¯¹ä¸åŒçš„ I/O è®¾å¤‡å…·æœ‰ä¸åŒå†…å®¹çš„è®¾å¤‡æœåŠ¡ æ¢å¤çŽ°åœºï¼šå‡ºæ ˆæŒ‡ä»¤ ä¸­æ–­è¿”å›žï¼šä¸­æ–­è¿”å›žæŒ‡ä»¤ ä¸­æ–­è¿˜åˆ†ä¸ºå•é‡ä¸­æ–­ï¼ˆä¸å…è®¸ä¸­æ–­çŽ°è¡Œçš„ä¸­æ–­æœåŠ¡ç¨‹åºï¼‰å’Œå¤šé‡ä¸­æ–­ï¼ˆå…è®¸çº§åˆ«æ›´é«˜çš„ä¸­æ–­æºä¸­æ–­çŽ°è¡Œçš„æœåŠ¡ç¨‹åºï¼‰ï¼ŒäºŒè€…çš„åŒºåˆ«å¦‚ä¸‹å›¾ï¼š æœ€åŽï¼Œéœ€è¦å†æ¬¡å¼ºè°ƒçš„æ˜¯ï¼Œåœ¨å®è§‚ä¸Š CPU å’Œ I/O å¹¶è¡Œå·¥ä½œï¼Œä½†åœ¨å¾®è§‚ä¸Šï¼ŒCPU ä¸­æ–­çŽ°è¡Œç¨‹åºä¸º I/O æœåŠ¡ã€‚ DMA æ–¹å¼DMA æ–¹å¼çš„ç‰¹ç‚¹ç¨‹åºä¸­æ–­æ–¹å¼çš„æ•°æ®ä¼ é€é€šè·¯éœ€è¦ç»è¿‡ CPUï¼Œä½† DMA æ–¹å¼çš„æ•°æ®ä¼ é€é€šè·¯ä¸éœ€è¦ç»è¿‡ CPUï¼Œå¤–éƒ¨è®¾å¤‡ä¸Žä¸»å­˜ç›´æŽ¥é€šè¿‡ DMA æŽ¥å£å³å¯è¿›è¡Œæ•°æ®äº¤æ¢ã€‚ DMA ä¸Žä¸»å­˜äº¤æ¢æ•°æ®çš„æ–¹å¼æœ‰ä¸‰ç§ï¼š åœæ­¢ CPU è®¿é—®ä¸»å­˜ï¼Œè¿™ç§æ–¹å¼æŽ§åˆ¶ç®€å•ï¼Œä½†åœ¨æ•°æ®ä¼ é€çš„è¿‡ç¨‹ä¸­ï¼ŒCPU å¤„äºŽä¸å·¥ä½œçŠ¶æ€æˆ–ä¿æŒçŠ¶æ€ï¼Œä¸èƒ½å……åˆ†å‘æŒ¥ CPU å¯¹ä¸»å­˜çš„åˆ©ç”¨çŽ‡ã€‚ å‘¨æœŸæŒªç”¨ï¼ˆä¹Ÿå«å‘¨æœŸçªƒå–ï¼‰ï¼Œè¿™é‡Œæåˆ°çš„å‘¨æœŸå°±æ˜¯æŒ‡è®¿å­˜å‘¨æœŸï¼ˆå­˜å–å‘¨æœŸï¼‰ã€‚æ‰€è°“å‘¨æœŸæŒªç”¨ï¼Œå…¶å®žå°±æ˜¯æŒ‡åœ¨ DMA æŽ¥å£å¼€å§‹è¿›è¡Œæ•°æ®ä¼ é€æ—¶ï¼ŒCPU æ”¾å¼ƒå¯¹ä¸»å­˜çš„å ç”¨ï¼Œå¾… DMA æŽ¥å£å®Œæˆæ•°æ®ä¼ é€åŽï¼ŒCPU å†è¿›è¡Œå¯¹ä¸»å­˜è®¿é—®ã€‚æ­¤æ—¶å­˜åœ¨ä¸‰ç§å¯èƒ½ï¼šCPU æ­¤æ—¶ä¸è®¿å­˜ã€CPU æ­£åœ¨è®¿å­˜ã€CPU å’Œ DMA åŒæ—¶è¯·æ±‚è®¿å­˜ï¼ˆæ­¤æ—¶ CPU å°†æ€»çº¿æŽ§åˆ¶æƒè®©ç»™ DMAï¼‰ã€‚ DMA ä¸Ž CPU äº¤æ›¿è®¿é—®ï¼Œå°† CPU å·¥ä½œå‘¨æœŸåˆ†ä¸º $C_1$ï¼ˆä¸“ä¾› DMA è®¿å­˜ï¼‰å’Œ $C_2$ï¼ˆä¸“ä¾› CPU è®¿å­˜ï¼‰ã€‚ DMA æŽ¥å£çš„åŠŸèƒ½ä¸»è¦æ˜¯ä»¥ä¸‹äº”ç‚¹ï¼š å‘ CPU ç”³è¯· DMA ä¼ é€ å¤„ç†æ€»çº¿æŽ§åˆ¶æƒçš„è½¬äº¤ ç®¡ç†ç³»ç»Ÿæ€»çº¿ã€æŽ§åˆ¶æ•°æ®ä¼ é€ ç¡®å®šæ•°æ®ä¼ é€çš„é¦–åœ°å€å’Œé•¿åº¦ï¼Œä¿®æ­£ä¼ é€è¿‡ç¨‹ä¸­çš„æ•°æ®åœ°å€å’Œé•¿åº¦ DMA ä¼ é€ç»“æŸæ—¶ï¼Œç»™å‡ºæ“ä½œå®Œæˆä¿¡å· DMA æŽ¥å£ç»„æˆå‚è€ƒä¸‹å›¾ï¼š DMA å·¥ä½œè¿‡ç¨‹DMA ä¼ é€è¿‡ç¨‹DMA ä¼ é€è¿‡ç¨‹ä¾æ¬¡æ˜¯é¢„å¤„ç†ã€æ•°æ®ä¼ é€å’ŒåŽå¤„ç†ã€‚ é¢„å¤„ç†é€šè¿‡å‡ æ¡è¾“å…¥è¾“å‡ºæŒ‡ä»¤é¢„ç½®å¦‚ä¸‹ä¿¡æ¯ï¼š é€šçŸ¥ DMA æŽ§åˆ¶é€»è¾‘ä¼ é€æ–¹å‘ï¼ˆå…¥/å‡ºï¼‰ è®¾å¤‡åœ°å€ DMA çš„ DAR ä¸»å­˜åœ°å€ DMA çš„ AR ä¼ é€å­—æ•° DMA çš„ WC æ•°æ®ä¼ é€ åŽå¤„ç†åŽå¤„ç†ä¸»è¦å®Œæˆä»¥ä¸‹ä¸‰ä¸ªä»»åŠ¡ï¼š æ ¡éªŒé€å…¥ä¸»å­˜çš„æ•°æ˜¯å¦æ­£ç¡® æ˜¯å¦ç»§ç»­ç”¨ DMA æµ‹è¯•ä¼ é€è¿‡ç¨‹æ˜¯å¦æ­£ç¡®ï¼Œé”™åˆ™è½¬è¯Šæ–­ç¨‹åº æ³¨æ„ï¼ŒåŽå¤„ç†è¿‡ç¨‹éƒ½æ˜¯ç”±ä¸­æ–­æœåŠ¡ç¨‹åºå®Œæˆã€‚ DMA æŽ¥å£ä¸Žç³»ç»Ÿçš„è¿žæŽ¥æ–¹å¼ä¸»è¦æ˜¯ä¸¤ç§æ–¹å¼ï¼šå…·æœ‰å…¬å…±è¯·æ±‚çº¿çš„ DMA è¯·æ±‚å’Œç‹¬ç«‹çš„ DMA è¯·æ±‚ï¼Œè¿™æœ‰ç‚¹åƒæ˜¯å¹¶è”å’Œä¸²è”çš„å·®å¼‚ï¼ŸðŸ˜¦ DMA æ–¹å¼ä¸Žç¨‹åºä¸­æ–­æ–¹å¼çš„æ¯”è¾ƒ ç±»åˆ« ä¸­æ–­æ–¹å¼ DMAæ–¹å¼ã€ æ•°æ®ä¼ é€ ç¨‹åº ç¡¬ä»¶ å“åº”æ—¶é—´ æŒ‡ä»¤æ‰§è¡Œç»“æŸ å­˜å–å‘¨æœŸç»“æŸ å¤„ç†å¼‚å¸¸æƒ…å†µ èƒ½ ä¸èƒ½ ä¸­æ–­è¯·æ±‚ ä¼ é€æ•°æ® åŽå¤„ç† ä¼˜å…ˆçº§ ä½Ž é«˜ DMA æŽ¥å£çš„ç±»åž‹ä¹Ÿå°±æ˜¯ä¸‹é¢ä¸¤ç§ï¼š é€‰æ‹©åž‹ï¼š åœ¨ç‰©ç†ä¸Šè¿žæŽ¥å¤šä¸ªè®¾å¤‡ï¼Œåœ¨é€»è¾‘ä¸Šåªå…è®¸è¿žæŽ¥ä¸€ä¸ªè®¾å¤‡ã€‚ å¤šè·¯åž‹ï¼šåœ¨ç‰©ç†ä¸Šè¿žæŽ¥å¤šä¸ªè®¾å¤‡ï¼Œåœ¨é€»è¾‘ä¸Šå…è®¸è¿žæŽ¥å¤šä¸ªè®¾å¤‡ã€‚ æ€»ç»“è¿™ç« çš„å†…å®¹å¬èµ·æ¥çœŸçš„æ˜¯æž¯ç‡¥æ— å‘³å•Š...åŸºæœ¬ä¸Š 30s è¿‡åŽï¼Œç»å¯¹ä¼šèµ°ç¥žã€‚å“Žï¼Œè‡ªå·±çš„æ³¨æ„åŠ›å·²ç»å˜å¾—è¿™ä¹ˆéš¾ä»¥é›†ä¸­äº†ä¹ˆï¼ˆæ‰‹åŠ¨ç‹—å¤´ï¼‰... å›žåˆ°æ­£é¢˜ï¼Œè¾“å…¥è¾“å‡ºç³»ç»Ÿè¿™ä¸€å—çš„å†…å®¹åº”è¯¥åœ¨ä¿¡æ¯ä¼ é€çš„ä¸‰ç§æŽ§åˆ¶æ–¹å¼ä¸Šï¼Œå®¹æ˜“ä¸Žå…¶ä»–ç« èŠ‚çš„çŸ¥è¯†ç‚¹ç»“åˆèµ·æ¥å‡ºç»¼åˆé¢˜ã€‚æ‰€ä»¥é’ˆå¯¹åº”è¯•çš„è¯ï¼Œéœ€è¦æ‰¾ä¸€æ‰¾è¿™æ–¹é¢çš„é¢˜ç›®è¿›è¡Œç»ƒä¹ ã€‚å¦å¤–ï¼Œåœ¨å­¦ä¹ è¿™ç« çš„è¿‡ç¨‹ä¸­ï¼Œæœ‰ä¸€ä¸ªå¾ˆæ·±åˆ»çš„æ„Ÿå—ï¼šå¦‚æžœå­¦ä¹ è¿™é—¨è¯¾ä¹‹å‰å…ˆå­¦ä¹ äº†å¾®æœºåŽŸç†ï¼Œé‚£è¿™é—¨è¯¾å­¦èµ·æ¥åº”è¯¥æ’å®¹æ˜“ðŸ˜‚ï¼ŒåŽŸå› æ˜¯å› ä¸ºè¿™é—¨è¯¾ä»‹ç»äº†å¾ˆå¤šä¸Žç”µè·¯ç›¸å…³çš„ä¸œè¥¿ã€‚ PSï¼šåœ¨ MOOC ä¸Šçš„è¯¾ç¨‹ä¸­ï¼Œè¿™æ˜¯ä¸¤å‘¨çš„å†…å®¹ï¼Œè¿™é‡Œåªç®—ä¸€å‘¨çš„å†…å®¹ã€‚ PPSï¼šæœ€åŽè¡¥ä¸Šæœ€åŽä¸€ç« çš„æ€ç»´å¯¼å›¾...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_10_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F10%2F29%2F2023-10-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä¸çŸ¥ä¸è§‰ï¼Œæ¥ä¸Šæµ·ä¸€å¹´äº†... å¯¹å¾ˆå¤šäº‹æƒ…åˆæœ‰äº†æ–°çš„è®¤è¯†å•Š... Dust in the wind - KansasYour browser does not support the audio tag. æ—¶é—´è¿‡å¾—çœŸå¿«ï¼Œåˆæ˜¯ä¸€å¹´è¿‡åŽ»äº†ã€‚åœ¨å†™è¿™ç¯‡ blog ä¹‹å‰ï¼Œæˆ‘ä¸“é—¨çœ‹äº†ä¸‹åŽ»å¹´è¿™ä¸ªæœˆçš„ blogï¼Œçœ‹çœ‹è‡ªå·±åœ¨å¹²å˜›ï¼Œçœ‹çœ‹è‡ªå·±åœ¨æƒ³å•¥ã€‚æŠŠåŽŸæ¥çš„ç”Ÿæ´»è®°å½•ä¸‹æ¥ï¼ŒçŽ°åœ¨å›žæƒ³ä¸€ä¸‹å½“æ—¶è‡ªå·±çš„å¿ƒå¢ƒï¼Œå†è½¬å¤´çœ‹çœ‹çŽ°åœ¨çš„è‡ªå·±ï¼Œå¿ƒä¸­éš¾å…ä¼šå‡èµ·ä¸€ç§å¼‚æ ·çš„æƒ…ç»ªã€‚ å®žé™…ä¸Šï¼Œåœ¨è¿™ç¯‡ blog é‡Œï¼Œæˆ‘å¹¶ä¸æƒ³å†™è‡ªå·±è¿™ä¸€å¹´æ¥çš„æ„Ÿå—ï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†å°±ç•™åˆ°å¹´æœ«æ€»ç»“äº†ã€‚ å¥½äº†ï¼Œå›žåˆ°åæœˆæœ¬èº«æ¥ã€‚ åæœˆä»½çš„å·¥ä½œä¸å¿™ä¹Ÿä¸é—²ï¼Œä¹ŸåŸºæœ¬éƒ½æ˜¯æ­£å¸¸çš„å·¥ä½œèŠ‚å¥ã€‚ä½†æ˜¯è¿™ä¸ªæœˆå¾—åˆ°çš„æ¶ˆæ¯æ˜¯ï¼Œè¿™ä¸ªé¡¹ç›®å¿«è¦ä¸‹çº¿äº†ï¼Œå½“æ—¶å¿ƒé‡Œåªæœ‰ä¸€ä¸ªæƒ³æ³•ï¼šå¦ˆå‘€ï¼Œè¿™æ ·æˆ‘ä¸å°±å¤±ä¸šäº†å—ï¼Ÿå“ˆå“ˆðŸ˜‚ æ˜¾ç„¶ï¼Œè¿™ä¸ªäº‹æƒ…ä¸æ˜¯æˆ‘èƒ½å†³å®šçš„ï¼Œæ‰€ä»¥ä¸€åˆ†é’Ÿä¹‹åŽï¼Œå°±ä¸åŽ»æƒ³äº†ï¼Œå…ˆåšå¥½çœ¼å‰çš„å·¥ä½œå§ã€‚ä¸è¿‡ï¼Œå†…å¿ƒçš„å±æœºæ„Ÿå·²ç»æµ®çŽ°äº†ï¼Œæ¶ˆé™¤è¿™è‚¡æ„Ÿè§‰çš„æœ€å¥½æ–¹æ³•å°±æ˜¯å¿™èµ·æ¥ï¼Œæ‰€ä»¥è¦åŠ ç´§è‡ªå·±çš„å­¦ä¹ è®¡åˆ’å•Šã€‚ å­¦ä¹ æ–¹é¢çš„è¯ï¼Œè¿™ä¸ªæœˆæ‡ˆæ€ äº†å¾ˆå¤šï¼Œä¸è¿‡è¿˜æœ‰æ—¶é—´å¯ä»¥è¡¥å›žæ¥ï¼Œå¯ä»¥é¢„è§æŽ¥ä¸‹æ¥çš„æ—¥å­ä¼šå¿™ç¢Œèµ·æ¥ðŸ¥±ã€‚ ç”Ÿæ´»æ–¹é¢çš„è¯ï¼Œä¸Žå¾€å¸¸ä¸€æ ·ï¼Œæ²¡æœ‰å¤ªå¤§çš„å˜åŒ–ï¼Œè¯¥åƒåƒï¼Œè¯¥å–å–ï¼Œè¯¥ç¡ç¡ï¼Œå°±æ˜¯èº«ä½“å¥½åƒåˆæœ‰ä¸€ç‚¹ä¸èˆ’æœçš„æ„Ÿè§‰ï¼ˆå“Žï¼Œè¿™ä¹Ÿæ˜¯å¯¼è‡´è‡ªå·±å­¦ä¹ è®¡åˆ’ä¼šä¸­æ–­çš„åŽŸå› ï¼‰ã€‚é”»ç‚¼è®¡åˆ’è¿˜æ˜¯æ­£å¸¸çš„åœ¨è¿›è¡Œä¸­ï¼Œç›®å‰ä½“é‡å¤§æ¦‚åœ¨ 64KG å·¦å³ï¼Œæœç»é•¿èƒ–ðŸ˜ã€‚å¦å¤–ï¼Œé©¬ä¸ŠåŒåä¸€è¦åˆ°äº†ï¼Œæ­£ç¢ç£¨ç€ï¼Œè¦ä¸è¦ç»™è‡ªå·±ä¹°ç‚¹ä¸œè¥¿ï¼ŒæŒºæƒ³ä¹°ç‚¹è¡£æœå•¥çš„ï¼Œä½†æ˜¯è‡ªå·±åˆå«Œéº»çƒ¦æ‡’å¾—åŽ»æŒ‘é€‰ï¼Œå“ˆå“ˆã€‚ä¸Šä¸ªæœˆè¯´çš„ã€ŠRomanceã€‹å·²ç»æ˜¯ç»ƒå®Œäº†ï¼ŒçŽ°åœ¨ç»ƒä¹ çš„æ˜¯ã€Šå¥¹æ¥å¬æˆ‘çš„æ¼”å”±ä¼šã€‹ï¼Œè¿™é¦–æ­Œçš„ä¼´å¥è¿˜éœ€è¦å¥½å¥½ç»ƒä¹ ä¸‹ã€‚è¯è¯´ï¼Œæ–°çš„ç´å¼¦åˆä¸Šé”ˆäº†ã€‚ æœ€åŽï¼Œæƒ³å‘Šè¯‰è‡ªå·±çš„æ˜¯ï¼šèº«ä½“ä¼šæ…¢æ…¢æ¢å¤çš„ï¼Œä¸è¦æ‹…å¿ƒï¼ŒåŠ å¼ºé”»ç‚¼ï¼Œæ…¢æ…¢æ¥ï¼ŒæŠŠæ³¨æ„åŠ›æ”¾åœ¨è‡ªå·±åº”è¯¥åšä¸”æ„Ÿå…´è¶£çš„äº‹æƒ…ä¸Šï¼Œçæƒœæ—¶é—´ðŸ˜Œã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_5]]></title>
    <url>%2F2023%2F10%2F07%2FHIT-CO-Week-5%2F</url>
    <content type="text"><![CDATA[å‡æœŸç»“æŸï¼Œå­¦ä¹ ç»§ç»­ðŸ¤“ è¿™å‘¨æ˜¯å­˜å‚¨å™¨çš„æœ€åŽä¸€éƒ¨åˆ†äº†ï¼Œä½™ä¸‹çš„å†…å®¹ä¸ç®—å¤šï¼Œé‡ç‚¹åœ¨é«˜é€Ÿç¼“å†²å­˜å‚¨å™¨ï¼ˆCacheï¼‰è¿™ä¸€éƒ¨åˆ†ã€‚ Cacheæ¦‚è¿° é¦–å…ˆå›žç­”ç¬¬ä¸€ä¸ªé—®é¢˜ï¼šä¸ºä»€ä¹ˆä½¿ç”¨ Cacheï¼Ÿ ç­”æ¡ˆå¾ˆç®€å•ï¼Œç›®çš„æ˜¯ä¸ºäº†é¿å… CPU â€œç©ºç­‰â€çŽ°è±¡ï¼Œå¼¥è¡¥ CPU å’Œä¸»å­˜ï¼ˆDRAMï¼‰çš„é€Ÿåº¦å·®å¼‚ï¼Œä½¿è®¡ç®—æœºèƒ½ä»¥æ›´é«˜çš„æ•ˆçŽ‡è¿›è¡Œå·¥ä½œã€‚ å¦å¤–ï¼Œè¿˜å¾—æä¸€ä¸‹ç¨‹åºçš„å±€éƒ¨æ€§åŽŸç†ï¼Œå…·ä½“ç‚¹å‡»å‚è€ƒç™¾åº¦ï¼Œè¿™é‡Œä¸èµ˜è¿°äº†ã€‚ Cache çš„å·¥ä½œåŽŸç†ä¸»å­˜å’Œç¼“å­˜çš„ç¼–å€è§ä¸‹å›¾ï¼š ä¸»å­˜å’Œç¼“å­˜çš„å—å†…åœ°å€å®Œå…¨ä¸€æ ·ï¼Œå‡è®¾ç¼“å­˜å…±åˆ†ä¸º C å—ï¼Œä¸»å­˜å…±åˆ†ä¸º M å—ï¼Œé‚£ä¹ˆ M æ˜¯è¿œå¤§äºŽ C çš„ã€‚æ­¤æ—¶ï¼Œä¸»å­˜å—ä¼šè°ƒå…¥ç¼“å­˜ä¸­ï¼ˆè¿™æ ·ä¸»å­˜å—å°±ä¸Žç¼“å­˜å—å»ºç«‹äº†å¯¹åº”å…³ç³»ï¼‰ï¼ŒåŒæ—¶åˆ©ç”¨æ ‡è®°è®°å½•ä¸ŽæŸç¼“å­˜å—å»ºç«‹å¯¹åº”å…³ç³»çš„ä¸»å­˜å—å·ï¼Œè¿™æ ·å°±ç§°ç¼“å­˜å—å‘½ä¸­äº†ä¸»å­˜å—ã€‚ç›¸åï¼Œå¦‚æžœä¸»å­˜å—æœªè°ƒå…¥ç¼“å­˜ä¸­ï¼Œé‚£ä¹ˆä¸»å­˜å—ä¸Žç¼“å­˜å—å°±ä¸å­˜åœ¨å¯¹åº”å…³ç³»ï¼Œä¹Ÿå°±æ˜¯æœªå‘½ä¸­äº†ã€‚ ç”±æ­¤ï¼ŒCache ä¼šäº§ç”Ÿä¸€ä¸ªå«åšå‘½ä¸­çŽ‡($h$)çš„å‚æ•°ï¼Œä¹Ÿå³ï¼š$$h = \frac {N_c} {N_c + N_m}$$ä¸Šè¿°å¼å­ä¸­ï¼Œ$N_c$ è¡¨ç¤º Cache å®Œæˆå­˜å–çš„æ€»æ¬¡æ•°ï¼Œ$N_m$ è¡¨ç¤ºä¸»å­˜å®Œæˆå­˜å–çš„æ€»æ¬¡æ•°ã€‚ å¯¹åº”çš„ï¼ŒCache-ä¸»å­˜ç³»ç»Ÿçš„æ•ˆçŽ‡è§ä¸‹å›¾ï¼š å†çœ‹ä¸€ä¸‹ Cache çš„åŸºæœ¬ç»“æž„ï¼š Cache çš„è¯»æ“ä½œåªæœ‰ä¸€ç§ï¼š Cache çš„å†™æ“ä½œè¦å¤æ‚ä¸€äº›ï¼ˆå› ä¸ºéœ€è¦è€ƒè™‘ Cache å’Œä¸»å­˜çš„ä¸€è‡´æ€§é—®é¢˜ï¼‰ï¼Œæœ‰ä¸¤ç§ï¼š å†™ç›´è¾¾æ³•ï¼ˆWrite-throughï¼‰ï¼šå†™æ“ä½œæ—¶æ•°æ®æ—¢å†™å…¥ Cache åˆå†™å…¥ä¸»å­˜ï¼Œè¿™æ ·èƒ½ä¿è¯ Cache å’Œä¸»å­˜ä¸€è‡´ï¼Œä½†å¯èƒ½é€ æˆ CPU å¯¹åŒä¸€å†…å­˜å•å…ƒé‡å¤å†™çš„é—®é¢˜ã€‚å†™æ“ä½œæ—¶é—´å°±æ˜¯è®¿é—®ä¸»å­˜çš„æ—¶é—´ï¼ŒCache å—é€€å‡ºæ—¶ï¼Œä¸éœ€è¦å¯¹ä¸»å­˜æ‰§è¡Œå†™æ“ä½œï¼Œæ›´æ–°ç­–ç•¥æ¯”è¾ƒå®¹æ˜“å®žçŽ°ã€‚ å†™å›žæ³•ï¼ˆWrite-backï¼‰ï¼šå†™æ“ä½œæ—¶åªæŠŠæ•°æ®å†™å…¥ Cache è€Œä¸å†™å…¥ä¸»å­˜ï¼Œå½“ Cache æ•°æ®è¢«æ›¿æ¢å‡ºåŽ»æ—¶æ‰å†™å›žä¸»å­˜ã€‚æ­¤æ³•ä¸èƒ½ä¿è¯ Cache å’Œä¸»å­˜å®žæ—¶ä¸€è‡´ï¼ŒåŒæ—¶å› ä¸ºå¤šæ ¸ CPU çš„å­˜åœ¨ï¼Œä¸åŒæ ¸å¿ƒå¯¹åº”çš„ Cache å¯èƒ½ä¸åŒï¼Œç”±æ­¤ä¼šå¯¼è‡´ä¸åŒ Cache ä¸­åŒæ—¶å­˜åœ¨ä¸»å­˜çš„æŸä¸€ä¸ªå‰¯æœ¬ï¼Œè€Œä¸”è¿™äº›å‰¯æœ¬è¿˜ä¸èƒ½ç¡®å®šæ˜¯å¦ä¸€è‡´ã€‚å¦å¤–ï¼Œå†™æ“ä½œæ—¶é—´å°±æ˜¯è®¿é—® Cache çš„æ—¶é—´ï¼ŒCache å—é€€å‡ºæ—¶ï¼Œè¢«æ›¿æ¢çš„å—éœ€å†™å›žä¸»å­˜ï¼Œå¢žåŠ äº† Cache çš„å¤æ‚æ€§ã€‚ ä¸ºäº†æé«˜ Cache çš„æ•ˆçŽ‡ï¼Œé’ˆå¯¹ Cache è¿˜æœ‰ä¸€äº›æ”¹è¿›æŽªæ–½ï¼š å¢žåŠ  Cache çš„æŠ€æœ¯ï¼Œå¦‚ç‰‡è½½ï¼ˆç‰‡å†…ï¼‰Cacheï¼Œç‰‡å¤– Cacheã€‚ ç»Ÿä¸€ç¼“å­˜å’Œåˆ†ç«‹ç¼“å­˜ï¼Œå¦‚æŒ‡ä»¤ Cache å’Œæ•°æ® Cacheï¼Œå…·ä½“ä¸ŽæŒ‡ä»¤æ‰§è¡Œçš„æŽ§åˆ¶æ–¹å¼æœ‰å…³ã€‚ Cache-ä¸»å­˜çš„åœ°å€æ˜ å°„ä¸‰ç§æ˜ å°„æ–¹æ³•ï¼š ç›´æŽ¥æ˜ å°„ï¼šæ¯ä¸ªç¼“å­˜å—å¯ä»¥ä¸Žè‹¥å¹²ä¸ªä¸»å­˜å—å¯¹åº”ï¼›æ¯ä¸ªä¸»å­˜å—åªèƒ½ä¸Žä¸€ä¸ªç¼“å­˜å—å¯¹åº”ã€‚ å…¨ç›¸è”æ˜ å°„ï¼šä¸»å­˜ä¸­çš„ä»»ä¸€å—å¯ä»¥æ˜ å°„åˆ°ç¼“å­˜ä¸­çš„ä»»ä¸€å—ã€‚ ç»„ç›¸è”æ˜ å°„ï¼šæŸä¸€ä¸»å­˜å—æŒ‰æ¨¡ Q æ˜ å°„åˆ°ç¼“å­˜ä¸­çš„ç¬¬ i ç»„ä¸­çš„ä»»ä¸€å—ï¼Œç®—æ˜¯ç›´æŽ¥æ˜ å°„å’Œå…¨ç›¸è”æ˜ å°„çš„ç»“åˆç‰ˆï¼ˆä¹Ÿå¯ä»¥ç†è§£ä¸ºå°†ä¸»å­˜å’Œç¼“å­˜åˆ†ç»„ï¼Œç»„ä¹‹é—´ä¸ºç›´æŽ¥æ˜ å°„ï¼Œç»„å†…å†…å…¨ç›¸è”æ˜ å°„ï¼‰ã€‚ æ›¿æ¢ç®—æ³•æ›¿æ¢ç®—æ³•ä»‹ç»äº†ä¸¤ç§ï¼š å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼Œç±»ä¼¼é˜Ÿåˆ—ï¼‰ç®—æ³• è¿‘æœŸæœ€å°‘ä½¿ç”¨ï¼ˆLRUï¼‰ç®—æ³• è¾…åŠ©å­˜å‚¨å™¨è¾…åŠ©å­˜å‚¨å™¨æœ€ç›´æŽ¥çš„ç‰¹ç‚¹å°±æ˜¯ä¸ç›´æŽ¥ä¸Ž CPU äº¤æ¢ ä¿¡æ¯ï¼Œåªæ˜¯ä½œä¸ºä¸»å­˜çš„â€œè¾…åŠ©â€è€Œå­˜åœ¨ï¼Œå¸¸è§çš„è¾…åŠ©å­˜å‚¨å™¨åˆæœ‰ç£è¡¨é¢å­˜å‚¨å™¨ï¼ˆåˆå¯åˆ†ä¸ºç¡¬ç£å’Œè½¯ç£ï¼‰ã€å…‰ç›˜å­˜å‚¨å™¨ã€‚ ç£è¡¨é¢å­˜å‚¨å™¨çš„æŠ€æœ¯æŒ‡æ ‡ï¼š è®°å½•å¯†åº¦ å­˜å‚¨å®¹é‡ å¹³å‡å¯»å€æ—¶é—´ æ•°æ®ä¼ è¾“çŽ‡ è¯¯ç çŽ‡ ç£è®°å½•åŽŸç†å°±ä¸æ·±å…¥æŽ¢ç©¶äº†ã€‚ ç¡¬ç£ç›˜å­˜å‚¨å™¨çš„ç±»åž‹ï¼š å›ºå®šç£å¤´å’Œç§»åŠ¨ç£å¤´ å¯æ¢ç›˜å’Œå›ºå®šç›˜ ç¡¬ç£ç›˜å­˜å‚¨å™¨ç”±ç£ç›˜æŽ§åˆ¶å™¨ã€ç£ç›˜é©±åŠ¨å™¨å’Œç›˜ç‰‡ç»„æˆï¼Œè½¯ç›˜ä¸»è¦ç”±èšé…¯è–„è†œåˆ¶æˆã€‚ å…‰ç›˜å­˜å‚¨å™¨é‡‡ç”¨å…‰å­˜å‚¨æŠ€æœ¯ï¼Œåˆ©ç”¨æ¿€å…‰å†™å…¥å’Œè¯»å‡ºã€‚ç¬¬ä¸€ä»£å…‰å­˜å‚¨æŠ€æœ¯é‡‡ç”¨éžç£æ€§ä»‹è´¨ï¼Œä¸å¯æ“¦å†™ï¼›ç¬¬äºŒä»£å…‰å­˜å‚¨æŠ€æœ¯ï¼Œé‡‡ç”¨ç£æ€§ä»‹è´¨ï¼Œå¯æ“¦å†™ã€‚åªè¯»åž‹å’Œåªå†™ä¸€æ¬¡åž‹å…‰ç›˜çš„å­˜å‚¨åŽŸç†ä¸ºçƒ­ä½œç”¨ï¼ˆä¹Ÿå³ç‰©ç†æˆ–åŒ–å­¦å˜åŒ–ï¼‰ï¼Œå¯æ“¦å†™å…‰ç›˜çš„å­˜å‚¨åŽŸç†ä¸ºçƒ­ç£æ•ˆåº”ã€‚ æ€»ç»“è¿™ä¸€å‘¨è¯¾ç¨‹çš„é‡éš¾ç‚¹éƒ¨åˆ†åœ¨ Cache è¿™ä¸€å—ï¼Œä»Žåº”è¯•çš„è§’åº¦æ¥è®²ï¼Œè¿™éƒ¨åˆ†å†…å®¹å®¹æ˜“ä¸Žå…¶ä»–ç« èŠ‚å†…å®¹ç»“åˆï¼Œç„¶åŽç»„åˆåœ¨ä¸€èµ·ä½œä¸ºä¸€é“å¤§é¢˜å‡ºçŽ°ï¼Œå»ºè®®ç€é‡ç†è§£è¿™å—çŸ¥è¯†ç‚¹ã€‚ è¡¥é½å­˜å‚¨å™¨æ•´ä¸ªç« èŠ‚çš„æ€ç»´å¯¼å›¾ï¼š PSï¼šå­˜å‚¨å™¨ç®—æ˜¯å®Œç»“äº†ï¼Œè¿™ä¸ªæ€ç»´å¯¼å›¾å¥½å¤§å•Š~è¯´æ˜Žé›¶é›¶æ•£æ•£çš„çŸ¥è¯†ç‚¹çœŸçš„å¤š...ðŸ¥´]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_09_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F10%2F04%2F2023-09-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å›½åº†å‡æœŸåªæœ‰ 2 å¤©äº†å•Š...ðŸ˜ å“ˆå“ˆï¼Œæ”¾å‡å‰å‡ å¤©éƒ½åœ¨è‡ªå·±çŽ©è‡ªå·±çš„ï¼Œå®Œå…¨æ²¡æŠŠå†™ blog çš„äº‹æƒ…æ”¾åœ¨å¿ƒä¸Š...ðŸ˜‚ ä¸è¦å‘Šåˆ« - é«˜æ——&amp;è¶…è½½ä¹é˜ŸYour browser does not support the audio tag. æœ€è¿‘åœ¨å¬è¿™é¦–æ­Œï¼Œæ„Ÿæ…¨è‰¯å¤š...æ€»æ˜¯ä¼šè®©è‡ªå·±å›žå¿†åˆ°å¤§å­¦æ—¶ä»£ï¼ŒåŽæ‚”æ²¡æœ‰çŽ©ä¹é˜Ÿå•Šï¼Œä½†ä»”ç»†æƒ³æƒ³è‡ªå·±ä¹Ÿæ²¡æœ‰æ¡ä»¶çŽ©ï¼Œå“ˆå“ˆã€‚å¥½äº†ï¼Œå›žåˆ°æœ¬æ–‡çš„ä¸»é¢˜ã€‚ ä¹æœˆæ€»ä½“ä¸å¿™ï¼Œç›¸æ¯”ä¹‹å‰çš„å‡ ä¸ªæœˆï¼Œç®—æ˜¯æ¯”è¾ƒé—²çš„äº†ã€‚å¯¼è‡´è¿™ä¸ªç»“æžœçš„ç›´æŽ¥åŽŸå› ï¼Œå°±æ˜¯ä¹‹å‰å»¶æœŸçš„éœ€æ±‚ç»§ç»­å»¶æœŸåˆ°åæœˆåº•äº†ã€‚å°½ç®¡ä¸å¿™ï¼Œä½†æ˜¯æœˆåˆçš„æ—¶å€™å·®ç‚¹æƒ¹ä¸Šå¤§éº»çƒ¦ðŸ˜‘ï¼ŒåŽŸå› å°±æ˜¯å› ä¸ºè¿™ä¸ªéœ€æ±‚å»¶æœŸå¤ªä¹…äº†ï¼Œè€å¤§è¦äº²è‡ªæŠ“ä¸€ä¸‹ã€‚ä¸è¿‡å¥½åœ¨è·Ÿæˆ‘å…³ç³»ä¸å¤§ï¼Œå½±å“ä¸åˆ°æˆ‘è¿™é‡Œã€‚å®žé™…ä¸Šï¼ŒçŽ°åœ¨å›žæƒ³èµ·è¿™ä»¶äº‹ï¼Œå¿ƒä¸­ä¸å…ä¼šå†’å‡ºä¸€ä¸ªæƒ³æ³•ï¼šå¹¸å¥½å½“æ—¶å¬ Y è€å¸ˆçš„è¯ï¼Œä¸¥æ ¼æŒ‰ç…§éœ€æ±‚æ–‡æ¡£ä¸Šæ‰§è¡Œï¼Œéœ€æ±‚æœ‰ä¿®æ”¹ä¸€å®šè¦åŠæ—¶åŒæ­¥æ›´æ–°åˆ°éœ€æ±‚æ–‡æ¡£ä¸Šã€‚ä¸è¿‡ä»”ç»†æƒ³æƒ³ï¼Œè¿™æœ¬è´¨ä¸Šæ˜¯ä¸€ç§ä¸¥è°¨çš„å·¥ä½œæ€åº¦ï¼Œè‡ªå·±ä¸€å¼€å§‹æ˜¯æ²¡æœ‰æƒ³åˆ°â€œå£è¯´æ— å‡­â€è¿™ä¸ªé—®é¢˜çš„ï¼Œè¿˜æ˜¯è‡ªå·±å¤„ç†äº‹æƒ…ä¸å¤Ÿæˆç†Ÿå•ŠðŸ˜¤ã€‚æ€»è€Œè¨€ä¹‹ï¼Œè¿™ä¸ªäº‹æƒ…ç›®å‰å·²ç»ç¡®å®šè¦åœ¨åæœˆåº•ç»“æŸæŽ‰äº†ï¼ŒæŒ‰éƒ¨å°±ç­å®Œæˆå°±è¡Œäº†ã€‚ ç„¶åŽæ˜¯å­¦ä¹ æ–¹é¢ï¼Œè¿™ä¸ªæœˆä¸»è¦ä»Žä¸¤ä¸ªæ–¹é¢æ¥å¼€å±•ï¼š å› ä¸ºå·¥ä½œä¸å¿™çš„ç¼˜æ•…ï¼Œä»”ç»†è¯»äº†ã€ŠThe C Programming Languageã€‹è¿™æœ¬ä¹¦å‰ä¸ƒç« ï¼ˆå…³äºŽæœ¬ä¹¦çš„è¯„ä»·ï¼Œè¯·ç§»æ­¥å³ä¾§ Book Listï¼‰ï¼Œæœ‰ä¸€å®šçš„æ”¶èŽ·ï¼Œè¯»èµ·æ¥ä¹Ÿè§‰å¾—å¾ˆäº«å—ã€‚ å¼€å§‹ã€Šç»„æˆåŽŸç†ã€‹çš„å­¦ä¹ ï¼Œè¯¾ç¨‹é€‰æ‹©æ˜¯ MOOC ä¸Šå“ˆå·¥å¤§è¯¾ç¨‹ï¼Œç›¸å…³ blog ä¹Ÿå·²ç»æ›´æ–°ï¼Œè¯è¯´ç›®å‰è¿˜æ¬ ä¸€ç¯‡å‘¢ï¼Œå¤ªæ‡’äº†ðŸ¤£ å¯¹åº”çš„ï¼Œè¿™ä¸ªæœˆ Linux ç³»ç»Ÿå¼€å‘çš„è§†é¢‘çœ‹çš„å°±å°‘äº†ã€‚ä¸è¿‡å›žè¿‡å¤´çœ‹ï¼Œè§†é¢‘çš„å†…å®¹å…¶å®žå°±æ˜¯ã€ŠThe C Programming Languageã€‹å’Œã€ŠUnix çŽ¯å¢ƒé«˜çº§ç¼–ç¨‹ã€‹è¿™ä¸¤æœ¬ä¹¦çš„ç»“åˆä½“ï¼Œè¦ä¸‹åŠŸå¤«ç†è§£çŸ¥è¯†ï¼Œè¿˜æ˜¯å¾—ä»”ç»†çœ‹çœ‹è¿™ä¸¤æœ¬ä¹¦çš„éƒ¨åˆ†å†…å®¹ã€‚å¥½äº†ï¼Œè¶ç€å‡æœŸè¿˜æœ‰å‡ å¤©ï¼Œæœ€å¥½æŠŠæ²¡æœ‰å®Œæˆçš„å­¦ä¹ ä»»åŠ¡å®Œæˆäº†ã€‚ æœ€åŽå°±æ˜¯ç”Ÿæ´»äº†ï¼Œå“ˆå“ˆï¼Œæ¯æ¬¡æŠŠç”Ÿæ´»æ”¾åœ¨æœ€åŽï¼Œç”Ÿæ´»éƒ½è¦æœ‰æ„è§äº†ï¼ˆä¸»è¦æ˜¯è‡ªå·±ä¸€ä¸ªäººçš„ç”Ÿæ´»å…¶å®žä¹Ÿæ²¡ä»€ä¹ˆå¥½æçš„ðŸ¤£ï¼‰ã€‚ç”Ÿæ´»è¿˜æ˜¯æŒ‰éƒ¨å°±ç­çš„ç”Ÿæ´»ï¼Œä¸è¿‡è‡ªå·±å¼€å§‹æŽ¥è§¦æ¡Œçƒäº†ï¼Œæ„Ÿè§‰è¿˜æŒºå¥½çŽ©çš„ï¼Œå°±æ˜¯è§‰å¾—æœ‰ç‚¹éš¾ï¼Œæ‰“çƒçš„æ—¶å€™ç»å¸¸ä¼šæ„Ÿæ…¨æ€Žä¹ˆæŠŠä¸€ä¸ªçƒæ‰“è¿›æ´žï¼Œé‚£ä¹ˆéš¾å‘€...é”»ç‚¼æ–¹é¢ä¾ç„¶åœ¨è¿›è¡Œï¼Œä¸è¿‡åšæžœå’Œé¸¡èƒ¸è‚‰éƒ½è¦åƒå®Œäº†ï¼Œå¾—ä¹°ä¸€ç‚¹äº†ã€‚ç§‹å¤©å·²ç»æ¥äº†ï¼Œç¿»ç¿»è‡ªå·±çš„è¡£æœï¼Œéƒ½æ˜¯å¥½å‡ å¹´ä¹‹å‰çš„è¡£æœäº†ï¼Œå¾—ç»™è‡ªå·±ä¹°ç‚¹æ–°è¡£æœå’Œéž‹å­äº†ï¼Œçœ‹æ¥å¾—å¤šæ‰¾æ‰¾ç©¿æ­æ–¹é¢çš„æ”»ç•¥äº†ï¼Œå“ˆå“ˆðŸ˜„ã€‚è€å®žè®²ï¼Œå¦‚æžœæ˜¯ä»¥å‰çš„è‡ªå·±ï¼Œä¼šè®¤ä¸ºåšè¿™æ ·çš„äº‹æƒ…æ˜¯å¾ˆæ²¡æ„ä¹‰çš„ðŸ˜‚ï¼Œä¸è¿‡çŽ°åœ¨çš„æˆ‘è®¤ä¸ºï¼Œåœ¨ä¸ªäººå½¢è±¡ä¸Šçš„æŠ•èµ„ä¹Ÿæ˜¯åˆç†çš„ï¼Œä»»ä½•äº‹æƒ…æœ€å¥½éƒ½è¦è®¤çœŸå¯¹å¾…ï¼Œè¿™æ‰æ˜¯çŸ¥è¡Œåˆä¸€ã€‚ å¯¹äº†ï¼Œè¿˜è¦è¯´çš„ä¸€ä»¶äº‹æ˜¯æœ€è¿‘åœ¨ç»ƒã€ŠRomanceã€‹è¿™ä¸ªå¤å…¸å‰ä»–æ›²å­ï¼Œæ¯æ¬¡ç»ƒéƒ½è¦æ„Ÿæ…¨è¿™æ›²å­ä¸ºç”šä¹ˆä¼šè¿™ä¹ˆå¥½å¬ï¼Œç®€ç›´æ˜¯å¥½å¬çš„å“­äº†ðŸ˜­ã€‚å¯¹å¯¹äº†ï¼Œè¶è¿™æ¬¡æ”¾å‡ï¼Œæ¢äº†æ–°çš„ç´å¼¦ï¼Œä¸¤ä¸ªå­—ï¼Œèˆ’æœã€‚ ä»¥ä¸Šï¼Œå°±è¿™æ ·ï¼Œè¦åŽ»æŠŠè‡ªå·±çš„è„è¡£æœå¤„ç†ä¸€ä¸‹äº†ã€‚ðŸ˜‘]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_4]]></title>
    <url>%2F2023%2F09%2F23%2FHIT-CO-Week-4%2F</url>
    <content type="text"><![CDATA[è¿™ä¸€å‘¨å»¶ç»­ä¸Šå‘¨æ²¡è®²å®Œçš„ä¸»å­˜å‚¨å™¨çš„ä¸‹åŠéƒ¨åˆ†ðŸ¤... æŽ¥ç€ä¸Šå‘¨çš„å†…å®¹ï¼Œé¦–å…ˆä»‹ç»çš„åªè¯»å­˜å‚¨å™¨ï¼ˆROMï¼‰ã€‚ ROMåªè¯»å­˜å‚¨å™¨ï¼ˆRead-Only Memoryï¼‰ï¼Œé¡¾åæ€ä¹‰ï¼Œå°±æ˜¯åªèƒ½è¯»ä¸èƒ½å†™çš„å­˜å‚¨å™¨ï¼Œä½†çŽ°åœ¨çš„ ROMï¼ŒåŸºæœ¬éƒ½æ˜¯å¯è¯»å¯å†™çš„ï¼Œåªæ˜¯é€Ÿåº¦æ¯” RAM æ…¢è€Œå·²ã€‚å®žé™…ä¸Šï¼Œæ—©æœŸçš„ ROM è®¾å¤‡ç¡®å®žæ˜¯åªèƒ½è¯»ï¼ŒåŽæ¥éšç€å¸‚åœºéœ€æ±‚çš„æ”¹å˜ï¼Œæ‰è¯žç”Ÿäº†å¯è¯»å¯å†™çš„ ROMï¼Œå¹¶ä¸” ROM ä¹Ÿä¸æ˜¯ä¸€ä¸‹å­å°±å¯ä»¥å†™äº†ï¼Œè€Œæ˜¯æ…¢æ…¢å‘å±•æˆç›®å‰çš„æ ·å­çš„ã€‚ æŒ‰ç…§ä¹¦ä¸Šçš„ä»‹ç»ï¼ŒROM å…·ä½“åˆ†ä¸ºä»¥ä¸‹å‡ ç§ï¼š æŽ©è†œ ROMï¼ˆMROMï¼‰ï¼šè¡Œåˆ—é€‰æ‹©çº¿äº¤å‰å¤„æœ‰ MOS ç®¡ä¸º 1ï¼Œæ—  MOS ç®¡åˆ™ä¸º 0 PROMï¼ˆä¸€æ¬¡æ€§ç¼–ç¨‹ï¼‰ï¼šä»¥è¡Œã€åˆ—çº¿é—´çš„ç†”ä¸æ˜¯å¦ç†”æ–­åŒºåˆ† 1 å’Œ 0ï¼Œç†”æ–­ä¸º 0ï¼Œåä¹‹ä¸º 0 EPROMï¼ˆå¤šæ¬¡æ€§ç¼–ç¨‹ï¼‰ EEPROMï¼ˆä¹Ÿå« $E^2PROM$ï¼Œå¤šæ¬¡æ€§ç¼–ç¨‹ï¼‰ï¼šç”µå¯æ“¦å†™ï¼Œæ”¯æŒå±€éƒ¨æ“¦å†™å’Œå…¨éƒ¨æ“¦å†™ Flash Memoryï¼ˆé—ªé€Ÿåž‹å­˜å‚¨å™¨ï¼Œä¹Ÿå«é—ªå­˜ï¼‰ï¼šè¯»å†™é€Ÿåº¦å¾ˆå¿«ã€åŠŸè€—ä½Žï¼Œä½†ä»·æ ¼è¾ƒé«˜ å­˜å‚¨å™¨ä¸Ž CPU çš„è¿žæŽ¥è¿™ä¸€å—å†…å®¹ç®—æ˜¯é‡ç‚¹ä¸Žéš¾ç‚¹å†…å®¹äº†ðŸ¤ã€‚ å­˜å‚¨å™¨å®¹é‡çš„æ‰©å±•é¦–å…ˆæ˜¯å­˜å‚¨å™¨å®¹é‡çš„æ‰©å±•ï¼Œä¸»è¦æ˜¯ä¸‰ç§æ–¹å¼ï¼šä½æ‰©å±•ã€å­—æ‰©å±•å’Œå­—ä½æ‰©å±•ã€‚ ä½æ‰©å±•ä½æ‰©å±•å…¶å®žå°±æ˜¯å¢žåŠ å­˜å‚¨å­—é•¿ï¼Œæ¯”å¦‚ç”¨ 2 ç‰‡ $1K \times 4$ ä½å­˜å‚¨èŠ¯ç‰‡ç»„æˆ $1K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ï¼Œå°±åªæ˜¯æŠŠå­˜å‚¨å­—é•¿æ‰©å¤§äº†ä¸€å€ã€‚ä½†ä¸è®ºæ˜¯ 2 ç‰‡ $1K \times 4$ ä½å­˜å‚¨èŠ¯ç‰‡è¿˜æ˜¯ 1 ç‰‡ $1K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ï¼Œæ€»ä½“çš„å­˜å‚¨å®¹é‡éƒ½æ˜¯ $8K$ ä½ï¼ˆè¿™ä¸ªè¯´æ³•å¯èƒ½ä¸ä¸¥è°¨ï¼Œæ‡‚æ„æ€å³å¯ï¼‰ã€‚ å­—æ‰©å±•å­—æ‰©å±•å°±æ˜¯å¢žåŠ å­˜å‚¨å­—çš„æ•°é‡ï¼Œæ¯”å¦‚ç”¨ 2 ç‰‡ $1K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ç»„æˆ $2K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ï¼Œæœ¬è´¨ä¸Šç›¸å½“äºŽæ˜¯æŠŠå­˜å‚¨å•å…ƒçš„æ•°ç›®æ‰©å¤§äº†ä¸€å€ã€‚ä½†ä¸è®ºæ˜¯ 2 ç‰‡ $1K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡è¿˜æ˜¯ 1 ç‰‡$2K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ï¼Œæ€»ä½“çš„å­˜å‚¨å®¹é‡éƒ½æ˜¯ $16K$ ä½ã€‚ å­—ã€ä½æ‰©å±•å­—ã€ä½æ‰©å±•å°±æ˜¯å­—æ‰©å±•ä¸Žä½æ‰©å±•ç»“åˆä½¿ç”¨çš„æ–¹å¼ï¼Œæ¯”å¦‚ç”¨ 8 ç‰‡ $1K \times 4$ ä½å­˜å‚¨èŠ¯ç‰‡ç»„æˆ $4K \times 8$ ä½å­˜å‚¨èŠ¯ç‰‡ã€‚ ä¸Ž CPU çš„è¿žæŽ¥å­˜å‚¨å™¨ä¸Ž CPU çš„è¿žæŽ¥ä¸»è¦åŒ…æ‹¬å…­ä¸ªéƒ¨åˆ†ï¼š åœ°å€çº¿çš„è¿žæŽ¥ æ•°æ®çº¿çš„è¿žæŽ¥ è¯»/å†™å‘½ä»¤çº¿çš„è¿žæŽ¥ ç‰‡é€‰çº¿çš„è¿žæŽ¥ åˆç†é€‰æ‹©å­˜å‚¨èŠ¯ç‰‡ å…¶ä»–èŠ¯ç‰‡æˆ–æŽ§åˆ¶ç”µè·¯ï¼Œå¦‚æ—¶åºã€è´Ÿè½½ ä»¥ä¹¦ä¸Šçš„ä¾‹é¢˜ 4.1 å’Œ 4.2 ä½œä¸ºä¾‹å­ï¼Œè€å¸ˆè®²çš„å¾ˆæ¸…æ¥šï¼Œä¹¦ä¸Šå†™çš„ä¹Ÿå¾ˆæ¸…æ¥šï¼Œè¿™é‡Œä¸å†èµ˜è¿°äº†ï¼Œåªè®°å½•ä¸‹ä¸»è¦çš„è§£é¢˜æ­¥éª¤æ˜¯ï¼š å†™å‡ºç›¸åº”çš„äºŒè¿›åˆ¶åœ°å€ç  ç¡®å®šèŠ¯ç‰‡çš„æ•°é‡åŠç±»åž‹ åˆ†é…åœ°å€çº¿ ç¡®å®šç‰‡é€‰ä¿¡å· å­˜å‚¨å™¨çš„æ ¡éªŒå­˜å‚¨å™¨çš„æ ¡éªŒæ˜¯é€šè¿‡ä¸€ç³»åˆ—çš„ç¼–ç æ–¹æ³•æ¥å®Œæˆçš„ï¼Œè¿™ä¸€ç« ä¸»è¦ä»‹ç»æ±‰æ˜Žç ã€‚é¦–å…ˆè¦æ˜Žç¡®æ±‰æ˜Žç ä¸­ç è·çš„æ¦‚å¿µï¼Œä¹Ÿå³ä¸¤ä¸ªåˆæ³•ä»£ç å¯¹åº”ä½ä¸Šç¼–ç ä¸åŒçš„ä½æ•°ç§°ä¸ºç è·ã€‚ç¼–ç çš„çº é”™ã€æ£€é”™èƒ½åŠ›ä¸Žç¼–ç çš„æœ€å°è·ç¦»æœ‰å…³ï¼Œè€Œæ±‰æ˜Žç æ˜¯å…·æœ‰ä¸€ä½çº é”™èƒ½åŠ›çš„ç¼–ç ã€‚ éœ€è¦æ³¨æ„ä»¥ä¸‹æ±‰æ˜Žç ç»„æˆçš„ä¸‰è¦ç´ ï¼Œå¦‚ä¸‹å›¾ï¼š æ±‰æ˜Žç çš„é…ç½®ã€æ£€é”™è¿‡ç¨‹ï¼Œè¿™é‡Œå°±ä¸å†èµ˜è¿°äº†ï¼Œè€å¸ˆè®²è§£çš„å¾ˆæ¸…æ™°ï¼Œä¹¦ä¸Šä¹Ÿè§£é‡Šå¾ˆæ¸…æ¥šã€‚ æé«˜è®¿å­˜é€Ÿåº¦çš„æŽªæ–½æŒ‰ç…§è€å¸ˆçš„è®²è§£ï¼Œæé«˜è®¿å­˜é€Ÿåº¦çš„æ€è·¯å°±æ˜¯ä¸‰ä¸ªæ–¹é¢ï¼š é‡‡ç”¨é«˜é€Ÿå™¨ä»¶ é‡‡ç”¨å±‚æ¬¡ç»“æž„ï¼Œæ¯”å¦‚ Cache-ä¸»å­˜ è°ƒæ•´ä¸»å­˜ç»“æž„ å‰ä¸¤ç‚¹å·²ç»åœ¨å‰é¢æåˆ°è¿‡äº†ï¼Œè¿™é‡Œåœ¨æä¸€ä¸‹ç¬¬ä¸‰ä¸ªæ€è·¯ï¼Œä¸»è¦æœ‰ä¸¤ä¸ªæ–¹å¼ï¼š å•ä½“å¤šå­—ç³»ç»Ÿï¼Œæœ¬è´¨æ˜¯å¢žåŠ å­˜å‚¨å™¨å¸¦å®½ å¤šä½“å¹¶è¡Œç³»ç»Ÿï¼Œåˆ†ä¸ºä¸¤ç§æ–¹å¼ï¼šé«˜ä½äº¤å‰ã€é¡ºåºç¼–å€ï¼ˆå„ä¸ªä½“å¹¶è¡Œå·¥ä½œï¼‰å’Œä½Žä½äº¤å‰ã€å„ä¸ªä½“è½®æµç¼–å€ï¼ˆåœ¨ä¸æ”¹å˜å­˜å–å‘¨æœŸçš„å‰æä¸‹ï¼Œå¢žåŠ å­˜å‚¨å™¨çš„å¸¦å®½ï¼‰ã€‚ æœ€åŽçš„å†…å®¹å°±æ˜¯å‡ ç§é«˜æ€§èƒ½å­˜å‚¨èŠ¯ç‰‡ï¼š SDRAMï¼ˆåŒæ­¥ DRAMï¼‰ï¼Œåœ¨ç³»ç»Ÿæ—¶é’Ÿçš„æŽ§åˆ¶ä¸‹è¿›è¡Œè¯»å‡ºå’Œå†™å…¥ï¼ŒCPU æ— é¡»ç­‰å¾…ï¼Œä¹Ÿå°±æ˜¯çŽ°ä»£è®¡ç®—æœºçš„å†…å­˜æ¡ RDRAMï¼Œç”± Rambus å¼€å‘ï¼Œä¸»è¦è§£å†³å­˜å‚¨å™¨å¸¦å®½é—®é¢˜ å¸¦ Cache çš„ DRAMï¼Œåœ¨ DRAM çš„èŠ¯ç‰‡å†…é›†æˆäº†ä¸€ä¸ªç”± SRAM ç»„æˆçš„ Cacheï¼Œæœ‰åˆ©äºŽçŒå‘å¼è¯»å– æ€»ç»“åœ¨ä¸Šå‘¨åŸºç¡€ä¸Šæ·»åŠ æœ¬å‘¨å†…å®¹åŽçš„æ€ç»´å¯¼å›¾ï¼š æœ¬å‘¨çš„é‡ç‚¹å†…å®¹åœ¨å­˜å‚¨å™¨ä¸Ž CPU çš„è¿žæŽ¥éƒ¨åˆ†ï¼Œä»Žåº”è¯•çš„è§’åº¦æ¥è®²ï¼Œè¿™å—å†…å®¹åº”è¯¥å¾ˆå®¹æ˜“å‡ºç»¼åˆå¤§é¢˜ï¼Œå› ä¸ºè¿™é‡Œå¯ä»¥æŠŠ CPU å’Œæ€»çº¿çš„å†…å®¹ç»“åˆèµ·æ¥ï¼Œæ‰€ä»¥æœ€å¥½æŠŠä¹¦ä¸Šçš„å‡ ä¸ªä¾‹é¢˜åƒé€ã€‚è¿˜æœ‰ä¸€ä¸ªè€ƒç‚¹ï¼Œåº”è¯¥æ˜¯æ±‰æ˜Žç ï¼Œè¿™å—çŸ¥è¯†ç‚¹ï¼Œè¦æ˜¯ä¸ç†è§£ï¼Œåšé¢˜ä¼°è®¡è¿˜æ˜¯é”™ï¼Œå»ºè®®æ‰¾é¢˜ç›®åšåšçœ‹ã€‚å¥½æ¶ˆæ¯æ˜¯ï¼Œæˆ‘ä¸ç”¨è€ƒè¯•äº†ï¼Œåªè¦ç†è§£å¤§éƒ¨åˆ†çŸ¥è¯†ç‚¹å°±å¯ä»¥äº†ðŸ˜‚ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_3]]></title>
    <url>%2F2023%2F09%2F15%2FHIT-CO-Week-3%2F</url>
    <content type="text"><![CDATA[è¿™å‘¨å­˜å‚¨å™¨ï¼Œä¸çŸ¥é“ä¼šä¸ä¼šæœ‰è¶£ä¸€ç‚¹...ðŸ˜´å¬å®Œäº†ï¼Œæ‰çŸ¥é“ä¹Ÿä¸æ˜¯å¾ˆæœ‰è¶£...ðŸ˜‚ æœ‰å…³å­˜å‚¨å™¨çš„å†…å®¹ä¸€å…±åˆ†äº†ä¸‰å‘¨çš„è¯¾ç¨‹ï¼Œè¿™å‘¨çš„ä¸»è¦å†…å®¹æ˜¯æœ‰å…³ä¸»å­˜å‚¨å™¨çš„éƒ¨åˆ†ã€‚ å­˜å‚¨å™¨é¦–å…ˆè¦ä»‹ç»çš„æ˜¯å­˜å‚¨å™¨çš„åˆ†ç±»å’ŒçŽ°ä»£å­˜å‚¨å™¨çš„å±‚æ¬¡ç»“æž„ã€‚ åˆ†ç±»1. æŒ‰ç…§å­˜å‚¨ä»‹è´¨åˆ†ç±» åŠå¯¼ä½“å­˜å‚¨å™¨ ç£è¡¨é¢å­˜å‚¨å™¨ ç£èŠ¯å­˜å‚¨å™¨ å…‰ç›˜å­˜å‚¨å™¨ æ³¨æ„ï¼šåŠå¯¼ä½“å­˜å‚¨å™¨å­˜å‚¨çš„ä¿¡æ¯æ˜¯æ˜“å¤±çš„ï¼Œè€Œå…¶ä»–ä¸‰ç§å­˜å‚¨å™¨æ˜¯éžæ˜“å¤±çš„ã€‚ 2. æŒ‰ç…§å­˜å–æ–¹å¼åˆ†ç±» å½“å­˜å–æ—¶é—´ä¸Žç‰©ç†åœ°å€æ— å…³ï¼ˆéšæœºè®¿é—®ï¼‰ï¼Œå¯åˆ†ä¸ºéšæœºå­˜å‚¨å™¨ï¼ˆåœ¨ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹å¯è¯»å¯å†™ï¼‰å’Œåªè¯»å­˜å‚¨å™¨ï¼ˆåœ¨ç¨‹åºçš„æ‰§è¡Œè¿‡ç¨‹ä¸­åªè¯»ï¼‰ã€‚ å½“å­˜å–æ—¶é—´ä¸Žç‰©ç†åœ°å€æœ‰å…³ï¼ˆä¸²è¡Œè®¿é—®ï¼‰ï¼Œå¯åˆ†ä¸ºé¡ºåºå­˜å–å­˜å‚¨å™¨ï¼ˆå¦‚ç£å¸¦ï¼‰å’Œç›´æŽ¥å­˜å–å­˜å‚¨å™¨ï¼ˆç£ç›˜ï¼‰ 3. æŒ‰åœ¨è®¡ç®—æœºä¸­çš„ä½œç”¨åˆ†ç±» å±‚æ¬¡ç»“æž„ä¸å¤šè¯´äº†ï¼Œä¸»è¦çœ‹ä¸‹é¢ä¸¤å¼ å›¾ï¼š ä¸Šé¢è¿™å¼ å›¾ä¸»è¦æ˜¯åœ¨è¯´æ˜Žï¼šè¶Šè´´è¿‘ CPU çš„å­˜å‚¨ä»‹è´¨çš„é€Ÿåº¦è¶Šå¿«ã€å®¹é‡è¶Šå°ã€ä»·æ ¼è¶Šè´µï¼Œæ‰€ä»¥å¦‚ä½•æŠŠè®¡ç®—æœºçš„ç»“æž„è®¾è®¡çš„ç»æµŽåˆç†å°±æ˜¯ä¸€ä¸ªå¾ˆé‡è¦çš„é—®é¢˜äº†ã€‚ è¿™å¼ å›¾å®žé™…ä¸Šå°±æ˜¯ä¸Šè¿°é—®é¢˜çš„ç­”æ¡ˆï¼Œå¯¹äºŽç”¨æˆ·ä½“éªŒè€Œè¨€ï¼Œå¹¶ä¸éœ€è¦æ¯ä¸€å—å­˜å‚¨èŠ¯ç‰‡éƒ½æœ‰å¾ˆå¿«çš„è¯»å†™é€Ÿåº¦ï¼ˆå¯¹ç”¨æˆ·è€Œè¨€ï¼Œæ€§ä»·æ¯”æ‰æ˜¯çŽ‹é“ï¼Œå“ˆå“ˆ~ï¼‰ï¼Œè€Œä¸”ä»ŽåŠŸèƒ½ä¸Šè€Œè¨€ï¼Œé€Ÿåº¦ä¾æ¬¡é€’å‡ä¹Ÿä¸ä¼šå¯¹æ•´ä¸ªè®¡ç®—æœºæž„æˆå½±å“ã€‚ ä¸»å­˜å‚¨å™¨ ç¬¬ä¸€å¼ æåˆ°çš„æœ‰å…³å­˜å‚¨å™¨çš„çŸ¥è¯†è¿™é‡Œä¾ç„¶ç”¨å¾—åˆ°ï¼Œä¹‹å‰æ˜¯å¤§æ¦‚äº†è§£ï¼ŒçŽ°åœ¨æ˜¯æ·±å…¥äº†è§£ã€‚ æ¦‚è¿°é¦–å…ˆè¦äº†è§£çš„æ˜¯ä¸»å­˜å‚¨å™¨çš„åŸºæœ¬ç»„æˆï¼Œè§ä¸‹å›¾ï¼ˆè¿˜æ˜¯ç”µè·¯ä¹‹ç±»çš„ä¸œè¥¿ï¼‰ï¼š å¯¹åº”çš„æ˜¯ï¼ŒCPU å’Œä¸»å­˜çš„è”ç³»ï¼Œè§ä¸‹å›¾ï¼š è¿™é‡Œåˆæåˆ°äº†å¤§ç«¯å­˜å‚¨å’Œå°ç«¯å­˜å‚¨çš„æ¦‚å¿µï¼š å¤§ç«¯å­˜å‚¨ï¼šæ•°æ®çš„é«˜å­—èŠ‚ä¿å­˜åœ¨å†…å­˜çš„ä½Žåœ°å€ä¸­ï¼Œè€Œæ•°æ®çš„ä½Žå­—èŠ‚ä¿å­˜åœ¨å†…å­˜çš„é«˜åœ°å€ä¸­ã€‚å°æ®µæ¨¡å¼ï¼šæ•°æ®çš„é«˜å­—èŠ‚ä¿å­˜åœ¨å†…å­˜çš„é«˜åœ°å€ä¸­ï¼Œè€Œæ•°æ®çš„ä½Žå­—èŠ‚ä¿å­˜åœ¨å†…å­˜çš„ä½Žåœ°å€ä¸­ã€‚ ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œ0x12345678ï¼Œå¦‚æžœæ˜¯å¤§ç«¯æ¨¡å¼ï¼Œå¯¹åº”å†…å­˜ä¸­ä¿å­˜çš„å€¼å°±æ˜¯12 34 56 78ï¼›å¦‚æžœæ˜¯å°ç«¯æ¨¡å¼ï¼Œå¯¹åº”å†…å­˜ä¸­ä¿å­˜çš„å€¼å°±æ˜¯78 56 34 12ã€‚ æœ€åŽæ˜¯ä¸»å­˜çš„æŠ€æœ¯æŒ‡æ ‡ï¼Œä¸»è¦æ˜¯æ˜¯å­˜å‚¨å®¹é‡ã€å­˜å–é€Ÿåº¦ã€å­˜å‚¨å¸¦å®½ï¼ˆä½/ç§’ï¼‰è¿™äº›æ¦‚å¿µã€‚ å­˜å–é€Ÿåº¦ç›¸å…³çš„æ¦‚å¿µæœ‰ä¸¤ä¸ªï¼šå­˜å–æ—¶é—´ï¼šå­˜å‚¨å™¨çš„è®¿é—®æ—¶é—´ï¼Œå¯åˆ†ä¸ºè¯»å‡ºæ—¶é—´å’Œå†™å…¥æ—¶é—´ã€‚å­˜å–å‘¨æœŸï¼šè¿žç»­ä¸¤æ¬¡ç‹¬ç«‹çš„å­˜å‚¨å™¨æ“ä½œï¼ˆè¯»æˆ–å†™ï¼‰æ‰€éœ€çš„æœ€å°é—´éš”æ—¶é—´ï¼Œå¯åˆ†ä¸ºè¯»å‘¨æœŸå’Œå†™å‘¨æœŸã€‚ åŠå¯¼ä½“å­˜å‚¨èŠ¯ç‰‡é¦–å…ˆè¦å­¦ä¹ çš„æ˜¯åŠå¯¼ä½“å­˜å‚¨èŠ¯ç‰‡çš„ç›¸å…³çŸ¥è¯†ï¼Œä¸»è¦åˆ†ä¸¤å—ï¼šåŸºæœ¬ç»“æž„å’Œè¯‘ç é©±åŠ¨æ–¹å¼ã€‚ åŸºæœ¬ç»“æž„åŠå¯¼ä½“å­˜å‚¨èŠ¯ç‰‡çš„åŸºæœ¬ç»“æž„è§ä¸‹å›¾ï¼š ç›¸æ¯”å‰é¢ä»‹ç»çš„ä¸»å­˜çš„åŸºæœ¬ç»„æˆï¼Œå¤šäº†ç‰‡é€‰çº¿ï¼ˆç¡®å®šé‚£å—å­˜å‚¨èŠ¯ç‰‡è¢«é€‰ä¸­ï¼‰å’Œè¯»å†™æŽ§åˆ¶çº¿ï¼ˆç¡®å®šèŠ¯ç‰‡è¿›è¡Œè¯»/å†™æ“ä½œï¼‰ã€‚å®žé™…ä¸Šï¼Œä¸ªäººè®¤ä¸ºè¿™ä¸¤éƒ¨åˆ†ç»„åˆåœ¨ä¸€èµ·å°±æ˜¯å­˜å‚¨å™¨çš„â€œæŽ§åˆ¶å™¨â€ï¼Œç”±å®ƒæ¥å†³å®šå­˜å‚¨å™¨çš„ä¸€äº›è¡Œä¸ºã€‚å¦å¤–ï¼Œç‰‡é€‰çº¿ä¸­å­˜åœ¨ä¸¤ä¸ªä¿¡å·ï¼š$\overline {CE}$ å’Œ $\overline {CS}$ï¼›è¯»/å†™æŽ§åˆ¶çº¿ä¸­å­˜åœ¨ä¸‰ä¸ªä¿¡å·ï¼š$\overline {WE}$ï¼ˆä½Žç”µå¹³å†™ï¼Œé«˜ç”µå¹³è¯»ï¼‰ã€$\overline {OE}$ï¼ˆå…è®¸è¯»ï¼‰å’Œ $\overline {OE}$ï¼ˆå…è®¸å†™ï¼‰ã€‚ å…³äºŽç‰‡é€‰ä¿¡å·çš„ä½œç”¨ï¼Œè€å¸ˆä¸¾äº†ä¸€ä¸ªä¾‹å­ï¼šç»„æˆä¸€ä¸ª$64K \times 8$ä½çš„å­˜å‚¨èŠ¯ç‰‡éœ€è¦ä½¿ç”¨ 4 ç»„$16K \times 1$ä½çš„å­˜å‚¨èŠ¯ç‰‡ï¼Œä¸”æ¯ç»„ 8 ä¸ªï¼Œä¸€å…± 64 ä¸ªï¼Œæ­¤æ—¶ç”±ä¸¤ä¸ªç‰‡é€‰ä¿¡å·å°±å¯ä»¥å”¯ä¸€ç¡®å®šæ˜¯å¯¹é‚£ä¸€å—$16K \times 1$çš„èŠ¯ç‰‡è¿›è¡Œæ“ä½œï¼Œå®žé™…ä¸Šè¿™ä¸ªè¿‡ç¨‹ç±»ä¼¼äºŽé€šè¿‡çŸ©é˜µçš„è¡Œåˆ—åæ ‡æ¥ç¡®å®šå…¶ä¸­çš„ç‰¹å®šå…ƒç´ ã€‚ è¯‘ç é©±åŠ¨åŠå¯¼ä½“èŠ¯ç‰‡çš„è¯‘ç é©±åŠ¨æ–¹å¼è¿™é‡Œä»‹ç»äº†ä¸¤ç§ï¼šçº¿é€‰æ³•å’Œé‡åˆæ³•ã€‚ çº¿é€‰æ³•å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š $A_0 - A_3$ä½œä¸ºåœ°å€ç ä¼šè¢«åœ°å€è¯‘ç å™¨è§£æžä¸ºå¯¹åº”çš„å­—çº¿ï¼Œ4 ä¸ª bit æ­£å¥½å¯¹åº” 16 æ ¹çº¿ï¼Œè¿˜æœ‰ 8 æ ¹ä½çº¿è¿žæŽ¥åœ¨è¯»/å†™æŽ§åˆ¶ç”µè·¯ä¸Šã€‚ é‡åˆæ³•å¦‚ä¸‹å›¾æ‰€ç¤ºï¼š é‡åˆæ³•æ„Ÿè§‰è¦ç®€å•ä¸€ç‚¹ï¼Œ$A_0 - A_4$ä½œä¸º X åœ°å€ç ï¼Œ5 ä¸ª bit ä½å¯¹åº” 32 æ ¹çº¿ï¼Œ$A_5 - A_9$ä½œä¸º Y åœ°å€ç ï¼Œä¹Ÿæ˜¯ 5 ä¸ª bit ä½ï¼Œå¯¹åº” 32 æ ¹çº¿ï¼ŒXã€Y å®žé™…ä¸Šå°±å¯ä»¥å½“ä½œæ˜¯æ¨ªçºµåæ ‡äº†ã€‚ RAMéšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆRAMï¼‰åˆ†ä¸ºä¸¤ç§ï¼šé™æ€éšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆSRAMï¼‰å’ŒåŠ¨æ€éšæœºå­˜å–å­˜å‚¨å™¨ï¼ˆDRAMï¼‰ã€‚ SRAMé™æ€éšæœºå­˜å–å­˜å‚¨å™¨æ˜¯ç”±åŒç¨³æ€è§¦å‘å™¨ç»„æˆï¼Œæ–­ç”µåŽä¼šä¸¢å¤±ä¿¡æ¯ï¼Œå­˜å–é€Ÿåº¦å¿«ï¼ŒåŸºæœ¬ç”µè·¯å¦‚ä¸‹ï¼š è¿™é‡Œä¸æ·±ç©¶ç”µè·¯çš„è®¾è®¡æ€è·¯å’ŒåŽŸç†äº†...ðŸ¤ è¯»æ“ä½œï¼š å†™æ“ä½œï¼š æœ€åŽæåˆ°äº†ä¸€ä¸ªå®žé™…ç”¨é‡åˆæ³•ç»„æˆçš„èŠ¯ç‰‡â€”â€”Intel 2114ï¼Œæœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª$64 \times 64$çš„çŸ©é˜µï¼Œè¿™é‡Œä¸åšæ·±ç©¶äº†ã€‚ DRAMåŠ¨æ€éšæœºå­˜å–å­˜å‚¨å™¨æ˜¯ç”±ç”µå®¹ç»„æˆï¼ŒåŒæ ·æ–­ç”µåŽä¼šä¸¢å¤±ä¿¡æ¯ï¼Œé€Ÿåº¦æ¯” SRAM æ…¢ï¼ŒåŸºæœ¬ç”µè·¯å¦‚ä¸‹ï¼š åœ¨ä¸Šå›¾ä¸­ï¼Œå·¦è¾¹æ˜¯ä¸‰ç®¡å¼å­˜å‚¨ç”µè·¯ï¼Œå³è¾¹æ˜¯å•ç®¡å¼å­˜å‚¨ç”µè·¯ã€‚ ä¸‰ç®¡åŠ¨æ€ RAM èŠ¯ç‰‡çš„è¯»å†™æ“ä½œè¿‡ç¨‹æ˜¯ç±»ä¼¼çš„ï¼Œè¿™é‡Œç®€å•åˆ†æžä¸€ä¸‹ Intel 1103 èŠ¯ç‰‡çš„å†™æ“ä½œï¼Œå¦‚ä¸‹å›¾ï¼š å®žé™…ä¸Šå°±æ˜¯ä¸‹é¢ä¸¤ä¸ªè¦ç‚¹ï¼š ä¸Žé‡åˆæ³•ç±»ä¼¼ï¼Œä¸‰ç®¡åŠ¨æ€ RAM èŠ¯ç‰‡çš„è¯‘ç è¿‡ç¨‹ä¹Ÿæ˜¯éœ€è¦åˆ†åˆ«ä½¿ç”¨è¡Œåˆ—åœ°å€è¯‘ç å™¨æ¥å®Œæˆï¼Œä¸åŒçš„åœ°æ–¹åœ¨äºŽä¸‰ç®¡å¼åŒºåˆ†å¼€äº†è¯»/å†™é€‰æ‹©çº¿ï¼Œæ‰€ä»¥è¡Œåœ°å€è¯‘ç çš„è¿‡ç¨‹å®žé™…ä¸Šæœ‰è¯»å†™æŽ§åˆ¶ç”µè·¯çš„å‚ä¸Žã€‚ æ¯ä¸€åˆ—éƒ½éœ€è¦æœ‰ä¸€ä¸ªåˆ·æ–°æ”¾å¤§å™¨æ¥å½¢æˆå†ç”Ÿä¿¡æ¯ï¼ŒåŽŸå› æ˜¯ç”µå®¹ä¼šæ¼ç”µï¼ˆè€å¸ˆçš„åŽŸè¯ðŸ˜ï¼‰ã€‚ ç„¶åŽæ˜¯å•ç®¡åŠ¨æ€ RAM èŠ¯ç‰‡ï¼Œè¿™é‡Œä»¥ Intel 4116 èŠ¯ç‰‡ä¸ºä¾‹ï¼Œé¦–å…ˆæ˜¯ Intel 4116 çš„å¤–ç‰¹æ€§ï¼Œå¦‚ä¸‹å›¾ï¼š è¿™ä¸ªç»“æž„æœ‰ä¸¤ä¸ªè¦ç‚¹ï¼š æ•´ä¸ªèŠ¯ç‰‡åªæœ‰ 7 ä½åœ°å€çº¿ï¼Œè¾“å…¥çš„è¡Œåˆ—åœ°å€ä¼šå…ˆå­˜æ”¾åœ¨è¡Œåˆ—åœ°å€ç¼“å­˜å™¨ä¸­ï¼Œç„¶åŽåœ¨è¿›è¡ŒåŽç»­çš„è¯‘ç è¿‡ç¨‹ã€‚ è¿™ä¸ªèŠ¯ç‰‡å†…éƒ¨è¿˜æœ‰ä¸€ä¸ªå°æŽ§åˆ¶å™¨ï¼šæ—¶åºä¸ŽæŽ§åˆ¶æŽ§åˆ¶å™¨ï¼Œè¿™ä¸ªæŽ§åˆ¶å™¨åˆ©ç”¨è¡Œé€‰ä¸­ä¿¡å·ï¼ˆ$\overline {RAS}$ï¼‰ã€åˆ—é€‰ä¸­ä¿¡å·ï¼ˆ$\overline {CAS}$ï¼‰å’Œè¯»å†™æŽ§åˆ¶ä¿¡å·ï¼ˆ$\overline {WE}$ï¼‰ä½œä¸ºè¾“å…¥ï¼Œäº§ç”Ÿè¡Œæ—¶é’Ÿã€åˆ—æ—¶é’Ÿå’Œå†™æ—¶é’Ÿï¼Œæ¥æŽ§åˆ¶èŠ¯ç‰‡å†…éƒ¨çš„è¯»å†™æ“ä½œã€‚ Intel 4116 çš„è¯»/å†™æ“ä½œä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œè¿™é‡Œä»¥è¯»æ“ä½œä¸ºä¾‹ï¼Œå¦‚ä¸‹å›¾ï¼š åŒæ ·ï¼ŒIntel 4116 ä¹Ÿéœ€è¦æ”¾å¤§å™¨æ¥å½¢æˆå†ç”Ÿä¿¡æ¯ï¼ŒåŒæ—¶è¿™ä¸ªæ”¾å¤§å™¨ä¸¤ç«¯äº§ç”Ÿçš„ä¿¡å·æ˜¯ç›¸åçš„ã€‚è€Œå¯»æ‰¾å­˜å‚¨å•å…ƒçš„æ€è·¯ä¾ç„¶æ˜¯é‡åˆæ³•é‚£ä¸€å¥—ï¼Œè¡Œåˆ—ä¿¡å·å½“ä½œåæ ‡å³å¯ã€‚ DRAM æœ€åŽä¸€ä¸ªé—®é¢˜æ˜¯å…³äºŽåˆ·æ–°çš„é—®é¢˜ï¼Œä¹Ÿå°±æ˜¯ä¸Šé¢æåˆ°çš„å› ç”µå®¹æ¼ç”µè€Œéœ€è¦æ”¾å¤§å™¨å½¢æˆå†ç”Ÿä¿¡æ¯ã€‚åˆ·æ–°çš„æ•´ä¸ªè¿‡ç¨‹æ˜¯é’ˆå¯¹ä¸€è¡Œè€Œè¨€ï¼Œå¯¹åº”çš„åˆ·æ–°æ–¹æ³•æœ‰ä¸‰ç§ï¼šé›†ä¸­åˆ·æ–°ã€åˆ†æ•£åˆ·æ–°å’Œå¼‚æ­¥åˆ·æ–°ï¼ˆäºŒè€…ç»“åˆï¼‰ã€‚ é›†ä¸­åˆ·æ–°é›†ä¸­åˆ·æ–°å…¶å®žå°±æ˜¯é›†ä¸­ä¸€ä¸ªæ—¶é—´æ®µè¿›è¡Œåˆ·æ–°ï¼Œä»¥ $128 \times 128$ çŸ©é˜µä¸ºä¾‹ï¼Œéœ€è¦ 128 ä¸ªå‘¨æœŸè¿›è¡Œåˆ·æ–°ï¼Œå‡è®¾èŠ¯ç‰‡çš„å­˜å–å‘¨æœŸæ˜¯ $0.5\mu s$ï¼Œåˆ·æ–°æ—¶é—´é—´éš”æ˜¯ $2 ms$ï¼Œæ‰€ä»¥åˆ·æ–°æ—¶é—´å°±æ˜¯ $0.5 \mu s \times 128 = 64 \mu s$ï¼Œåœ¨è¿™ä¸ªæ—¶é—´æ®µä¸­ï¼ŒCPU ä¸Ž I/O éƒ½æ— æ³•ä¸Ž DRAM äº¤äº’ï¼Œæ•…è¿™ä¸ªæ—¶é—´æ®µä¹Ÿå«â€œæ­»åŒºâ€ï¼Œå¯¹åº”çš„â€œæ­»æ—¶é—´çŽ‡â€ä¸º $128 / 4000 \times 100\% = 3.2\%$ ã€‚ åˆ†æ•£åˆ·æ–°åˆ†æ•£åˆ·æ–°æ˜¯åœ¨æ¯ä¸€ä¸ªå­˜å–å‘¨æœŸè¿›è¡Œåˆ·æ–°ï¼Œä¹Ÿå°±æ˜¯è¯»å†™æ“ä½œå®ŒæˆåŽç›´æŽ¥è¿›è¡Œåˆ·æ–°ã€‚ä»¥ä¸Šé¢æåˆ°çš„ä¾‹å­ä¸ºä¾‹ï¼Œåœ¨åˆ†æ•£åˆ·æ–°çš„æ¡ä»¶ä¸‹ï¼Œæ•´ä¸ªå­˜å–å‘¨æœŸå°±ä»Ž $0.5 \mu s$ å˜æˆäº† $1 \mu s$ï¼Œè¿™ç§æ–¹æ³•è™½ç„¶æ¶ˆé™¤äº†â€œæ­»åŒºâ€ï¼Œä½† DRAM æ ¹æœ¬ä¸éœ€è¦è¿™ä¹ˆé¢‘ç¹çš„åˆ·æ–°ã€‚ å¼‚æ­¥åˆ·æ–°æ‰€è°“å¼‚æ­¥åˆ·æ–°ï¼Œå…¶å®žå°±æ˜¯é›†ä¸­åˆ·æ–°å’Œåˆ†æ•£åˆ·æ–°ç»“åˆã€‚è¿˜æ˜¯ä¸Šé¢çš„ä¾‹å­ï¼Œè‹¥æ¯ $15.6 \mu s$ åˆ·æ–°ä¸€è¡Œï¼Œåªéœ€è¦æŠŠè¿™ä¸€æ¬¡åˆ·æ–°æ“ä½œå®‰æŽ’åœ¨æœ€åŽé›†ä¸­åˆ·æ–°å³å¯ï¼Œè¿™æ ·å¯¹æ•´ä¸ªåˆ·æ–°æ—¶é—´é—´éš”å°±æ˜¯åˆ†æ•£åˆ·æ–°äº†ã€‚åŒæ ·ï¼Œç”±é›†ä¸­åˆ·æ–°å¸¦æ¥çš„â€œæ­»åŒºâ€æ˜¯ $0.5 \mu s$ï¼Œä½†å¦‚æžœå°†åˆ·æ–°å®‰æŽ’åœ¨æŒ‡ä»¤è¯‘ç é˜¶æ®µï¼Œå°±ä¸ä¼šäº§ç”Ÿâ€œæ­»åŒºâ€äº†ã€‚ SRAM å’Œ DRAM çš„æ¯”è¾ƒSRAM ä¸€èˆ¬ç”¨æ¥åš CPU çš„ç¼“å­˜ï¼ˆCacheï¼‰ï¼ŒDRAM ä¸€èˆ¬ç”¨æ¥åšä¸»å­˜ï¼ˆRAMï¼‰ï¼ŒäºŒè€…å·®åˆ«è§ä¸‹è¡¨ï¼š ç±»åˆ« DRAM SRAM å­˜å‚¨åŽŸç† ç”µå®¹ è§¦å‘å™¨ é›†æˆåº¦ é«˜ ä½Ž èŠ¯ç‰‡å¼•è„š å°‘ å¤š åŠŸè€— å° å¤§ ä»·æ ¼ ä½Ž é«˜ é€Ÿåº¦ æ…¢ å¿« åˆ·æ–° æœ‰ æ—  æ€»ç»“è¿™å‘¨çš„å†…å®¹ä¾ç„¶æ˜¯åç†è®ºæ€§è´¨çš„ï¼Œå®žåœ¨æ˜¯è°ˆä¸ä¸Šæœ‰è¶£ï¼Œåªèƒ½è€ç€æ€§å­å¬ä¸‹åŽ»ðŸ˜‚ã€‚æ€»ä½“å¬ä¸‹æ¥ï¼Œå‡ºçŽ°äº†å¾ˆå¤šå’Œç”µè·¯ç›¸å…³çš„æœ¯è¯­ï¼Œä¸å¾—ä¸è¯´ï¼Œä¸Žã€Šç»„æˆåŽŸç†ã€‹ç»“åˆç´§å¯†çš„è¯¾ç¨‹è¿˜å¾—æ˜¯ã€Šæ•°å­—ç”µè·¯ã€‹ã€‚ä¸è¿‡ï¼Œå•ä»ŽåŽŸç†çš„è§’åº¦æ¥è®²ï¼Œå€’ä¹Ÿå¯ä»¥ç”¨æ­»è®°ç¡¬èƒŒæ¥è§£å†³ã€‚å¥½äº†ï¼Œè¿™å‘¨çš„å†…å®¹çš„æ€ç»´å¯¼å›¾å¦‚ä¸‹ï¼š å‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯æŠŠé¢˜ç›®è§£å†³äº†...ðŸ˜´]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_2]]></title>
    <url>%2F2023%2F09%2F08%2FHIT-CO-Week-2%2F</url>
    <content type="text"><![CDATA[çœ‹äº†çœ¼ç¬¬äºŒå‘¨çš„æ ‡é¢˜ï¼Œå¥½åƒè¿˜æ˜¯æ¦‚å¿µæ€§çš„å†…å®¹å•Š...ðŸ˜ è®¡ç®—æœºçš„å‘å±•åŠåº”ç”¨è€å¸ˆçš„ç¬¬ä¸€å¥è¯ï¼šè¿™éƒ¨åˆ†å†…å®¹ä¸æ˜¯ä¸»è¦å­¦ä¹ å†…å®¹ï¼Œåªè¿›è¡Œç®€å•è®²è¿°ðŸ¤£ã€‚æ‡‚äº†ï¼Œå°±æ˜¯ä¸é‡è¦çš„å†…å®¹ï¼Œç›´æŽ¥äºŒå€é€Ÿäº†ã€‚ å¬çš„äººæ‰“çžŒç¡ï¼Œç•¥æ— èŠ...å¿«é€Ÿè¿‡äº†ã€‚ ç³»ç»Ÿæ€»çº¿æ€»çº¿ï¼ˆBusï¼‰è¿™ä¸ªæ¦‚å¿µç®—æ˜¯ç»„æˆåŽŸç†ä¸­æ¯”è¾ƒé‡è¦çš„åŸºç¡€æ¦‚å¿µäº†å§ï¼ŸðŸ¤” åŸºæœ¬æ¦‚å¿µ ä¸ºä»€ä¹ˆè¦ç”¨æ€»çº¿ï¼Ÿå…¶å®žå°±æ˜¯ä¸ºäº†å‡å°‘ç¡¬ä»¶è®¾å¤‡ä¸Ž CPU ä¹‹é—´çš„ç‰©ç†è¿žæŽ¥æ•°ã€‚ æ€»çº¿ï¼ˆBusï¼‰æ˜¯è¿žæŽ¥å„ä¸ªéƒ¨ä»¶çš„ä¿¡æ¯ä¼ è¾“çº¿ï¼Œæ˜¯å„ä¸ªéƒ¨ä»¶å…±äº«çš„ä¼ è¾“ä»‹è´¨ã€‚æŒ‰ç…§æ•°æ®ä¼ é€æ–¹å¼çš„ä¸åŒï¼Œæ€»çº¿å¯åˆ†ä¸ºä¸²è¡Œä¼ è¾“æ€»çº¿å’Œå¹¶è¡Œä¼ è¾“æ€»çº¿ã€‚ æ€»çº¿åˆ†ç±»æŒ‰ç…§æ€»çº¿çš„åŠŸèƒ½åˆ’åˆ†ï¼Œæ€»çº¿å¯ä»¥åˆ’åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»ï¼šç‰‡å†…æ€»çº¿ç³»ç»Ÿæ€»çº¿é€šä¿¡æ€»çº¿ç‰‡å†…æ€»çº¿æ˜¯èŠ¯ç‰‡å†…éƒ¨çš„æ€»çº¿ï¼Œå®ƒæ˜¯ CPU èŠ¯ç‰‡å†…éƒ¨å¯„å­˜å™¨ä¸Žå¯„å­˜å™¨ä¹‹é—´ã€å¯„å­˜å™¨å’Œ ALU ä¹‹é—´çš„å…¬å…±è¿žæŽ¥çº¿ã€‚ç³»ç»Ÿæ€»çº¿æ˜¯è®¡ç®—æœºç³»ç»Ÿå†…å„åŠŸèƒ½éƒ¨ä»¶ï¼ˆCPUã€ä¸»å­˜ã€I/O æŽ¥å£ï¼‰ä¹‹é—´ç›¸äº’è¿žæŽ¥çš„æ€»çº¿ã€‚æŒ‰ç…§ä¼ è¾“ä¿¡æ¯å†…å®¹çš„ä¸åŒï¼Œç³»ç»Ÿæ€»çº¿åˆå¯ä»¥åˆ†ä¸ºï¼š æ•°æ®æ€»çº¿ï¼Œä¸Žæœºå™¨å­—é•¿ã€å­˜å‚¨å­—é•¿æœ‰å…³ï¼Œæ˜¯åŒå‘ä¼ è¾“æ€»çº¿ åœ°å€æ€»çº¿ï¼Œä¸Žå­˜å‚¨åœ°å€ã€I/O åœ°å€æœ‰å…³ï¼Œæ˜¯å•å‘ä¼ è¾“æ€»çº¿ æŽ§åˆ¶æ€»çº¿ï¼Œä¼ è¾“çš„æ˜¯æŽ§åˆ¶ä¿¡æ¯ï¼Œä¼ è¾“æ–¹å‘æœ‰å‡ºæœ‰å…¥ é€šä¿¡æ€»çº¿ç”¨äºŽè®¡ç®—æœºç³»ç»Ÿä¹‹é—´æˆ–è®¡ç®—æœºç³»ç»Ÿä¸Žå…¶å®ƒç³»ç»Ÿï¼ˆå¦‚æŽ§åˆ¶ä»ªè¡¨ã€ç§»åŠ¨é€šä¿¡ç­‰ï¼‰ä¹‹é—´çš„é€šä¿¡ï¼ŒæŒ‰ç…§ä¼ è¾“æ–¹å¼å¯åˆ†ä¸ºï¼šä¸²è¡Œé€šä¿¡æ€»çº¿å’Œå¹¶è¡Œé€šä¿¡æ€»çº¿ã€‚ æ€»çº¿ç‰¹æ€§åŠæ€§èƒ½æŒ‡æ ‡ç‰¹æ€§æ€§èƒ½æŒ‡æ ‡ æœºæ¢°ç‰¹æ€§ï¼šå°ºå¯¸ã€å½¢çŠ¶ã€ç®¡è„šæ•°åŠæŽ’åˆ—é¡ºåº ç”µæ°”ç‰¹æ€§ï¼šä¼ è¾“æ–¹å‘å’Œæœ‰æ•ˆçš„ç”µå¹³èŒƒå›´ åŠŸèƒ½ç‰¹æ€§ï¼šæ¯æ ¹ä¼ è¾“çº¿çš„åŠŸèƒ½ï¼ˆåœ°å€ã€æ•°æ®ã€æŽ§åˆ¶ï¼‰ æ—¶é—´ç‰¹æ€§ï¼šä¿¡å·çš„æ—¶åºå…³ç³» æ€»çº¿å®½åº¦ï¼šæ•°æ®çº¿çš„æ ¹æ•° æ ‡å‡†ä¼ è¾“çŽ‡ï¼šæ¯ç§’ä¼ è¾“çš„æœ€å¤§å­—èŠ‚æ•°ï¼ˆMBpsï¼‰ æ—¶é’ŸåŒæ­¥/å¼‚æ­¥ æ€»çº¿å¤ç”¨ï¼ˆåœ°å€çº¿ä¸Žæ•°æ®çº¿å¤ç”¨ï¼‰ ä¿¡å·çº¿æ•°ï¼šåœ°å€çº¿ã€æ•°æ®çº¿å’ŒæŽ§åˆ¶çº¿çš„æ€»å’Œ æ€»çº¿æŽ§åˆ¶æ–¹å¼ï¼šçªå‘ã€è‡ªåŠ¨ã€ä»²è£ã€é€»è¾‘ã€è®¡æ•° å…¶ä»–æŒ‡æ ‡ï¼šè´Ÿè½½èƒ½åŠ›ç­‰ æ€»çº¿ç»“æž„å•æ€»çº¿ç»“æž„åŒæ€»çº¿ç»“æž„ä¸‰æ€»çº¿ç»“æž„å››æ€»çº¿ç»“æž„åªæœ‰ä¸€æ¡ç³»ç»Ÿæ€»çº¿ï¼Œå¯ç»†åˆ†ä¸ºæ•°æ®æ€»çº¿ã€åœ°å€æ€»çº¿å’ŒæŽ§åˆ¶æ€»çº¿ã€‚åŒ…æ‹¬ä¸»å­˜æ€»çº¿ã€I/O æ€»çº¿ï¼Œç”±é€šé“ï¼ˆå…·æœ‰ç‰¹æ®ŠåŠŸèƒ½çš„å¤„ç†å™¨ï¼‰å¯¹ I/O ç»Ÿä¸€ç®¡ç†ã€‚ä¸¤ç§ä¸åŒçš„ä¸‰æ€»çº¿ç»“æž„ï¼š ä¸»å­˜æ€»çº¿ã€I/O æ€»çº¿ã€DMA æ€»çº¿ å±€éƒ¨æ€»çº¿ã€ç³»ç»Ÿæ€»çº¿ã€æ‰©å±•æ€»çº¿ åŒ…æ‹¬å±€éƒ¨æ€»çº¿ã€ç³»ç»Ÿæ€»çº¿ã€é«˜é€Ÿæ€»çº¿ã€æ‰©å±•æ€»çº¿ã€‚ æ€»çº¿æŽ§åˆ¶ä¸¤ä¸ªåŸºæœ¬æ¦‚å¿µï¼šä¸»è®¾å¤‡ï¼ˆæ¨¡å—ï¼‰ï¼šèŽ·å¾—æ€»çº¿æŽ§åˆ¶æƒçš„è®¾å¤‡ä»Žè®¾å¤‡ï¼ˆæ¨¡å—ï¼‰ï¼šè¢«ä¸»è®¾å¤‡è®¿é—®çš„è®¾å¤‡ï¼Œåªèƒ½å“åº”ä»Žä¸»è®¾å¤‡å‘æ¥çš„å„ç§æ€»çº¿å‘½ä»¤ã€‚ æ€»çº¿åˆ¤ä¼˜æ€»çº¿åˆ¤ä¼˜æŽ§åˆ¶çš„æ–¹å¼åˆ†ä¸ºï¼šé›†ä¸­å¼åˆ†å¸ƒå¼å¯ç»†åˆ†ä¸ºä¸‰ç§ï¼šé“¾å¼æŸ¥è¯¢ã€è®¡æ•°å™¨å®šæ—¶æŸ¥è¯¢å’Œç‹¬ç«‹è¯·æ±‚æ–¹å¼åˆ†å¸ƒå¼ä»²è£ä¸éœ€è¦ä¸­å¤®ä»²è£å™¨ï¼Œæ¯ä¸ªæ½œåœ¨çš„ä¸»æ¨¡å—éƒ½æœ‰è‡ªå·±çš„ä»²è£å·å’Œä»²è£å™¨ã€‚ æ€»çº¿é€šä¿¡æŽ§åˆ¶ç›®çš„ï¼šè§£å†³é€šä¿¡åŒæ–¹åè°ƒé…åˆé—®é¢˜ã€‚æ€»çº¿ä¼ è¾“å‘¨æœŸåˆ†ä¸ºå››ä¸ªè¿‡ç¨‹ï¼š ç”³è¯·åˆ†é…é˜¶æ®µï¼šä¸»æ¨¡å—ç”³è¯·ï¼Œæ€»çº¿ä»²è£å†³å®š å¯»å€é˜¶æ®µï¼šä¸»æ¨¡å—å‘ä»Žæ¨¡å—ç»™å‡ºåœ°å€å’Œå‘½ä»¤ ä¼ æ•°é˜¶æ®µï¼šä¸»æ¨¡å—å’Œä»Žæ¨¡å—äº¤æ¢æ•°æ® ç»“æŸé˜¶æ®µï¼šä¸»æ¨¡å—æ’¤é”€æœ‰å…³ä¿¡æ¯ é€šä¿¡æ–¹å¼å¯åˆ†ä¸ºå››ç§ï¼š åŒæ­¥é€šä¿¡ï¼šç”±ç»Ÿä¸€æ—¶æ ‡æŽ§åˆ¶æ•°æ®ä¼ é€ å¼‚æ­¥é€šä¿¡ï¼šé‡‡ç”¨åº”ç­”æ–¹å¼ï¼Œæ²¡æœ‰å…¬å…±æ—¶é’Ÿæ ‡å‡† åŠåŒæ­¥é€šä¿¡ï¼šåŒæ­¥ã€å¼‚æ­¥ç»“åˆ åˆ†ç¦»å¼é€šä¿¡ï¼šå……åˆ†æŒ–æŽ˜ç³»ç»Ÿæ€»çº¿æ¯ä¸ªçž¬é—´çš„æ½œåŠ› å‰ä¸‰ç§é€šä¿¡æ–¹å¼çš„å…±åŒç‚¹ï¼šï¼ˆåœ¨ä¸€ä¸ªæ€»çº¿ä¼ è¾“å‘¨æœŸå†…ï¼Œä»¥è¾“å…¥æ•°æ®ä¸ºä¾‹ï¼‰ ä¸»æ¨¡å—å‘åœ°å€ã€å‘½ä»¤ï¼ˆå ç”¨æ€»çº¿ï¼‰ ä»Žæ¨¡å—å‡†å¤‡æ•°æ®ï¼ˆä¸å ç”¨æ€»çº¿ï¼Œæ€»çº¿ç©ºé—²ï¼‰ ä»Žæ¨¡å—å‘ä¸»æ¨¡å—å‘æ•°æ®ï¼ˆå ç”¨æ€»çº¿ï¼‰ ç›¸æ¯”ä¹‹ä¸‹ï¼Œåˆ†ç¦»å¼é€šä¿¡çš„è¿‡ç¨‹æ˜¯ï¼š å­å‘¨æœŸ 1ï¼Œä¸»æ¨¡å—ç”³è¯·å ç”¨æ€»çº¿ï¼Œä½¿ç”¨å®ŒåŽï¼Œå³æ”¾å¼ƒæ€»çº¿çš„ä½¿ç”¨æƒ å­å‘¨æœŸ 2ï¼Œä»Žæ¨¡å—ç”³è¯·å ç”¨æ€»çº¿ï¼Œå°†å„ç§ä¿¡æ¯é€è‡³æ€»çº¿ä¸Š å…¶å¯¹åº”çš„ç‰¹ç‚¹ï¼ˆå……åˆ†æé«˜äº†æ€»çº¿çš„æœ‰æ•ˆå ç”¨ï¼‰ï¼š å„æ¨¡å—æœ‰æƒç”³è¯·å ç”¨æ€»çº¿ é‡‡ç”¨åŒæ­¥æ–¹å¼é€šä¿¡ï¼Œä¸ç­‰å¯¹æ–¹å›žç­” å„æ¨¡å—å‡†å¤‡æ•°æ®æ—¶ï¼Œä¸å ç”¨æ€»çº¿ æ€»çº¿è¢«å ç”¨æ—¶ï¼Œæ— ç©ºé—² æ€»ç»“è¿™æ˜¯è¿™å‘¨çš„æ€ç»´å¯¼å›¾ï¼š è¿™å‘¨æ˜¯å…ˆåšçš„æ€ç»´å¯¼å›¾ï¼ŒåŽå†™çš„ blogï¼Œå¯¼è‡´å†™ blog çš„æ—¶å€™ç›´æŽ¥æŠ„çš„æ€ç»´å¯¼å›¾çš„å†…å®¹ï¼Œå†™å®Œä¹‹åŽï¼Œè‡ªå·±éƒ½è§‰å¾—å¾ˆæ°´ðŸ˜‚ï¼Œä½†åˆä¸æƒ³å†é‡æ–°å†™äº†ï¼Œå“Žï¼Œè¿˜æ˜¯æ‡’å•Šã€‚ ä¸è¿‡è¯è¯´å›žæ¥ï¼Œè¿™å‘¨çš„å†…å®¹ä¾ç„¶æ˜¯æ¦‚å¿µæ€§çš„çŸ¥è¯†ï¼Œç•¥æ— èŠã€‚å•å‡­è€å¸ˆè§†é¢‘å°†çš„å†…å®¹ï¼Œä½œä¸šé¢˜å¤§æ¦‚çŽ‡ä¸èƒ½æ‹¿æ»¡åˆ†ï¼Œä¸€æ˜¯æœ‰äº›æ¦‚å¿µé¢˜è€å¸ˆæ ¹æœ¬æ²¡æè¿‡ï¼ŒäºŒæ˜¯è¿˜å‡ºçŽ°äº†ä¸€äº›è®¡ç®—é¢˜ï¼Œæ‰€ä»¥è¿˜æ˜¯éœ€è¦æ‰¾ç‚¹ç»ƒä¹ é¢˜åšåšï¼Œä¹Ÿè®¸çœ‹çœ‹å”è€å¸ˆç¼–çš„é‚£æœ¬æ•™æçš„è¯¾åŽé¢˜å¯ä»¥è§£å†³ï¼ŸðŸ¤”ä½†æˆ‘æ‰‹è¾¹ä¸Šæ²¡æœ‰ï¼Œåªèƒ½æ‰¾æ‰¾èµ„æºäº†ã€‚ å¥½äº†ï¼ŒæŽ¥ä¸‹æ¥ä¸‰å‘¨éƒ½æ˜¯ä¸Žå­˜å‚¨å™¨æ‰“äº¤é“äº†ï¼Œå¸Œæœ›ä¼šæœ‰è¶£ä¸€ç‚¹ã€‚ðŸ˜¶]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_CO_Week_1]]></title>
    <url>%2F2023%2F09%2F05%2FHIT-CO-Week-1%2F</url>
    <content type="text"><![CDATA[ä»Žä»Šå¤©å¼€å§‹æ›´æ–°ç¬”è€…åœ¨ MOOC ä¸Šè‡ªå­¦å“ˆå·¥å¤§è®¡ç®—æœºç»„æˆåŽŸç†æ—¶çš„ç¬”è®°ï¼ŒæŒ‰ç…§æ¯ä¸€å‘¨çš„è¯¾ç¨‹è¿›è¡Œè®°å½•ï¼Œæ¯å‘¨å¯¹åº”ä¸€ç¯‡ Blogï¼Œç®—ä¸Šä¸Šä¸‹ä¸¤é—¨è¯¾ç¨‹ï¼Œè¿™ä¸ªç³»åˆ—å¤§æ¦‚æœ‰ä¸ªåæ¥ç¯‡å§ã€‚ðŸ§ è¯¾ç¨‹æ¦‚è²Œè¿™é—¨è¯¾ä¸»è¦è®²è§£ä¸‰ä¸ªæ–¹é¢çš„å†…å®¹ï¼šè®¡ç®—æœºã€ç»„æˆå’ŒåŽŸç†ï¼Œä¸»è¦ä»Žä¸‰ä¸ªè§’åº¦å…¥æ‰‹ï¼š åŸºæœ¬éƒ¨ä»¶çš„ç»“æž„å’Œç»„ç»‡æ–¹æ³• åŸºæœ¬è¿ç®—çš„æ“ä½œåŽŸç† åŸºæœ¬éƒ¨ä»¶å’Œå•å…ƒçš„è®¾è®¡æ€æƒ³ è¿™é—¨è¯¾ç¨‹å¯¹åº”çš„äº¤ææ˜¯å”æœ”é£žè€å¸ˆç¼–çš„é‚£æœ¬ã€Šè®¡ç®—æœºç»„æˆåŽŸç†ã€‹ï¼ˆç¬¬äºŒç‰ˆï¼‰ï¼Œç”±é«˜ç­‰æ•™è‚²å‡ºç‰ˆç¤¾å‡ºç‰ˆã€‚å¦å¤–ï¼Œè€å¸ˆæŽ¨èäº†ä¸¤æœ¬å‚è€ƒæ•™æï¼š Computer Organization & Design: A Hardware/Software Interface, David A.Patterson. John L.Hennessy Digital Design and Computer Architecture. Morgan Kaufmann, 2007, David Harris, Sarah Harris è¿™é—¨è¯¾æ€»å…±æœ‰åç« å†…å®¹ï¼Œä¸ŠåŠéƒ¨åˆ†è¯¾ç¨‹ä¼šè®²è§£å‰äº”ç« ï¼Œä¸»è¦å†…å®¹ä¸ºè®¡ç®—æœºç»„æˆåŽŸç†ä¸­ä¸Žæœºå™¨ç›¸å…³çš„éƒ¨åˆ†ï¼›ä¸‹åŠéƒ¨åˆ†è¯¾ç¨‹ä¼šè®²è§£åŽäº”ç« ï¼Œä¸»è¦å†…å®¹ä¸ºè®¡ç®—æœºç»„æˆåŽŸç†ä¸­æ•°æ®çš„å­˜å‚¨ã€è¡¨ç¤ºå’Œè¿ç®—ä»¥åŠ CPU çš„è®¾è®¡æ€æƒ³ã€‚ ç¬¬ä¸€å‘¨çš„è¯¾ç¨‹æœ‰ç‚¹ boringðŸ¥±ï¼Œä¸»è¦è®²è§£è®¡ç®—æœºç³»ç»Ÿæ¦‚è®ºï¼Œç®—æ˜¯åŸºæœ¬æ¦‚å¿µçŸ¥è¯†ã€‚ è®¡ç®—æœºç³»ç»Ÿæ¦‚è®ºè®¡ç®—æœºçš„è½¯ç¡¬ä»¶æ¦‚å¿µè¿™ä¸ªåœ°æ–¹å…¶å®žæ²¡ä»€ä¹ˆå¥½è¯´çš„ï¼Œç®—æ˜¯å¸¸è¯†æ€§çš„å†…å®¹ã€‚ è®¡ç®—æœºç³»ç»Ÿçš„å±‚æ¬¡ç»“æž„è¿™é‡Œè¦æåˆ°äº†ä¸¤ä¸ªç³»ç»Ÿå¤æ‚æ€§ç®¡ç†æ–¹æ³•ï¼šæŠ½è±¡å’Œ3Yï¼ˆHierachyã€Modularity å’Œ Regularityï¼‰ã€‚å¦‚æžœç†Ÿæ‚‰ä¸€é—¨ OOP è¯­è¨€çš„è¯ï¼Œè¿™äº›æ¦‚å¿µä¹Ÿéƒ½æ˜¯åŸºæœ¬å¸¸è¯†äº†ã€‚ å¦å¤–ï¼Œä¸‹é¢è¿™å¼ å›¾å¯ä»¥æ³¨æ„ä¸€ä¸‹ï¼š è®¡ç®—æœºä½“ç³»ç»“æž„å’Œè®¡ç®—æœºç»„æˆæ³¨æ„åŒºåˆ†è¿™ä¸¤ä¸ªæ¦‚å¿µï¼š è®¡ç®—æœºä½“ç³»ç»“æž„ï¼šç¨‹åºå‘˜æ‰€è§åˆ°çš„è®¡ç®—æœºç³»ç»Ÿçš„å±žæ€§ï¼Œæ¦‚å¿µæ€§çš„ç»“æž„å’ŒåŠŸèƒ½ç‰¹æ€§ï¼ˆæŒ‡ä»¤ç³»ç»Ÿã€æ•°æ®ç±»åž‹ã€å¯»å€æŠ€æœ¯ã€I/O åŽŸç†ç­‰ï¼‰ è®¡ç®—æœºç»„æˆï¼šå®žçŽ°è®¡ç®—æœºä½“ç³»ç»“æž„æ‰€ä½“çŽ°çš„å±žæ€§ï¼ˆå…·ä½“æŒ‡ä»¤çš„å®žçŽ°ï¼‰ è®¡ç®—æœºçš„åŸºæœ¬ç»„æˆå†¯Â·è¯ºä¾æ›¼è®¡ç®—æœºçš„ç‰¹ç‚¹ è®¡ç®—æœºç”±äº”å¤§éƒ¨ä»¶ç»„æˆ æŒ‡ä»¤å’Œæ•°æ®ä»¥åŒç­‰åœ°ä½å­˜äºŽå­˜å‚¨å™¨ï¼Œå¯æŒ‰åœ°å€å¯»è®¿ æŒ‡ä»¤å’Œæ•°æ®ç”¨äºŒè¿›åˆ¶è¡¨ç¤º æŒ‡ä»¤ç”±æ“ä½œç å’Œåœ°å€ç ç»„æˆ å­˜å‚¨ç¨‹åº ä»¥è¿ç®—å™¨ä¸ºä¸­å¿ƒ å†¯Â·è¯ºä¾æ›¼è®¡ç®—æœºå­˜åœ¨ä¸€ä¸ªç¼ºé™·ï¼Œé‚£å°±æ˜¯è¿ç®—å™¨æ‰¿æ‹…äº†å¾ˆå¤šå·¥ä½œï¼Œå¤§éƒ¨åˆ†äº‹æƒ…éƒ½æ˜¯äº²åŠ›äº²ä¸ºï¼Œè¿™å°±å¯¼è‡´äº†è¿ç®—å™¨çš„é€Ÿåº¦ç›´æŽ¥æˆäº†æ•´å°ç”µè„‘çš„é€Ÿåº¦ï¼ˆå®žé™…ä¸Šå°±æ˜¯æœ¨æ¡¶æ•ˆåº”ï¼‰ã€‚ è®¡ç®—æœºç¡¬ä»¶æ¡†å›¾é’ˆå¯¹å†¯Â·è¯ºä¾æ›¼è®¡ç®—æœºçš„æ”¹è‰¯æŽªæ–½å°±æ˜¯å°†æ•´ä¸ªä½“ç³»çš„ä¸­å¿ƒä»Žè¿ç®—å™¨æ¢æˆäº†å­˜å‚¨å™¨ã€‚ çŽ°ä»£è®¡ç®—æœºä¹Ÿæ˜¯æŒ‰ç…§ä¸Šå›¾ä¸­çš„ç»“æž„æ­å»ºèµ·æ¥çš„ï¼Œæ­¤æ—¶å„éƒ¨åˆ†ç¡¬ä»¶è®¾å¤‡éƒ½æœ‰äº†è‡ªå·±çš„åå­—ï¼Œä»Žè¿™é‡Œä½“çŽ°çš„è®¾è®¡æ€æƒ³å°±æ˜¯å‰é¢æåˆ°çš„ 3Yâ€”â€”å±‚æ¬¡åŒ–ï¼ˆHierachyï¼‰ã€æ¨¡å—åŒ–ï¼ˆModularityï¼‰å’Œè§„åˆ™æ€§ï¼ˆRegularityï¼‰ã€‚ å­˜å‚¨å™¨çš„åŸºæœ¬ç»„æˆå­˜å‚¨å™¨ç”±ä¸»å­˜å‚¨å™¨ï¼ˆä¸»å­˜ï¼Œå†…å­˜æ¡ï¼‰å’Œè¾…å­˜å‚¨å™¨ï¼ˆè¾…å­˜ï¼Œç¡¬ç›˜ï¼‰ã€‚ä¸»å­˜å‚¨å™¨ç”±è®¸å¤šå­˜å‚¨å•å…ƒç»„æˆï¼Œæ¯ä¸ªå­˜å‚¨å•å…ƒåŒ…å«è‹¥å¹²ä¸ªå­˜å‚¨å…ƒä»¶ï¼ˆä¹Ÿå°±æ˜¯åœ¨ Nand2tetris è¿™é—¨è¯¾ä¸­æŽ¥è§¦åˆ°çš„ Bit èŠ¯ç‰‡ï¼Œå¯ä»¥ç”¨æ¥å­˜å‚¨ä¸€ä½äºŒè¿›åˆ¶ä¿¡æ¯ï¼‰ã€‚è¿™é‡Œè¿˜æœ‰ä¸€ä¸ªå­˜å‚¨å­—é•¿çš„æ¦‚å¿µï¼Œä¹Ÿå°±æ˜¯æŒ‡å­˜å‚¨å•å…ƒä¸­äºŒè¿›åˆ¶ä»£ç çš„ä½æ•°ã€‚ é™¤äº†å­˜å‚¨å•å…ƒå¤–ï¼Œä¸»å­˜å‚¨å™¨è¿˜åŒ…æ‹¬äº†åœ°å€å¯„å­˜å™¨ï¼ˆMARï¼‰ã€æ•°æ®å¯„å­˜å™¨ï¼ˆMDRï¼‰å’Œä¸€äº›é€»è¾‘ç”µè·¯ã€‚åœ°å€å¯„å­˜å™¨ï¼ˆMARï¼‰å­˜æ”¾è®¿å­˜åœ°å€ï¼Œç»è¿‡åœ°å€è¯‘ç åŽæ‰¾åˆ°æ‰€é€‰çš„å­˜å‚¨å•å…ƒï¼Œä»Žè€Œæ‹¿åˆ°æ•°æ®ï¼ˆç±»æ¯”ä¸€ä¸‹æŒ‡é’ˆçš„æ¦‚å¿µï¼‰ã€‚MAR ç”¨äºŽå¯»å€ï¼Œæ•…å…¶ä½æ•°å¯¹åº”ç€å­˜å‚¨å•å…ƒçš„ä¸ªæ•°æ•°æ®å¯„å­˜å™¨ï¼ˆMDRï¼‰æ˜¯ä¸»å­˜å’Œå…¶ä»–éƒ¨ä»¶çš„ä¸­ä»‹æœºæž„ï¼Œç”¨äºŽæš‚å­˜è¦ä»Žå­˜å‚¨å™¨ä¸­è¯»æˆ–å†™çš„ä¿¡æ¯ï¼ˆç±»æ¯”ä¸´æ—¶å˜é‡ï¼‰ã€‚MDR çš„ä½æ•°å’Œå­˜å‚¨å­—é•¿ç›¸ç­‰ã€‚ çŽ°ä»£ CPU ä¸­çš„ç¼“å­˜ï¼ˆCacheï¼‰åœ¨æ¦‚å¿µä¸Šä¹Ÿæ˜¯ä¸»å­˜ã€‚ è¿ç®—å™¨çš„åŸºæœ¬ç»„æˆè¿ç®—å™¨çš„åŸºæœ¬ç»„æˆåŒ…æ‹¬ï¼šç®—æœ¯é€»è¾‘å•å…ƒï¼ˆALUï¼‰ã€ç´¯åŠ å™¨ï¼ˆACCï¼‰ã€ä¹˜å•†å¯„å­˜å™¨ï¼ˆMQï¼‰å’Œæ“ä½œæ•°å¯„å­˜å™¨ï¼ˆXï¼‰ï¼Œå„å¯„å­˜å™¨è¿ç®—åŽå­˜å‚¨çš„å†…å®¹è§ä¸‹å›¾ï¼š æŽ§åˆ¶å™¨çš„åŸºæœ¬ç»„æˆæŽ§åˆ¶å™¨çš„åŸºæœ¬ç»„æˆåŒ…æ‹¬ï¼šæŽ§åˆ¶å•å…ƒï¼ˆCUï¼‰ã€ç¨‹åºè®¡æ•°å™¨ï¼ˆIRï¼‰å’ŒæŒ‡ä»¤å¯„å­˜å™¨ï¼ˆPCï¼‰ï¼Œå„éƒ¨åˆ†åŠŸèƒ½è§ä¸‹å›¾ï¼š è®¡ç®—æœºçš„æ€§èƒ½æŒ‡æ ‡è¿™ä¸€éƒ¨åˆ†åˆæ˜¯ä¸€å †æ¦‚å¿µæ€§çš„å†…å®¹ðŸ¤ï¼š æœºå™¨å­—é•¿ï¼šCPU ä¸€æ¬¡èƒ½å¤„ç†æ•°æ®çš„ä½æ•°ä¸Ž CPU ä¸­çš„å¯„å­˜å™¨ä½æ•°æœ‰å…³ CPU ä¸»é¢‘ã€æ ¸å¿ƒæ•°ã€CPIï¼ˆæ‰§è¡Œä¸€æ¡æŒ‡ä»¤æ‰€éœ€æ—¶é’Ÿå‘¨æœŸæ•°ï¼‰ã€MIPSï¼ˆæ¯ç§’æ‰§è¡Œç™¾ä¸‡æ¡æŒ‡ä»¤ï¼‰ã€FLOPSï¼ˆæ¯ç§’æµ®ç‚¹è¿ç®—æ¬¡æ•°ï¼‰ å­˜å‚¨å®¹é‡ï¼ŒåŒ…æ‹¬ä¸»å­˜å®¹é‡å’Œè¾…å­˜å®¹é‡ æ€»ç»“åšäº†å¼ æ€ç»´å¯¼å›¾ï¼š ä¹‹å‰ä¸€ç›´åœ¨å¬ Nand2tetris çš„è¯¾ï¼ŒçŽ°åœ¨ä¸€æ—¶æ¢å›žå›½å†…è€å¸ˆçš„è¯¾ï¼Œå¬çš„è¿˜æœ‰ç‚¹ä¸ä¹ æƒ¯ã€‚å“Žï¼Œå¬å®Œä¸€å‘¨ï¼Œè¿™ç§ä¸ºäº†åº”è¯•è€Œå¬è¯¾ã€å­¦ä¹ çš„æ„Ÿè§‰åˆå›žæ¥äº†ã€‚ç›¸æ¯”ä¹‹ä¸‹ï¼Œæ„Ÿè§‰å›½å¤–è¯¾ç¨‹å¾€å¾€æŠŠå¤æ‚çš„ç†è®ºè®²çš„å¾ˆç®€å•ï¼Œåœ¨ä½ ç†è§£çš„å·®ä¸å¤šäº†ä¹‹åŽï¼Œä¼šç»™ä½ ä¸€ä¸ªä»»åŠ¡ï¼Œè®©ä½ é€šè¿‡å®žè·µæ¥ç»§ç»­åŠ æ·±ç†è§£ã€‚ä½†å›½å†…è¯¾ç¨‹ä¸ºäº†åº”è¯•ï¼Œåœ¨ç†è®ºä¸Šçš„è®²è§£å¾€å¾€å°±æ¯”è¾ƒå¤æ‚...ðŸ˜“ä»”ç»†æƒ³äº†ä¸€ä¸‹ï¼Œå›½å†…çš„è¯¾ç¨‹çœŸçš„å¾ˆå®¹æ˜“æ‰“æ¶ˆå­¦ç”Ÿçš„å…´è¶£ï¼Œå½“ç„¶å¦‚æžœèƒ½åšæŒä¸‹æ¥ï¼Œç¡®å®žèƒ½èŽ·å¾—ä¸é”™çš„ç†è®ºèƒ½åŠ›ï¼Œä½†æ˜¯æ²¡æœ‰å®žè·µè¿˜æ˜¯ä¸è¡Œå•Šï¼Œå“Žï¼ŒåŽŸæœ¬ä¹‹å‰åœ¨è‡ªå­¦ Nand2tetris æ—¶ï¼Œå°±å·²ç»æ„Ÿæ…¨è¿‡å›½å¤–å­¦ç”Ÿçš„å®žè·µèƒ½åŠ›å¾ˆå¼ºï¼ŒçŽ°åœ¨è¿™ç§ä½“ä¼šåˆåŠ æ·±äº†ã€‚ ä¸æ‰¯è¿™äº›é—²ç¯‡äº†...å›žè¿‡å¤´æ¥è°ˆä¸€è°ˆè¿™é—¨è¯¾çš„æ„Ÿå—ï¼Œåœ¨å­¦ä¹ ã€Šç»„æˆåŽŸç†ã€‹ä¹‹å‰ä¸€å®šè¦æŠŠ C è¯­è¨€çš„æŒ‡é’ˆã€åœ°å€è¿™ä¸¤ä¸ªæ¦‚å¿µçŽ©æ˜Žç™½ä¸ªå¤§æ¦‚ï¼Œä¸ç„¶ï¼Œè¿™äº›ç¡¬ä»¶çš„è®¾è®¡æ€æƒ³ä¼šéžå¸¸éš¾ä»¥ç†è§£ã€‚åªè¦èƒ½ç†è§£ç¡¬ä»¶ä¸­åœ°å€çš„è®¾è®¡æ€æƒ³ç†è§£é€å½»ï¼Œåº”è¯¥å°±ä¸ä¼šæœ‰å¤ªå¤§çš„é—®é¢˜äº†ã€‚ å¦å¤–ï¼Œä»Žå›½å†…åº”è¯•ï¼ˆæœŸæœ«è€ƒã€408 ä¹‹ç±»ï¼‰çš„è§’åº¦æ¥è®²ï¼Œå“ˆå·¥å¤§å¼€çš„è¿™é—¨è¯¾è®²çš„è¿˜æ˜¯å¾ˆæ¸…æ™°çš„ï¼ŒæŽ¨èå­¦ä¹ ï¼Œå¦‚æžœä½ å¬çš„è¿‡ç¨‹ä¸­æ„Ÿè§‰å¾ˆåƒåŠ›ï¼Œé‚£è¯´æ˜Žå¯èƒ½å¯¹ä¸€äº›åŸºç¡€æ¦‚å¿µè¿˜ä¸ç†Ÿæ‚‰ï¼Œè¿˜æ˜¯å…ˆæŠŠåŸºç¡€æ‰“æ‰Žå®žã€‚ å¥½äº†ï¼Œè¿™å‘¨è¿˜æœ‰ä¸€ä»¶äº‹æƒ…ï¼Œé‚£å°±æ˜¯æŠŠä¹¦ä¸Šçš„é¢˜åšå®ŒðŸ˜‘ï¼Œå§æ§½ï¼Œçªç„¶æƒ³èµ·æ¥ï¼Œå¥½ä¹…æ²¡å†™è¿‡ä½œä¸šäº†...ðŸ¤£]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>HIT_CO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_08_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F08%2F27%2F2023-08-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å‘¨æœ«æ­£å¥½æ˜¯å…«æœˆåº•å‘€~ðŸ˜Ž Kiss Goodbye - çŽ‹åŠ›å®Your browser does not support the audio tag. è¿™å‡ å¤©ä¸€ç›´åœ¨å¬è¿™é¦–æ­Œ...æ„Ÿè§‰ä¸æ˜¯é‚£ç§å¾ˆéš¾å”±çš„æ­Œï¼Œä½†ä¹Ÿä¸æ˜¯é‚£ä¹ˆå®¹æ˜“å°±å¯ä»¥å”±å¥½ã€‚å¦å¤–ï¼Œè¿™é¦–æ­Œçš„é’¢ç´é—´å¥çœŸçš„å¾ˆå¥½å¬ï¼Œå¥½åƒæŠŠåˆ†å¼€åŽä¸€ä¸ªäººå½¢å•å½±åªåˆæ¸´æœ›å†è§çš„æ„Ÿæƒ…å…¨è¡¨è¾¾å‡ºæ¥:-( å¥½å•¦ï¼Œè¿›å…¥æ­£é¢˜... æœ¬æ¥ä»¥ä¸ºè¿™ä¸ªæœˆæ–°ç‰ˆæœ¬ä¼šä¸Šçº¿çš„ï¼Œç»“æžœåˆå»¶æœŸäº†ï¼Œå¯¼è‡´æœˆåˆå¾ˆå¿™ï¼Œæœˆæœ«åˆä¸æ˜¯å¾ˆå¿™äº†ã€‚è€Œæ‰€å¿™çš„äº‹æƒ…å‘¢ï¼Œè¿˜æ˜¯è·Ÿä¸Šä¸ªæœˆä¸€æ ·ðŸ˜‚ï¼Œè¿˜æ˜¯æµ‹è¯•æ–°ç‰ˆæœ¬ï¼Œæ‰¾æ‰¾æœ‰æ²¡æœ‰éšè—çš„ BugðŸžã€‚ç»“æžœè¿˜çœŸçš„å°±æ‰¾å‡ºæ¥ä¸€ä¸ªï¼Œä¸è¿‡å¥½åœ¨ä¸æ˜¯é‡å¤§çš„ Bugï¼Œä¿®å¤å¥½å°±è¡Œäº†ã€‚é™¤äº†è¿™ä¸ªä¸»è¦çš„äº‹æƒ…å¤–ï¼Œå°±æ²¡æœ‰å…¶ä»–ç´§æ€¥çš„äº‹æƒ…äº†ã€‚å¦å¤–ï¼Œè‡ªå·±é€šè¿‡ Java å†™çš„æŠ¥æ–‡è§£æžå·¥å…·ä¹Ÿç®—æ˜¯åŸºæœ¬å¼€å‘å¥½äº†ã€‚å…¶å®žä¹Ÿä¸ç”¨åœ¨ä¿®ä¿®æ”¹æ”¹äº†ï¼Œå› ä¸ºä¹Ÿåªæœ‰è‡ªå·±ä¸€ä¸ªäººç”¨ï¼Œä¸è¿‡æœ¬ç€æŠŠä»£ç å†™ç²¾ç‚¼ã€ç®€æ´çš„åŽŸåˆ™ï¼Œè¿˜æ˜¯çœ‹çœ‹èƒ½ä¸èƒ½åœ¨æ”¹æ”¹ã€‚å®žé™…ä¸Šï¼Œé€šè¿‡è¿™ä¸ªå°é¡¹ç›®ï¼Œè‡ªå·±å¯¹å‰ç«¯ç»™åŽç«¯çš„æ•°æ®æœ‰äº†ä¸€ä¸ªæ›´æ·±å…¥çš„ç†è§£ã€‚åŒæ—¶ï¼Œå¯¹ Java çš„äº†è§£ä¹Ÿæ›´æ·±å…¥äº†ä¸€ç‚¹ï¼Œçœ‹çœ‹è¿˜æœ‰æ²¡æœ‰èƒ½è®©è‡ªå·±å­¦ä¹ çš„åœ°æ–¹ã€‚ å›žåˆ°å­¦ä¹ ä¸Šï¼Œè¿™ä¸ªæœˆçœ‹äº†å¤§æ¦‚ 30 - 40 ä¸ªè§†é¢‘ï¼Œæ‰€å­¦ä¹ çš„å†…å®¹æ›´å¤šçš„æ˜¯ Linux çš„ç³»ç»Ÿ I/O å‡½æ•°ã€‚è€å®žè®²ï¼Œè‡ªå·±å¯¹è¿™éƒ¨åˆ†çš„å‡½æ•°ä¸å¤ªç†Ÿæ‚‰ã€‚å°½ç®¡å·²ç»å¬è€å¸ˆè®²è¿‡ä¸€éäº†ï¼Œä½†ä¹Ÿåªæ˜¯è®²çš„æ—¶å€™å¬çš„å¾ˆæ¸…æ¥šï¼Œè¯¾åŽå°±å¿˜äº†ï¼Œæˆ–è€…è¯´ä¸ä¼šç”¨ï¼Œæ‰€ä»¥ä¸ªäººçš„çœ‹æ³•è¿˜æ˜¯è¦ä»Žå®žé™…é¡¹ç›®ä¸­å‡ºå‘ã€‚ç­‰åˆ°å­¦çš„å·®ä¸å¤šäº†ï¼Œå°±é‡æ–°çœ‹çœ‹ tinyhttpd è¿™ä¸ªå°é¡¹ç›®ï¼Œé‡ç‚¹æ˜¯æžæ¸…æ¥šé‡Œé¢ä¸€äº›å‡½æ•°çš„ä½¿ç”¨ã€‚ è¿™ä¸ªæœˆå†™äº†ä¸‰ç¯‡ Blogï¼Œä¸€æ˜¯æ€»ç»“äº†ä¸€ä¸‹è¯¾ç¨‹çš„å­¦ä¹ å†…å®¹ï¼ŒäºŒæ˜¯æžæ¸…æ¥šäº†ä¸€äº›ç»†èŠ‚æ€§çš„é—®é¢˜ã€‚ä½†ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œè¿˜æ˜¯éœ€è¦å†æŽ¥å†åŽ‰å‘€ðŸ˜ï¼ä¸è¿‡ä¸è¦æœ‰å¤ªå¤§çš„åŽ‹åŠ›ï¼Œä¸€æ­¥ä¸€ä¸ªè„šå°åšä¸‹åŽ»å°±å¥½ã€‚ç®—ä¸‹æ¥ï¼Œä¸ƒæœˆä»½çš„å°ç›®æ ‡ç®—æ˜¯å®Œæˆäº†ã€‚ ç”Ÿæ´»ä¸Šå°±æ˜¯æŒ‰éƒ¨å°±ç­äº†ï¼ŒèŠ±åœ¨åƒå–çŽ©ä¹ä¸Šçš„èŠ±é”€ä¸Žä¸Šä¸ªæœˆå·®ä¸å¤šã€‚ä¸è¿‡ï¼Œä¸Šå‘¨è‡ªå·±å¼€å§‹å°è¯•ä¹°é¸¡èƒ¸è‚‰å’Œåšæžœæ¥æ”¹å–„è‡ªå·±çš„è¥å…»æ‘„å…¥ï¼Œä¸çŸ¥é“èƒ½ä¸èƒ½å¤šé•¿ç‚¹è‚Œè‚‰å•Šï¼Œå¯åƒä¸‡ä¸è¦é•¿è‚¥è‚‰ðŸ¤£ï¼Œå“ˆå“ˆï¼Œå…ˆåƒä¸€æ®µæ—¶é—´å†è¯´å§ï¼Œæ˜Žå¤©åŽ»ç§°ä¸€ç§°çœ‹çœ‹è‡ªå·±çŽ°åœ¨ä½“é‡å¤šå°‘ï¼Œä¸Šæ¬¡æ˜¯ 62.8 å…¬æ–¤æ¥ç€ï¼ŒåŠ æ²¹é”»ç‚¼ï¼ŒåŠ æ²¹åƒï¼Œå“ˆå“ˆðŸ’ªã€‚å¦å¤–ï¼Œä¸Žä¸Šä¸ªæœˆçš„é—®é¢˜ä¸€æ ·ï¼Œè‡ªå·±çš„ç¡çœ è´¨é‡çœŸçš„ä¸é«˜ï¼Œæ€»ä¹‹å°±æ˜¯ä¸€å¥è¯ï¼Œæˆ’æŽ‰æ‰‹æœºå§ï¼Œéªšå¹´ã€‚ä¸Šä¸ªæœˆè¯´è‡ªå·±æ˜¯åœ¨è¯´å±è¯ï¼Œç»“æžœè¿˜è°å¯¹ä¹ðŸ˜…...è¿˜æ˜¯è¦è®¤çœŸçš„å¯¹å¾…ç”Ÿæ´»å‘€ï¼Œçªç„¶åˆæƒ³åˆ°äº†ã€Šå£«å…µçªå‡»ã€‹é‡Œé¢è€é©¬çš„å°è¯ï¼šä½ ä»¬å¤©å¤©æ··æ—¥å­ï¼Œå°å¿ƒå°†æ¥è®©æ—¥å­æ··äº†ã€‚å¯¹ï¼Œæ²¡é”™ï¼Œä¸‹ä¸ªæœˆæœ€ä¸»è¦çš„ä»»åŠ¡æ˜¯å¤šç¡è§‰ï¼Œå¤šä¼‘æ¯ï¼ï¼ï¼ðŸ˜  å¯¹äº†ï¼Œå‰å‡ å¤©æ‹¿åˆ°äº†æ–‡å¿ƒä¸€è¨€çš„å†…æµ‹èµ„æ ¼ï¼Œè®©åˆ«äººç”³è¯·äº†ä¸€ä¸‹ï¼Œä¹Ÿç”³è¯·åˆ°äº†ï¼Œæ˜¯ä¸æ˜¯çŽ°åœ¨å¾ˆå®¹æ˜“ç”³è¯·äº†å‘¢ï¼Ÿä¸ç®¡äº†ï¼Œåæ­£èƒ½å¯¹è‡ªå·±æä¾›ä¸€å®šé‡çš„å¸®åŠ©å°±è¡Œäº†ã€‚ è¿˜æœ‰ä¸€ä»¶äº‹ï¼Œè¿™ä¸ªæœˆå¼€å§‹è¯»å²é“ç”Ÿçš„ã€Šæˆ‘ä¸Žåœ°å›ã€‹äº†ï¼Œæ˜¯ä¸€æœ¬æ•£æ–‡é›†ï¼Œä»Žç›®å‰è¯»è¿‡çš„å†…å®¹æ¥çœ‹ï¼Œå†™çš„å¾ˆçœŸè¯šï¼Œæœ‰äº›åœ°æ–¹çš„æå†™ä¹Ÿå¾ˆæœ‰è¯—æ„ï¼Œä½†ç›®å‰è§‰å¾—æœ€é—ªå…‰çš„åœ°æ–¹æ˜¯å¯¹å¹³æ·¡è€ŒåˆçœŸæŒšçš„æ„Ÿæƒ…çš„æå†™ï¼Œç‰¹åˆ«æ˜¯æ¯çˆ±ï¼Œå†™çš„çœŸçš„å¾ˆæ„Ÿäººï¼Œè¯»ç€è¯»ç€ï¼Œæœ‰æ—¶å€™éƒ½ä¼šæƒ³åˆ°ä¸¤å¹´å‰è‡ªå·±çš„æ ·å­ã€‚å›žåˆ°è¿‡åŽ»ä¸çŽ°å®žï¼Œå¥½å¥½æŠŠæ¡çŽ°åœ¨æ‰æ˜¯æ­£é€”ï¼Œä¸éœ€è¦å¸¦ç€æ˜¨æ—¥çš„åŒ…è¢±ï¼Œä¹Ÿä¸éœ€è¦å¸¦ç€æœªæ¥çš„åŽ‹åŠ›ï¼Œè®¤çœŸåšå¥½çœ¼å‰çš„äº‹æƒ…å°±å¥½ðŸ˜Œã€‚ BTWï¼Œè¿™ä¸ªæœˆå…¶å®žæ²¡æ€Žä¹ˆå¥½å¥½ç»ƒç´ï¼Œå¥½åƒä¸€æ—¶é—´æ‰¾ä¸åˆ°æ–¹å‘äº†ä¸€æ ·ã€‚ä»Žä¸Šæ¬¡è‡ªå·±å½•éŸ³ï¼Œåˆ°çŽ°åœ¨å·²ç»å¿«ä¸€å¹´çš„æ—¶é—´äº†ï¼Œè™½ç„¶è‡ªå·±ä»Šå¹´ä¹Ÿç»ƒä¹ äº†ä¸€äº›æ­Œå’Œæ›²å­ï¼Œä½†ä¹Ÿè¦è‡ªå·±å½•ä¸€ä¸‹ï¼Œè®°å½•ä¸‹æ¥å•Šï¼Œä¸‹ä¸ªæœˆå¾—è°‹åˆ’ä¸€ä¸‹è¿™ä¸ªäº‹æƒ…ã€‚ å¥½äº†ï¼Œå°±è¿™æ ·ï¼Œç¥è‡ªå·±å¤©å¤©å¼€å¿ƒ~PSï¼šä½ å¥½åœŸå•ŠðŸ˜†]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C è¯­è¨€ä¸Žç¼“å†²åŒº]]></title>
    <url>%2F2023%2F08%2F24%2FC-%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[æœ‰å…³ç¼“å†²åŒºçš„æ¦‚å¿µå’Œ C è¯­è¨€ä¸­ç›¸å…³çš„å†…å®¹...åœ¨äº†è§£äºŒè€…è”ç³»ä¹‹å‰ï¼Œå…ˆè¦æ˜Žç™½ç¼“å†²åŒºçš„æ¦‚å¿µã€‚ ç¼“å†²åŒºæ‰€è°“ç¼“å†²åŒºï¼ˆBufferï¼‰ï¼Œå°±æ˜¯æŒ‡æš‚æ—¶å­˜æ”¾è¾“å…¥æˆ–è¾“å‡ºå†…å®¹çš„ä¸€ä¸ªå†…å­˜ç©ºé—´ï¼Œå¹¶ä¸”è¿™ä¸ªç©ºé—´çš„å¤§å°æ˜¯ä¸€å®šçš„ã€‚é‚£ä¸ºä»€ä¹ˆè¦è®¾ç½®ç¼“å†²åŒºå‘¢ï¼Ÿç›®çš„æ˜¯ä¸ºäº†å°†é«˜é€Ÿè¯»å†™è®¾å¤‡ä¸Žä½Žé€Ÿè¯»å†™è®¾å¤‡åŒæ­¥èµ·æ¥ã€‚ä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼Œæ‰“å°æœºçš„æ‰“å°é€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œè€Œç”µè„‘æ“ä½œæŒ‡ä»¤çš„å“åº”é€Ÿåº¦æ¯”è¾ƒå—ï¼Œä½†åœ¨æ‰“å°æœºæ‰“å°çš„åŒæ—¶ï¼Œå¯ä»¥æ“ä½œç”µè„‘ä¸æ–­æŠŠè¦æ‰“å°çš„å†…å®¹å‘é€åˆ°æ‰“å°æœºï¼ˆç”µè„‘æ“ä½œä¸ç”¨ç­‰å¾…ï¼‰ï¼Œå¯¹åº”æ‰“å°æœºå°±ä¼šä¾æ¬¡æ‰§è¡Œæ‰“å°ä»»åŠ¡ã€‚ å¦å¤–ï¼Œéœ€è¦æ³¨æ„åŒºåˆ†ç¼“å†²åŒºï¼ˆBufferï¼‰å’Œç¼“å­˜ï¼ˆCacheï¼‰çš„æ¦‚å¿µï¼Œè¿™é‡Œä¸åšæ·±ç©¶ã€‚ Cåœ¨ C è¯­è¨€ä¸­ä¹Ÿæœ‰ç”¨åˆ°ç¼“å†²åŒºè¿™ä¸ªâ€œè®¾è®¡æ¨¡å¼â€ï¼Œä¹‹æ‰€ä»¥ç§°ä¹‹ä¸ºè®¾è®¡æ¨¡å¼ï¼Œä¸€æ˜¯ç¬”è€…ä¸ç¡®å®šå…¶ä»–è¯­è¨€æ˜¯å¦ä¹Ÿæ˜¯å¦‚æ­¤ï¼ˆåªèƒ½ç¡®å®šå¤§éƒ¨åˆ†è¯­è¨€æ˜¯å¦‚æ­¤ï¼‰ï¼›äºŒæ˜¯å°±ç¬”è€…çš„ä¸ªäººç†è§£ï¼Œå°†ç¼“å†²åŒºç§°å‘¼ä¸ºä¸€ç§ï¼ˆè®¡ç®—æœºé¢†åŸŸçš„ï¼‰è®¾è®¡æ¨¡å¼æ›´æ°å½“ï¼Œå› ä¸ºä¸æ­¢ç¨‹åºè¯­è¨€çš„è®¾è®¡å¦‚æ­¤ï¼Œéƒ¨åˆ†ç¡¬ä»¶çš„è®¾è®¡ä¹Ÿæ˜¯æœ‰è¿™ä¸ªæ¨¡å¼çš„å­˜åœ¨ã€‚ä¸è¿‡ï¼Œè¿™é‡Œä¸æ·±ç©¶å…¶ä»–çš„å†…å®¹ï¼Œåªä¸“æ³¨ C è¯­è¨€ä¸­ä¸Žç¼“å†²åŒºç›¸å…³çš„å†…å®¹ã€‚ C è¯­è¨€ä¸­å­˜åœ¨ä¸‰ç§ç¼“å†²æ¨¡å¼ï¼šå…¨ç¼“å†²ï¼ˆfully bufferedï¼‰ã€è¡Œç¼“å†²ï¼ˆline bufferedï¼‰å’Œæ— ç¼“å†²ï¼ˆunbufferedï¼‰ã€‚åœ¨æŽ¢è®¨å„ç§ç¼“å†²æ¨¡å¼ä¹‹å‰ï¼Œå…ˆå¾—æ˜Žç¡®ä¸€ä¸‹ C è¯­è¨€ä¸­æµçš„æ¦‚å¿µï¼Œå¯ä»¥å‚è€ƒä¸€ä¸‹ç™¾åº¦ç™¾ç§‘â€”â€”æµã€‚å®žé™…ä¸Šï¼Œå¯ä»¥æŠŠ C è¯­è¨€ä¸­é€šè¿‡fopenå‡½æ•°æ‰“å¼€æ–‡ä»¶å¾—åˆ°çš„æ–‡ä»¶æŒ‡é’ˆçœ‹ä½œæµçš„å…¥å£ï¼Œå½“é€šè¿‡è¿™ä¸ªæ–‡ä»¶æŒ‡é’ˆå‘æ–‡ä»¶è¯»å†™æ•°æ®æ—¶ï¼Œè¿™äº›æ•°æ®å°±æ˜¯æµï¼Œè¿™ä¸ªè¿‡ç¨‹å°±æ˜¯â€œæµåŠ¨â€ã€‚å¯¹åº”çš„ï¼ŒC è¯­è¨€ä¸­æä¾›äº†ä¸‰ä¸ªæ ‡å‡†æµï¼šæ ‡å‡†è¾“å…¥æµï¼ˆstdinï¼‰ã€æ ‡å‡†è¾“å‡ºæµï¼ˆstdoutï¼‰å’Œæ ‡å‡†é”™è¯¯æµï¼ˆstderrï¼‰ï¼Œå…¶ä¸­stdinå’Œstdoutä¸€èˆ¬æ˜¯è¡Œç¼“å†²ï¼Œstderrä¸€èˆ¬æ˜¯æ— ç¼“å†²çš„ï¼ˆä¸ºçš„æ˜¯èƒ½ç¬¬ä¸€æ—¶é—´è¾“å‡ºé”™è¯¯ä¿¡æ¯ï¼‰ã€‚å†™åˆ°è¿™é‡Œï¼Œä¼šæœ‰ä¸€ä¸ªç–‘é—®ï¼Œä½¿ç”¨fopenå‡½æ•°æ‰“å¼€çš„æ–‡ä»¶æµï¼Œé»˜è®¤çš„ç¼“å†²æ¨¡å¼æ˜¯ä»€ä¹ˆå‘¢ï¼Ÿä¸€èˆ¬æ˜¯è¡Œç¼“å†²ï¼Œå¯èƒ½æ˜¯å…¨ç¼“å†²ï¼Œè¿™å–å†³äºŽç¼–è¯‘å™¨å…·ä½“çš„å®žçŽ°ï¼Œä½†å¯ä»¥é€šè¿‡setvbufå‡½æ•°æ¥ä¿®æ”¹æµçš„ç¼“å†²æ¨¡å¼ã€‚ å¥½äº†ï¼Œå…¶ä»–çš„é—®é¢˜æš‚æ—¶ä¸è°ˆäº†ï¼Œä¸‹é¢æ¥æŽ¢ç©¶ä¸€ä¸‹å„ç§ç¼“å†²æ¨¡å¼ã€‚PSï¼šä»¥ä¸‹æµ‹è¯•å‡åœ¨ Ubuntu 16.04 çŽ¯å¢ƒä¸‹è¿›è¡Œã€‚ å…¨ç¼“å†²å…¨ç¼“å†²å°±æ˜¯åœ¨ç¼“å†²åŒºå¡«æ»¡äº†ä¹‹åŽï¼Œæ‰æ‰§è¡Œ I/O æ“ä½œã€‚æµ‹è¯•ä»£ç ï¼štest112345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOFBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œé¦–å…ˆä½¿ç”¨fopenå‡½æ•°åœ¨w+ï¼ˆè¯»ï¼Œè‹¥æ–‡ä»¶ä¸å­˜åœ¨åˆ™åˆ›å»ºï¼‰çš„æ¨¡å¼ä¸‹æ‰“å¼€æ–‡ä»¶ï¼ŒæŽ¥ç€ä½¿ç”¨setvbufå‡½æ•°è®¾ç½®ç¼“å†²æ¨¡å¼ä¸º_IOFBFï¼ˆå…¨ç¼“å†²ï¼‰ã€‚è¿è¡Œç¨‹åºï¼Œåœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­å¯ä»¥ç¡®è®¤tmpæ–‡ä»¶å·²åˆ›å»ºï¼Œç„¶åŽé”®å…¥1$ cat tmp æ˜¾ç¤ºæ–‡ä»¶æ— å†…å®¹ã€‚ è¡Œç¼“å†²è¡Œç¼“å†²å°±æ˜¯åœ¨é‡åˆ°æ¢è¡Œç¬¦ï¼ˆ\nï¼‰æ—¶ï¼Œæ‰§è¡Œ I/O æ“ä½œï¼Œå…¸åž‹ä»£è¡¨å°±æ˜¯æ ‡å‡†è¾“å…¥çš„scanfå‡½æ•°ï¼Œæ¯æ¬¡è¾“å…¥å®Œæ•°æ®å’Œå›žè½¦åŽï¼Œæ‰èƒ½çœ‹åˆ°æ•ˆæžœã€‚æµ‹è¯•ä»£ç ï¼štest2123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG\n";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOLBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; ç›¸æ¯” test1ï¼Œä¸Šé¢çš„ä»£ç æœ‰ä¸¤ä¸ªæ”¹åŠ¨ï¼š const char *string = &quot;ABCDEFG\n&quot;;ï¼ŒåŠ å…¥\nåŽï¼Œç¨‹åºæ‰ä¼šè¿›è¡Œ I/O æ“ä½œ ret = setvbuf(fp, buff, _IOLBF, 1024);ï¼Œä¿®æ”¹ä¸ºè¡Œç¼“å†²æ¨¡å¼ åŒæ ·çš„æ€è·¯ï¼Œè¿è¡Œç¨‹åºï¼Œåœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­å¯ä»¥ç¡®è®¤tmpæ–‡ä»¶å·²åˆ›å»ºï¼Œç„¶åŽé”®å…¥1$ cat tmp æ˜¾ç¤ºï¼š1ABCDEFG æ— ç¼“å†²æ— ç¼“å†²å°±æ˜¯ä¸è¿›è¡Œç¼“å†²ï¼Œç›´æŽ¥æ‰§è¡Œ I/O æ“ä½œã€‚æµ‹è¯•ä»£ç ï¼štest3123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IONBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); while(1)&#123; &#125; return 0;&#125; ç›¸æ¯” test2ï¼Œä¸Šé¢çš„ä»£ç æœ‰ä¸¤ä¸ªæ”¹åŠ¨ï¼š const char *string = &quot;ABCDEFG;ï¼Œä¸Ž test1 ä¿æŒä¸€è‡´ ret = setvbuf(fp, buff, _IONBF, 1024);ï¼Œä¿®æ”¹ä¸ºæ— ç¼“å†²æ¨¡å¼ åŒæ ·çš„æ€è·¯ï¼Œè¿è¡Œç¨‹åºï¼Œåœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­å¯ä»¥ç¡®è®¤tmpæ–‡ä»¶å·²åˆ›å»ºï¼Œç„¶åŽé”®å…¥1$ cat tmp æ˜¾ç¤ºï¼š1ABCDEFG(account)$xxx ä¸Šé¢çš„(account)$xxxæ˜¯ç»ˆç«¯æ˜¾ç¤ºçš„ç”¨æˆ·åï¼Œå› ä¸ºæ²¡æœ‰\nï¼Œæ‰€ä»¥ä¼šä¸Žç»ˆç«¯çš„ç”¨æˆ·åæ˜¾ç¤ºåœ¨ä¸€è¡Œã€‚ å¦‚ä½•åˆ·æ–°ç¼“å†²åŒºæ˜Žç¡®å„ç§ç¼“å†²æ¨¡å¼çš„ç‰¹ç‚¹åŽï¼Œä¹Ÿè¦æ˜Žç™½å¦‚ä½•åˆ·æ–°ç¼“å†²åŒºã€‚å…¶å®žä¸Šé¢å·²ç»æåˆ°ä¸€ç§åˆ·æ–°ç¼“å†²åŒºçš„æ–¹æ³•äº†ï¼Œåœ¨è¡Œç¼“å†²æ¨¡å¼ä¸‹ï¼Œåªéœ€è¦åœ¨å‘æµè¾“å…¥ä¸€ä¸ª\nï¼Œå°±ä¼šåˆ·æ–°ç¼“å†²åŒºã€‚è€Œ C æ ‡å‡†åº“ä¹Ÿæä¾›äº†fflushå‡½æ•°ç”¨æ¥åˆ·æ–°ç¼“å†²åŒºã€‚ä½¿ç”¨ test1 ä¸­çš„ä»£ç ï¼štest41234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define FILEPATH "./tmp"const char *string = "ABCDEFG";int main() &#123; char buff[1024]; FILE *fp = NULL; fp = fopen(FILEPATH, "w+"); if(fp == NULL) &#123; perror("fopen() error!\n"); &#125; int ret = 0; ret = setvbuf(fp, buff, _IOFBF, 1024); if(ret != 0) &#123; perror("setvbuf error!\n"); &#125; fprintf(fp, "%s", string); fflush(fp); while(1)&#123; &#125; return 0;&#125; ç›¸æ¯” test1ï¼Œä¸Šé¢çš„ä»£ç æœ‰ä¸ªæ”¹åŠ¨ï¼š fflush(fp);ï¼Œæ‰‹åŠ¨åˆ·æ–°ç¼“å†²åŒº åŒæ ·çš„æ€è·¯ï¼Œè¿è¡Œç¨‹åºï¼Œåœ¨å¦ä¸€ä¸ªç»ˆç«¯ä¸­å¯ä»¥ç¡®è®¤tmpæ–‡ä»¶å·²åˆ›å»ºï¼Œç„¶åŽé”®å…¥1$ cat tmp æ˜¾ç¤ºï¼š1ABCDEFG(account)$xxx æ˜¾ç¤ºç»“æžœä¸Ž test3 ä¸€è‡´ã€‚ è°ƒç”¨fflushå‡½æ•°åŽå°±ä¼šåˆ·æ–°ç¼“å†²åŒºï¼Œä»»ä½•ä¸€ç§ç¼“å†²æ¨¡å¼ä¸‹ï¼Œéƒ½å¯ä»¥ä½¿ç”¨è¯¥å‡½æ•°æ¥åˆ·æ–°ç¼“å†²åŒºã€‚ ç»“è¯­C è¯­è¨€ä¸­æœ‰å…³ç¼“å†²åŒºçš„çŸ¥è¯†æš‚æ—¶å°±è®°å½•åˆ°è¿™é‡Œäº†ï¼Œå¦‚å‰æ‰€è¯´ï¼Œâ€œç¼“å†²â€æ›´å¤šæ˜¯ä¸€ç§æ€æƒ³ï¼Œä»Žè¿™ä¸ªè§’åº¦åŽ»ç†è§£ï¼Œåº”è¯¥èƒ½æ”¶èŽ·æ›´å¤šä¸œè¥¿ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[typedef å…³é”®å­—ä¸€äº›ç†è§£]]></title>
    <url>%2F2023%2F08%2F22%2Ftypedef-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å·©å›ºä¸€ä¸‹typedefå…³é”®å­—çš„ç”¨æ³•... ç”¨æ³•typedefæ˜¯ C è¯­è¨€çš„å…³é”®å­—ä¹‹ä¸€ï¼Œäººå°½çš†çŸ¥çš„ç”¨æ³•å°±æ˜¯â€œä¸ºä¸€ä¸ªç±»åž‹å–åˆ«åâ€ï¼Œæ¯”å¦‚ï¼štest112typedef unsigned int size_t;typedef char bool; æˆ–è€…ï¼štest212345typedef struct Student student;typedef struct Teacher &#123; char name[NAMESIZE]; int age;&#125; teacher; è¿˜æœ‰ï¼štest312345typedef struct Node* PtrtoNode;typedef struct Node &#123; PtrtoNode next; int data;&#125; node; ç±»ä¼¼çš„ä¾‹å­æœ‰å¾ˆå¤šï¼Œä½†å®žé™…ä¸Šâ€œä¸ºä¸€ä¸ªç±»åž‹å–åˆ«åâ€è¿™ç§è¯´æ³•æ˜¯ä¸ä¸¥è°¨çš„ã€‚ç§è®¤ä¸ºtypedefå…³é”®å­—ä¸ä»…ä»…æ˜¯â€œå–åˆ«åâ€ï¼Œè¿˜è¦ä»Žè¯­ä¹‰çš„è§’åº¦ä¸ŠåŽ»ç†è§£typedefçš„è¡Œä¸ºã€‚æ¯”å¦‚ï¼štest4123typedef int Arr[5];Arr *a;int (*parr)[5]; ä»Žè¯­ä¹‰çš„è§’åº¦è€Œè¨€ï¼Œåœ¨ä¸Šè¿°ä»£ç ä¸­ï¼ŒArræ˜¯ä¸€ç§â€œæ–°ç±»åž‹â€ï¼ˆè¿™é‡Œçš„æ–°ç±»åž‹å…¶å®žå¹¶ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šæ–°ç±»åž‹ï¼‰ï¼Œè¡¨ç¤ºå…ƒç´ ä¸ªæ•°ä¸º 5 çš„intæ•°ç»„ï¼Œå¯¹åº”çš„aæ˜¯ä¸€ä¸ªæŒ‡å‘å…ƒç´ ä¸ªæ•°ä¸º 5 çš„intæ•°ç»„çš„æ•°ç»„æŒ‡é’ˆã€‚å¯¹æ¯”ç±»åž‹ä¸€æ ·ã€ç”¨åŸºæœ¬ç±»åž‹å£°æ˜Žçš„æ•°ç»„æŒ‡é’ˆparrï¼Œä¹Ÿå¯ä»¥çœ‹å‡ºä½¿ç”¨typedefå¸¦æ¥çš„ä¾¿åˆ©æ€§ã€‚å®žé™…ä¸Šï¼Œç†Ÿæ‚‰ C++ çš„åŒå­¦ï¼Œå¯èƒ½ä¼šå‘çŽ°typedefå’Œusingçš„åŠŸèƒ½æœ‰ç‚¹ç±»ä¼¼ã€‚ ç±»ä¼¼çš„ç”¨æ³•ï¼Œè¿˜æœ‰å®šä¹‰å‡½æ•°æŒ‡é’ˆçš„ç”¨æ³•ï¼Œå¦‚ä¸‹ï¼štest51typedef void (*pfun)(int); ä¸Šè¿°ä»£ç ä¸­ï¼Œå®šä¹‰äº†ä¸€ä¸ªè¿”å›žå€¼ä¸ºvoidï¼Œå‚æ•°ä¸ºä¸€ä¸ªintçš„å‡½æ•°æŒ‡é’ˆç±»åž‹pfunã€‚ é™·é˜±è¿™é‡Œï¼Œè¿˜éœ€è¦æä¸€ä¸‹typedefå’Œconstå…³é”®å­—ä¸€èµ·ä½¿ç”¨æ—¶çš„é™·é˜±â€”â€”åƒä¸‡ä¸è¦æŠŠtypedefå’Œ#defineçš„æ–‡æœ¬æ›¿æ¢æ··ä¸ºä¸€è°ˆã€‚æ¯”å¦‚ï¼štest51234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;typedef char *pchar;int main() &#123; char s1[10] = "hello"; char s2[10] = "world"; const pchar str = s1;// str = s2; // error *str = 'g'; puts(s1); const char *pc = s1; pc = s2;// *pc = 'g'; // error puts(pc); int i = 0, j = 2; const int *pi = &amp;j; pi = &amp;i;// *pi = 2; // error int * const ppi = &amp;i; *ppi = 3; // correct printf("%d\n", *pi); return 0;&#125;/*out:gelloworld3*/ åœ¨é˜…è¯»ä¸‹é¢çš„è®¨è®ºä¹‹å‰ï¼Œéœ€è¦ç†è§£const typename *å’Œtypename * constçš„åŒºåˆ«ã€‚ å¦‚æžœè®¤ä¸ºtypedefæ˜¯æ–‡æœ¬æ›¿æ¢ï¼Œé‚£ä¹ˆconst pchar strä¸Žconst char *strä¸€è‡´ï¼Œå¯¹åº”è¯­å¥*str = &#39;g&#39;;å°±ä¼šå‡ºé”™ï¼Œè€Œstr = s2;å°±ä¼šæ­£å¸¸æ‰§è¡Œï¼ˆå¯ä»¥å¯¹æ¯”ä¸‹é¢const char *å’Œconst intç›¸å…³çš„ä»£ç ï¼‰ã€‚ä½†äº‹å®žä¸Šï¼Œç»“æžœæ­£å¥½ç›¸åï¼Œç¼–è¯‘å™¨è®¤ä¸º*str = &#39;g&#39;;æ­£ç¡®ã€str = s2;é”™è¯¯ï¼Œè¿™è¯´æ˜Žï¼Œç¼–è¯‘å™¨å¹¶ä¸è®¤ä¸ºstræ˜¯ä¸€ä¸ªconst char *ã€‚ ä»Žè¯­ä¹‰çš„è§’åº¦æ¥ç†è§£ï¼Œpcharçš„ç±»åž‹æ˜¯charåž‹çš„æŒ‡é’ˆï¼Œåœ¨å…¶å‰é¢åŠ ä¸Šä¸€ä¸ªconstï¼Œè¡¨ç¤ºè¿™ä¸ªæŒ‡é’ˆæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œæ‰€ä»¥const pcharçš„å®žé™…ç±»åž‹æ˜¯char * constï¼Œè€Œä¸æ˜¯const char *ï¼Œè¿™ç‚¹ä»ŽåŽé¢çš„ä»£ç ä¹Ÿå¯ä»¥å¯¹æ¯”å‡ºæ¥ã€‚ æœ€åŽéœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œtypedefçš„ç”¨æ³•æ˜¯ C çš„æ ‡å‡†è§„å®šçš„ï¼Œæœ¬æ–‡åªæ˜¯éªŒè¯å¦‚ä½•ä½¿ç”¨ï¼Œè€Œä¸æ˜¯è¯æ˜Žè¿™æ˜¯ç¼–è¯‘å™¨çš„é»‘é­”æ³•ðŸ˜‚ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>typedef</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C è¯­è¨€ä¸­çš„å›žè°ƒå‡½æ•°]]></title>
    <url>%2F2023%2F08%2F12%2FC-%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[å¾ˆä¹…æ²¡æœ‰å†™ blog äº†ï¼Œè¿™æ¬¡å†™ä¸€ç‚¹ä¸Žå›žè°ƒå‡½æ•°ç›¸å…³çš„å†…å®¹...ðŸ§ æ­¤æ–‡ç®—æ˜¯ä¹‹å‰å­¦ä¹ è¿‡ç¨‹ä¸­ï¼Œè®°å½•çš„ç¬”è®°å§ã€‚ æ¦‚å¿µé¦–å…ˆäº†è§£ä¸€ä¸‹å›žè°ƒçš„æ¦‚å¿µï¼š å›žè°ƒå‡½æ•°å°±æ˜¯ä¸€ä¸ªè¢«ä½œä¸ºå‚æ•°ä¼ é€’çš„å‡½æ•°ã€‚åœ¨Cè¯­è¨€ä¸­ï¼Œå›žè°ƒå‡½æ•°åªèƒ½ä½¿ç”¨å‡½æ•°æŒ‡é’ˆå®žçŽ°ï¼Œåœ¨C++ã€Pythonã€ECMAScriptç­‰æ›´çŽ°ä»£çš„ç¼–ç¨‹è¯­è¨€ä¸­è¿˜å¯ä»¥ä½¿ç”¨ä»¿å‡½æ•°æˆ–åŒ¿åå‡½æ•°ã€‚ ä»¥ä¸Šè§£é‡Šæ¥è‡ªç™¾åº¦ç™¾ç§‘ - å›žè°ƒå‡½æ•°ã€‚ä»…ä»Žç®€å•ç†è§£çš„è§’åº¦æ¥è®²ï¼Œä¸ªäººè®¤ä¸ºä»¥è¿™æ ·çš„æ–¹å¼è¯´æ˜Žå›žè°ƒå‡½æ•°æ˜¯ä»€ä¹ˆï¼Œå¾ˆç›´è§‚æ˜Žäº†ã€‚æ‰€ä»¥ï¼Œè¿™ç¯‡æ–‡ç« ä¸­æ‰€æåˆ°çš„å›žè°ƒå‡½æ•°å°±æ˜¯æŒ‡è¢«ä½œä¸ºå‚æ•°ä¼ é€’çš„å‡½æ•°ã€‚ä¸‹é¢ï¼Œå†ç ”ç©¶ä¸€ä¸‹ C ä¸­å›žè°ƒå‡½æ•°çš„ä½¿ç”¨ã€‚ åº”ç”¨å¦‚ä¸Šæ‰€è¿°ï¼ŒC ä¸­çš„å›žè°ƒå‡½æ•°åªèƒ½ç”¨å‡½æ•°æŒ‡é’ˆå®žçŽ°ï¼Œå…·ä½“å¦‚ä½•ï¼Œç›´æŽ¥çœ‹ä¸‹é¢çš„ç¤ºä¾‹ï¼štest11234567891011121314151617#include &lt;stdio.h&gt;typedef void (*pfunc)();void ppfunc() &#123; printf("Here is ppfunc!\n");&#125;void func(pfunc p) &#123; p(); printf("Here is func!\n");&#125;int main() &#123; func(&amp;ppfunc); return 0;&#125; åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œåˆ©ç”¨typedefå…³é”®å­—å®šä¹‰äº†ä¸€ä¸ªå«åšpfuncçš„å‡½æ•°æŒ‡é’ˆï¼Œè¿™ä¸ªå‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°æœ‰ä¸¤ä¸ªâ€œç‰¹ç‚¹â€ï¼š æ²¡æœ‰å‚æ•° è¿”å›žå€¼ä¸ºvoid å¦å¤–ï¼Œä¸Šè¿°ä»£ç è¿˜å®šä¹‰äº†ä¸€ä¸ªå«åšfuncçš„å‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ä»¥pfuncç±»åž‹çš„å‡½æ•°æŒ‡é’ˆpä½œä¸ºå‚æ•°ï¼Œè¿”å›žå€¼ä¸ºvoidï¼Œä¸”åœ¨å…¶å‡½æ•°ä½“å†…è¿˜è°ƒç”¨äº†pæŒ‡å‘çš„å‡½æ•°ï¼Œå¹¶æ‰“å°è¾“å‡ºäº†Here is func!ã€‚æœ€ç»ˆï¼Œè¿™ä¸ªç¨‹åºçš„è¾“å‡ºç»“æžœæ˜¯ï¼š12Here is ppfunc!Here is func! å¯ä»¥å‘çŽ°ï¼Œåœ¨mainå‡½æ•°ä¸­é€šè¿‡ä¼ é€’å‡½æ•°æŒ‡é’ˆppfuncï¼ˆå®žé™…ä¸Šï¼Œè¿™é‡ŒæŠŠå‡½æ•°çš„å…¥å£åœ°å€å«åšå‡½æ•°æŒ‡é’ˆä¸æ˜¯å¾ˆä¸¥è°¨çš„è¯´æ³•ï¼Œä»…ä»…æ˜¯ä¸ºäº†æ–¹ä¾¿è¯´æ˜Ž&gt;ï¼‰ï¼Œåœ¨funcå‡½æ•°ä¸­æˆåŠŸè°ƒç”¨äº†ppfuncå‡½æ•°ã€‚æ­¤æ—¶ï¼Œppfuncå°±å«åšå›žè°ƒå‡½æ•°ï¼Œfuncå°±å«åšä¸»è°ƒå‡½æ•°ã€‚æ•´ä¸ªæ‰§è¡Œè¿‡ç¨‹ï¼Œä¹Ÿå¯ä»¥ç®€å•çš„æ¦‚æ‹¬ä¸ºï¼šåœ¨è°ƒç”¨funcå‡½æ•°çš„è¿‡ç¨‹ä¸­ï¼Œé€šè¿‡ä¼ é€’è¿‡æ¥çš„å‡½æ•°æŒ‡é’ˆpæ¥è°ƒç”¨ppfuncå‡½æ•°ã€‚ çŽ°åœ¨å¯ä»¥å‘çŽ°ï¼Œè¦æƒ³æŽŒæ¡ C ä¸­å›žè°ƒå‡½æ•°çš„ç”¨æ³•ï¼Œå¿…é¡»è¦å…·å¤‡ï¼š ç†è§£å‡½æ•°æŒ‡é’ˆæ¦‚å¿µ ç†è§£typedefå…³é”®å­—å®šä¹‰å‡½æ•°æŒ‡é’ˆç”¨æ³• ç†è§£å‡½æ•°çš„æœ¬è´¨ï¼šå†…å­˜ä¸­çš„ä»£ç æ®µ åŒæ—¶ï¼Œä¹Ÿä¼šäº§ç”Ÿè¿™æ ·çš„ç–‘é—®ï¼šå¦‚æžœåªæ˜¯ä¸ºäº†è°ƒç”¨ppfuncå‡½æ•°ï¼Œä¸ºä»€ä¹ˆä¸ç›´æŽ¥åœ¨funcå‡½æ•°é‡Œè°ƒç”¨ppfuncå‡½æ•°å‘¢ï¼Ÿç”¨å›žè°ƒå‡½æ•°çš„æ–¹å¼æ¥è°ƒç”¨ï¼Œä¸æ˜¯å¤šæ­¤ä¸€ä¸¾å—ï¼Ÿ å…¶å®žä¸Šé¢çš„ä»£ç ä»…ä»…æ˜¯ä¸ºäº†ç”¨ä½œè¯´æ˜Žè€Œå†™å‡ºæ¥çš„ï¼Œå®žé™…æƒ…å†µå½“ç„¶ä¸ä¼šè¿™ä¹ˆå¤šæ­¤ä¸€ä¸¾ã€‚åœ¨ C è¯­è¨€ä¸­æ¯”è¾ƒå¸¸è§ä½¿ç”¨å›žè°ƒå‡½æ•°çš„ä¾‹å­ï¼Œå°±æ˜¯æ ‡å‡†åº“çš„qsortå‡½æ•°ï¼Œæ¯”å¦‚ä¸‹é¢çš„ç¤ºä¾‹ä»£ç ï¼štest212345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int cmp_int(const void *p, const void *q) &#123; return *(int *)p &gt; *(int *)q;&#125;int cmp_double(const void *p, const void *q) &#123; return *(double *)p &lt; *(double *)q;&#125;int main() &#123; int arr1[5] = &#123;3, 2, 5, 1, 4&#125;; qsort(arr1, 5, sizeof(*arr1), cmp_int); puts("arr1:"); for(int i = 0; i &lt; sizeof(arr1) / sizeof(*arr1); i++) printf("%d ", arr1[i]); putchar('\n'); double arr2[5] = &#123;1.2, 2.3, 3.4, 4.5, 5.6&#125;; qsort(arr2, 5, sizeof(*arr2), cmp_double); puts("arr2:"); for(int i = 0; i &lt; sizeof(arr2) / sizeof(*arr2); i++) printf("%.1lf ", arr2[i]); putchar('\n'); return 0;&#125;/*out:arr1:1 2 3 4 5arr2:5.6 4.5 3.4 2.3 1.2*/ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä½¿ç”¨qsortå‡½æ•°å¯¹arr1å’Œarr2åˆ†åˆ«è¿›è¡Œå‡åºæŽ’åºå’Œé™åºæŽ’åºï¼Œè€Œarr1å’Œarr2åˆ†åˆ«æ˜¯ä¸¤ä¸ªä¸åŒç±»åž‹çš„æ•°ç»„ã€‚æ­¤æ—¶ï¼Œå¯ä»¥å‘çŽ°ï¼Œå¦‚æžœä¸ä½¿ç”¨å›žè°ƒå‡½æ•°ï¼Œå°±éœ€è¦å†™å‡ºä¸¤ä¸ªå‚æ•°ç±»åž‹å’ŒæŽ’åºæ–¹å¼éƒ½ä¸åŒçš„æŽ’åºå‡½æ•°ï¼Œå°½ç®¡è¿™ä¸¤ä¸ªæŽ’åºå‡½æ•°çš„ç®—æ³•æ˜¯ä¸€æ ·ã€‚æ‰€ä»¥ï¼Œä¸ºäº†é¿å…å†™é‡å¤çš„ä»£ç ï¼ˆå¦‚æžœä»Žå·¥ç¨‹çš„è§’åº¦æ¥è®²ï¼ŒåŽŸå› æ›´å¤šï¼‰ï¼Œå°±å¯ä»¥å€ŸåŠ©å›žè°ƒå‡½æ•°çš„æ–¹å¼ã€‚ ç»“è¯­åœ¨ C è¯­è¨€ä¸­ï¼Œå›žè°ƒå‡½æ•°çš„åº”ç”¨åœºæ™¯è¿˜æ˜¯æ¯”è¾ƒå¤šçš„ï¼Œä½†æƒ³è¦ç”¨å¥½è¿™ä¸ªå·¥å…·ï¼Œå¿…é¡»è¦æ˜Žç™½æŒ‡é’ˆçš„æ¦‚å¿µã€‚å½’æ ¹ç»“åº•ï¼Œå›žè°ƒå‡½æ•°è¿˜æ˜¯åœ¨æŒ‡é’ˆä¸ŠçŽ©èŠ±æ ·ã€‚å¦å¤–ï¼ŒC++ ä¸­çš„å›žè°ƒå‡½æ•°ä¹Ÿå¾ˆå¸¸è§ï¼Œæ¯”å¦‚ C++11 çš„ lambda æä¾›çš„åŒ¿åå‡½æ•°æˆ–è€…ä»¿å‡½æ•°ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå›žè°ƒå‡½æ•°æ˜¯ä¸€ç§ç¼–ç¨‹æ€æƒ³ï¼Œæ˜¯å·¥ç¨‹ä¸­çš„ä¸€ç§å®žè·µæ–¹æ³•ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>callback_function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_07_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F07%2F30%2F2023-07-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[æš‘å‡å·²ç»è¿‡åŽ»ä¸€åŠï¼Œç„¶è€Œæˆ‘å·²ç»æ²¡æœ‰äº†æš‘å‡... ãƒ†ã‚£ã‚³ - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼Your browser does not support the audio tag. è¿™å‡ å¤©åœ¨ç»ƒä¹ è¿™é¦–æ›²å­ï¼Œä¸æ˜¯å¾ˆéš¾ï¼Œä½†æœ‰äº›åœ°æ–¹æœ‰ç‚¹éº»çƒ¦ï¼Œè¿˜å¾—å¼ºåŒ–è®­ç»ƒä¸€ä¸‹å·¦æ‰‹çš„èƒ½åŠ›...å¦å¤–ï¼Œè™½ç„¶è¿™æ˜¯é¦–æ‚²ä¼¤ã€å­¤ç‹¬çš„æ›²å­ï¼Œä½†æˆ‘çŽ°åœ¨çš„å¿ƒæƒ…å¹¶ä¸æ‚²ä¼¤ã€å­¤ç‹¬ï¼Œå€’æ˜¯æœ‰äº›è®¸ sabishiyiï¼Œå“ˆå“ˆðŸ˜~ è¿™ä¸ªæœˆçš„æœˆåˆæ¯”è¾ƒå¿™ï¼ŒåŽŸå› æ˜¯å•å­è¦æŠ•äº§äº†ï¼Œå¿™äºŽæµ‹è¯•ä»£ç ï¼Œè€Œä¸”ä¸‹ä¸ªç‰ˆæœ¬åˆæ”¹äº†å¥½å¤šæ¬¡ðŸ˜‚ã€‚ç»“æžœï¼ŒåŽé¢å•å­å»¶æœŸäº†ï¼Œçž¬é—´å°±ä¸å¿™äº†ï¼Œä½†æ˜¯åˆæœ‰å…¶ä»–çš„æµ‹è¯•ä»»åŠ¡æ¥äº†ã€‚è€Œè¿™ä¸ªæµ‹è¯•ä»»åŠ¡å¾ˆæ¶å¿ƒï¼Œæ˜Žç¡®è¦å®Œæˆçš„ç›®æ ‡ï¼Œä¸æ˜¯æˆ‘ä¸€ä¸ªäººèƒ½è§£å†³çš„ï¼Œéœ€è¦å¤šä¸ªç³»ç»Ÿæ¥é…åˆå®Œæˆï¼Œä½†æ˜¯å°±æ˜¯è®©æˆ‘æµ‹è¯•...æœ‰æ—¶å€™ï¼Œæˆ‘çœŸçš„åœ¨æ€€ç–‘ï¼Œå¤„äºŽæŸäº›ä½ç½®çš„äººï¼ŒçŸ¥é“å¹²æ´»çš„äººå…·ä½“åœ¨å¹²ä»€ä¹ˆæ ·çš„äº‹æƒ…å—ï¼Ÿå“ˆå“ˆï¼Œæˆ‘çœŸæ˜¯å’¸åƒèåœæ·¡æ“å¿ƒ~ðŸ˜†ä¸åŽ»æƒ³è¿™äº›äº‹æƒ…äº†ï¼ŒæŠŠè‡ªå·±è¦æŠ•äº§çš„ä»»åŠ¡åšå¥½å°±è¡Œäº†ï¼Œæ¯•ç«Ÿè¿™æ˜¯è‡ªå·±çš„åˆ†å†…ä¹‹äº‹ã€‚ç›®å‰è¿˜æœ‰å‡ ä¸ªæ ·ä¾‹æ²¡è·‘è¿‡ï¼Œå¯èƒ½è¿˜éœ€è¦åœ¨ä¿®æ”¹ä¸‹ä»£ç ï¼Œæ‰€ä»¥æœ‰äº›åœ°æ–¹è¿˜è¦åœ¨æ·±ç©¶ä¸€ä¸‹ã€‚ä»¥ä¸Šï¼Œæ˜¯å¤§è‡´å·¥ä½œçš„å†…å®¹ï¼Œå…·ä½“ä¹Ÿä¸æƒ³å±•å¼€çš„å¤ªç»†äº†ï¼Œå°±è¿™æ ·å§ã€‚ å›žåˆ°å­¦ä¹ ä¸Šï¼Œè¿™ä¸ªæœˆç»§ç»­åœ¨çœ‹å››æœˆä»½åœä¸‹æ¥çš„ç½‘è¯¾ã€‚æ¶‰åŠåˆ°çš„å†…å®¹ï¼Œå°±æ˜¯ C å’Œæ•°æ®ç»“æž„ç›¸å…³çš„éƒ¨åˆ†ï¼Œä¹Ÿç®—æ˜¯ä¸€ç§å¤ä¹ å§ï¼Œæ¯•ç«Ÿæ•°æ®ç»“æž„å¾ˆå¤šéƒ½å¿˜äº†ðŸ¤...ä½†æ˜¯åœ¨å®žé™…å¬è¯¾å’Œæ‰“ç çš„è¿‡ç¨‹ä¸­ï¼Œè¿˜æ˜¯è§åˆ°äº†å¾ˆå¤šæ–°çš„å†…å®¹ï¼Œæ¯”å¦‚ï¼šC ä¸­å›žè°ƒå‡½æ•°çš„å®žçŽ°å’Œä½¿ç”¨ã€C ä¸­å¦‚ä½•åº”ç”¨ OO çš„æ€æƒ³å’ŒæŒ‡é’ˆåç§»é‡çš„ä½¿ç”¨ç­‰ï¼Œéƒ½æ˜¯è®©æˆ‘è§åˆ°è§‰å¾—å¾ˆæ–°å¥‡çš„ä¸œè¥¿ï¼Œä¸å¾—ä¸æ„Ÿå¹ C è¯­è¨€çœŸçš„å¤ªç²¾ç‚¼å’Œç®€æ´äº†ã€‚å¦å¤–ï¼Œå…³äºŽä¸Šé¢è¿™äº›æ–°å¥‡ï¼ˆå¯¹æˆ‘è€Œè¨€ï¼‰å†…å®¹çš„ç¬”è®°ï¼Œè®¡åˆ’æ˜¯åŽé¢æ…¢æ…¢è¡¥èµ·æ¥ï¼Œæ€»è€Œè¨€ä¹‹ï¼ŒåŠ æ²¹å§ã€‚æ‰€ä»¥ï¼Œå…«æœˆæœ€å¥½æ˜¯æŠŠè·Ÿæ•°æ®ç»“æž„ç›¸å…³çš„å†…å®¹åšå®Œï¼Œå¹¶ä¸”æŠŠä¸Ž C ç›¸å…³çš„å†…å®¹å¥½å¥½æ•´ç†ä¸€ä¸‹ï¼Œä¸ºé‡æ–°å¼€å§‹åŸºç¡€ç†è®ºçš„å­¦ä¹ æ‰“ä¸€ç‚¹åŸºç¡€ã€‚ ç”Ÿæ´»ä¸Šå€¼å¾—ä¸€æçš„æ˜¯ï¼Œè¿™ä¸ªæœˆåœ¨åƒã€çŽ©ä¸Šçš„èŠ±é”€æ˜Žæ˜¾å¤šäº†ä¸€äº›ï¼Œè‡³å°‘è‡ªå·±è¾¹è‡ªæˆ‘é”»ç‚¼ã€è¾¹æå‡ä¼™é£Ÿï¼Œè¿˜æ˜¯è®©è‡ªå·±é•¿äº† 3 å…¬æ–¤å•Šï¼Œå¤ªä¸å®¹æ˜“å•¦~ðŸ˜˜ã€‚è¯è¯´ï¼Œä»Šå¤©ä¸‹åˆæ‰åŽ»æ¸¸æ³³å›žæ¥ï¼Œå“ˆå“ˆï¼ŒçœŸç´¯~è®¡åˆ’ï¼Œä¸‹å‘¨å†åŽ»æ¸¸æ³³ï¼Œå˜¿å˜¿ã€‚å¯¹äº†ï¼Œè¿™ä¸ªæœˆè‡ªå·±åŽ»å”±äº†ä¸€æ¬¡æ­Œï¼Œä¸€ä¸ªäººé…£å”±äº† 4 å°æ—¶ï¼Œæ— äººæ‰“æ‰°ï¼Œæ˜¯çœŸçš„å¤ªçˆ½å•¦ã€‚è™½ç„¶å—“å­æœ€åŽæ„Ÿè§‰æœ‰ç‚¹ä¸èˆ’æœäº†ï¼Œä½†æ˜¯æ˜Žæ˜¾è¿˜ä¸å¤Ÿå°½å…´ï¼Œå“ˆå“ˆï¼Œå”±æ­ŒçœŸçš„æ˜¯ä¸€ä¸ªå¾ˆè§£åŽ‹çš„æ´»åŠ¨å•ŠðŸŽ¤~å”¯ä¸€è§‰å¾—è‡ªå·±è¿˜åšçš„ä¸å¥½çš„åœ°æ–¹å°±æ˜¯ï¼Œç¡çœ æ—¶é—´ä¸å¤ªå¤Ÿï¼ŒåŽŸå› æ˜¯å·¥ä½œæ—¥çš„æ—¶é—´å¤ªçŸ­æš‚äº†ï¼Œæ„Ÿè§‰å¤§è„‘å¥½åƒè¿˜æ²¡å¾—åˆ°ä¼‘æ¯ï¼Œå°±åˆè¦ä¸Šç­äº†ï¼Œå°±çœ‹ç‚¹åˆ«çš„è§†é¢‘åˆ†æ•£ä¸€ä¸‹è‡ªå·±çš„æ³¨æ„åŠ›ï¼Œç»“æžœæ¯æ¬¡éƒ½åˆ°åäºŒç‚¹ã€‚ä»Žå¥åº·å‡ºå‘ï¼Œè‡ªå·±è¿˜æ˜¯è¦æ³¨æ„å‘€ï¼Œè¦æ³¨æ„è‡ªæˆ‘çº¦æŸï¼Œå“ˆå“ˆï¼Œæ„Ÿè§‰è‡ªå·±åœ¨è¯´å±è¯ðŸ˜†ã€‚ å°±è¿™æ ·å§ï¼Œå°±è®°å½•è¿™äº›äº†ï¼Œå‰©ä¸‹è¦å®Œæˆçš„ä»»åŠ¡å°±ä¸¢ç»™å…«æœˆçš„è‡ªå·±å§ï¼Œä¸è¦å¿˜è®°è‡ªå·±çš„ç›®æ ‡å°±å¥½ã€‚ PSï¼šæˆ‘åˆæ¡äº†ä¸€å¼ é—¨ç¦å¡ðŸ˜‘]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_06_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F07%2F03%2F2023-06-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[2023 å·²ç»è¿‡åŽ»ä¸€åŠ~âœˆ å¥¹æ¥å¬æˆ‘çš„æ¼”å”±ä¼š - å¼ å­¦å‹Your browser does not support the audio tag. çªç„¶å¾ˆæƒ³å¬è¿™é¦–å‡†å¤‡å¼€å§‹ç»ƒä¹ ä½†è¿˜æ²¡å¼€å§‹ç»ƒä¹ çš„æ­ŒðŸ˜ï¼Œè½¬çœ¼é—´ï¼ŒåŠå¹´å·²é€... ç›®å…‰å›žåˆ°è¿™ä¸ªæœˆæ¥ï¼Œè¿˜æ˜¯è€è§„çŸ©ï¼Œå…ˆè¯´è¯´å·¥ä½œçš„äº‹æƒ…ã€‚è¿™ä¸ªæœˆçš„å·¥ä½œè¾ƒä¸ºå¿™ç¢Œï¼Œå¿™ç¢Œçš„ç‚¹åœ¨äºŽéœ€æ±‚æ²¡æœ‰ç†è§£æ¸…æ¥šï¼Œå¯¼è‡´å¼€å‘è¿‡ç¨‹ä¸­ï¼Œæ”¹è¿‡æ¥ï¼Œæ”¹è¿‡åŽ»ï¼Œåšäº†ä¸å°‘é‡å¤æ€§çš„å·¥ä½œï¼Œæœ‰ä¸€ç§å¹³ç™½æ— æ•…åšäº†å¾ˆå¤šæ— ç”¨åŠŸçš„æ„Ÿè§‰ï¼Œä½†è¿™æ ·åšçš„å¥½å¤„ï¼ˆå®‰æ…°è‡ªå·±ä¸€ä¸‹ï¼‰å°±æ˜¯ä»£ç å†™èµ·æ¥æ›´åŠ é¡ºæ‰‹äº†~ðŸ¤£ä»”ç»†æƒ³ä¸€æƒ³ï¼Œç›¸æ¯”è‡ªå·±åˆšæ¥è¿™é‡Œçš„æ—¶å€™ï¼ŒçœŸçš„è¿›æ­¥äº†å¾ˆå¤šå‘€ã€‚ä¸ç®¡æ˜¯ä»Žå¼€å‘æµç¨‹ã€ç¼–ç èƒ½åŠ›ï¼Œè¿˜æ˜¯ä¸šåŠ¡ç†è§£ã€æ²Ÿé€šèƒ½åŠ›ç­‰ï¼Œè‡ªå·±å„æ–¹é¢çš„èƒ½åŠ›éƒ½æœ‰æ‰€æé«˜ï¼Œä½†æ˜¯æœ€ä¸»è¦çš„è¿˜æ˜¯è‡ªå·±åˆ†æžé—®é¢˜å’Œè§£å†³é—®é¢˜çš„èƒ½åŠ›ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸¤æ–¹é¢çš„èƒ½åŠ›è¿˜å¾—ç»§ç»­é”»ç‚¼ï¼Œè¿˜æ˜¯è¦å¤šåŠ¨è„‘å­æ€è€ƒï¼Œè°‹å®šè€ŒåŽåŠ¨ã€‚æœ€åŽï¼Œå†æ’ä¸€å¥çš„æ˜¯ï¼Œä¸Šæ–‡æåˆ°çš„éœ€æ±‚ï¼Œä»Šå¤©æ‰æŠŠä»£ç å®¡æŸ¥å®ŒðŸ˜‚ å†å›žåˆ°å­¦ä¹ ä¸Šï¼Œè¿™ä¸ªæœˆé‡çœ‹äº†ç¿æºè€å¸ˆçš„ C++ è¯¾ç¨‹ï¼Œåˆæœ‰äº†ä¸€äº›ä¸ä¸€æ ·çš„æ”¶èŽ·ï¼Œä½†æ˜¯æ²¡æœ‰åšä¸‹ç¬”è®°ï¼ŒåŽŸå› æ˜¯æ²¡æœ‰å®žé™…çš„å·¥ç¨‹çŽ¯å¢ƒï¼Œä¸çŸ¥é“æ€Žä¹ˆå†™ç¬”è®°äº†ï¼Œåˆä¸æƒ³å†™å¤ªæ°´çš„æ–‡æ¡£...æ‰€ä»¥ï¼Œå¾ˆå°´å°¬ã€‚ç„¶åŽï¼Œæœ¬æ¥è®¡åˆ’é‡å†™ Nand2tetris é¡¹ç›®çš„ä¸€äº›ä»£ç ï¼Œç»“æžœä¹Ÿææµ…äº†ï¼Œè¿˜æœ‰æ‰“ç®—è¯»ä¸‹å…¶ä»–é¡¹ç›®çš„ä»£ç ï¼Œä¹Ÿéƒ½ææµ…äº†...çœ‹æ¥è‡ªå·±è¿˜æ˜¯å·æ‡’äº†å•Šï¼ˆå…¶å®žæ˜¯å¿™ç€æ‰“æ¸¸æˆï¼Œå“ˆå“ˆï¼‰ï¼Œå¾—ç»§ç»­åŠ æ²¹å•Š~é‚£è¿™ä¸ªæœˆå°±ä¸ç»™è‡ªå·±å®šå­¦ä¹ è®¡åˆ’äº†ï¼Œå…å¾—è‡ªå·±åˆå®Œä¸æˆðŸ˜‘ï¼Œå…¨å‡­è‡ªå¾‹äº†ã€‚ æœ€åŽå†å›žåˆ°ç”Ÿæ´»ä¸Šï¼Œèº«ä½“å·²ç»æ²¡æœ‰ä¸é€‚çš„åœ°æ–¹äº†ï¼Œé”»ç‚¼è®¡åˆ’ä¹Ÿä¸€ç›´åœ¨åšæŒï¼Œç†¬å¤œä¹Ÿå‡å°‘äº†ï¼Œè¦ç»§ç»­åŠªåŠ›ï¼ŒåŠ å¼ºé”»ç‚¼ã€‚çœ‹ç€å¤å¤©åˆ°äº†ï¼Œå¤©å¤©ä¸Šä¸‹ç­æ±—å¦‚é›¨ä¸‹ï¼Œæƒ³ç€å•¥æ—¶å€™åŽ»æ¸¸æ³³äº†ðŸŠâ€ï¼ŒæŠ½æ—¶é—´ä¸€å®šè¦è·Ÿæœ‹å‹åŽ»ä¸€æ¬¡ï¼Œå“ˆå“ˆã€‚ä¸Šä¸ªæœˆå€Ÿçš„ä¹¦æ²¡æ€Žä¹ˆçœ‹ï¼Œå®žå±žæƒ­æ„§ï¼Œçªç„¶æƒ³èµ·äº†ï¼Œèƒ¡é€‚æ›¾ç»å†™çš„æ‰“ç‰Œæ—¥è®°ï¼Œå“ˆå“ˆï¼Œä¸è¿‡ï¼ŒiPad ä¸Šçš„ä¹¦ç®—æ˜¯çœ‹çš„å·®ä¸å¤šäº†ã€‚æ‰€ä»¥ï¼Œè¿˜æ˜¯è¦æœ‰ä¸€å®šçš„é˜…è¯»é‡ï¼Œä½†ä¸å¤šï¼Œå“ˆå“ˆï¼Œè¿˜æ˜¯ä¸è¡Œå•Šï¼Œè¿˜å¾—åŠ å¤§é˜…è¯»é‡ã€‚å¦å¤–ï¼Œè¿™ä¸ªæœˆæŠŠé©´å¾—æ°´çš„ä¸»é¢˜æ›²ã€Šæˆ‘è¦ä½ ã€‹ç®—æ˜¯å¼¹ä¸‹æ¥äº†ï¼Œå…·ä½“çš„ç»†èŠ‚å› ä¸ºæ²¡æœ‰è®°è°±ï¼Œä¸æ˜¯ç‰¹åˆ«ç†Ÿï¼Œä½†å’Œå¼¦çš„èµ°å‘å·²ç»å¿ƒé‡Œæœ‰è°±äº†ï¼ŒæŒ‰ç…§è®¡åˆ’å¯ä»¥å¼€å§‹ã€Šå¤ªèªæ˜Žã€‹äº†ï¼Œä½†æ˜¯åˆæƒ³å¼¹ã€Šå¥¹æ¥å¬æˆ‘çš„æ¼”å”±ä¼šã€‹ï¼Œå“Žå‘€ï¼Œæœ‰ç‚¹éš¾ä»¥å–èˆã€‚ å¥½äº†ï¼Œè¿™æ¬¡çš„æ€»ç»“å°±åˆ°è¿™é‡Œäº†å§ï¼Œä¸ƒæœˆä»½ç»§ç»­åŠ æ²¹å§ï¼Œéªšå¹´~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_05_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F06%2F04%2F2023-05-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[å¿™ç¢Œçš„äº”æœˆ~ðŸ˜‘ Highway To Hell - AC/DCYour browser does not support the audio tag. ä¸ç®¡æ˜¯ä»Žå·¥ä½œè¿˜æ˜¯å­¦ä¹ æ¥è®²ï¼Œè¿™ä¸ªæœˆå¾ˆå¿™ç¢Œ...è¿˜æ˜¯è€è§„çŸ©ï¼Œå…ˆè¯´è¯´å·¥ä½œçš„äº‹æƒ…ã€‚è¿™ä¸ªæœˆå·¥ä½œä¸Šçš„äº‹æƒ…å¾ˆå¤šï¼Œä¸€æ˜¯è¿™ä¸ªæœˆçš„æŠ•äº§ï¼Œè¿˜æœ‰ä¸‹ä¸ªæœˆçš„æŠ•äº§ï¼Œä¸€å£æ°”å¥½å‡ ä¸ªå•å­ï¼ŒçœŸæ˜¯è®©äººåƒä¸æ¶ˆå•Š~é¡ºå¸¦çš„è¿˜æœ‰å¾ˆå¤šé…åˆæµ‹è¯•çš„æ‚äº‹è¦åšï¼ŒçœŸçš„æŒºå¿™çš„ðŸ˜ªã€‚å³ä¾¿æ˜¯åœ¨æˆ‘å†™è¿™ç¯‡æ€»ç»“çš„æ—¶å€™ï¼Œè¿˜æœ‰ä¸€äº›å·¥ä½œçš„äº‹æƒ…ä¸Šæ²¡æœ‰è§£å†³ã€‚ä½†æ˜¯ï¼Œè¿™æ˜¯ä¸‹å‘¨éœ€è¦è§£å†³çš„é—®é¢˜äº†ï¼Œå‘¨æœ«å°±è®©è‡ªå·±è½»æ¾ä¸€ç‚¹å§ã€‚ðŸ˜ å†è¯´è¯´å­¦ä¹ ï¼Œå˜¿å˜¿ï¼Œè¿™ä¸ªæœˆèŠ±äº†å¾ˆå¤šæ—¶é—´åœ¨ Nand2tetris ä¸Šï¼Œæ€»ä½“å­¦åˆ°äº†å¤§æ¦‚ç¬¬åç« çš„æ ·å­ï¼Œè¿˜å‰©ä¸‹ä¸€ç‚¹ç¼–è¯‘åŽŸç†å’Œæ“ä½œç³»ç»Ÿçš„å†…å®¹ã€‚ç›®å‰æ‰“ç®—æš‚æ—¶åœæ­¢ä¸€ä¸‹è¿›åº¦ï¼Œå›žè¿‡å¤´æ€»ç»“ä¸€ä¸‹ï¼ŒæŠŠä¸€äº›é€»è¾‘é‡æ–°æ¢³ç†æ¸…æ¥šï¼Œå†é‡å†™ä¸€äº›åŽŸæ¥çš„ä»£ç ã€‚å…¶å®žï¼Œä¸»è¦è¿˜æ˜¯æƒ³å…­æœˆä»½è¿‡çš„è½»æ¾ç‚¹ï¼Œå“ˆå“ˆ~è€Œä¸”ä¹Ÿæƒ³å†™ç‚¹å…¶ä»–çš„é¡¹ç›®ä»£ç ï¼Œæ¯•ç«Ÿå›žå¤´çœ‹çš„æ—¶å€™ï¼Œå¥½åƒåˆæ¬ äº†å¾ˆå¤šä¸œè¥¿ã€‚ æœ€åŽå›žåˆ°ç”Ÿæ´»ï¼ˆç”Ÿæ´»æ‰æ˜¯æœ€é‡è¦çš„ä¸œè¥¿å•Šï¼Œå´è¢«æˆ‘æŽ’åˆ°äº†æœ€åŽðŸ¤ï¼‰ï¼Œè¿™ä¸ªæœˆå› ä¸ºç†¬å¤œå¤ªå¤šï¼Œèº«ä½“å‡ºäº†ä¸€ç‚¹å°é—®é¢˜ðŸ˜žï¼Œéš¾å—äº†å¿«ä¸¤å‘¨ï¼Œè™½ç„¶ä¸æ˜¯å¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œä½†æ˜¯å¿ƒé‡Œå¾ˆä»‹æ€€...å®žé™…ä¸Šï¼Œèº«ä½“çš„é—®é¢˜è¯´ä¸å®šå¾ˆæ—©å°±äº§ç”Ÿäº†ï¼Œåªæ˜¯åŽŸæ¥å¹´è½»ï¼Œè¿™ä¸ªå®šæ—¶ç‚¸å¼¹æ²¡æœ‰çˆ†ç‚¸è€Œå·²ï¼Œä½†ä¸ç®¡æ€Žä¹ˆè¯´ï¼ŒçŽ°åœ¨çš„è‡ªå·±åº”è¯¥è®¤çœŸå¯¹å¾…è¿™ä¸ªé—®é¢˜äº†ï¼ˆä¸€ç›´è‡ªæˆ‘æ ‡æ¦œè®¤çœŸï¼Œåˆ°è¿™ä¸ªæ—¶å€™äº†ä¸èƒ½å†å½“ä½œçŽ©ç¬‘è¯äº†ï¼‰ã€‚ä¸è¿‡å¥½åœ¨ï¼Œå†™è¿™ç¯‡æ–‡ç« çš„æ—¶å€™ï¼Œèº«ä½“å·²ç»ä¸éš¾å—äº†ï¼Œé”»ç‚¼è®¡åˆ’ä¹Ÿå¼€å§‹é€æ­¥è¿›è¡Œäº†ï¼Œä¸å¥½çš„ä¹ æƒ¯ä¹Ÿå¾—æ”¹ä¸€æ”¹äº†ï¼Œå‰©ä¸‹çš„å°±äº¤ç»™æ—¶é—´å§ã€‚ å¦å¤–ï¼Œçœ‹äº†çœ¼ä¸Šä¸ªæœˆçš„æ€»ç»“ï¼Œè¿™ä¸ªæœˆæ˜¯æ‰“ç®—çœ‹å®Œã€Šé»„é‡‘æ—¶ä»£ã€‹çš„ï¼Œå¥½åœ¨è‡ªå·±æ²¡æœ‰å¿˜è®°ï¼Œæ˜¨å¤©ä¸‹åˆæŠ½äº†ä¸¤ä¸ªå°æ—¶æ—¶é—´ï¼Œä¸€å£æ°”è¯»å®Œäº†ï¼Œä¸è¿‡æ²¡æœ‰æ”¶èŽ·ç‰¹åˆ«å¤šçš„ä¹è¶£ï¼Œçœ‹æ¥éœ€è¦çœ‹ç‚¹å…¶ä»–ä½œå®¶çš„ä½œå“äº†ðŸ™‚ã€‚æ‰€ä»¥ï¼Œä¸Šä¸Šå‘¨æŠ½ç©ºåŽ»å›¾ä¹¦é¦†å€Ÿäº†ä¸¤æœ¬ä¹¦ï¼šã€Šè¥¿è¥¿å¼—ç¥žè¯ã€‹å’Œã€Šæ¯›æ³½ä¸œé€‰é›†1ã€‹ï¼ŒæŽ¥è§¦ä¸€ä¸‹å…¶ä»–çš„æ€è€ƒã€‚ è¿˜æœ‰ï¼Œä¸Šä¸ªæœˆåœ¨ç»ƒä¹ çš„é£Žä¹‹è¯—ï¼Œå·²ç»å¾ˆç†Ÿäº†ï¼Œä½†è¿žç»­ä¸‰ä¸‹æ»‘å¼¦çš„åœ°æ–¹è¿˜æ˜¯æ²¡ç»ƒå¥½ï¼Œè¿˜éœ€è¦è¿›ä¸€æ­¥ç»ƒä¹ å‘¢ï¼Œå…¶ä»–åœ°æ–¹éƒ½æ²¡æœ‰ä»€ä¹ˆå¤ªå¤§çš„é—®é¢˜äº†ï¼Œè°±å­ä¹Ÿå¾ˆç†Ÿæ‚‰äº†ï¼Œå¯ä»¥å¼€å§‹ç»ƒä¹ å…¶ä»–çš„ä¸œè¥¿äº†ï¼Œæƒ³ç€æ˜¯ä¸æ˜¯è¯¥ç»ƒä¹ ä¸€äº›æ­Œæ›²ï¼Œç ”ç©¶ä¸€ä¸‹å¼¹å”±è°±ä¸­çš„å’Œå¼¦ã€ä¹ç†äº†å‘¢ï¼Ÿæ¯•ç«Ÿï¼Œæ„Ÿè§‰æœ€è¿‘ç»ƒç´çš„æ—¶é—´çœŸçš„å¾ˆå°‘ï¼Œè€Œä¸”æ²¡æœ‰æ€Žä¹ˆæ€è€ƒï¼Œéƒ½æ˜¯ç®€å•çš„ç»ƒæ‰‹ä¸ŠåŠŸå¤«ã€‚ PSï¼šä¸Šä¸ªæœˆä¸¢æŽ‰çš„é—¨ç¦å¡ï¼Œåˆè¢«æˆ‘æ¡äº†ä¸€å¼ ðŸ¤£ PPSï¼šä¸€å¬åˆ° AC/DC å°±æƒ³åˆ°äº†åŽ»å¹´åœ¨é©¬è·¯ä¸Šæºœå†°çš„æ—¶å€™ðŸ˜†]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[printf å‡½æ•°çš„ä¸€äº›ç»†èŠ‚]]></title>
    <url>%2F2023%2F05%2F18%2Fprintf-%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%2F</url>
    <content type="text"><![CDATA[ä¸€é“å®¹æ˜“çŠ¯æ€ç»´æƒ¯æ€§é”™è¯¯çš„ C è¯­è¨€é¢˜ç›®... å¤§æ¦‚ä¸€ä¸ªæœˆä¹‹å‰ï¼Œçœ‹è§ä¸€é“æœ‰è¶£çš„ C è¯­è¨€é¢˜ç›®ï¼Œé¢˜ç›®çš„å½¢å¼å¾ˆç®€å•ï¼Œä»£ç éƒ¨åˆ†ä¹Ÿæ¯”è¾ƒå®¹æ˜“ç†è§£ï¼Œå¤§è‡´å¦‚ä¸‹ï¼štest11234567#include &lt;stdio.h&gt;int main() &#123; unsigned int a = 16; printf("%d %d %d\n", a &gt;&gt; 2, a = a &gt;&gt; 2, a); return 0;&#125; çŽ°åœ¨ï¼Œé—®è¾“å‡ºçš„å€¼å„æ˜¯å¤šå°‘ã€‚å½“æ—¶ï¼Œç®€å•æ€è€ƒäº†ä¸€ä¸‹ï¼Œå°±ç»™å‡ºäº†4 1 1çš„ç­”æ¡ˆã€‚åŽæ¥ï¼Œè‡ªå·±æ¨¡æ‹Ÿäº†ä¸€ä¸‹ï¼Œå¾—åˆ°çš„ç»“æžœç«Ÿç„¶æ˜¯1 4 4ã€‚è„‘å­ä¸­ç«‹é©¬ååº”è¿‡æ¥ï¼Œè¿™æ˜¯ C è¯­è¨€ä¸­çš„æœªå®šä¹‰è¡Œä¸ºï¼ˆUndefined behaviorï¼Œç®€ç§° UB è¡Œä¸ºðŸ˜‚ï¼‰ï¼Œä½†æ˜¯ä¸€æ˜¯åŠä¼šæžä¸æ˜Žç™½ä¸ºå•¥ä¼šå¾—åˆ°è¿™æ ·çš„ç»“æžœã€‚æŸ¥é˜…äº†ä¸€äº›èµ„æ–™åŽï¼Œå‘çŽ°printfå‡½æ•°çš„æ‰§è¡Œè¿‡ç¨‹æœ‰ä¸€ä¸ªå…¥æ ˆå‡ºæ ˆçš„è¿‡ç¨‹ï¼Œå…·ä½“è€Œè¨€ï¼š printfå‡½æ•°çš„å‚æ•°æ˜¯ä»ŽåŽå¾€å‰ä¾æ¬¡å…¥æ ˆçš„ï¼Œè¿™æ ·å‡ºæ ˆæ—¶å°±æ˜¯ä»Žå‰å¾€åŽä¾æ¬¡è¾“å‡ºçš„äº† åœ¨å…¥æ ˆçš„è¿‡ç¨‹ä¸­ï¼Œè¡¨è¾¾å¼å·²ç»æ‰§è¡Œäº†ï¼Œæœ€åŽæ ˆå†…å­˜å‚¨çš„â€œä¸œè¥¿â€å¤§æ¦‚çŽ‡æ˜¯æŸä¸ªå˜é‡çš„åœ°å€ï¼ˆæ³¨æ„ï¼Œè¿™é‡Œæ²¡æœ‰æ·±ç©¶ï¼‰ æŒ‰ç…§ä¸Šé¢çš„è§„åˆ™ï¼Œå¯ä»¥åˆ†æžå‡ºä¸ºä½•ä¸Šé¢çš„ä»£ç ä¼šå¾—å‡º1 4 4çš„ç»“æžœï¼š1234561. åŽ‹ a çš„åœ°å€å…¥æ ˆ2. a = a &gt;&gt; 2ï¼Œè¡¨è¾¾å¼çš„å€¼ä¸º a æ­¤æ—¶çš„å€¼ï¼Œå³ 4ï¼Œå…¥æ ˆ3. è¡¨è¾¾å¼çš„å€¼ä¸º a &gt;&gt; 2 çš„å€¼ 1ï¼Œå…¥æ ˆ4. å‡ºæ ˆï¼Œè§£æžä¸º 15. å‡ºæ ˆï¼Œè§£æžä¸º 46. å‡ºæ ˆï¼Œè§£æžä¸º 4 æœ‰äº†ä¸Šé¢çš„åˆ†æžï¼Œå¯¹ç»“æžœçš„ç”±æ¥å°±ä¸å†é™Œç”Ÿäº†ã€‚ä½†è¿™é‡Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæœ€åŽè¾“å‡ºç»“æžœä¸­ç¬¬äºŒä¸ªå‚æ•°çš„å€¼4å¹¶ä¸èƒ½ä½è¯æ ˆå†…å­˜å‚¨çš„â€œä¸œè¥¿â€å¤§æ¦‚çŽ‡æ˜¯æŸä¸ªå˜é‡çš„åœ°å€è¿™ä¸ªè§‚ç‚¹ã€‚å®žé™…ä¸Šï¼Œå¯ä»¥é€šè¿‡å¦å¤–ä¸€ä¸ªç®€å•çš„ä¾‹å­æ¥éªŒè¯ä¸€ä¸‹çŒœæƒ³ï¼štest212345678#include &lt;stdio.h&gt;int main() &#123; int b; printf("%d %d %d\n", b = 3, b = 2, b = 1); printf("%d\n", b); return 0;&#125; å¦‚æžœæ ˆå†…å­˜å‚¨çš„æ˜¯è¡¨è¾¾å¼çš„å€¼ï¼Œé‚£ä¹ˆæœ€åŽè¾“å‡ºçš„ç»“æžœåº”è¯¥æ˜¯ï¼š123 2 13 ä½†å®žé™…ä¸Šå´æ˜¯ï¼š123 3 33 æŒ‰ç…§ä»ŽåŽå¾€å‰å…¥æ ˆå¹¶æ‰§è¡Œçš„è§„åˆ™ï¼Œå˜é‡bä¸€å…±è¢«èµ‹å€¼äº† 3 æ¬¡ï¼Œä½†ç»“æžœä»¥æœ€åŽä¸€æ¬¡ä¸ºå‡†ï¼Œä¹Ÿå³b = 3ã€‚ä½†æ­¤æ—¶åˆä¼šæœ‰ä¸€ä¸ªæ–°çš„é—®é¢˜äº§ç”Ÿï¼Œé‚£å°±æ˜¯ç©¶ç«Ÿæ˜¯printfå‡½æ•°çš„å‚æ•°åˆ—è¡¨å…¥æ ˆåŽä¿å­˜çš„æ˜¯å˜é‡çš„åœ°å€ï¼Œè¿˜æ˜¯èµ‹å€¼è¡¨è¾¾å¼æœ¬èº«çš„è¿”å›žç»“æžœæ˜¯ä¸€ä¸ªåœ°å€å‘¢ï¼Ÿ å“ˆå“ˆï¼Œæƒ³è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œåº”è¯¥æœ‰ä¸‰ä¸ªæ–¹æ³•ï¼š ä»”ç»†çœ‹çœ‹printfå‡½æ•°çš„æºç ï¼Œç ”ç©¶ä¸€ä¸‹å…·ä½“æ˜¯å¦‚ä½•å®žçŽ°çš„ ç›´æŽ¥ç¼–è¯‘æˆæ±‡ç¼–ï¼Œçœ‹çœ‹æ±‡ç¼–ä»£ç æ˜¯æ€Žä¹ˆå†™çš„ï¼ˆè¿™éœ€è¦ä¸€å®šçš„æ±‡ç¼–åŸºç¡€ï¼‰ å€ŸåŠ©ä¸€äº›è°ƒè¯•å·¥å…·ï¼Œçœ‹çœ‹æ ˆä¸Šçš„åœ°å€æ˜¯å¦‚ä½•å˜åŒ–çš„ åœ¨è¿™é‡Œå°±ä¸å†æ·±ç©¶äº†ï¼Œä¸ºå•¥ï¼Ÿå› ä¸ºæ·±ç©¶è¿™äº› UB è¡Œä¸ºæ²¡æœ‰å¤ªå¤§çš„æ„ä¹‰ðŸ˜„ï¼Œä¹‹æ‰€ä»¥è¿™ä¹ˆè¯´ï¼Œæ˜¯å› ä¸ºä¸åŒç¼–è¯‘å™¨çš„å…·ä½“å®žçŽ°ä¸åŒï¼Œè¿™å°±å¯¼è‡´ç›¸åŒå½¢å¼çš„æœªå®šä¹‰è¡Œä¸ºåœ¨ä¸åŒç¼–è¯‘å™¨ä¸‹ç¼–è¯‘åŽäº§ç”Ÿçš„ç»“æžœå¯èƒ½ä¹Ÿä¸ç›¸åŒðŸ˜‚ã€‚å½“ç„¶äº†ï¼Œé˜…è¯»ä¸€ä¸‹æºç ï¼Œå­¦ä¹ ä¸€ä¸‹æ±‡ç¼–æˆ–è€…ç ”ç©¶ä¸€ä¸‹å¦‚ä½•ä½¿ç”¨è°ƒè¯•å·¥å…·éƒ½æ˜¯å¾ˆå¥½çš„ï¼Œè¿™äº›å°±ç•™åˆ°ä¸‹æ¬¡å†è¯´å§...PSï¼šä¸»è¦æ˜¯ä¸‹æ¬¡åˆå¯ä»¥æ°´æ–‡äº†ï¼Œå˜»å˜»~ðŸ˜]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_06]]></title>
    <url>%2F2023%2F05%2F05%2FNand2Tetris-Part1-06%2F</url>
    <content type="text"><![CDATA[å¥½å‡ å¹´äº†ï¼Œä¸Šå†Œç»ˆäºŽè¦å­¦å®Œäº†ðŸ¤£...æœ€åŽä¸€å‘¨çš„å†…å®¹ä¸Žæ±‡ç¼–è§£é‡Šå™¨æœ‰å…³ã€‚å› ä¸ºè¿™ä¸€å‘¨åœ¨è¯¾å ‚ä¸Šç”¨ iPad åšäº†ç¬”è®°ï¼Œæ‰€ä»¥æ¯ä¸€èŠ‚çš„å†…å®¹ç›´æŽ¥ç”¨è¯¾å ‚ä¸Šçš„ç¬”è®°ï¼Œç„¶åŽçœ‹æƒ…å†µå†å¢žåŠ æˆ–ä¿®æ”¹ä¸€ç‚¹å†…å®¹å§ã€‚ Unit 6.1 Assembly Languages and AssemblersWeek Target: use a Assembler translate Assembly Language to binary code.Basic Concept: The â€œAssemblerâ€ is software First software layer above the hardware Basic Logic: Read the next Assembly language command Break it into the different fields it is composed of Lookup the binary code for each field Combine these codes into a single machine language command Output this machine language command example1234567891011121314151. Load R1, 18 &lt;- char array == strings ðŸ‘‡2. load R1 18 v s t &lt;- 3 strings ðŸ‘‡3. Command Table &lt;- use a table to translate the command into machine language directly Load 11001 R1 01 18 000010010 ... ... ðŸ‘‡4. Combination, sometime need to add other bits to it. Load + R1 + 18 = 1100101000010010 ðŸ‘‡5. Output About Symbols: Assembler must replace names with address by using a Symbols-Address Table like Command Table. Unit 6.2 The Hack Assembly Language: A Translatorâ€™s PerspectiveHack language specification: A-instructionSymbolic syntax: @valueBinary syntax: 0valueInBinaryExample: @21 == 0000000000010101 C-instructionSymbolic syntax: dest=comp;jumpBinary syntax: 111 ac1c2c3c4c5c6 d1d2d3 j1j2j3 Pre-defined symbolsR0, R1, R2...(refer to the book for more information) Assembly program elements: White space(Ignore it, we donâ€™t need to care âœ…) Empty lines / indentation Line comments In-line comments Instructions A-instructions C-instructions Symbols (â­â­â­ Challenges) References Label declaration The plan ahead: Develop a basic assembler that translate symbol-less Hack programs(next unit) Develop an ability to handle symbols(nexxt unit) Morph the basic assembler into an assembler that translate any Hack program(nexxxt unit) Unit 6.3 The Assembly Process: Handling Instructions Translating A-instructions 2 situations121. If value is a decimal constant, generate the equivalent 15-bit binary constant2. If value is a symbol, later Translating C-instructions example12345678MD=D+1 ðŸ‘‡dst = MD, comp = D+1, jmp = null ðŸ‘‡dst = 011, comp = 1011111, jmp = 000, C-flag = 111 ðŸ‘‡C-flag + comp + dst + jmp111 1011111 011 000 The overall assembly logic Unit 6.4 The Assembly Process: Handling SymbolsSymbols: Pre-defined symbols, Label symbols, Variable symbols. Pre-defined symbolsPre-defined symbols represent special memory locations. @pre-defined symbols = @value, itâ€™s A-instructions. Label symbolsLabel symbols represent destinations of goto instructions.3 steps: Used to label destinations of goto commands Declared by the pseudo-command: (xxx), and no need to translate, just ignore it. This directive defines the symbols xxx to refer to the memory location holding the next instruction in the program, like that:example1234Symbol Value LOOP 4 STOP 18 END 22 So, translate the label symbol:@lableSymbol = @value, and here the value is just a line number. Variable symbolsVariable symbols represent memory location where the programmer wants to maintain values. Thereâ€™s a little hard to translate it. First of all, any symbol xxx appearing in an assembly program which isnot pre-defined and is not defined elsewhere using the (xxx) directive is treated as a variable. Secondly, each variable is assigned a unique memory address, starting at 16(not a arbitrary number ðŸ‘€). So, translate variable symbols by 2 steps: If you see it for the first time, assign a unique memory address. Replace variable symbols with itâ€™s value. And in order to get this value, we search the value by a Symbol Table. Now, how do we get the Symbol Table?3 steps: Initialization: Add the pre-defined symbols First pass: Add the label symbols Second pass: Add the variable symbols Unit 6.5 Developing a Hack Assembler: Proposed Software ArchitectureSub-tasks that need to be done:Task 1Task 2Task 3Reading and parsing commandsSteps:a. Start reading a file with a given nameb. Move to the next command in the filec. Get the fields of current commandTips: No need to understand the meaning of anything.Converting mnemonics -&gt; codeUse the API provided by Java/C++/Python string class to parse the instructions.Tips: No need to worry about the mnemonic fields were obtained.Handling symbolsUse the Use the Symbol Table that we have mentioned eariler translate symbols.Tips: No need to worry about what these symbols mean.Over logic: Initialization: Parser and Symbol Table First Pass: Read all commands, only paying attention to labels and updating the symbol table Second Pass: Restart reading and translating commands Main Loop: Get the next Assembly Language Command and parse it For A-Commands: Translate symbols to binary addresses For C-Commands: get code for each part and put them together Output the resulting machine language command Unit 6.6 Project 6 Overview(Programming Option)Proposed design: Parser Code Symbol Table Main Proposed Implementation: Staged development Develop a basic assembler that translate assembly programs without symbols Develop an ability to handle symbols Morph the basic assembler into an assembler that can translate any assembly program Supplied 2 types of test programs1234Add.asmMax.asm MaxL.asmRectangle.asm RectangleL.asmPong.asm PongL.asm Unit 6.6 Project 6 Overview(without Programming)Translating *.asm program manuallyâœ, and it will be a boring process.So, it would be better to solve this problem by programming. Unit 6.7 ProjectAs mentioned earlier, we can use Java, C++ or Python implement assembler. And here I use C++ to complete the project. I also get some template files about this project, so I just need to complete the methods that implement these classes.ðŸŽˆ Here are the files that have been implemented(can handle A/C instructions and symbols):Assembler.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#ifndef ASSEMBLER_H#define ASSEMBLER_H#include &lt;string&gt;#include "SymbolTable.h"using namespace std;class Assembler &#123; public: /** Instruction types */ enum InstructionType &#123; A_INSTRUCTION, C_INSTRUCTION, L_INSTRUCTION, NULL_INSTRUCTION &#125;; /** C-instruction destinations */ enum InstructionDest &#123; A, D, M, AM, AD, MD, AMD, NULL_DEST &#125;; /** C-instruction jump conditions */ enum InstructionJump &#123; JLT, JGT, JEQ, JLE, JGE, JNE, JMP, NULL_JUMP &#125;; /** C-instruction computations/op-codes */ enum InstructionComp &#123; CONST_0, CONST_1, CONST_NEG_1, VAL_A, VAL_M, VAL_D, NOT_A, NOT_M, NOT_D, NEG_A, NEG_M, NEG_D, A_ADD_1, M_ADD_1, D_ADD_1, A_SUB_1, M_SUB_1, D_SUB_1, D_ADD_A, D_ADD_M, D_SUB_A, D_SUB_M, A_SUB_D, M_SUB_D, D_AND_A, D_AND_M, D_OR_A, D_OR_M, NULL_COMP &#125;; static uint16_t variableSymbolCount; /** Practical Assignment 5 methods */ Assembler(); ~Assembler(); void buildSymbolTable(SymbolTable* symbolTable, string instructions[], int numOfInst); string generateMachineCode(SymbolTable* symbolTable, string instructions[], int numOfInst); InstructionType parseInstructionType(string instruction); InstructionDest parseInstructionDest(string instruction); InstructionJump parseInstructionJump(string instruction); InstructionComp parseInstructionComp(string instruction); string parseSymbol(string instruction); string translateDest(InstructionDest dest); string translateJump(InstructionJump jump); string translateComp(InstructionComp comp); string translateSymbol(string symbol, SymbolTable* symbolTable);&#125;;#endif /* ASSEMBLER_H */ Assembler.cpp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include "Assembler.h"#include "SymbolTable.h"#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;uint16_t Assembler::variableSymbolCount = 16;/** * Assembler constructor */Assembler::Assembler() &#123; // Your code here&#125;/** * Assembler destructor */Assembler::~Assembler() &#123; // Your code here&#125;/** * Assembler first pass; populates symbol table with label locations. * @param instructions An array of the assembly language instructions. * @param symbolTable The symbol table to populate. */void Assembler::buildSymbolTable(SymbolTable* symbolTable, string instructions[], int numOfInst) &#123; // Your code here uint16_t lineNumber = 0; for(int i = 0; i &lt; numOfInst; i++) &#123; if(instructions[i][0] == '(') &#123; string t = instructions[i].substr(1, instructions[i].size() - 2); symbolTable-&gt;addSymbol(t, lineNumber); &#125; else &#123; lineNumber++; &#125; &#125;&#125;/** * Assembler second pass; Translates a set of instructions to machine code. * @param instructions An array of the assembly language instructions to be converted to machine code. * @param symbolTable The symbol table to reference/update. * @return A string containing the generated machine code as lines of 16-bit binary instructions. */string Assembler::generateMachineCode(SymbolTable* symbolTable, string instructions[], int numOfInst) &#123; // Your code here // Only process A and C instructions string ret = ""; for(int i = 0; i &lt; numOfInst; i++) &#123; InstructionType t = parseInstructionType(instructions[i]); if(t == A_INSTRUCTION || t == L_INSTRUCTION) &#123; ret = ret + '0' + translateSymbol(parseSymbol(instructions[i]), symbolTable); &#125; else if(t == C_INSTRUCTION) &#123; ret += "111"; // C instructions prefix ret = ret + translateComp(parseInstructionComp(instructions[i])); ret = ret + translateDest(parseInstructionDest(instructions[i])); ret = ret + translateJump(parseInstructionJump(instructions[i])); &#125; &#125; return ret;&#125;/** * Parses the type of the provided instruction * @param instruction The assembly language representation of an instruction. * @return The type of the instruction (A_INSTRUCTION, C_INSTRUCTION, L_INSTRUCTION, NULL) */Assembler::InstructionType Assembler::parseInstructionType(string instruction) &#123; // Your code here: if(instruction[0] == '@' &amp;&amp; ('0' &lt;= instruction[1] &amp;&amp; instruction[1] &lt;= '9')) return A_INSTRUCTION; else if(instruction[0] == '@' &amp;&amp; !('0' &lt;= instruction[1] &amp;&amp; instruction[1] &lt;= '9')) return L_INSTRUCTION; else if(instruction[0] =='(') return NULL_INSTRUCTION; else return C_INSTRUCTION;&#125;/** * Parses the destination of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The destination of the instruction (A, D, M, AM, AD, MD, AMD, NULL) */Assembler::InstructionDest Assembler::parseInstructionDest(string instruction) &#123; // Your code here: InstructionDest ret = NULL_DEST; string::size_type idx = instruction.find("="); if(idx == string::npos) return ret; string dest = instruction.substr(0, idx); if(dest == "A") ret = A; else if(dest == "D") ret = D; else if(dest == "M") ret = M; else if(dest == "AM") ret = AM; else if(dest == "AD") ret = AD; else if(dest == "MD") ret = MD; else if(dest == "AMD") ret = AMD; return ret;&#125;/** * Parses the jump condition of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The jump condition for the instruction (JLT, JGT, JEQ, JLE, JGE, JNE, JMP, NULL) */Assembler::InstructionJump Assembler::parseInstructionJump(string instruction) &#123; // Your code here: // for example if "JLT" appear at the comp field return enum label JLT if (instruction.find("JLT") != string::npos) &#123; return JLT; &#125; else if(instruction.find("JGT") != string::npos) &#123; return JGT; &#125; else if(instruction.find("JEQ") != string::npos) &#123; return JEQ; &#125; else if(instruction.find("JLE") != string::npos) &#123; return JLE; &#125; else if(instruction.find("JGE") != string::npos) &#123; return JGE; &#125; else if(instruction.find("JNE") != string::npos) &#123; return JNE; &#125; else if(instruction.find("JMP") != string::npos) &#123; return JMP; &#125; return NULL_JUMP;&#125;/** * Parses the computation/op-code of the provided C-instruction * @param instruction The assembly language representation of a C-instruction. * @return The computation/op-code of the instruction (CONST_0, ... ,D_ADD_A , ... , NULL) */Assembler::InstructionComp Assembler::parseInstructionComp(string instruction) &#123; // Your code here: // for example if "0" appear at the comp field return CONST_0 InstructionComp ret; string::size_type idx1 = instruction.find("="); string::size_type idx2 = instruction.find(";"); string comp; if(idx1 != string::npos &amp;&amp; idx2 != string::npos) &#123; comp = instruction.substr(idx1 + 1, idx2); &#125; else if(idx1 == string::npos &amp;&amp; idx2 != string::npos) &#123; comp = instruction.substr(0, idx2); &#125; else if(idx1 != string::npos &amp;&amp; idx2 == string::npos) &#123; comp = instruction.substr(idx1 + 1, instruction.length()); &#125; else &#123; comp = instruction; &#125; if ("0" == comp) &#123; ret = CONST_0; &#125; else if("1" == comp) &#123; ret = CONST_1; &#125; else if("-1" == comp) &#123; ret = CONST_NEG_1; &#125; else if("A" == comp) &#123; ret = VAL_A; &#125; else if("M" == comp) &#123; ret = VAL_M; &#125; else if("D" == comp) &#123; ret = VAL_D; &#125; else if("!A" == comp) &#123; ret = NOT_A; &#125; else if("!M" == comp) &#123; ret = NOT_M; &#125; else if("!D" == comp) &#123; ret = NOT_D; &#125; else if("-A" == comp) &#123; ret = NEG_A; &#125; else if("-M" == comp) &#123; ret = NEG_M; &#125; else if("-D" == comp) &#123; ret = NEG_D; &#125; else if("A+1" == comp) &#123; ret = A_ADD_1; &#125; else if("M+1" == comp) &#123; ret = M_ADD_1; &#125; else if("D+1" == comp) &#123; ret = D_ADD_1; &#125; else if("A-1" == comp) &#123; ret = A_SUB_1; &#125; else if("M-1" == comp) &#123; ret = M_SUB_1; &#125; else if("D-1" == comp) &#123; ret = D_SUB_1; &#125; else if("D+A" == comp) &#123; ret = D_ADD_A; &#125; else if("D+M" == comp) &#123; ret = D_ADD_M; &#125; else if("D-A" == comp) &#123; ret = D_SUB_A; &#125; else if("D-M" == comp) &#123; ret = D_SUB_M; &#125; else if("A-D" == comp) &#123; ret = A_SUB_D; &#125; else if("M-D" == comp) &#123; ret = M_SUB_D; &#125; else if("D&amp;A" == comp) &#123; ret = D_AND_A; &#125; else if("D&amp;M" == comp) &#123; ret = D_AND_M; &#125; else if("D|A" == comp) &#123; ret = D_OR_A; &#125; else if("D|M" == comp) &#123; ret = D_OR_M; &#125; return ret;&#125;/** * Parses the symbol of the provided A/L-instruction * @param instruction The assembly language representation of a A/L-instruction. * @return A string containing either a label name (L-instruction), * a variable name (A-instruction), or a constant integer value (A-instruction) */string Assembler::parseSymbol(string instruction) &#123; // Your code here: return instruction.substr(1);&#125;/** * Generates the binary bits of the dest part of a C-instruction * @param dest The destination of the instruction * @return A string containing the 3 binary dest bits that correspond to the given dest value. */string Assembler::translateDest(InstructionDest dest) &#123; // Your code here: string ret; switch(dest) &#123; case A: ret = "100"; break; case D: ret = "010"; break; case M: ret = "001"; break; case AM: ret = "101"; break; case AD: ret = "110"; break; case MD: ret = "011"; break; case AMD: ret = "111"; break; case NULL_DEST: ret = "000"; break; default: break; &#125; return ret;&#125;/** * Generates the binary bits of the jump part of a C-instruction * @param jump The jump condition for the instruction * @return A string containing the 3 binary jump bits that correspond to the given jump value. */string Assembler::translateJump(InstructionJump jump) &#123; // Your code here: string ret; switch(jump) &#123; case JLT: ret = "100"; break; case JGT: ret = "001"; break; case JEQ: ret = "010"; break; case JLE: ret = "110"; break; case JGE: ret = "011"; break; case JNE: ret = "101"; break; case JMP: ret = "111"; break; case NULL_JUMP: ret = "000"; break; default: break; &#125; return ret;&#125;/** * Generates the binary bits of the computation/op-code part of a C-instruction * @param comp The computation/op-code for the instruction * @return A string containing the 7 binary computation/op-code bits that correspond to the given comp value. */string Assembler::translateComp(InstructionComp comp) &#123; // Your code here: string ret; if (CONST_0 == comp) &#123; ret = "0101010"; &#125; else if(CONST_1 == comp) &#123; ret = "0111111"; &#125; else if(CONST_NEG_1 == comp) &#123; ret = "0111010"; &#125; else if(VAL_A == comp) &#123; ret = "0110000"; &#125; else if(VAL_M == comp) &#123; ret = "1110000"; &#125; else if(VAL_D == comp) &#123; ret = "0001100"; &#125; else if(NOT_A == comp) &#123; ret = "0110001"; &#125; else if(NOT_M == comp) &#123; ret = "1110001"; &#125; else if(NOT_D == comp) &#123; ret = "0001101"; &#125; else if(NEG_A == comp) &#123; ret = "0110011"; &#125; else if(NEG_M == comp) &#123; ret = "1110011"; &#125; else if(NEG_D == comp) &#123; ret = "0001111"; &#125; else if(A_ADD_1 == comp) &#123; ret = "0110111"; &#125; else if(M_ADD_1 == comp) &#123; ret = "1110111"; &#125; else if(D_ADD_1 == comp) &#123; ret = "0011111"; &#125; else if(A_SUB_1 == comp) &#123; ret = "0110010"; &#125; else if(M_SUB_1 == comp) &#123; ret = "1110010"; &#125; else if(D_SUB_1 == comp) &#123; ret = "0001110"; &#125; else if(D_ADD_A == comp) &#123; ret = "0000010"; &#125; else if(D_ADD_M == comp) &#123; ret = "1000010"; &#125; else if(D_SUB_A == comp) &#123; ret = "0010011"; &#125; else if(D_SUB_M == comp) &#123; ret = "1010011"; &#125; else if(A_SUB_D == comp) &#123; ret = "0000111"; &#125; else if(M_SUB_D == comp) &#123; ret = "1000111"; &#125; else if(D_AND_A == comp) &#123; ret = "0000000"; &#125; else if(D_AND_M == comp) &#123; ret = "1000000"; &#125; else if(D_OR_A == comp) &#123; ret = "0010101"; &#125; else if(D_OR_M == comp) &#123; ret = "1010101"; &#125; return ret;&#125;/** * Generates the binary bits for an A-instruction, parsing the value, or looking up the symbol name. * @param symbol A string containing either a label name, a variable name, or a constant integer value * @param symbolTable The symbol table for looking up label/variable names * @return A string containing the 15 binary bits that correspond to the given sybmol. */string Assembler::translateSymbol(string symbol, SymbolTable* symbolTable) &#123; // Your code here: uint16_t n; if(!('0' &lt;= symbol[0] &amp;&amp; symbol[0] &lt;= '9')) &#123; if(symbolTable-&gt;getSymbol(symbol) == -1) &#123; n = variableSymbolCount; symbolTable-&gt;addSymbol(symbol, variableSymbolCount); variableSymbolCount++; &#125; else &#123; n = symbolTable-&gt;getSymbol(symbol); &#125; &#125; else &#123; n = stoi(symbol); &#125; string binNum = ""; for(int i = 0; i &lt; 15; i++) &#123; if(n &amp; 1) binNum += '1'; else binNum += '0'; n &gt;&gt;= 1; &#125; reverse(binNum.begin(), binNum.end()); return binNum;&#125; SymbolTable.h1234567891011121314151617181920#ifndef SYMBOL_TABLE_H#define SYMBOL_TABLE_H#include &lt;cstdint&gt; // this contains uint16_t#include &lt;map&gt; // indexable dictionary#include &lt;string&gt; // process c++ stringusing namespace std;class SymbolTable &#123; public: map&lt;string, uint16_t&gt; hashMap; SymbolTable(); ~SymbolTable(); void addSymbol(string symbol, uint16_t value); int getSymbol(string symbol);&#125;;#endif /* SYMBOL_TABLE_H */ SymbolTable.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "SymbolTable.h"#include &lt;string&gt;/** * Symbol Table constructor */SymbolTable::SymbolTable() &#123; // add pre-defined symbols hashMap["R0"] = 0; hashMap["R1"] = 1; hashMap["R2"] = 2; hashMap["R3"] = 3; hashMap["R4"] = 4; hashMap["R5"] = 5; hashMap["R6"] = 6; hashMap["R7"] = 7; hashMap["R8"] = 8; hashMap["R9"] = 9; hashMap["R10"] = 10; hashMap["R11"] = 11; hashMap["R12"] = 12; hashMap["R13"] = 13; hashMap["R14"] = 14; hashMap["R15"] = 15; hashMap["SCREEN"] = 16384; hashMap["KBD"] = 24576; hashMap["SP"] = 0; hashMap["LCL"] = 1; hashMap["ARG"] = 2; hashMap["THIS"] = 3; hashMap["THAT"] = 4;&#125;/** * Symbol Table destructor */SymbolTable::~SymbolTable() &#123;&#125;/** * Adds a symbol to the symbol table * @param symbol The name of the symbol * @param value The address for the symbol */void SymbolTable::addSymbol(string symbol, uint16_t value) &#123; // Your code here hashMap[symbol] = value;&#125;/** * Gets a symbol from the symbol table * @param symbol The name of the symbol * @return The address for the symbol or -1 if the symbol isn't in the table */int SymbolTable::getSymbol(string symbol) &#123; // Your code here if(hashMap.find(symbol) != hashMap.end()) return hashMap[symbol]; return -1;&#125; Main.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;fstream&gt;#include &lt;iostream&gt;#include &lt;regex&gt;#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include "Assembler.h"#include "SymbolTable.h"using namespace std;int main(int argc, char** argv) &#123; if (argc &gt; 1) &#123; SymbolTable symbolTable; Assembler assembler; vector&lt;string&gt; instructionList; // Open file fstream file; string fname = argv[1]; file.open(argv[1], ios::in); if (file.is_open()) &#123; // Read line-by-line string line; while (getline(file, line)) &#123; /* remove comments */ string::size_type idx = line.find("//"); // find start of "//" string lineRmComm = line.substr(0, idx); if (lineRmComm.size() == 0) continue; // skip empty line /* remove spaces */ string::iterator str_iter = remove(lineRmComm.begin(), lineRmComm.end(), ' '); lineRmComm.erase(str_iter, lineRmComm.end()); instructionList.push_back(lineRmComm); &#125; file.close(); &#125; // Get array of instructions string instructions[instructionList.size()]; copy(instructionList.begin(), instructionList.end(), instructions); // First pass assembler.buildSymbolTable(&amp;symbolTable, instructions, instructionList.size()); // Second pass string code = assembler.generateMachineCode(&amp;symbolTable, instructions, instructionList.size()); // Print output cout &lt;&lt; code &lt;&lt; endl; &#125;&#125; Unit 6.8 PerspectivesThree questions in this week: Can you possibly improve the symbolic Hack language without changing the binary code or the machine language which is underlying the symbolic level? We have 2 layers of expression here: symbolic level and binary code. We can take symbolic level, and make it more user-friendly or more programmer-friendly. For example, D=M[100] can be translated to @100 and D=M. Will I ever have to use an assembler outside school? Vvvvvery rarely. How was the first assembler actually written? First, simply had to complie something by hand. You write an assembler in a high-level language and translate it by hand for the first time only into a machine language of your computer. Once youâ€™ll finish this translation, which is extremely time-consuming, extremely annoying to do, but only needs to be done once conceptually.Then you already have a machine language that runs your compiler or your assembler or any high-level help that you want.]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_04_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F05%2F04%2F2023-04-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[äº”ä¸€å‡æœŸè¿‡çš„çœŸå¿«å•ŠðŸ˜ª~ é¢¨ã®è©© - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼Your browser does not support the audio tag. æœ¬æ¥è¿™ç¯‡æ€»ç»“åº”è¯¥åœ¨äº”ä¸€å‡æœŸæœŸé—´ï¼ˆä¹Ÿå°±æ˜¯å››æœˆçš„æœ€åŽå‡ å¤©ï¼‰å†™å¥½çš„ï¼Œä½†æ˜¯äº”ä¸€æœŸé—´ï¼Œå› ä¸ºåœ¨çˆ†è‚ Nand2tetris å’Œå‡ é“ç®—æ³•å¡«ç©ºé¢˜ï¼Œæ‰€ä»¥è€½æäº†ã€‚å…ˆè¯´è¯´å·¥ä½œçš„äº‹æƒ…ï¼Œå››æœˆä»½æ²¡æœ‰æŠ•äº§ï¼Œå¾ˆèˆ’æœ~ä½†è¿™ä¸ªæœˆé…åˆæµ‹è¯•çš„å•å­å¤ªå¤šäº†ï¼Œå„ç§é…åˆæµ‹è¯•çš„ä»»åŠ¡ï¼Œè¿˜æœ‰ä¸€äº›è®©äººå¾ˆçƒ¦èºçš„å·¥å•...ä¸è¿‡æ€»çš„è¯´æ¥ï¼Œè¿˜ç®—æ˜¯åº¦è¿‡çš„æ¯”è¾ƒå¹³ç¨³ï¼Œå°½ç®¡è‡ªå·±è¿˜æ˜¯æœ‰å¾ˆå¤šä¸è¶³çš„åœ°æ–¹ã€‚å››æœˆåº•åšäº†ä¸€ä¸ªå•å­ï¼Œæ˜¯ä¸Žå‰ç«¯ç›¸å…³çš„å•å­ï¼Œè¿™ä¸ªå•å­ä¹Ÿè€—è´¹äº†è‡ªå·±å¾ˆå¤šåŠŸå¤«ï¼Œå®žé™…çš„æ”¹åŠ¨å´å°‘çš„å¾ˆã€‚åœ¨å¼€å‘è¿™ä¸ªä»»åŠ¡çš„è¿‡ç¨‹ä¸­ï¼Œåªæœ‰ä¸€ä¸ªæ„Ÿè§‰ï¼šå‰ç«¯çœŸçš„å¥½æ— èŠå•Š...ðŸ¤£å¦å¤–ï¼Œåˆ°äº†æœˆåº•çš„æ—¶å€™ï¼Œçªç„¶ä¸€ä¸‹å­åˆæ¥äº†ä¸¤ä¸ªå…¶ä»–çš„å¼€å‘ä»»åŠ¡ï¼Œå¯ä»¥é¢„æ–™åˆ°èŠ‚åŽå¾ˆå¿™ã€‚ç»“æžœä»Šå¤©åŽ»ä¸Šç­ï¼Œç«Ÿç„¶åˆæ¥äº†ä¸€ä¸ªå¼€å‘ä»»åŠ¡ï¼Œè¿™æ ·ç®—ä¸‹æ¥ï¼ŒèŠ‚åŽçš„å‰å‡ å¤©éœ€è¦è§£å†³ä¸‰ä¸ªå¼€å‘ä»»åŠ¡äº†ðŸ™ƒï¼ŒçœŸå¿™å•Š...ä¸è¿‡å¥½åœ¨ï¼Œä»Šå¤©å·²ç»è§£å†³å®Œä¸€ä¸ªäº†ï¼Œè¿™ä¸¤å¤©ä¾æ¬¡è§£å†³å‰©ä¸‹çš„å³å¯ã€‚æ‰€ä»¥ï¼Œç»™è‡ªå·±åŠ ä¸ªæ²¹å§ï¼ æœ¬æ¥æ‰“ç®—åœ¨å››æœˆç»§ç»­å­¦ä¹  Linux/C ä¸‹çš„åµŒå…¥å¼å¼€å‘è¯¾ç¨‹çš„ï¼Œç»“æžœå­¦å®Œäº†ä¸Ž C çš„ç›¸å…³å†…å®¹åŽï¼Œå°±é‡æ–°å¼€å§‹å®Œæˆ Nand2tetris è¯¾ç¨‹åŽ»äº†ï¼Œä¸å¾—ä¸è¯´ï¼ŒWeek 5 çš„ä»»åŠ¡çœŸçš„å¤ªéš¾äº†ï¼ŒèŠ±äº†è‡ªå·±å¾ˆé•¿çš„æ—¶é—´æ‰å®Œæˆï¼ŒWeek 6 çš„ä»»åŠ¡ç›¸å¯¹ç®€å•ä¸€äº›äº†ï¼Œå®ŒæˆåŽä¹Ÿæœ‰å¾ˆå¤šæ”¶èŽ·ã€‚ç›®å‰ï¼Œæƒ³çš„æ˜¯å†å›žæ¥çœ‹çœ‹è¿™ä¸¤ä¸ªç« èŠ‚çš„å†…å®¹ï¼Œå®Œå–„ä¸€ä¸‹ blog çš„å†…å®¹ã€‚ è¿™ä¸ªæœˆé€‰äº†ä¸€é¦–åŽŸæ¥å¸¸å¬çš„æŒ‡å¼¹æ›²å­ä½œä¸º BGMï¼ŒåŽŸå› æ˜¯è‡ªå·±æœ€è¿‘åœ¨ç»ƒä¹ è¿™é¦–æ›²å­ï¼Œå“ˆå“ˆã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªæœˆå·²ç»æŠŠ One more timeï¼ŒOne more chance ç»ƒç†Ÿäº†ï¼Œæ­Œè¯ä¹Ÿè®°äº†å¤§æ¦‚ä¸€åŠå·¦å³ï¼Œæƒ³ç€ç­‰å…ˆå­¦ä¼šå”±æ•´é¦–æ­Œå†ç»§ç»­ç»ƒä¹ ï¼Œæ‰€ä»¥å…ˆå¼€å§‹ç»ƒä¹ é£Žä¹‹è¯—äº†ã€‚çªç„¶æƒ³åˆ°ï¼Œåº”è¯¥å…ˆç»ƒä¹ å¤ªèªæ˜Žçš„ï¼Œå“ˆå“ˆã€‚ å¯æƒœçš„æ˜¯ï¼Œè¿™ä¸ªæœˆæ²¡æœ‰æŠŠã€Šé»„é‡‘æ—¶ä»£ã€‹è¯»å®Œï¼Œä¸çŸ¥é“è‡ªå·±å¤©å¤©åœ¨å¿™å•¥ï¼Œå“Žï¼Œäº”æœˆä»½ä¸€å®šè¦çœ‹å®Œï¼Œæœ€å¥½æ˜¯èƒ½å†å¤šè¯»ä¸€æœ¬ï¼Œå˜»å˜»ã€‚ å®žé™…ä¸Šï¼Œè¿˜æœ‰ä¸€ä»¶äº‹æƒ…è¦æä¸€ä¸‹ï¼Œé‚£å°±æ˜¯å…¥æ‰‹äº†ä¸€ä¸ª Apple pencil ä¸€ä»£ï¼Œä¸Šè¯¾çš„æ—¶å€™ç”¨æ¥è®°ä¸‹ç¬”è®°çœŸçš„æŒºä¸é”™çš„ï¼Œç¡®å®žèƒ½è®©è‡ªå·±çš„è¯¾å ‚æ•ˆçŽ‡æé«˜ï¼Œè‡³äºŽç”Ÿäº§åŠ›çš„æé«˜ï¼Œæš‚æ—¶è¿˜ä½“ä¼šä¸åˆ°ï¼Œå¯èƒ½è‡ªå·±è¿˜ä¸å¤ªä¼šç”¨ã€‚ å¯¹äº†ï¼Œå› ä¸ºå››æœˆä¸ºäº†å®Œæˆ Nand2tetris week 5 çš„ projectï¼Œè€—è´¹äº†å¤§é‡æ—¶é—´ï¼Œå¯¼è‡´è¿™ä¸ªæœˆçš„æ–‡æ¡£äº§å‡ºï¼Œéƒ½æ˜¯é›†ä¸­åœ¨æœˆåˆï¼Œå­¦ä¹ å’Œ C ç›¸å…³å†…å®¹çš„æ—¶å€™å†™çš„...ðŸ˜“è¿™ä¸ªæœˆï¼Œå¾—æƒ³åŠžæ³•å¢žåŠ ä¸€ç‚¹æ–‡æ¡£çš„äº§å‡ºäº†ðŸ˜¤ã€‚ æš‚å®šçš„è®¡åˆ’æ˜¯å®Œæˆ Nand2tetris week 6 çš„ projectï¼Œè‡³äºŽè¦ä¸è¦ç»§ç»­ä¸‹å†Œï¼Œçœ‹æƒ…å†µäº†ï¼Œå¯èƒ½ä¼šå›žå¤´ç»§ç»­åŽ»çŽ© Linux/C çš„å†…å®¹ï¼Œæ„Ÿè§‰çŽ©å†…æ ¸æ‰æœ‰æ„æ€ã€‚å¦å¤–ï¼Œå¸Œæœ›è‡ªå·±ä¸è¦å¿˜è®°çš„æ˜¯ï¼Œç»„æˆåŽŸç†å’Œæ“ä½œç³»ç»Ÿè¿™ä¸¤é—¨è¯¾ç¨‹ï¼Œä¸€å®šä¹Ÿè¦æƒ³åŠžæ³•å®Œæˆã€‚è¿˜æœ‰ï¼Œäº”ä¸€èŠ‚æœŸé—´åšçš„å‡ é“ç®—æ³•é¢˜ï¼Œæ¶‰åŠäº†ä¸€äº› DFSã€DP çš„æ€æƒ³ï¼ŒçœŸçš„æ˜¯å¾ˆå¥½çš„å…¥é—¨é¢˜ã€‚ä¸å¾—ä¸æ„Ÿæ…¨ï¼Œå¥½å­¦æ ¡è¿˜æ˜¯ä¸ä¸€æ ·å•Šï¼Œè€å¸ˆæ•™çš„ä¸œè¥¿éƒ½è¦å¥½ä¸€äº›ï¼Œå“Žï¼Œå…¶å®žè¯´è¿™è¯æŒºæ²¡æ„æ€çš„ã€‚ ç»§ç»­åŠ æ²¹å§ï¼Œéªšå¹´~ PSï¼šæˆ‘çš„é—¨å¡å¥½åƒæŽ‰äº†ï¼Œå¾—èŠ± 30 å—è¡¥åŠžðŸ˜­]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å…³äºŽ C è¯­è¨€å†…å­˜å¯¹é½çš„æ€è€ƒ]]></title>
    <url>%2F2023%2F04%2F05%2F%E5%85%B3%E4%BA%8E-C-%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[å†…å­˜å¯¹é½åˆæ˜¯ C è¯­è¨€çš„ç»å…¸é—®é¢˜äº†... introé¦–å…ˆåº”è¯¥æ˜Žç¡®çš„æ˜¯å†…å­˜å¯¹é½ï¼ˆMemory alignmentï¼‰æ˜¯ä¸€ä¸ªæ¦‚å¿µï¼Œä¸èƒ½æŠŠå®ƒä»…ä»…å±€é™åœ¨ C è¯­è¨€ä¸­ï¼ˆå°½ç®¡æ€»æ˜¯ä¼šå‡ºçŽ°åœ¨ C è¯­è¨€é¢è¯•é¢˜ä¸­ðŸ˜‚ï¼‰ï¼Œå®ƒå…¶å®žæ˜¯ä¸€ç§å’Œç¡¬ä»¶ç›¸å…³çš„è®¡ç®—æœºç³»ç»Ÿç»“æž„è®¾è®¡æ€æƒ³ï¼Œæœ¬è´¨å°±æ˜¯ç©ºé—´æ¢æ—¶é—´ã€‚å…¶æ¬¡ï¼Œä¸Žå…¶è¯´å†…å­˜å¯¹é½æ˜¯ä¸€ä¸ªå¾ˆéš¾ç†è§£çš„æ¦‚å¿µï¼Œä¸å¦‚è¯´æ˜¯ä¸€ä¸ªå¾ˆéº»çƒ¦çš„æ¦‚å¿µã€‚æ¢å¥è¯è¯´ï¼Œåªè¦å¯¹é½çš„è¿‡ç¨‹ç†æ¸…æ¥šäº†ï¼Œå°±ä¸éš¾äº†ã€‚å½“ç„¶äº†ï¼Œæœ¬ç¯‡æ–‡ç« ä¸ä¼šæ·±å…¥çš„è®¨è®ºè¿™äº›ç†è®ºï¼Œè¿˜æ˜¯é‡ç‚¹ä»‹ç» C è¯­è¨€ä¸­å’Œå†…å­˜å¯¹é½ç›¸å…³çš„çŸ¥è¯†ã€‚ structç»“æž„ä½“ï¼ˆstructï¼‰æ˜¯ä¸€ç§æž„é€ ç±»åž‹ï¼Œå…¶å¯¹é½è§„åˆ™å¦‚ä¸‹ï¼š ç»“æž„ä½“ä¸­ï¼Œç¬¬ä¸€ä¸ªæ•°æ®æˆå‘˜æ”¾åœ¨ offset ä¸º 0 çš„åœ°æ–¹ï¼Œä»¥åŽæ¯ä¸ªæ•°æ®æˆå‘˜æŒ‰å…¶ç±»åž‹å¤§å°å’Œé»˜è®¤å¯¹é½å‚æ•°ï¼ˆ32 ä½ç³»ç»Ÿé»˜è®¤æŒ‰ç…§ 4 å­—èŠ‚å¯¹é½ï¼Œ64 ä½ç³»ç»Ÿé»˜è®¤æŒ‰ç…§ 8 å­—èŠ‚å¯¹é½ï¼‰ä¸­è¾ƒå°çš„ä¸€ä¸ªå¯¹é½ï¼Œä¸”éœ€è¦æ»¡è¶³addr % size == 0ï¼Œå…¶ä¸­addræ˜¯å½“å‰æ•°æ®æˆå‘˜çš„èµ·å§‹åœ°å€ï¼Œsizeæ˜¯å½“å‰æ•°æ®æˆå‘˜çš„å¯¹é½å€¼ï¼Œå¦åˆ™è¡¥ç©ºç›´è‡³æ»¡è¶³æ¡ä»¶ã€‚ ç»“æž„ä½“æœ¬èº«ä¹Ÿéœ€è¦å¯¹é½ï¼Œæœ€ç»ˆsizeofçš„ç»“æžœå¿…é¡»æ˜¯ç³»ç»Ÿé»˜è®¤çš„å¯¹é½é•¿åº¦å’Œæˆå‘˜ä¸­æœ€é•¿ç±»åž‹äºŒè€…ä¹‹ä¸­æœ€å°å€¼çš„æ•´æ•°å€ã€‚ å¦‚æžœå­˜åœ¨ç»“æž„ä½“åµŒå¥—ï¼Œåˆ™å†…å±‚çš„ç»“æž„ä½“æˆå‘˜é»˜è®¤æŒ‰ç…§è§„åˆ™ 1 è¿›è¡Œå¯¹é½ã€‚ æŽ¥ä¸‹æ¥ï¼Œé€šè¿‡ä¸€äº›çš„ä¾‹å­æ¥ç†è§£è¿™äº›è§„åˆ™ã€‚eg1123456789101112131415161718192021#include &lt;stdio.h&gt;struct A &#123; char c1; short s;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); struct A a; printf("&amp;a.c1 = %p\n", &amp;a.c1); printf("&amp;a.s = %p\n", &amp;a.s); return 0;&#125;/*out:sizeof(struct A) = 4&amp;a.c1 = 000000834ddffbcc&amp;a.s = 000000834ddffbce*/ è¿™ä¸ªä¾‹å­æŒ‰ç…§è§„åˆ™ 1 ç†è§£å³å¯ã€‚eg21234567891011121314151617181920212223#include &lt;stdio.h&gt;struct A &#123; char c1; short s; char c2;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); struct A a; printf("&amp;a.c1 = %p\n", &amp;a.c1); printf("&amp;a.s = %p\n", &amp;a.s); printf("&amp;a.c2 = %p\n", &amp;a.c2); return 0;&#125;/*out:sizeof(struct A) = 6&amp;a.c1 = 000000016c7ffb3a&amp;a.s = 000000016c7ffb3c&amp;a.c2 = 000000016c7ffb3e*/ è¿™ä¸ªä¾‹å­éœ€è¦ç”¨è§„åˆ™ 1 å’Œè§„åˆ™ 2 æ¥ç†è§£ï¼Œc1åªéœ€è¦ä¸€ä¸ªå­—èŠ‚ï¼Œä½†séœ€è¦ 2 ä¸ªå­—èŠ‚ï¼Œè€Œ000000016c7ffb3b % 2 != 0ï¼Œæ‰€ä»¥è¡¥ 1 ä¸ªå­—èŠ‚ï¼Œæ•…sä»Ž000000016c7ffb3cå¼€å§‹å­˜ï¼›å¯¹åº”çš„ï¼Œc2æŒ‰ç…§é¡ºåºå­˜å‚¨åœ¨000000016c7ffb3eï¼Œä½†ç”±äºŽæ­¤æ—¶ç»“æž„ä½“çš„æ€»å¤§å°æ˜¯ 5ï¼Œæ•´ä¸ªç»“æž„ä½“çš„å¤§å°å¿…é¡»è¦æ˜¯ 2ï¼ˆè¿™ä¸ªç»“æž„ä½“çš„å¯¹é½å€¼ï¼‰çš„å€æ•°ï¼Œæ‰€ä»¥åˆè¡¥é½äº† 1 ä¸ªå­—èŠ‚ï¼Œæœ€ç»ˆçš„å¤§å°å°±æ˜¯ 6ã€‚eg312345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;struct A &#123; char c1; int i; double d; char c2;&#125;;struct B &#123; int a; char c1; struct A sa; char c2;&#125;;int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); printf("sizeof(struct B) = %d\n", sizeof(struct B)); struct B b; printf("&amp;b.a = %p\n", &amp;b.a); printf("&amp;b.c1 = %p\n", &amp;b.c1); printf("&amp;b.sa = %p\n", &amp;b.sa); printf("&amp;b.sa.c1 = %p\n", &amp;b.sa.c1); printf("&amp;b.sa.i = %p\n", &amp;b.sa.i); printf("&amp;b.sa.d = %p\n", &amp;b.sa.d); printf("&amp;b.sa.c2 = %p\n", &amp;b.sa.c2); printf("&amp;b.c2 = %p\n", &amp;b.c2); return 0;&#125;/*out:sizeof(struct A) = 24sizeof(struct B) = 40&amp;b.a = 0000003dd87ff6a0&amp;b.c1 = 0000003dd87ff6a4&amp;b.sa = 0000003dd87ff6a8&amp;b.sa.c1 = 0000003dd87ff6a8&amp;b.sa.i = 0000003dd87ff6ac&amp;b.sa.d = 0000003dd87ff6b0&amp;b.sa.c2 = 0000003dd87ff6b8&amp;b.c2 = 0000003dd87ff6c0*/ è¿™ä¸ªä¾‹å­éœ€è¦ç”¨è§„åˆ™ 1ã€è§„åˆ™ 2 å’Œè§„åˆ™ 3 æ¥ç†è§£ã€‚é¦–å…ˆåœ¨struct Aä¸­ï¼Œb.sa.c2æ”¾åœ¨ç¬¬ 17 ä¸ªåœ°å€å¤„ï¼Œä¸ºäº†æ»¡è¶³è§„åˆ™ 3ï¼Œåˆè¡¥äº† 7 ä¸ªå­—èŠ‚ï¼Œæ‰€ä»¥sizeof(struct A)æœ€ç»ˆç»“æžœæ˜¯ 24ï¼›è€Œb.sa.c1å’Œb.sa.iåªéœ€è¦æ»¡è¶³addr % size == 0ï¼ˆè§„åˆ™ 1ï¼‰å³å¯ï¼›æœ€åŽåœ¨struct Bä¸­ï¼Œb.c2æ”¾åœ¨ç¬¬ 33 ä¸ªåœ°å€å¤„ï¼Œä¸ºäº†æ»¡è¶³è§„åˆ™ 2ï¼Œåˆè¡¥äº† 7 ä¸ªå­—èŠ‚ã€‚ unionåœ¨unionå…³é”®å­—ä¸­ï¼Œå…¶å®žæ²¡æœ‰â€œå¯¹é½â€è¿™ä¸ªæ¦‚å¿µï¼Œä½†æ˜¯æœ‰â€œå†…å­˜â€çš„æ¦‚å¿µï¼ˆå®žé™…ä¸Šï¼ŒC è¯­è¨€æ€»æ˜¯ä¸Žå†…å­˜è”ç³»ç´§å¯†ï¼‰ï¼Œç›¸æ¯”äºŽstructè€Œè¨€ï¼Œunionå…³é”®å­—çš„å†…å­˜è§„åˆ™è¦ç®€å•ä¸Šè®¸å¤šã€‚å¦å¤–ï¼Œä¹‹æ‰€ä»¥ä¼šæŠŠunionçš„å†…å®¹æ”¾åœ¨å†…å­˜å¯¹é½è¿™é‡Œï¼Œä¹Ÿæ˜¯ä¸ºäº†ä¸Žstructè¿›è¡Œå¯¹æ¯”ï¼Œæ›´å®¹æ˜“ç†Ÿæ‚‰äºŒè€…çš„è”ç³»ä¸Žå·®åˆ«ã€‚ unionçš„è§„åˆ™å¦‚ä¸‹ï¼š unionä¸­èƒ½å¤Ÿå®šä¹‰å¤šä¸ªæˆå‘˜ï¼Œæ•´ä¸ªunionçš„å¤§å°ç”±æœ€å¤§çš„æˆå‘˜çš„å¤§å°å†³å®šã€‚ unionæˆå‘˜å…±äº«åŒä¸€å—å¤§å°çš„å†…å­˜ï¼Œä¸€æ¬¡ä»…ä»…èƒ½ä½¿ç”¨å½“ä¸­çš„ä¸€ä¸ªæˆå‘˜ã€‚ å¯¹æŸä¸€ä¸ªæˆå‘˜èµ‹å€¼ï¼Œä¼šè¦†ç›–æŽ‰å…¶å®ƒæˆå‘˜çš„å€¼ã€‚è¿™æ˜¯ç”±äºŽè¿™äº›å˜é‡å…±äº«ä¸€å—å†…å­˜ï¼Œä½†å½“æˆå‘˜æ‰€å å­—èŠ‚æ•°ä¸ä¸€è‡´æ—¶ï¼Œä»…ä»…ä¼šè¦†ç›–å¯¹åº”å­—èŠ‚ä¸Šçš„å€¼ï¼Œæ¯”å¦‚å¯¹charæˆå‘˜èµ‹å€¼å¹¶ä¸ä¼šæŠŠæ•´ä¸ªintæˆå‘˜è¦†ç›–æŽ‰ï¼Œå› ä¸ºcharåªå ä¸€ä¸ªå­—èŠ‚ï¼Œè€Œintå å››ä¸ªå­—èŠ‚ã€‚ unionçš„å­˜æ”¾é¡ºåºæ˜¯å…¨éƒ¨æˆå‘˜éƒ½ä»Žä½Žåœ°å€å¼€å§‹å­˜æ”¾çš„ã€‚ è¿˜æ˜¯ç›´æŽ¥çœ‹ä»£ç æ¥ç†è§£ï¼šeg41234567891011121314151617181920212223#include &lt;stdio.h&gt;union A &#123; char c; short i;&#125;;union B &#123; int i; float f; double d;&#125;;int main() &#123; printf("sizeof(union A) = %d\n", sizeof(union A)); printf("sizeof(union B) = %d\n", sizeof(union B)); return 0;&#125;/*out:sizeof(union A) = 2sizeof(union B) = 8*/ ä»Žè¾“å‡ºç»“æžœçœ‹ï¼Œunionçš„è§„åˆ™å¾ˆå®¹æ˜“ç†è§£ï¼Œè¿™é‡Œä¸å†èµ˜è¿°ã€‚ bit fieldå†™åˆ°è¿™é‡Œï¼Œä¸å¾—ä¸å†æä¸€ä¸‹ä½åŸŸï¼ˆä¹Ÿå«ä½å­—æ®µï¼Œbit fieldï¼‰ã€‚ä½åŸŸå…¶å®žå°±æ˜¯äººä¸ºåˆ’åˆ†å¥½çš„äºŒè¿›åˆ¶ä½åŒºåŸŸï¼Œå¹¶ä¸”æ¯ä¸ªåŒºåŸŸéƒ½æœ‰åŸŸåå’Œå…·ä½“çš„ä½æ•°ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§å½¢å¼ï¼šeg5123456struct &#123; unsigned int a: 1; char b: 2; char c: 1; int i: 1;&#125; b; ä»¥ä¸Šæ˜¯ç”¨structå…³é”®å­—å£°æ˜Žä½åŸŸï¼Œéœ€è¦æŒ‡å‡ºçš„æ˜¯ä½åŸŸä¸­æ— æ³•ä½¿ç”¨æµ®ç‚¹åž‹å…³é”®å­—å£°æ˜Žä½åŸŸåï¼Œå¦‚float f: 1;å’Œdouble d: 2;ç­‰ã€‚å¦‚æžœéœ€è¦æŸäº›ä½ï¼ˆbitï¼‰åœ¨ç‰¹å®šä½ç½®ï¼Œå¯ä»¥ç”¨æœªå‘½åçš„å­—æ®µè¿›è¡Œåˆ†éš”ï¼Œæ¯”å¦‚ï¼šeg712345struct &#123; unsigned int a: 32; char : 2; char c: 1;&#125; b; å½“ç„¶äº†ï¼Œæœªå‘½åçš„ä½åŸŸå­—æ®µæ˜¯æ— æ³•ä½¿ç”¨çš„ã€‚æœ€åŽï¼Œåœ¨ä¸¾ä¸€ä¸ªä½åŸŸçš„å®žé™…ä¾‹å­ï¼Œè®¡ç®— 16 è¿›åˆ¶æ•°ç›¸åŠ ï¼šeg81234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;union &#123; struct &#123; uint16_t i; uint16_t j; &#125; x; uint32_t y;&#125; a;int main() &#123; a.y = 0x11223344; printf("%x\n", a.x.i + a.x.j); return 0;&#125;/*out:4466*/ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œxå’Œyå…±ç”¨ä¸€å— 4 å­—èŠ‚å†…å­˜ï¼Œå¯¹yèµ‹å€¼ä¹Ÿç›¸å½“äºŽå¯¹xçš„æˆå‘˜iã€jèµ‹å€¼ï¼Œæ‰€ä»¥åŽé¢ç›´æŽ¥ç›¸åŠ ï¼Œå°±å¯ä»¥å°†ä¸¤ä¸ªåå…­è¿›åˆ¶æ•°ç›¸åŠ ã€‚ Summaryæœ‰å…³ C è¯­è¨€å†…å­˜å¯¹é½çš„ä¸€äº›æ€è€ƒï¼Œåˆ°è¿™é‡Œå°±æš‚æ—¶ç»“æŸäº†ã€‚å®žé™…ä¸Šï¼Œä¸ªäººè®¤ä¸ºåœ¨ C è¯­è¨€ä¸­ï¼ŒæŽŒæ¡å¯¹åº”è§„åˆ™ï¼ŒçŸ¥é“æœ‰è¿™ä¸ªâ€œç‰¹æ€§â€å­˜åœ¨ï¼Œå¹¶èƒ½å–„äºŽåˆ©ç”¨å³å¯ã€‚çœŸç¢°åˆ°äº†ç¬”è¯•é¢˜æ—¶ï¼Œä¸€ä¸ªä¸€ä¸ªç®—ï¼Œå…¶å®žæ²¡æœ‰å¤ªå¤§æ„ä¹‰ðŸ˜¶ã€‚å› ä¸ºæœ¬èº« C è¯­è¨€å°±æä¾›äº†è‡ªå®šä¹‰å†…å­˜å¯¹é½å€¼çš„åŠŸèƒ½ï¼Œæ¯”å¦‚ï¼š1#pragma pack(n) è¿™ä¸ªç¼–è¯‘æŒ‡ä»¤å¯ä»¥æŒ‡å®šæœ‰æ•ˆå¯¹é½å€¼ä¸º nã€‚ä¹Ÿå¯ä»¥æŒ‡å®šæŸä¸ªç»“æž„ä½“ä¸è¿›è¡Œå†…å­˜å¯¹é½ï¼Œå¦‚ï¼šeg91234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct A &#123; int a; double d; char c;&#125;__attribute__((packed));int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); return 0;&#125;/*out:sizeof(struct A) = 13*/ æ­¤æ—¶ç»“æž„ä½“çš„å¤§å°ï¼Œå°±æ˜¯å…¶æˆå‘˜å¤§å°ä¹‹å’Œã€‚å¦å¤–ï¼Œè¿˜æœ‰ä¸€ä¸ªåŽŸå› æ˜¯ C11 æä¾›äº†æŸ¥çœ‹å¯¹é½å€¼çš„å®_Alignofï¼ˆéœ€è¦åŒ…å«å¤´æ–‡ä»¶stdalign.hï¼Œä¸”åœ¨ C++ ä¸­æ˜¯alignofè¿ç®—ç¬¦ï¼‰ï¼Œä»¥ä¸Šé¢çš„ä»£ç ä¸ºä¾‹ï¼Œå¯ä»¥å¾—åˆ°ï¼šeg1012345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdalign.h&gt;struct A &#123; int a; double d; char c;&#125;__attribute__((packed));int main() &#123; printf("sizeof(struct A) = %d\n", sizeof(struct A)); printf("%d\n", _Alignof(struct A)); return 0;&#125;/*out:sizeof(struct A) = 131*/ ä»Žè¾“å‡ºç»“æžœä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒæŒ‡å®šç»“æž„ä¸å¯¹é½å…¶å®žå°±æ˜¯æŒ‰ 1 å­—èŠ‚è¿›è¡Œå¯¹é½ðŸ˜‚ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå¯¹äºŽå†…å­˜å¯¹é½ï¼Œåªè¦æŽŒæ¡åˆ†æžçš„æ–¹æ³•ï¼Œå†æŽŒæ¡åˆ†æžçš„æ€è·¯ï¼Œå¹¶ç†Ÿç»ƒçµæ´»è¿ç”¨å°±å¯ä»¥äº†ï¼Œæ­»è®°ç¡¬èƒŒè¿‡è€ƒè¯•é¢˜ã€é¢è¯•é¢˜ï¼ŒçœŸçš„ä¸æ˜¯å¥½äº‹æƒ…...å¥½äº†ï¼Œåˆæ‰¯äº†è¿™ä¹ˆå¤šï¼Œå…³äºŽå†…å­˜å¯¹é½ï¼Œæš‚æ—¶å°±åˆ°è¿™é‡Œäº†ã€‚PSï¼šå†™äº†å¥½å‡ å¤©ï¼Œç»ˆäºŽå‹‰å¼ºç®—æ˜¯å®Œæˆäº†ï¼Œç´¯ðŸ˜´ã€‚ å‚è€ƒå†…å®¹ï¼š1. C/C++å†…å­˜å¯¹é½è¯¦è§£2. åŸºç¡€ï¼ˆä¸€ï¼‰ç»“æž„ä½“å†…å­˜å¯¹é½3. alignof è¿ç®—ç¬¦(C++11 èµ·)4. alignof è¿ç®—ç¬¦]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Memory alignment</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æµ…æžå¿«é€Ÿå¹‚ç®—æ³•]]></title>
    <url>%2F2023%2F04%2F03%2F%E6%B5%85%E6%9E%90%E5%BF%AB%E9%80%9F%E5%B9%82%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[ä¸Šå‘¨åšäº†ä¸€é“ç®€å• C è¯­è¨€ç»ƒä¹ é¢˜ï¼Œåšå®Œäº†æ‰ååº”è¿‡æ¥æ˜¯å¿«é€Ÿå¹‚...ðŸ˜¶è®°å¾—ä¸Šä¸€æ¬¡çœ‹åˆ°å¿«é€Ÿå¹‚ç›¸å…³çš„å†…å®¹å·²ç»æ˜¯å¥½å‡ å¹´å‰çš„äº‹æƒ…äº†ï¼Ÿå½“æ—¶çœ‹çš„ä¸€çŸ¥åŠè§£ï¼Œä¹Ÿæ²¡å¤ªåœ¨æ„ï¼ŒçŽ°åœ¨åˆåšåˆ°äº†ï¼Œç«Ÿç„¶èŽ«åè§‰å¾—å¾ˆæ¸…æ™°ï¼Œæ˜¯æˆ‘å˜å¼ºäº†å—ï¼Ÿå“ˆå“ˆ~ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œè¿™æ¬¡å¾—æŠŠè¿™ä¸ªç®€å•å®žç”¨çš„ç®—æ³•æžæ¸…æ¥šäº†ï¼ Introå¿«é€Ÿå¹‚ç®—æ³•ï¼Œä¹Ÿå«äºŒè¿›åˆ¶æ±‚å¹‚ï¼ˆBinary Exponentiationï¼‰ï¼Œç®—æ³•çš„åå­—å°±æ˜¯ç®—æ³•çš„ç”¨é€”ã€‚ç®—æ³•çš„æ€è·¯ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯é€šè¿‡å‡å°‘ä¹˜æ³•æ“ä½œçš„æ¬¡æ•°æ¥è¾¾æˆå¿«é€Ÿæ±‚å¹‚ã€‚åœ¨å¸¸è§„æ±‚å¹‚çš„è¿‡ç¨‹ä¸­ï¼Œ$a^n=\underbrace{a \times a \cdots \times a}_n$ï¼Œè€Œå¿«é€Ÿå¹‚åˆ™æ˜¯å°†æ¯æ¬¡å¾—åˆ°çš„å¹‚ä½œä¸ºä¸‹ä¸€æ¬¡çš„ä¹˜æ•°å’Œè¢«ä¹˜æ•°è¿›è¡Œç›¸ä¹˜ï¼Œè¿™æ ·æ— å½¢ä¹‹ä¸­å‡å°‘äº†ä¹˜æ³•çš„æ¬¡æ•°ã€‚ Sampleä»¥è®¡ç®— 7 çš„ 10 æ¬¡æ–¹ä¸ºä¾‹ï¼Œè¯´æ˜Žä¸€ä¸‹å¸¸è§„æ€è·¯å’Œå¿«é€Ÿå¹‚æ€è·¯ã€‚å¸¸è§„æ€è·¯ï¼šé‚£å°±æ˜¯ $7 \times 7 = 49$ï¼Œ$49 \times 7 = 343$ï¼Œ... ä¸€æ­¥ä¸€æ­¥ç®—ï¼Œä¸€å…±è¦è¿›è¡Œ 9 æ¬¡ä¹˜æ³•ã€‚ å¿«é€Ÿå¹‚ï¼šå…ˆç®— $7 \times 7 = 49$ï¼Œç„¶åŽç®— $49 \times 49 = 343$ï¼Œå†ç®— $7^4$ çš„å¹³æ–¹ï¼Œæœ€åŽåœ¨ä¹˜ä»¥ä¸€ä¸ª $7$ å°±å¯ä»¥å¾—å‡ºç»“æžœäº†ï¼Œä¸€å…±æ˜¯ 4 æ¬¡ä¹˜æ³•ã€‚ ä»Žè¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œå¸¸è§„æ€è·¯çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n)$ï¼Œå¿«é€Ÿå¹‚çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(log n)$ã€‚ ImplementationRecursionå¿«é€Ÿå¹‚ä¹Ÿæ˜¯åŸºäºŽäºŒåˆ†çš„ï¼Œå¯ä»¥è€ƒè™‘ä»Žé€’å½’çš„è§’åº¦æ¥å®žçŽ°ï¼Œè¿™é‡Œç›´æŽ¥å€Ÿç”¨ä¸Šå‘¨é¢˜ç›®ä¸­æ‰€ç»™çš„é€’å½’å‡½æ•°ï¼š$$fun(a, b) =\begin{cases}{1} &amp; \text{if b = 0;} \\{fun(a \times a, b / 2)} &amp; \text{else if b mod 2 = 0;} \\{fun(a \times a, b / 2) \times a} &amp; \text{else.} \\\end{cases}$$ è¿™æ˜¯å½“æ—¶çš„å®žçŽ°ï¼šver1123456#define MOD 1000007int fun(int a, int b) &#123; if(b == 0) return 1; else if(b % 2 == 0) return (fun(a * a, b / 2) % MOD); else return ((fun(a * a, b / 2) % MOD) * (a % MOD));&#125; å› ä¸ºåœ¨è®¡ç®—è¿‡ç¨‹ä¸­ï¼Œç»“æžœå¯èƒ½ä¼šéžå¸¸å¤§ï¼Œä¸ºäº†ä¿è¯æœ€åŽç»“æžœçš„æ­£ç¡®æ€§éœ€è¦è¿›è¡Œå–ä½™æ“ä½œï¼Œå¦å¤–è¿˜å»ºè®®æ”¹ç”¨long longæ¥é¿å…æº¢å‡ºï¼Œæ‰€ä»¥å¯ä»¥å¾—åˆ°ä¸‹é¢çš„ç‰ˆæœ¬ï¼šver2123456#define MOD 1000007long long fun(long long a, long long b) &#123; if(b == 0) return 1; else if(b % 2 == 0) return (fun(a * a, b / 2) % MOD); else return ((fun(a * a, b / 2) % MOD) * (a % MOD));&#125; Non-Recursionæƒ³è¦å°†ä¸Šè¿°é€’å½’ç®—æ³•æ”¹ä¸ºéžé€’å½’ï¼Œå°±éœ€è¦ä»ŽäºŒè¿›åˆ¶çš„è§’åº¦æ¥æ€è€ƒé—®é¢˜ã€‚æ¯”å¦‚ï¼Œè¦è®¡ç®— $7^{10}$ï¼Œå°±æœ‰ $7^{(1010)} = 7^{(1000)} \times 7^{(0010)}$ï¼Œæ‰€ä»¥éžé€’å½’ç®—æ³•çš„å…³é”®åœ¨äºŽåˆ©ç”¨ä½è¿ç®—è®¡ç®—ä¹˜æ•°ï¼Œæœ€åŽå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ç‰ˆæœ¬ï¼šver312345678910long long fun(long long a, long long b) &#123; long long ans = 1; while(n) &#123; if(n &amp; 1) ans = ((ans % MOD) * (a % MOD)) % MOD; a *= a; n &gt;&gt;= 1; &#125; return ans;&#125; è¿™é‡Œï¼Œå€Ÿç”¨ä»–äººæ–‡ç« ä¸­çš„ä¸€å¼ å›¾æ¥è¯´æ˜Žæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ã€‚ å›žå¤´æ¥çœ‹ï¼Œé€’å½’å¿«é€Ÿå¹‚çš„æ€è·¯å…¶å®žä¹Ÿæ˜¯äºŒè¿›åˆ¶ï¼Œä¹Ÿå³å¯¹æŒ‡æ•°ä¸æ–­è¿›è¡Œå–ä½™å’Œé™¤ 2 æ“ä½œï¼Œè¿™ä¸ªè¿‡ç¨‹å…¶å®žå°±æ˜¯é™¤äºŒå–ä½™æ³•ã€‚ Extensionæ‰©å±•éƒ¨åˆ†ä¸»è¦å¼•ç”¨ä»–äººæ–‡ç« ä¸­çš„å†…å®¹ï¼ŒåŒ…æ‹¬ä¸€äº›è‡ªå·±çš„ç†è§£å’Œåº”ç”¨ã€‚é¦–å…ˆæ˜¯è¿™ç±»æ€è·¯çš„æ¨¡æ¿ï¼š123456789101112// æ³›åž‹çš„éžé€’å½’å¿«é€Ÿå¹‚template &lt;typename T&gt;T qpow(T a, ll n) &#123; T ans = 1; // èµ‹å€¼ä¸ºä¹˜æ³•å•ä½å…ƒï¼Œå¯èƒ½è¦æ ¹æ®æž„é€ å‡½æ•°ä¿®æ”¹ while (n) &#123; if (n &amp; 1) ans = ans * a; // è¿™é‡Œå°±æœ€å¥½åˆ«ç”¨è‡ªä¹˜äº†ï¼Œä¸ç„¶é‡è½½å®Œ*è¿˜è¦é‡è½½*=ï¼Œæœ‰ç‚¹éº»çƒ¦ã€‚ n &gt;&gt;= 1; a = a * a; &#125; return ans;&#125; è¿˜æœ‰ä¸€ä¸ªçŸ©é˜µå¿«é€Ÿå¹‚çš„ä¾‹å­ï¼šæ´›è°· P1962 æ–æ³¢é‚£å¥‘æ•°åˆ— ä»¥åŠå¯¹åº”çš„ä»£ç ï¼šP1962123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#define MOD 1000000007typedef long long ll;struct matrix&#123; ll a1, a2, b1, b2; // constructor with initialize list matrix(ll a1, ll a2, ll b1, ll b2) : a1(a1), a2(a2), b1(b1), b2(b2) &#123;&#125; // operator * overloading matrix operator*(const matrix &amp;y) &#123; matrix ans((a1 * y.a1 + a2 * y.b1) % MOD, (a1 * y.a2 + a2 * y.b2) % MOD, (b1 * y.a1 + b2 * y.b1) % MOD, (b1 * y.a2 + b2 * y.b2) % MOD); return ans; &#125;&#125;;matrix qpow(matrix a, ll n)&#123; matrix ans(1, 0, 0, 1); //å•ä½çŸ©é˜µ while (n) &#123; if (n &amp; 1) ans = ans * a; a = a * a; n &gt;&gt;= 1; &#125; return ans;&#125;int main()&#123; ll x; matrix M(0, 1, 1, 1); scanf("%lld", &amp;x); matrix ans = qpow(M, x - 1); printf("%lld\n", (ans.a1 + ans.a2) % MOD); return 0;&#125; è¿™ä¸ªå°é¢˜ç”¨åˆ°äº†ä¸‰ä¸ªé‡è¦çš„çŸ¥è¯†ç‚¹ï¼š çŸ©é˜µå¿«é€Ÿå¹‚ æž„é€ å‡½æ•°åˆå§‹åŒ–åˆ—è¡¨ è¿ç®—ç¬¦é‡è½½ çœŸè¦ç”¨çº¯ç”¨ C è¯­è¨€çš„ä¸œè¥¿ï¼Œä¼°è®¡ä»£ç é‡æ˜¯ä¸¤å€äº†...ðŸ¤” å‚è€ƒå†…å®¹ï¼š1. ç®—æ³•å­¦ä¹ ç¬”è®°(4)ï¼šå¿«é€Ÿå¹‚]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Binary Exponentiation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makefile_ç®€å•å…¥é—¨]]></title>
    <url>%2F2023%2F04%2F02%2FMakefile-%E7%AE%80%E5%8D%95%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[ç®€å•å­¦ä¸€ä¸‹ Makefile çš„ç¼–å†™è§„åˆ™~ðŸ§ å‰è¨€é¦–å…ˆåº”è¯¥çŸ¥é“ Makefile æ˜¯ç”¨æ¥ç»™ Linuxï¼ˆUnitï¼‰å¹³å°ä¸‹ Make å·¥å…·æè¿°æºç¨‹åºä¹‹é—´çš„ç›¸äº’å…³ç³»å¹¶è‡ªåŠ¨ç»´æŠ¤ç¼–è¯‘å·¥ä½œçš„æ–‡ä»¶ã€‚Makefile æ–‡ä»¶éœ€è¦æŒ‰ç…§æŸç§ç‰¹å®šè¯­æ³•ç¼–å†™ï¼Œæ–‡ä»¶ä¸­éœ€è¦è¯´æ˜Žå¦‚ä½•ç¼–è¯‘å„ä¸ªæºæ–‡ä»¶å¹¶é“¾æŽ¥ç”Ÿæˆå¯æ‰§è¡Œæ–‡ä»¶ï¼Œå¹¶è¦æ±‚å®šä¹‰æºæ–‡ä»¶ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚æ€»è€Œè¨€ä¹‹ï¼ŒMake æ˜¯å·¥å…·ï¼Œç”¨æˆ·é€šè¿‡ç¼–å†™ Makefile æ¥å‘Šè¯‰ Make å·¥å…·å¦‚ä½•æ‰§è¡Œç¼–è¯‘å·¥ä½œã€‚æœ€åŽï¼Œéœ€è¦æŒ‡å‡ºçš„æ˜¯ï¼ŒWindows ä¸‹ä¹Ÿå¯ä»¥é€šè¿‡ MingW æ¥å®‰è£… Make å·¥å…·ã€‚ ä¸‹é¢ï¼Œä»¥ä¸€ä¸ªä¾‹å­æ¥è¯´æ˜Žå¦‚ä½•ç¼–å†™ Makefileï¼Œæ­¤ä¾‹å­æ¥æºäºŽæŽæ…§èŠ¹ - Makefile å·¥ç¨‹æ–‡ä»¶çš„ç¼–å†™è§„åˆ™ã€‚ å·¥ç¨‹ç»“æž„è¿™ä¸ªä¾‹å­çš„å·¥ç¨‹ç»“æž„æ¯”è¾ƒç®€å•ï¼Œç›´æŽ¥çœ‹æºç å°±å¯ä»¥çŸ¥é“å¯¹åº”çš„ä¾èµ–å…³ç³»ï¼šmain.c123456789101112#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;// åœ¨ main.c ä¸­å¼•å…¥ä¸¤ä¸ªå¤´æ–‡ä»¶ï¼Œç¼–è¯‘ main.c æ—¶ï¼Œéœ€è¦æå‰ç¼–è¯‘å¥½è¿™ä¸¤ä¸ªæ–‡ä»¶#include "tool1.h"#include "tool2.h"int main() &#123; mytool1(); mytool2(); exit(0);&#125; åœ¨.cæ–‡ä»¶ä¸­å†™å¥½å‡½æ•°çš„å®šä¹‰ã€‚tool1.c123456#include &lt;stdio.h&gt;#include "tool1.h"void mytool1() &#123; printf("tool1 print\n\n");&#125; åœ¨.hæ–‡ä»¶ä¸­å†™å¥½å‡½æ•°çš„å£°æ˜Žå’Œæ¡ä»¶ç¼–è¯‘è§„åˆ™ï¼Œä»¥å…é‡å¤ç¼–è¯‘ã€‚tool1.h123456#ifndef TOOL1_H__#define TOOL1_H__void mytool1();#endif tool2å¦‚æ³•ç‚®åˆ¶ã€‚tool2.c123456#include &lt;stdio.h&gt;#include "tool2.h"void mytool2() &#123; printf("tool2 print\n");&#125; tool2.h123456#ifndef TOOL2_H__#define TOOL2_H__void mytool2();#endif ç¼–å†™çŽ°åœ¨ï¼Œå¼€å§‹ç¼–å†™ Makefileï¼Œéœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œå·¥ç¨‹çš„ç›®å½•ä¸‹å¯ä»¥å­˜åœ¨å¤šä¸ªåç§°ä¸ºMakefileçš„æ–‡ä»¶ï¼Œä½† Make å·¥å…·è®¤ä¸ºå°å†™çš„ä¼˜å…ˆçº§æ›´é«˜ã€‚Makefile çš„ç¼–å†™è§„åˆ™æ¯”è¾ƒç®€å•ï¼Œè·Ÿè„šæœ¬æœ‰ç‚¹ç±»ä¼¼ï¼Œè¯­æ³•å¦‚ä¸‹ï¼š12target: prerequisites command å…¶ä¸­ï¼Œtargetæ˜¯è¦ç”Ÿæˆçš„æ–‡ä»¶ï¼Œprerequisiteså°±æ˜¯ç¼–è¯‘targetæ‰€éœ€è¦çš„ä¾èµ–æ–‡ä»¶ï¼Œè€Œcommandå°±æ˜¯åœ¨ç»ˆç«¯è¾“å…¥çš„ç¼–è¯‘å‘½ä»¤äº†ã€‚æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œcommandå‰éœ€è¦æœ‰ä¸€ä¸ªtabç¬¦å·ï¼Œä¸”ä¸èƒ½ç”¨ç©ºæ ¼ä»£æ›¿ï¼Œä¸ç„¶ Make è¯†åˆ«ä¸å‡ºæ¥ã€‚æœ‰äº†ä¸Šé¢çš„çŸ¥è¯†ï¼Œå°±å¯ä»¥å†™å‡ºä¸‹é¢çš„ Makefile äº†ï¼šm1123456789mytool: main.o tool1.o tool2.o gcc main.o tool1.o tool2.o -o mytoolmain.o: main.c gcc main.c -c -Wall -g -o main.otool1.o: tool1.c gcc tool1.c -c -Wall -g -o tool1.otool2.o: tool2.c gcc tool2.c -c -Wall -g -o tool2.o æ­¤æ—¶ï¼Œåœ¨ç»ˆç«¯è¾“å…¥$ makeåŽï¼ŒMake å·¥å…·å°±ä¼šæŒ‰ç…§ Makefile è¿›è¡Œç¼–è¯‘ã€‚ç¼–è¯‘å®ŒæˆåŽï¼Œå¯ä»¥å‘çŽ°ç›®å½•ä¸‹ï¼Œå‡ºçŽ°äº†å¾ˆå¤š.oçš„ä¸´æ—¶æ–‡ä»¶ï¼Œéœ€è¦åˆ é™¤ï¼Œæ‰‹åŠ¨åˆ é™¤å¤ªéº»çƒ¦ï¼ŒåŒæ ·å€ŸåŠ© Makefileï¼Œåªéœ€è¦åœ¨ä¸‹é¢å†åŠ ä¸Šï¼šm2123456789101112mytool: main.o tool1.o tool2.o gcc main.o tool1.o tool2.o -o mytoolmain.o: main.c gcc main.c -c -Wall -g -o main.otool1.o: tool1.c gcc tool1.c -c -Wall -g -o tool1.otool2.o: tool2.c gcc tool2.c -c -Wall -g -o tool2.oclean: rm *.o mytool -rf æ­¤æ—¶ï¼Œä½¿ç”¨ Make å‘½ä»¤ç¼–è¯‘æ—¶å°±ä¼šè‡ªåŠ¨åˆ é™¤å¤šä½™çš„.oæ–‡ä»¶ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªmytoolçš„å¯æ‰§è¡Œæ–‡ä»¶ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥åœ¨ç»ˆç«¯è¾“å…¥$ make cleanæ¥æ¸…é™¤.oæ–‡ä»¶ã€‚ ç®€åŒ–è§‚å¯Ÿ m2ï¼Œå¯ä»¥å‘çŽ°æœ‰å¾ˆå¤šé‡å¤çš„éƒ¨åˆ†ï¼Œè€Œ Makefile å…è®¸æˆ‘ä»¬å®šä¹‰å˜é‡æ¥å–ä»£é‡å¤ä¸”å†—é•¿çš„éƒ¨åˆ†ï¼Œè€Œå˜é‡çš„å¼•ç”¨éœ€è¦ä½¿ç”¨$å’Œ()æ¥å®Œæˆã€‚æ­¤æ—¶ï¼Œæˆ‘ä»¬å¯ä»¥ä¸‹é¢çš„ Makefile äº†ï¼šm3123456789101112131415OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $(OBJS) -o mytoolmain.o: main.c $(CC) main.c $(CFLAGS) -o main.otool1.o: tool1.c $(CC) tool1.c $(CFLAGS) -o tool1.otool2.o: tool2.c $(CC) tool2.c $(CFLAGS) -o tool2.oclean: $(RM) *.o mytool -r æ³¨æ„ï¼Œæœ€ä¸‹é¢ä½¿ç”¨RMå˜é‡ä»£æ›¿äº†rm -fã€‚ ç»§ç»­ç®€åŒ–å®žé™…ä¸Šï¼ŒMakefile æä¾›äº†ä¸€äº›è‡ªåŠ¨å˜é‡è¿è¡Œæˆ‘ä»¬è¿›ä¸€æ­¥ç®€åŒ– Makefileã€‚æ¯”å¦‚ï¼Œåœ¨å½“å‰æŸä¸€è¡Œçš„å®žçŽ°ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥ç”¨$^æ¥ä»£æ›¿æ‰€æœ‰çš„ä¾èµ–æ–‡ä»¶ï¼Œç”¨$@æ¥ä»£æ›¿ç›®æ ‡æ–‡ä»¶ã€‚æ­¤æ—¶ Makefile å°±å¯ä»¥å†™æˆï¼šm4123456789101112131415OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $^ -o $@main.o: main.c $(CC) $^ $(CFLAGS) -o $@tool1.o: tool1.c $(CC) $^ $(CFLAGS) -o $@tool2.o: tool2.c $(CC) $^ $(CFLAGS) -o $@clean: $(RM) *.o mytool -r å†™åˆ°è¿™é‡Œï¼Œä½ ä¼šå‘çŽ°ï¼Œç®€åŒ–åŽçš„æ–‡ä»¶ä¸­ï¼Œå¥½åƒæœ‰å‡ è¡Œéƒ½æ˜¯ä¸€æ ·çš„ï¼Œæ˜¯ä¸æ˜¯è¿˜å¯ä»¥ç®€åŒ–å‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„...ðŸ˜‚åœ¨ Makefile ä¸­%æ˜¯ä¸€ä¸ªé€šé…ç¬¦ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºå½“å‰æŸè¡Œå®žçŽ°ä¸Šçš„ç›¸åŒæ–‡ä»¶åã€‚æ­¤æ—¶ï¼ŒMakefile å°±å¯ä»¥å†™æˆï¼šm51234567891011OBJS=main.o tool1.o tool2.oCC=gccCFLAGS+=-c -Wall -gmytool: $(OBJS) $(CC) $^ -o $@%.o:%.c $(CC) $^ $(CFLAGS) -o $@clean: $(RM) *.o mytool -r è¿™æ ·å†™ï¼Œå°±æ›´ç®€å•äº†ã€‚ ç»“è¯­è¿™ä¹ˆä¸€é€šé€šç®€åŒ–ä¸‹æ¥ï¼Œçœ‹èµ·æ¥å¥½åƒæ˜¯è¶Šå†™è¶Šç®€å•äº†ï¼Œå¯è¯»æ€§æ˜¯è¶Šæ¥è¶Šå·®äº†...ðŸ˜…ä¸è¿‡ Makefile ä½œä¸ºä¸€ä¸ªå·¥å…·è€Œè¨€ï¼Œå­¦ä¼šè¿™äº›ä¹Ÿå·®ä¸å¤šäº†ï¼Œå‰©ä¸‹çš„ï¼Œç­‰é‡åˆ°äº†å†æŸ¥ä¹¦~]]></content>
      <categories>
        <category>Tools</category>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_03_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F04%2F01%2F2023-03-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä¸‰æœˆï¼Œæ˜¯æ¨±èŠ±ðŸŒ¸é£žèˆžçš„å­£èŠ‚... Nocturne No. 2 in E Flat Major, Op. 9, No. 2 - Arthur RubinsteinYour browser does not support the audio tag. è¿˜æ˜¯å¤å…¸éŸ³ä¹è®©äººæ²‰é™~ å…ˆè¯´è¯´å·¥ä½œçš„äº‹æƒ…ï¼Œä¸‰æœˆä»½ï¼ˆä¹Ÿå°±æ˜¯ä¸Šå‘¨ï¼‰æŠ•äº§äº†ä¸€ä¸ªå•å­ï¼Œå®žé™…æ”¹åŠ¨å¹¶ä¸å¤§ï¼Œåªæ˜¯åšæµ‹è¯•çš„æ—¶å€™èŠ±äº†å¾ˆå¤šæ—¶é—´...çŽ°åœ¨æƒ³æ¥ï¼Œè¿˜è§‰å¾—ååˆ†éº»çƒ¦...ç©¶å…¶åŽŸå› ï¼Œè¿˜æ˜¯å¯¹é¡¹ç›®ä¸ç†Ÿæ‚‰ï¼Œå¯¹åŠŸèƒ½ä»£ç ä¸äº†è§£ã€‚å›žå¤´æ¥çœ‹ï¼Œè¿™ä¸ªâ€œå¹´è€çš„â€å·¥ç¨‹éœ€è¦æˆ‘æ‡‚å¾—ä¸œè¥¿è¿˜æŒºå¤šï¼ŒåŒ…æ‹¬ C++ã€WSAPã€HTMLã€MFC å’Œä¸€ç‚¹ç‚¹ç¡¬ä»¶çŸ¥è¯†ï¼Œå¹¸å¥½ç³»ç»Ÿè¿˜åŽŸè¿™äº›è¿ç»´æ“ä½œï¼Œæˆ‘æœ¬æ¥å°±ä¼šðŸ˜‚ï¼Œä¹Ÿè®¸èƒ½æŽ¥æ‰‹è¿™ä»½å·¥ä½œä¹Ÿæ˜¯å¶ç„¶ä¸­çš„å¿…ç„¶å¯¼è‡´çš„...å¥½äº†ï¼Œä¸åŽ»æƒ³è¿™äº›äº†ã€‚å®žé™…ä¸Šè€Œè¨€ï¼Œè™½ç„¶æµ‹è¯•è´¹äº†å¾ˆå¤šåŠŸå¤«ï¼Œä½†æ˜¯è‡³å°‘è®©æˆ‘å¯¹åŠŸèƒ½ä»£ç ç†Ÿæ‚‰äº†å¾ˆå¤šã€‚åˆšæ‰å›žå¤´çœ‹äº†ä¸‹ä¸Šä¸ªæœˆçš„æ€»ç»“ï¼Œä¸Šä¸ªæœˆå›°æ‰°è‡ªå·±ä¸ç†Ÿæ‚‰æ•´ä½“æž¶æž„çš„é—®é¢˜ï¼Œè¿™ä¸ªæœˆå¾—åˆ°äº†å¤§çº¦ç™¾åˆ†ä¹‹å››åçš„è§£å†³ï¼ˆå“ˆå“ˆï¼Œè¿™ä¹ˆè¯´è¯æ„Ÿè§‰ä¸å¤ªç²¾ç¡®ï¼Œä¹Ÿä¸åƒä¹¦é¢è¯­ï¼‰ã€‚ä¸€æ–¹é¢æ˜¯å› ä¸ºï¼Œè¿™å‘¨è·Ÿ y è€å¸ˆä¸€èµ·æŽ¢è®¨äº†ä¸€äº›é—®é¢˜ï¼Œæœ‰äº›é—®é¢˜å¾—åˆ°äº†ä»–çš„è§£ç­”ï¼›å¦ä¸€æ–¹é¢æ˜¯è‡ªå·±åˆçœ‹äº†ä¸€äº›å…¶ä»–çš„æ–‡æ¡£ï¼Œè‡ªå·±åšäº†ä¸€äº›æ€»ç»“æ€§çš„ç¬”è®°ã€‚ å¥½äº†ï¼Œå·¥ä½œä¸Šå…¶å®žä¹Ÿæ²¡æœ‰å…¶ä»–çš„é—®é¢˜äº†ã€‚ å›žåˆ°è‡ªå·±çš„å­¦ä¹ ä¸Šï¼Œä¸Šä¸ªæœˆè‡ªå·±æ‰¿è¯ºè¦å†™å®Œçš„ Nand2tetris é¡¹ç›®ï¼Œè¿™ä¸ªæœˆè¿˜æ˜¯ææµ…äº†...ä¸è¿‡ Tinyhttpd é¡¹ç›®ç¬”è®°ç®—æ˜¯å†™å®Œäº†ï¼Œå½“ç„¶äº†ï¼Œé‡Œé¢è¿˜æœ‰ä¸€äº›å†…å®¹å¯ä»¥æ·±æŒ–ä¸€ä¸‹ã€‚è¿™ä¸ªé¡¹ç›®çš„ç¬”è®°å†™å®ŒåŽï¼Œçœ‹åˆ° PAT ä¹™çº§é¢˜åº“æ›´æ–°äº†äº”é“é¢˜ï¼ŒæŠ½äº†ä¸€ä¸ªå‘¨æœ«çš„æ—¶é—´ï¼Œåšå®Œäº†ï¼Œæ„Ÿè§‰è¿˜æœ‰ç‚¹æ”¶èŽ·ï¼Œå°±æ˜¯å¤ªä¹…æ²¡å†™ C++ ä»£ç ï¼Œæœ‰ç‚¹æ‰‹ç”Ÿã€‚ç„¶åŽå°±æ˜¯åˆå¼€å§‹çœ‹ä¸€é—¨æ–°çš„è§†é¢‘è¯¾äº†ï¼Œä¸»è®²å°±æ˜¯ Linux/C ä¸‹çš„åµŒå…¥å¼å¼€å‘ã€‚å°±å½“æ˜¯å¤ä¹ å·©å›º C è¯­è¨€äº†ï¼Œå¹¶å­¦ä¹ ä¸€ä¸‹ Linux çŽ¯å¢ƒä¸‹çš„ç¼–ç¨‹ï¼Œçœ‹çœ‹å››æœˆèƒ½ä¸èƒ½çœ‹å®Œå§ã€‚ å›­åŒºçš„æ¨±èŠ±æ ‘ðŸŒ¸ä¸€å¼€å§‹è¢«æˆ‘å½“ä½œäº†æ¡ƒæ ‘ï¼Œç»“æžœæŸ¥è¯äº†ä¸€ä¸‹æ‰çŸ¥é“ï¼Œæ˜¯æ¨±èŠ±æ ‘ðŸ˜“ï¼ŒåŽŸè°…æˆ‘çš„æ— çŸ¥ï¼Œå“ˆå“ˆã€‚ç”±äºŽä»Šå¹´æ¶¦äº†ä¸€ä¸ªäºŒæœˆï¼Œå¯¼è‡´çŽ°åœ¨æ°”æ¸©ä¸é«˜ä¸ä½Žï¼Œä½†å¶å°”ä¼šæœ‰æ˜¥é£Žå¹è¿‡å›­åŒºï¼Œè¿žå¸¦ç€æ¨±èŠ±çš„èŠ±ç“£ðŸŒ¸åœ¨ç©ºä¸­é£žèˆžï¼Œååˆ†æ¼‚äº®ã€‚èµ°åœ¨è·¯ä¸Šï¼Œä¹Ÿä¼šæ—¶ä¸æ—¶çš„è¸©åˆ°è¿™äº›èŠ±ç“£ï¼Œäººä¹Ÿä¼šä¸çŸ¥ä¸è§‰çš„æ„Ÿæ…¨èµ·æ—¶é—´çš„æµé€...]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C è¯­è¨€æ•°ç»„ä¸ŽæŒ‡é’ˆçš„æ·±å…¥ç†è§£]]></title>
    <url>%2F2023%2F03%2F28%2FC-%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[æ¥æ·±å…¥ç†è§£ä¸€ä¸‹æ•°ç»„ä¸ŽæŒ‡é’ˆå§~ åœ¨C è¯­è¨€å‡½æ•°æŒ‡é’ˆçš„ä¸€äº›ç†è§£ä¸­å·²ç»æ¢³ç†è¿‡äº†å‡½æ•°æŒ‡é’ˆã€æŒ‡é’ˆæ•°ç»„ä»¥åŠäºŒè€…ç»“åˆçš„ä½¿ç”¨æƒ…å½¢ï¼ŒçŽ°åœ¨ç»§ç»­æ·±å…¥ç†è§£ä¸€ä¸‹æ•°ç»„ä¸ŽæŒ‡é’ˆä¹‹é—´çš„å·®å¼‚ä¸Žè”ç³»ã€‚ å›žé¡¾é¦–å…ˆï¼Œçœ‹ä¸€æ®µä»£ç å›žé¡¾ä¸€ä¸‹æ•°ç»„ä¸ŽæŒ‡é’ˆçš„å¸¸è§„ä½¿ç”¨ï¼štest1123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", *pa++); return 0;&#125; ç±»ä¼¼çš„ï¼Œè¿˜æœ‰ä¸‹é¢è¿™æ ·çš„ç”¨æ³•ï¼štest2123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", pa[i]); return 0;&#125; ä»¥åŠï¼Œè¿™æ ·çš„ç”¨æ³•ï¼štest3123456789#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; for(int i = 0; i &lt; sizeof(arr) / sizeof(*arr); i++) printf("%d\n", *(pa + i)); return 0;&#125; ä»¥ä¸Šè¿™äº›ç”¨æ³•ï¼Œéƒ½æ˜¯æ¯”è¾ƒå®¹æ˜“ç†è§£çš„æŒ‡é’ˆåœ¨æ•°ç»„ä¸Šçš„ç®€å•åº”ç”¨ã€‚ä¸‹é¢ï¼Œå†æ¥ä»”ç»†ç ”ç©¶ä¸€ä¸‹æ•°ç»„ä¸ŽæŒ‡é’ˆçš„å…³ç³»ã€‚ ä¸€ç»´æ•°ç»„åœ¨ä¹‹å‰çš„æ–‡ç« é‡Œé¢ï¼Œå·²ç»æåˆ°è¿‡äº†æ•°ç»„åä¸ŽæŒ‡é’ˆæŒ‡çš„ä¸æ˜¯åŒä¸€ç§ä¸œè¥¿ï¼Œç”¨æ¥åŒºåˆ†äºŒè€…ä¸åŒçš„å·¥å…·æ˜¯sizeofå…³é”®å­—ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢è¿™æ®µä»£ç ï¼štest412345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[] = &#123;1, 2, 3&#125;, *pa = arr; printf("arr = %p, pa = %p\n", arr, pa); printf("sizeof(arr) = %d\n", sizeof(arr)); printf("sizeof(pa) = %d\n", sizeof(pa)); return 0;&#125;/*out:arr = 0061FF10, pa = 0061FF10sizeof(arr) = 12sizeof(pa) = 4*/ æ˜¾ç„¶ï¼Œä»Žä¸Šé¢çš„è¾“å‡ºç»“æžœä¸­å¯ä»¥çŸ¥é“arrè¿™ä¸ªæ•°ç»„åå äº† 12 ä¸ªå­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯å®ƒæ€»å…ƒç´ ä¸ªæ•°ä¹˜ä»¥å•ä½å…ƒç´ çš„å¤§å°ï¼›åŒæ—¶ï¼Œæˆ‘ä»¬ä¹ŸçŸ¥é“äº†ä¸€ä¸ªæ™®é€šint *æŒ‡é’ˆæ‰€å å¤§å°æ˜¯ 4ã€‚å°½ç®¡å®ƒä»¬å€¼éƒ½æ˜¯åœ°å€ä¸”ç›¸åŒï¼Œä½†äºŒè€…æ˜¯å®Œå…¨ä¸ä¸€æ ·çš„ã€‚ å®žé™…ä¸Šï¼ŒæŒ‰ç…§ C è¯­è¨€çš„è§„å®šï¼Œæ•°ç»„åæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œå¹¶ä¸”å…¶å€¼æ˜¯ä¸€ä¸ªåœ°å€ï¼Œä½†å¹¶ä¸èƒ½å°†æ•°ç»„åä¸ŽæŒ‡é’ˆç­‰ä»·ã€‚åœ¨å‰é¢çš„ä»£ç ä¸­ï¼Œä½¿ç”¨äº†ä¸€ä¸ªint *æŒ‡é’ˆæ¥è®¿é—®æ•°ç»„çš„å…ƒç´ ï¼Œå®žé™…ä¸Šè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„æ˜¯æ•°ç»„çš„å…ƒç´ ã€‚å¦‚æžœï¼Œéœ€è¦æœ‰ä¸€ä¸ªæŒ‡é’ˆæŒ‡å‘æ•°ç»„ï¼Œé‚£ä¹ˆéœ€è¦æŒ‰ç…§å¦‚ä¸‹çš„æ–¹å¼å£°æ˜ŽæŒ‡é’ˆï¼štest5123456789101112131415#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3] = &#123;1, 2, 3&#125;; int (*parr)[3] = &amp;arr; printf("arr = %p\n", arr); printf("parr = %p\n", parr); return 0;&#125;/*out:arr = 0061FF10parr = 0061FF10*/ è¿™ä¸Žä¹‹å‰è®¨è®ºå‡½æ•°æŒ‡é’ˆçš„ç”¨æ³•æ—¶æ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿå°±æ˜¯éœ€è¦ä½¿ç”¨()å°†æŒ‡é’ˆåä¸Ž*æ‹¬èµ·æ¥ï¼Œä»Žè€Œå‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œè€Œä¸æ˜¯æŒ‡é’ˆæ•°ç»„ã€‚ä½†æ­¤æ—¶éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œparræ˜¯ä¸€ä¸ªæ•°ç»„æŒ‡é’ˆï¼Œå¹¶ä¸èƒ½åƒä½¿ç”¨paä¸€æ ·éåŽ†æ•°ç»„ã€‚è€Œpaä¹‹æ‰€ä»¥èƒ½éåŽ†æ•°ç»„çš„åŽŸå› æ˜¯å› ä¸º C è¯­è¨€ä¸­å­˜åœ¨ä¸€ä¸ªå«åšåç§»é‡çš„æ¦‚å¿µï¼Œåœ¨å£°æ˜Žäº†paæ˜¯ä¸€ä¸ªint *åŽï¼Œæ¯æ¬¡æ‰§è¡Œpa + 1ï¼Œé‚£ä¹ˆpaæ‰§è¡Œçš„åœ°å€å°±ä¼šç§»åŠ¨ 4 ä¸ªå­—èŠ‚ï¼Œè¿™å°±æ˜¯åç§»é‡ï¼ˆoffsetï¼‰ã€‚ äºŒç»´æ•°ç»„çŽ°åœ¨ï¼Œå†å›žå¤´çœ‹äºŒç»´æ•°ç»„ã€‚æˆ‘ä»¬å…ˆå£°æ˜Žä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œå¹¶è¾“å‡ºå¯¹åº”çš„åœ°å€ï¼štest612345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; printf("arr = %p\n", arr); printf("*arr = %p\n", *arr); printf("**arr = %d\n", **arr); return 0;&#125;/*out:arr = 0061FEFC*arr = 0061FEFC**arr = 1*/ å¯ä»¥å‘çŽ°ï¼Œarrå’Œ*arrè¡¨ç¤ºçš„å€¼éƒ½æ˜¯ä¸€æ ·çš„åœ°å€ï¼Œä¹Ÿå³æ•°ç»„é¦–å…ƒç´ çš„åœ°å€ï¼›å¹¶ä¸”arrè¿™ä¸ªæ•°ç»„åéœ€è¦è¿›è¡Œä¸¤æ¬¡è§£å¼•ç”¨æ“ä½œï¼Œæ‰å¯ä»¥è¡¨ç¤ºæ•°ç»„çš„å…ƒç´ ã€‚å®žé™…ä¸Šï¼Œarrå°±æ˜¯åœ¨ test5 ä¸­å£°æ˜Žçš„æ•°ç»„æŒ‡é’ˆï¼Œæˆ‘ä»¬å¯ä»¥ç”¨ä¸‹é¢çš„ä»£ç æ¥éªŒè¯ï¼štest7123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; printf("arr = %p\n", arr); printf("arr + 1 = %p\n", arr + 1); printf("**arr = %d\n", **arr); printf("**(arr + 1) = %d\n", **(arr + 1)); return 0;&#125;/*out:arr = 0061FEFCarr + 1 = 0061FF08**arr = 1**(arr + 1) = 4*/ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå€Ÿç”¨äº†ä¸€ç»´æ•°ç»„ä¸ŽæŒ‡é’ˆçš„æŠ€å·§ï¼Œå°†arræŒ‡é’ˆç§»åŠ¨äº†ä¸€ä¸ªåç§»é‡ï¼Œå¾—åˆ°äº†ä¸¤ä¸ªä¸åŒçš„åœ°å€ã€‚ã€‚è€Œä¸¤ä¸ªåœ°å€çš„å·®å€¼ï¼š$0061FEFC_{16} - 0061FF08_{(16)} = C_{(16)} = 12_{(10)}$ï¼Œè¿™ä¸ª 12 æ­£å¥½å°±æ˜¯ 3 ä¸ªintçš„å¤§å°ï¼Œæ‰€ä»¥**(arr + 1) = 4ã€‚ çŽ°åœ¨ï¼Œæˆ‘ä»¬å°±å¯ä»¥å†™å‡ºä¸‹é¢çš„ä»£ç äº†ï¼štest812345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int (*parr)[3] = arr; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", parr[i][j]); putchar('\n'); &#125; return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ æˆ–è€…æ˜¯ï¼štest912345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; int (*parr)[3] = arr; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", *(*(parr + i) + j)); putchar('\n'); &#125; return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ ç±»ä¼¼çš„ç”¨æ³•ï¼Œå…¶å®žéƒ½æ˜¯å·®ä¸å¤šçš„ã€‚ æ•°ç»„ä¼ å‚æŽ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬åœ¨è€ƒè™‘å¦‚ä½•åœ¨å‡½æ•°ä¸­ä¼ å…¥æ•°ç»„çš„é—®é¢˜ã€‚å°±ä¸€ç»´æ•°ç»„è€Œè¨€ï¼Œç›´æŽ¥åˆ©ç”¨ä¸€ä¸ªæŒ‡é’ˆå³å¯ï¼Œæ¯”å¦‚ï¼štest10123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int *a, int size) &#123; for(int i = 0; i &lt; size; i++) printf("%d ", *(a + i)); putchar('\n');&#125;int main() &#123; int arr[3] = &#123;1, 2, 3&#125;; fun(arr, 3); return 0;&#125;/*out:1 2 3 */ å‡½æ•°çš„å£°æ˜Žä¹Ÿå¯ä»¥å†™æˆvoid fun(int a[], int size);ï¼Œè¿™æ ·å†™å…¶å®žæ›´æ–°é†’ç›®ã€‚åŒæ ·ï¼ŒäºŒç»´æ•°ç»„ä¹Ÿç±»ä¼¼ï¼Œä½†æ˜¯éœ€è¦æŒ‡å®šç¬¬äºŒç»´çš„å¤§å°ï¼Œä¹Ÿå°±æ˜¯ï¼štest1112345678910111213141516171819202122#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int (*arr)[3]) &#123; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) printf("%d ", *(*(arr + i) + j)); putchar('\n'); &#125;&#125;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; fun(arr); return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ åŒæ ·ï¼Œå‡½æ•°çš„å£°æ˜Žä¹Ÿå¯ä»¥å†™æˆvoid fun(int arr[][3]);ã€‚ ä¸‹é¢ï¼Œæˆ‘ä»¬æ¥åšä¸€ä»¶æœ‰è¶£çš„äº‹æƒ…ï¼Œå…ˆçœ‹ä»£ç ï¼štest12123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void fun(int *arr) &#123; for(int i = 0; i &lt; 9; i++) printf("%d ", *(arr + i)); putchar('\n');&#125;int main() &#123; int arr[3][3] = &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;; fun(arr); return 0;&#125;/*out:1 2 3 4 5 6 7 8 9 */ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæˆ‘ä»¬æŠŠäºŒç»´æ•°ç»„çš„é¦–åœ°å€ï¼Œå½“ä½œä¸€ç»´æ•°ç»„çš„é¦–åœ°å€ä¼ ç»™å‡½æ•°ï¼Œå°½ç®¡ç¼–è¯‘æœ‰ warningsï¼Œä½†æ˜¯ç¨‹åºè¿è¡Œçš„ç»“æžœæ˜¯ç¬¦åˆé¢„æœŸçš„ã€‚ä¸ºä»€ä¹ˆä¼šå‡ºçŽ°è¿™ç§çŽ°è±¡å‘¢ï¼Ÿå®žé™…ä¸Šï¼ŒäºŒç»´æ•°ç»„åœ¨å†…å­˜ä¸­çš„å­˜å‚¨æ–¹å¼ä¸Žä¸€ç»´æ•°ç»„åˆ«æ— äºŒè‡´ï¼Œéƒ½æ˜¯ä¸€ä¸ªæŽ¥ä¸€ä¸ªé¡ºåºæŽ’åˆ—çš„ï¼Œè¿™ä¹Ÿå°±æ„å‘³ç€æˆ‘ä»¬å¯ä»¥åˆ©ç”¨å‰é¢æåˆ°çš„â€œåç§»é‡â€è¿™ä¸ªæ¦‚å¿µæ¥ç›´æŽ¥è¯»å–å†…å­˜ï¼Œè¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ã€‚è¿™å°±æ˜¯ C è¯­è¨€åŒºåˆ«äºŽ Java è¿™ç±»è¯­è¨€çš„åœ°æ–¹ï¼Œå®ƒå…è®¸ç¨‹åºå‘˜è‡ªå·±æ“ä½œå†…å­˜ï¼Œä½†å‰ææ˜¯ä½ è¦çŸ¥é“è‡ªå·±åœ¨å¹²ä»€ä¹ˆï¼Œä¼šå¾—åˆ°ä»€ä¹ˆæ ·çš„æ•ˆæžœï¼Œæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚åŒæ—¶ï¼Œä¸Šé¢è¿™ä¸ªä¾‹å­ï¼Œä¹Ÿå‘Šè¯‰æˆ‘ä»¬ï¼Œç¨‹åºä¸­çš„ warningsï¼Œä¸å¯å¿½ç•¥ï¼Œç¨ä¸æ³¨æ„å°±ä¼šäº§ç”Ÿé”™è¯¯ã€‚ å­—ç¬¦æ•°ç»„ä¸‹é¢ï¼Œå†å•ç‹¬çœ‹çœ‹å­—ç¬¦æŒ‡é’ˆæ•°ç»„ï¼Œå…ˆçœ‹ä¸‹é¢çš„ä»£ç ï¼štest1312345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *str1 = "How"; char str2[5] = "How"; printf("str1 = %s\n", str1); printf("str2 = %s\n", str2); str1 = "are"; // str2 = "are"; // error assignment printf("str1 = %s\n", str1); return 0;&#125;/*out:str1 = Howstr2 = Howstr1 = are*/ å‰é¢å·²ç»æåˆ°è¿‡æ•°ç»„åæ˜¯ä¸€ä¸ªå¸¸é‡ï¼Œæ‰€ä»¥è¿™é‡Œçš„str2å°±ä¸èƒ½ç›´æŽ¥è¢«èµ‹å€¼ï¼Œä½†æ˜¯str1ä»…ä»…åªæ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œå®ƒæ˜¯å¯ä»¥è¢«èµ‹å€¼çš„ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªè¿‡ç¨‹ä¹Ÿå¾ˆå®¹æ˜“æƒ³æ˜Žç™½ï¼Œé‡æ–°èµ‹å€¼str1æ— éžæ˜¯è¦è®©è¿™ä¸ªæŒ‡é’ˆå†æŒ‡å‘å¦å¤–ä¸€å—å†…å­˜å³å¯ï¼Œä½†é‡æ–°èµ‹å€¼str2æ„å‘³ç€è¦åœ¨å†…å­˜ä¸­æ‰¾ä¸€å—ä¸€æ ·å¤§å°çš„ç©ºé—´ï¼Œå¹¶å†™å…¥ä¸ŽåŽŸå…ˆç›¸åŒçš„å€¼ï¼Œè¿™æ˜¯å¾ˆå¤æ‚çš„äº‹æƒ…ã€‚ å°½ç®¡å­—ç¬¦æ•°ç»„æ— æ³•ç›´æŽ¥èµ‹å€¼ï¼Œä½†å­—ç¬¦æŒ‡é’ˆæ•°ç»„æ˜¯å¯ä»¥ç›´æŽ¥èµ‹å€¼çš„ï¼Œæ¯”å¦‚ï¼štest1412345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; char *str[4] = &#123;"I", "am", "a", "cat."&#125;; for(int i = 0; i &lt; 4; i++) printf("%s ", str[i]); putchar('\n'); str[3] = "mouse."; for(int i = 0; i &lt; 4; i++) printf("%s ", str[i]); putchar('\n'); return 0;&#125;/*out:I am a cat. I am a mouse.*/ æ€»ç»“èµ·æ¥ï¼Œä¹Ÿå°±æ˜¯ä¸€å¥è¯ï¼šæ•°ç»„åæ— æ³•ç›´æŽ¥è¢«èµ‹å€¼ï¼Œä½†æŒ‡é’ˆå¯ä»¥ç›´æŽ¥è¢«èµ‹å€¼ã€‚åœ¨è¿›è¡Œèµ‹å€¼æ“ä½œæ—¶ï¼Œæ³¨æ„åŒºåˆ†æ•°ç»„åå’ŒæŒ‡é’ˆå³å¯ã€‚ ç»“å°¾åˆ°è¿™é‡Œï¼Œæœ‰å…³å‡½æ•°ã€æŒ‡é’ˆå’Œæ•°ç»„ä¹‹é—´çš„åŸºæœ¬ç†è§£ï¼ŒåŸºæœ¬ä¸Šå·²ç»è¯´å®Œäº†ã€‚å…¶ä»–ä¸ŽæŒ‡é’ˆã€å‡½æ•°å’Œæ•°ç»„ç»„åˆä¸€èµ·ä½¿ç”¨çš„ä¸œè¥¿æœ¬è´¨ä¸Šä¹Ÿå°±æ˜¯å¤šå±‚æ¦‚å¿µçš„åµŒå¥—ä½¿ç”¨ï¼Œå¦‚æžœåŸºæœ¬æ¦‚å¿µæ‰Žå®žï¼Œä»”ç»†åˆ†æžä¹‹åŽä¹Ÿèƒ½å¾—å‡ºç»“æžœã€‚æ¯”å¦‚ä¸‹é¢ä¸¤ç§ï¼štest1512345678910111213141516#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main() &#123; int *(*funcp[3])(int); printf("sizeof(funcp) = %d\n", sizeof(funcp)); int (*(*funcp2)[3])(int); printf("sizeof(funcp2) = %d\n", sizeof(funcp2)); exit(0);&#125;/*out:sizeof(funcp) = 12sizeof(funcp2) = 4*/ æ ¹æ®sizeofå…³é”®å­—ï¼Œæˆ‘ä»¬å¯ä»¥çŸ¥é“ï¼Œfuncpæ˜¯æŒ‡å‘æŒ‡é’ˆå‡½æ•°çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œfuncp2æ˜¯æŒ‡å‘å‡½æ•°æŒ‡é’ˆæ•°ç»„çš„æŒ‡é’ˆã€‚ä¸å¾—ä¸è¯´ï¼ŒæŒ‡é’ˆçœŸçš„æ˜¯ä¸ªå¼ºå¤§çš„ä¸œè¥¿ã€‚å°½ç®¡å¦‚æ­¤ï¼ŒçœŸæ­£å†™ä»£ç çš„æ—¶å€™è¿™æ ·å†™ï¼Œå¤§æ¦‚çŽ‡ä¼šè¢«æ‰“çš„å¾ˆæƒ¨ðŸ¤£~å°½é‡ä¿æŒç®€å•ã€å¯è¯»æ€§é«˜çš„ä»£ç æ‰æ˜¯æ¯”èµ·ç‚«æŠ€æ›´åº”è¯¥å€¼å¾—è€ƒè™‘çš„äº‹æƒ…ã€‚ OKï¼Œåˆ°æ­¤ç»“æŸï¼ŒåŽç»­æƒ³åˆ°äº†å†è¡¥å……~]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_ä¹™çº§é¢˜åº“_1111-1115]]></title>
    <url>%2F2023%2F03%2F19%2FPAT-%E4%B9%99%E7%BA%A7%E9%A2%98%E5%BA%93-1111-1115%2F</url>
    <content type="text"><![CDATA[å¾ˆä¹…æ²¡æ¥ PAT äº†ï¼Œæ²¡æƒ³åˆ°ä¹™çº§é¢˜åº“æ–°å¢žäº† 5 é“é¢˜ðŸ˜~ç™¾åº¦äº†ä¸€ä¸‹ï¼Œå‘çŽ°è¿™æ˜¯ 2020 å¹´æ˜¥è€ƒ PAT çš„åŽŸé¢˜ï¼Œæ­£å¥½æ˜¯å‘¨æœ«çš„æ—¶é—´ï¼Œåšä¸€ä¸‹ã€‚ 1111 å¯¹ç§°æ—¥Analysisé¢˜æ„å¾ˆæ¸…æ™°ï¼ŒæŠŠå­—æ¯è½¬æ¢ä¸ºæ•°å­—ï¼Œç„¶åŽåˆ¤æ–­æ˜¯å¦æ˜¯å›žæ–‡ä¸²å³å¯ï¼Œæ‰€ä»¥éœ€è¦è§£å†³çš„é—®é¢˜æœ‰ä¸¤ä¸ªï¼š å­—æ¯è½¬æ¢ä¸ºæ•°å­—ï¼Œè¿™ä¸ªé—®é¢˜é¢˜åº“æœ‰ç±»ä¼¼çš„é¢˜ åˆ¤æ–­å›žæ–‡ä¸²ï¼Œè¿™æ˜¯ C è¯­è¨€çš„è¯¾åŽä¹ é¢˜ðŸ˜‚ æ³¨æ„è¿™ä¸ªé¢˜æœ‰ä¸ªç»†èŠ‚ï¼Œé»˜è®¤çš„æ ¼å¼æ˜¯YYYYMMDDï¼Œå¹´ã€æœˆã€æ—¥çš„ä½æ•°å·²ç»å®šæ­»äº†ï¼Œå¦‚æžœé‡åˆ°æŸä¸€é¡¹ä½æ•°ä¸å¤Ÿçš„æƒ…å†µï¼Œéœ€è¦è¡¥å‰å¯¼é›¶ï¼Œä¸å¦‚ 1 æœˆï¼Œåœ¨æ•´ä¸ªå­—ç¬¦ä¸²å†…æ˜¯01ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä¸ä»Žå­—ç¬¦ä¸²çš„è§’åº¦æ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œç›´æŽ¥ä»Žæ•°å­—çš„è§’åº¦æ¥æ€è€ƒä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ Codemethod 112345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; mon2num = &#123; &#123;"Jan", 1&#125;, &#123;"Feb", 2&#125;, &#123;"Mar", 3&#125;, &#123;"Apr", 4&#125;, &#123;"May", 5&#125;, &#123;"Jun", 6&#125;, &#123;"Jul", 7&#125;, &#123;"Aug", 8&#125;, &#123;"Sep", 9&#125;, &#123;"Oct", 10&#125;, &#123;"Nov", 11&#125;, &#123;"Dec", 12&#125;,&#125;;int main(int argc, char const *argv[]) &#123; char month[5]; int day, year, N; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d, %d", month, &amp;day, &amp;year); string str_mon = month; int mon = mon2num[month]; int n = year * 10000 + mon * 100 + day; string ans = to_string(n), rans; if(ans.length() == 7) ans = "0" + ans; if(ans.length() == 6) ans = "00" + ans; if(ans.length() == 5) ans = "000" + ans; rans = ans; reverse(rans.begin(), rans.end()); if(ans == rans) printf("Y "); else printf("N "); printf("%s\n", ans.c_str()); &#125; return 0;&#125; ä»Žæ•°å­—çš„è§’åº¦æ€è€ƒï¼Œæœ€åŽè¿˜æ˜¯è¦å›žå½’åˆ°å­—ç¬¦ä¸²ä¸Šï¼Œå› ä¸ºæœ€åŽè¿˜è¦åˆ¤æ–­å›žæ–‡ä¸²ã€‚ method 212345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, string&gt; mon2num = &#123; &#123;"Jan", "01"&#125;, &#123;"Feb", "02"&#125;, &#123;"Mar", "03"&#125;, &#123;"Apr", "04"&#125;, &#123;"May", "05"&#125;, &#123;"Jun", "06"&#125;, &#123;"Jul", "07"&#125;, &#123;"Aug", "08"&#125;, &#123;"Sep", "09"&#125;, &#123;"Oct", "10"&#125;, &#123;"Nov", "11"&#125;, &#123;"Dec", "12"&#125;, &#125;;int main(int argc, char const *argv[]) &#123; char month[5]; int day, year, N; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d, %d", month, &amp;day, &amp;year); string str_mon = month, str_day = to_string(day), str_year = to_string(year); if(str_day.length() == 1) str_day = "0" + str_day; if(str_year.length() == 1) str_year = "000" + str_year; else if(str_year.length() == 2) str_year = "00" + str_year; else if(str_year.length() == 3) str_year = "0" + str_year; string date = str_year + mon2num[str_mon] + str_day; string tmp = date; reverse(tmp.begin(), tmp.end()); if(date == tmp) printf("Y "); else printf("N "); printf("%s\n", date.c_str()); &#125; return 0;&#125; 1112 è¶…æ ‡åŒºé—´Analysisè¿™ä¸ªé¢˜æ˜¯ä¸ªç®€å•çš„æ»‘åŠ¨çª—å£ï¼ˆæˆ–è€…è¯´åŒæŒ‡é’ˆï¼‰é¢˜ç›®ï¼Œåˆ©ç”¨ç±»ä¼¼çš„æ€æƒ³å³å¯ã€‚è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆAå’ŒBï¼Œä»ŽAæŒ‡é’ˆè¿›å…¥å¾ªçŽ¯ï¼Œæ¯æ¬¡é‡åˆ°ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„æ•°å­—æ—¶ï¼Œåˆ©ç”¨BæŒ‡é’ˆä»Žå½“å‰çš„æ¨ªåæ ‡å¼€å§‹éåŽ†æ•°ç»„ï¼Œæ‰¾å‡ºè¿žç»­ç¬¦åˆçš„æ‰€æœ‰æ•°å­—ï¼Œè¿™æ ·å°±å¯ä»¥åˆ©ç”¨Aã€BæŒ‡é’ˆæ±‚å‡ºå½“å‰åŒºé—´äº†ï¼Œç„¶åŽå†æ›´æ–°å¾ªçŽ¯å˜é‡çš„å€¼ã€‚å”¯ä¸€éœ€è¦å¤šæ€è€ƒä¸€ä¸‹çš„è¾¹ç•Œæ˜¯å½“æ•°ç»„æœ€åŽä¸€ä¸ªå…ƒç´ ç¬¦åˆæ¡ä»¶æ—¶ï¼ŒBçš„å€¼æ˜¯æ•°ç»„çš„é•¿åº¦ï¼Œæ‰€ä»¥å¾ªçŽ¯æ¡ä»¶ä½¿ç”¨B &lt; Nå’ŒA &lt; Nå³å¯ï¼Œå®žé™…ä¸Šè¿™ä¸ªé¢˜ä¹Ÿè§„å®šäº†æ¨ªåæ ‡çš„å€¼æ˜¯$[0, N - 1]$ã€‚ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main(int argc, char const *argv[]) &#123; int N, T; vector&lt;int&gt; v; cin &gt;&gt; N &gt;&gt; T; v.resize(N); for(int i = 0; i &lt; N; i++) cin &gt;&gt; v[i]; int A = 0; bool flag = false; while(A &lt; N) &#123; int B = A; while(B &lt; N &amp;&amp; v[B] &gt; T) B++; if(B &gt; A) &#123; cout &lt;&lt; "[" &lt;&lt; A &lt;&lt; ", " &lt;&lt; B - 1 &lt;&lt; "]" &lt;&lt; endl; A = B; flag = true; &#125; else A++; &#125; if(!flag) cout &lt;&lt; *max_element(v.begin(), v.end()); return 0;&#125; 1113 é’±ä¸²å­çš„åŠ æ³•Analysisä¸å¤šè¯´äº†ï¼Œä¸€ä¸ªå¸¸è§„çš„è¿›åˆ¶è½¬æ¢é¢˜åž‹ï¼Œä»Ž 16 è¿›åˆ¶æ¢æˆäº† 30 è¿›åˆ¶è€Œå·²ã€‚éœ€è¦æ³¨æ„çš„ä¸€ä¸ªæµ‹è¯•ç‚¹æ˜¯è¾“å…¥å¤šä¸ª0çš„æƒ…å†µï¼Œæ¯”å¦‚è¾“å…¥000å’Œ000ï¼Œæœ€åŽç»“æžœä¸æ˜¯000ï¼Œè€Œæ˜¯0ï¼Œæ‰€ä»¥éœ€è¦åˆ é™¤æœ€åŽç»“æžœä¸­çš„å‰å¯¼ 0ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, char&gt; num2char = &#123; &#123;0, '0'&#125;, &#123;1, '1'&#125;, &#123;2, '2'&#125;, &#123;3, '3'&#125;, &#123;4, '4'&#125;, &#123;5, '5'&#125;, &#123;6, '6'&#125;, &#123;7, '7'&#125;, &#123;8, '8'&#125;, &#123;9, '9'&#125;, &#123;10, 'a'&#125;, &#123;11, 'b'&#125;, &#123;12, 'c'&#125;, &#123;13, 'd'&#125;, &#123;14, 'e'&#125;, &#123;15, 'f'&#125;, &#123;16, 'g'&#125;, &#123;17, 'h'&#125;, &#123;18, 'i'&#125;, &#123;19, 'j'&#125;, &#123;20, 'k'&#125;, &#123;21, 'l'&#125;, &#123;22, 'm'&#125;, &#123;23, 'n'&#125;, &#123;24, 'o'&#125;, &#123;25, 'p'&#125;, &#123;26, 'q'&#125;, &#123;27, 'r'&#125;, &#123;28, 's'&#125;, &#123;29, 't'&#125;,&#125;;unordered_map&lt;char, int&gt; char2num = &#123; &#123;'0', 0&#125;, &#123;'1', 1&#125;, &#123;'2', 2&#125;, &#123;'3', 3&#125;, &#123;'4', 4&#125;, &#123;'5', 5&#125;, &#123;'6', 6&#125;, &#123;'7', 7&#125;, &#123;'8', 8&#125;, &#123;'9', 9&#125;, &#123;'a', 10&#125;, &#123;'b', 11&#125;, &#123;'c', 12&#125;, &#123;'d', 13&#125;, &#123;'e', 14&#125;, &#123;'f', 15&#125;, &#123;'g', 16&#125;, &#123;'h', 17&#125;, &#123;'i', 18&#125;, &#123;'j', 19&#125;, &#123;'k', 20&#125;, &#123;'l', 21&#125;, &#123;'m', 22&#125;, &#123;'n', 23&#125;, &#123;'o', 24&#125;, &#123;'p', 25&#125;, &#123;'q', 26&#125;, &#123;'r', 27&#125;, &#123;'s', 28&#125;, &#123;'t', 29&#125;,&#125;;void trimRightZero(string &amp;num) &#123; for(auto it = num.rbegin(); it != num.rend(); it++) if(*it == '0') num.pop_back(); else break;&#125;int main() &#123; string num1, num2, sum; cin &gt;&gt; num1 &gt;&gt; num2; reverse(num1.begin(), num1.end()); reverse(num2.begin(), num2.end()); int index = 0, carry = 0; while(index &lt; num1.length() || index &lt; num2.length()) &#123; int tmp1 = index &lt; num1.length() ? char2num[num1[index]] : 0; int tmp2 = index &lt; num2.length() ? char2num[num2[index]] : 0; int s = tmp1 + tmp2 + carry; carry = s / 30; s %= 30; sum.push_back(num2char[s]); index++; &#125; if(carry) sum.push_back(num2char[carry]); trimRightZero(sum); reverse(sum.begin(), sum.end()); if(sum == "") sum = "0"; cout &lt;&lt; sum &lt;&lt; endl; return 0;&#125; ä»£ç ä¸­çš„ map å¯ä»¥ä½¿ç”¨ç®€å•çš„intæ•°ç»„å’Œcharæ•°ç»„æ¥å®Œæˆã€‚ 1114 å…¨ç´ æ—¥Analysisé¢˜æ„å¾ˆæ˜Žç¡®äº†ï¼Œéœ€è¦è§£å†³ä¸¤ä¸ªé—®é¢˜ï¼š é€ä¸ªæ‹†åˆ†å‡ºæ‰€æœ‰çš„æ•°å­—æƒ…å†µ åˆ¤æ–­æ˜¯å¦æ˜¯ç´ æ•° é’ˆå¯¹ç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œç›´æŽ¥ç”¨ string å®¹å™¨æ¥å®Œæˆå³å¯ã€‚è€Œç¬¬äºŒä¸ªé—®é¢˜ï¼Œæœ€å¤§çš„æ•°ä¹Ÿä¸è¿‡ 99991231ï¼Œç›´æŽ¥åˆ¤æ–­ä¹Ÿæ˜¯ä¸ä¼šè¶…æ—¶çš„ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;string&gt;using namespace std;bool isPrime(int num) &#123; if(num &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(num); i++) if(num % i == 0) return false; return true;&#125;int main(int argc, char const *argv[]) &#123; string date; cin &gt;&gt; date; int index = 0, len = date.length(); bool flag = true; while(index &lt; len) &#123; string num = date.substr(index); int n = stoi(num); if(isPrime(n)) cout &lt;&lt; num &lt;&lt; " Yes" &lt;&lt; endl; else &#123; cout &lt;&lt; num &lt;&lt; " No" &lt;&lt; endl; flag = false; &#125; index++; &#125; if(flag) cout &lt;&lt; "All Prime!" &lt;&lt; endl; return 0;&#125; 1115 è£åˆ¤æœºAnalysisé¢˜ç›®ç•¥é•¿ï¼Œå®žé™…ä¸Šæ˜¯å†™ä¸€ä¸ªç±»ä¼¼æ•°å­—æŽ¥é¾™çš„æ¸¸æˆï¼Œè¦æ±‚å°±æ˜¯é¢˜ç›®çš„è¦æ±‚äº†ã€‚ä¸€å¼€å§‹ä»¥ä¸ºæ˜¯ä¸ªæ¨¡æ‹Ÿé¢˜ï¼Œæ‰€ä»¥ç›´æŽ¥æ¨¡æ‹Ÿäº†ï¼Œä½†æ˜¯æœ‰ä¸ª 4 åˆ†æµ‹è¯•ç‚¹è¿‡ä¸åŽ»ã€‚ä»”ç»†ä¸€æƒ³ï¼Œåº”è¯¥è¿˜å¾—æœ‰ç‚¹å“ˆå¸Œçš„æ€è·¯ï¼Œæ¢äº†åŽï¼Œç»“æžœå†…å­˜è¶…é™äº†ã€‚å¥½å§ï¼Œçœ‹æ¥æ˜¯æ˜Žç¡®ç¦æ­¢ä½¿ç”¨æ¯”è¾ƒå¤§çš„å®¹å™¨äº†ï¼Œåªå¥½åˆ©ç”¨intæ•°ç»„ä»£æ›¿ unordered_map äº†ï¼Œå†æ¬¡æäº¤ï¼ŒACã€‚ Codeversion 1è¿™æ˜¯ç¬¬ä¸€ç‰ˆä»£ç äº†ï¼Œå†™çš„è‡­é•¿è‡­é•¿çš„ï¼Œæ€è·¯ä¸å¤Ÿç®€æ´ï¼Œå°±æ˜¯çº¯çº¯çš„æ¨¡æ‹Ÿï¼Œæœ€åŽæ˜¯æµ‹è¯•ç‚¹ 5 è¶…æ—¶äº†ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;cstdio&gt;#include &lt;unordered_map&gt;#include &lt;set&gt;#include &lt;vector&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;unordered_map&lt;int, set&lt;int&gt;&gt; number2diff;bool player[15] = &#123;false&#125;;int main(int argc, char const *argv[]) &#123; int init1, init2; scanf("%d %d", &amp;init1, &amp;init2); set&lt;int&gt; st1, st2; if(init1 &gt; init2) st1.insert(init1 - init2); else st2.insert(init2 - init1); number2diff.insert(&#123;init1, st1&#125;); number2diff.insert(&#123;init2, st2&#125;); scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) for(int j = 1; j &lt;= M; j++) scanf("%d", &amp;matrix[i][j]); for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(number2diff.find(tmp) != number2diff.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; for(auto &amp;p: number2diff) &#123; auto it = p.second.lower_bound(tmp); if(it != p.second.end() &amp;&amp; *it == tmp) &#123; flag = true; break; &#125; &#125; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; set&lt;int&gt; st; for(auto &amp;p: number2diff) &#123; if(p.first &lt; tmp) st.insert(tmp - p.first); &#125; number2diff.insert(&#123;tmp, st&#125;); for(auto &amp;p: number2diff) &#123; if(p.first &gt; tmp) &#123; p.second.insert(p.first - tmp); &#125; &#125; &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 2ç¬¬äºŒç‰ˆä»£ç ï¼Œä½¿ç”¨äº†ä¸€ç‚¹å“ˆå¸Œçš„æ€è·¯ã€‚è¿™ä¸ªæ€è·¯çš„æ¥æºæ˜¯çªç„¶å‘çŽ°é¢˜ç›®åªè¦æ±‚æ¯ä¸ªäººç»™å‡ºæ•°å­—ä¸èƒ½é‡å¤å‡ºçŽ°ï¼Œå¹¶æœªè¦æ±‚æ•°å­—ä¹‹é—´çš„å·®å€¼ä¸èƒ½é‡å¤å‡ºçŽ°ã€‚é‚£ä¹ˆï¼Œåªéœ€è¦è®°å½•æ¯ä¸ªäººæ¯å›žåˆç»™å‡ºæ•°å­—ä¹‹å‰çš„æ‰€æœ‰å·®å€¼æ˜¯å¦å‡ºçŽ°ï¼Œç„¶åŽå†æ»¡è¶³ï¼š å½“å‰ç»™å‡ºçš„æ•°å­—ä¸Žä¹‹å‰ç»™å‡ºçš„æ•°å­—ä¸é‡å¤ å½“å‰ç»™å‡ºçš„æ•°å­—ä¸Žä¹‹å‰ç»™å‡ºçš„æ•°å­—çš„å·®å€¼å­˜åœ¨ ä¸ºäº†æ–¹ä¾¿èµ·è§ï¼Œä½¿ç”¨ unordered_set æ¥å½“ä½œ hashmapï¼Œä½†æ˜¯ä¸‹é¢è¿™æ®µä»£ç è¿˜æ˜¯è¶…æ—¶äº†ã€‚ä¼°è®¡å§¥å§¥æ˜¯é“äº†å¿ƒä¸è®©ç”¨å®¹å™¨äº†...ðŸ¤£123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;unordered_set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;set&lt;int&gt; num;unordered_set&lt;int&gt; diff;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); num.insert(N); num.insert(M); diff.insert(abs(N - M)); scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num.find(tmp) != num.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff.find(tmp) != diff.end()) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: num) diff.insert(abs(i - tmp)); num.insert(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 3æ³¨æ„åˆ°é¢˜ç›®ç»™å®šæ•°å­—çš„èŒƒå›´åœ¨$[1, 10^5]$ï¼Œæ‰€ä»¥å¯ä»¥ç”¨ä¸€ä¸ªintæ•°ç»„æ¥å½“ä½œ hashmapã€‚ä¸è¿‡ï¼Œè¿™æ®µä»£ç ä¹Ÿæ˜¯ 320ms å·¦å³é€šè¿‡æµ‹è¯•ç‚¹ 5 çš„ï¼Œæ˜¯ä¸æ˜¯è¿˜å¯ä»¥ä¼˜åŒ–ä¸‹ï¼Ÿæœ€å®¹æ˜“æƒ³åˆ°çš„ä¼˜åŒ–æ–¹å¼å°±æ˜¯å°† set æ›¿æ¢ä¸º unordered_setï¼Œå“ˆå“ˆï¼Œè¯•äº†ä¸‹ï¼Œæµ‹è¯•ç‚¹ 5 çš„æ—¶é—´æˆäº† 170ms äº†ðŸ˜‚ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;set&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;set&lt;int&gt; num;const int MAXN = 100000 + 5;int diff[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); num.insert(N); num.insert(M); diff[abs(N - M)] = true; scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num.find(tmp) != num.end()) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff[tmp] == true) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: num) diff[abs(i - tmp)] = true; num.insert(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; version 4ä»”ç»†æƒ³äº†ä¸‹ï¼Œå‰é¢æåˆ°äº†æ¯ä¸ªäººæå‡ºçš„æ•°å­—ä¸èƒ½ä¸Žä¹‹å‰çš„æ•°å­—é‡å¤ï¼Œé‚£è¿™ä¸ªé—®é¢˜ä¸è¿˜æ˜¯ hashmap çš„é—®é¢˜å—ðŸ˜‚ï¼Ÿæ‰€ä»¥ï¼Œä½¿ç”¨ä¸¤ä¸ª hashmap æ¥è®°å½•æ•°å­—å’Œå·®å€¼æ˜¯å¦å‡ºçŽ°ï¼Œå†ç”¨ä¸€ä¸ª vector æ¥ä¿å­˜å‡ºçŽ°è¿‡çš„æ•°å­—å³å¯ã€‚æäº¤äº†ä¸‹ï¼Œæµ‹è¯•ç‚¹ 5 è€—æ—¶æ‰ 50ms ï¼Œè¿˜æ˜¯ C è¯­è¨€å¥½ä½¿ðŸ˜†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int matrix[15][1005] = &#123;0&#125;, N, M;bool player[15] = &#123;false&#125;;const int MAXN = 100000 + 5;vector&lt;int&gt; nums;bool num[MAXN] = &#123;false&#125;, diff[MAXN] = &#123;false&#125;;int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;M); nums.push_back(N), nums.push_back(M); num[N] = 1, num[M] = 1; diff[abs(N - M)] = true; scanf("%d %d", &amp;N, &amp;M); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; for(int j = 1; j &lt;= M; j++) &#123; for(int i = 1; i &lt;= N; i++) &#123; int tmp = matrix[i][j]; if(player[i] == true) continue; if(num[tmp] == true) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; bool flag = false; if(diff[tmp] == true) flag = true; if(!flag) &#123; printf("Round #%d: %d is out.\n", j, i); player[i] = true; &#125; else &#123; for(auto &amp;i: nums) diff[abs(i - tmp)] = true; num[tmp] = true; nums.push_back(tmp); &#125; &#125; &#125; &#125; vector&lt;int&gt; winner; for(int i = 1; i &lt;= N; i++) &#123; if(player[i] == false) winner.push_back(i); &#125; if(winner.size() == 0) printf("No winner.\n"); else &#123; printf("Winner(s):"); for(int &amp;i: winner) printf(" %d", i); &#125; return 0;&#125; å›žè¿‡å¤´æ¥å†çœ‹ï¼ŒæŒ‰ç…§ä¸Šé¢ä»£ç çš„é€»è¾‘ï¼Œåœ¨ nums ä¸­æ ¹æœ¬ä¸å¯èƒ½å‡ºçŽ°é‡å¤å…ƒç´ ï¼Œæ‰€ä»¥å‰é¢ä½¿ç”¨ set ç™½ç™½æµªè´¹äº†è‡ªåŠ¨åŽ»é‡çš„åŠŸèƒ½ï¼Œè¿˜æµªè´¹äº†æ—¶é—´ã€‚è€Œä¸”ï¼Œè¿™ä¸ªé¢˜åº”è¯¥ç®—ä½œä¸€é“è€ƒå¯Ÿæ•£åˆ—çš„é¢˜ç›®ï¼Œåªè¦èƒ½æƒ³åˆ°æ•£åˆ—è¿™ä¸ªçŸ¥è¯†ç‚¹ï¼ŒåŸºæœ¬å°±å¯ä»¥ AC äº†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C è¯­è¨€å‡½æ•°æŒ‡é’ˆçš„ä¸€äº›ç†è§£]]></title>
    <url>%2F2023%2F03%2F13%2FC-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E4%B8%80%E4%BA%9B%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[å‡½æ•°æŒ‡é’ˆå±žäºŽ C è¯­è¨€çš„è¿›é˜¶å†…å®¹ä¹‹ä¸€ï¼Œå‰ä¸¤å¤©ç ”ç©¶ tinyhttpd æ—¶ï¼Œç¢°åˆ°äº†å‡½æ•°æŒ‡é’ˆï¼Œäº§ç”Ÿäº†ä¸€äº›ç–‘é—®... æ™®é€šæŒ‡é’ˆåœ¨ç ”ç©¶å‡½æ•°æŒ‡é’ˆä¹‹å‰ï¼Œå…ˆå›žé¡¾ä¸€ä¸‹æ™®é€šæŒ‡é’ˆï¼Œå…ˆçœ‹ä¸‹é¢çš„ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;struct point &#123; int x, y;&#125;; int main(int argc, char const *argv[]) &#123; int a = 10, *pa = &amp;a; printf("*pa = %d, a = %d\n", *pa, a); float f = 1.0, *pf = &amp;f; printf("*pf = %f, f = %f\n", *pf, f); struct point A, *pA = &amp;A; A.x = 3, A.y = 3; printf("A.x = %d, A.y = %d\n", A.x, A.y); printf("pA-&gt;x = %d, pA-&gt;y = %d\n", pA-&gt;x, pA-&gt;y); printf("*pA.x = %d, *pA.y = %d\n", (*pA).x, (*pA).y); return 0;&#125;/*output:*pa = 10, a = 10*pf = 1.000000, f = 1.000000A.x = 3, A.y = 3pA-&gt;x = 3, pA-&gt;y = 3*pA.x = 3, *pA.y = 3sizeof(pa) = 4sizeof(pf) = 4sizeof(pA) = 4*/ ä»Žè¾“å‡ºç»“æžœå¯ä»¥çœ‹å‡ºï¼Œä¸ç®¡æ˜¯æ™®é€šå˜é‡çš„æŒ‡é’ˆï¼Œè¿˜æ˜¯ç»“æž„ä½“çš„æŒ‡é’ˆï¼Œéƒ½æ˜¯æ™®é€šçš„æŒ‡é’ˆå˜é‡ï¼Œè€ŒæŒ‡é’ˆçš„æœ¬è´¨å°±æ˜¯ä¿å­˜åœ°å€çš„å˜é‡ï¼Œé€šè¿‡è¿™ä¸ªåœ°å€å¯ä»¥æ‰¾åˆ°å¯¹åº”çš„å˜é‡ã€‚åˆ©ç”¨&amp;ç¬¦å·ï¼Œå¯ä»¥å¾—åˆ°å˜é‡çš„åœ°å€ä»Žè€Œèµ‹å€¼ç»™æŒ‡é’ˆå˜é‡ï¼Œè¿™æ ·è¿™ä¸ªæŒ‡é’ˆå˜é‡å°±æŒ‡å‘äº†ä½¿ç”¨&amp;è¿ç®—ç¬¦çš„å˜é‡ã€‚ å‡½æ•°æŒ‡é’ˆçŽ°åœ¨ï¼Œå›žåˆ°å¯¹å‡½æ•°æŒ‡é’ˆçš„æ€è€ƒä¸Šï¼Œé¦–å…ˆåº”è¯¥è¦è®¤è¯†çš„æ˜¯ï¼šå‡½æ•°æŒ‡é’ˆçš„æœ¬è´¨è¿˜æ˜¯æŒ‡é’ˆï¼Œå®ƒä¸Žæ™®é€šæŒ‡é’ˆæ²¡æœ‰ä»€ä¹ˆå·®åˆ«ï¼Œè¿˜æ˜¯æŒ‡é’ˆå˜é‡ï¼Œåªä¸è¿‡è¿™ä¸ªæŒ‡é’ˆå˜é‡æŒ‡å‘çš„æ˜¯å‡½æ•°ï¼Œå°±è·Ÿä¸åŒç±»åž‹çš„æŒ‡é’ˆå˜é‡æŒ‡å‘å¯¹åº”ç±»åž‹çš„å˜é‡ä¸€æ ·ã€‚é€šè¿‡ä¸Šé¢çš„ä»£ç ï¼Œæˆ‘ä»¬çŸ¥é“&amp;ç¬¦å·å¯ä»¥å–å‡ºä¸€ä¸ªå˜é‡çš„åœ°å€ï¼Œé‚£å‡½æ•°çš„åœ°å€æ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥è¿™æ ·å–å‡ºå‘¢ï¼Ÿå†™ä¸ªç¨‹åºæµ‹è¯•ä¸€ä¸‹ï¼štest11234567891011121314#include &lt;stdio.h&gt;void fun() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("&amp;fun = %p\n", &amp;fun); printf("sizeof(&amp;fun) = %d\n", sizeof(&amp;fun)); return 0;&#125;/*output:&amp;fun = 00401460sizeof(&amp;fun) = 4*/ å¯ä»¥å‘çŽ°ä½¿ç”¨&amp;ç¬¦å·çš„ç¡®å¯ä»¥è¾“å‡ºå‡½æ•°çš„åœ°å€ï¼ŒåŒæ—¶ä½¿ç”¨sizeofå…³é”®å­—å¾—åˆ°äº†â€œå–å‡ºçš„åœ°å€â€çš„å¤§å°ã€‚æŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œæˆ‘ä»¬çŸ¥é“è¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼Œä½†è¿™æ˜¯ä¸ªä»€ä¹ˆç±»åž‹çš„æŒ‡é’ˆï¼Œä¸çŸ¥é“ï¼Œä¸ºä»€ä¹ˆæ˜¯ 4ï¼Œä¹Ÿä¸çŸ¥é“ï¼Œä½†æˆ‘ä»¬å¯ä»¥å†å¤šå†™ç‚¹ä»£ç éªŒè¯ä¸€ä¸‹æ€è·¯ï¼štest2123456789101112131415161718#include &lt;stdio.h&gt;void fun() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("&amp;fun = %p\n", &amp;fun); printf("sizeof(&amp;fun) = %d\n", sizeof(&amp;fun)); int i = 10, *pi = &amp;i; printf("sizeof(&amp;i) = %d\n", sizeof(&amp;i)); printf("*pi = %d, sizeof(pi) = %d\n", *pi, sizeof(pi)); return 0;&#125;/*&amp;fun = 00401460sizeof(&amp;fun) = 4sizeof(&amp;i) = 4*pi = 10, sizeof(pi) = 4*/ çŽ°åœ¨ï¼Œå¯ä»¥å¾ˆæ¸…æ¥šçš„ç¡®å®šï¼Œåˆ©ç”¨&amp;å–å‡ºçš„å‡½æ•°çš„åœ°å€ä¸ŽæŒ‡é’ˆå˜é‡æ˜¯ä¸€æ ·ï¼Œå®ƒä»¬éƒ½æ˜¯ 4 ä¸ªå­—èŠ‚çš„å¤§å°ï¼Œé‚£ä¹ˆä¹Ÿå°±æ˜¯è¯´å‡½æ•°æŒ‡é’ˆä¹Ÿæ˜¯ä¸€ç§æŒ‡é’ˆå˜é‡ï¼Œè¿™ä¸Žå‰é¢çš„æ€è·¯æ˜¯ä¸€è‡´çš„ã€‚ äº†è§£å‡½æ•°æŒ‡é’ˆå¤§æ¦‚æ˜¯ä»€ä¹ˆæ ·å­çš„åŽï¼Œè‚¯å®šä¼šå†’å‡ºè¿™æ ·çš„é—®é¢˜ï¼šæ€Žä¹ˆä½¿ç”¨å‡½æ•°æŒ‡é’ˆå˜é‡æŒ‡å‘æŸä¸ªå‡½æ•°å‘¢ï¼Ÿæ¢å¥è¯è¯´ï¼Œå°±æ˜¯å¦‚ä½•åƒä½¿ç”¨int i, *a = &amp;i;è¿™æ ·ï¼Œå£°æ˜ŽæŸä¸ªæŒ‡é’ˆå˜é‡å¹¶æŒ‡å‘æŸä¸ªå‡½æ•°å‘¢ï¼Ÿ æ˜¾ç„¶ï¼Œè¿™ä¸ªé—®é¢˜ C è¯­è¨€è‚¯å®šæ˜¯æœ‰è§„å®šçš„ï¼Œå‡½æ•°æŒ‡é’ˆçš„å£°æ˜Žæ–¹å¼ä¸Žå‡½æ•°å£°æ˜Žæ˜¯ç±»ä¼¼çš„ï¼Œåªæ˜¯éœ€è¦åŠ ä¸Š*å’Œ()ã€‚åŒæ ·ï¼Œæˆ‘ä»¬ç”¨ä»£ç è¯´è¯ï¼štest31234567891011121314151617#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;int main(int argc, char const *argv[]) &#123; int (*pf)(int) = &amp;fun, a = 10; pf(a); return 0;&#125;/*output:In fun, a = 10*/ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œå£°æ˜Žäº†ä¸€ä¸ªå‡½æ•°æŒ‡é’ˆå˜é‡pfæŒ‡å‘å‡½æ•°funï¼Œç„¶åŽé€šè¿‡pfæŒ‡é’ˆï¼Œè°ƒç”¨äº†å‡½æ•°funï¼Œè¾“å‡ºaçš„å€¼ã€‚ç›¸æ¯”å‡½æ•°çš„å£°æ˜Žè€Œè¨€ï¼Œæœ‰ä¸¤ä¸ªç‰¹ç‚¹ï¼š çœç•¥äº†å‚æ•°åï¼Œä½†ä¸èƒ½çœç•¥å‚æ•°ç±»åž‹ï¼Œä¸”å¿…é¡»ä¸Žè¢«æŒ‡å‘çš„å‡½æ•°å‚æ•°ç±»åž‹ã€æ•°é‡ä¸€è‡´ éœ€è¦ç”¨*å’Œ()è®²æŒ‡é’ˆåæ‹¬èµ·æ¥ æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå¯ä»¥çŸ¥é“å‡½æ•°æŒ‡é’ˆçš„å£°æ˜Žæ–¹å¼æ˜¯[return-type] (*pointer-name)(parameter-list)ã€‚ çŽ°åœ¨ï¼Œæˆ‘ä»¬åœ¨ä¸Šé¢çš„ä»£ç ä¸­å°è¯•å°†å‡½æ•°æŒ‡é’ˆä½œä¸ºå‡½æ•°çš„å‚æ•°ä½¿ç”¨ï¼štest41234567891011121314151617181920#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;void func(int (*pf)(int)) &#123; int a = 10; pf(a);&#125;int main(int argc, char const *argv[]) &#123; func(&amp;fun); return 0;&#125;/*output:In fun, a = 10*/ test3 å’Œ test4 ä¸¤æ®µä»£ç çš„è¾“å‡ºç»“æžœæ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œä¸åŒçš„æ˜¯åœ¨ test4 ä¸­ï¼Œç›´æŽ¥ä½¿ç”¨å‡½æ•°æŒ‡é’ˆä½œä¸ºå¦ä¸€å‡½æ•°çš„å‚æ•°ï¼Œç„¶åŽåœ¨å¦ä¸€å‡½æ•°ä¸­é€šè¿‡å‡½æ•°æŒ‡é’ˆè°ƒç”¨è¿™ä¸ªå‡½æ•°ã€‚å¯ä»¥å‘çŽ°ï¼Œå‡½æ•°æŒ‡é’ˆä½œä¸ºå‡½æ•°å‚æ•°çš„å†™æ³•ä¸Žå…¶å£°æ˜Žæ²¡æœ‰å¤ªå¤§å·®å¼‚ã€‚ æ•°ç»„æŒ‡é’ˆçŽ°åœ¨æˆ‘ä»¬å†å›žé¡¾ä¸€ä¸‹æ•°ç»„æŒ‡é’ˆçš„ç”¨æ³•ï¼Œå…ˆçœ‹ä¸‹é¢çš„ä»£ç ï¼štest512345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;void fun(int *pa) &#123; printf("*pa = %d\n", *pa); printf("sizeof(pa) = %d\n", sizeof(pa));&#125;int main(int argc, char const *argv[]) &#123; int a[5] = &#123;1, 2, 3, 4, 5&#125;; fun(a); printf("sizeof(a) = %d\n", sizeof(a)); int (*parr)[5] = &amp;a; printf("a = %p, &amp;a = %p\n", a, &amp;a); printf("parr = %p\n", parr); printf("*parr = %d\n", *parr); printf("sizeof(&amp;a) = %d\n", sizeof(&amp;a)); printf("sizeof(parr) = %d\n", sizeof(parr)); return 0;&#125;/**pa = 1sizeof(pa) = 4sizeof(a) = 20a = 0061FF08, &amp;a = 0061FF08parr = 0061FF08*parr = 6422280sizeof(&amp;a) = 4sizeof(parr) = 4 æˆ‘ä»¬çŸ¥é“æ•°ç»„åå°±è¡¨ç¤ºæ•°ç»„çš„é¦–åœ°å€ï¼Œæ‰€ä»¥å¯ä»¥å°†æ•°ç»„åç›´æŽ¥ä½œä¸ºå‡½æ•°çš„å‚æ•°ï¼Œä»Žè€Œä¼ å…¥æ•°ç»„çš„åœ°å€ï¼Œä½†æ•°ç»„åå’ŒæŒ‡å‘æ•°ç»„çš„æŒ‡é’ˆæ˜¯ä¸¤ä¸ªå®Œå…¨ä¸åŒçš„ä¸œè¥¿ï¼Œè¿™ä¸€ç‚¹å¯ä»¥é€šè¿‡sizeofå…³é”®å­—çœ‹å‡ºï¼Œä¹Ÿå°±æ˜¯è¯´parrè·Ÿ&amp;aæ˜¯åŒä¸€ç±»äº‹ç‰©â€”â€”äºŒè€…éƒ½æ˜¯æ•°ç»„æŒ‡é’ˆï¼Œå¯¹åº”çš„å®ƒçš„ç±»åž‹å£°æ˜Žæ‰æ˜¯æ•°ç»„æŒ‡é’ˆçš„å£°æ˜Žï¼Œè€Œsizeofåˆ™è®¤ä¸ºaæ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œæ‰€ä»¥sizeof(a) = 20ã€‚ä»Žè¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œæ•°ç»„æŒ‡é’ˆçš„å£°æ˜Žä¸Žå‡½æ•°æŒ‡é’ˆç±»ä¼¼ï¼Œæœ‰ä¸¤ä¸ªæ¡ä»¶éœ€è¦æŒ‡å®šï¼š æ•°ç»„çš„ç±»åž‹ æ•°ç»„çš„ç»´åº¦ ä¸è¿‡ï¼Œå®žé™…ä¸Šï¼ŒC è¯­è¨€å­˜åœ¨éšå¼ç±»åž‹è½¬æ¢ï¼ˆè¿˜æœ‰å…¼å®¹è€ç‰ˆæœ¬å†™æ³•ä¹‹ç±»çš„åŽ†å²é—ç•™åŽŸå› ç­‰ï¼‰ï¼Œæ‰€ä»¥æœ‰æ—¶å€™å†™æ³•ä¸ä¸¥æ ¼ï¼Œç¼–è¯‘ä¹Ÿå¯ä»¥é€šè¿‡ï¼Œä½†ä¼šäº§ç”Ÿ warningsï¼Œæ€»ä¹‹å°½é‡ä¿æŒç±»åž‹ä¸€è‡´ï¼Œä¸è¦å‡ºçŽ° warningsã€‚ä½†è¿™é‡Œæœ‰æ„æ€çš„æ˜¯ï¼Œæ•°ç»„åä½œä¸ºåœ°å€å¯ä»¥ç›´æŽ¥ä½œä¸ºæŒ‡é’ˆä¼ ç»™å‡½æ•°ä½¿ç”¨ï¼Œé‚£å‡½æ•°åå‘¢ï¼Ÿå½“ç„¶ä¹Ÿå¯ä»¥äº†~é‚£ä¹ˆï¼Œtest4 çš„ä»£ç å¯ä»¥æ”¹æˆï¼štest4_112345678910111213141516171819202122#include &lt;stdio.h&gt;int fun(int a) &#123; printf("In fun, a = %d\n", a); return a;&#125;// void func(int (*pf)(int)) &#123;void func(int pf(int)) &#123; int a = 10; pf(a);&#125;int main(int argc, char const *argv[]) &#123; // func(&amp;fun); func(fun); return 0;&#125;/*output:In fun, a = 10*/ åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œæœ‰ä¸¤ä¸ªæ”¹åŠ¨çš„åœ°æ–¹ï¼š å‡½æ•°æŒ‡é’ˆåšå‚æ•°çš„å‡½æ•°å£°æ˜Žä¸­ï¼ŒåŽ»æŽ‰äº†* ç›´æŽ¥å°†å‡½æ•°åä½œä¸ºå‚æ•°ä¼ å…¥å¦ä¸€ä¸ªå‡½æ•°ä¸­ï¼ŒåŽ»æŽ‰äº†&amp; è™½ç„¶è¿™ä¸¤å¤„æ”¹åŠ¨éƒ½ä¸å½±å“ä½¿ç”¨ï¼Œä½†æ˜¯è¯»èµ·æ¥å®¹æ˜“å¼•èµ·æ··æ·†ï¼Œè¯­ä¹‰ä¸æ˜Žç¡®ï¼Œè¿™åº”è¯¥æ˜¯æŸç§â€œåŽ†å²é—ç•™å†™æ³•â€ï¼Œæœ€å¥½ä¸è¦è¿™æ ·å†™ã€‚å®žé™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡sizeofæ¥è§‚å¯Ÿä¸€ä¸‹å‡½æ•°åä¸Žå‡½æ•°æŒ‡é’ˆçš„å·®å¼‚ï¼Œå†æ·»å‡ è¡Œä»£ç ï¼štest612345678910111213#include &lt;stdio.h&gt;void func() &#123; &#125;int main(int argc, char const *argv[]) &#123; printf("sizeof(func) = %d, sizeof(&amp;func) = %d\n", sizeof(func), sizeof(&amp;func)); return 0;&#125;/*output:sizeof(func) = 1, sizeof(&amp;func) = 4*/ æ˜¾ç„¶ï¼Œä¸Žæ•°ç»„ç±»ä¼¼ï¼Œå‡½æ•°åä¸Žå‡½æ•°æŒ‡é’ˆä¹Ÿæ˜¯ä¸¤ä¸ªä¸åŒçš„ä¸œè¥¿ã€‚ æŒ‡é’ˆæ•°ç»„æŽ¥ä¸‹æ¥ï¼Œåœ¨çœ‹çœ‹æŒ‡é’ˆæ•°ç»„ï¼ˆåç€å«åˆæ˜¯å¦å¤–ä¸€ç§ä¸œè¥¿äº†ðŸ˜‚ï¼‰çš„ç”¨æ³•ï¼Œç›´æŽ¥çœ‹ä¸‹é¢çš„ä»£ç ï¼štest712345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int a = 10, b = 20; int *parr[2] = &#123;&amp;a, &amp;b&#125;; printf("%d, %d\n", *parr[0], *parr[1]); return 0;&#125; å…¶å®žå°±æ˜¯åœ¨æŒ‡é’ˆåŽé¢åŠ ä¸Šäº†[]ç¬¦å·ï¼Œå¯¹äºŽå…¶ä»–ç±»åž‹ä¹Ÿæ˜¯ä¸€æ ·çš„ç”¨æ³•ã€‚ å‡½æ•°æŒ‡é’ˆæ•°ç»„è¯´å®Œäº†å‡½æ•°æŒ‡é’ˆä¹Ÿæ•°ç»„æŒ‡é’ˆçš„åŒºåˆ«ï¼Œè§åˆ°äº†æŒ‡é’ˆæ•°ç»„çš„ç”¨æ³•ï¼ŒæŽ¥ä¸‹æ¥ï¼Œå†æ¥çœ‹çœ‹å¦‚ä½•ä½¿ç”¨å‡½æ•°æŒ‡é’ˆæ•°ç»„ã€‚å‡è®¾æˆ‘ä»¬è¦è®¡ç®—ä¸¤ä¸ªæ•´æ•°çš„å››åˆ™è¿ç®—ç»“æžœï¼Œä¸ºäº†ä½¿ç”¨åˆ°å‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œå…ˆå®šä¹‰å››ä¸ªå‡½æ•°ï¼Œç„¶åŽæ”¾åˆ°å‡½æ•°æŒ‡é’ˆæ•°ç»„ä¸­ï¼Œå†åˆ©ç”¨å‡½æ•°æŒ‡é’ˆæ•°ç»„é€ä¸ªè°ƒç”¨å‡½æ•°å®Œæˆè®¡ç®—ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯ä»¥å†™å‡ºä»¥ä¸‹ä»£ç ï¼štest81234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;int add(int a, int b) &#123; return a + b;&#125;int minus(int a, int b) &#123; return a - b;&#125;int mult(int a, int b) &#123; return a * b;&#125;int div(int a, int b) &#123; return a / b;&#125;int main(int argc, char const *argv[]) &#123; int a = 10, b = 10; int (*pfun[4])(int, int) = &#123;add, minus, mult, div&#125;; for(int i = 0; i &lt; 4; i++) printf("pfun[%d](a, b) = %d\n", i, pfun[i](a, b)); return 0;&#125;/*output:pfun[0](a, b) = 20pfun[1](a, b) = 0pfun[2](a, b) = 100pfun[3](a, b) = 1*/ å®žé™…ä¸Šï¼Œå‡½æ•°æŒ‡é’ˆæ•°ç»„ä¹Ÿå°±æ˜¯åœ¨å‡½æ•°æŒ‡é’ˆä¸­é—´åŠ ä¸Š[]ï¼Œè¿™ä¸ŽæŒ‡é’ˆæ•°ç»„æ˜¯ç±»ä¼¼çš„ã€‚ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯ï¼Œå‡½æ•°æŒ‡é’ˆæ•°ç»„åªèƒ½ä¿å­˜â€œåŒä¸€ç±»â€å‡½æ•°æŒ‡é’ˆï¼Œè€Œâ€œåŒä¸€ç±»â€åœ¨è¿™é‡Œæ˜¯æŒ‡è¿”å›žç±»åž‹å’Œå‚æ•°åˆ—è¡¨éœ€è¦ä¸€è‡´ã€‚ æ€»ç»“è™½ç„¶è¿™ç¯‡æ–‡ç« é¢˜ç›®å«åšå‡½æ•°æŒ‡é’ˆï¼Œä½†æ˜¯ç›®å‰æˆ‘ä»¬ä¸€å…±å­¦ä¹ äº†äº”ç§ä¸åŒçš„ä¸ŽæŒ‡é’ˆç›¸å…³çš„æ¦‚å¿µå’Œç”¨æ³•ï¼Œåˆ†åˆ«æ˜¯ï¼š æ™®é€šæŒ‡é’ˆ æ•°ç»„æŒ‡é’ˆ å‡½æ•°æŒ‡é’ˆ æŒ‡é’ˆæ•°ç»„ å‡½æ•°æŒ‡é’ˆæ•°ç»„ åŒæ—¶ï¼Œè¿˜è®¤è¯†åˆ°äº†æ•°ç»„åä¸Žæ•°ç»„æŒ‡é’ˆã€å‡½æ•°åä¸Žå‡½æ•°æŒ‡é’ˆçš„åŒºåˆ«ã€‚è¿™äº›éƒ½åªæ˜¯æŒ‡é’ˆç”¨æ³•çš„å†°å±±ä¸€è§’ï¼ŒæŒ‡é’ˆè¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç”¨æ³•ï¼Œæ¯”å¦‚é€šè¿‡æŒ‡é’ˆåœ¨å‡½æ•°ä¸­ä¿®æ”¹å®žå‚çš„å€¼ï¼Œæˆ–è€…æ˜¯åœ¨ C++ ä¸­ç”¨çˆ¶ç±»æŒ‡é’ˆæŒ‡å‘å­ç±»å¯¹è±¡ï¼Œè°ƒç”¨å­ç±»æ–¹æ³•ï¼Œä»Žè€Œå®žçŽ°åŠ¨æ€å¤šæ€ç­‰ç­‰ã€‚æ‰€ä»¥ï¼Œå­¦ä¹ ä¹‹è·¯è¿˜å¾ˆæ¼«é•¿å•Š~ðŸ˜ª]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Pointer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_02_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F03%2F05%2F2023-02-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[çŽ°åœ¨æ˜¯ 2023 å¹´ 3 æœˆ 5 æ—¥äº†...ðŸ˜‘ Dreams - The CranberriesYour browser does not support the audio tag. æœ¬æ¥æ‰“ç®—äºŒæœˆåº•å°±å†™å¥½è¿™ç¯‡ blog çš„ï¼Œä½†æ˜¯äºŒæœˆçš„æœ€åŽå‡ å¤©è¿˜æ˜¯å·¥ä½œæ—¥ï¼Œè®¡åˆ’å°±ææµ…äº†ï¼ˆå“ˆå“ˆï¼Œæ€»æ˜¯ä¸ºè‡ªå·±æ‰¾å€Ÿå£ï¼‰ã€‚ ç­‰ç­‰ï¼Œçªç„¶å‘çŽ°ä¸€æœˆçš„æ€»ç»“ä¹Ÿæ˜¯äºŒæœˆä¸­æ—¬æ‰å†™çš„...åºŸäº†ï¼Œå·²ç»æ˜¯æ‹–å»¶ç—‡æ™šæœŸäº†ðŸ¤ å“ˆå“ˆï¼Œä½†æ˜¯çŽ°åœ¨è®°å½•çš„æ˜¯äºŒæœˆçš„äº‹æƒ…ï¼Œå…¶ä»–çš„å°±ä¸åŽ»æƒ³äº†ã€‚ è¿™ä¸ªæœˆå·¥ä½œæ–¹é¢ä¸æ˜¯å¾ˆå¿™ï¼Œåªæœ‰æŠ•äº§çš„é‚£ä¸ªå‘¨æ ¼å¤–å¿™ä¸€äº›ï¼Œä½†æ˜¯æŠ•äº§ä¹‹åŽå°±æ²¡æœ‰ä»€ä¹ˆå…¶ä»–çš„äº‹æƒ…äº†ã€‚è¿™æ¬¡æŠ•äº§çš„ç‰ˆæœ¬ï¼Œç®—æ˜¯è‡ªå·±åšçš„ç¬¬äºŒä¸ªç‰ˆæœ¬äº†ã€‚ç›®å‰å¯¹æ•´ä¸ªé¡¹ç›®å¤§è‡´ä¸Šæœ‰äº†ä¸€å®šçš„æ€è·¯ï¼Œè‡³å°‘è§‚å¯Ÿ debug æ—¥å¿—çš„æ—¶å€™ï¼ŒçŸ¥é“ä»€ä¹ˆæ ·å­æ˜¯æ­£å¸¸çš„ï¼Œä»€ä¹ˆæ ·å­æ˜¯å¼‚å¸¸äº†ã€‚ä½†æ˜¯ï¼Œå¯¹é¡¹ç›®çš„æ•´ä½“ç»“æž„è¿˜æ˜¯ç¼ºä¹è®¤è¯†ï¼Œå¯¹å„ä¸ªéƒ¨åˆ†çš„ä½œç”¨å’Œé€šä¿¡ï¼Œè¿˜æ˜¯å¾ˆè¿·ç³Šã€‚ä½†æ˜¯ï¼Œè‡ªå·±è¿˜æ˜¯æƒ³åæ§½è¿™ä¸ªä»Žé›¶å‡ å¹´ä¸€ç›´ç»´æŠ¤åˆ°çŽ°åœ¨çš„ MFC åº”ç”¨ï¼Œè¿˜æ˜¯ç”¨ VC++6.0 å¼€å‘çš„ï¼ˆæ¯æ¬¡è¿›å…¥è¿™ä¸ª IDE éƒ½æœ‰ä¸€ç§å¿ƒç´¯çš„æ„Ÿè§‰ðŸ˜‚ï¼‰ï¼Œä»Žè¿™ä¸€ç‚¹ä¸Šçœ‹ï¼Œè¿™ä¸ªé¡¹ç›®å…¶å®žä¹Ÿå¿«æ²¡æœ‰ç»´æŠ¤çš„ä»·å€¼äº†ï¼ˆçŽ°åœ¨å°±æˆ‘ä¸€ä¸ªäººåœ¨ç»´æŠ¤è¿™ä¸ªé¡¹ç›®ï¼Œå¿ƒç´¯å•Š~ï¼‰ã€‚å®¢è§‚æ¥è®²ï¼Œåœ¨é‚£ä¸ª STL éƒ½æ²¡æœ‰çš„å¹´ä»£ï¼ŒMFC èƒ½æž„é€ å‡ºè¿™ä¹ˆå¤šçš„æ•°æ®ç»“æž„å®žåœ¨æ˜¯å¾ˆä¸å®¹æ˜“äº†ï¼Œè€Œå½“æ—¶ windows å¹³å°ä¸‹çš„ C/C++ é¡¹ç›®ä¸ç”¨ MFC å¯èƒ½å°±æ²¡åˆ«çš„å¯ä»¥ç”¨äº†ðŸ˜‚ã€‚ä½†æ˜¯ï¼Œæ—¶ä»£ä¹Ÿåœ¨å‘å±•ï¼ŒçŽ°åœ¨å¾—å‘å‰çœ‹äº†ï¼Œä¸ç®¡æ€Žä¹ˆæ ·ï¼Œè‡ªå·±å¯¹è¿™ä¸ªä¸œè¥¿ä¸€å®šè¦è®¤è¯†æ¸…é†’ï¼Œè¦å­¦ä¹ è‡ªå·±åº”è¯¥å­¦ä¹ çš„ä¸œè¥¿ï¼Œä¿æŒè‡ªèº«çš„ç«žäº‰åŠ›ã€‚ å¥½äº†ï¼Œä»¥ä¸Šæ˜¯å·¥ä½œæ–¹é¢ï¼Œä¸€åˆ‡éƒ½æŒ‰éƒ¨å°±ç­çš„è¿›è¡Œç€ã€‚ ä¸‹é¢æ˜¯ç”Ÿæ´»æ–¹é¢çš„äº‹æƒ…ï¼Œè¿™ä¸ªæœˆæœ«ï¼Œæ‰¾åˆ°äº†ä¸€ä¸ªå°å•é—´ï¼ˆåˆç§Ÿçš„ï¼‰ï¼Œè™½ç„¶è·Ÿæœ‹å‹åˆ†å¼€ä½äº†ï¼Œæœ‰äº›è®¸ä¸èˆï¼Œä½†æ˜¯è‡ªå·±çŽ°åœ¨ç¦»å·¥ä½œçš„åœ°æ–¹å¾ˆè¿‘ï¼Œè¿™ç‚¹çœŸçš„å¾ˆé¦™ï¼ˆè™½ç„¶æ•´ä¸ªç§Ÿæˆ¿çš„è¿‡ç¨‹ä¹Ÿæ˜¯ä¸€è¨€éš¾å°½äº†ï¼Œè¯¦æƒ…è§æ‰¾æˆ¿è®°ï¼‰ã€‚çŽ°åœ¨ä¸‹ç­çš„æ—¶é—´å¾ˆå……è¶³äº†ï¼Œäº”ç‚¹ä¸‹ç­ï¼Œåƒå®Œæ™šé¥­ï¼Œåˆ°ä½çš„åœ°æ–¹æ‰å…­ç‚¹ï¼Œå°±æœ‰å¾ˆå¤šæ—¶é—´å¯ä»¥å¹²è‡ªå·±çš„äº‹æƒ…äº†ï¼Œæ„Ÿè§‰çŽ°åœ¨å¼¹ç´éƒ½æœ‰å¤§æŠŠæ—¶é—´äº†ï¼Œå“ˆå“ˆã€‚è€Œä¸”æ—©ä¸Šä¹Ÿä¸ç”¨èµ·çš„é‚£ä¹ˆæ—©äº†ï¼Œä¸è¿‡æ—©ç¡æ—©èµ·çš„å¥½ä¹ æƒ¯è¿˜æ˜¯è¦ä¿æŒï¼Œå˜¿å˜¿ã€‚ è‡³äºŽå­¦ä¹ æ–¹é¢ï¼ŒNand2tetris è¿˜æœ‰ä¸¤ç¯‡ blog æ²¡æœ‰å†™ï¼Œè‡ªå·±çœŸçš„æ˜¯ä¸€æ‹–å†æ‹–äº†...ä¸è¿‡è‡ªå·±çŽ°åœ¨æ­£åœ¨çœ‹ TinyHttpd æ•´ä¸ªäºŒåå¹´å‰çš„æœåŠ¡å™¨é¡¹ç›®ã€‚æ²¡æƒ³åˆ°ï¼Œè¿™ä¸ªäºŒåä¸–çºªåˆçš„é¡¹ç›®æ‰€ä½¿ç”¨çš„è¯­æ³•ï¼Œç«Ÿç„¶è®©æˆ‘è§‰å¾—æ¯«æ— è¿å’Œæ„Ÿï¼ŒC è¯­è¨€æžœç„¶æ˜¯æœ€å¥½çš„è¯­è¨€ï¼Œå“ˆå“ˆ~è¿™ä¸ªæœˆæœ€å¥½èƒ½æŠŠ Nand2tetris è¿™ä¸ªè¯¾ç¨‹å®Œç»“äº†ï¼Œç„¶åŽæŠŠ TinyHttpd è¿™ä¸ªé¡¹ç›®çš„æºç ä¹Ÿè¯»å®Œï¼Œè¿™æ ·æˆ‘å°±æœ‰æ—¶é—´åŽ»è¯»åŽŸæ¥æ²¡è¯»å®Œçš„ Linux å†…æ ¸æºç ï¼ˆä¸ºä»€ä¹ˆè‡ªå·±æ¬ äº†è¿™ä¸ªå¤šè´¦å•ŠðŸ˜‚ï¼‰ã€‚æ€»è€Œè¨€ä¹‹ï¼Œèµ¶ç´§åŠ¨èµ·æ¥å§ï¼ŒçŽ°åœ¨ä¸€ä¸ªäººä½äº†ï¼Œå¯æ²¡äººæ‰“æ‰°äº†ï¼Œè€Œä¸”ä¸‰æœˆä»½çš„å·¥ä½œåº”è¯¥ä¹Ÿä¸å¿™ï¼ˆä¸¤ä¼šæœŸé—´ï¼Œå˜æ›´æ“ä½œå¾ˆå°‘ï¼‰ã€‚ å€¼å¾—ä¸€æçš„æ˜¯ï¼Œå¹¸å¥½æå‰æ¬è¿‡æ¥äº†ï¼Œä¸ç„¶å‘¨å…­æ¥æ‰“å¼€é‚£çœŸçš„æ˜¯å¾ˆéš¾å—å•Šã€‚å¦å¤–ï¼Œæœ‹å‹å° yï¼Œä¹Ÿæ¬ç¦»äº†åŽŸæ¥çš„æˆ¿å­ï¼Œæ¢äº†ä¸€ä¸ªä¾¿å®œç‚¹çš„åˆç§Ÿæˆ¿å­ï¼Œå°±åœ¨ä»–ä¸Šç­çš„å¯¹é¢ï¼ŒçœŸè¿‘å•Šï¼ BTWï¼Œåœ¨ä¸‰æœˆå¼€åˆï¼Œæ˜¥å¤©åˆ°æ¥çš„æ—¥å­ï¼Œæˆ‘å¥½åƒå¾—äº†æµæ„Ÿ...è€Œä¸”å°±æ˜¯è¿™ä¸¤å¤©çš„äº‹æƒ…ï¼ŒçœŸè›‹ç–¼å•Šï¼Œå¸Œæœ›è‡ªå·±å¿«ç‚¹å¥½ã€‚ æœ€åŽï¼Œè‡ªå·±åœ¨æé†’è‡ªå·±ä¸€ä¸‹ï¼Œåˆ«å¿˜äº†æŒ‰æ—¶å®Œæˆä»»åŠ¡~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‰¾æˆ¿è®°]]></title>
    <url>%2F2023%2F02%2F28%2F%E6%89%BE%E6%88%BF%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[ä¸çŸ¥ä¸è§‰æ¥åˆ°ä¸Šæµ·å·²ç»äº”ä¸ªæœˆäº†ï¼Œä¸Žæœ‹å‹å° y ä¹Ÿä¸€èµ·åº¦è¿‡äº†äº”ä¸ªæœˆ... ç»è¿‡äº†å››ä¸ªæœˆæ¯å¤©é•¿è¾¾ä¸‰ä¸ªå¤šå°æ—¶çš„é€šå‹¤ï¼Œç»ˆäºŽåœ¨å·¥ä½œè½¬æ­£ä¹‹åŽï¼Œå†³å®šæ¬åˆ°ä¸€ä¸ªç¦»ä¸Šç­åœ°ç‚¹è¿‘ä¸€ç‚¹çš„åœ°æ–¹äº†ã€‚äºŽæ˜¯ä¹Žï¼Œå‘¨äº”ä¸‹ç­ä¹‹åŽå°±åŽ»ä¹‹å‰è”ç³»å¥½çš„ä¸­ä»‹é‚£é‡Œçœ‹æˆ¿äº†ã€‚ ç¬¬ä¸€ä¸ªå‡ºåœºçš„æ˜¯ä¸€ä¸ªå…¬å¯“ä¸­ä»‹ï¼Œå°åŒºæˆ¿ï¼Œé¢ç§¯ä¸å¤§ï¼Œå•†ç”¨ç”µï¼Œ1900 ä¸€ä¸ªæœˆï¼Œæ°´ç½‘å¦ç®—ã€‚æ€»è€Œè¨€ä¹‹ï¼Œä¸€å¥è¯ï¼Œä¸ç®¡ç”¨ä¸ç”¨éƒ½è¦äº¤é’±ã€‚çœ‹ç€ä¸å¤§çš„æˆ¿é—´å’Œè¶…æ ‡çš„æ°´ç”µç½‘è´¹ï¼Œç›´æŽ¥å¦å†³ã€‚ç»“æžœäº‹åŽï¼Œè¿™ä½å…¬å¯“ä¸­ä»‹è¿˜å‘æ¶ˆæ¯è¯´è¿™ä¸ªä»·æ ¼éƒ½å·®ä¸å¤šï¼Œç­”æ›°è°¢è°¢ï¼Œå†è€ƒè™‘è€ƒè™‘ã€‚ ç¬¬ä¸€ä¸ªçœ‹å®Œäº†ï¼Œèµ°åœ¨å°åŒºå†…ï¼Œçœ‹åˆ°æ”¾åœ¨æ¤ç‰©ä¸Šçš„å¹¿å‘Šç‰Œâ€”â€”å¤§ä¸šä¸»ç›´ç§Ÿï¼Œé‚ç”µè¯ä¹‹ã€‚ä¸‰åˆ†é’ŸåŽï¼Œå‡ºçŽ°åœ¨çœ¼å‰çš„æ˜¯ä¸€ä½ä¸Šæµ·é˜¿å§¨ï¼Œç„¶åŽå°±é¢†æˆ‘åˆ°äº†å¥¹å®¶è‡ªå·±çš„æˆ¿å­ä¸­ã€‚è¯´æ˜¯è‡ªå®¶çš„ï¼Œå…¶å®žä¸€æ ·æ˜¯åˆç§Ÿæˆ¿ï¼Œä¸Žå…¶ä»–ä¸­ä»‹çš„æˆ¿å­åˆ«æ— äºŒè‡´ï¼Œå”¯ä¸€çš„ä¼˜ç‚¹æ˜¯ç‡ƒæ°”åšé¥­ï¼Œå¯åœ¨è¿™ä¸€ç‚¹ä¸Šï¼Œæˆ‘ä¸€ä»¶åšé¥­çš„å®¶ä¼™éƒ½æ²¡æœ‰ã€‚ä¸è¿‡å€¼å¾—ç§°é“çš„æ˜¯ï¼Œè¿™é—´åˆç§Ÿæˆ¿å¦å¤–ä¸¤ä¸ªå®¤å‹çœ‹ç€æ¯”è¾ƒè®²å¹²å‡€ï¼Œè¿™å¯¹æˆ‘æ¥è¯´æ˜¯ä¸ªå¥½æ¶ˆæ¯ã€‚è€Œä¸”ï¼Œè¿™ä¸ªæˆ¿å­çš„ç¼ºç‚¹å¾ˆæ˜Žæ˜¾â€”â€”æœåŒ—ï¼Œå¾ˆæš—ï¼Œæ²¡æœ‰é˜³å…‰ã€‚ä¸è¿‡å¯¹äºŽä¸Šç­æ—æ¥è®²ï¼Œè¿™å€’ä¸æ˜¯å¾ˆå¤§çš„é—®é¢˜ã€‚ä»”ç»†è¯¢ä»·ä¹‹åŽï¼Œæ‰çŸ¥é“å¾—è¦ 1600ï¼Œæ„Ÿè§‰è¿˜æ˜¯éš¾ä»¥æŽ¥å—ï¼Œç„¶åŽå°±èµ°äº†ã€‚ å›žåˆ°å°åŒºé—¨å£åŽï¼Œåˆçœ‹åˆ°åœ°ä¸Šçš„å¹¿å‘Šï¼Œçœ‹ç€ä¸Šé¢å†™çš„å•é—´ã€ç‹¬å«ï¼Œç‡ƒæ°”åšé¥­ï¼Œåªè¦ 1800 å·¦å³ï¼Œåˆæ‰“ç”µè¯è¯¢é—®ã€‚ç»“æžœåœ¨ç”µè¯é‡Œé¢ï¼Œä¸ç®¡é—®ä»€ä¹ˆéƒ½æ˜¯æœ‰ï¼Œç„¶åŽå°±æ˜¯é—®ä½ åœ¨å“ªé‡Œï¼Œå¸¦ä½ åŽ»çœ‹ã€‚äº”åˆ†é’Ÿä¹‹åŽï¼Œç«™åœ¨çœ¼å‰çš„æ˜¯ä¸¤ä½ä¸­å¹´å¦‡å¥³ï¼Œæˆ‘é—®æ˜¯ä¸æ˜¯ä¸­ä»‹ï¼Œè¯´ä¸æ˜¯ï¼Œæ˜¯äºŒæˆ¿ä¸œã€‚é¢†ç€æˆ‘åˆ°äº†ä¸€ä¸ªè€å°åŒºï¼Œå…ˆçœ‹äº†ä¸€ä¸ªå•é—´ï¼Œç ´çš„ä¸åƒæ ·å­äº†ï¼Œè¦ 1500ï¼Œè¢«æˆ‘ç›´æŽ¥å¦å†³ã€‚ç„¶åŽåˆå¸¦æˆ‘çœ‹äº†ä¸€ä»¶ç¨å¥½ä¸€ç‚¹çš„æˆ¿å­ï¼Œæ˜¯å•é—´ã€ç‹¬å«ï¼Œåˆç§Ÿåšé¥­ï¼Œè¦ä»· 2000ï¼Œæˆ‘ç›´æŽ¥èµ°ï¼Œç»“æžœè¢«æ‹‰å›žæ¥ï¼Œå•†é‡ä»·æ ¼ï¼Œè¿˜åˆ° 1800ï¼Œæœªæžœã€‚èµ°å‡ºæ¥ï¼Œçœ‹äº†çœ¼æ—¶é—´å·²ç»å…«ç‚¹äº†ï¼Œå‡†å¤‡å‘Šåˆ«è¿™ä¸¤ä½â€œäºŒæˆ¿ä¸œâ€å›žåŽ»äº†ï¼Œç»“æžœåˆè¢«å«å›žæ¥ï¼Œè¯´ä½ è¦å•¥æ ·çš„æˆ¿å­ï¼Œæˆ‘ä»¬ç»™ä½ æ‰¾ï¼Œç„¶åŽå°±çœ‹åˆ°å¥¹ä¿©å¿«é€Ÿç¿»åŠ¨ç€æ‰‹æœºçš„å¾®ä¿¡ç¾¤ï¼Œå…¶ä¸­ä¸€ä¸ªæ‰¾åˆ°äº†ï¼Œç›´æŽ¥æŠŠä»·æ ¼å‡½æ•°æ¥äº†ï¼Œè¢«å¦å¤–ä¸€ä¸ªæ­¢ä½äº†ï¼Œå¤§æ¦‚æ„æ€æ˜¯ä»·æ ¼è¯´é”™äº†ã€‚æˆ‘å¯»æ€ç€ï¼Œèƒ½ä¸èƒ½ä¸“ä¸šä¸€ç‚¹ï¼Œå“ˆå“ˆã€‚ðŸ¤£ æœ€ç»ˆï¼Œè¿˜æ˜¯å…ˆå›žå®¶äº†ã€‚ ä»¥ä¸Šæ˜¯å‘ç”Ÿåœ¨ 2 æœˆ 24 æ—¥å‘¨äº”ä¸‹ç­ä¹‹åŽçš„äº‹æƒ…ã€‚ ç­‰åˆ°ç¬¬äºŒå¤©åˆåŽ»æ‰¾æˆ¿å­äº†ï¼Œé¦–å…ˆæ‰¾åˆ°çš„æ˜¯ä¸€ä¸ªæ›¾ç»å¼€è´§è½¦çŽ°åœ¨æ˜¯ä¸­ä»‹çš„å¤§å”ï¼Œè¿™å¤§å”æ˜¯æ±Ÿè‹äººï¼Œå…ˆé¢†æˆ‘çœ‹äº†ä¸€ä¸ª 1300 çš„å°æˆ¿å­ï¼Œåªæœ‰ä¸€æ‰‡çª—æˆ·ï¼Œç‰¹åˆ«æš—ï¼Œè™½ç„¶æ˜¯ç‹¬å«ï¼Œä½†æ˜¯ç‹¬å«åœ¨æ¥¼æ¢¯ä¸‹é¢ï¼Œä¸ŠåŽ•æ‰€è¿˜å¾—ä¿¯èº«è¿›åŽ»ï¼ˆæˆ‘å®¹æ˜“ä¹ˆæˆ‘ðŸ˜‚ï¼‰ã€‚çœ‹ç€æˆ‘ä¸æ»¡æ„çš„æ ·å­ï¼Œå¤§å”åˆé¢†æˆ‘åŽ»äº†ä¸€ä¸ªç¨å¾®å¤§ç‚¹ï¼Œäº®å¾ˆå¤šçš„æˆ¿å­ï¼Œå¯æƒœè¦ä»· 2000ï¼Œé—®é¢˜æ˜¯ï¼Œæˆ‘ç”¨è¿™ 2000 ç§Ÿä¸ªå°åŒºæ¥¼ä¸é¦™å—ï¼Ÿè¿˜æŒ¤åœ¨æ°‘æˆ¿é‡Œå¹²å•¥ï¼ŸðŸ˜…è½¬èº«è°¢ç¦»å¤§å”äº†~ æœ¬æ¥ä»Šå¤©çš„ç›®æ ‡å°±æ˜¯æ°‘æˆ¿ï¼Œç›´æŽ¥æ‰«äº†ä¸ªé»„è½¦ï¼Œç»§ç»­æ°‘æˆ¿ä¹‹æ—…ã€‚å·¦æ‹å³æ‹ï¼Œé—¨ä¸Šçš„å¢™ä¸Šçš„å¹¿å‘Šç¡®å®žå¤šï¼Œä»”ç»†ä¸€çœ‹è¿™æˆ¿å­æ˜¯ä¸ªå…¬å¯“åž‹çš„ï¼Œæ¯«æ— ç–‘é—®ï¼Œå¢™ä¸Šçš„ç”µè¯æ˜¯äºŒæˆ¿ä¸œçš„...åŽæ¥é—®äº†ä¸€ä½æ­£åœ¨å¹²æ´»çš„å¤§çˆ·ï¼Œåœ¨å¤§çˆ·çš„å‘ŠçŸ¥ä¸‹ï¼Œè¿™é™„è¿‘æœ‰æˆ¿å­ï¼Œè¿˜æ˜¯ 900 ä¸€ä¸ªæœˆçš„ï¼Œæœ¬æƒ³è®©å¤§çˆ·å¸¦æˆ‘è¿‡åŽ»ï¼Œä½†æ˜¯å¤§çˆ·åœ¨æ¸…ç†è‡ªå®¶é™¢å­ï¼Œèƒ½å‘Šè¯‰æˆ‘è¿™äº›ä¿¡æ¯å·²ç»å¾ˆä¸é”™äº†ï¼ˆå¤§çˆ·è¯´çš„è¯å¤šåŠæ˜¯æ­£å¸¸çš„ä»·æ ¼ï¼‰ï¼Œå°±é“è°¢èµ°äººäº†ã€‚æ‰¾äº†ä¸€åœˆæ²¡æ‰¾åˆ°ï¼Œ åˆæ¢äº†ä¸ªæ‘å­è½¬ï¼Œç»“æžœåœ¨è¿™é‡Œç¢°åˆ°äº†ä¸€ä¸ªç§Ÿä½æ°‘æˆ¿åå‡ å¹´çš„äºŒæˆ¿ä¸œï¼ŒæŽ¥å¾…æˆ‘çš„æ˜¯æˆ¿ä¸œå„¿å­ï¼Œ97 å¹´ç”Ÿäººï¼Œä»”ç»†ä¸€èŠï¼Œä¸Šç­çš„åœ°æ–¹è¿˜éƒ½ä¸€æ ·ï¼Œé—®é—®æ˜¯ä¸æ˜¯æ‰“ç®—å°±å¾…åœ¨ä¸Šæµ·äº†ï¼Œç»“æžœå‘Šè¯‰å¥³æœ‹å‹æ€€å­•äº†ï¼Œå‡†å¤‡ä»Šå¹´å›žåŽ»äº†ï¼Œå¿ƒä¸­ä¸ç”±å¾—æ„Ÿæ…¨ï¼Œè¿˜æ˜¯ç•™ä¸ä¸‹æ¥... ä¸‹åˆï¼Œæ˜¨å¤©çš„å¤§ä¸šä¸»é˜¿å§¨ï¼Œåˆæ‰“ç”µè¯æ¥äº†ï¼Œé—®æˆ‘ç§Ÿä¸ç§Ÿï¼Œè¿˜æƒ³è®©å…¶ä»–ä¸­ä»‹å¸¦æˆ‘çœ‹çœ‹åˆ«çš„æˆ¿å­ã€‚å®žé™…ä¸Šï¼Œå¥¹æ˜¯æƒ³è®©å…¶ä»–ä¸­ä»‹ä¸ºå¥¹é€ åŠ¿ï¼Œå¥½è®©æˆ‘ç§Ÿå¥¹çš„æˆ¿å­ï¼Œæ‰€ä»¥ç”µè¯é‡Œï¼Œæˆ‘ç›´æŽ¥æŠŠä»·æ ¼ç»™å¥¹è¿˜åˆ°äº† 1400ï¼Œç»“æžœå¥¹ä¸ç­”åº”ï¼Œåªè¯´è®©æˆ‘è¿‡åŽ»ã€‚å®žé™…ä¸Šï¼Œæˆ‘æ˜¯æƒ³ç§Ÿè¿™ä¸ªæˆ¿å­çš„ï¼Œä½†æ˜¯ä»·æ ¼æ–¹é¢æˆ‘è®¤ä¸ºè¿˜æœ‰å›žæ—‹çš„ä½™åœ°ï¼Œå°±åŽ»äº†ã€‚åŽ»äº†ä¹‹åŽï¼Œæžœç„¶å¦‚æˆ‘æ‰€æ–™ï¼Œä¸­ä»‹è¦å¸¦æˆ‘åŽ»çœ‹æˆ¿å­ï¼Œä½†æ˜¯æˆ‘ç›´æŽ¥å©‰æ‹’äº†ï¼Œä¸€å£å’¬å®šè¿™æ˜¯æˆ‘ä¸Žè¿™ä½å¤§ä¸šä¸»çš„äº‹æƒ…ðŸ¤£ï¼Œç»“æžœåºŸäº†å¾ˆå¤šå£èˆŒï¼Œç»ˆäºŽåˆä»Ž 1400 å›žåˆ° 1480ï¼ˆåŽŸä»·æ˜¯ 1600ï¼‰ï¼Œè¿™ä½é˜¿å§¨æ‰è‚¯ç§Ÿç»™æˆ‘ï¼ŒçœŸéš¾ã€‚å®žé™…ä¸Šï¼Œé€šè¿‡å‰é¢çš„èŠå¤©å·²çŸ¥äº†è¿™ä½é˜¿å§¨åœ¨è¿™æœ‰ä¸‰å¥—æˆ¿å­ï¼Œè¿™ä¸ªå°åŒºçš„æˆ¿å­å‡ä»·åœ¨ 500 - 600 ä¸‡ä¹‹é—´ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä½é˜¿å§¨ä¹Ÿæ˜¯æ‹¥æœ‰åƒä¸‡èµ„äº§çš„äººäº†ï¼Œæ€Žä¹ˆå°±è¿™ä¹ˆéš¾è¿˜ä»·å‘¢ðŸ˜‚ã€‚ å®žé™…ä¸Šï¼Œæˆ‘å¾ˆç†è§£å¥¹çš„å¿ƒå¢ƒï¼ŒæŒ‰ç…§â€œå¸‚åœºä»·â€ï¼Œåˆæ˜¯å¹´è½»äººï¼Œè¿™ä»·æ ¼ä¸æ˜¯å¾ˆå®¹æ˜“æŽ¥å—å—ï¼Ÿä½†å¥¹è¶Šæ˜¯è¿™æ ·ï¼Œæˆ‘è¶Šæ˜¯è¦è¿˜ä»·ï¼Œå› ä¸ºæˆ‘å®žåœ¨ä¸æ˜Žç™½ä¸ºä»€ä¹ˆå¹´è½»äººå°±ä¸èƒ½è¿˜ä»·ï¼Œå°½ç®¡æˆ‘ä¹ŸçŸ¥é“ï¼Œå®žé™…ä¸Šæˆ‘å®Œå…¨æ²¡æœ‰å¿…è¦æµªè´¹æ—¶é—´åœ¨è¿™äº›äº‹æƒ…ä¸Šã€‚åœ¨è¿˜ä»·çš„è¿‡ç¨‹ä¸­ï¼Œé˜¿å§¨ä¹Ÿè¯´æˆ‘ä¸çˆ½å¿«ï¼Œå“ˆå“ˆï¼Œæˆ‘æ‰¿è®¤ï¼Œå¯è¶Šè¿™æ ·æˆ‘è¶Šæ˜¯è¦è¿˜ä»·ï¼ˆæˆ‘å¯èƒ½æœ‰å¤§ç—…ï¼Œå“ˆå“ˆðŸ˜ï¼‰ã€‚åŽæ¥ï¼Œæ•²å®šä»·æ ¼ä¹‹åŽï¼Œé˜¿å§¨åˆè¯´æˆ‘è›®æˆç†ŸðŸ¤£ã€‚ å®žé™…ä¸Šå½“åˆåœ¨è¿™ä¸ªå°åŒºæ‰¾æˆ¿ç¢°åˆ°äº†ä¸€ä¸Šæµ·å¤§çˆ·ï¼Œæ­£åœ¨ä¸Žä¸€ç¾¤ä¸Šæµ·å¤§å¦ˆä¾ƒå¤§å±±ï¼Œé—®äº†é—®å°åŒºæˆ¿ç§Ÿä¸€èˆ¬å¤šå°‘é’±ï¼Œç›´æŽ¥å‘Šè¯‰æˆ‘ 3000ï¼Œé¡¿æ—¶ï¼Œæˆ‘çš„é»‘äººé—®å·è„¸éƒ½å‡ºæ¥äº†ðŸ˜…ï¼Œå¿ƒé‡Œä¸ç”±å¾—æƒ³ï¼Œè¿™å°±æ˜¯ä¸Šæµ·å—ï¼Ÿå“ˆå“ˆ ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œå‡ºé—¨åœ¨å¤–æ‰“å·¥çš„äººè¿˜æ˜¯å¾ˆä¸å®¹æ˜“çš„ã€‚ æœ€åŽï¼Œä¸ç®¡æ˜¯ç§Ÿè¿˜æ˜¯ä¹°ï¼Œå¸Œæœ›å¤§å®¶éƒ½èƒ½æœ‰å¿ƒä»ªçš„ä½æ‰€ï¼Œæ­£æ˜¯å®‰å¾—å¹¿åŽ¦åƒä¸‡é—´ï¼Œå¤§åº‡å¤©ä¸‹å¯’å£«ä¿±æ¬¢é¢œå‘~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TinyHttpd_Reading_Notes]]></title>
    <url>%2F2023%2F02%2F20%2FTinyHttpd-Reading-Notes%2F</url>
    <content type="text"><![CDATA[TinyHttpd æ˜¯ J. David Blackstone äºŽ 1999 å¹´å†™çš„ä¸€ä¸ª 500 è¡Œå·¦å³çš„è¶…è½»é‡çº§ http serverï¼Œç”¨æ¥å­¦ä¹ æœåŠ¡å™¨çš„å·¥ä½œåŽŸç†ååˆ†ä¸é”™ã€‚ introæœ¬ç¯‡ blog ä¸ºè‡ªå·±å­¦ä¹  tinyhttpd è¿™ä¸ªæœåŠ¡å™¨å°é¡¹ç›®æ‰€å†™çš„å­¦ä¹ ç¬”è®°ï¼Œå†…å®¹ä¸å¤šï¼Œä½†å¾ˆç»†è‡´ã€‚å¦å¤–ï¼Œæœ¬æ–‡æ‰€ä½¿ç”¨çš„æºç æ¥è‡ªäºŽTiny HTTPdâ€™s tiny homepageï¼ŒæŒ‰ç…§æºç ä¸­çš„æ³¨é‡Šï¼Œä¿®æ”¹æŽ‰å¯¹åº”çš„éƒ¨åˆ†å°±å¯ä»¥åœ¨ Linux ä¸Šè¿è¡Œäº†ã€‚å®žé™…ä¸Šï¼ŒæŒ‰ç…§æ³¨é‡Šä¿®æ”¹çš„ç‰ˆæœ¬æ˜¯ä¸ªæ— çº¿ç¨‹ç‰ˆçš„ tinyhttpdï¼Œè€ŒçŽ°åœ¨ Linux ä¹Ÿæœ‰äº†pthread.hè¿™ä¸ªå¤´æ–‡ä»¶ï¼Œä¹Ÿå°±å¯ä»¥ä½¿ç”¨pthread_createå‡½æ•°ï¼ˆè¿™ä¸ªå‡½æ•°å¯ä»¥åˆ›å»ºçº¿ç¨‹ï¼‰äº†ï¼Œä½†åœ¨æºç åŸºç¡€ä¸Šï¼Œä»ç„¶éœ€è¦åšä¸€äº›å°ä¿®æ”¹æ‰å¯ä»¥è¿è¡Œã€‚ å¦‚æžœè¦åœ¨ Linux ä¸Šä½¿ç”¨çº¿ç¨‹å‡½æ•°pthread_createï¼Œåœ¨è¿›è¡Œä¸‹é¢çš„æ”¹åŠ¨ä¹‹å‰ï¼Œå¿½ç•¥æŽ‰æºç æœ¬æ¥çš„æç¤ºä¿®æ”¹æ³¨é‡Šã€‚ é¦–å…ˆæ˜¯accept_requestå‡½æ•°ï¼Œéœ€è¦ä¿®æ”¹å‡½æ•°çš„å£°æ˜Žå’Œå®šä¹‰çš„å±€éƒ¨å†…å®¹ï¼ˆå…·ä½“å¯ä»¥å‚è€ƒåŽé¢è´´å‡ºæ¥çš„æºç ï¼‰ï¼šaccept_request12345678- void accept_request(int);+ void *accept_request(void *);+ void *accept_request(void *pclient) &#123; ...+ return NULL; ...+ return NULL;+ &#125; æŽ¥ç€åœ¨accept_requestå‡½æ•°å†…ç¬¬ä¸€è¡Œå†æ·»åŠ int client = *(int*)pclient;å³å¯ï¼ŒåŽé¢ä¼šè§£é‡ŠåŽŸå› ã€‚ ç„¶åŽåœ¨mainå‡½æ•°ä¸­ï¼Œå°†pthread_createå‡½æ•°çš„ç¬¬å››ä¸ªå‚æ•°æ”¹ä¸ºä¼ å…¥client_sockçš„åœ°å€å³å¯ï¼šmain12- if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)+ if (pthread_create(&amp;newthread , NULL, accept_request, &amp;client_sock) != 0) çŽ°åœ¨é€šè¿‡ç¼–è¯‘æ‰€å¾—åˆ°çš„ httpd æ˜¯ä¸€ä¸ªçº¿ç¨‹ç‰ˆæœ¬çš„æœåŠ¡å™¨ã€‚ ä½†æ— è®ºæ˜¯çº¿ç¨‹ç‰ˆè¿˜æ˜¯æ— çº¿ç¨‹ç‰ˆï¼Œéƒ½éœ€è¦ä¿®æ”¹ä»¥ä¸‹å†…å®¹æ‰å¯ä»¥åœ¨ Linux ä¸‹è¿è¡Œï¼š é¦–å…ˆæ˜¯Makefileï¼Œä¸Žæºç ä¸­æ³¨é‡Š 5 ä¸€æ ·ï¼Œéœ€è¦åˆ é™¤-lsocketæŒ‡ä»¤ï¼Œå¹¶å°†-lpthreadæŒ‡ä»¤æ”¾åœ¨æœ€åŽé¢ï¼Œå…·ä½“å¦‚ä¸‹ï¼šMakefile12- gcc -W -Wall -lsocket -lpthread -o httpd httpd.c+ gcc -W -Wall -o httpd httpd.c -lpthreadç„¶åŽï¼Œè¿˜éœ€è¦ä¿®æ”¹index.htmlçš„æƒé™ï¼ŒåŽ»æŽ‰è¿™ä¸ªæ–‡ä»¶çš„å¯æ‰§è¡Œæƒé™ï¼Œç»ˆç«¯ä¸‹æ‰§è¡Œå‘½ä»¤chmod 600 index.htmlå³å¯ã€‚ æœ€åŽï¼Œè¿˜éœ€è¦æé†’çš„æ˜¯æ­¤æºç çš„ CGI è„šæœ¬éœ€è¦ç”¨ perl æ¥æ‰§è¡Œï¼Œæ‰€ä»¥è¦å…ˆå®‰è£… perlï¼Œå¦‚ä½•å®‰è£…ï¼Œæ­¤å¤„ä¸è¡¨ï¼Œè‡ªè¡Œç™¾åº¦ï¼Œä½† perl å®‰è£…å¥½ä¹‹åŽåˆä¼šå­˜åœ¨ä¸€ä¸ª perl è·¯å¾„çš„é—®é¢˜ã€‚ å…·ä½“è€Œè¨€ï¼Œæºç ä¸­ CGI è„šæœ¬çš„è·¯å¾„æ˜¯#!/usr/local/bin/perl -Twï¼Œä½†ä¸åŒ Linux å‘è¡Œç‰ˆçš„è½¯ä»¶å®‰è£…è·¯å¾„å¯èƒ½ä¸ä¸€è‡´ï¼Œæ¯”å¦‚ Ubuntu 16.04 ä¸‹éœ€è¦å°†è·¯å¾„æ”¹ä¸º#!/usr/bin/perl -Twã€‚æ‰€ä»¥ï¼Œå¦‚è‹¥å¯ä»¥è®¿é—®index.htmlé¡µé¢ï¼Œä½†æ— æ³•æ‰§è¡Œ CGI è„šæœ¬ï¼Œå¯ä»¥å°è¯•ä»Žè¿™æ–¹é¢è°ƒè¯•ã€‚ æœ€åŽçš„æœ€åŽï¼ˆå†åºŸè¯ä¸€ä¸‹ðŸ˜‚ï¼‰ï¼Œè¿˜éœ€è¦è¯´æ˜Žçš„æ˜¯æœ¬æ–‡æ‰€æœ‰çš„ä»£ç éƒ¨åˆ†ï¼Œä¸ä¼šä¿®æ”¹æˆ–åˆ é™¤ J. David Blackstone æ›¾ç»ç•™ä¸‹çš„æ³¨é‡Šï¼Œè¿™éƒ¨åˆ†æ³¨é‡Šä¹Ÿå¯ä»¥è¯»è¯»ï¼Œå¯¹ç›´æŽ¥ç†è§£å‡½æ•°çš„åŠŸèƒ½æœ‰ç”¨ï¼Œä½†æ˜¯è‹±æ–‡çš„ï¼Œè¯»èµ·æ¥å¯èƒ½ä¸å¤ªæ–¹ä¾¿ðŸ™‚ã€‚ ä¸‹é¢å°±å¼€å§‹é€ä¸ªåˆ†æžä¸€ä¸‹å…³é”®çš„å‡½æ•°ã€‚ mainå…ˆä»Žmainå‡½æ•°å¼€å§‹ï¼Œå…ˆæžæ¸…æ¥šå¤§è‡´çš„å·¥ä½œæµç¨‹æ˜¯ä»€ä¹ˆï¼Œç›¸å…³çš„æ³¨é‡Šå·²ç»å†™åœ¨å¯¹åº”ä½ç½®ï¼šmain1234567891011121314151617181920212223242526272829int main(void) &#123; // åˆå§‹åŒ–å˜é‡ int server_sock = -1; // æœåŠ¡å™¨å¥—æŽ¥å­— u_short port = 0; // æœåŠ¡å™¨ç«¯å£ int client_sock = -1; // ä¸Žå®¢æˆ·ç«¯è¿žæŽ¥çš„å¥æŸ„ struct sockaddr_in client_name; int client_name_len = sizeof(client_name); pthread_t newthread; // å£°æ˜Žçº¿ç¨‹ id server_sock = startup(&amp;port); // å¯åŠ¨æœåŠ¡å™¨ï¼Œç”¨æŒ‡å®šç«¯å£å¼€å¯ http æœåŠ¡ printf("httpd running on port %d\n", port); // debug ä¿¡æ¯ while (1) &#123; // è°ƒç”¨ accept å‡½æ•°ï¼Œè¿”å›žä¸Žå®¢æˆ·ç«¯è¿žæŽ¥çš„æ–‡ä»¶æè¿°ç¬¦ // accept å‡½æ•°æ˜¯ä¸€ç§é˜»å¡žå‡½æ•°ï¼Œé˜»å¡žç­‰å¾…ç”¨æˆ·æµè§ˆå™¨å‘èµ·è®¿é—® client_sock = accept(server_sock, (struct sockaddr *)&amp;client_name, &amp;client_name_len); if (client_sock == -1) error_die("accept"); /* accept_request(client_sock); */ // é€šè¿‡ client_sock è°ƒç”¨ accept_request å‡½æ•°å¯¹ç”¨æˆ·è¿›è¡Œè®¿é—® // åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼Œä¼šè§£æžç”¨æˆ·æµè§ˆå™¨å‘æ¥çš„è¯·æ±‚ if (pthread_create(&amp;newthread, NULL, (void*)accept_request, (void*)&amp;client_sock) != 0) perror("pthread_create"); &#125; // å…³é—­æœåŠ¡å™¨å¥—æŽ¥å­— close(server_sock); return 0;&#125; ä»¥ä¸‹æ˜¯ç›¸å…³çŸ¥è¯†ç‚¹ç®€è¦è¯´æ˜Žï¼š sockaddr_inæ˜¯ç½‘ç»œç¼–ç¨‹ä¸­çš„ä¸€ç§ç»“æž„ï¼Œåœ¨ä¸åŒçš„çŽ¯å¢ƒä¸­å…¶å®šä¹‰ä¹Ÿä¸ä¸€è‡´ã€‚ in_addræ˜¯ä¸€ä¸ªç»“æž„ä½“ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºä¸€ä¸ª 32 ä½çš„ IPv4 åœ°å€ã€‚ acceptå‡½æ•°æ˜¯åº“å‡½æ•°ï¼Œä½œç”¨æ˜¯é€šè¿‡å¥—æŽ¥å­—æŽ¥å—ä¸€ä¸ªè¿žæŽ¥ã€‚ pthread_createè¿™é‡Œï¼Œå†ç€é‡è¯´ä¸€ä¸‹pthread_createå‡½æ•°ï¼Œå®ƒæ˜¯ç±» Unix æ“ä½œç³»ç»Ÿä¸­åˆ›å»ºçº¿ç¨‹çš„åº“å‡½æ•°ï¼ˆLinux çŽ°åœ¨ä¹Ÿæœ‰äº†ï¼‰ã€‚åŠŸèƒ½æ˜¯å…ˆå°†çº¿ç¨‹åˆ›å»ºå¥½ï¼Œç„¶åŽå¼€å§‹è¿è¡Œç›¸å…³çš„çº¿ç¨‹å‡½æ•°ã€‚å‰é¢å·²ç»æåˆ°äº†éœ€è¦å¯¹pthread_createå‡½æ•°çš„è°ƒç”¨åšä¸€äº›ä¿®æ”¹ï¼šmain12- if (pthread_create(&amp;newthread , NULL, accept_request, client_sock) != 0)+ if (pthread_create(&amp;newthread , NULL, accept_request, &amp;client_sock) != 0) å®žé™…ä¸Šï¼Œåœ¨ç¬”è€…çš„ Ubuntu 16.04 ç³»ç»Ÿä¸‹ï¼Œpthread_createå‡½æ•°çš„ç¬¬ä¸‰ä¸ªå‚æ•°éœ€è¦ä¸€ä¸ªè¿”å›žç©ºæŒ‡é’ˆä¸”å‚æ•°ä¸ºvoid *çš„å‡½æ•°æŒ‡é’ˆï¼ˆç±»åž‹ä¸ºvoid *(*)(void *)ï¼‰ï¼Œæ‰€ä»¥éœ€è¦ä¿®æ”¹accept_requestå‡½æ•°çš„å£°æ˜Žå’Œå®šä¹‰ï¼›ç¬¬å››ä¸ªå‚æ•°åˆ™éœ€è¦ä¸€ä¸ªç©ºæŒ‡é’ˆï¼ˆç±»åž‹ä¸ºvoid *ï¼‰ï¼Œè€Œè¿™ç¬¬å››ä¸ªå‚æ•°å®žé™…ä¸Šå°±æ˜¯ç»™å‡½æ•°æŒ‡é’ˆæŒ‡å‘çš„å‡½æ•°ï¼ˆä¹Ÿå°±æ˜¯accept_requestï¼‰ä½¿ç”¨çš„ï¼Œä¹‹æ‰€ä»¥èƒ½ç›´æŽ¥ä¼ å…¥client_sockçš„åœ°å€æ˜¯å› ä¸ºç¬”è€…ä½¿ç”¨çš„ GCC ç¼–è¯‘å™¨ä¼šåšéšå¼è½¬æ¢ï¼ˆimplicit conversionï¼‰ï¼Œæ‰€ä»¥ç›´æŽ¥ä¼ æŒ‡é’ˆå³å¯ï¼Œå…¶ä»– C/C++ ç³»ç¼–è¯‘å™¨ä¼šä¸ä¼šè½¬æ¢å°±ä¸çŸ¥é“äº†ã€‚ startupstartupä¸»è¦ä½œç”¨æ˜¯ç”¨æ¥å¯åŠ¨æœåŠ¡ï¼Œç›¸å…³çš„æ³¨é‡Šå·²ç»å†™åœ¨å¯¹åº”ä½ç½®ï¼šstartup12345678910111213141516171819202122232425262728293031323334353637/**********************************************************************//* This function starts the process of listening for web connections * on a specified port. If the port is 0, then dynamically allocate a * port and modify the original port variable to reflect the actual * port. * Parameters: pointer to variable containing the port to connect on * Returns: the socket *//**********************************************************************/int startup(u_short *port) &#123; int httpd = 0; struct sockaddr_in name; // socket å‡½æ•°ä¼šè¿”å›žä¸€ä¸ªå¥—æŽ¥å­— httpd = socket(PF_INET, SOCK_STREAM, 0); if (httpd == -1) error_die("socket"); memset(&amp;name, 0, sizeof(name)); name.sin_family = AF_INET; // åè®®æ— name.sin_port = htons(*port); // ç«¯å£å· name.sin_addr.s_addr = htonl(INADDR_ANY); // IP åœ°å€ // ç»‘å®šå¥—æŽ¥å­— if (bind(httpd, (struct sockaddr *)&amp;name, sizeof(name)) &lt; 0) error_die("bind"); // å¦‚æžœæ²¡æœ‰è®¾ç½®ç«¯å£ï¼Œå°±åŠ¨æ€ç”³è¯·ä¸€ä¸ªç«¯å£ if (*port == 0) /* if dynamically allocating a port */ &#123; int namelen = sizeof(name); // åˆ©ç”¨ getsockname å‡½æ•°æ¥åŠ¨æ€ç”³è¯·ä¸€ä¸ªç«¯å£ï¼Œè¿™ä¸ªç«¯å£ä¼šä¿å­˜åœ¨ç»“æž„ä½“ä¸­ if (getsockname(httpd, (struct sockaddr *)&amp;name, &amp;namelen) == -1) error_die("getsockname"); // é€šè¿‡ç»“æž„ä½“çš„æˆå‘˜èµ‹å€¼ç»™è§£å¼•ç”¨çš„æŒ‡é’ˆï¼Œåˆ©ç”¨æŒ‡é’ˆæ”¹å˜åŽŸå˜é‡çš„å€¼ *port = ntohs(name.sin_port); &#125; // åˆ›å»ºè¯·æ±‚é˜Ÿåˆ—å¤§å°ä¸º 5 çš„ç›‘å¬é˜Ÿåˆ— if (listen(httpd, 5) &lt; 0) error_die("listen"); return httpd;&#125; ä»Žæºç ä¸­å¯ä»¥å‘çŽ°ï¼Œstartupå‡½æ•°ä¸ä»…åˆ›å»ºå¥½äº†å¥—æŽ¥å­—ã€ç«¯å£ï¼Œè¿˜å¼€å§‹è¿›è¡Œç›‘å¬äº†ã€‚è™½ç„¶startupè¿™ä¸ªå‡½æ•°ä½¿ç”¨çš„ç³»ç»Ÿ API éžå¸¸å¤šï¼Œä½†ç»“åˆæ³¨é‡Šä¹Ÿèƒ½å¤§æ¦‚çŸ¥é“åŠŸèƒ½æ˜¯ä»€ä¹ˆäº†ã€‚ accept_requestè¿™ä¸ªå‡½æ•°æ˜¯æ•´ä¸ªé¡¹ç›®çš„å…³é”®å‡½æ•°ï¼ŒåŠŸèƒ½æ˜¯æŽ¥æ”¶å®¢æˆ·ç«¯è¯·æ±‚ï¼Œå¹¶è§£æžå®¢æˆ·ç«¯å‘æ¥çš„æŠ¥æ–‡ï¼Œå†æ ¹æ®ä¸åŒçš„æ–¹æ³•å’Œæ–‡ä»¶æ˜¯å¦å¯æ‰§è¡Œæ¥å†³å®šæ˜¯å¦æ‰§è¡Œ CGI ç¨‹åºã€‚è¯¦ç»†çš„æ³¨é‡Šè¯·çœ‹ä¸‹é¢çš„ä¿®æ”¹åŽæºç ï¼šaccept_request123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/**********************************************************************//* A request has caused a call to accept() on the server port to * return. Process the request appropriately. * Parameters: the socket connected to the client *//**********************************************************************/void *accept_request(void *pclient) &#123; int client = *(int*)pclient; char buf[1024]; int numchars; char method[255]; char url[255]; char path[512]; size_t i, j; struct stat st; int cgi = 0; /* becomes true if server decides this is a CGI * program */ char *query_string = NULL; // åˆ©ç”¨ get_line å‡½æ•°è¯»å–è¯·æ±‚å¤´çš„ä¸€è¡Œï¼Œè¿”å›žå­—ç¬¦ä¸²çš„é•¿åº¦ numchars = get_line(client, buf, sizeof(buf)); i = 0; j = 0; // æˆªå–å‡ºè¯·æ±‚æŠ¥æ–‡ä¸­çš„æ–¹æ³•å­—ç¬¦ä¸² while(!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(method) - 1)) &#123; method[i] = buf[j]; i++; j++; &#125; method[i] = '\0'; // strcasecmp åº“å‡½æ•°ï¼Œå¿½ç•¥å¤§å°å†™è¿›è¡Œå­—ç¬¦ä¸²æ¯”è¾ƒï¼ŒåŠŸèƒ½ä¸Ž strcmp å‡½æ•°ç±»ä¼¼ if(strcasecmp(method, "GET") &amp;&amp; strcasecmp(method, "POST")) &#123; // æ•´ä¸ªæµ‹è¯•ç¨‹åºåªæµ‹è¯• GET å’Œ POST æ–¹æ³•ï¼Œæ‰€ä»¥äºŒè€…åŒæ—¶ä¸æ»¡è¶³æ¡ä»¶æ—¶ï¼Œè¯´æ˜Žæ˜¯æ•´ä¸ªç¨‹åºæ²¡æœ‰å®žçŽ°çš„æ–¹æ³• // è°ƒç”¨ unimplemented å‡½æ•°å‘å®¢æˆ·ç«¯ç›´æŽ¥å‘é€å¼‚å¸¸é¡µé¢ unimplemented(client); return NULL; // å› ä¸ºä¿®æ”¹äº†å‡½æ•°è¿”å›žå€¼ï¼Œè¿™é‡Œä¹ŸåŠ ä¸Š &#125; // å¦‚æžœå®¢æˆ·ç«¯å‘æ¥çš„æ˜¯ post è¯·æ±‚ if(strcasecmp(method, "POST") == 0) cgi = 1; // å°† cgi æ ‡å¿—ç½® 1 // é‡æ–°ä½¿ç”¨ i ä½œä¸º url å­—ç¬¦æ•°ç»„çš„ä¸‹æ ‡ i = 0; // è·³è¿‡è¯·æ±‚æŠ¥æ–‡ä¸­çš„ç©ºæ ¼ while(ISspace(buf[j]) &amp;&amp; (j &lt; sizeof(buf))) j++; // è§£æžå‡ºè¯·æ±‚æŠ¥æ–‡ä¸­çš„ url while(!ISspace(buf[j]) &amp;&amp; (i &lt; sizeof(url) - 1) &amp;&amp; (j &lt; sizeof(buf))) &#123; url[i] = buf[j]; i++; j++; &#125; url[i] = '\0'; // å¦‚æžœå®¢æˆ·ç«¯ä½¿ç”¨ GET æ–¹æ³• // url å¯èƒ½ä¼šå¸¦æœ‰ ?ï¼Œä¸”æœ‰æŸ¥è¯¢å‚æ•° if(strcasecmp(method, "GET") == 0) &#123; query_string = url; while((*query_string != '?') &amp;&amp; (*query_string != '\0')) query_string++; if (*query_string == '?') &#123; // å¦‚æžœ url ä¸­æœ‰ ?ï¼Œè¯´æ˜Žæ˜¯æŸ¥è¯¢è¯·æ±‚ï¼Œéœ€è¦æ‰§è¡Œ CGI // åŒæ—¶å°†è¿™ä¸ªå­—ç¬¦ä¸²æ”¹ä¸º'\0'ï¼Œå¹¶å°† query_string æŒ‡é’ˆæŒ‡å‘åŽé¢çš„å­—ç¬¦ä¸² cgi = 1; *query_string = '\0'; query_string++; &#125; &#125; // èµ„æºè·¯å¾„è®¾ç½®ä¸º htdocs/ sprintf(path, "htdocs%s", url); // åœ¨è·¯å¾„åŽé¢åŠ ä¸Šå…·ä½“çš„é¡µé¢åç§°ï¼ŒçŽ°åœ¨è·¯å¾„æ˜¯ htdocs/index.htmlï¼Œè¿™ä¸ªè·¯å¾„ä¸Žæ­¤é¡¹ç›®æ–‡ä»¶ç›®å½•çš„ç»“æž„ä¸€è‡´ if(path[strlen(path) - 1] == '/') strcat(path, "index.html"); if(stat(path, &amp;st) == -1) &#123; // å¦‚æžœæ— æ³•æŒ‰ç…§è·¯å¾„èŽ·å–åˆ°æ–‡ä»¶ä¿¡æ¯ï¼Œè¯´æ˜Žæ–‡ä»¶ä¸å­˜åœ¨ï¼Œæ­¤æ—¶çš„æŠ¥æ–‡ä¿¡æ¯ä¸¢å¼ƒ // å¹¶å‘æµè§ˆå™¨å‘é€ 404 é¡µé¢ while((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); not_found(client); &#125; else &#123; // stat(path, &amp;st) != -1ï¼Œè¯´æ˜Ž path æ˜¯ä¸ªç›®å½• // å¦‚æžœ path æ˜¯ä¸ªç›®å½•ï¼Œå°±å°† path æ”¹ä¸º ç›®å½•/index.html è¿™ç§æ–‡ä»¶è·¯å¾„çš„å½¢å¼ if ((st.st_mode &amp; S_IFMT) == S_IFDIR) strcat(path, "/index.html"); if((st.st_mode &amp; S_IXUSR) || (st.st_mode &amp; S_IXGRP) || (st.st_mode &amp; S_IXOTH)) // å¦‚æžœæ–‡ä»¶å¯æ‰§è¡Œï¼Œå½“ä½œ cgi è„šæœ¬æ‰§è¡Œ cgi = 1; if(!cgi) // ä¸æ‰§è¡Œ cgi è„šæœ¬ï¼Œç›´æŽ¥å‘å®¢æˆ·ç«¯å‘é€ HTML æ–‡ä»¶ serve_file(client, path); else // æ‰§è¡Œ cgi è„šæœ¬ï¼Œæ­¤æ—¶è¦é¢å¤–ä¼ å…¥æ‰€ä½¿ç”¨çš„æ–¹æ³•å’ŒæŸ¥è¯¢å­—ç¬¦ä¸² execute_cgi(client, path, method, query_string); &#125; // æ‰§è¡Œå®Œæ¯•ï¼Œå…³é—­å¥—æŽ¥å­— close(client); return NULL; // åŠ ä¸Šå‡½æ•°è¿”å›žå€¼&#125; å‰é¢æåˆ°è¿‡éœ€è¦ä¿®æ”¹index.htmlçš„æ–‡ä»¶æƒé™ï¼Œä¿®æ”¹åŽè¿™ä¸ªæ–‡ä»¶çš„æƒé™æ˜¯-rw-------ï¼Œå¯ä»¥å‘çŽ°åªä¿ç•™äº†ç”¨æˆ·å¯¹å…¶çš„è¯»å†™æƒé™ï¼Œæ²¡æœ‰å¯æ‰§è¡Œæƒé™ã€‚ä¸ºä»€ä¹ˆè¦è¿™æ ·æ”¹ï¼Ÿå¯ä»¥ä»Žä¸Šé¢ä»£ç çš„ 77 - 81 è¡Œå‘çŽ°ç­”æ¡ˆï¼Œå¦‚æžœindex.htmlæ–‡ä»¶å¯æ‰§è¡Œï¼Œé‚£ä¹ˆå°±ä¼šè¢«å½“ä½œ CGI è„šæœ¬æ¥æ‰§è¡Œï¼Œé‚£è¿™ä¸ªæ–‡ä»¶å°±ä¸ä¼šå‘é€ç»™å®¢æˆ·ç«¯äº†ã€‚è€Œä¸”ï¼Œä»Žæºç ä¸­è¿˜å¯ä»¥çœ‹å‡ºæœåŠ¡å™¨è§£æžå®¢æˆ·ç«¯è¯·æ±‚æŠ¥æ–‡æ—¶ï¼Œå…¶å®žå°±æ˜¯é€šè¿‡è§£æžå­—ç¬¦ä¸²æ¥å®Œæˆçš„ã€‚å¦å¤–ï¼Œå‰é¢è¿˜æåˆ°äº†éœ€è¦åœ¨é¦–è¡Œæ·»åŠ int client = *(int*)pclient;ï¼Œä¹‹æ‰€ä»¥è¦æ·»åŠ è¿™ä¸€å¥ï¼Œå…¶å®žå°±æ˜¯å°½å¯èƒ½çš„é¿å…ä¿®æ”¹æ›´å¤šçš„ä»£ç ï¼Œå› ä¸ºæºç æ˜¯ç›´æŽ¥ä½¿ç”¨clientå˜é‡çš„ã€‚ get_lineget_lineå‡½æ•°çš„åŠŸèƒ½ä¸Žå…¶åç§°ä¸€è‡´ï¼Œå°±æ˜¯è¯»å–ä¸€è¡Œå­—ç¬¦ï¼Œä»¥ CRLF ä¸ºç»“å°¾ã€‚å¯èƒ½ä¼šæœ‰äººç–‘é—®ä¸ºä»€ä¹ˆæ˜¯ CRLF ä¸ºç»“å°¾çš„æ ‡å¿—ï¼Œå› ä¸ºè¿™æ˜¯ HTTP åè®®è§„å®šçš„ã€‚ä¸‹é¢æ˜¯å¯¹åº”çš„æ³¨é‡Šå’Œæºç ï¼šget_line123456789101112131415161718192021222324252627282930313233343536373839404142434445/**********************************************************************//* Get a line from a socket, whether the line ends in a newline, * carriage return, or a CRLF combination. Terminates the string read * with a null character. If no newline indicator is found before the * end of the buffer, the string is terminated with a null. If any of * the above three line terminators is read, the last character of the * string will be a linefeed and the string will be terminated with a * null character. * Parameters: the socket descriptor * the buffer to save the data in * the size of the buffer * Returns: the number of bytes stored (excluding null) *//**********************************************************************/int get_line(int sock, char *buf, int size) &#123; // CRLF == "\r\n" int i = 0; char c = '\0'; int n; while ((i &lt; size - 1) &amp;&amp; (c != '\n')) &#123; // åˆ©ç”¨ recv å‡½æ•°æŽ¥å—æ•°æ®ï¼Œé•¿åº¦ä¸º 1ï¼Œç”¨å­—ç¬¦å˜é‡ c æ¥ä¿å­˜ï¼Œrecv å‡½æ•°è¿”å›žå®žé™…å¤åˆ¶çš„å­—èŠ‚æ•° n = recv(sock, &amp;c, 1, 0); /* DEBUG printf("%02X\n", c); */ if (n &gt; 0) &#123; if (c == '\r') &#123; // è¯»åˆ°æ¢è¡Œç¬¦æ—¶ // è¯»å–æœ€åŽçš„å›žè½¦ç¬¦ï¼Œä½†ä¸åˆ é™¤è¾“å…¥æµä¸­çš„å›žè½¦ï¼ˆMSG_PEEK å‚æ•°çš„æ„ä¹‰ï¼‰ n = recv(sock, &amp;c, 1, MSG_PEEK); /* DEBUG printf("%02X\n", c); */ if ((n &gt; 0) &amp;&amp; (c == '\n')) // å¦‚æžœæ˜¯å›žè½¦ï¼Œå°±åƒæŽ‰æœ€åŽä¸€ä¸ªå›žè½¦ç¬¦ recv(sock, &amp;c, 1, 0); else c = '\n'; &#125; // å¦‚æžœ c ä¸æ˜¯'\r'æˆ–'\n' ï¼Œå°±æ”¾åˆ°ç¼“å­˜å­—ç¬¦ä¸²ä¸­ buf[i] = c; i++; &#125; else c = '\n'; &#125; // å®Œæˆä¸€è¡Œçš„è¯»å–ï¼Œæœ€åŽåŠ ä¸Š C å­—ç¬¦ä¸²ç»“æŸçš„æ ‡å¿— buf[i] = '\0'; return(i);&#125; è¿™ä¸ªå‡½æ•°å¹¶ä¸å¤æ‚ï¼Œæœ¬è´¨ä¸Šå°±å¯ä»¥å½“ä½œä¸€ä¸ªå­—ç¬¦ä¸²ç›¸å…³çš„å¤„ç†å‡½æ•°æ¥ç†è§£ã€‚ not_found/bad_request/cannot_execute/headers/unimplementednot_foundã€bad_requestã€cannot_executeã€headerså’Œunimplementedè¿™äº”ä¸ªå‡½æ•°éƒ½å¾ˆç®€å•ï¼Œåªæœ‰ä¸€ä¸ªåŠŸèƒ½å°±æ˜¯å‘å®¢æˆ·ç«¯å‘é€ä¿¡æ¯ï¼Œè¿™é‡Œä¸ç»†è¯´äº†ï¼Œç›´æŽ¥çœ‹æºç å’Œå¯¹åº”æ³¨é‡Šå³å¯ï¼šnot_found1234567891011121314151617181920212223242526/**********************************************************************//* Give a client a 404 not found status message. *//**********************************************************************/void not_found(int client) &#123; // ä¸Ž unimplemented å‡½æ•°ç±»ä¼¼ï¼Œå‘å®¢æˆ·ç«¯å‘é€ 404 é¡µé¢ char buf[1024]; sprintf(buf, "HTTP/1.0 404 NOT FOUND\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;HTML&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;BODY&gt;&lt;P&gt;The server could not fulfill\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "your request because the resource specified\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "is unavailable or nonexistent.\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/BODY&gt;&lt;/HTML&gt;\r\n"); send(client, buf, strlen(buf), 0);&#125; bad_request12345678910111213141516171819/**********************************************************************//* Inform the client that a request it has made has a problem. * Parameters: client socket *//**********************************************************************/void bad_request(int client) &#123; // é”™è¯¯è¯·æ±‚ï¼Œå‘å®¢æˆ·ç«¯å‘é€ 400 é¡µé¢ char buf[1024]; sprintf(buf, "HTTP/1.0 400 BAD REQUEST\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "Content-type: text/html\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "\r\n"); send(client, buf, sizeof(buf), 0); sprintf(buf, "&lt;P&gt;Your browser sent a bad request, "); send(client, buf, sizeof(buf), 0); sprintf(buf, "such as a POST without a Content-Length.\r\n"); send(client, buf, sizeof(buf), 0);&#125; cannot_execute1234567891011121314151617/**********************************************************************//* Inform the client that a CGI script could not be executed. * Parameter: the client socket descriptor. *//**********************************************************************/void cannot_execute(int client) &#123; // CGI è„šæœ¬æ— æ³•æ‰§è¡Œï¼Œè¿”å›ž 500 é¡µé¢ char buf[1024]; sprintf(buf, "HTTP/1.0 500 Internal Server Error\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;P&gt;Error prohibited CGI execution.\r\n"); send(client, buf, strlen(buf), 0);&#125; headers12345678910111213141516171819/**********************************************************************//* Return the informational HTTP headers about a file. *//* Parameters: the socket to print the headers on * the name of the file *//**********************************************************************/void headers(int client, const char *filename) &#123; // å‘å®¢æˆ·ç«¯å‘é€å“åº”æŠ¥æ–‡å¤´ char buf[1024]; (void)filename; /* could use filename to determine file type */ strcpy(buf, "HTTP/1.0 200 OK\r\n"); send(client, buf, strlen(buf), 0); strcpy(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); strcpy(buf, "\r\n"); send(client, buf, strlen(buf), 0);&#125; unimplemented12345678910111213141516171819202122232425262728/**********************************************************************//* Inform the client that the requested web method has not been * implemented. * Parameter: the client socket *//**********************************************************************/void unimplemented(int client) &#123; // å­—ç¬¦ä¸²ç¼“å­˜ char buf[1024]; // å‘å®¢æˆ·ç«¯å‘é€ä¸€ä¸ªæ–¹æ³•æœªå®žçŽ°çš„æç¤ºä¸šé¢ // å…ˆç”¨ sprintf å‡½æ•°å‘ buf å†™å…¥è¦è¾“å‡ºçš„å­—ç¬¦ä¸² // å†ç”¨ send å‡½æ•°é€šè¿‡å¥—æŽ¥å­—å‘å®¢æˆ·ç«¯å‘é€ sprintf(buf, "HTTP/1.0 501 Method Not Implemented\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, SERVER_STRING); send(client, buf, strlen(buf), 0); sprintf(buf, "Content-Type: text/html\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Method Not Implemented\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/TITLE&gt;&lt;/HEAD&gt;\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;BODY&gt;&lt;P&gt;HTTP request method not supported.\r\n"); send(client, buf, strlen(buf), 0); sprintf(buf, "&lt;/BODY&gt;&lt;/HTML&gt;\r\n"); send(client, buf, strlen(buf), 0);&#125; serve_fileserve_fileå‡½æ•°ç”¨æ¥å‘å®¢æˆ·ç«¯å‘é€æ–‡ä»¶ï¼Œéœ€è¦æœ‰å®¢æˆ·ç«¯å¥—æŽ¥å­—å’Œå¯¹åº”çš„æ–‡ä»¶è·¯å¾„ä½œä¸ºå‚æ•°ã€‚serve_file12345678910111213141516171819202122232425262728293031/**********************************************************************//* Send a regular file to the client. Use headers, and report * errors to client if they occur. * Parameters: a pointer to a file structure produced from the socket * file descriptor * the name of the file to serve *//**********************************************************************/void serve_file(int client, const char *filename) &#123; FILE *resource = NULL; int numchars = 1; char buf[1024]; // é»˜è®¤å­—ç¬¦ buf[0] = 'A'; buf[1] = '\0'; // ä¸Ž accept_request å‡½æ•°ä¸€æ ·ï¼Œä¸¢å¼ƒå‰©ä½™çš„æŠ¥æ–‡ä¿¡æ¯ while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); // ç”¨æ–‡ä»¶æŒ‡é’ˆæ‰“å¼€æ–‡ä»¶ resource = fopen(filename, "r"); if (resource == NULL) // å¦‚æžœæ–‡ä»¶æœªæ‰¾åˆ°ï¼Œå‘é€ 404 é¡µé¢ not_found(client); else &#123; // å…ˆå‘é€æŠ¥æ–‡å¤´ headers(client, filename); // å†å‘é€ html æ–‡ä»¶ cat(client, resource); &#125; // å…³é—­æ–‡ä»¶æŒ‡é’ˆ fclose(resource);&#125; catcatå‡½æ•°çš„åŠŸèƒ½ç±»ä¼¼ Linux ä¸­çš„catå‘½ä»¤ï¼Œéƒ½æ˜¯è¯»å–é€è¡Œè¯»å–æ–‡ä»¶ï¼Œä¸è¿‡è¿™é‡Œçš„catå‡½æ•°éœ€è¦é€è¡Œè¯»å–æ–‡ä»¶å¹¶å‘é€ç»™å®¢æˆ·ç«¯ã€‚cat12345678910111213141516/**********************************************************************//* Put the entire contents of a file out on a socket. This function * is named after the UNIX "cat" command, because it might have been * easier just to do something like pipe, fork, and exec("cat"). * Parameters: the client socket descriptor * FILE pointer for the file to cat *//**********************************************************************/void cat(int client, FILE *resource) &#123; char buf[1024]; // é€è¡Œè¯»å– html æ–‡ä»¶ï¼Œå¹¶å‘é€ç»™å®¢æˆ·ç«¯ï¼Œè¯»åˆ° EOF æ—¶ï¼Œè¯»å–å®Œæ¯•ï¼Œè·³å‡ºå¾ªçŽ¯ fgets(buf, sizeof(buf), resource); while (!feof(resource)) &#123; send(client, buf, strlen(buf), 0); fgets(buf, sizeof(buf), resource); &#125;&#125; execute_cgiexecute_cgiå‡½æ•°ä¹Ÿæ˜¯ä¸€ä¸ªå…³é”®å‡½æ•°ï¼Œå…·ä½“åŠŸèƒ½æ˜¯æ‰§è¡Œ CGI ç¨‹åºï¼Œå…·ä½“è¯·çœ‹ä¸‹é¢çš„æºç å’Œæ³¨é‡Šï¼šexecute_cgi123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130/**********************************************************************//* Execute a CGI script. Will need to set environment variables as * appropriate. * Parameters: client socket descriptor * path to the CGI script *//**********************************************************************/void execute_cgi(int client, const char *path, const char *method, const char *query_string) &#123; char buf[1024]; int cgi_output[2]; int cgi_input[2]; pid_t pid; int status; int i; char c; int numchars = 1; int content_length = -1; // é»˜è®¤å­—ç¬¦ buf[0] = 'A'; buf[1] = '\0'; if(strcasecmp(method, "GET") == 0) // å¦‚æžœå®¢æˆ·ç«¯çš„è¯·æ±‚æ˜¯ GET æ–¹æ³•ï¼Œå¿½ç•¥æŽ‰å‰©ä½™çš„æŠ¥æ–‡ while((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) /* read &amp; discard headers */ numchars = get_line(client, buf, sizeof(buf)); else &#123; /* POST */ // å¦‚æžœæ˜¯ POST æ–¹æ³•ï¼Œé€è¡Œè¯»å–èŽ·å– content_length numchars = get_line(client, buf, sizeof(buf)); while ((numchars &gt; 0) &amp;&amp; strcmp("\n", buf)) &#123; // åŠ ä¸Šå­—ç¬¦ä¸²ç»“æŸç¬¦ï¼Œä¾¿äºŽä½¿ç”¨ strcasecmp å‡½æ•° buf[15] = '\0'; if(strcasecmp(buf, "Content-Length:") == 0) content_length = atoi(&amp;(buf[16])); numchars = get_line(client, buf, sizeof(buf)); &#125; // é”™è¯¯è¯·æ±‚ if(content_length == -1) &#123; bad_request(client); return; // ç›´æŽ¥è¿”å›ž &#125; &#125; // æˆåŠŸè¯»å–è¯·æ±‚åŽï¼Œå‘å®¢æˆ·ç«¯å‘é€è¯·æ±‚æˆåŠŸæŠ¥æ–‡ // ä¸ç®¡ GET è¿˜æ˜¯ POSTï¼Œéƒ½éœ€è¦ sprintf(buf, "HTTP/1.0 200 OK\r\n"); send(client, buf, strlen(buf), 0); // åˆ›å»º 2 ä¸ªç®¡é“ // pipe å‡½æ•°ä¼šå»ºç«‹ç®¡é“ // é»˜è®¤æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯è¯»å…¥ç«¯ï¼Œç¬¬äºŒä¸ªå…ƒç´ æ˜¯å†™å…¥ç«¯ // cgi_output[0] æ˜¯è¯»å…¥ç«¯ï¼Œcgi_output[1] æ˜¯å†™å…¥ç«¯ if(pipe(cgi_output) &lt; 0) &#123; cannot_execute(client); return; &#125; // cgi_input[0] æ˜¯è¯»å…¥ç«¯ï¼Œcgi_input[1] æ˜¯å†™å…¥ç«¯ if(pipe(cgi_input) &lt; 0) &#123; cannot_execute(client); return; &#125; // åˆ›å»ºå­è¿›ç¨‹ // fork å‡½æ•°åœ¨å­è¿›ç¨‹ä¸­è¿”å›ž 0 // åœ¨çˆ¶è¿›ç¨‹ä¸­è¿”å›žå­è¿›ç¨‹çš„ id // å½“è¿”å›žè´Ÿæ•°æ—¶ï¼Œè¡¨ç¤ºå­è¿›ç¨‹åˆ›å»ºå¤±è´¥ if((pid = fork()) &lt; 0 ) &#123; cannot_execute(client); return; &#125; if(pid == 0) &#123; /* child: CGI script */ // å­è¿›ç¨‹è¿è¡Œ CGI è„šæœ¬ï¼Œåˆ©ç”¨ç®¡é“æŽ¥å—ä»Žçˆ¶è¿›ç¨‹å‘æ¥çš„å®¢æˆ·ç«¯çš„è¯·æ±‚ char meth_env[255]; char query_env[255]; char length_env[255]; // æŠŠ stdout é‡å®šå‘åˆ° cgi_output[1] å†™å…¥ç«¯ // å¯¹äºŽå­è¿›ç¨‹è€Œè¨€ï¼Œè¿™æ˜¯å†™å…¥ç«¯ï¼Œä½†å¯¹çˆ¶è¿›ç¨‹è€Œè¨€ï¼Œè¿™æ˜¯è¯»å…¥ç«¯ // ä¹Ÿå°±æ˜¯è¯´å­è¿›ç¨‹å‘ cgi_output[1] å†™å…¥å†…å®¹ // çˆ¶è¿›ç¨‹ä»Ž cgi_output[0] è¯»å–å†…å®¹ dup2(cgi_output[1], 1); // æŠŠ stdin é‡å®šå‘åˆ° cgi_input[0] è¯»å…¥ç«¯ // å¯¹äºŽå­è¿›ç¨‹è€Œè¨€ï¼Œè¿™æ˜¯è¯»å…¥ç«¯ï¼Œä½†å¯¹çˆ¶è¿›ç¨‹è€Œè¨€ï¼Œè¿™æ˜¯å†™å…¥ç«¯ // ä¹Ÿå°±æ˜¯è¯´çˆ¶è¿›ç¨‹å‘ cgi_input[1] å†™å…¥å†…å®¹ // å­è¿›ç¨‹ä»Ž cgi_input[0] è¯»å–å†…å®¹ dup2(cgi_input[0], 0); // ä»¥ä¸Šä¸¤ä¸ªç®¡é“çš„ä¸¤ä¸ªé€šé“ï¼Œéƒ½æ˜¯å­è¿›ç¨‹åœ¨ä½¿ç”¨ // ä¸‹é¢ä¸¤ä¸ªç®¡é“çš„é€šé“è¦ç•™ç»™çˆ¶è¿›ç¨‹ä½¿ç”¨ï¼Œåœ¨å­è¿›ç¨‹ä¸­å…³é—­æŽ‰ // åˆ†åˆ«æ˜¯ç®¡é“ cgi_output çš„è¯»å…¥ç«¯å’Œç®¡é“ cgi_input çš„å†™å…¥ç«¯ close(cgi_output[0]); close(cgi_input[1]); sprintf(meth_env, "REQUEST_METHOD=%s", method); // è®¾ç½®çŽ¯å¢ƒå˜é‡ // æ³¨æ„ï¼šè®¾ç½®çš„çŽ¯å¢ƒä»…å¯¹ç¨‹åºæœ¬èº«æœ‰æ•ˆã€‚ä½ åœ¨ç¨‹åºé‡Œåšçš„æ”¹å˜ä¸ä¼š // åæ˜ åˆ°å¤–éƒ¨çŽ¯å¢ƒä¸­ï¼Œè¿™æ˜¯å› ä¸ºå˜é‡çš„å€¼ä¸ä¼šä»Žå­è¿›ç¨‹ä¼ æ’­åˆ°çˆ¶ // è¿›ç¨‹ï¼Œè¿™æ ·åšæ›´å®‰å…¨ã€‚ putenv(meth_env); if(strcasecmp(method, "GET") == 0) &#123; // GET æ–¹æ³•å¯¹åº” query_string sprintf(query_env, "QUERY_STRING=%s", query_string); putenv(query_env); &#125; else &#123; /* POST */ // POST æ–¹æ³•å¯¹åº” content_length sprintf(length_env, "CONTENT_LENGTH=%d", content_length); putenv(length_env); &#125; // æ‰§è¡Œå¯¹åº”çš„ CGI è„šæœ¬ execl(path, path, NULL); exit(0); &#125; else &#123; /* parent */ // çˆ¶è¿›ç¨‹å…ˆè¯»å–å®¢æˆ·ç«¯è¯·æ±‚ï¼Œå†é€šè¿‡ç®¡é“å‘ç»™å­è¿›ç¨‹ // å­è¿›ç¨‹è¿è¡Œ CGI è„šæœ¬å¾—åˆ°çš„ç»“æžœä¹Ÿé€šè¿‡ç®¡é“å‘ç»™çˆ¶è¿›ç¨‹ // çˆ¶è¿›ç¨‹å†å‘ç»™å®¢æˆ·ç«¯ // å…³é—­å­è¿›ç¨‹æ‰€ä½¿ç”¨çš„ç®¡é“é€šé“ close(cgi_output[1]); close(cgi_input[0]); if(strcasecmp(method, "POST") == 0) for(i = 0; i &lt; content_length; i++) &#123; // ä»Žå®¢æˆ·ç«¯æŽ¥æ”¶è¯·æ±‚æŠ¥æ–‡ recv(client, &amp;c, 1, 0); // çˆ¶è¿›ç¨‹é€šè¿‡ç®¡é“å‘å­è¿›ç¨‹å†™å…¥ä»Žå®¢æˆ·ç«¯æŽ¥æ”¶çš„æŠ¥æ–‡ write(cgi_input[1], &amp;c, 1); &#125; // çˆ¶è¿›ç¨‹é€šè¿‡ç®¡é“è¯»å–å­è¿›ç¨‹å†™å…¥ç®¡é“çš„ä¿¡æ¯ while(read(cgi_output[0], &amp;c, 1) &gt; 0) // ç„¶åŽä¾æ¬¡å‘é€ç»™å®¢æˆ·ç«¯ send(client, &amp;c, 1, 0); // å…³é—­çˆ¶è¿›ç¨‹ä½¿ç”¨çš„ç®¡é“é€šé“ close(cgi_output[0]); close(cgi_input[1]); // ç­‰å¾…å­è¿›ç¨‹è¿è¡Œç»“æŸ waitpid(pid, &amp;status, 0); &#125;&#125; è¿™ä¸ªå‡½æ•°çš„éš¾ç‚¹åœ¨äºŽå¯¹çˆ¶å­è¿›ç¨‹ä¹‹é—´ç®¡é“é€šä¿¡çš„ç†è§£ï¼Œå•çº¯è¯»æ³¨é‡Šå¯èƒ½ä¼šè¢«ç»•æ™•ï¼Œè¿™é‡Œå¼•ç”¨åˆ«äºº blog çš„ä¸€å¼ å›¾ï¼Œç»“åˆä¸‹é¢è¿™å¼ å›¾åº”è¯¥ä¼šæ¸…æ¥šä¸€äº›ã€‚ summaryçŽ°åœ¨å›žè¿‡å¤´æ¥ï¼Œå¯ä»¥å‘çŽ°æœåŠ¡å™¨çš„å·¥ä½œæµç¨‹å…¶å®žå¾ˆç®€å•ï¼š å¯åŠ¨æœ¬åœ°æœåŠ¡ æŽ¥æ”¶å¹¶åˆ†æžå®¢æˆ·ç«¯è¯·æ±‚ æ‰§è¡Œå¯¹åº” CGI ç¨‹åº å‘é€ CGI ç¨‹åºæ‰§è¡Œç»“æžœç»™å®¢æˆ·ç«¯ å…³é—­å¥—æŽ¥å­— ä¹Ÿå°±æ˜¯ä¸‹é¢è¿™å¼ å›¾ï¼š å®žé™…ä¸Šï¼Œå¦‚æžœå•çº¯æ˜¯é’ˆå¯¹ tinyhttpd è¿™ä¸ªå°é¡¹ç›®è€Œè¨€ï¼Œä¸‹é¢è¿™å¼ å›¾ä¼šæ›´ç»†èŠ‚ä¸€ç‚¹ï¼š åŒæ ·çš„ï¼Œtinyhttpd é¡¹ç›®æ‰€è®¾è®¡çš„å‡½æ•°ä¹Ÿå¯ä»¥æŒ‰åŠŸèƒ½åˆ†ç±»ï¼š æœ€åŽï¼Œä¸å¾—ä¸æ„Ÿå¹ï¼Œéº»é›€è™½å°ï¼Œä½†æ˜¯ä¾ç„¶äº”è„ä¿±å…¨~ å‚è€ƒå†…å®¹ï¼š1. EZLippi/Tinyhttpd2. HTTPæœåŠ¡å™¨çš„æœ¬è´¨:tinyhttpdæºç åˆ†æžåŠæ‹“å±•3. Tinyhttpdç²¾è¯»è§£æž]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>TinyHttpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_ç±»çš„ç®€å•æž„é€ æ¡ˆä¾‹]]></title>
    <url>%2F2023%2F02%2F12%2FC-%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E6%9E%84%E9%80%A0%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[è¿™ç¯‡æ–‡ç« ä¸»è¦æ˜¯ä»‹ç»ç”¨ C++ å®žçŽ°çš„ä¸€ä¸ªç®€å•æ•°å­¦ç±»â€”â€”åˆ†æ•°ç±»ï¼Œå…¶ä¸­åŒ…å«äº†å¯¹åº”çš„åŸºæœ¬è¿ç®—è§„åˆ™ã€‚ å‰è¨€å­¦ä¹ å®Œ C++ å…³äºŽç±»çš„éƒ¨åˆ†åŽï¼Œå¾ˆæƒ³è‡ªå·±åŠ¨æ‰‹å†™ä¸€å†™ï¼Œæ‰€ä»¥è¿™é‡Œå°è¯•è‡ªå·±ç”¨ C++ çš„è¯­è¨€å†™ä¸€ä¸ªç®€å•çš„ç±»ã€‚ ç±»çš„å®šä¹‰é¦–å…ˆå®Œæˆç±»çš„å®šä¹‰ï¼Œå…ˆè€ƒè™‘åˆ†æ•°çš„ç»„æˆâ€”â€”åˆ†å­å’Œåˆ†æ¯ï¼Œè¿™é‡Œä¸ºäº†æ•°æ®å¤„ç†æ—¶æ–¹ä¾¿ï¼Œç®€å•è®¤ä¸ºåˆ†å­å’Œåˆ†æ¯éƒ½æ˜¯æœ‰ç¬¦å·æ•´æ•°ï¼Œæ•°æ®ç±»åž‹å°±ç”¨intã€‚12345class Fraction &#123;private: int numerator; int denominator;&#125;; ç±»çš„åŠŸèƒ½è®¾è®¡å¥½ç±»çš„å®šä¹‰åŽï¼ŒæŽ¥ä¸‹æ¥è¦è€ƒè™‘çš„å°±æ˜¯ç±»çš„åŠŸèƒ½å‡½æ•°äº†ã€‚æŒ‰ç…§ä¸‰äº”æ³•åˆ™ï¼Œå¿…é¡»è¦ä¸ºè¿™ä¸ªç±»æä¾›æ‹·è´æž„é€ å‡½æ•°ã€æ‹·è´å¤åˆ¶è¿ç®—ç¬¦å’Œæžæž„å‡½æ•°ã€‚åŒæ—¶ï¼Œå› ä¸ºè¦æ±‚åŒ…å«åŸºæœ¬è¿ç®—è§„åˆ™ï¼Œæ‰€ä»¥å¿…é¡»è¦å®Œæˆå¯¹åº”å››ä¸ªè¿ç®—ç¬¦çš„é‡è½½ç­‰åŠŸèƒ½ã€‚ æž„é€ å‡½æ•°è¿™é‡Œæä¾›ä¸€ä¸ªæœ‰å‚æž„é€ å‡½æ•°ï¼Œæ³¨æ„åœ¨ C++ ä¸­ï¼Œå¦‚æžœæä¾›äº†æž„é€ å‡½æ•°ï¼Œç¼–è¯‘å™¨å°±ä¸å†æä¾›é»˜è®¤æž„é€ å‡½æ•°äº†ï¼Œä½†å¯ä»¥é€šè¿‡defaultå…³é”®å­—ç»§ç»­ä½¿ç”¨ç”±ç¼–è¯‘å™¨æä¾›çš„é»˜è®¤æž„é€ å‡½æ•°ã€‚æ­¤æ—¶Fraction.hæ–‡ä»¶çš„å†…å®¹ä¸ºï¼š123456789class Fraction &#123;public: Fraction() = default; Fraction(int up, int down); ~Fraction() = default;private: int numerator; int denominator;&#125;; ç±»çš„é»˜è®¤æž„é€ å‡½æ•°ä½¿ç”¨ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆï¼Œæœ‰å‚æž„é€ å‡½æ•°çš„å®šä¹‰æ”¾åœ¨Fraction.cppæ–‡ä»¶ä¸­ï¼š1Fraction::Fraction(int up, int down): numerator(up), denominator(down) &#123;&#125; æœ‰å‚æž„é€ å‡½æ•°ç›´æŽ¥ä½¿ç”¨constructor initialize listæ¥å®Œæˆå®šä¹‰ã€‚ æžæž„å‡½æ•°å› ä¸ºæ•°æ®ç»“æž„å¾ˆç®€å•ï¼Œç›´æŽ¥ä½¿ç”¨ç¼–è¯‘å™¨é»˜è®¤ç”Ÿæˆçš„æžæž„å‡½æ•°ï¼Œç›´æŽ¥æ·»åŠ åˆ°Fraction.hæ–‡ä»¶ä¸­å³å¯ã€‚123456789class Fraction &#123;public: Fraction() = default; Fraction(int up, int down); ~Fraction() = default;private: int numerator; int denominator;&#125;; æ‹·è´æž„é€ å‡½æ•°é¡¾åæ€ä¹‰ï¼Œæ‹·è´æž„é€ å‡½æ•°çš„åŠŸèƒ½å°±æ˜¯æ‹·è´åŽŸæ¥çš„å¯¹è±¡ï¼Œå¹¶æŒ‰ç…§åŽŸæ¥çš„å¯¹è±¡æž„é€ ä¸€ä¸ªæ–°å¯¹è±¡ï¼Œæ‰€ä»¥æ‹·è´æž„é€ å‡½æ•°çš„å®šä¹‰å¯ä»¥å†™æˆä¸‹é¢è¿™ç§å½¢å¼ï¼š1234Fraction::Fraction(const Fraction &amp;f) &#123; numerator = f.numerator; denominator = f.denominator;&#125; æ³¨æ„è¿™é‡Œä½¿ç”¨äº†constå’Œ&amp;ï¼Œä½¿ç”¨constæ˜¯å› ä¸ºä¸å¯¹åŽŸå¯¹è±¡åšä¿®æ”¹ï¼Œè€Œä½¿ç”¨&amp;æ˜¯å› ä¸ºæ‹·è´æž„é€ å‡½æ•°è¿˜æœ‰å®šä¹‰å‡ºæ¥ï¼Œå¦‚æžœä¸ç”¨&amp;ï¼Œç¼–è¯‘å™¨ä¼šé»˜è®¤è°ƒç”¨è¿™ä¸ªå¯¹è±¡çš„æ‹·è´æž„é€ å‡½æ•°æ¥å¤åˆ¶è¿™ä¸ªå½¢å‚ã€‚ C++ ä¸­æ‹·è´æž„é€ å‡½æ•°çš„è°ƒç”¨æ—¶æœºï¼šä½¿ç”¨ä¸€ä¸ªå·²ç»åˆ›å»ºå®Œæ¯•çš„å¯¹è±¡åˆå§‹åŒ–ä¸€ä¸ªæ–°å¯¹è±¡ã€‚å€¼ä¼ é€’çš„æ–¹å¼ç»™å‡½æ•°å‚æ•°å½¢å‚ã€‚ä»¥å€¼æ–¹å¼è¿”å›žå±€éƒ¨å¯¹è±¡ã€‚ æ‹·è´èµ‹å€¼è¿ç®—ç¬¦åœ¨ C++ ä¸­ï¼Œè¿ç®—ç¬¦æœ¬è´¨ä¸Šä¹Ÿæ˜¯å‡½æ•°ï¼Œé‡è½½è¿ç®—ç¬¦å°±æ˜¯åœ¨é‡æ–°å®šä¹‰å‡½æ•°ï¼Œè€Œæ‹·è´èµ‹å€¼è¿ç®—ç¬¦å°±æ˜¯é‡è½½èµ‹å€¼è¿ç®—ç¬¦ã€‚12345Fraction::Fraction&amp; operator=(const Fraction &amp;fra) &#123; numerator = fra.numerator; denominator = fra.denominator; return *this;&#125; æ³¨æ„è¿™é‡Œçš„ç»†èŠ‚ï¼š ä¸ºäº†å®žçŽ°a = b = c;è¿™æ ·çš„æ•ˆæžœï¼ˆä¹Ÿå°±æ˜¯é“¾å¼ç¼–ç¨‹æ³•åˆ™ï¼‰ï¼Œéœ€è¦è¿”å›žè‡ªèº«çš„å¼•ç”¨ã€‚ å½¢å‚çš„ç±»åž‹æ˜¯å¸¸é‡å¼•ç”¨ï¼Œä¸€æ–¹é¢æ˜¯é¿å…æ‹·è´å’Œä¿®æ”¹å½¢å‚ï¼Œå¦ä¸€æ–¹é¢æ— è®ºå½¢å‚çš„ç±»åž‹æ˜¯å¸¸é‡è¿˜æ˜¯éžå¸¸é‡éƒ½æ˜¯å¯ä»¥ä½¿ç”¨çš„ã€‚ è¿”å›žè‡ªèº«æ˜¯é€šè¿‡thisæŒ‡é’ˆå®Œæˆçš„ã€‚ é‡è½½ &lt;&lt; è¿ç®—ç¬¦ä¸ºäº†ä¾¿äºŽè¾“å‡ºï¼Œéœ€è¦å…ˆé‡è½½&lt;&lt;è¿ç®—ç¬¦ã€‚é‡è½½&lt;&lt;è¿ç®—ç¬¦æ—¶ï¼Œå¯ä»¥ç”¨æˆå‘˜å‡½æ•°çš„å½¢å¼é‡è½½ï¼Œä¹Ÿå¯ä»¥ç”¨å…¨å±€å‡½æ•°çš„å½¢å¼é‡è½½ã€‚åˆ©ç”¨æˆå‘˜å‡½æ•°é‡è½½&lt;&lt;è¿ç®—ç¬¦ï¼Œæœ€åŽå¾—åˆ°çš„æ•ˆæžœæ˜¯f &lt;&lt; cout;ï¼Œä½†æˆ‘ä»¬æƒ³è¦çš„æ•ˆæžœæ˜¯cout &lt;&lt; f;ï¼Œè€ŒåŽä¸€ç§ç»“æžœå¯ä»¥é€šè¿‡å…¨å±€å‡½æ•°çš„å½¢å¼é‡è½½å¾—åˆ°ã€‚ç”±äºŽå‰é¢å°†ç±»çš„æ•°æ®æˆå‘˜å®šä¹‰ä¸ºç§æœ‰å±žæ€§ï¼Œè€Œå…¨å±€å‡½æ•°ä¸ºäº†èƒ½è®¿é—®åˆ°ç±»çš„ç§æœ‰æˆå‘˜ï¼Œéœ€è¦å°†è¯¥å…¨å±€å‡½æ•°å£°æ˜Žä¸ºç±»çš„å‹å…ƒå‡½æ•°ï¼Œæ‰€ä»¥éœ€è¦åœ¨fraction.hå¤´æ–‡ä»¶ä¸­ï¼ŒåŠ å…¥å‹å…ƒå‡½æ•°å£°æ˜Žï¼š1friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, Fraction &amp;f); å°†è¯¥å‡½æ•°çš„å®šä¹‰æ”¾åˆ°test.cppä¸­ï¼š1234ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; out &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator; return out;&#125; æ³¨æ„ï¼Œè¿™é‡Œå‡å®šè¾“å‡ºåˆ†æ•°çš„å½¢å¼ç±»ä¼¼äºŽ1/2ã€‚ å®šä¹‰å¥½åŽé¢çš„è®¡ç®—è¿ç®—ç¬¦åŽï¼Œå‘çŽ°å¯èƒ½å­˜åœ¨åˆ†æ•°ä¸º 0ã€è´Ÿã€å‡åˆ†æ•°å’Œæ•´æ•°çš„æƒ…å†µï¼Œè¿™æ—¶è¾“å‡ºæ ¼å¼ä¼šæœ‰ä¸€äº›å˜åŒ–ï¼š è‹¥ä¸ºè´Ÿåˆ†æ•°ï¼Œå…ˆè¾“å‡ºè´Ÿå·ï¼Œåœ¨è¾“å‡ºåˆ†æ•°ï¼Œå¦‚-1/2 è‹¥ä¸º 0ï¼Œç›´æŽ¥è¾“å‡º0 è‹¥ä¸ºå‡åˆ†æ•°ï¼Œå…ˆè¾“å‡ºæ•´æ•°ï¼Œåœ¨è¾“å‡ºåˆ†æ•°ï¼Œå¦‚3 1/2è¡¨ç¤ºä¸‰åˆäºŒåˆ†ä¹‹ä¸€ è‹¥ä¸ºæ•´æ•°ï¼Œç›´æŽ¥è¾“å‡ºæ•´æ•°å€¼ï¼Œå¦‚2/2ï¼Œè¾“å‡º1 12345678910ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; f.reduction(); if(f.denominator == 1) cout &lt;&lt; f.numerator; else if(abs(f.numerator) &gt; f.denominator) cout &lt;&lt; f.numerator / f.denominator &lt;&lt; f.numerator % f.denominator &lt;&lt; '/' &lt;&lt; f.denominator; else cout &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator;&#125; é‡è½½ &gt;&gt; è¿ç®—ç¬¦åŒç†&lt;&lt;è¿ç®—ç¬¦çš„æ€è·¯ï¼Œå‡å®šè¾“å…¥ä¸¤ä¸ªæ•´æ•°åˆ†åˆ«ä»£è¡¨åˆ†å­å’Œåˆ†æ¯ã€‚1friend std::istream&amp; operator&gt;&gt;(std::istream &amp;in, Fraction &amp;f); 1234istream&amp; operator&gt;&gt;(istream &amp;in, Fraction &amp;f) &#123; in &gt;&gt; f.numerator &gt;&gt; f.denominator; return in;&#125; é‡è½½ == è¿ç®—ç¬¦ä¸ºäº†æ–¹ä¾¿æ¯”è¾ƒä¸¤ä¸ªå‡½æ•°ç›¸ç­‰ï¼Œé¡ºä¾¿æŠŠ==è¿ç®—ç¬¦ä¹Ÿé‡è½½äº†ï¼Œåˆ¤æ–­é€»è¾‘ä¹Ÿå¾ˆç®€å•ï¼Œé»˜è®¤æ‰€æœ‰çš„åˆ†æ•°éƒ½æ˜¯æœ€ç®€å½¢å¼çš„ï¼Œåªè¦åˆ†å­åˆ†æ¯åŒæ—¶ç›¸ç­‰å°±æ˜¯ç›¸ç­‰çš„åˆ†æ•°ã€‚12345bool operator==(const Fraction &amp;fra) &#123; if(numerator == fra.numerator &amp;&amp; denominator == fra.denominator) return true; else return false;&#125; ==è¿ç®—ç¬¦é‡è½½å®ŒæˆåŽï¼Œå¯ä»¥ç›´æŽ¥ç”¨æ¥é‡è½½!=è¿ç®—ç¬¦ã€‚ åŠŸèƒ½å‡½æ•°åœ¨è®¾è®¡åˆ†æ•°çš„è¿ç®—è§„åˆ™ä¹‹å‰ï¼Œéœ€è¦å…ˆå‡†å¤‡å¥½ä¸€äº›åŠŸèƒ½å‡½æ•°æ¥ä¾¿äºŽè®¡ç®—ã€‚ æœ€å°å…¬çº¦æ•°è¿™ä¸ªå‡½æ•°å®šä¹‰çš„å£°æ˜Žæ”¾åœ¨function.hæ–‡ä»¶ä¸­ï¼Œå®šä¹‰æ”¾åœ¨å¯¹åº”çš„function.cppä¸­ï¼Œä½¿ç”¨è¾—è½¬ç›¸é™¤æ³•çš„æ€è·¯è®¡ç®—æœ€å¤§å…¬çº¦æ•°ã€‚1234long long gcd(int a, int b) &#123; if(b == 0) return a; else return gcd(b, a % b);&#125; ç»å¯¹å€¼å‡½æ•°è¿™ä¸ªå‡½æ•°å®šä¹‰çš„å£°æ˜Žæ”¾åœ¨function.hæ–‡ä»¶ä¸­ï¼Œå®šä¹‰æ”¾åœ¨å¯¹åº”çš„function.cppä¸­ï¼ŒåŠŸèƒ½æ˜¯è¿”å›žintåž‹å˜é‡çš„ç»å¯¹å€¼ã€‚123int abs(int a) &#123; return a &gt; 0 ? a : -a;&#125; åŒ–ç®€å‡½æ•°å½“åˆ†æ¯ä¸Žåˆ†å­å¯ä»¥çº¦åˆ†æ—¶ï¼Œè¦åŒ–ä¸ºæœ€ç®€åˆ†æ•°ã€‚è€ƒè™‘åˆ°ç‰¹æ®Šæƒ…å†µï¼Œå¦‚æžœåˆ†å­ä¸º 0ï¼Œå°±è®©åˆ†æ¯ä¸º 1ã€‚12345678910111213void Fraction::reduction() &#123; if(denominator &lt; 0) &#123; numerator = -numerator; denominator = -denominator; &#125; if(numerator == 0) &#123; denominator = 1; &#125; else &#123; int d = gcd(abs(numerator), abs(denominator)); numerator /= d; denominator /= d; &#125;&#125; é‡è½½ + è¿ç®—ç¬¦åˆ†æ•°çš„åŠ æ³•æœ‰ç‚¹éº»çƒ¦ï¼Œéœ€è¦å…ˆé€šåˆ†ï¼Œè®¡ç®—åŽï¼Œå†çº¦åˆ†ã€‚ä¸è¿‡ï¼Œæˆ‘ä»¬å·²ç»æŠŠåŒ–ç®€çš„è¿‡ç¨‹ç‹¬ç«‹å‡ºæ¥äº†ï¼Œæ‰€ä»¥ç›´æŽ¥è®¡ç®—ï¼Œç„¶åŽå†è°ƒç”¨åŒ–ç®€å‡½æ•°å³å¯ã€‚1234567Fraction Fraction::operator+(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator + fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; æŽ¥ä¸‹æ¥ï¼Œå¦‚æ³•ç‚®åˆ¶å…¶ä»–è¿ç®—ç¬¦ã€‚ é‡è½½ - è¿ç®—ç¬¦1234567Fraction Fraction::operator-(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator - fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; é‡è½½ * è¿ç®—ç¬¦1234567Fraction Fraction::operator*(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.numerator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125; é‡è½½ / è¿ç®—ç¬¦1234567Fraction Fraction::operator/(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator; res.denominator = denominator * fra.numerator; res.reduction(); return res;&#125; æ€»ç»“å°½ç®¡æ˜¯ä¸ªç®€å•çš„æ¡ˆä¾‹ï¼Œä½†å…¶ä¸­æ¶‰åŠäº†å¾ˆå¤š C++ çš„åŸºç¡€çŸ¥è¯†ç‚¹ã€‚æœ€åŽè´´å‡ºæ‰€æœ‰æ–‡ä»¶ï¼ˆå…¶å®žä¸€å…±ä¹Ÿå°±äº”ä¸ªæ–‡ä»¶ðŸ˜‚ï¼‰çš„ä»£ç ï¼šfraction.h1234567891011121314151617181920212223#pragma once#include &lt;iostream&gt;class Fraction &#123;public: friend std::ostream&amp; operator&lt;&lt;(std::ostream &amp;out, Fraction &amp;f); friend std::istream&amp; operator&gt;&gt;(std::istream &amp;in, Fraction &amp;f); Fraction() = default; Fraction(int up, int down); Fraction(const Fraction &amp;fra); Fraction operator=(const Fraction &amp;fra); bool operator==(const Fraction &amp;fra); Fraction operator+(const Fraction &amp;fra); Fraction operator-(const Fraction &amp;fra); Fraction operator*(const Fraction &amp;fra); Fraction operator/(const Fraction &amp;fra); ~Fraction() = default;private: int numerator; int denominator; void reduction();&#125;; fraction.cpp12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include "fraction.h"#include "function.h"Fraction::Fraction(int up, int down): numerator(up), denominator(down)&#123;&#125;Fraction::Fraction(const Fraction &amp;f) &#123; numerator = f.numerator; denominator = f.denominator;&#125;Fraction Fraction::operator=(const Fraction &amp;fra) &#123; numerator = fra.numerator; denominator = fra.denominator; return *this;&#125;bool Fraction::operator==(const Fraction &amp;fra) &#123; if(numerator == fra.numerator &amp;&amp; denominator == fra.denominator) return true; else return false;&#125;void Fraction::reduction() &#123; if(denominator &lt; 0) &#123; numerator = -numerator; denominator = -denominator; &#125; if(numerator == 0) &#123; denominator = 1; &#125; else &#123; int d = gcd(abs(numerator), abs(denominator)); numerator /= d; denominator /= d; &#125;&#125;Fraction Fraction::operator+(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator + fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator-(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator - fra.numerator * denominator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator*(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.numerator; res.denominator = denominator * fra.denominator; res.reduction(); return res;&#125;Fraction Fraction::operator/(const Fraction &amp;fra) &#123; Fraction res; res.numerator = numerator * fra.denominator; res.denominator = denominator * fra.numerator; res.reduction(); return res;&#125; function.h1234#pragma oncelong long gcd(int a, int b);int abs(int a); function.cpp12345678long long gcd(int a, int b) &#123; if(b == 0) return a; else return gcd(b, a % b);&#125;int abs(int a) &#123; return a &gt; 0 ? a : -a;&#125; test.cpp1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include "fraction.h"using namespace std;ostream&amp; operator&lt;&lt;(ostream &amp;out, Fraction &amp;f) &#123; f.reduction(); if(f.denominator == 1) cout &lt;&lt; f.numerator; else if(abs(f.numerator) &gt; f.denominator) cout &lt;&lt; f.numerator / f.denominator &lt;&lt; ' ' &lt;&lt; f.numerator % f.denominator &lt;&lt; '/' &lt;&lt; f.denominator; else cout &lt;&lt; f.numerator &lt;&lt; '/' &lt;&lt; f.denominator; return out;&#125;istream&amp; operator&gt;&gt;(istream &amp;in, Fraction &amp;f) &#123; in &gt;&gt; f.numerator &gt;&gt; f.denominator; return in;&#125;int main() &#123; Fraction a, b, res; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; b &lt;&lt; endl; if(a == b) cout &lt;&lt; "a = b" &lt;&lt; endl; else cout &lt;&lt; "a != b" &lt;&lt; endl; /* è¿™é‡Œéœ€è¦ç”¨ res æŽ¥æ”¶è®¡ç®—ç»“æžœï¼Œå¦‚æžœç›´æŽ¥å†™æˆ cout &lt;&lt; a + b &lt;&lt; endl; ä¼šå­˜åœ¨ä¸Ž &lt;&lt; çš„ä¼˜å…ˆçº§é—®é¢˜ï¼Œä»Žè€Œå¾—ä¸åˆ°æ­£ç¡®çš„ç»“æžœã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥å†™æˆ cout &lt;&lt; (a + b) &lt;&lt; endl; */ res = a + b; cout &lt;&lt; res &lt;&lt; endl; res = a - b; cout &lt;&lt; res &lt;&lt; endl; res = a * b; cout &lt;&lt; res &lt;&lt; endl; res = a / b; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2023_01_æœˆæ€»ç»“]]></title>
    <url>%2F2023%2F02%2F12%2F2023-01-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[è¦è¿‡å¹´å•¦~ Every Breath You Take - The PoliceYour browser does not support the audio tag. ä¸€æœˆåˆï¼Œåˆšåˆšé˜³åº·å°±é‡æ–°å›žåˆ°å…¬å¸ä¸Šç­äº†ã€‚å°½ç®¡å¯¹å·¥ä½œè¿˜ä¸ç†Ÿæ‚‰ï¼Œä½†æ˜¯èº«ä½“å·²ç»é€æ¸é€‚åº”äº†ä¸Šç­çš„èŠ‚å¥ã€‚åäºŒæœˆä¸‹æ—¬åšå¥½çš„å·¥ä½œï¼Œä¹Ÿåœ¨ä¸€æœˆåˆâ€œæŠ•äº§â€äº†ï¼Œè¿™æ˜¯å¹´å‰æœ€åŽçš„äº‹æƒ…äº†ã€‚å¿™å®Œè¿™ä¸ªäº‹æƒ…ä¹‹åŽï¼Œå°±å¯ä»¥å¹³é™çš„ç­‰å¾…è¿‡å¹´äº†ã€‚æåˆ°è¿‡å¹´ï¼Œå°±ä¸å…å¾—è¦ä¹°ç¥¨ï¼Œè€Œä¹°ç¥¨åˆæ˜¯ä¸ªéº»çƒ¦äº‹ã€‚å›žåŽ»å¾—ä¹°å›žå®¶çš„ç¥¨ï¼Œå›žæ¥å¾—ä¹°è¿”ç¨‹çš„ç¥¨ï¼Œä¸€æ—¦æ²¡æŠ¢åˆ°å°±å¾—è€ƒè™‘å…¶ä»–çš„äº¤é€šæ–¹å¼ï¼Œå…¶å®žä¹Ÿä¸å¤–ä¹Žå°±æ˜¯æ¢ä¹˜è€Œå·²ã€‚ä¸ç®¡æ€Žä¹ˆé€‰æ‹©ï¼Œæ€»æ˜¯å¾ˆæŠ˜è…¾äººï¼Œè¿™å¤§æ¦‚ä¹Ÿæ˜¯æ¼‚æ³Šåœ¨å¤–çš„æ¸¸å­å¿ƒé…¸çš„æ²§æµ·ä¸€ç²Ÿäº†å§ï¼Œä¸æä¹Ÿç½¢ã€‚ ä»Šå¹´å›žå®¶åŽï¼Œçˆ¶æ¯æ²¡æœ‰å‘å¾€å¹´ä¸€æ ·â€œçŒè¾“â€ä¸€äº›ç†å¿µï¼Œå–è€Œä»£ä¹‹çš„æ˜¯è½»æ¾çš„è°ˆè¯ã€‚ä¸Žæ­¤å¯¹åº”ï¼Œæˆ‘ä¹Ÿä¸å†å¦„æƒ³æ”¹å˜ä»–ä»¬çš„æƒ³æ³•äº†ï¼Œå› ä¸ºä»–ä»¬æœ¬è¯¥å¦‚æ­¤...å¦å¤–ï¼Œæ•´ä¸ªè¿‡å¹´æœŸé—´éƒ½åœ¨å®¶é‡Œå¾…ç€ï¼Œå“ªé‡Œéƒ½æ²¡æœ‰åŽ»ï¼Œå“ˆå“ˆï¼Œä¸å¾—ä¸è¯´ï¼Œè¿˜æ˜¯åœ¨å®¶é‡Œå¥½ã€‚ å¯æƒœï¼Œæ—¶é—´è¿‡å¾—å¾ˆå¿«ï¼Œåˆå…­è‡ªå·±å°±è¸ä¸Šäº†è¿”ç¨‹ï¼Œå¿ƒé‡Œè™½ç„¶æœ‰äº›è®¸ä¸èˆï¼Œä½†ä¹Ÿä¸èƒ½åœæ­¢è‡ªå·±çš„è„šæ­¥â€”â€”åˆä¸ƒä¸Šç­å•¦ï¼ æ–°çš„ä¸€å¹´åˆ°æ¥äº†ï¼Œæš‚æ—¶æ²¡æœ‰æƒ³å¥½è¿™ä¸€å¹´è¦åšäº›ä»€ä¹ˆæ ·çš„äº‹æƒ…ï¼Œä¸è¿‡å¸Œæœ›è‡ªå·±æ„Ÿå…´è¶£çš„é¢†åŸŸéƒ½èƒ½æœ‰æ‰€å¢žå¼ºå§ï¼Œæ¯”å¦‚ï¼šå¼¹ç´æŠ€å·§ã€ç¼–ç¨‹åŠŸåº•ã€é˜…è¯»å¹¿åº¦ç­‰ç­‰ï¼Œå“ˆå“ˆã€‚ å¯¹äº†ï¼Œå€¼å¾—ä¸€æçš„æ˜¯ï¼Œè¿™æ¬¡æ˜¥èŠ‚å‡æœŸè¯»å®Œäº†ã€Šä¹¡åœŸä¸­å›½ã€‹ï¼Œæ”¶èŽ·æŒºå¤šï¼Œä½†æ˜¯ä¸æ‡‚çš„åœ°æ–¹ä¹Ÿæœ‰å¾ˆå¤šï¼Œè‡ªå·±æžœç„¶è¿˜æ˜¯æ— çŸ¥å•Š~æ²¡äº‹ï¼Œä¸‹æ¬¡é‡è¯»çš„æ—¶å€™åº”è¯¥ä¼šæœ‰æ›´å¤šæ”¶èŽ·äº†ã€‚ æœ€åŽï¼Œå¸Œæœ›æˆ‘çš„å®¶äººã€æœ‹å‹ä»¬éƒ½èƒ½èº«ä½“å¥åº·ï¼]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_å¹´æœ«å°ç»“]]></title>
    <url>%2F2023%2F01%2F02%2F2022-%E5%B9%B4%E6%9C%AB%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä¸çŸ¥ä¸è§‰ï¼Œ2022 å·²ç»è¿‡åŽ»äº†... æˆ‘æƒ³è¦çš„æ„Ÿè§‰ - å¼ éœ‡å²³Your browser does not support the audio tag. ä»Šå¤©æ˜¯ 2023 å¹´çš„ç¬¬äºŒå¤©ï¼Œä¹Ÿæ˜¯å…ƒæ—¦å‡æœŸçš„æœ€åŽä¸€å¤©ã€‚æœ¬æ¥è¿™ç¯‡æ–‡ç« åº”è¯¥åœ¨ 2022 çš„æœ€æœ«å†™å‡ºæ¥çš„ï¼Œå¯æ˜¯è‡ªå·±å¥½åƒåˆå·æ‡’äº†ï¼Œå“ˆå“ˆã€‚çªç„¶æƒ³åˆ°äº†ä¸Šåˆä¸­çš„è‡ªå·±ï¼Œæ¯é€¢å‘¨æœ«ï¼Œå…ˆçŽ©å†è¯´ï¼Œç­‰åˆ°å‘¨æœ«çš„ä¸‹åˆæ‰å¼€å§‹å¤„ç†å‘¨æœ«çš„å®¶åº­ä½œä¸šï¼ŒçŽ°åœ¨çš„æƒ…å†µå¥½åƒå¦‚å‡ºä¸€è¾™~ðŸ¤£ä½†æ˜¯ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œè¿™ä»¶äº‹æƒ…è¿˜æ˜¯è¦åšå‘€ï¼ å¥½äº†ï¼Œå›žæƒ³ä¸€ä¸‹ä»Šå¹´åœ¨å¹²ä»€ä¹ˆå§ã€‚ 1 - 2 æœˆè¿™æ˜¯åŽ»å¹´è¿‡å¹´çš„æ—¶å€™äº†ï¼Œæˆ‘è¿˜åœ¨å®¶è‡ªå·±ç¢ç£¨è‡ªå·±çš„ä¸–ç•Œã€‚ä¸´è¿‘è¿‡å¹´ï¼Œä¹Ÿå¸®å®¶é‡ŒåŠžäº†ä¸€äº›å¹´è´§ã€‚ä¸è¿‡ï¼Œæœ€è¾›è‹¦åº”è¯¥æ˜¯æ¯äº²äº†ï¼Œå…ˆæ˜¯å›žäº†ä¸€è¶Ÿè€å®¶ï¼Œå®‰æŽ’äº†ä¸€ä¸‹è¿‡å¹´çš„äº‹æƒ…ï¼Œç„¶åŽåˆèµ¶åˆ° SYï¼Œç…§é¡¾æ¥å¹´è¦é«˜è€ƒçš„å¦¹å¦¹ã€‚è¿‡å¹´çš„äº‹æƒ…å°±å¾ˆç®€å•äº†ï¼Œå¹´å¤œé¥­æ˜¯æˆ‘çƒ§çš„ï¼Œè€ã€ä¸­ã€é’ä¸‰ä»£äººä¸€èµ·åç€åƒäº†é¡¿å›¢å¹´é¥­ï¼Œè°ˆçš„äº‹æƒ…ä¾ç„¶æ˜¯å…³äºŽæˆ‘çš„äº‹æƒ…ï¼Œå‘µå‘µï¼Œè¿™äº›å·²ç»ä¹ ä»¥ä¸ºå¸¸äº†ï¼Œæ”¾åœ¨å¿ƒé‡Œå°±å¥½ã€‚æ„æ–™ä¹‹ä¸­ï¼ˆä¹‹æ‰€ä»¥è¿™ä¹ˆè¯´ï¼ŒåŽé¢ä¼šæåˆ°ï¼‰çš„æ˜¯å°æ—¶å€™ä¸€èµ·é•¿å¤§çš„è¡¨å“¥ç«Ÿç„¶åœ¨æˆ‘å®¶å¾…äº†å¥½å‡ å¤©ï¼Œæœ‰æ¬¡åƒé¥­ç«Ÿç„¶è¿˜å–é«˜åäº†ï¼Œé¥­æ¡Œä¸Šï¼Œä¹Ÿå‘æˆ‘ã€æˆ‘çˆ¶äº²è¡¨è¾¾äº†ä»–è‡ªå·±çš„åŽ‹åŠ›ã€‚æ˜¯å•Šï¼Œä»–ä¸€æ™ƒ 28 äº†ï¼Œè¿˜æ²¡ç»“å©šï¼Œå¿ƒé‡ŒåŽ‹åŠ›å¾ˆå¤§ã€‚æˆ‘ä¹Ÿè¯•ç€å®‰æ…°ä»–ï¼Œä½ å¥³æœ‹å‹ä»Žé«˜ä¸­è°ˆåˆ°çŽ°åœ¨å·¥ä½œï¼Œä¸€èµ·è¿‡äº†éƒ½å¥½å‡ å¹´äº†ï¼Œè€å¤«è€å¦»äº†ï¼Œè¿˜æ€•ä¸èƒ½ç»“å©šï¼Ÿç»“æžœä»–åªæ˜¯æ‘‡æ‘‡å¤´ï¼Œç®€å•è¯´äº†å¥ç»“å©šè¦æˆ¿å•Šã€‚åŽæ¥åˆèŠåˆ°äº†ä»–çš„çˆ¶æ¯ï¼Œåœ¨é…’ç²¾çš„ä½œç”¨ä¸‹ï¼Œä»–ä¹Ÿä¸åœ¨æŽ§åˆ¶è‡ªå·±çš„æƒ…æ„Ÿï¼Œæ´’ä¸‹äº†å‡ æ»´çƒ­æ³ª...ä¹Ÿè®¸æ˜¯è‡ªå·±ä¸€äº‹æ— æˆå¯¹çˆ¶æ¯çš„æ„§ç–šå§ã€‚åŽé¢åˆåŽ»äº†å…¶ä»–äº²æˆšå®¶é‡Œåƒé¥­ï¼Œè‡ªå·±çªç„¶å‘çŽ°ï¼Œå¥½åƒæ„Ÿè§‰éƒ½ä¸ä¸€æ ·äº†ã€‚ 3 - 4 æœˆè¿™ä¸¤ä¸ªæœˆæ˜¯è‡ªå·±å‡†å¤‡æ‰¾å·¥ä½œçš„æ—¶é—´ï¼Œç¬¬ä¸€ä»¶äº‹å°±æ˜¯å·©å›ºè‡ªå·±çš„ç®—æ³•èƒ½åŠ›ï¼Œå…¶å®žæ˜¯è¯•è¯•è‡ªå·±çš„è„‘å­æ˜¯ä¸æ˜¯è¿˜æ˜¯è½¬çš„åŠ¨ï¼Œç»“æžœå‘çŽ°ï¼Œè¿˜æ˜¯è½¬çš„åŠ¨çš„ðŸ˜‚ã€‚å¦å¤–åœ¨è¿™ä¸ªæ—¶é—´å†™äº†å¾ˆå¤šå’Œç®—æ³•é¢˜ç›¸å…³çš„ blogï¼Œè¿™äº›å¯ä»¥åœ¨å½’æ¡£é¡µé¢çœ‹ï¼Œè‡ªå·±ä¹Ÿç¡®å®žæ”¶èŽ·äº†ä¸€äº›ä¸œè¥¿ã€‚å°½ç®¡è¿™æ—¶æˆ‘çš„æ—¶é—´å¤§éƒ¨åˆ†éƒ½èŠ±åœ¨å†™ä»£ç ä¸Šï¼Œä½†æ˜¯è®©æˆ‘å°è±¡æœ€æ·±åˆ»çš„äº‹æƒ…æ˜¯å†™äº†å‡ ä¸ªå°æ—¶çš„ä»£ç åŽï¼Œä¸€ä¸ªäººåœ¨ç”°é‡Žä¸Šæºœè¾¾ï¼Œçœ‹çœ‹èº«è¾¹çš„ç¨»ç”°å’Œå°æ²³ï¼Œçªç„¶æ„è¯†åˆ°åŽŸæ¥ä¸–ç•Œä¸Šè¿˜æœ‰å…¶ä»–çš„ç”Ÿç‰©å•Šã€‚ 4 - 5 æœˆè¿™ä¸¤ä¸ªæœˆåœ¨ç–¯ç‹‚ç»ƒç´ï¼Œå“ˆå“ˆï¼ŒäºŒæ‰‹æ·˜äº†æœ¬ã€Šæ°‘è°£å‰ä»–è€ƒçº§æ•™ç¨‹ã€‹ï¼Œç»ƒäº†å¥½å‡ é¦–ä¸Šé¢çš„æ­Œï¼Œä¸€çº§ä¸€çº§çš„ï¼Œæœ€åŽæŠŠã€Šæ™®é€šæœ‹å‹ã€‹çš„ç™¾åˆ†ä¹‹ä¸ƒåæ‹¿ä¸‹äº†ã€‚è¿™æœŸé—´å¯¹æ°‘è°£å‰ä»–çš„å¼¹å”±æŠ€å·§ã€å’Œå¼¦ç†è®ºæ”¶èŽ·å¾ˆå¤šï¼Œä½†æ˜¯æ„Ÿè§‰è¿˜å¾ˆä¸å¤Ÿã€‚å½“ç„¶äº†ï¼Œè‡ªå·±è¿˜æ˜¯ä¾ç„¶å†™ä»£ç ï¼Œå¶å°”è¿˜è·‘åŽ»é’“é’“é±¼ï¼Œå®ˆåœ¨æ²³è¾¹ä¸€ä¸‹åˆï¼Œç­‰åˆ°å‚æ™šæèµ·é±¼ç¯“ï¼Œçœ‹ç€è¹¦è¹¦è·³è·³çš„é±¼å„¿ï¼Œå¿ƒé‡Œç”­ææœ‰å¤šæ¬¢ä¹äº†ðŸ¤£~ 6 æœˆæœ¬æ¥æ‰“ç®—åŽ»æœ‹å‹å° z æ‰€åœ¨çš„åŸŽå¸‚æ‰¾å·¥ä½œï¼Œä½†æ˜¯å› ä¸ºç–«æƒ…å…³ç³»ï¼Œå°åŸŽäº†ï¼Œè®¡åˆ’ææµ…ï¼Œç´¢æ€§ç»§ç»­è¿‡è‡ªå·±çš„ç”Ÿæ´»ï¼Œå¤©å¤©å¼¹ç´ã€æ‰“ç ï¼Œå€’ä¹Ÿè¿‡çš„æ¶ˆé£ã€‚ 7 - 8 æœˆå¦¹å¦¹é«˜è€ƒé¡ºåˆ©ç»“æŸï¼Œå› ä¸ºå¡«å†™å¿—æ„¿çš„å…³ç³»ï¼Œéœ€è¦æˆ‘åŽ»ä¸€è¶Ÿï¼Œæœ¬æ¥æ¯äº²å’Œçˆ¶äº²å·²ç»è¿‡åŽ»äº†ï¼Œä½†æ˜¯è·Ÿå¦¹å¦¹çš„æ²Ÿé€šå¥½åƒæ— æ³•é¡ºåˆ©è¿›è¡Œï¼Œç´¢æ€§æˆ‘å°±è¿‡åŽ»äº†ã€‚åˆ°äº†ä¹‹åŽï¼Œåˆä¹…è¿çš„åƒåˆ°äº†æ¯äº²åšçš„ðŸŸï¼ŒçœŸé¦™~è·Ÿå¦¹å¦¹å¥½å¥½èŠäº†ä¸‰å¤©åŽï¼Œå¿—æ„¿çš„äº‹æƒ…ç»“æŸäº†ï¼ŒæŽ¥ä¸‹æ¥å°±æ˜¯ç­‰å¾…å½•å–ç»“æžœäº†ã€‚çˆ¶äº²å’Œæ¯äº²ä¹Ÿéƒ½å›žåˆ°è‡ªå·±çš„å·¥ä½œä¸ŠåŽ»äº†ï¼Œå‰©ä¸‹æˆ‘è·Ÿå¦¹å¦¹ä¸¤ä¸ªäººã€‚æœ¬æ¥ä»¥ä¸ºä¼šè¿‡å‡ å¤©æ¶ˆé£æ—¥å­ï¼Œç»“æžœç‰™ç–¼åˆæ‰¾ä¸Šé—¨äº†ã€‚æŠ˜è…¾å‡ å¤©éƒ½æ²¡ä¼‘æ¯å¥½ï¼ŒåŽ»åŒ»é™¢ä¹‹åŽæ‰çŸ¥é“æ˜¯æ€¥æ€§ç‰™é«“ç‚Žï¼Œåˆæ˜¯åƒè¯ï¼Œåˆæ˜¯æ ¹ç®¡æ²»ç–—ï¼ŒèŠ±æŽ‰ä¸‰åƒå—é’±ï¼Œè€—æ—¶äºŒåå¤šå¤©ï¼Œç»ˆäºŽç®—æ˜¯ç»“æŸäº†...åŽæ¥ï¼Œå½•å–ç»“æžœå‡ºæ¥åŽå°±æ”¶æ‹¾ä¸œè¥¿å›žè€å®¶äº†ï¼Œè¿™æ—¶æ‰æ„è¯†åˆ°ï¼Œè¿™æ˜¯å®¶é‡Œå››ä¸ªäººæœ€åŽä¸€æ¬¡ä¸€èµ·é½èš SY è¿™ä¸ªåŸŽå¸‚äº†ã€‚å›žåˆ°è€å®¶åŽï¼Œåˆæ€¥åŒ†åŒ†çš„åŠžå®Œäº†å‡å­¦å®´ï¼Œè™½ç„¶å¾ˆç´¯ï¼Œä½†æ˜¯äº‹æƒ…éƒ½é¡ºåˆ©è§£å†³äº†ã€‚ 9 - 11 æœˆä¹æœˆæ˜¯å¼€å­¦çš„æ—¥å­ï¼Œä¹Ÿæ˜¯æˆ‘åˆå¤§ä¸€å²çš„æœˆä»½ã€‚å¦¹å¦¹çš„å¤§å­¦å¼€å­¦åŽï¼Œé€å¦¹å¦¹åŽ»å­¦æ ¡çš„æ—¶å€™åŽ»äº†ä¸€è¶Ÿ WHã€‚å®Œäº‹ä¹‹åŽï¼ŒåˆåŽ»äº†ä¸€è¶Ÿé»„é¹¤æ¥¼ï¼Œé¢†ç•¥äº†ä¸€ä¸‹â€œçŽ°ä»£ç¾Žæ™¯â€ã€‚å›žåˆ°å®¶åŽï¼Œåˆå¼€å§‹æ€å¿–è‡ªå·±æ‰¾å·¥ä½œçš„äº‹æƒ…äº†ï¼Œæƒ³ç€è¶ç€ç§‹æ‹›ï¼Œå‡ºæ¥æ‰¾å·¥ä½œå§ã€‚10 æœˆ 11 æ—¥å‡ºé—¨äº†ï¼ŒåˆèŠ±äº† 1 ä¸ªæœˆæ—¶é—´ï¼Œç»ˆäºŽæ‰¾åˆ°äº†ä¸€ä»½å·¥ä½œðŸ˜‚ã€‚ 12 æœˆæ•´ä½“è€Œè¨€ï¼ŒåäºŒæœˆæ˜¯å……æ»¡å·¥ä½œå’Œå­¦ä¹ çš„ä¸€ä¸ªæœˆã€‚æœˆåˆæ—¶ï¼Œæ¯å¤©æ—©ä¸Šå¾—å…­ç‚¹å¤šèµ·æ¥ï¼Œåä¸Šä¸€ä¸ªå¤šå°æ—¶çš„åœ°é“ï¼Œå†éª‘ 20 åˆ†é’Ÿçš„è½¦ï¼Œæ‰èƒ½åˆ°è¾¾å·¥ä½œåœ°ç‚¹ï¼Œæ¯å¤©éƒ½å¾ˆå¿™ç¢Œçš„å¥”æ³¢åœ¨å·¥ä½œåœ°ç‚¹å’Œä½çš„åœ°æ–¹ä¹‹é—´ã€‚åˆ°äº†æœˆä¸­ï¼Œè¢«æ–°å† ç»™ä¸Šèº«äº†ï¼Œç›´æŽ¥å±…å®¶åŠä¸ªæœˆäº†ðŸ˜‚ï¼Œç›®å‰ç®—æ˜¯ç†¬è¿‡æ¥äº†ï¼Œå‡†å¤‡æ˜Žå¤©ä¸Šç­äº†å“ˆå“ˆã€‚ å›žå¤´çœ‹çœ‹ï¼Œä»Šå¹´å¥½åƒä»€ä¹ˆäº‹æƒ…ä¹Ÿæ²¡æœ‰åšï¼Œæ²¡æœ‰å…·ä½“çš„æ¸…å•åˆ—å‡ºè‡ªå·±åšçš„äº‹æƒ…ï¼Œå¥½åƒè¿˜çœŸçš„æ„Ÿè§‰æ˜¯åœ¨ç©ºåº¦å…‰é˜´å‘¢ã€‚ä¸è¿‡ï¼Œä»”ç»†ä¸€æƒ³ï¼Œä¸æ˜¯è‡ªå·±æ²¡æœ‰åšä»€ä¹ˆï¼Œè€Œåœ¨äºŽçŸ­æœŸä¹‹å†…ï¼Œè¿™äº›ä¸œè¥¿è¿˜æ²¡åŠžæ³•æ˜¾çŽ°å‡ºæ¥ï¼Œæ‰€ä»¥ï¼Œæ²‰ä½æ°”å§~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_05]]></title>
    <url>%2F2022%2F12%2F26%2FNand2Tetris-Part1-05%2F</url>
    <content type="text"><![CDATA[è¿™å‘¨å¥½åƒè¦å¼€å§‹è®²å…·ä½“çš„è®¡ç®—æœºç»“æž„äº†... Unit 5.1 Von Neumann Architectureè¿™èŠ‚è¯¾çš„æ ‡é¢˜æ˜¯å†¯è¯ºä¾æ›¼ç»“æž„ï¼Œå®žé™…ä¸Šè®²åˆ°äº† 3 ä¸ªæ¦‚å¿µï¼šæ•°æ®æ€»çº¿ï¼ˆdata busï¼‰ã€åœ°å€æ€»çº¿ï¼ˆaddress busï¼‰å’ŒæŽ§åˆ¶æ€»çº¿ï¼ˆcontrol busï¼‰ã€‚è¿™äº›æ€»çº¿å°±æ˜¯è®¡ç®—æœºå†…éƒ¨ä¿¡æ¯çš„å…¬è·¯ï¼Œæ¯”ç‰¹æµåœ¨è¿™äº›æ€»çº¿ä¸ŠæµåŠ¨ï¼Œä¸åŒåŠŸèƒ½çš„æ¯”ç‰¹æµåœ¨ä¸åŒçš„æ€»çº¿ä¸ŠæµåŠ¨ã€‚è®¡ç®—æœºçš„ç¡¬ä»¶è®¾å¤‡ï¼Œå¦‚å†…å­˜ã€CPUç­‰éƒ½è¿žæŽ¥åœ¨è¿™äº›æ€»çº¿ä¸Šï¼Œæ—¶ä¸æ—¶çš„è¯»å…¥ä¿¡æ¯å’Œè¾“å‡ºä¿¡æ¯ã€‚ Unit 5.2 The Fetch-Execute Cycleè¿™èŠ‚è¯¾ä¸»è¦åœ¨è®²è§£æå–-æ‰§è¡Œå‘¨æœŸï¼ˆFetch-Execute Cycleï¼‰çš„å¤§è‡´è¿‡ç¨‹ã€‚æŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œç¨‹åºçš„æ•°æ®å’ŒæŽ§åˆ¶æŒ‡ä»¤éƒ½ä¿å­˜åœ¨ä¸€å—å†…å­˜èŠ¯ç‰‡ä¸­ï¼Œé‚£ CPU æ˜¯å¦‚ä½•çŸ¥é“ä»€ä¹ˆæ—¶å€™è¯¥æ‰§è¡Œé‚£æ¡æŒ‡ä»¤ï¼Œå¦‚ä½•åŽ»åˆ†è¾¨æŽ§åˆ¶æŒ‡ä»¤å’Œæ•°æ®å‘¢ï¼Ÿ å®žé™…ä¸Šï¼ŒCPU æœ‰ä¸€ä¸ªå«åš Program Counter çš„ç¨‹åºå¯„å­˜å™¨æ¥ä¸“é—¨è®°å½•å†…å­˜ä¸­ä¿å­˜æŒ‡ä»¤çš„åœ°å€ï¼Œæ•°æ®åœ°å€å’ŒæŒ‡ä»¤åœ°å€ï¼ˆProgram Counterï¼‰ä¸­ä¿å­˜æ¯”ç‰¹çš„ä¸€åŒæµå…¥ Multiplexor ä¸­ï¼Œè€Œè¿™ä¸ªå¤šè·¯å¤ç”¨å™¨ç”¨ä¸€ä½æŽ§åˆ¶ä½æ¥åŒºåˆ†çŽ°åœ¨æ˜¯æå–ï¼ˆFetchï¼‰å‘¨æœŸè¿˜æ˜¯æ‰§è¡Œï¼ˆExecuteï¼‰å‘¨æœŸã€‚å¦‚æžœæ˜¯æå–æ¨¡å¼ï¼Œé‚£ä¹ˆå°±è¯»å–æŒ‡ä»¤åœ°å€ï¼Œå°†å…·ä½“çš„æŒ‡ä»¤åŠ è½½åˆ° CPU ä¸­ï¼›å¦‚æžœæ˜¯æ‰§è¡Œå‘¨æœŸï¼Œå°±è¯»å–æ•°æ®åœ°å€ï¼Œå°†å…·ä½“çš„æ•°æ®åŠ è½½åˆ° CPU ä¸­ç”¨äºŽæ‰§è¡Œã€‚ Unit 5.3 Central Processing Unitè¿™èŠ‚è¯¾çš„ä¸»è¦å†…å®¹æ˜¯ CPU çš„å†…éƒ¨ç»“æž„ã€åŠŸèƒ½å’Œå¯¹åº”çš„å®žçŽ°åŽŸç†ï¼Œè®²çš„ä¸æ˜¯å¾ˆæ·±å…¥ã€‚CPU å®žé™…ä¸Šå°±æ˜¯ ALU å’Œå…¶ä»–å¯„å­˜å™¨çš„ç»„åˆä½“ï¼Œä¸Žè®¡ç®—ç›¸å…³çš„åŠŸèƒ½æ˜¯ç”± ALU å®žçŽ°çš„ï¼Œè¿‡ç¨‹æŽ§åˆ¶æ˜¯ç”± ALU å’Œå…¶ä»–å¯„å­˜å™¨ç»„åˆå®Œæˆçš„ã€‚è€å¸ˆç”¨ä¸Šå‘¨è®²çš„ A æŒ‡ä»¤å’Œ C æŒ‡ä»¤ä¸¾ä¾‹ï¼Œè¯´æ˜Žäº† CPU æ˜¯å¦‚ä½•è¯†åˆ«è¿™äº›æŒ‡ä»¤ï¼Œå¦‚ä½•å®žçŽ°è¿™äº›æŒ‡ä»¤çš„åŠŸèƒ½ï¼Œè¿™é‡Œå°±ä¸å…·ä½“å±•å¼€äº†ã€‚ Unit 5.4 The Hack Computerè¿™èŠ‚è¯¾ä¸»è¦åœ¨è®² Hack Computer çš„ç»“æž„ï¼šä¸€å— CPUã€ä¸€ä¸ª ROM32K çš„å¤–å­˜ã€ä¸€å—å†…å­˜ï¼Œå†åŠ é”®ç›˜å’Œå±å¹•ä¸¤ä¸ª I/O è®¾å¤‡ã€‚æŽ¥ç€è€å¸ˆåˆåˆ†å¼€è®²è§£äº†æ¯éƒ¨åˆ†ç¡¬ä»¶çš„æž„æˆåŽŸç†ï¼Œä¸è¿‡è®²çš„ä¸æ˜¯å¾ˆæ·±å…¥ï¼Œä¸Žå‰é¢æåˆ°çš„å·®ä¸å¤šï¼Œæ¯•ç«Ÿè¿™ä¸€å‘¨çš„ä»»åŠ¡å°±æ˜¯åšè¿™äº›ä¸œè¥¿ã€‚ Unit 5.5 Project Overviewè¿™å‘¨ä¸»è¦å®žçŽ° 3 ä¸ªç¡¬ä»¶è®¾å¤‡ï¼Œè€Œè¿™äº›è®¾å¤‡å°±æ˜¯ä¸Šä¸€å‘¨ç”¨åˆ°çš„è®¾å¤‡ã€‚ Memoryç¬¬ä¸€ä¸ªå®žçŽ°çš„è®¾å¤‡æ˜¯ Memoryï¼Œå®žçŽ°è¿‡ç¨‹çœŸæ˜¯ä¸€è¨€éš¾å°½ï¼Œæ˜Žæ˜Žæ˜¯ç›¸å¯¹å®¹æ˜“çš„é—®é¢˜ï¼Œå´æƒ³äº†å¾ˆä¹…ï¼Œæœ€åŽæ‰æ„è¯†åˆ°æ˜¯è‡ªå·±æœ‰äº›åŸºç¡€æ¦‚å¿µï¼ˆæˆ–è€…è¯´é»˜è®¤è§„åˆ™ï¼‰æ²¡ç†è§£æ¸…æ¥šï¼Œå¯¼è‡´åšä¸å‡ºæ¥ï¼ŒæŸ¥èµ„æ–™çº æ­£è¿‡æ¥åŽï¼Œå°±è¿Žåˆƒè€Œè§£äº†ã€‚ä½†è¯è¯´å›žæ¥ï¼Œèƒ½è¿™æ ·ä¸€æ­¥æ­¥åšåˆ°ç¬¬äº”å‘¨ä¹Ÿæ˜¯æ²¡è°äº†ðŸ˜…...ä¸å¤šè¯´äº†ï¼Œè¿›å…¥æ­£é¢˜ã€‚Memory çš„å®žçŽ°ç›¸å¯¹æ¯”è¾ƒç®€å•ï¼Œå‚è€ƒèµ„æ–™å·²ç»ç»™äº†å¾ˆè¯¦ç»†çš„æç¤ºâ€”â€”å‚è€ƒç¬¬ä¸‰å‘¨æž„é€ å†…å­˜èŠ¯ç‰‡çš„æ€è·¯å®Œæˆã€‚æŒ‰ç…§æç¤ºçš„æ€è·¯ï¼Œå®Œæˆ Memory éœ€è¦ä½¿ç”¨ RAM16Kã€Screen å’Œ Keyboard è¿™ä¸‰ä¸ªä¸»è¦èŠ¯ç‰‡ï¼Œç„¶åŽå†åŠ ä¸Šå…¶ä»–è‹¥å¹²èŠ¯ç‰‡ã€‚æ­¤æ—¶ï¼Œå·²çŸ¥çš„å†…å®¹æ˜¯ Memory çš„åœ°å€èŒƒå›´åœ¨$[0, 24576]$ï¼Œå¹¶ä¸”åˆ†åˆ«å¯¹åº”ç€å†…å­˜ã€æ˜¾ç¤ºå™¨å’Œé”®ç›˜çš„åœ°å€èŒƒå›´ï¼Œå³ï¼š1230x0000 - 0x3FFFF -&gt; 0000 .... 0000 - 0111 .... 1111 -&gt; Ram0x4000 - 0x5FFFF -&gt; 0010 .... 0000 - 0101 .... 1111 -&gt; Screen0x6000 -&gt; 1100 .... 0000 -&gt; Keyboard ç»“åˆå®žçŽ° RAM16K çš„æ€è·¯ï¼Œå®žçŽ° Memory ä¹Ÿéœ€è¦ä½¿ç”¨ä¸€ä¸ª DMux4Way å°†è¾“å…¥çš„åœ°å€åŒºåˆ†å¼€ï¼Œç„¶åŽå°†ç‰¹å®šçš„ç®¡è„šè¿žæŽ¥åˆ°ç‰¹å®šçš„èŠ¯ç‰‡ä¸Šå³å¯ï¼Œæœ€åŽå†ç”¨ Mux4Way16 è¾“å‡ºå³å¯ï¼Œæ•´ä½“æ€è·¯è¿˜ç®—æ˜¯æ¯”è¾ƒç®€å•çš„ã€‚å› ä¸ºå·²ç»çŸ¥é“ RAM16K æ˜¯ 14 ä½å¯»å€çš„ï¼ŒScreen æ˜¯ 13 ä½å¯»å€çš„ï¼ŒKeyboard å°±ä¸€ä¸ªåœ°å€ï¼Œè€Œ Memory çš„ address æ˜¯ 15 ä½çš„ï¼Œæ‰€ä»¥å¯ä»¥å¾ˆè‡ªç„¶çš„æƒ³åˆ°ç”¨ address çš„å‰ä¸¤ä½æ¥ä½œä¸º DMux4Way çš„ sel bitsï¼Œè¿™æ ·å°±å¯ä»¥åŒºåˆ†å‡ºåœ°å€äº†ã€‚ä½†æ˜¯ï¼Œåœ¨é€‰æ‹©ç®¡è„šä½œä¸º sel bits å’Œè¿žæŽ¥ç®¡è„šçš„æ—¶å€™ï¼Œæˆ‘æ²¡æœ‰æžæ¸…æ¥šåœ¨ hdl è¯­è¨€ä¸­æ¯”ç‰¹æµåˆ°åº•æ˜¯æ€Žä¹ˆæµåŠ¨çš„ï¼Œå¯¼è‡´æˆ‘æ— è®ºæ€Žä¹ˆæ“ä½œç®¡è„šéƒ½æ˜¯é”™è¯¯çš„...ï¼ˆè™½ç„¶æŒ‰ç…§é”™è¯¯æ€è·¯ç¼–å†™å¥½çš„ hdl èƒ½è·‘å®Œå’Œå†…å­˜ç›¸å…³çš„éƒ¨åˆ†è„šæœ¬ï¼‰å…·ä½“è€Œè¨€ï¼Œä»¥ä¸€æ¡ A æŒ‡ä»¤ä¸ºä¾‹ï¼š1234567891011121314 æŒ‡ä»¤ å¯¹åº”çš„æ¯”ç‰¹æµ æµå…¥æœºå™¨çš„é¡ºåºï¼ˆä¸Žäººæ­£å¥½ç›¸åï¼‰@3001 -&gt; 000101110111001 -&gt; 100111011101000ä¹‹å‰ç†è§£çš„æ¯”ç‰¹æµåœ¨ hdl ä¸­çš„é¡ºåºv[0] v[1] v[2] v[3] ... v[13] v[14] 0 0 0 1 ... 0 1 å®žé™…æ¯”ç‰¹æµåœ¨ hdl ä¸­çš„é¡ºåºv[0] v[1] v[2] v[3] ... v[13] v[14] 1 0 0 1 ... 0 0 æ‰€ä»¥ï¼Œåœ¨ hdl ä¸­ï¼Œé€‰å–å¤´ä¸¤ä½ä½œä¸º sel bitsï¼Œå°±åº”è¯¥é€‰å– v[13] å’Œ v[14] è€Œä¸æ˜¯ v[0] å’Œ v[1]ï¼ŒåŒæ—¶å¯ä»¥å‘çŽ°ï¼Œå®žé™…é¡ºåºä¸­çš„ 0 - 14 ä¹Ÿç¡®å®žä»£è¡¨ç€è¿›å…¥åˆ°è®¡ç®—æœºå†…çš„æ¯”ç‰¹æµé¡ºåºï¼Œä¹Ÿè¯´æ˜Žè¿™æ ·è¡¨ç¤ºæ˜¯ç§‘å­¦çš„ã€‚PSï¼šè¿™é‡Œå…¶å®žå¯ä»¥æ·±å…¥æ‰©å±•ä¸€ä¸‹ MSB å’Œ LSB çš„æ¦‚å¿µã€‚ æœ€åŽï¼Œè´´å‡ºæ­£ç¡®çš„å®žçŽ°ä»£ç ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/Memory.hdl/** * The complete address space of the Hack computer&apos;s memory, * including RAM and memory-mapped I/O. * The chip facilitates read and write operations, as follows: * Read: out(t) = Memory[address(t)](t) * Write: if load(t-1) then Memory[address(t-1)](t) = in(t-1) * In words: the chip always outputs the value stored at the memory * location specified by address. If load==1, the in value is loaded * into the memory location specified by address. This value becomes * available through the out output from the next time step onward. * Address space rules: * Only the upper 16K+8K+1 words of the Memory chip are used. * Access to address&gt;0x6000 is invalid. Access to any address in * the range 0x4000-0x5FFF results in accessing the screen memory * map. Access to address 0x6000 results in accessing the keyboard * memory map. The behavior in these addresses is described in the * Screen and Keyboard chip specifications given in the book. *//* 0x0000 - 0x3FFFF -&gt; 0000 .... 0000 - 0111 .... 1111 -&gt; Ram 0x4000 - 0x5FFFF -&gt; 0010 .... 0000 - 0101 .... 1111 -&gt; Screen 0x6000 -&gt; 1100 .... 0000 -&gt; Keyboard*/CHIP Memory &#123; IN in[16], load, address[15]; OUT out[16]; PARTS: // Put your code here: DMux4Way(in=load, sel=address[13..14], a=load0, b=load1, c=loadsrc, d=loadkb); Or(a=load0, b=load1, out=loadram); RAM16K(in=in, load=loadram, address=address[0..13], out=uram); Screen(in=in, load=loadsrc, address=address[0..12], out=usrc); Keyboard(out=ukb); Mux4Way16(a=uram, b=uram, c=usrc, d=ukb, sel=address[13..14], out=out);&#125; å¦å¤–ï¼Œè¿˜æœ‰ä¸€ç‚¹ï¼ŒMemory çš„æµ‹è¯•è„šæœ¬åœ¨æ‰§è¡Œåˆ°æµ‹è¯• Keyboard çš„æ—¶å€™ï¼Œéœ€è¦åœ¨è½¯ä»¶ä¸Šåˆ‡æ¢æˆé”®ç›˜è¾“å…¥ï¼Œå…·ä½“çš„æ“ä½œæ–¹æ³•ï¼ˆStackoverflow è®ºå›ä¸Šçš„æ–¹æ³•ï¼‰ï¼š To anyone facing the same problemâ€¦ on the Hardware Simulator user interface, right above where you see the script executing the tests, there are three drop down boxes. The one furthest to the right which is labeled â€œViewâ€ is probably currently set to â€œScript.â€ Click the drop down and select â€œScreen,â€ and you will see an interface that has a keyboard icon. Click it and then hit the corresponding key to complete the test. CPUç¬¬äºŒä¸ªå®žçŽ°çš„æ˜¯ CPUï¼ŒèŠ±äº†æˆ‘åŠä¸ªæœˆçš„æ—¶é—´ï¼Œæ€»ç®—æ˜¯å¤§è‡´ç†è§£äº†è®¾è®¡åŽŸç†ï¼Œè€Œä¸”è¿˜æ˜¯å‚è€ƒåˆ«äººçš„åšæ³•...æƒ³è¦å®Œæ•´çš„è®¾è®¡å‡º CPUï¼Œé¦–å…ˆå¿…é¡»è¦æžæ˜Žç™½è€å¸ˆè¯¾ä¸Šç»™çš„è®¾è®¡å›¾ï¼š è¿™å¼ å›¾æ¸…æ¥šçš„æ ‡å‡ºäº† bits åœ¨ Hack-CPU ä¸­çš„æµåŠ¨ï¼Œå¹¶æŒ‡å‡ºäº†åœ¨ç‰¹å®š control bit ä½ç½®æ—¶æ‰€ä½¿ç”¨çš„èŠ¯ç‰‡ï¼Œæ‰€ä»¥éœ€è¦æˆ‘ä»¬åšçš„äº‹æƒ…å°±æ˜¯æžæ¸…æ¥šè¿™äº› control bit æ˜¯ä»€ä¹ˆå’Œå¹¶åˆç†ä½¿ç”¨å®ƒä»¬å¾—åˆ°æƒ³è¦çš„è¾“å‡ºã€‚ ä»Žå›¾ä¸­å¯ä»¥çœ‹åˆ°ï¼Œæ•´ä¸ª CPU ä¸€å…±æœ‰ 4 ä¸ªè¾“å‡ºï¼Œåˆ†åˆ«æ˜¯ï¼šoutMã€writeMã€addressM å’Œ pcï¼Œè¿˜æœ‰ 3 ä¸ªè¾“å…¥ï¼Œåˆ†åˆ«æ˜¯ï¼šinstructionã€inM å’Œ resetï¼Œè¿™äº›åè¯çš„å«ä¹‰å¯ä»¥ç›´æŽ¥ä»Žhdlæ–‡ä»¶ä¸­å¾—åˆ°ï¼š123456789inM[16], // M value input (M = contents of RAM[A])instruction[16], // Instruction for executionreset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0).outM[16], // M value outputwriteM, // Write to M? addressM[15], // Address in data memory (of M)pc[15]; // address of next instruction æŒ‰ç…§è¯¾ç¨‹ä¸­è€å¸ˆè®²è§£çš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆå®žçŽ°ä¸Ž ALU ç›¸å…³çš„å†…å®¹ï¼š ä¸ºäº†æ–¹ä¾¿è¡¨ç¤ºå’Œä½¿ç”¨ï¼Œæå‰ä¸€æ¬¡æ€§å°† C æŒ‡ä»¤çš„å„ä¸ª bit å…¨éƒ¨æå–å‡ºæ¥ï¼š12345678910111213141516// C-insAnd(a=instruction[15], b=instruction[12], out=ca); // aAnd(a=instruction[15], b=instruction[11], out=c1); // c1And(a=instruction[15], b=instruction[10], out=c2); // c2And(a=instruction[15], b=instruction[9], out=c3); // c3And(a=instruction[15], b=instruction[8], out=c4); // c4And(a=instruction[15], b=instruction[7], out=c5); // c5And(a=instruction[15], b=instruction[6], out=c6); // c6And(a=instruction[15], b=instruction[5], out=d1); // d1And(a=instruction[15], b=instruction[4], out=d2); // d2And(a=instruction[15], b=instruction[3], out=d3); // d3And(a=instruction[15], b=instruction[2], out=j1); // j1And(a=instruction[15], b=instruction[1], out=j2); // j2And(a=instruction[15], b=instruction[0], out=j3); // j3 ARegister and inMè¿™é‡Œæˆ‘ä»¬æŒ‰ç…§ instruction å’Œ inM ä»Žå·¦è‡³å³çš„æ–¹å‘è¿›è¡Œå®žçŽ°ï¼Œé¦–å…ˆå®žçŽ°çš„æ˜¯ä¸Ž ARegister ç›¸å…³çš„å†…å®¹ã€‚æŒ‰ç…§å›¾ç¤ºï¼ŒæŒ‡ä»¤ï¼ˆinstructionï¼‰åˆšè¿›å…¥åˆ° CPU æ—¶ï¼Œå°±ä¼šæœ‰ä¸€ä¸ª control bit ç”¨æ¥åŒºåˆ†æ˜¯ A æŒ‡ä»¤è¿˜æ˜¯ C æŒ‡ä»¤ï¼Œæ­¤æ—¶å›¾ç¤ºæ˜¯ä½¿ç”¨ä¸€ä¸ª Mux16 æ¥å®Œæˆçš„ã€‚è€Œå¯¹äºŽ A/C æŒ‡ä»¤çš„åŒºåˆ†ï¼Œé€šè¿‡ç¬¬å››ç« çš„çŸ¥è¯†å¯çŸ¥æŒ‡ä»¤çš„é¦–ä½ä¸º 0 å³ä¸º A æŒ‡ä»¤ï¼Œä¸º 1 åˆ™ä¸º C æŒ‡ä»¤ï¼Œæ‰€ä»¥ç›´æŽ¥æŒ‰ç…§é¦–ä½ bit è¿›è¡ŒåŒºåˆ†å³å¯ã€‚ ä½†ä»”ç»†çœ‹å›¾å¯ä»¥å‘çŽ°ï¼Œå›¾ä¸Šè¿˜æœ‰ä¸€ä¸ª ALU output ä¹ŸæŒ‡å‘è¿™é‡Œï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿå®žé™…ä¸Šè¿™æ˜¯å› ä¸ºç»è¿‡ ALU è®¡ç®—åŽçš„ C æŒ‡ä»¤ä¹Ÿæœ‰å¯èƒ½ä¼šè®¿é—® ARegisterï¼Œè¿™è¿˜æ˜¯ç¬¬å››ç« çš„çŸ¥è¯†ï¼Œå…·ä½“å‚è€ƒä¸‹é¢çš„è¡¨æ ¼ï¼š æ‰€ä»¥éœ€è¦å…ˆç”¨ Mux16 å°† instruction å’Œ ALUout å¤šè·¯å¤ç”¨ï¼Œè€Œåœ¨åˆ°è¾¾ ARegister åŽï¼Œåˆå‡ºçŽ°äº†ä¸€ä¸ª control bitï¼Œæ­¤æ—¶ä¸ºäº†å°†åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µçš„ bit ä½ç»„åˆèµ·æ¥ï¼Œéœ€è¦ä½¿ç”¨ä¸€ä¸ª Mux æ¥å®žçŽ°ã€‚åŒæ—¶ï¼Œè§‚å¯Ÿåˆ°å›¾ç¤ºä¸Š ARegister çš„ output ä¹ŸæŒ‡å‘äº† addressMï¼Œè¿™ä¹Ÿå°±æ˜¯è¯´ ARegister ä¸Ž Memory æ˜¯å¯¹åº”çš„ï¼Œè€Œæˆ‘ä»¬å·²ç»çŸ¥é“äº† Memory çš„åœ°å€æ˜¯ 15 ä½çš„ï¼Œæ‰€ä»¥ ARegister çš„å‰ 15 ä½å°±æ˜¯ addressMã€‚ç»¼ä¸Šï¼Œä¸Ž ARegister ç›¸å…³çš„å†…å®¹ï¼Œå¯ä»¥è®¾è®¡ä¸ºï¼šARegister123456// instruction[15]: 0 -&gt; A, 1 -&gt; CMux16(a=instruction, b=ALUout, sel=instruction[15], out=uins);// ARegisterMux(a=true, b=instruction[5], sel=instruction[15], out=insA); // ALUout -&gt; A RegisterARegister(in=uins, load=insA, out[0..14]=addressM, out=uAreg); å†æŽ¥ç€æœå³èµ°ï¼ŒARegister çš„ output ä¼šå’Œ inM ä¸€èµ·è¿›å…¥ Mux16ï¼Œä¹Ÿå³ï¼šinM12// inMMux16(a=uAreg, b=inM, sel=ca, out=u1); ä¹‹æ‰€ä»¥è¿™é‡Œä¼šç”¨åˆ° Mux16ï¼Œæ˜¯å› ä¸ºåªæœ‰ C æŒ‡ä»¤çš„ a bit æ‰èƒ½åŒºåˆ†è¿™æ¡ C æŒ‡ä»¤æ˜¯æ“ä½œ M å¯„å­˜å™¨çš„ï¼Œåä¹‹å°±æ˜¯ A æŒ‡ä»¤äº†ã€‚ DRegister and writeMç»§ç»­è§‚å¯Ÿè®¾è®¡å›¾ï¼ŒALU çš„è¾“å…¥ä¸€å…±æœ‰ä¸¤ä¸ªï¼Œå·²ç»è§£å†³äº†ä¸€ä¸ªï¼Œè¿˜æœ‰ä¸€ä¸ª DRegister éœ€è¦è§£å†³ã€‚ç›¸æ¯” ARegister è€Œè¨€ï¼ŒDRegister å°±ç®€å•å¤šäº†ï¼Œåªæœ‰ä¸€ä¸ªè¾“å…¥å°±æ˜¯ ALU outputï¼ŒåŒæ ·æŒ‰ç…§ç¬¬å››ç« çš„çŸ¥è¯†ï¼š æ‰€ä»¥æˆ‘ä»¬åªéœ€è¦è®¨è®ºå¯¹åº”æŒ‡ä»¤çš„ d2 ä½å³å¯ï¼šDRegister12// DRegisterDRegister(in=ALUout, load=d2, out=uDreg); åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å‘çŽ°åªæœ‰å½“ d3 ä¸º 1 æ—¶ï¼Œæ‰ä¼šå†™å…¥ M å¯„å­˜å™¨ï¼Œä¹Ÿå°±æ˜¯ writeM æ‰ä¼šæ˜¯ 1ï¼šwriteM12// writeMAnd(a=instruction[15], b=d3, out=writeM); è¿™é‡Œå¯èƒ½ä¼šæœ‰äººç–‘é—®ä¸ºä»€ä¹ˆæ˜¯ C æŒ‡ä»¤çš„ d2 å’Œ d3 ä½ï¼Œå®žé™…ä¸Šä¹¦çš„ç¬¬å››ç« å·²ç»è§£é‡Šäº†ï¼š ALUè§£å†³äº† ALU çš„è¾“å…¥é—®é¢˜ï¼ŒçŽ°åœ¨å†è€ƒè™‘å¦‚ä½•ä½¿ç”¨ ALU æ¥å®Œæˆè®¡ç®—ã€‚ALU çš„æŽ¥å£ç›´æŽ¥å‚è€ƒä¹¦ä¸Šçš„å›¾ç¤ºï¼š é™¤äº†ä¸¤ä¸ªè¾“å…¥ï¼Œè¿˜æœ‰ 6 ä¸ªæŽ§åˆ¶ä½éœ€è¦è§£å†³ï¼Œè€Œè¿™ 6 ä¸ªæŽ§åˆ¶ä½æ­£å¥½å¯¹åº”çš„å°±æ˜¯ C æŒ‡ä»¤çš„ comp bitsï¼š åŒæ—¶ï¼Œä»Žä¸Šé¢çš„æŒ‡ä»¤å›¾ä¸­ä¹Ÿå¯ä»¥çœ‹å‡º ALU çš„ x ä¸€å®šæ˜¯ DRegister çš„è¾“å‡ºï¼Œy ä¸€å®šæ˜¯ ARegister çš„è¾“å‡ºå’Œ inM ä¸­çš„ä¸€ä¸ªï¼Œæ¯”å¦‚ä¸‹é¢è¿™æ¡æŒ‡ä»¤ï¼š æ‰€ä»¥ ALU å¯ä»¥è®¾è®¡ä¸ºï¼šALU12// ALUALU(x=uDreg, y=u1, zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6, out=ALUout, out=outM, zr=zr, ng=ng); C-JUMP by PCæœ€åŽè¦å®žçŽ°çš„åŠŸèƒ½æ˜¯ C æŒ‡ä»¤çš„è·³è½¬åŠŸèƒ½ï¼Œè¿™éƒ¨åˆ†åŠŸèƒ½æ˜¯é€šè¿‡ PC æ¥å®žçŽ°çš„ï¼Œä½†æ˜¯å¦è·³è½¬å–å†³äºŽ C æŒ‡ä»¤çš„ jump fieldï¼š æ ¹æ® ALU è¾“å‡ºçš„ zr å’Œ ng åˆšå¥½å¯ä»¥åˆ¤æ–­ output çš„å¤§å°ï¼šzr and ng1234567// PCNot(in=zr, out=notzr);Not(in=ng, out=notng);And(a=notzr, b=ng, out=negative); // ALUout &lt; 0And(a=zr, b=notng, out=zero); // ALUout = 0And(a=notzr, b=notng, out=positive); // ALUout &gt; 0 æŽ¥ä¸‹æ¥ï¼Œå†æ¥é€ä¸€å®žçŽ°è·³è½¬åŠŸèƒ½ï¼šJUMP12345678910// JUMPAnd(a=j3, b=positive, out=JGT); // JGTAnd(a=j2, b=zero, out=JEQ); // JEQAnd(a=j1, b=negative, out=JLT); // JLTAnd(a=j1, b=j2, out=tmp);And(a=tmp, b=j3, out=JMP); // JMP + JNE + nullOr(a=JGT, b=JEQ, out=jmp1); // JGT + JEQ + JGE, 3 possibilitiesOr(a=jmp1, b=JLT, out=jmp2); // jmp1 + JLT + JLE, 5 possibilitiesOr(a=jmp2, b=JMP, out=jmp3); // jmp2 + JMP + JNE + null, 8 possibilities è€ƒè™‘åˆ° PC è¿˜æœ‰ä¸€ä¸ªè‡ªå¢žçš„åŠŸèƒ½ï¼Œå½“æŒ‡ä»¤ä¸º A æŒ‡ä»¤æ—¶ï¼Œä¸è¿›è¡Œè·³è½¬ï¼ŒPC è‡ªå¢žï¼šincrement12And(a=instruction[15], b=jmp3, out=load); // not C-insNot(in=load, out=inc); // increment æœ€åŽå†™å…¥ PC ä¸­ï¼šPC1PC(in=uAreg, inc=inc, load=load, reset=reset, out[0..14]=pc); CPU_CodesCPU123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/CPU.hdl/** * The Hack CPU (Central Processing unit), consisting of an ALU, * two registers named A and D, and a program counter named PC. * The CPU is designed to fetch and execute instructions written in * the Hack machine language. In particular, functions as follows: * Executes the inputted instruction according to the Hack machine * language specification. The D and A in the language specification * refer to CPU-resident registers, while M refers to the external * memory location addressed by A, i.e. to Memory[A]. The inM input * holds the value of this location. If the current instruction needs * to write a value to M, the value is placed in outM, the address * of the target location is placed in the addressM output, and the * writeM control bit is asserted. (When writeM==0, any value may * appear in outM). The outM and writeM outputs are combinational: * they are affected instantaneously by the execution of the current * instruction. The addressM and pc outputs are clocked: although they * are affected by the execution of the current instruction, they commit * to their new values only in the next time step. If reset==1 then the * CPU jumps to address 0 (i.e. pc is set to 0 in next time step) rather * than to the address resulting from executing the current instruction. */CHIP CPU &#123; IN inM[16], // M value input (M = contents of RAM[A]) instruction[16], // Instruction for execution reset; // Signals whether to re-start the current // program (reset==1) or continue executing // the current program (reset==0). OUT outM[16], // M value output writeM, // Write to M? addressM[15], // Address in data memory (of M) pc[15]; // address of next instruction PARTS: // Put your code here: // C-ins bits And(a=instruction[15], b=instruction[12], out=ca); // a And(a=instruction[15], b=instruction[11], out=c1); // c1 And(a=instruction[15], b=instruction[10], out=c2); // c2 And(a=instruction[15], b=instruction[9], out=c3); // c3 And(a=instruction[15], b=instruction[8], out=c4); // c4 And(a=instruction[15], b=instruction[7], out=c5); // c5 And(a=instruction[15], b=instruction[6], out=c6); // c6 And(a=instruction[15], b=instruction[5], out=d1); // d1 And(a=instruction[15], b=instruction[4], out=d2); // d2 And(a=instruction[15], b=instruction[3], out=d3); // d3 And(a=instruction[15], b=instruction[2], out=j1); // j1 And(a=instruction[15], b=instruction[1], out=j2); // j2 And(a=instruction[15], b=instruction[0], out=j3); // j3 // instruction[15]: 0 -&gt; A, 1 -&gt; C Mux16(a=instruction, b=ALUout, sel=instruction[15], out=uins); // A-ins Mux(a=true, b=instruction[5], sel=instruction[15], out=insA); // ALUout -&gt; A Register ARegister(in=uins, load=insA, out[0..14]=addressM, out=uAreg); // inM Mux16(a=uAreg, b=inM, sel=ca, out=u1); // DRegister DRegister(in=ALUout, load=d2, out=uDreg); // writeM And(a=instruction[15], b=d3, out=writeM); // ALU ALU(x=uDreg, y=u1, zx=c1, nx=c2, zy=c3, ny=c4, f=c5, no=c6, out=ALUout, out=outM, zr=zr, ng=ng); // PC Not(in=zr, out=notzr); Not(in=ng, out=notng); And(a=notzr, b=ng, out=negative); // ALUout &lt; 0 And(a=zr, b=notng, out=zero); // ALUout = 0 And(a=notzr, b=notng, out=positive); // ALUout &gt; 0 // JUMP And(a=j3, b=positive, out=JGT); // JGT And(a=j2, b=zero, out=JEQ); // JEQ And(a=j1, b=negative, out=JLT); // JLT And(a=j1, b=j2, out=tmp); And(a=tmp, b=j3, out=JMP); // JMP + JNE + null Or(a=JGT, b=JEQ, out=jmp1); // JGT + JEQ + JGE, 3 possibilities Or(a=jmp1, b=JLT, out=jmp2); // jmp1 + JLT + JLE, 5 possibilities Or(a=jmp2, b=JMP, out=jmp3); // jmp2 + JMP + JNE + null, 8 possibilities And(a=instruction[15], b=jmp3, out=load); // not C-ins Not(in=load, out=inc); PC(in=uAreg, inc=inc, load=load, reset=reset, out[0..14]=pc);&#125; ComputerComputer çš„è®¾è®¡æ€è·¯è¿˜æ˜¯å‚è€ƒè€å¸ˆä¸Šè¯¾ç»™å‡ºçš„æ€è·¯ï¼š æœ‰äº†å‰é¢çš„è®¾è®¡åŸºç¡€ï¼ˆè¢«åå¤æ‹·æ‰“ðŸ¤£ï¼‰ï¼ŒçŽ°åœ¨åªéœ€è¦æŒ‰ç…§ä¸Šå›¾ä¸­çš„æ€è·¯å°†å„ä¸ªç¡¬ä»¶è¿žæŽ¥èµ·æ¥å³å¯ï¼Œæœ€åŽå¾—åˆ°çš„ä»£ç å¦‚ä¸‹ï¼šComputer123456789101112131415161718192021222324252627// This file is part of www.nand2tetris.org// and the book &quot;The Elements of Computing Systems&quot;// by Nisan and Schocken, MIT Press.// File name: projects/05/Computer.hdl/** * The HACK computer, including CPU, ROM and RAM. * When reset is 0, the program stored in the computer&apos;s ROM executes. * When reset is 1, the execution of the program restarts. * Thus, to start a program&apos;s execution, reset must be pushed &quot;up&quot; (1) * and &quot;down&quot; (0). From this point onward the user is at the mercy of * the software. In particular, depending on the program&apos;s code, the * screen may show some output and the user may be able to interact * with the computer via the keyboard. */CHIP Computer &#123; IN reset; PARTS: // Put your code here: ROM32K(address=Upc, out=ROMins); CPU(inM=MinM, instruction=ROMins, reset=reset, outM=UoutM, writeM=UwriteM, addressM=UaddrM, pc=Upc); Memory(in=UoutM, load=UwriteM, address=UaddrM, out=MinM);&#125; Unit 5.6 Perspectiveè¿™å‘¨ä¸€å…±åªæœ‰ä¸¤ä¸ªé—®é¢˜ï¼š å†¯è¯ºä¾æ›¼ç»“æž„å’Œå“ˆä½›ç»“æž„æœ‰ä»€ä¹ˆå·®å¼‚ï¼Ÿ å“ˆä½›ç»“æž„æ˜¯å†¯è¯ºä¾æ›¼ç»“æž„çš„ä¸€ä¸ªå˜ç§ï¼ŒäºŒè€…çš„å·®å¼‚åœ¨äºŽå“ˆä½›ç»“æž„çš„æ•°æ®å†…å­˜å’ŒæŒ‡ä»¤å†…å­˜æ˜¯åˆ†å¼€çš„ï¼Œè€Œå†¯è¯ºä¾æ›¼ç»“æž„çš„æ•°æ®å’ŒæŒ‡ä»¤æ˜¯å­˜æ”¾åœ¨ä¸€èµ·çš„ï¼Œè¿™ä¹Ÿå°±å¯¼è‡´å“ˆä½›ç»“æž„è¿›è¡Œå–å€æ‰§è¡Œåªéœ€è¦ä¸€ä¸ªæ—¶é—´å‘¨æœŸï¼Œè€Œå†¯è¯ºä¾æ›¼ç»“æž„éœ€è¦ä¸¤ä¸ªç‹¬ç«‹çš„æ—¶é—´å‘¨æœŸã€‚å¦å¤–ï¼Œè¿˜æåˆ°äº†å¦‚ä½•æž„å»ºç»“åˆä¸¤ç§ç»“æž„ç‰¹ç‚¹çš„è®¡ç®—æœºï¼Œç­”æ¡ˆå°±æ˜¯é€šè¿‡æœ‰é™çŠ¶æ€æœºçš„å½¢å¼æ¥æž„å»ºï¼Œè¿™é‡Œä¸æ·±ç©¶ã€‚ è®¡ç®—æœºè¿žæŽ¥å…¶ä»–çš„å¤–è®¾ï¼Œæ˜¯å¦‚ä½•å·¥ä½œçš„ï¼Ÿ é™¤äº†é”®ç›˜å’Œå±å¹•ï¼Œè®¡ç®—æœºæœ‰å¾ˆå¤šå…¶ä»–çš„å¤–è®¾ï¼ˆè¿™é‡Œçš„å¤–è®¾åŒ…æ‹¬æ˜¾å¡ã€ç½‘å¡ç­‰ç¡¬ä»¶è®¾å¤‡ï¼‰ï¼Œè€Œè®¡ç®—æœºè¿žæŽ¥è¿™äº›å¤–è®¾çš„æ–¹å¼ä¸Žè¿žæŽ¥é”®ç›˜å’Œå±å¹•æ˜¯ç±»ä¼¼çš„ï¼ˆæ³¨æ„è¿™é‡Œçš„ç±»ä¼¼æŒ‡çš„æ˜¯çŽ°ä»£è®¡ç®—æœºè€Œä¸æ˜¯ Hackï¼‰ã€‚æ¢å¥è¯è¯´ï¼ŒçŽ°ä»£è®¡ç®—æœºè¿žæŽ¥å¤–è®¾éƒ½æ˜¯é€šè¿‡è®¾å¤‡æŽ§åˆ¶å™¨ï¼ˆdevice controllersï¼‰æ¥å®Œæˆçš„ï¼Œè¿™ç‚¹å…¶å®žä¹Ÿå¯ä»¥ä»Ž Windows ç³»ç»Ÿä¸­çš„è®¾å¤‡ç®¡ç†å™¨é¡µé¢çœ‹å‡ºï¼Œè€Œä¹‹æ‰€ä»¥è¦è¿™æ ·åšæ˜¯ä¸ºäº†é™ä½Ž CPU çš„å·¥ä½œåŽ‹åŠ›ã€‚ Unit 5.7 Summaryè¿™ä¸€ç« çœŸçš„è®©æˆ‘æ„Ÿæ…¨è‰¯å¤š...ï¼ˆå…¶å®žæ˜¯è¢«è™çš„ä½“æ— å®Œè‚¤ðŸ¤£ï¼Œä¸è¿‡è¿˜æ˜¯å®Œæˆäº†ðŸ˜¤ï¼‰ æœ¬ç« ç®—æ˜¯å¯¹å‰äº”ç« å†…å®¹çš„æ±‡æ€»ï¼ŒåŸºæœ¬æŠŠå‰äº”ç« æ‰€å­¦çš„çŸ¥è¯†ç‚¹éƒ½æ¦‚æ‹¬è¿›æ¥äº†ã€‚ä¸€å¼€å§‹ç¢ç£¨ CPU å’Œ Memory å¦‚ä½•è®¾è®¡çš„æ—¶å€™ï¼ŒçœŸçš„æ˜¯è„‘è¢‹éƒ½è¦æƒ³ç ´äº†ï¼Œæƒ³äº†å¾ˆä¹…ä¸€ç‚¹å¤´ç»ªéƒ½æ²¡æœ‰ï¼Œå¯¼è‡´è‡ªå·±è¶Šæƒ³è¶Šçƒ¦èºï¼Œè¶Šæƒ³è¶Šæƒ³ä¸å‡ºæ¥ï¼Œå®Œå…¨å†·é™ä¸ä¸‹æ¥ã€‚ç„¶åŽï¼Œå°±ä¸€ç›´æ‹–ç€ï¼Œç»“æžœå°±æ˜¯è¿›åº¦å¾ˆæ…¢ï¼ŒèŠ±äº†åŠä¸ªæœˆï¼Œè¿™ç¯‡ Blog æ‰å®Œæˆ...è¿™æ ·çœŸçš„ä¸å¥½ðŸ˜¥ï¼Œè¿˜æ˜¯è¦æ³¨æ„æ•ˆçŽ‡ã€‚ çŽ°åœ¨å›žæƒ³èµ·æ¥ï¼Œä¸å¤Ÿå†·é™æ˜¯ä¸€ä¸ªé—®é¢˜ï¼Œè¿˜æœ‰ä¸€ä¸ªé—®é¢˜æ˜¯è‡ªå·±å®Œæˆè¿™äº›å†…å®¹çš„æ—¶é—´é—´éš”å¤ªé•¿äº†ï¼Œç¬¬ä¸€ç« çš„åŸºç¡€èŠ¯ç‰‡ã€ç¬¬äºŒç« çš„ ALU å’Œç¬¬ä¸‰å‘¨çš„ RAMï¼Œéƒ½æ˜¯ä¸€ä¸¤å¹´å‰å®Œæˆçš„äº†ï¼ŒçŽ°åœ¨é‡æ–°æ¡èµ·æ¥å­¦ä¹ ï¼ŒåŽŸæ¥çš„æ„Ÿè§‰éƒ½æ²¡äº†...æ‰€ä»¥ï¼Œå­¦ä¹ éœ€è¦è¶çƒ­æ‰“é“ï¼Œç†Ÿç»ƒæ‰èƒ½ç”Ÿå·§ï¼ å¦å¤–ï¼Œè¿˜æƒ³è¯´çš„æ˜¯ï¼Œå‰äº”ç« çš„æ ¸å¿ƒå†…å®¹å°±æ˜¯å¦‚ä½•è®¾è®¡ç¡¬ä»¶ï¼Œè€Œè´¯ç©¿å‰äº”ç« è®¾è®¡ç¡¬ä»¶çš„æŠ€å·§ï¼ˆæˆ–è€…è¯´æ€è·¯ï¼‰ï¼Œå°±æ˜¯å¦‚ä½•ä½¿ç”¨ç‰¹å®šçš„ control bit æ¥åˆ†æƒ…å†µè¾“å…¥è¾“å‡ºæ¯”ç‰¹æµï¼Œè¿™ä¸€ç‚¹åœ¨ Muxã€ALUã€RAMã€PCã€CPU å’Œ Memory ä¸Šéƒ½æœ‰ä½“çŽ°ã€‚ æœ€åŽï¼Œå¸Œæœ›è‡ªå·±å†æŽ¥å†åŽ‰ï¼Œè¶çƒ­æ‰“é“ï¼Œèµ¶ç´§æŠŠç¬¬å…­ç« çš„æ±‡ç¼–å™¨å®Œæˆäº†ï¼Œè¿™å›žä¸èƒ½å·æ‡’äº†ï¼ðŸ˜¤]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ–°å† æ„ŸæŸ“è®°]]></title>
    <url>%2F2022%2F12%2F19%2F%E6%96%B0%E5%86%A0%E6%84%9F%E6%9F%93%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æ–°å† å·²ç»ä¸‰å¹´äº†ï¼Œä»Šå¤©ç»ˆäºŽè½®åˆ°æˆ‘äº†...å†™è¿™ç¯‡æ–‡ç« å¹¶ä¸æ˜¯æƒ³è¯´ä¸€äº›è·Ÿæ–°å† ç›¸å…³çš„çœ‹æ³•ï¼Œåªæ˜¯æƒ³è®°å½•ä¸€ä¸‹è‡ªå·±çš„æ–°å† è¿‡ç¨‹ã€‚ 12 æœˆ 15 æ—¥ æ™šåŒä½çš„æœ‹å‹å° z å‘Šè¯‰æˆ‘ï¼Œä»–å¥½åƒå‡ºçŽ°äº†æ–°å† çš„ç—‡çŠ¶ï¼Œä½†æ˜¯æˆ‘æŽ¥å—äº†ï¼Œæ™šä¸Šä¾ç„¶ä½åœ¨ä¸€èµ·ã€‚ 12 æœˆ 16 æ—¥ æ—©å› ä¸ºæ˜¯å‘¨äº”è¿˜å¾—ä¸Šç­ï¼Œæ‰€ä»¥é†’çš„å¾ˆæ—©ï¼Œå…ˆåšäº†ä¸ªæ ¸é…¸ã€‚ç„¶åŽï¼Œè‹¥æ— å…¶äº‹çš„åœ¨é¦’å¤´åº—ï¼Œåƒäº†æ—©ç‚¹ã€‚ 12 æœˆ 17 æ—¥å‘¨å…­æ”¾å‡äº†ï¼Œæ—©ä¸Šèµ·åºŠåŽï¼Œå–‰å’™å¼€å§‹å‡ºçŽ°å¹²æ¶©çš„ç—‡çŠ¶ï¼Œä½†ä¸æ˜¯å¾ˆä¸¥é‡ï¼Œå¯ä»¥æ„Ÿè§‰å¾ˆæ˜Žæ˜¾ï¼Œä¹Ÿæ²¡æœ‰å¤ªå½“å›žäº‹ï¼Œå¿ƒé‡Œåªæƒ³ç€ç—Šæ„ˆåŽåˆ«å½±å“æˆ‘å”±æ­Œå°±å¥½ã€‚ èµ·åºŠåŽ»èœå¸‚åœºä¹°äº†åªé¸¡ï¼Œå†åŠ ä¸€ç‚¹å±±è¯ã€æž¸æžã€çº¢æž£ï¼Œç‚–äº†é”…æ±¤ï¼Œè·Ÿå° z ä¸€èµ·è£¹äº†è…¹ã€‚ä¸‹åˆï¼Œå° z åŽ»åŒ»é™¢æ£€æŸ¥è‚ºéƒ¨å’Œå¼€æ–°å† çš„è¯æ˜Žï¼ˆä¸ºäº†ä¿é™©ï¼‰ï¼Œæˆ‘é¡ºè·¯åšäº†ä¸ªå•ç®¡ã€‚å…¶å®žåšä¸åšéƒ½æ— æ‰€è°“ï¼Œè‡ªå·±ç»å¯¹æ˜¯é˜³äº†ï¼Œä¹‹å‰åœ¨æ ¡åŒºåšçš„æ··ç®¡ç»“æžœæ˜¯å¾…å¤æ ¸ã€‚ 12 æœˆ 18 æ—¥17 æ—¥æ™šä¸Šç¡è§‰çš„æ—¶å€™ï¼Œè¿˜æ²¡æœ‰ä»€ä¹ˆæ„Ÿè§‰ï¼Œç­‰åˆ°æ—©ä¸Š 4ã€5 ç‚¹çš„æ—¶å€™ï¼Œå¼€å§‹æµ‘èº«é…¸ç—›ï¼Œå››è‚¢æ— åŠ›ï¼Œå¹¶ä¼´æœ‰å‘çƒ§ã€‚å› ä¸ºåœ¨åºŠä¸Šï¼Œå‘çƒ§è„‘è¢‹ä¹Ÿæœ‰ç‚¹æ™•ä¹Žä¹Žçš„ï¼ŒåŽè„‘å‹ºæœ‰ç‚¹ç—›ï¼ˆè·Ÿåå¤´ç—›ç›¸æ¯”å·®è¿œäº†ï¼Œä¸»è¦æ˜¯æ™•ï¼‰ï¼Œæ„Ÿè§‰è‡ªå·±é¢å¤´çƒ«çƒ«çš„ï¼Œé™æ¸©æ–¹å¼æ˜¯éš”ä¸€æ®µæ—¶é—´ç”¨è¢«å­æ‰‡é£ŽðŸ˜‚ï¼Œå¹¶å°†èƒ³è†Šéœ²åœ¨è¢«å­å¤–é¢ã€‚åŽæ¥æ„Ÿè§‰é¢å¤´è¿˜æ˜¯å¾ˆçƒ«ï¼Œå°±æŠŠæ‰‹æœºé åœ¨è‡ªå·±çš„é¢å¤´ï¼Œæ°å·§å› ä¸ºå†¬å¤©çš„å…³ç³»ï¼Œæ”¾ç½®åœ¨å¤–çš„æ‰‹æœºæ¸©åº¦å¾ˆä½Žï¼Œæ”¾åˆ°é¢å¤´çš„ä¸€çž¬é—´çœŸçš„æ˜¯å¾ˆèˆ’æœ... æ•´å¤©åŸºæœ¬å¤„äºŽå‘çƒ§çŠ¶æ€ï¼Œå‡Œæ™¨å¤§æ¦‚æ˜¯å‘çƒ§æ¸©åº¦æœ€é«˜çš„æ—¶å€™ï¼Œåƒäº†ä¸€ç²’è¿‡æœŸçš„å¸ƒæ´›èŠ¬ï¼Œåˆèººåœ¨åºŠä¸Šçœ¯äº†ä¼šï¼Œæ„Ÿè§‰å¥½åƒå¥½å—äº†ä¸€äº›ã€‚ åŽæ¥èµ·åºŠæºœè¾¾äº†ä¸€ä¼šï¼Œä¸­åˆä»€ä¹ˆéƒ½ä¸æƒ³åƒï¼Œè€Œä¸”æ—¶ä¸æ—¶æœ‰åèƒƒçš„æ„Ÿè§‰ï¼Œåªåƒäº†ä¸€ç¢—å°ç±³ç²¥ï¼Œè¡¥å……äº†ä¸€ç‚¹ç¢³æ°´åŒ–åˆç‰©ã€‚ç„¶åŽåƒäº†é¢—å¸ƒæ´›èŠ¬ï¼ˆè¿˜æ˜¯è¿‡æœŸçš„ðŸ˜‚ï¼‰ï¼ŒåˆåŽ»åºŠä¸Šç¡è§‰äº†ã€‚åˆšä¸ŠåºŠï¼Œæ„Ÿè§‰å¥‡å†·æ— æ¯”ï¼Œå…¨èº«ä¸å†å‘çƒ§ï¼Œè€Œæ˜¯å‘å†·ã€‚è¿«ä¸å¾—å·²ï¼Œè®©å° z æžäº†ä¸ªçƒ­æ°´è¢‹ï¼Œæ‰æ…¢æ…¢ç¡ç€ï¼Œç¡é†’åŽï¼Œç”¨è„šä¸€æ‘¸çƒ­æ°´è¢‹ï¼Œç«Ÿç„¶è§‰å¾—å¾ˆçƒ«ï¼Œå°±çŸ¥é“è‡ªå·±åˆå¼€å§‹å‘çƒ§äº†ã€‚ æ™šä¸Šçš„çŠ¶æ€è¿˜å¯ä»¥ï¼Œå‘çƒ§æ¸©åº¦åº”è¯¥ä¸‹é™åˆ°äº† 37.xï¼Œèƒ½åšä¸€ç‚¹è„‘åŠ›æ´»åŠ¨äº†ã€‚ç„¶åŽï¼Œå°±çœ‹äº†çœ‹è§†é¢‘ã€‚ 12 æœˆ 19 æ—¥ä»Šå¤©æ˜¯å‘¨ä¸€ï¼Œå·¥ä½œæ—¥ï¼Œæ—©ä¸Šèµ·æ¥æ²¡æ„Ÿè§‰åˆ°å‘çƒ§ï¼Œå¯èƒ½æ˜¯å·²ç»å˜æˆä½Žçƒ§äº†å§ï¼Œåæ­£æ„Ÿè§‰æ¯”æ˜¨å¤©å¥½å¤šäº†ã€‚ ä¸è¿‡è¿˜æ˜¯è§‰å¾—å¾ˆå†·ï¼Œå¹¶ä¸”æ‰‹è„šå¶å°”è¿˜æ˜¯å‘å†·ï¼Œä¸­åˆå‡ºåŽ»èµ°äº†ä¸€åœˆï¼Œæ™’äº†ä¼šå¤ªé˜³ï¼Œè¿˜æ˜¯è§‰å¾—å†·ï¼Œè¯´æ˜Žè‡ªå·±çš„å‘çƒ§çŠ¶æ€è¿˜æ²¡ç—Šæ„ˆã€‚ ä½†æ˜¯ä¸ç®¡æ€Žä¹ˆæ ·ï¼Œå¾—ä¸Šç­å•Š~ðŸ˜‚è¿™ä¸¤å¤©ï¼Œè¿˜æ˜¯æŒºå¿™çš„...å¸Œæœ›æ˜Žå¤©è‡ªå·±å’Œæœ‹å‹å° z èƒ½æ¢å¤çš„æ›´å¥½~ðŸ’ª 12 æœˆ 20 æ—¥åˆè¿‡äº†ä¸€å¤©ï¼Œèº«ä½“çš„é…¸ç—›æ„Ÿå·²ç»å¿«è¦æ¶ˆå¤±äº†ï¼Œå¯æƒœè¿˜æ˜¯æœ‰é¼»å¡žã€æµæ¶•ã€å’³å—½çš„ç—‡çŠ¶ã€‚å¯¹äº†ï¼Œè¿˜å¿˜è®°äº†å‘çƒ§ï¼Œå‘µå‘µï¼Œå‘çƒ§çš„ç—‡çŠ¶ä¹ŸåŸºæœ¬æ¶ˆå¤±äº†ï¼Œå°±æ˜¯å¤©å¤©å±…å®¶åŠžå…¬ï¼Œååœ¨å®¶é‡Œè§‰å¾—å¥½å†·å“¦ã€‚ç›®å‰èº«ä½“å·²ç»æ²¡æœ‰å…¶ä»–ä¸é€‚çš„ç—‡çŠ¶äº†ï¼Œè‡ªæˆ‘æ„Ÿè§‰èº«ä½“çŠ¶å†µä¹Ÿåœ¨é€æ¸çš„æ¢å¤ï¼Œè¿™å¯çœŸæ˜¯è®©äººé«˜å…´çš„äº‹æƒ…ðŸ˜ã€‚å‚æ™šï¼ŒåŽ»åšäº†ä¸ªæ ¸é…¸ï¼Œåº”è¯¥å¤§æ¦‚çŽ‡è¿˜æ˜¯é˜³æ€§ï¼Œä¸è¿‡è¿˜æ˜¯æ£€æµ‹ä¸€ä¸‹ï¼Œçœ‹ä¸‹è‡ªå·±èº«ä½“çš„çŠ¶å†µå§ã€‚ä¸è¿‡ï¼Œåšæ ¸é…¸çš„è¿‡ç¨‹ä¸­ï¼Œæ ¸é…¸æ£€æŸ¥äººå‘˜å‘Šè¯‰æˆ‘é˜³æ€§æ¬¡æ•°è¶Šå¤šï¼Œç å˜ç»¿çš„æ—¶é—´å°±è¶Šé•¿ï¼Œè®©æˆ‘è‡ªå·±è€ƒè™‘æ¸…æ¥šã€‚æ²¡æƒ³å¤ªå¤šï¼Œä¹Ÿæ²¡é—®å¤ªå¤šè¿˜æ˜¯åšäº†ï¼Œæˆ‘å¯»æ€ï¼Œæˆ‘çš„ç ä»Žæœªå˜çº¢ï¼Œæˆ‘éšä¾¿ä¸€æ¬¡æ ¸é…¸é˜´æ€§ä¸å°±å®Œäº‹äº†å—ï¼Ÿï¼Ÿï¼Ÿå¯é—®é¢˜æ˜¯ï¼Œæˆ‘æ˜¯ä¸ä¼šé‚£ä¹ˆå¹²çš„ðŸ˜‚ï¼Œé‚£æ ·æ—¢å¯¹è‡ªå·±ä¸è´Ÿè´£ï¼Œä¹Ÿå¯¹åˆ«äººä¸è´Ÿè´£ã€‚ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œè‡ªå·±çš„ç—…æƒ…æ˜¯åœ¨é€æ¸å¥½è½¬çš„ï¼Œè¿™ç‚¹æ˜¯æ¯‹åº¸ç½®ç–‘çš„ï¼Œå‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯å¥½å¥½å±…å®¶åŠžå…¬äº†ï¼ŒåŠ æ²¹å§~ 12 æœˆ 21 æ—¥å’³å—½çš„ç—‡çŠ¶è¿›ä¸€æ­¥ç¼“è§£ï¼Œä½†æ˜¯è¿˜æ˜¯æœ‰ç—°ï¼Œå‘çƒ§çš„ç—‡çŠ¶å·²ç»å¯ä»¥ç¡®å®šæ¶ˆå¤±äº†~ä»Šå¤©ä¹…è¿çš„æ´—äº†ä¸ªæ¾¡ï¼Œé—´éš”äº†å¤§çº¦ 4ã€5 å¤©ï¼Ÿå¤´å‘éƒ½æ²¹çš„ä¸æˆæ ·å­äº†ï¼Œè¦ä¸æ˜¯å› ä¸ºå‘çƒ§ï¼Œç»ä¸ä¼šæ‹–è¿™ä¹ˆä¹…...å¦å¤–ï¼Œè™½ç„¶æ´—çš„æ—¶å€™å¾ˆå†·ï¼Œä½†æ˜¯æ´—å®Œäº†æ˜¯çœŸçš„èˆ’æœ~ðŸ˜Žå¯æƒœï¼Œè®©äººçƒ¦å¿ƒçš„äº‹æƒ…æ˜¯å·¥ä½œä»ç„¶æ²¡æœ‰å®Œæˆï¼Œä½†è¯åˆè¯´å›žæ¥ï¼Œå·¥ä½œåˆæ€Žä¹ˆèƒ½çœŸæ­£çš„å®Œæˆå‘¢ï¼Œæ‰€ä»¥ï¼Œæ˜Žå¤©å†è¯´å’¯~ðŸ¤£ 12 æœˆ 23 æ—¥è½¬çœ¼å·²è¿‡ä¸€å‘¨äº†ï¼Œæ„ŸæŸ“æ–°å† çš„ç—‡çŠ¶æ¯å¤©éƒ½åœ¨é€æ­¥ç¼“è§£ï¼Œä½†è‡ªå·±çš„ä½“åŠ›è¿˜æ˜¯æœ‰æ‰€ä¸‹é™ï¼ŒçŽ°åœ¨æ²¡èµ°ä¸¤æ­¥è·¯ï¼Œå°±å¼€å§‹æ°”å–˜ååçš„ï¼Œæ„Ÿè§‰ç´¯å¾—ä¸è¡Œ...ä½†æ˜¯ä¹Ÿä¸èƒ½æ€¥ç€å°±å¼€å§‹åšå‰§çƒˆè¿åŠ¨ï¼Œéœ€è¦æ…¢æ…¢æ¢å¤ï¼Œä¸€æ­¥ä¸€æ­¥æ¥ï¼Œä»¥å…äº§ç”Ÿä¸å¥½çš„äº‹æƒ…ã€‚åŒä½çš„å° zï¼Œä»Šå¤©æ—©ä¸Šå‘Šè¯‰æˆ‘ï¼Œä»–çš„æ ¸é…¸å·²ç»è½¬é˜´äº†ï¼Œæ­å–œä»–å·²ç»ç—Šæ„ˆäº†ã€‚è€Œæˆ‘è¿™å‡ å¤©æ²¡æœ‰åšæ ¸é…¸ï¼Œæš‚æ—¶ä¸çŸ¥é“è‡ªå·±çš„æƒ…å†µã€‚æœ€è¿‘çš„ä¸€æ¬¡æ ¸é…¸æ˜¯åœ¨ 3 å¤©å‰ï¼Œç»“æžœæ˜¯é˜³æ€§ã€‚æŒ‰ç…§æ—¥æœŸæ¥è®¡ç®—ï¼Œæˆ‘ä¹Ÿå¿«è¦è½¬é˜´äº†ã€‚ä¸è¿‡ï¼Œä¸‹å‘¨è¦å±…å®¶åŠžå…¬äº†ï¼Œåšä¸åšæ ¸é…¸å¥½åƒåªä¸Žè‡ªå·±æœ‰å…³äº†ã€‚ä½œä¸ºç›‘æµ‹è‡ªå·±èº«ä½“å¥åº·çš„æ‰‹æ®µï¼Œä¸‹å‘¨å†åšæ ¸é…¸ä¹Ÿä¸è¿Ÿã€‚ 12 æœˆ 27 æ—¥æ˜¨å¤©æ—©ä¸Šåšäº†ä¸€æ¬¡æ ¸é…¸ï¼Œç»“æžœæ˜¯æ™šä¸Šå‡ºæ¥çš„ï¼Œå·²ç»è½¬é˜´äº†ã€‚ç®—èµ·æ¥ï¼Œå‰å‰åŽåŽæœ‰åæ¥å¤©äº†ã€‚ä¸å®¹æ˜“å•Šï¼Œè‡ªå·±å¥½åƒåˆç»åŽ†äº†å–ç»è·¯ä¸Šçš„ä¸€â€œéš¾â€ã€‚è®°å¾—å‘çƒ§çš„é‚£ä¸¤å¤©ï¼Œè‡ªå·±å¿ƒé‡Œè¿˜åœ¨å˜€å’•ï¼Œéš¾å—çš„æ—¥å­æ€»æ˜¯è¿‡å¾—å¾ˆæ¼«é•¿ã€‚æ²¡æƒ³åˆ°ï¼Œè½¬çœ¼ä¹‹é—´ï¼Œè‡ªå·±å°±å¿«ç—Šæ„ˆäº†ã€‚è™½ç„¶æ ¸é…¸æ˜¯è½¬é˜´äº†ï¼Œä½†æ˜¯è‡ªå·±çš„å‘¼å¸é“å¹¶æ²¡æœ‰å®Œå…¨æ¢å¤ï¼Œä¾ç„¶è¿˜æ˜¯å’³å—½ä¸æ–­ã€‚æœ‰æ—¶å€™ï¼Œæ„Ÿè§‰æ¨ä¸å¾—æŠŠè‚ºå’³å‡ºæ¥äº†ðŸ˜‚ï¼Œå°½ç®¡è¿™ä¸ªæè¿°å¾ˆå¤¸å¼ ï¼Œä½†æˆ‘æ˜¯çœŸçš„æƒ³è¡¨è¾¾å‡ºæˆ‘çš„å’³å—½æƒ…å†µ...è¿˜æœ‰ä¸€ç‚¹åˆ‡èº«æ„Ÿå—ï¼Œé‚£å°±æ˜¯è‡ªå·±çš„ä½“åŠ›ä¸‹é™äº†å¾ˆå¤šï¼Œæ„Ÿè§‰çˆ¬å‡ å±‚æ¥¼éƒ½å–˜çš„ä¸è¡Œï¼Œåƒæ˜¯è‡ªå·±æå‰æ­¥å…¥è€å¹´ç”Ÿæ´»äº†ðŸ˜‚ã€‚ä¸ç®¡æ€Žä¹ˆæ ·ï¼Œè‡ªå·±çš„å¿ƒæ€è¿˜æ˜¯å¾—æ‘†æ­£ã€‚å‘µå‘µï¼Œå¥½æ­»ä¸å¦‚èµ–æ´»ç€ï¼ŒçŽ°åœ¨çœ‹è¿™å¥è¯ï¼Œå…¶å®žä¹Ÿéšè—äº†å¾ˆå¤šåŠ³åŠ¨äººæ°‘çš„æ™ºæ…§å‘¢ã€‚å¦å¤–ï¼Œè¿™å‡ å¤©çœ‹äº†ä¸€äº›ç½‘ä¸Šçš„ä¿¡æ¯ï¼Œè¯´æ˜¯é˜³åº·äººå‘˜è¿‘å‡ å‘¨éƒ½éœ€è¦å¥½å¥½ä¼‘æ¯ã€‚ä¸ªäººæ„Ÿè§‰ï¼Œä¹Ÿç¡®å®žéœ€è¦å¥½å¥½ä¼‘æ¯ï¼Œè®©è‡ªå·±çš„èº«ä½“å¥½å¥½æ¢å¤ä¸‹ã€‚æœ€åŽï¼Œå¸Œæœ›å…³å¿ƒæˆ‘çš„äººå’Œæˆ‘å…³å¿ƒçš„äººéƒ½èƒ½æ—©æ—©æ¢å¤~ 1 æœˆ 2 æ—¥ä»Šå¤©æ˜¯ 2023 å¹´çš„ç¬¬äºŒå¤©ï¼Œ12 æœˆ 27 æ—¥æ ¸é…¸ç»“æžœè½¬é˜´åŽï¼Œ12 æœˆå‰©ä¸‹å‡ å¤©ä¾ç„¶è¿˜æ˜¯å¤©å¤©åšæ ¸é…¸ï¼Œä¹Ÿéƒ½æ˜¯é˜´æ€§ã€‚æ˜Žå¤©å°±è¦å›žåŽ»ä¸Šç­äº†ï¼Œæ™šä¸Šåšäº†ä¸€ä¸ªæŠ—åŽŸï¼Œä¹Ÿæ˜¯é˜´æ€§çš„ã€‚ç›®å‰ï¼Œå¯¹è‡ªå·±è€Œè¨€ï¼Œæ–°å† åº”è¯¥ç®—æ˜¯å‘Šä¸€æ®µè½äº†...å·®ä¸å¤šåŠä¸ªæœˆçš„å±…å®¶æ—¶é—´ï¼Œä¹Ÿè·Ÿè‡ªå·±è¯´å£°è¾›è‹¦äº†ï¼Œä¸å®¹æ˜“å•Š~è¯è¯´ï¼Œæ˜Žå¤©åŽ»è¡Œé‡Œåº”è¯¥è¿˜å¾ˆå¿™å‘¢ï¼Œå“ˆå“ˆï¼ŒFighting å§ðŸ§]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_04]]></title>
    <url>%2F2022%2F12%2F17%2FNand2Tetris-Part1-04%2F</url>
    <content type="text"><![CDATA[æŽ¥ç€ 2 å¹´å‰çš„è¯¾ç¨‹ç»§ç»­å­¦ä¹ ðŸ˜‚... Unit 4.1 Machine Languages: Overviewæœ¬å°èŠ‚ä¸»è¦ä»‹ç»ä¸Žæœºå™¨è¯­è¨€ç›¸å…³çš„ä¸€äº›åŸºæœ¬è®¤è¯†ï¼Œå¤§èƒ¡å­è€å¸ˆæåˆ°äº†å›¾çµç¥–å¸ˆçˆ·å’Œå†¯è¯ºä¼Šæ›¼ç¥–å¸ˆçˆ·ðŸ˜‚ã€‚ä¸å¾—ä¸è¯´ï¼Œåªè¦æ˜¯è·Ÿè®¡ç®—æœºç›¸å…³çš„ä¸œè¥¿ï¼Œä¸€å®šè¦ä»‹ç»è¿™ 2 ä½ç¥–å¸ˆçˆ·ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªå°èŠ‚ä¸»è¦ä»‹ç»çš„å†…å®¹æ˜¯è®²å†…å­˜ä¸Ž CPU å¦‚ä½•æ²Ÿé€šï¼Œé€šä¿—æ¥è®²ï¼Œå°±æ˜¯åœ¨è®²è®¡ç®—æœºæ˜¯å¦‚ä½•æ‰§è¡ŒæŒ‡ä»¤çš„ã€‚å› ä¸º CPU åªè®¤è¯† 0 å’Œ 1 çš„æ¯”ç‰¹æµï¼Œæ‰€ä»¥å†…å­˜éœ€è¦è®²è¿™äº›æ¯”ç‰¹æµä¼ ç»™ CPUï¼Œç”± CPU è®¡ç®—å¥½äº†ä¹‹åŽåœ¨ä¼ ç»™ RAMã€‚è€Œé‚£äº›æ¯”ç‰¹æµå°±æ˜¯æŒ‡ä»¤ï¼ˆInstructionï¼‰ï¼Œè€Œ CPU è®¡ç®—çš„ç»“æžœå°±æ˜¯äººéœ€è¦çš„æ•°æ®ï¼ˆDataï¼‰ã€‚å½“ç„¶äº†ï¼ŒCPU ä¼ ç»™ RAM çš„æ•°æ®ä¾ç„¶æ˜¯æ¯”ç‰¹æµï¼Œè½¬æ¢ä¸ºäººèƒ½çœ‹æ‡‚çš„ä¸œè¥¿ï¼Œè¿˜éœ€è¦ç‰¹å®šçš„è½¯ä»¶æ¥é˜…è¯»ã€‚ æœ€åŽï¼Œå¤§èƒ¡å­è€å¸ˆåˆè®²äº†ä¸€ç‚¹è·Ÿæœºå™¨è¯­è¨€ç›¸å…³çš„ä¸œè¥¿ï¼Œä¸è¿‡è¿™æœºå™¨è¯­è¨€çœ‹ç€æŒºåƒæ±‡ç¼–çš„ï¼Œè™½ç„¶ä¹Ÿæ²¡å­¦è¿‡æ±‡ç¼–...ðŸ˜‚ Unit 4.2 Machine Language: Elementsä¾ç„¶å»¶ç»­ä¸Šä¸€èŠ‚å’Œæœºå™¨è¯­è¨€ç›¸å…³çš„å†…å®¹ï¼Œä¸è¿‡è¿™ä¸€å°èŠ‚è®²çš„æ›´å¤šçš„æ˜¯æœºå™¨è¯­è¨€çš„è¯­æ³•ï¼Œæˆ–è€…è¯´ï¼Œæ˜¯è¿™ä¸€æ¡æŒ‡ä»¤åœ¨è®¡ç®—æœºï¼ˆHackï¼‰å†…å¦‚ä½•åœ¨æ‰§è¡Œã€‚ Addressing Modesæœºå™¨è¯­è¨€çš„æŒ‡ä»¤éƒ½æ˜¯åœ°å€æ¨¡å¼ï¼ˆAddressing Modeï¼Œä¹Ÿä¸çŸ¥é“è¿™ä¹ˆç¿»è¯‘å¯¹ä¸å¯¹ï¼Ÿï¼‰çš„ï¼ŒæŒ‰ç…§å¤§èƒ¡å­è€å¸ˆçš„è®²è§£ï¼Œæœºå™¨è¯­è¨€å¯ä»¥ç›´æŽ¥ä½œç”¨äºŽå¯„å­˜å™¨ï¼Œå¤§æ¦‚å°±æ˜¯è¿™ä¸ªæ„æ€ã€‚ä¸¾äº†å››ä¸ªä¾‹å­ï¼š1234567891011// RegisterAdd R1, R2 // R2 &lt;- R2 + R1// DirectAdd R1, M[200] // Mem[200] &lt;- Mem[200] + R1// IndirectAdd R1, @A // Mem[A] &lt;- Mem[A] + R1// ImmediateAdd 73, R1 // R1 &lt;- R1 + R3 è¿™éš¾é“çœ‹ç€ä¸å°±æ˜¯æ±‡ç¼–å—ï¼ŸðŸ˜‚ Unit 4.3 The Hack Computer and Machine Languageæœ¬å°èŠ‚ä¸»è¦è®²è§£å³å°†è¦åšçš„ Hack Computer çš„å·¥ä½œåŽŸç†å’Œåœ¨ Hack ä¸Šç”¨çš„ Machine Language çš„ä¸€äº›è¯­æ³•ã€‚Hack ä¸­çš„æœºå™¨è¯­è¨€çš„æ‰§è¡Œè¿‡ç¨‹æ˜¯ï¼šå®žé™…ä¸Šä¹Ÿå°±æ˜¯ CPU è¯»å–ä¿å­˜åœ¨ instruction memory å†…çš„æŒ‡ä»¤ï¼ˆinstructionsï¼‰ï¼Œç„¶åŽåŠ è½½ä¿å­˜åœ¨ data memory ä¸­çš„æ•°æ®ï¼Œè®¡ç®—åŽï¼Œå°†ç»“æžœä¿å­˜åœ¨ data memory ä¸­ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªå›¾è¿˜å¯ä»¥ç”»æˆï¼šè¿™æ ·ä¼šæ›´æ¸…æ™°ä¸€äº›ã€‚Hack æ˜¯ä¸ª 16 çš„è®¡ç®—æœºï¼Œæ‰€ä»¥è¿™äº›ç¡¬ä»¶çš„æ€»çº¿å®½åº¦ä¹Ÿæ˜¯ 16-bits çš„ã€‚ The A-instructionç›´è¯‘æ˜¯ A-æŒ‡ä»¤ï¼Œå®žé™…ä¸Šå°±æ˜¯ Hack çš„æœºå™¨è¯­è¨€ä¸­çš„ä¸€ç§è¯­æ³•ï¼Œåˆ©ç”¨@æ¥è¡¨ç¤ºåœ°å€ï¼ŒåŽé¢è·Ÿä¸Šæ•°å­—ï¼Œè¿™ä¸ªæ•°å­—ä»£è¡¨å†…å­˜åœ°å€ã€‚åªä¸è¿‡ï¼Œè¿™ä¸ªè¯­æ³•éœ€è¦å€ŸåŠ© A å¯„å­˜å™¨æ¥å®Œæˆã€‚æ‰€ä»¥å®žé™…ä¸Šï¼ŒHack ä¸­è¿™æ¡è¯­å¥çš„æ‰§è¡Œè¿‡ç¨‹æ˜¯å…ˆå°†@åŽçš„åœ°å€å­˜å…¥ A å¯„å­˜å™¨ï¼Œè€Œ A å¯„å­˜å™¨ä¸­çš„åœ°å€å€¼ï¼Œä¼šè¢«å½“ä½œRAM[A]æ¥ä½¿ç”¨ï¼Œå®žé™…ä¸Š M å°±æ˜¯ RAM[A]ï¼ŒåŸºæœ¬è¯­æ³•ï¼š12@0M=1 // RAM[0] = 1 The C-instructionC-æŒ‡ä»¤ï¼Œè¿™æ˜¯ä¸ªå¤åˆè¯­å¥ï¼Œæœ‰ç‚¹ç±»ä¼¼ C/C++ ä¸­çš„ for å¾ªçŽ¯ï¼ŒåŸºæœ¬è¯­æ³•ï¼š1234dest = comp; jump // both dest and jump are optionalcomp = 0, 1, -1, D... // read the book get the othersdest = null, M, D, MD... // read the book get the othersjump = null, JGT, JEQ... // read the book get the others è€å¸ˆä¸¾å¾—ä¾‹å­è¿™é‡Œå°±ä¸å†™äº†ã€‚ Unit 4.4 Hack Language Specificationæœ¬å°èŠ‚ç»§ç»­åœ¨è®²ä¸Ž Hack Language ç›¸å…³çš„å†…å®¹ï¼ŒHack program å°±æ˜¯ç”¨ Hack machine language å†™çš„ä¸€ç³»åˆ—æŒ‡ä»¤ï¼Œå®žé™…ä¸Šè¿™ä¸Žå…¶ä»–ç¨‹åºè¯­è¨€æ˜¯ä¸€æ ·çš„ã€‚æŽ¥ç€ï¼Œè€å¸ˆåˆè®²äº†è®²ç¬¦å·æŒ‡ä»¤ï¼ˆSymbolic instructionsï¼‰å’ŒäºŒè¿›åˆ¶ä»£ç åœ¨ Hack Language ä¸­çš„å¯¹åº”å…³ç³»ï¼ˆè¿™äº›æŸ¥ä¹¦éƒ½å¯ä»¥æŸ¥åˆ°ï¼Œç†è§£èµ·æ¥ä¹Ÿæ¯”è¾ƒç®€å•ï¼‰ã€‚ Unit 4.5 Input/Outputæœ¬å°èŠ‚ä¸»è¦ä»‹ç»äº†åœ¨ Hack ä¸­å¦‚ä½•ä½¿ç”¨ä¸¤ä¸ª I/O è®¾å¤‡ã€‚é¦–å…ˆæ˜¯ Screenï¼ŒHack ä¸­çš„ Screen æ˜¯ä¸€ä¸ª 8K çš„å†…å»ºèŠ¯ç‰‡ï¼ˆbuilt-in chipï¼‰ï¼Œå®žé™…ä¸Šæ˜¯ä¸€ä¸ªäºŒç»´çŸ©é˜µï¼Œ512 åˆ—ï¼Œ256 è¡Œï¼Œè¿™ä¸ªçŸ©é˜µçš„æ¯ä¸€ä¸ªå…ƒç´ ä»£è¡¨ä¸€ä¸ª bitï¼Œç›´æŽ¥é€šè¿‡åœ°å€æ¥æ“æŽ§è¿™äº› bitã€‚å¯¹åº”çš„ï¼ŒæŒ‰ç…§åœ°å€çš„ç´¢å¼•æ–¹å¼æœ‰ä¸¤ä¸ªï¼š$ Screen[32 * row + col / 16] $ å’Œ $ RAM[16384 + 32 * row + col / 16]$ï¼ŒäºŒè€…æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œåªä¸è¿‡å‰è€…ç›´æŽ¥ä»Žä»£è¡¨ Screen çš„é‚£éƒ¨åˆ†å†…å­˜å¼€å§‹ç´¢å¼•ï¼Œè€ŒåŽè€…ä»Žæ•´ä¸ªå†…å­˜å•å…ƒçš„å¼€å¤´è¿›è¡Œç´¢å¼•ã€‚ä»Žè¿™é‡Œä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒScreen åœ¨å†…å­˜ä¸­çš„å¼€å§‹åœ°å€æ˜¯ 16385ã€‚ç¬¬äºŒä¸ªä»‹ç»çš„é”®ç›˜çš„ä½¿ç”¨ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå†…å»ºèŠ¯ç‰‡ï¼ˆbuilt-in chipï¼‰ï¼Œä½†æ˜¯è¿™ä¸ªå†…å»ºèŠ¯ç‰‡æ²¡æœ‰è¾“å…¥ï¼Œåªæœ‰è¾“å‡ºï¼Œå¯¹åº”çš„è¾“å…¥å…¶å®žå°±æ˜¯ä½ çŽ°åœ¨ç”¨çš„é”®ç›˜ï¼Œæ¯æŒ‰ä¸€ä¸‹ä¸åŒçš„æŒ‰é”®ï¼Œç‚¹å‡» tickï¼Œå°±å¯ä»¥äº§ç”Ÿä¸åŒçš„æ•ˆæžœã€‚ Unit 4.6 Hack Programming Part 1æœ¬å°èŠ‚æ˜¯è®²è§£ Hack Machine Language çš„ç¬¬ä¸€è¯¾ï¼Œä¸»è¦å†…å®¹æ˜¯ Hack Machine Language æ˜¯å¦‚ä½•æ“ä½œå¯„å­˜å™¨å’Œå†…å­˜çš„ã€‚åªéœ€è¦æŒ‰ç…§å…·ä½“çš„è¯­æ³•ä¹¦å†™æŒ‡ä»¤ï¼Œå°±å¯ä»¥æ“ä½œå¯„å­˜å™¨å’Œå†…å­˜äº†ã€‚ä½†æ˜¯è¿™æ ·å†™å‡ºçš„ç¨‹åºï¼Œå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯æ²¡æ³•ç»“æŸï¼Œè€å¸ˆç»™çš„å»ºè®®æ˜¯å®ŒæˆåŠŸèƒ½åŽï¼Œåœ¨ç»“å°¾å†™ä¸€ä¸ªå¾ªçŽ¯ã€‚ Unit 4.7 Hack Programming Part 2æœ¬å°èŠ‚æ˜¯è®²è§£ Hack Machine Language çš„ç¬¬äºŒè¯¾ï¼Œä¸»è¦å†…å®¹æ˜¯ Hack Machine Language ä¸­çš„åˆ†æ”¯ï¼ˆBranchingï¼‰ã€å˜é‡ï¼ˆVariablesï¼‰å’Œè¿­ä»£ï¼ˆIterationï¼‰ä¸‰ç§ç»“æž„çš„ç”¨æ³•ï¼Œè¿™ä¸‰ç§ç»“æž„éƒ½æ˜¯ç”±å‰é¢æåˆ°çš„ A æŒ‡ä»¤å’Œ C æŒ‡ä»¤æž„æˆçš„ã€‚ Branchingåˆ†æ”¯ç»“æž„ä¼šç”¨åˆ°ç±»ä¼¼ C è¯­è¨€ä¸­go toå…³é”®å­—çš„åŠŸèƒ½ï¼Œä¼šè·³è½¬åˆ°ä¸€è¡Œå¼€å§‹æ‰§è¡Œã€‚è¿™é‡Œï¼Œåˆå¼•å‡ºäº†è¡Œå·çš„æ¦‚å¿µï¼Œä¹Ÿå°±æ˜¯å¯ä»¥ç›´æŽ¥å†™æˆ@8ï¼Œè¿™ä¸ªæ•°å­— 8 å°±ä»£è¡¨è·³åˆ°ç¬¬ 8 è¡Œå¼€å§‹æ‰§è¡Œã€‚ä¸ºäº†æé«˜å¯è¯»æ€§ï¼Œå¯ä»¥å†™æˆ@labelï¼Œåªéœ€è¦å†åœ¨åŽé¢çš„æŸä¸€è¡Œå†™ä¸Š(label)å³å¯ï¼Œå…¶ä¸­çš„ label æ˜¯å¯ä»¥å†™æˆæœ‰æ„ä¹‰çš„å­—ç¬¦çš„ã€‚ Variableså˜é‡çš„ç”¨æ³•å’Œåˆ†æ”¯ä¸­ label çš„ç”¨æ³•æ˜¯ç±»ä¼¼çš„å†™æ³•éƒ½æ˜¯@labelï¼Œå¦‚æžœæ²¡æœ‰åœ¨åŽé¢çš„è¯­å¥ä¸­å†™ä¸Š(label)ï¼Œé‚£ä¹ˆæ±‡ç¼–å™¨å°±ä¼šè®¤ä¸ºè¿™ä¸ª label æ˜¯ä¸ªå˜é‡ã€‚å¦å¤–ï¼Œå˜é‡çš„å®žé™…å†…å­˜åœ°å€æ˜¯ä»Žåœ°å€ 16 å¼€å§‹çš„ï¼Œè¿™ä¸ªåœ°å€ä½äºŽ RAM èŠ¯ç‰‡ä¸Šã€‚ IterationåŒæ ·ï¼Œå¾ªçŽ¯ç»“æž„ä¹Ÿæ˜¯ç”± A æŒ‡ä»¤å’Œ C æŒ‡ä»¤æž„æˆã€‚è€å¸ˆæ²¡æœ‰å…·ä½“è®²è§£å¾ªçŽ¯æŒ‡ä»¤çš„å†™æ³•ï¼Œç»™äº†ä¸€ä¸ªç´¯åŠ çš„ç¤ºä¾‹ç¨‹åºè‡ªå·±çœ‹ã€‚ç„¶åŽå°±æ˜¯ä¹¦å†™è¿™ç±»ç¨‹åºçš„å»ºè®®ï¼Œå…ˆå†™å¥½ä¼ªä»£ç ï¼Œç„¶åŽå†å†™æˆæœºå™¨è¯­è¨€ä»£ç ã€‚ Unit 4.8 Hack Programming Part 3è¿™æ˜¯æœ€åŽä¸€èŠ‚è¯¾äº†ï¼Œç»ˆäºŽè¦è®²å®Œäº†å“ˆ...ðŸ˜‚è¿™èŠ‚è¯¾æåˆ°äº†æŒ‡é’ˆçš„æ¦‚å¿µï¼Œä¸ºäº†è§£é‡ŠæŒ‡é’ˆçš„ä½¿ç”¨ï¼Œè€å¸ˆä¸¾äº†ä¸€ä¸ªä¾‹å­ã€‚é«˜çº§è¯­è¨€ä¸­çš„æ•°ç»„åœ¨ä½Žçº§è¯­è¨€ä¸­æ˜¯ä¸å­˜åœ¨çš„ï¼Œé‚£ä½Žçº§è¯­è¨€æ˜¯å¦‚ä½•æ¥å®Œæˆå¯¹åº”çš„åŠŸèƒ½å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ç”¨æŒ‡é’ˆå®Œæˆçš„ï¼Œæ•°ç»„å arr å°±æ˜¯é¦–åœ°å€ï¼Œç„¶åŽç”¨ä¸€ä¸ª i ä»£è¡¨åç§»é‡ï¼Œä¹Ÿå°±æœ‰ï¼š$ arr + i = arr[i] $ï¼Œæ˜¾ç„¶è¿™ä¸Ž C è¯­è¨€æ˜¯ä¸€è‡´çš„ï¼ˆæžœç„¶ï¼ŒC è¯­è¨€å­¦çš„å¥½ï¼Œè¿™æ–¹é¢å¾ˆå®¹æ˜“ç†è§£ï¼‰ã€‚ åŽé¢åˆæåˆ°äº†ä¹‹å‰æåˆ°çš„ä¸¤ä¸ªè®¾å¤‡ï¼šå±å¹•å’Œé”®ç›˜ï¼Œåˆ†åˆ«æ¼”ç¤ºäº†ä¸¤ä¸ª demo ç¨‹åºï¼Œç®—æ˜¯è®²è§£äº†åœ¨ CPU Emulator ä¸­å¦‚ä½•ä½¿ç”¨è¿™ä¸¤ä¸ªè®¾å¤‡ã€‚ Unit 4.9 Project 4 Overviewè¿™å‘¨çš„ä»»åŠ¡æ¯”è¾ƒå°‘ï¼Œåªæœ‰ä¸¤ä¸ªä»»åŠ¡ã€‚ç¬¬ä¸€ä¸ªä»»åŠ¡æ˜¯ç”¨æœºå™¨è¯­è¨€å†™ä¸€ä¸ªä¹˜æ³•ç¨‹åºï¼Œèƒ½æ­£ç¡®èŽ·å¾— 2 ä¸ªæ•°çš„ä¹˜æ³•ç»“æžœå³å¯ï¼›ç¬¬äºŒä¸ªä»»åŠ¡æ˜¯ç”¨æœºå™¨è¯­è¨€å†™ä¸€ä¸ªäº¤äº’ç¨‹åºï¼Œæ¯å½“æŒ‰ä¸‹é”®ç›˜çš„æŒ‰é”®æ—¶ï¼Œæ¨¡æ‹Ÿå™¨çš„å±å¹•å°±ä¼šå˜é»‘ï¼Œæ¾å¼€æŒ‰é”®å°±ä¼šè¿˜åŽŸã€‚ Multä»Žæ€è·¯ä¸Šæ¥è®²ï¼Œä¹˜æ³•çš„å®žçŽ°å¾ˆç®€å•ï¼ŒALU æ˜¯æœ‰åŠ æ³•è¿ç®—åŠŸèƒ½çš„ï¼Œæ‰€ä»¥å†™ä¸€ä¸ªå¾ªçŽ¯ï¼Œé‡å¤åŠ ä¸Šç›¸åŒçš„æ•°å­—ï¼Œæœ€åŽå°†ç»“æžœä¿å­˜åœ¨æŒ‡å®šçš„å¯„å­˜å™¨ä¸­å³å¯ã€‚å…ˆçœ‹ä¸‹ç®€å•çš„åŠ æ³•æ˜¯æ€Žä¹ˆå†™çš„ï¼š123456789// D = R0@R0D=M// D = D + R1@R1D=D+M// R2 = D@R2M=D è€å¸ˆè¿˜è®²è¿‡ä¸€ä¸ªä»Ž 1 åŠ åˆ° 100 çš„ç¨‹åºï¼š1234567891011121314151617181920212223// Adds 1 + ... + 100 @i M=1 @sum M=0(LOOP) @i D=M @100 D=D-A @END D;JGT @i D=M @sum M=D+M @i M=M+1 @LOOP 0;JMP(END) @END 0;JMP è¿™ä¸ªç¨‹åºå·²ç»æŠŠå®Œæˆè¿™ä¸ªä»»åŠ¡éœ€è¦çš„å¾ªçŽ¯å†™å¥½äº†ï¼Œç…§ç€è¿™ä¸ªæ”¹ä¸€æ”¹å°±å¯ä»¥äº†ï¼Œåˆç†å·æ‡’ðŸ˜˜ã€‚æ”¹å®Œä¹‹åŽï¼š12345678910111213141516171819202122 @i M=0 @R2 M=0(LOOP) @R0 D=M @i D=D-M @END D;JLE // D &lt; 0, jump to END @R1 D=M @R2 M=D+M @i M=M+1 @LOOP 0;JMP(END) @END 0;JMP ç”¨æµ‹è¯•è„šæœ¬è¯•äº†ä¸‹ï¼Œæ²¡æœ‰é—®é¢˜ã€‚éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œå¾ªçŽ¯çš„å†™æ³•æœ‰å¾ˆå¤šç§ï¼Œä¸ç”¨å±€é™äºŽä¸€ç§ã€‚è¯è¯´å›žæ¥ï¼Œè¿™æ®µä»£ç çš„å¯è¯»æ€§æ˜¯çœŸçš„å·®ã€‚å•ç‹¬çœ‹è¿™æ®µä»£ç ï¼Œæˆ–è€…éš”ä¸€æ®µæ—¶é—´æ¥çœ‹ï¼Œåº”è¯¥å®Œå…¨ä¸çŸ¥é“å†™çš„æ˜¯å•¥... Fillè¿™ä¸ªé—®é¢˜å¯ä»¥åˆ†æˆ 2 ä¸ªå­é—®é¢˜ï¼š å¦‚ä½•ä½¿å±å¹•å…¨éƒ¨å˜é»‘ï¼Ÿ å¦‚ä½•èŽ·å–é”®ç›˜è¾“å…¥ï¼Ÿ å…ˆè€ƒè™‘ç¬¬ä¸€ä¸ªé—®é¢˜ã€‚åœ¨è€ƒè™‘è¿™ä¸ªé—®é¢˜ä¹‹å‰ï¼Œå…ˆç ”ç©¶ä¸€ä¸‹è€å¸ˆçš„è§†é¢‘ä¸­çš„ç¤ºä¾‹ç¨‹åºï¼š12345678910111213141516171819202122232425262728293031323334353637 @R0 D=M @n M=D @i M=0 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(LOOP) @i D=M @n D=D-M @END D;JGT // if i&gt;n go END @address A=M M=-1 @i M=M+1 @32 D=A @address M=D+M // address = address + 32 @LOOP 0;JMP // go to LOOP(END) @END // program&apos;s end 0;JMP è¿™ä¸ªç¨‹åºæœ€ç»ˆå®žçŽ°çš„æ•ˆæžœæ˜¯ï¼Œåœ¨å±å¹•ä¸Šæ‰“å°äº†ä¸€ä¸ª 16 ä¸ªåƒç´ å®½ï¼Œ$RAM[0]$ ä¸ªé•¿åº¦çš„é»‘è‰²çŸ©å½¢ã€‚ä»Žè¿™ä¸ªç¨‹åºä¸­ï¼Œå¯ä»¥å¾—å‡ºå‡ ä¸ªç»“è®ºï¼š å†…å­˜ä¸­ä¸€ä¸ªåœ°å€æŒ‡å‘çš„ 16 ä½å¯„å­˜å™¨å°±ä»£è¡¨äº†å±å¹•ä¸­ 16 ä¸ªåƒç´ ç‚¹ï¼ŒæŠŠè¿™ä¸ªå†…å­˜å•å…ƒçš„å€¼æ”¹ä¸º -1ï¼Œå°±å¯ä»¥ä½¿è¿™ 16 ä¸ªåƒç´ ç‚¹å˜é»‘ã€‚ åœ°å€æ¯åŠ  1ï¼Œå°±ä¼šè·³è¿‡ 16 ä¸ªåƒç´ ç‚¹ï¼Œä¹Ÿå³æ¯ç§»åŠ¨ä¸€ä¸ªå¯„å­˜å™¨ï¼Œå°±ä¼šè·³è¿‡ 16 ä¸ªåƒç´ ç‚¹ã€‚ å±å¹•çš„ä¸€è¡Œç”± 32 ä¸ªå†…å­˜å•å…ƒï¼ˆå¯„å­˜å™¨ï¼‰æ¥æ˜ å°„è¿™äº›åƒç´ ç‚¹ã€‚ æœ‰äº†è¿™äº›ç»“è®ºï¼Œè¦æƒ³å¾—åˆ°ä¸€ä¸ªå®Œå…¨å˜é»‘çš„å±å¹•ï¼Œåªéœ€è¦ä»Ž 16834 è¿™ä¸ªåœ°å€å¼€å§‹ï¼ŒæŠŠæŽ¥ä¸‹æ¥å…± 8192 ä¸ªå†…å­˜å•å…ƒçš„å€¼å…¨ç½®ä¸º -1 å³å¯ã€‚ï¼ˆå®žé™…ä¸Šï¼Œ16384 + 8192 = 24576ï¼Œè¿™ä¸ªåœ°å€å°±æ˜¯æ˜ å°„ä¸ºé”®ç›˜çš„åœ°å€ï¼ŒåŒæ—¶ä¹Ÿå¯ä»¥çŸ¥é“ä¸ºä»€ä¹ˆè€å¸ˆè¦è¯´å±å¹•æ˜¯ 8K çš„ã€‚ï¼‰ä¿®æ”¹ä¸‹ä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637 @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(LOOP) @i D=M @n D=D-M @END D;JGT // if i&gt;n go END @address A=M M=-1 @i M=M+1 @1 D=A @address M=D+M // address = address + 32 @LOOP 0;JMP // go to LOOP(END) @END // program&apos;s end 0;JMP å®žé™…ä¸Šï¼Œåªéœ€è¦è®¾ç½®å¾ªçŽ¯æ¬¡æ•°ä¸º 8192 æ¬¡ï¼Œi çš„é€’è¿›å€¼æ”¹ä¸º 1 å³å¯ã€‚è¿è¡ŒåŽï¼Œå°±å¯ä»¥å®žçŽ°å±å¹•å˜é»‘çš„æ•ˆæžœäº†ã€‚ çŽ°åœ¨è€ƒè™‘ç¬¬äºŒä¸ªé—®é¢˜ã€‚æœ‰äº†å‰é¢çš„æ€è€ƒï¼Œç›®å‰å·²ç»çŸ¥é“äº†åœ°å€ä¸º 24576 çš„å†…å­˜å•å…ƒä¿å­˜çš„æ˜¯æŒ‰é”®çš„å€¼ã€‚ç®€è¨€ä¹‹å¯¹åº”ä¸¤ç§æƒ…å†µï¼š æŒ‰é”®äº†ï¼Œå€¼ä¸ä¸º 0ã€‚ æœªæŒ‰é”®ï¼Œå€¼ä¸º 0ã€‚ é‚£ä¹ˆï¼Œå¯ä»¥æ ¹æ®è¿™ä¸ªæƒ…å†µï¼Œåˆ†åˆ«æ‰§è¡Œå°†å±å¹•å˜é»‘å’Œå˜ç™½çš„å­ä»£ç å—ï¼ˆè¿™ä¸ªè¯­è¨€æ²¡æœ‰å‡½æ•°çš„æ¦‚å¿µï¼Œä¸çŸ¥é“æ€Žä¹ˆæè¿°äº†...ðŸ˜‚ï¼‰ã€‚ä¿®æ”¹åŽçš„ä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687(PRIMARYLOOP) @KBD D=M @0 D=D-A @WHITE D;JEQ @BLACK 0;JMP(BLACK) @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(BLOOP) @i D=M @n D=D-M @BEND D;JGT // if i&gt;n go BEND @address A=M M=-1 @i M=M+1 @1 D=A @address M=D+M // address = address + 1 @BLOOP 0;JMP // go to BLOOP(BEND) @PRIMARYLOOP 0;JMP(WHITE) @8192 D=A @n M=D @i M=1 @SCREEN D=A @address M=D // address = 16384 (base address of the Hack screen)(WLOOP) @i D=M @n D=D-M @WEND D;JGT // if i&gt;n go WEND @address A=M M=0 @i M=M+1 @1 D=A @address M=D+M // address = address + 1 @WLOOP 0;JMP // go to WLOOP(WEND) @PRIMARYLOOP 0;JMP ä¸Šé¢çš„ä»£ç å®žé™…ä¸Šæ˜¯ä¸¤ä¸ªé‡å¤çš„éƒ¨åˆ†ï¼Œè€Œä¸»å¾ªçŽ¯ç¨‹åºä¹Ÿä¸è¿‡ 8 è¡Œï¼Œä¸»è¦æ˜¯èƒŒåŽçš„é€»è¾‘å¤ªç®€å•äº†ï¼Œå°±æ˜¯ä¸€ä¸ªæ¡ä»¶è¯­å¥ï¼Œä¸¤ä¸ªåˆ†æ”¯ï¼ŒæŠŠæ‰€æœ‰æƒ…å†µéƒ½å†™å‡ºæ¥å³å¯ã€‚ä¸è¿‡ï¼Œå› ä¸ºæœºå™¨è¯­è¨€æœ‰å¾ˆå¤šè·³è·ƒè¯­å¥ï¼Œæ‰€ä»¥ç”¨äºŽè·³è·ƒçš„ label ä¸€å®šè¦å†™çš„æ¸…æ™°æ˜Žäº†ä¸€ç‚¹ï¼Œä¸ç„¶å®¹æ˜“æŠŠè‡ªå·±æžæ··ã€‚ Unit 4.10 Perspectiveåˆåˆ°äº†è¿™å‘¨çš„é—®é¢˜æ—¶é—´ï¼š Hack Machine Language å’ŒçŽ°å®žä¸­çš„æœºå™¨è¯­è¨€æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Ÿ Hack Machine Language å¾ˆç®€å•ï¼Œç›¸æ¯”ä¹‹ä¸‹ï¼ŒçŽ°å®žä¸­çš„æœºå™¨è¯­è¨€æä¾›äº†æ›´ä¸°å¯Œçš„æŒ‡ä»¤å’ŒåŠŸèƒ½ï¼Œæ¯”å¦‚ä¹˜æ³•å’Œé™¤æ³•ã€‚ä½†æ˜¯ï¼Œè¿™äº›åŠŸèƒ½ä¹Ÿå¯ä»¥åœ¨ Hack è¿™å°è®¡ç®—æœºçš„æ›´é«˜å±‚å®Œç¾Žå®žçŽ°ã€‚ æ‰€æœ‰çš„æœºå™¨è¯­è¨€æ˜¯ä¸æ˜¯éƒ½è¦æ‹¥æœ‰æ”¹å˜å¯„å­˜å™¨çš„å€¼å’ŒèŽ·å–æŸä¸ªå¯„å­˜å™¨çš„åœ°å€è¿™ä¸¤ä¸ªåŠŸèƒ½ï¼Ÿ å®žé™…ä¸Šï¼ŒçŽ°å®žçš„æœºå™¨è¯­è¨€ä¸ä»…ä»…åªæä¾›äº†è¿™ä¸¤ä¸ªåŸºç¡€åŠŸèƒ½ã€‚ äººä»¬ç”¨æœºå™¨è¯­è¨€å†™ç¨‹åºæ—¶ï¼Œä¼šé‡åˆ°å›°éš¾å—ï¼Ÿ ï¼ˆè¿™é—®é¢˜é—®çš„ðŸ˜‚ï¼‰å®žé™…ä¸Šï¼Œäººä»¬å¹¶ä¸ç›´æŽ¥ç”¨æœºå™¨è¯­è¨€å†™ç¨‹åºï¼Œè€Œæ˜¯ç›´æŽ¥ç”¨é«˜çº§è¯­è¨€å†™ç¨‹åºï¼Œå†ç”¨ç¼–è¯‘å™¨å°†é«˜çº§è¯­è¨€ç¿»è¯‘æˆæœºå™¨è¯­è¨€ã€‚ä½†æ˜¯ï¼Œå¦‚æžœè¦æé«˜ç¨‹åºçš„æ€§èƒ½ï¼Œå°±å¿…é¡»è¦èƒ½çœ‹æ‡‚é«˜çº§è¯­è¨€è¢«ç¿»è¯‘åŽçš„æœºå™¨è¯­è¨€ã€‚å¯¹åº”çš„ï¼Œè¿™ä¸ªè¯¾ç¨‹çš„ç¬¬äºŒéƒ¨åˆ†ï¼Œä¹Ÿä¼šå­¦ä¹ ä¸Žç¼–è¯‘å™¨ç›¸å…³çš„å†…å®¹ï¼Œå¹¶è¯•ç€åŽ»ç¼–å†™ä¸€ä¸ªç¼–è¯‘å™¨ã€‚ è¿™å‘¨çš„ä¸»é¢˜æ˜¯æœºå™¨è¯­è¨€ï¼Œç›¸æ¯”å‰é¢çš„å†…å®¹ï¼Œè¿™ä¸€ç« ç»ˆäºŽè·Ÿç”µè·¯è”ç³»çš„ä¸æ˜¯é‚£ä¹ˆç´§å¯†äº†ã€‚è¿™ä¸€ç« çš„éš¾ç‚¹æ›´å¤šçš„æ˜¯åœ¨è¯­è¨€çš„è¯­æ³•æ–¹é¢ï¼Œå¥½åœ¨è€å¸ˆç»™çš„ç¤ºä¾‹ç¨‹åºå¾ˆå¤šï¼Œå€Ÿç”¨ä¸€ä¸‹ï¼Œå°±å¯ä»¥å¾ˆå¥½çš„å®Œæˆä½œä¸šäº†ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_11_æœˆæ€»ç»“]]></title>
    <url>%2F2022%2F12%2F04%2F2022-11-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[åä¸€æœˆæ‚„æ‚„æºœèµ°å•¦~ November Rain - Gunsâ€™nâ€™RoseYour browser does not support the audio tag. ä¸çŸ¥ä¸è§‰ï¼Œè·ç¦»ä¸Šæ¬¡å†™ç±»ä¼¼çš„æ–‡ç« ï¼Œåˆè¿‡äº†åŠä¸ªæœˆäº†ã€‚åŠä¸ªæœˆæ¥ï¼Œä¸Šæµ·çš„å¤©æ°”æ€»æ˜¯é˜´é˜´çš„ï¼Œæ—¶ä¸æ—¶è¿˜ä¼´éšç€ç»†é›¨ï¼Œå•ªå—’å•ªå—’è½åœ¨è¡ŒäººåŒ†å¿™çš„é›¨ä¼žä¸Šã€‚ç©ºæ°”çš„æ¸©åº¦ï¼Œä¹Ÿéšç€ç§‹é›¨çš„é™è½è€Œéª¤é™ã€‚æ˜¯å†¬å¤©ï¼Œå†¬å¤©æ¥äº†ï¼Œé›¨æ°´ç”¨å®ƒè‡ªå·±çš„æ–¹å¼åœ¨æé†’ç€äººä»¬ï¼Œè¯¥åŠ è¡£æœäº†ï¼Œå‘µå‘µã€‚å°½ç®¡å¤´é¡¶çš„ä¹Œäº‘ä»æœªæ¶ˆæ•£ï¼Œä½†æ˜¯æŠ¬èµ·å¤´å¥½åƒå·²ç»å¯ä»¥çœ‹åˆ°å…‰çº¿ä»Žäº‘å±‚ä¸­ç…§å°„ä¸‹æ¥äº†ã€‚ å›žåˆ°è‡ªå·±çš„ç”Ÿæ´»ä¸­æ¥ã€‚é‡æ–°å¼€å§‹ä¸Šç­ç”Ÿæ´»ä¹Ÿå·²è¿‡åŠæœˆäº†ï¼Œå¤©å¤©å€’æ˜¯æ¸…é—²çš„å¾ˆï¼ŒåŸºæœ¬æ²¡ä»€ä¹ˆäº‹æƒ…ï¼Œå¤§å¤šæ•°æ—¶é—´éƒ½æ˜¯åœ¨çœ‹è‡ªå·±æ„Ÿå…´è¶£çš„ä¹¦ç±ï¼Œå¾…çš„äººéƒ½æœ‰ç‚¹å¿ƒæ…Œäº†ðŸ˜‚ã€‚æœŸé—´ï¼Œä¸€èµ·åŒä½çš„æœ‹å‹å° z æˆå¯†æŽ¥äº†ï¼Œè¢«éš”ç¦» 5+3 äº†ï¼Œè‡ªå·±å€’æ˜¯æ²¡ä»€ä¹ˆé—®é¢˜ã€‚çŽ°åœ¨ï¼Œä»–å·²ç»éš”ç¦»å®Œäº†ï¼Œä¹Ÿæ²¡æœ‰ä»€ä¹ˆé—®é¢˜ã€‚å…³äºŽç–«æƒ…çš„é—®é¢˜ï¼Œä¹Ÿå·²ç»è¶Šæ¥è¶Šæ˜Žæœ—äº†èµ·æ¥ï¼Œè¿™æ˜¯å¥½äº‹ã€‚ åŠä¸ªæœˆçš„ä¸Šç­ç”Ÿæ´»ï¼Œä¸€å…±å†™äº† 4 ç¯‡ Blogï¼Œå…¶ä¸­ 3 ç¯‡éƒ½æ˜¯ä¸Ž VBS æœ‰å…³ï¼Œè¿™ä¹Ÿæ˜¯å…¬å¸çš„è¦æ±‚äº†ï¼Œæ¯•ç«Ÿæ˜¯æŽ¥ä¸‹æ¥è¦ä½¿ç”¨çš„å·¥å…·ã€‚å‰©ä¸‹çš„ 1 ç¯‡æ˜¯å…³äºŽç®€å•ä½¿ç”¨ G++ ç¼–è¯‘å™¨çš„ï¼Œè¿™äº›å®Œæˆçš„éƒ½å¾ˆè½»æ¾ã€‚å…¶ä»–çš„æ—¶é—´éƒ½æ˜¯åœ¨è¯»ã€ŠC++ Primerã€‹è¿™æœ¬ä¹¦äº†ï¼Œè¿™æ®µæ—¶é—´ç®—ä¸Šæ¥ä¸€å…±è¯»äº† 8 ç« ï¼Œç®—æ˜¯è¯»å®Œäº† C++ åŸºç¡€éƒ¨åˆ†ï¼Œå¹¶ä¸”å¼€å§‹è¯» C++ æ ‡å‡†åº“äº†ã€‚ è¯»è¿™æœ¬ä¹¦çš„è¿‡ç¨‹ä¸­ï¼Œç¡®å®žæ”¶èŽ·äº†ä¸€äº›ä¸œè¥¿ï¼Œä¹Ÿæœ‰ä¸€äº›è¯»çš„ä¸€çŸ¥åŠè§£çš„åœ°æ–¹ã€‚å½“ç„¶äº†ï¼Œè‡ªå·±ä¹Ÿæ²¡æƒ³ç€ä¸€éå°±å…¨è¯»æ‡‚äº†ï¼ˆå¦‚æžœçœŸçš„è¿™æ ·ï¼Œä¹Ÿå°±æ²¡æœ‰å¿…è¦è¯»è¿™æœ¬ä¹¦äº†ï¼‰ï¼ŒåŽé¢å®žè·µè¿‡ç¨‹ä¸­é‡åˆ°äº†ï¼Œå›žå¤´æ¥çœ‹åº”è¯¥ä¼šç†è§£çš„æ›´æ·±åˆ»å§ã€‚ æŒ‰ç…§äººäº‹çš„è¯´æ³•ï¼Œä¸‹å‘¨å°±å¯ä»¥æ­£å¼çš„å¼€å§‹å·¥ä½œäº†ï¼Œå¿ƒé‡Œè¿˜æ˜¯æœ‰ç‚¹æœŸå¾…æ–°çš„å·¥ä½œå†…å®¹çš„ã€‚å¯æ˜¯ï¼Œæ˜¨å¤©ä¸ŽåŒäº‹èŠè¿‡ä¹‹åŽï¼Œå‘çŽ°è‡ªå·±çš„å·¥ä½œå†…å®¹å¥½åƒä¸»è¦éƒ½æ˜¯å’Œ VBS ç›¸å…³çš„ï¼Œè‡ªå·±æ˜Žæ˜Žæƒ³åšçš„æ˜¯ä¸Ž C/C++ ç›¸å…³çš„åŽç«¯æ–¹å‘ã€‚åŒæ—¶ï¼Œè¿˜å¾—çŸ¥è‡ªå·±åšçš„é¡¹ç›®å¥½åƒæ˜¯ä¸Ž ATM ç›¸å…³çš„ä¸œè¥¿ðŸ˜‚ï¼Œä¸€å¬åå­—å°±è§‰å¾—æ˜¯å¾ˆè€çš„æŠ€æœ¯ã€‚å“ŽðŸ˜”ï¼Œè‡ªå·±çœŸæ˜¯å‘½é€”å¤šèˆ›å•Šã€‚ ä¸ç®¡æ€Žä¹ˆè¯´ï¼Œä»Žåšäººåšäº‹çš„è§’åº¦æ¥çœ‹ï¼Œå¾—å¹²ä¸€è¡Œçˆ±ä¸€è¡Œï¼Œäº‹æƒ…ä¹Ÿè¦æœ‰å§‹æœ‰ç»ˆçš„åšæ‰è¡Œã€‚å¸Œæœ›è‡ªå·±çš„å·¥ä½œå†…å®¹ä¸Žè‡ªå·±çš„å‘å±•æ–¹å‘æœ‰å…³å§ã€‚ å¦å¤–ï¼Œä¸å¾—ä¸æçš„æ˜¯è‡ªå·±çš„ä¸Šç­æ—¶é—´å¤ªç´§å¼ äº†ã€‚å…«ç‚¹åŠä¸Šç­ï¼Œè‡ªå·±å¾—å…­ç‚¹è¿‡ä¸€ç‚¹èµ·æ¥èµ¶åœ°é“ï¼Œèµ¶å…¬äº¤ã€‚è€Œä¸”è¿˜æ˜¯åœ¨å†¬å¤©ï¼Œæ—©ä¸Šèµ·åºŠçœŸæ˜¯å—ç½ªå•Šï¼Œå“ˆå“ˆã€‚æ‰€ä»¥ï¼Œè‡ªå·±ä¸€å®šè¦å¯¹å¾—èµ·è‡ªå·±æ‰è¡Œå•Š~ æœ€åŽï¼Œå¸Œæœ›è‡ªå·±åˆ«ç”Ÿç—…ã€å¥å¥åº·åº·çš„å°±å¥½ðŸ˜ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CLI ä¸‹ G++ çš„ä½¿ç”¨æ–¹æ³•]]></title>
    <url>%2F2022%2F11%2F24%2FCLI-%E4%B8%8B-G-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å­¦ä¹ ä¸€ä¸‹ CLI ä¸‹å¦‚ä½•ä½¿ç”¨ G++/GCC ç¼–è¯‘å™¨ã€‚ ç¼˜ç”±å­¦ä¹ å¦‚ä½•ä½¿ç”¨ç¼–è¯‘å™¨å¯¹äº†è§£ç¨‹åºçš„äº§ç”Ÿè¿‡ç¨‹æ˜¯å¾ˆæœ‰å¸®åŠ©çš„ï¼ˆåºŸè¯ðŸ˜ï¼‰ï¼Œä¸è‡³äºŽè„±ç¦»äº† IDEï¼Œå°±å®Œå…¨ä¸ä¼šç¼–ç¨‹äº†ã€‚å®žé™…ä¸Šï¼Œé€šè¿‡é˜…è¯»ç¼–è¯‘è¿‡ç¨‹ä¸­äº§ç”Ÿçš„ä¸­é—´æ–‡ä»¶ï¼Œä¼šå¯¹ç¼–è¯‘å™¨çš„å·¥ä½œè¿‡ç¨‹æœ‰ä¸€ä¸ªå¾ˆæ¸…æ™°çš„è®¤è¯†ã€‚ è¿™é‡Œä»¥ G++ ç¼–è¯‘å™¨çš„ä½¿ç”¨ä¸ºä¾‹ï¼Œå¹¶ä¸”åªä½œç®€å•çš„ä¸€äº›æŽ¢è®¨ï¼ˆGCC ä¸Ž G++ä¼šæœ‰ä¸åŒçš„åœ°æ–¹ï¼Œä½†åŸºæœ¬ä½¿ç”¨æ–¹æ³•å·®åˆ«ä¸å¤§ï¼‰ã€‚ ç¼–è¯‘è¿‡ç¨‹G++ çš„ç¼–è¯‘è¿‡ç¨‹ä¸»è¦åˆ†ä¸ºå››ä¸ªé˜¶æ®µï¼šé¢„å¤„ç†ï¼ˆPreprocessingï¼‰ã€ç¼–è¯‘ï¼ˆCompilationï¼‰ã€æ±‡ç¼–ï¼ˆAssemblyï¼‰å’Œé“¾æŽ¥ï¼ˆLinkingï¼‰ã€‚ é¢„å¤„ç†åœ¨é¢„å¤„ç†çš„è¿‡ç¨‹ä¸­ï¼Œç¼–è¯‘å™¨ä¼šå¯¹ä¸€äº›å®æŒ‡ä»¤ï¼ˆé¢„ç¼–è¯‘æŒ‡ä»¤ï¼ŒåŒ…æ‹¬å¼•å…¥å¤´æ–‡ä»¶ä¹‹ç±»ï¼‰è¿›è¡Œæ›¿æ¢ã€‚ä»¥ä¸‹é¢çš„æºä»£ç ä¸ºä¾‹ï¼š1234567#include &lt;iostream&gt;#define number 10int main() &#123; std::cout &lt;&lt; number &lt;&lt; std::endl; return 0;&#125; åœ¨ç»ˆç«¯è¾“å…¥ï¼š1$ g++ -E test.cpp -o test.i ä½¿ç”¨-EæŒ‡ä»¤ï¼Œè®©ç¼–è¯‘å™¨ç”Ÿæˆé¢„å¤„ç†åŽçš„.iæ–‡ä»¶ã€‚æŽ¥ç€ç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€ test.i æ–‡ä»¶ï¼ˆwindows ä¸‹æ²¡æœ‰ tail è¿™æ ·ç›´æŽ¥æŸ¥çœ‹æ–‡ä»¶å°¾éƒ¨çš„å‘½ä»¤ðŸ˜‘ï¼‰ï¼Œç›´æŽ¥çœ‹æœ€ä¸‹é¢çš„éƒ¨åˆ†ï¼š12345int main() &#123; std::cout &lt;&lt; 10 &lt;&lt; std::endl; return 0;&#125; åŽŸå…ˆè®¾å®šçš„å®numberå·²ç»è¢«æ›¿æ¢ä¸º 10 äº†ï¼ŒåŒæ—¶å› ä¸ºå¼•å…¥äº†iostreamè¿™ä¸ªå¤´æ–‡ä»¶ï¼Œæ‰€ä»¥ä¸Šé¢è¿˜å¤šäº†ä¸¤ä¸‡å¤šè¡Œçš„ä»£ç ï¼Œå…¶å®žå°±æ˜¯æŠŠiostreamå¤´æ–‡ä»¶çš„å†…å®¹ç›´æŽ¥æ’å…¥åˆ°test.iè¿™ä¸ªæ–‡ä»¶å†…äº†ã€‚ ç¼–è¯‘é¢„å¤„ç†ä¹‹åŽï¼Œå¯ä»¥ç›´æŽ¥å¯¹test.iæ–‡ä»¶è¿›è¡Œç¼–è¯‘ï¼Œç”Ÿæˆæ±‡ç¼–ä»£ç ã€‚åœ¨ç»ˆç«¯è¾“å…¥ï¼š1$ g++ -S test.i -o test.s ä½¿ç”¨-SæŒ‡ä»¤ï¼Œè®©ç¼–è¯‘å™¨ç”Ÿæˆç¼–è¯‘åŽçš„.sæ–‡ä»¶ã€‚test.sæ‰“å¼€åŽå¯ä»¥å‘çŽ°æ˜¯ä¸€å †æ±‡ç¼–æŒ‡ä»¤ï¼Œä½†å†…å®¹ç›¸æ¯”test.iè¦å°‘äº†å¾ˆå¤šï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç¼–è¯‘å™¨åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­åˆåˆ é™¤æŽ‰äº†ä¸éœ€è¦çš„éƒ¨åˆ†ã€‚ æ±‡ç¼–æœ‰äº†æ±‡ç¼–ä»£ç åŽï¼Œå°±å¯ä»¥åˆ©ç”¨æ±‡ç¼–å™¨å°†æ±‡ç¼–ä»£ç ç¼–è¯‘ä¸ºäºŒè¿›åˆ¶æ–‡ä»¶äº†ï¼Œå¯¹äºŽ G++ è€Œè¨€ï¼Œæ±‡ç¼–å™¨åº”è¯¥å†…åµŒåˆ°äº† G++ ä¹‹ä¸­ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨ G++ å°±å¯ä»¥äº†ã€‚1$ g++ -c test.s -o test.o test.oæ–‡ä»¶æ‰“å¼€åŽå°±æ˜¯åå…­è¿›åˆ¶æ•°ï¼Œè¿™å°±æ˜¯ç”Ÿæˆçš„äºŒè¿›åˆ¶æ–‡ä»¶ã€‚ é“¾æŽ¥æœ€åŽï¼Œå†å°†äºŒè¿›åˆ¶æ–‡ä»¶ä¸Ž G++ çš„æ ‡å‡†åº“è¿›è¡Œé“¾æŽ¥ï¼Œç”Ÿæˆå¯æ‰§è¡Œç¨‹åºtest.exeå¹¶æ‰§è¡Œã€‚123$ g++ test.o -o test.exe$ test.exe10 æ‰§è¡Œtest.exeè¿™ä¸ªæ–‡ä»¶åŽï¼ŒCLI ç»™å‡ºçš„ç»“æžœæ˜¯ 10ï¼Œè¿™ä¸ªç»“æžœä¸Žæºç çš„å†…å®¹æ˜¯å»åˆçš„ã€‚ åˆ†ç¦»å¼ç¼–è¯‘ä¸Šè¿°å†…å®¹éƒ½æ˜¯åœ¨ä¸€ä¸ªæºæ–‡ä»¶å®Œæˆçš„ï¼Œä½†å®žé™…è¿‡ç¨‹ä¸­ï¼Œè‚¯å®šä¸å¯èƒ½åªæœ‰ä¸€ä¸ªæºæ–‡ä»¶ï¼Œè€Œè¿™äº›æºæ–‡ä»¶å¯èƒ½ä¼šå­˜åœ¨ç›¸äº’ä½¿ç”¨çš„æ–‡ä»¶ï¼Œæ‰€ä»¥å°±éœ€è¦ç¼–è¯‘å™¨æ”¯æŒåˆ†ç¦»å¼ç¼–è¯‘ï¼ˆseparate compilationï¼‰ã€‚ ç®€è€Œè¨€ä¹‹ï¼Œå°±æ˜¯åœ¨ç¼–è¯‘main.cppä¹‹å‰ï¼Œå…ˆå°†è¦ä½¿ç”¨çš„å…¶ä»–æºæ–‡ä»¶ç¼–è¯‘å®Œæˆï¼Œå†è¿›è¡Œmain.cppçš„ç¼–è¯‘ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ç¼–è¯‘ä¸€ä¸ªæºæ–‡ä»¶ä¹‹å‰è¦ç¡®ä¿å®ƒçš„â€œä¾èµ–â€å·²ç»ç¼–è¯‘å®Œæˆã€‚ä»¥ä¸‹é¢ 3 ä¸ªæ–‡ä»¶ä¸ºä¾‹ï¼šfunc.h12#pragma oncevoid func(); func.cpp1234#include &lt;iostream&gt;void func() &#123; std::cout &lt;&lt; "hello world!" &lt;&lt; std::endl;&#125; main.cpp1234567#include &lt;iostream&gt;#include "func.h"int main() &#123; func(); return 0;&#125; CLI ç¼–è¯‘è¿‡ç¨‹ä¾æ¬¡æ˜¯ï¼š12345$ g++ -c func.cpp$ g++ -c main.cpp$ g++ func.o main.o -o main.exe$ main.exehello world! è¿™æ ·å°±ç®—æ˜¯ç¼–è¯‘å®Œæˆäº†ã€‚ æ€»ç»“è¿™ç¯‡æ–‡ç« ï¼Œåªæ˜¯ç®€å•è®°å½•äº†ä¸€ä¸‹ç¼–è¯‘å™¨çš„å·¥ä½œè¿‡ç¨‹å’Œä½¿ç”¨æ–¹æ³•ï¼Œä¸è‡³äºŽåœ¨æ²¡æœ‰ IDE çš„æ—¶å€™æœ›æ´‹å…´å¹ã€‚å®žé™…ä¸Šï¼Œè¿™é‡Œå¹¶æ²¡æœ‰æ·±å…¥æŽ¢è®¨ç±»ã€å‡½æ•°ã€å®¹å™¨ç­‰å¤æ‚ç»“æž„çš„ç¼–è¯‘è¿‡ç¨‹ï¼Œè¿™äº›é—®é¢˜åˆéƒ½åŒ…å«äº†å¾ˆå¤šå…¶ä»–çš„é—®é¢˜ï¼Œç•™ä½œä¸‹æ¬¡æŽ¢è®¨äº†ã€‚]]></content>
      <categories>
        <category>Tools</category>
        <category>GCC/G++</category>
      </categories>
      <tags>
        <tag>G++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_è •è™«ç—…æ¯’]]></title>
    <url>%2F2022%2F11%2F18%2FVBS-%E8%A0%95%E8%99%AB%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[è¿™å‡ å¤©çœ‹äº†å¾ˆå¤šè·Ÿ VBS ç›¸å…³çš„èµ„æ–™... èµ·å› è™½ç„¶çœ‹äº†å¾ˆå¤šèµ„æ–™ï¼Œä½†æ˜¯æ²¡åšå‡ºä»€ä¹ˆä¸œè¥¿æ¥ï¼Œæ„Ÿè§‰å¥½åƒä¹Ÿæ²¡æ”¶èŽ·ä»€ä¹ˆä¸œè¥¿ã€‚å¶ç„¶æƒ³åˆ°åŽŸæ¥åœ¨å­¦æ ¡æ‰“å°åº—æ’ U ç›˜æ‰“å°æ–‡ä»¶åŽï¼ŒU ç›˜æ€»æ˜¯ä¼šæ„ŸæŸ“è •è™«ç—…æ¯’ã€‚ç¢ç£¨äº†ä¸€ä¸‹ï¼Œå¥½åƒè¿™ç§ç®€å•çš„ç—…æ¯’å°±æ˜¯ VBS æ¥åšçš„ï¼Ÿ ç—…æ¯’çš„ç‰¹å¾å°è±¡ä¸­ï¼Œè¿™ç§è •è™«ç—…æ¯’ä¼šæŠŠ U ç›˜å†…çš„æ–‡ä»¶å…¨éƒ¨éšè—ï¼Œå¹¶ç”Ÿæˆä¸€ä¸ªæŒ‡å‘éšè—æ–‡ä»¶çš„å¿«æ·æ–¹å¼ã€‚æ‰€ä»¥ï¼Œè¿™ç§ç—…æ¯’å¹¶ä¸ä¼šæŸåæ–‡ä»¶ï¼Œæ²¡æœ‰ä»€ä¹ˆç ´åæ€§ã€‚ä½†æ˜¯å¯¹äºŽä¸ç†Ÿæ‚‰ windows æ“ä½œç³»ç»Ÿçš„äººï¼Œå¤šåŠä¼šè®¤ä¸ºè‡ªå·±çš„æ–‡ä»¶å·²ç»ä¸¢å¤±äº†ã€‚çŽ°åœ¨å›žå¤´æƒ³æƒ³ï¼Œè¿™ä¸ªç—…æ¯’å€’åƒæ˜¯å“ªä¸ªé¡½çš®çš„åŒå­¦åœ¨å­¦æ ¡æœºæˆ¿ä¼ æ’­çš„æ¶ä½œå‰§ðŸ˜‚ã€‚ ç—…æ¯’çš„æœ¬è´¨è¿™ç§è •è™«ç—…æ¯’çš„æœ¬è´¨å°±æ˜¯è„šæœ¬ç¨‹åºï¼Œä¹Ÿå°±æ˜¯è®©è®¡ç®—æœºåˆ©ç”¨ç”¨æˆ·çš„æƒé™åšä¸€äº›æŸåç”¨æˆ·è‡ªèº«æ–‡ä»¶çš„äº‹æƒ…ã€‚æ‰§è¡Œä¸åŒçš„è„šæœ¬ç¨‹åºéœ€è¦ä¸åŒçš„è„šæœ¬è§£é‡Šå™¨ï¼Œå¦‚æžœè¦è®©ç—…æ¯’å¿«é€Ÿä¼ æ’­ï¼Œä¸€å®šè¦é€‰ä¸€ä¸ªç”¨é€”æ¯”è¾ƒå¹¿çš„è„šæœ¬è§£é‡Šå™¨ã€‚æ˜¾ç„¶ï¼ŒVBS è„šæœ¬è§£é‡Šå™¨æ˜¯æœ€å¥½çš„é€‰æ‹©ã€‚å› ä¸ºåªè¦æ˜¯å¾®è½¯çš„æ“ä½œç³»ç»Ÿï¼Œé‚£ä¹ˆä¸€å®šè‡ªå¸¦ VBS è„šæœ¬è§£é‡Šå™¨ã€‚æ‰€ä»¥åœ¨ä¸éœ€è¦é¢å¤–å®‰è£…çš„æƒ…å†µä¸‹ï¼Œç—…æ¯’å¯ä»¥ç›´æŽ¥è¿è¡Œã€‚ å¦‚ä½•å®žçŽ°å…ˆåˆ†è§£ä¸€ä¸‹è¦å®žçŽ°çš„åŠŸèƒ½ï¼š æ‰¾åˆ°å½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼ŒåŒ…æ‹¬ç›®å½•å’Œæ–‡ä»¶ã€‚ åˆ›å»ºæŒ‡å‘å½“å‰æ–‡ä»¶æˆ–ç›®å½•çš„å¿«æ·æ–¹å¼ã€‚ å°†åŽŸæ–‡ä»¶éšè—ã€‚ èŽ·å–æ‰€æœ‰æ–‡ä»¶åœ¨ VBS ä¸­ï¼Œä¸Žæ–‡ä»¶çš„ç›¸å…³æ“ä½œéœ€è¦ç”¨åˆ°æ–‡ä»¶å¯¹è±¡æ¨¡åž‹FileSystemObjectã€‚è¿™ä¸ªæ–‡ä»¶å¯¹è±¡æ¨¡åž‹ä¸­å°è£…äº†è®¸å¤šä¸Žè®¿é—®æ–‡ä»¶ç›¸å…³çš„æ–¹æ³•ã€‚é¦–å…ˆï¼Œæˆ‘ä»¬åˆ›å»ºè¿™ä¸ªæ–‡ä»¶æ¨¡åž‹ï¼š123456789'è®¾ç½®å˜é‡å¿…é¡»è¦å£°æ˜Žæ‰èƒ½ä½¿ç”¨Option Explicit'å£°æ˜Ž 3 ä¸ªå˜é‡åˆ†åˆ«è¡¨ç¤ºæ–‡ä»¶å¯¹è±¡ã€æ–‡ä»¶å’Œå­ç›®å½•Dim Fso, Folders, SubFolders'åˆ›å»ºæ–‡ä»¶å¯¹è±¡Set Fso = CreateObject("Scripting.FileSystemObject")'èŽ·å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼Œ"." ä»£è¡¨å½“å‰ç›®å½•çš„è·¯å¾„'è¿™é‡Œ GetFolder è¿”å›žçš„æ˜¯ä¸€ä¸ª Folder å¯¹è±¡Set Folders = Fso.GetFolder(".") è®¾ç½® WshShell å¯¹è±¡å¦‚æžœè¯´å‰é¢æåˆ°çš„æ–‡ä»¶å¯¹è±¡æ˜¯ç”¨æ¥å¤„ç†ä¸Žæ–‡ä»¶ç›¸å…³æ“ä½œçš„ï¼Œé‚£ä¹ˆWshShellå°±æ˜¯ç”¨æ¥æ‰§è¡Œä¸€äº›ç³»ç»Ÿæ“ä½œçš„å¯¹è±¡ã€‚123'åˆ›å»º WshShell å¯¹è±¡ï¼Œç”¨äºŽåŽé¢åˆ›å»ºå¿«æ·æ–¹å¼Dim WshShellSet WshShell = WScript.CreateObject("WScript.Shell") åˆ›å»ºå¿«æ·æ–¹å¼å› ä¸º Folder å¯¹è±¡ä¸èƒ½ç›´æŽ¥éåŽ†ï¼Œæ‰€ä»¥ä¸ºäº†æŠŠåŠŸèƒ½åšçš„æ›´åŠ å®Œå–„ï¼ˆæ— è®ºæ˜¯ç›®å½•è¿˜æ˜¯æ–‡ä»¶ï¼Œå…¨éƒ¨éƒ½å˜æˆå¿«æ·æ–¹å¼å¹¶éšè—åŽŸæ–‡ä»¶ï¼‰ï¼Œéœ€è¦åˆ†åˆ«éåŽ†ã€‚åŒæ—¶ï¼Œå¦‚æžœå½“å‰ç›®å½•ä¸‹æ–‡ä»¶è¶…è¿‡ä¸€ä¸ªï¼Œä¹Ÿä¸èƒ½åªæ–°å»ºä¸€ä¸ªå¿«æ·æ–¹å¼ï¼Œæ‰€ä»¥éœ€è¦ç”Ÿæˆå¤šä¸ªå¿«æ·æ–¹å¼ï¼Œè¿™ä¸ªè¿‡ç¨‹å¯ä»¥ç”¨æ•°ç»„æ¥å®žçŽ°ï¼Œå¹¶ä¸”ç”±äºŽä¸çŸ¥é“å…·ä½“æœ‰å¤šå°‘ä¸ªæ–‡ä»¶ï¼Œè¿™ä¸ªæ•°ç»„å¿…é¡»æ˜¯å˜é•¿çš„ã€‚12345678910111213141516171819202122232425262728293031'å£°æ˜Žä¸€ä¸ªå˜é•¿æ•°ç»„ï¼Œå’Œå¯¹åº”çš„ä¸‹æ ‡Dim ShellLink()Dim indexindex = 0'ä¸ºæ–‡ä»¶è®¾ç½®å¿«æ·æ–¹å¼å¹¶éšè—åŽŸæ–‡ä»¶Dim Files, fileSet Files = Folders.FilesFor Each file In Files file.attributes = 2 'è®¾ç½®ä¸ºéšè— redim ShellLink(index) 'åˆ›å»ºå¿«æ·æ–¹å¼ï¼Œå¿«æ·æ–¹å¼é»˜è®¤æ”¾åœ¨å½“å‰ç›®å½•ä¸‹ï¼Œåç§°ä¸ŽåŽŸæ–‡ä»¶ä¸€è‡´ï¼ŒåŽç¼€ä¸º .lnk Set ShellLink(index) = WshShell.CreateShortcut(".\" &amp; file.Name &amp; ".lnk") ShellLink(index).TargetPath = file 'å¿«æ·æ–¹å¼çš„ç›®æ ‡è·¯å¾„ä¸ºåŽŸæ–‡ä»¶ ShellLink(index).IconLocation = file 'å¿«æ·æ–¹å¼çš„å›¾æ ‡ä¸ºåŽŸæ–‡ä»¶ ShellLink(index).Save 'ä¿å­˜å¿«æ·æ–¹å¼ index = index + 1 'ä¿å­˜å¿«æ·æ–¹å¼Next'ä¸ºç›®å½•è®¾ç½®å¿«æ·æ–¹å¼çš„è¿‡ç¨‹ç±»ä¼¼Dim SubFolders, folderSet SubFolders = Folders.SubFolders 'èŽ·å–å­ç›®å½•For Each folder In SubFolders folder.attributes = 2 redim ShellLink(index) Set ShellLink(index) = WshShell.CreateShortcut(".\" &amp; folder.Name &amp; ".lnk") ShellLink(index).TargetPath = folder ShellLink(index).IconLocation = folder ShellLink(index).Save index = index + 1Next ç»“è¯­åˆ°è¿™é‡Œï¼Œè •è™«ç—…æ¯’çš„å¤§è‡´åŠŸèƒ½å°±å®Œæˆäº†ã€‚ä½†ä¸¥æ ¼æ„ä¹‰ä¸Šè®²ï¼Œè¿™ç¯‡æ–‡ç« åšçš„ä¸œè¥¿åªèƒ½ç®—ä½œæ˜¯ä¸€ä¸ª VBS è„šæœ¬ï¼Œå› ä¸ºå®ƒå¹¶ä¸åƒå…·å¤‡ç—…æ¯’çš„ç ´åæ€§å’Œä¼ æ’­æ€§ï¼Œä¹Ÿä¸æƒ³è®¨è®ºå¦‚ä½•è¿™æ ·å¹²ðŸ˜‚ã€‚ä¸è¿‡ï¼Œä¸å¾—ä¸æ‰¿è®¤çš„æ˜¯ VBS è¿™ç±»è½»é‡çº§çš„è„šæœ¬è¯­è¨€ï¼Œç”¨æ¥å†™ä¸€äº›æé«˜å·¥ä½œæ•ˆçŽ‡çš„è„šæœ¬æ˜¯å¾ˆæ–¹ä¾¿çš„ï¼Œè¯­æ³•ç®€å•ï¼ŒåŠŸèƒ½é½å…¨ï¼Œä¸Šæ‰‹é€Ÿåº¦å¾ˆå¿«ã€‚å¦å¤–ï¼ŒçŽ°åœ¨ Web ç«¯ç”¨çš„éƒ½æ˜¯ JSï¼ŒVBS å¯èƒ½ä¹Ÿæ²¡æœ‰ä»€ä¹ˆç”¨æ­¦ä¹‹åœ°äº†ã€‚æœ€åŽè´´ä¸€ä¸‹æ•´ä½“æºç ï¼ˆå¯ä»¥ç›´æŽ¥ä¿å­˜ä¸º .vbs æ–‡ä»¶åœ¨æ–‡ä»¶å¤¹å†…è¿è¡Œï¼‰ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445&apos;è®¾ç½®å˜é‡å¿…é¡»è¦å£°æ˜Žæ‰èƒ½ä½¿ç”¨Option Explicit&apos;å£°æ˜Ž 3 ä¸ªå˜é‡åˆ†åˆ«è¡¨ç¤ºæ–‡ä»¶å¯¹è±¡ã€æ–‡ä»¶å’Œå­ç›®å½•Dim Fso, Folders&apos;åˆ›å»ºæ–‡ä»¶å¯¹è±¡Set Fso = CreateObject(&quot;Scripting.FileSystemObject&quot;)&apos;èŽ·å–å½“å‰ç›®å½•ä¸‹æ‰€æœ‰æ–‡ä»¶ï¼Œ&quot;.&quot; ä»£è¡¨å½“å‰ç›®å½•çš„è·¯å¾„&apos;è¿™é‡Œ GetFolder è¿”å›žçš„æ˜¯ä¸€ä¸ª Folder å¯¹è±¡Set Folders = Fso.GetFolder(&quot;.&quot;)&apos;åˆ›å»º WshShell å¯¹è±¡ï¼Œç”¨äºŽåŽé¢åˆ›å»ºå¿«æ·æ–¹å¼Dim WshShellSet WshShell = WScript.CreateObject(&quot;WScript.Shell&quot;)&apos;å£°æ˜Žä¸€ä¸ªå˜é•¿æ•°ç»„ï¼Œå’Œå¯¹åº”çš„ä¸‹æ ‡Dim ShellLink()Dim indexindex = 0&apos;ä¸ºæ–‡ä»¶è®¾ç½®å¿«æ·æ–¹å¼å¹¶éšè—åŽŸæ–‡ä»¶Dim Files, fileSet Files = Folders.FilesFor Each file In Files file.attributes = 0 &apos;è®¾ç½®ä¸ºéšè— redim ShellLink(index) &apos;åˆ›å»ºå¿«æ·æ–¹å¼ï¼Œå¿«æ·æ–¹å¼é»˜è®¤æ”¾åœ¨å½“å‰ç›®å½•ä¸‹ï¼Œåç§°ä¸ŽåŽŸæ–‡ä»¶ä¸€è‡´ï¼ŒåŽç¼€ä¸º .lnk Set ShellLink(index) = WshShell.CreateShortcut(&quot;.\&quot; &amp; file.Name &amp; &quot;.lnk&quot;) ShellLink(index).TargetPath = file &apos;å¿«æ·æ–¹å¼çš„ç›®æ ‡è·¯å¾„ä¸ºåŽŸæ–‡ä»¶ ShellLink(index).IconLocation = file &apos;å¿«æ·æ–¹å¼çš„å›¾æ ‡ä¸ºåŽŸæ–‡ä»¶ ShellLink(index).Save &apos;ä¿å­˜å¿«æ·æ–¹å¼ index = index + 1 &apos;ä¿å­˜å¿«æ·æ–¹å¼Next&apos;ä¸ºç›®å½•è®¾ç½®å¿«æ·æ–¹å¼çš„è¿‡ç¨‹ç±»ä¼¼Dim SubFolders, folderSet SubFolders = Folders.SubFolders &apos;èŽ·å–å­ç›®å½•For Each folder In SubFolders folder.attributes = 0 redim ShellLink(index) Set ShellLink(index) = WshShell.CreateShortcut(&quot;.\&quot; &amp; folder.Name &amp; &quot;.lnk&quot;) ShellLink(index).TargetPath = folder ShellLink(index).IconLocation = folder ShellLink(index).Save index = index + 1Next]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_ç®€å•å®žä¾‹]]></title>
    <url>%2F2022%2F11%2F15%2FVBS-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[è¿™ç¯‡æ–‡ç« æ¥è®°å½•ä¸€äº›ç”¨ vbscript ç¼–å†™çš„å®žä¾‹ã€‚ å¤§éƒ¨åˆ†å®žä¾‹æ˜¯å†…åµŒåœ¨ html ä¸­çš„è„šæœ¬ï¼Œå‰©ä½™æ˜¯ windows ä¸‹çš„è„šæœ¬ã€‚ æ˜¾ç¤ºæ—¥æœŸå’Œæ—¶é—´12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Today's date is " &amp; date()) document.write("&lt;br&gt;") document.write("The time is " &amp; time()) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- è¿è¡Œç»“æžœï¼šToday's date is 2022/11/15The time is 13:26:56 --&gt; ä¸Šé¢çš„ä»£ç ä¸­ï¼ŒåŒ…å«äº†ä¸¤ä¸ª vbs è‡ªå¸¦çš„å‡½æ•°ï¼šdate()å’Œtime()ï¼Œä¸€ä¸ªè¿”å›žæ—¥æœŸï¼Œä¸€ä¸ªè¿”å›žæ—¶é—´ã€‚ æ˜¾ç¤ºæ˜ŸæœŸ12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;p&gt;VBScripts' function &lt;b&gt;WeekdayName&lt;/b&gt; is used to get a weekday:&lt;/p&gt; &lt;script type="text/vbscript"&gt; document.write("&lt;p&gt;") document.write(weekdayname(1)) document.write("&lt;br&gt;") document.write(weekdayname(2)) document.write("&lt;/p&gt;&lt;p&gt;") document.write("Get the abbreviated name of a weekday:") document.write("&lt;br&gt;") document.write(weekdayname(1, true)) document.write("&lt;br&gt;") document.write(weekdayname(2, true)) document.write("&lt;/p&gt;&lt;p&gt;") document.write("Get the current weekday:") document.write("&lt;br&gt;") document.write(weekdayname(weekday(date))) document.write("&lt;br&gt;") document.write(weekdayname(weekday(date), true)) document.write("&lt;/p&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- è¿è¡Œç»“æžœï¼šVBScripts' function WeekdayName is used to get a weekday:æ˜ŸæœŸæ—¥æ˜ŸæœŸä¸€Get the abbreviated name of a weekday:å‘¨æ—¥å‘¨ä¸€Get the current weekday:æ˜ŸæœŸäºŒå‘¨äºŒ --&gt; æ³¨æ„weekdaynameå‡½æ•°çš„è¿”å›žä¼šæ ¹æ®æ˜¯å¦æä¾›ç¬¬äºŒä¸ªå‚æ•°è€Œå˜åŒ–ã€‚ æ˜¾ç¤ºæœˆä»½å’Œæ˜ŸæœŸ12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Today's day is " &amp; weekdayname(weekday(date))) document.write("&lt;br&gt;") document.write("The month is " &amp;monthName(month(date))) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- è¿è¡Œç»“æžœï¼šToday's day is æ˜ŸæœŸäºŒThe month is åä¸€æœˆ --&gt; è®¡ç®—æ—¥æœŸå·®12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;p&gt;Countdown to year 3000:&lt;/p&gt;&lt;p&gt;&lt;script type="text/vbscript"&gt;millennium=CDate("1/1/3000 00:00:00")document.write(millennium &amp; "&lt;br&gt;")document.write("It is " &amp; DateDiff("yyyy", Now(), millennium) &amp; " years to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("m", Now(), millennium) &amp; " months to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("d", Now(), millennium) &amp; " days to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("h", Now(), millennium) &amp; " hours to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("n", Now(), millennium) &amp; " minutes to year 3000!&lt;br&gt;")document.write("It is " &amp; DateDiff("s", Now(), millennium) &amp; " seconds to year 3000!&lt;br&gt;")&lt;/script&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šCountdown to year 3000:3000/1/1It is 978 years to year 3000!It is 11726 months to year 3000!It is 356889 days to year 3000!It is 8565322 hours to year 3000!It is 513919281 minutes to year 3000!It is 30835156829 seconds to year 3000!--&gt; cdateå‡½æ•°ç”¨æ¥ç”Ÿæˆä¸€ä¸ªæ—¥æœŸï¼Œå…¶ä¸­åŒ…å«æ—¥æœŸå’Œå…·ä½“æ—¶é—´ï¼›nowå‡½æ•°ç”¨æ¥è¿”å›žå½“å‰æ—¥æœŸå’Œæ—¶é—´ï¼›datediffå‡½æ•°ç”¨æ¥è®¡ç®—æ—¥æœŸå’Œæ—¶é—´ä¹‹å·®ã€‚ è®¡ç®—æ—¥æœŸä¹‹å’Œ123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write(DateAdd("d", 0, date())) document.write("&lt;br&gt;") document.write(DateAdd("d", 30, date())) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šTue Nov 15 00:00:00 UTC+0800 2022Thu Dec 15 00:00:00 UTC+0800 2022 --&gt; dateaddç”¨æ¥è®¡ç®—æ—¥æœŸä¹‹å’Œï¼Œç”¨æ³•ä¸Ždatediffç±»ä¼¼ã€‚ æŒ‰ç…§ä¸åŒæ ¼å¼è¾“å‡ºæ—¥æœŸ/æ—¶é—´123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write(formatdatetime(date(), vbgeneraldate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vblongdate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vbshortdate)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vblongtime)) document.write("&lt;br&gt;") document.write(formatdatetime(date(), vbshorttime)) &lt;/script&gt; &lt;p&gt;Syntax for formatdatetime: formatdatetime(date, nameformat).&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼š2022/11/152022å¹´11æœˆ15æ—¥2022/11/150:00:0000:00 Syntax for formatdatetime: formatdatetime(date, nameformat).--&gt; formatdatetimeå‡½æ•°å¯ä»¥æ ¹æ®ä¸åŒçš„æ ¼å¼è¾“å‡ºæ—¥æœŸï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸ºæ—¥æœŸï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸ºæ ¼å¼ç±»åž‹ã€‚ å¤§å°å†™è½¬æ¢1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Have a nice day!" document.write(txt &amp; "&lt;br&gt;") document.write(ucase(txt)) document.write("&lt;br&gt;") document.write(lcase(txt)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- Have a nice day!HAVE A NICE DAY!have a nice day! --&gt; ucaseå‡½æ•°è½¬æ¢ä¸ºå¤§å†™ï¼Œlcaseè½¬æ¢ä¸ºå°å†™ã€‚ åˆ é™¤å­—ç¬¦ä¸²ä¸¤ç«¯çš„ç©ºæ ¼1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; fname = " Bill " document.write("Hello" &amp; Trim(fname) &amp; "Gates&lt;br&gt;") document.write("Hello" &amp; RTrim(fname) &amp; "Gates&lt;br&gt;") document.write("Hello" &amp; LTrim(fname) &amp; "Gates&lt;br&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!-- HelloBillGatesHello BillGatesHelloBill Gates--&gt; Trimå‡½æ•°é»˜è®¤åˆ é™¤å­—ç¬¦ä¸²ä¸¤ç«¯çš„ç©ºæ ¼ï¼ŒRTrimé»˜è®¤åˆ é™¤å­—ç¬¦ä¸²å³ç«¯çš„ç©ºæ ¼ï¼ŒLTrimé»˜è®¤åˆ é™¤å­—ç¬¦ä¸²å·¦ç«¯çš„ç©ºæ ¼ã€‚PSï¼šdocument.writeåœ¨æ˜¾ç¤ºå­—ç¬¦ä¸²æ—¶ï¼Œå¼€å¤´ä¸æ˜¾ç¤ºï¼Œç»“å°¾é»˜è®¤åªæ˜¾ç¤ºä¸€ä¸ªã€‚ é€†ç½®å­—ç¬¦ä¸²12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Hello Everyone!" document.write(txt &amp; "&lt;br&gt;") document.write(strreverse(txt)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šHello Everyone!!enoyrevE olleH --&gt; è·Ÿ C++ ä¸­çš„ reverse å‡½æ•°ä¸€æ ·ï¼Œæ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚ å–æ•´å‡½æ•°1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = 48.66776677 j = 48.33333333 document.write(round(i)) document.write("&lt;br&gt;") document.write(round(j)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼š4948 --&gt; è·Ÿ C/C++ çš„roundå‡½æ•°åŠŸèƒ½ç±»ä¼¼ï¼Œé»˜è®¤å››èˆäº”å…¥ã€‚ è¿”å›žéšæœºæ•°12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; randomize() document.write(rnd()) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼š0.3182794451713562 --&gt; randomizeå‡½æ•°ç”¨äºŽäº§ç”Ÿéšæœºæ•°ç§å­ï¼Œrndå‡½æ•°ç”¨äºŽè¿”å›žä¸€ä¸ªéšæœºæ•°ï¼Œæ•°å­—æ€»æ˜¯å°äºŽ 1 ä¸”å¤§äºŽç­‰äºŽ 0ã€‚ äº§ç”Ÿ [0, 99] çš„éšæœºæ•°123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; randomize() random_number = int(100 * rnd()) document.write("A random number: &lt;b&gt;" &amp; random_number &amp; "&lt;/b&gt;") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šA random number: 37 --&gt; ä»Žå­—ç¬¦ä¸²çš„å·¦ä¾§æˆ–å³ä¾§è¿”å›žæŒ‡å®šæ•°ç›®çš„å­—ç¬¦1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to our web site!" document.write(left(txt, 5)) document.write("&lt;br&gt;") document.write(right(txt, 5)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šWelcosite! --&gt; æ›¿æ¢å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to this web!" document.write(txt &amp; "&lt;br&gt;") document.write(replace(txt, "web", "page")) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šWelcome to this web!Welcome to this page! --&gt; ä»Žä¸€æ®µå­—ç¬¦ä¸²æŒ‡å®šä½ç½®è¿”å›žæŒ‡å®šæ•°ç›®çš„å­—ç¬¦123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; txt = "Welcome to our web site!" document.write(txt &amp; "&lt;br&gt;") document.write(mid(txt, 9, 2)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;&lt;!--è¿è¡Œç»“æžœï¼šWelcome to our web site!to --&gt; æœ‰ç‚¹ç±»ä¼¼ C++ string ç±»çš„substrå‡½æ•°ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VBS_Basic]]></title>
    <url>%2F2022%2F11%2F14%2FVBS-basic%2F</url>
    <content type="text"><![CDATA[è®°å½•ä¸€äº›ä¸Ž VBS ç›¸å…³çš„ä¸œè¥¿ã€‚ ä»€ä¹ˆæ˜¯ VBSVBScript æ˜¯å¾®è½¯å‡ºå“çš„è„šæœ¬è¯­è¨€,æ˜¯ ASPï¼ˆActive Server Pagesï¼‰é»˜è®¤ä½¿ç”¨çš„è„šæœ¬è¯­è¨€ã€‚VBS æ˜¯ä¸€ä¸ªåŠ¨æ€è„šæœ¬è¯­è¨€ï¼Œä¹Ÿæ˜¯ VB çš„è½»é‡ç‰ˆæœ¬ï¼ŒIE ä½¿ç”¨ VBS çš„åœ°æ–¹æ¯”è¾ƒå¤šï¼ˆå¥½åƒåªæœ‰ IE æ”¯æŒäº†ðŸ˜‚ï¼‰ï¼Œè¿™åº”è¯¥ä¹Ÿæ˜¯ä»ŠåŽçš„å·¥ä½œå†…å®¹äº†ã€‚ VBS çš„ç¬¬ä¸€ä¸ªä¾‹å­Internet Explorer æ”¯æŒ VBScriptï¼Œæ‰€ä»¥å¯ä»¥åœ¨ IE æµè§ˆå™¨ä¸­æ‰§è¡Œ VBS è„šæœ¬ã€‚ æ³¨æ„ç”±äºŽæ–°ç‰ˆ IE ä¹Ÿå·²ç»ä¸å†æ”¯æŒ VBScript äº†ï¼Œæ‰€ä»¥è¦åœ¨å‰ç«¯æ‰§è¡Œ VBScript è„šæœ¬å°±å¿…é¡»ä½¿ç”¨è€ç‰ˆæœ¬çš„ IEï¼ˆðŸ˜“è¿™æŠ€æœ¯æ ˆä¹Ÿå¤ªè€äº†å§ï¼‰ã€‚æ¯”å¦‚ï¼š12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; document.write("Hello World!") &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ä»¥ä¸Šé¢è¿™æ®µä»£ç ä¸ºä¾‹ï¼Œç¼–è¾‘ä¿å­˜ä¸º HTML æ–‡ä»¶ï¼Œå†ç”¨ IE æ‰“å¼€æ— æ³•ç›´æŽ¥æ˜¾ç¤ºï¼Œéœ€è¦æ‰“å¼€ IE çš„å¼€å‘è€…æ¨¡å¼ï¼Œå°†æ–‡æ¡£æ¨¡å¼æ”¹ä¸ºå°äºŽ 10 æ‰èƒ½æ˜¾ç¤º...æ¢å¥è¯è¯´ï¼Œæœ€æ–°çš„ IE11 å·²ç»ä¸æ”¯æŒ VBScript äº†ï¼ŒIE10 åŠä»¥ä¸‹ç‰ˆæœ¬æ‰èƒ½æ­£å¸¸æ˜¾ç¤º...è¿™ä¸ªçœŸçš„å¤ªè€äº†å§ï¼Œæˆ‘æ€Žä¹ˆæ„Ÿè§‰æˆ‘åœ¨ç»™åœ°çº§å¸‚ã€åŽ¿çº§å¸‚çš„é“¶è¡Œ ATM æœºå†™ä»£ç ...æ‰¯è¿œäº†... å¦‚ä½•ä½¿ç”¨ VBSè¯è¯´å›žæ¥ï¼Œçœ‹æ¥ç”¨åˆ° VBS çš„åœºæ™¯ä¸»è¦å°±æ˜¯åœ¨ IE æµè§ˆå™¨ä¸Šå°±ä¸€äº›ä¸Žç”¨æˆ·äº¤äº’çš„äº‹æƒ…äº†ï¼Ÿä¹Ÿå°±æ˜¯è¯´ï¼Œå®žé™…ä¸Šå°±æ˜¯å¾€ç½‘é¡µé‡Œé¢å†™è„šæœ¬ðŸ¤£ï¼Œç”¨çš„è¿˜ä¸æ˜¯ JavaScript è¿™ç§ç”¨çš„å¤šçš„è„šæœ¬è¯­è¨€ï¼Œç”¨çš„è¿˜æ˜¯ VBS è¿™ç§... åœ¨ HTML ä¸­ï¼Œ&lt;script&gt;ç”¨æ¥å‘ HTML ä¸­æ’å…¥ VBScriptã€‚æ¢å¥è¯è¯´ï¼Œå†™å¥½çš„ VBS è„šæœ¬å¿…é¡»å†™åœ¨&lt;script&gt;å’Œ&lt;/script&gt;ï¼Œå¹¶ä¸”éœ€è¦ä½¿ç”¨typeå±žæ€§æ¥å®šä¹‰è„šæœ¬è¯­è¨€çš„ç±»åž‹ä¸ºtext/vbscriptã€‚å¦å¤–ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œvbscript æ˜¯ä¸åŒºåˆ†å¤§å°å†™çš„ï¼Œæ˜¯å¦éœ€è¦å¤§å°å†™è¦æŒ‰ç…§å·¥ä½œè¦æ±‚æ¥å®šã€‚ VBS è¾“å‡ºå½“ VBScript è¢«ç”¨åœ¨ Web æœåŠ¡å™¨ä¸Šçš„ ASP é¡µé¢æ—¶ï¼Œè¯­å¥response.write()äº§ç”Ÿè¾“å‡ºï¼›å½“ä½¿ç”¨ IE æ¥æµ‹è¯•æ—¶ï¼Œè¯­å¥document.write()æ¥äº§ç”Ÿè¾“å‡ºï¼ˆè¿™ç‚¹å¥½åƒä¸Ž JavaScript æ˜¯ç±»ä¼¼çš„ï¼‰ã€‚ä¸åŒç±»åž‹çš„å˜é‡åœ¨è¾“å‡ºæ—¶éœ€è¦ç”¨åˆ°&amp;å’Œ&quot;&quot;ç¬¦å·ï¼Œæ¯”å¦‚ï¼š123Dim namename="xxx"document.write("My name is:"&amp;name) ç®€è€Œè¨€ä¹‹ï¼Œå­—ç¬¦ä¸²éœ€è¦ç”¨&quot;&quot;æ‹¬èµ·æ¥ï¼Œ&amp;ç”¨æ¥è¿žæŽ¥ä¸¤ä¸ªä¸åŒçš„å˜é‡ã€‚ VBS å˜é‡VBScript ä½¿ç”¨Dimå…³é”®å­—æ¥å£°æ˜Žï¼ˆåˆ›å»ºï¼‰ä¸€ä¸ªå˜é‡ï¼Œæ³¨æ„å¤§å°å†™ï¼Œæ¯”å¦‚ï¼š123Dim xDim carnamecarname="Volvo" æœ‰æ—¶å¯èƒ½ä¼šå†™é”™å˜é‡çš„åå­—ï¼Œå¦‚carnameå†™æˆcarnimeï¼Œæ­¤æ—¶è„šæœ¬ä¼šè‡ªåŠ¨åˆ›å»ºä¸€ä¸ªcarnimeçš„å˜é‡ã€‚ä¸ºäº†é¿å…ä¸å¿…è¦çš„é”™è¯¯ï¼Œå¯ä»¥åœ¨è„šæœ¬çš„é¡¶ç«¯å†™ä¸Šï¼šOption Explicitï¼Œæ¯”å¦‚ï¼š123Option ExplicitDim carnamecarname=value è¿™æ ·è„šæœ¬å°±åªèƒ½ä½¿ç”¨å£°æ˜ŽåŽçš„å˜é‡äº†ã€‚Dimå£°æ˜Žçš„å˜é‡æ—¢å¯ä»¥èµ‹æ•°å­—ï¼Œä¹Ÿå¯ä»¥èµ‹ä¸ºå­—ç¬¦ä¸²ã€‚ VBS æ•°ç»„ç”¨æ³•ç±»ä¼¼ C è¯­è¨€ï¼Œå¦‚ä¸‹ï¼š12345Dim names(2)names(0)="Tove"names(1)="Jani"names(2)="Stale"mother=names(0) æ³¨æ„ä¸Ž C è¯­è¨€å·®å¼‚çš„åœ°æ–¹åœ¨äºŽï¼ŒDim names(2)ä¸­çš„æ•°å­—ä¸º 2ï¼Œè¡¨ç¤ºæ•°ç»„çš„ä¸‹æ ‡ä»Ž 0 å¼€å§‹ï¼Œå› æ­¤è¯¥æ•°ç»„åŒ…å« 3 ä¸ªå…ƒç´ ã€‚å¤šç»´æ•°ç»„çš„å£°æ˜Žæ–¹æ³•ä¹Ÿæ˜¯ç±»ä¼¼çš„ï¼Œæ¯”å¦‚å£°æ˜Žä¸€ä¸ª 5 è¡Œ 7 åˆ—çš„å¤šç»´æ•°ç»„ï¼š1Dim table(4, 6) å†çœ‹ä¸‹é¢å¤šç»´æ•°ç»„çš„å®žä¾‹ï¼š1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;body&gt; &lt;script type="text/vbscript"&gt; Dim x(2,2) x(0,0)="Volvo" x(0,1)="BMW" x(0,2)="Ford" x(1,0)="Apple" x(1,1)="Orange" x(1,2)="Banana" x(2,0)="Coke" x(2,1)="Pepsi" x(2,2)="Sprite" for i=0 to 2 document.write("&lt;p&gt;") for j=0 to 2 document.write(x(i,j) &amp; "&lt;br&gt;") next document.write("&lt;/p&gt;") next &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; VBS ç¨‹åºVBScript å¯ä½¿ç”¨ä¸¤ç§ç¨‹åºï¼šå­ç¨‹åºå’Œå‡½æ•°ã€‚ å­ç¨‹åºVBScript ä¸­çš„å­ç¨‹åºæ˜¯ä¸€ç³»åˆ—è¯­å¥ï¼Œè¢«å°è£…åœ¨Subå’ŒEnd Subè¯­å¥å†…ï¼Œå¯ä»¥æ‰§è¡ŒæŸäº›æ“ä½œï¼Œä½†æ˜¯ä¸ä¼šè¿”å›žå€¼ï¼Œå¹¶ä¸”å¯ä»¥å¸¦æœ‰å‚æ•°ã€‚æ¯”å¦‚ï¼š123Sub mysub()some statementsEnd Sub æˆ–è€…123Sub mysub(argument1, argument2)some statementsEnd Sub å‡½æ•°VBScript ä¸­çš„å‡½æ•°ä¸Ž C/C++ ä¸­çš„å‡½æ•°ç±»ä¼¼ï¼Œæ‰§è¡Œä¸€ç³»åˆ—æ“ä½œå¹¶è¿”å›žç»“æžœï¼Œå†™æ³•ä¸Žå­ç¨‹åºç±»ä¼¼ï¼Œå°†å‡½æ•°ä½“å°è£…åœ¨Functionå’ŒEnd Functionä¹‹ä¸­å°±å¯ä»¥äº†ã€‚å¯ä»¥å‚è€ƒä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; Function myfunction(a, b) myfunction = a + b End Function document.write(myfunction(5, 9)) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; VBS æ¡ä»¶ä¸Žå…¶ä»–ç¨‹åºè¯­è¨€ç±»ä¼¼ï¼ŒVBScript ä½¿ç”¨Ifã€Thenã€Elseã€ElseIfå’ŒSelect Caseæ¥ä½œä¸ºæ¡ä»¶æŽ§åˆ¶è¯­å¥ï¼Œç”¨æ³•ä¹Ÿæ˜¯ä¸Žå…¶ä»–è¯­è¨€ç±»ä¼¼çš„ï¼Œç›´æŽ¥çœ‹ 3 ä¸ªä¾‹å­ã€‚ç¬¬ä¸€ä¸ªï¼š12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;script type="text/vbscript"&gt; i = hour(time) If i &lt; 10 Then document.write("Good Morning!") Else document.write("Have a nice day!") End If&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œhouræ˜¯ vbscript è‡ªå¸¦çš„å‡½æ•°ï¼Œè¿”å›žä¸€å¤©ä¸­å½“å‰çš„å°æ—¶æ•°ï¼ˆ0 - 23ï¼‰ã€‚ä¸Ž C/C++ æœ‰å·®åˆ«çš„åœ°æ–¹åœ¨äºŽæ¡ä»¶è¯­å¥éœ€è¦ç”¨End Ifæ¥è¡¨ç¤ºç»“æŸã€‚ç¬¬äºŒä¸ªï¼š12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = hour(time) if i = 9 then document.write("Just started...!") elseif i = 11 then document.write("Hungry!") elseif i = 12 then document.write("Ah, lunch-time!") elseif i = 17 then document.write("Time to go home!") else document.write("Unknow") end if &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ç¬¬ä¸‰ä¸ªï¼š12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; d = weekday(Date) document.write(d &amp; "&lt;br&gt;") select case d case 1 document.write("Sleepy Sunday") case 2 document.write("Monday again!") case 3 document.write("Just Tuesday!") case 4 document.write("Wednesday!") case 5 document.write("Thursday...") case 6 document.write("Finally Friday!") case else document.write("Super Saturday!!!") end select &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; ç›¸æ¯” C/C++ ä¸­çš„switchï¼Œè¿™é‡Œä¸ç”¨å†™å¾ˆå¤šbreakæ˜¯ä¸€ä»¶å¾ˆä¸é”™çš„äº‹æƒ…ã€‚ä¸è¿‡è¯´å¥é¢˜å¤–è¯ï¼Œä¸ºä»€ä¹ˆå‘¨äºŒçš„æ•°å­—è¦è®¾ç½®æˆ 3 ï¼Ÿ VBS å¾ªçŽ¯åœ¨ VBS ä¸­ï¼Œå¯ä»¥ä½¿ç”¨å››ç§å¾ªçŽ¯ï¼šFor...Nextã€For Each...Nextã€Do...Loopå’ŒWhile...Wendã€‚ Forâ€¦NextForè¯­å¥è§„å®šè®¡æ•°å˜é‡iä»¥åŠå®ƒçš„åˆå§‹å€¼å’Œç»“æŸå€¼ï¼ŒNextè¯­å¥ä¼šä»¥ 1 ä½œä¸ºæ­¥è¿›å€¼æ¥é€’å¢žå˜é‡iã€‚æ¯”å¦‚ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 0 to 5 document.write("The number is " &amp; i &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; è¿è¡Œç»“æžœï¼š123456The number is 0The number is 1The number is 2The number is 3The number is 4The number is 5 çœ‹æ¥ï¼Œ0 to 5æ˜¯ä»Ž 0 åˆ° 5ï¼Œå¾—è¿è¡Œ 6 æ¬¡ã€‚å¦‚æžœä¸ºäº†åœ¨ä¸æ”¹å˜è¾¹ç•Œæ¡ä»¶çš„æƒ…å†µä¸‹ï¼Œå‡å°‘å¾ªçŽ¯æ¬¡æ•°ï¼Œå¯ä»¥ä½¿ç”¨Stepå…³é”®å­—æ¥å®Œæˆï¼Œçœ‹ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š12345678910&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 0 to 5 step 2 document.write("The number is " &amp; i &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; è¿è¡Œç»“æžœï¼š123The number is 0The number is 2The number is 4 å¯¹åº”çš„ï¼Œå½“StepåŽçš„æ•°å­—ä¸ºå¤æ•°æ—¶ï¼Œå°±å¯ä»¥ä½¿å¾ªçŽ¯å˜é‡é€’å‡äº†ã€‚å¦‚æžœæœ‰æ—¶å€™è¦åœ¨å¾ªçŽ¯è¿è¡Œåˆ°ä¸€å®šç¨‹åº¦çš„æ—¶å€™é€€å‡ºå¾ªçŽ¯å‘¢ï¼Ÿæ­¤æ—¶å¯ä»¥ä½¿ç”¨Exit Forå…³é”®å­—ï¼Œæ¯”å¦‚ï¼š1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; for i = 1 to 10 document.write("The number is " &amp; i &amp; "&lt;br&gt;") if i = 5 then exit for next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; è¿è¡Œç»“æžœï¼š12345The number is 1The number is 2The number is 3The number is 4The number is 5 For Eachâ€¦NextFor Each...Nexté’ˆå¯¹é›†åˆä¸­çš„æ¯ä¸ªé¡¹ç›®æˆ–è€…æ•°ç»„ä¸­çš„æ¯ä¸ªå…ƒç´ æ¥é‡å¤è¿è¡ŒæŸæ®µä»£ç ï¼Œç›´æŽ¥çœ‹ä¸‹é¢è¿™ä¸ªä¾‹å­ï¼š1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; dim cars(2) cars(0) = "Volvo" cars(1) = "Saab" cars(2) = "BMW" for each x in cars document.write(x &amp; "&lt;br&gt;") next &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Doâ€¦Loopç±»ä¼¼ C è¯­è¨€çš„do-whileï¼Œç›´æŽ¥çœ‹ä¾‹å­ï¼š123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;body&gt; &lt;script type="text/vbscript"&gt; i = 0 do while i &lt; 10 document.write(i &amp; "&lt;br&gt;") i = i + 1 loop &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; è¿è¡Œç»“æžœï¼š123456789100123456789 æ€»ç»“åˆ°è¿™é‡Œä¸ºæ­¢ï¼Œä¸Ž VBScript ç›¸å…³çš„åŸºç¡€å†…å®¹å­¦ä¹ å°±ç®—æ˜¯å®Œæˆäº†ã€‚æŽ¥ä¸‹æ¥è¦åšçš„äº‹æƒ…ï¼Œæ˜¯åšä¸€äº› VBS å®žä¾‹ï¼Œå­¦ä¹ ä¸€ä¸‹ VBS çš„å†…å»ºå‡½æ•°ï¼ˆå¯èƒ½å°±æ˜¯ä»¥åŽçš„ç”Ÿäº§åŠ›å·¥å…·ï¼‰ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>VBS</category>
      </categories>
      <tags>
        <tag>VBS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2022_10_æœˆæ€»ç»“]]></title>
    <url>%2F2022%2F11%2F11%2F2022-10-%E6%9C%88%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[ä¸çŸ¥ä¸è§‰ï¼Œæ¥ä¸Šæµ·ä¸€ä¸ªæœˆäº†... æ˜¯å¦ - å´”å¥Your browser does not support the audio tag. çªç„¶å¾ˆæƒ³å¬è¿™é¦–æ­Œ... 10 æœˆ 11 æ—¥æ¥çš„ä¸Šæµ·ï¼Œä¾ç¨€è®°å¾—è‡ªå·±æ‹–ç€è¡ŒæŽç®±ï¼ŒèƒŒç€å‰ä»–å’Œç”µè„‘åŒ…ï¼Œæ¥åˆ°è¿™ä¸ªé™Œç”ŸåŸŽå¸‚çš„åœºæ™¯ï¼šä»Žè¿™å¤©æ—©ä¸Šç¦»å¼€å®¶é—¨ï¼Œå´æ²¡æœ‰ååˆ°æœ€æ—©ä¸€ç­è½¦ï¼Œåªå¥½ç­‰ä¸‹ä¸€ç­ï¼Œç»“æžœå´ç¢°åˆ°äº†å‡†å¤‡å›žé‡åº†å®¶ä¹¡çš„å¤§å”ï¼›åˆ°è¾¾æ­¦æ±‰ï¼Œåˆåœ¨æ±‰å£ç«è½¦ç«™è§’è½çš„å¿«é¤åº—åƒäº†åˆé¥­åŽï¼Œè¸ä¸Šäº†å¥”èµ´ä¸Šæµ·çš„åŠ¨è½¦ï¼›ä¹‹åŽè·¯è¿‡æ±Ÿè¥¿ã€å—äº¬ã€æ‰¬å·žã€æ­å·žç­‰åŸŽå¸‚åŽï¼Œæœ€åŽåˆ°äº†ä¸Šæµ·ï¼Œåˆè·Ÿç€äº²çˆ±çš„æœ‹å‹å° z åä¸Šåœ°é“ï¼Œæ…¢æ…¢å›žåˆ°äº†ä»–çš„å®¶ã€‚ è¿™ä¸€ä¸ªæœˆæ¥ï¼Œè‡ªå·±çš„å¿ƒæ€å…¶å®žæ²¡æœ‰ä»€ä¹ˆå¤ªå¤§çš„å˜åŒ–ã€‚å› ä¸ºå¾ˆå¤šé—®é¢˜ï¼Œè‡ªå·±è¿™å‡ å¹´å·²ç»æƒ³çš„å¾ˆæ¸…æ¥šäº†ã€‚åªæ˜¯è‡ªå·±ä¸æ„¿æ„é‚£æ ·åšè€Œå·²ï¼Œä¸ºä»€ä¹ˆä¼šè¿™æ ·ï¼Ÿå› ä¸ºè‡ªå·±æ˜¯äººï¼Œä¼šå—è¿™æ ·æˆ–é‚£æ ·çš„æƒ…ç»ªå·¦å³ï¼Œä¼šå˜å¾—ä¸å†ç›¸ä¿¡ä¸€äº›äº‹æƒ…ï¼Œä»Žè€Œå¤±åŽ»æ”¯æ’‘è‡ªå·±çš„â€œæŸ±å­â€ã€‚çŽ°åœ¨çœ‹æ¥ï¼Œèƒ½æ€è€ƒçš„äººä½œä¸ºä¸€ä¸ªç‹¬ç«‹çš„ä¸ªä½“ï¼Œæœ¬èº«å°±ä¸åº”è¯¥å°†è‡ªå·±çš„å­˜åœ¨ä¾é åœ¨é‚£äº›â€œæŸ±å­â€ä¸Šã€‚ æ‰¯è¿œäº†... å›žè¿‡å¤´æ¥ï¼Œè¿™ä¸ªæœˆè‡ªå·±èµ°è¿‡äº†ä¸€äº›ä¸Šæµ·çš„è¡—é“ï¼Œæ„Ÿå—äº†ä¸€ä¸‹å›½é™…åŒ–å¤§éƒ½å¸‚çš„é­…åŠ›ï¼Œå°½ç®¡è¿™äº›å¹¶æœªåœ¨è‡ªå·±çš„å¿ƒä¸­æƒŠèµ·ä»»ä½•çš„æ¶Ÿæ¼ªï¼Œå¤§æ¦‚è‡ªå·±å”¯ä¸€èƒ½ç¡®å®šçš„å°±æ˜¯è‡ªå·±éƒ½è¿™äº›ä¸œè¥¿å·²ç»å­˜åœ¨äº†ä¸€å®šçš„å…ç–«åŠ›äº†ã€‚ä»Žè‡ªå·±è¸ä¸Šç¦»å®¶çš„è½¦æ—¶ï¼Œè‡ªå·±çš„ç›®çš„å°±æ˜¯æ¥å·¥ä½œçš„ã€‚è¿™ä¸€ä¸ªæœˆæ¥ï¼Œè‡ªå·±ä¹Ÿæ˜¯æŒ‰ç…§è¿™ä¸ªç›®çš„æ¥è¿›è¡Œçš„ã€‚è™½ç„¶æ±‚èŒè¿‡ç¨‹æœ‰ç‚¹å¿ƒç´¯ï¼Œä½†æœ€ç»ˆç»“æžœè‡ªå·±æ˜¯æ»¡æ„çš„ï¼Œæ‰€ä»¥è§‰å¾—è‡ªå·±å¯èƒ½è½¬äº†ä¸€ç‚¹è¿äº†å§ï¼Ÿ å¦å¤–ï¼Œä¸å¾—ä¸æ„Ÿè°¢å° z ç»™æˆ‘çš„å¸®åŠ©ï¼Œç»™äº†æˆ‘å¾ˆå¤šæœ‰ç”¨çš„å»ºè®®ï¼Œè¿˜å¸®æˆ‘ä¿®æ”¹äº†å¤šæ¬¡ç®€åŽ†... çŽ°åœ¨å·¥ä½œå·²ç»æ‰¾åˆ°äº†ï¼ŒæŽ¥ä¸‹æ¥è¦åšçš„äº‹æƒ…å°±æ˜¯å¥½å¥½å·¥ä½œäº†ã€‚ðŸ˜‚ å…·ä½“å¦‚ä½•ï¼Œä¸‹ä¸ªæœˆå†è§å§~ ç¿»äº†ç¿»æ‰‹æœºç›¸å†Œï¼Œå°±ç•™ä¸€å¼ ä¸Šæµ·å¤–æ»©çš„å¤œæ™¯ç…§ç‰‡å§~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_set å®¹å™¨çš„å¸¸è§ç”¨æ³•]]></title>
    <url>%2F2022%2F11%2F01%2FC-set-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å¥½ä¹…æ²¡æœ‰æ°´æ–‡äº†ï¼Œè¿™æ¬¡æ¢³ç†ä¸€ä¸‹ set çš„ç”¨æ³•ã€‚ set çš„ç¿»è¯‘å°±æ˜¯é›†åˆï¼Œä½†æ˜¯ä¸Žæ•°å­¦ä¸Šé›†åˆä¸åŒçš„æ˜¯ set æ˜¯ä¸€ä¸ªå†…éƒ¨è‡ªåŠ¨æœ‰åºä¸”ä¸å«é‡å¤å…ƒç´ çš„å®¹å™¨ã€‚å› ä¸ºè¿™ä¸ªç‰¹ç‚¹ï¼Œset åœ¨æŸäº›åœºæ™¯ä¸‹èƒ½å¾ˆæ–¹ä¾¿çš„è§£å†³ä¸€äº›é—®é¢˜ã€‚ ä½¿ç”¨ set ä¹‹å‰ï¼Œéœ€è¦å…ˆå¼•å…¥ set å¤´æ–‡ä»¶ã€‚å¦å¤–ï¼Œset çš„åº•å±‚å¥½åƒæ˜¯ç”¨çº¢é»‘æ ‘æ¥å®žçŽ°çš„ï¼Ÿ åˆå§‹åŒ–set çš„åˆå§‹åŒ–ä¸Ž vector å’Œå…¶ä»– STL å®¹å™¨ç±»ä¼¼ï¼ˆå¯ä»¥çœ‹ä¸‹ set æä¾›çš„æž„é€ å‡½æ•°ï¼‰ï¼š1234set&lt;int&gt; s1;set&lt;double&gt; s2;set&lt;char&gt; s3;set&lt;int&gt; s4[100] // s4 å¤§å°ä¸º 100ï¼Œå†…éƒ¨æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯ä¸€ä¸ª set è®¿é—®set åªèƒ½é€šè¿‡è¿­ä»£å™¨ï¼ˆiteratorï¼‰è®¿é—®ï¼š123set&lt;int&gt;::iterator it;set&lt;double&gt;::iterator it;set&lt;char&gt;::iterator it; set çš„è¿­ä»£å™¨åªèƒ½é€šè¿‡è‡ªå¢žï¼ˆå‡ï¼‰è¿ç®—ç¬¦æ¥æ”¹å˜ï¼š12345678910111213141516171819#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;int main() &#123; set&lt;int&gt; st; st.insert(1); st.insert(2); st.insert(3); st.insert(4); st.insert(5); for(set&lt;int&gt;::iterator it = st.begin(); it != st.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; ' '; &#125; return 0;&#125;/*out:1 2 3 4 5 */ å¸¸ç”¨å‡½æ•°insertå‘é›†åˆå†…æ’å…¥å…ƒç´ ï¼Œå‰é¢è¯´è¿‡äº†ï¼Œé›†åˆä¼šè‡ªåŠ¨æŽ’åºå’ŒåŽ»é‡ã€‚1st.insert(x); findé›†åˆå†…æŸ¥æ‰¾å…ƒç´ ï¼Œè¿”å›ž set ä¸­å¯¹åº”å€¼ä¸º value çš„è¿­ä»£å™¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º O(logN)ã€‚1st.find(value); countæŸ¥è¯¢é›†åˆå†…æ˜¯å¦å­˜åœ¨å€¼ä¸º value çš„å…ƒç´ ï¼Œå¦‚æžœå­˜åœ¨è¿”å›ž 1ï¼Œåä¹‹ï¼Œè¿”å›ž 0ã€‚1st.count(value); eraseerase å‡½æ•°ç”¨äºŽåˆ é™¤é›†åˆå†…çš„å…ƒç´ ï¼Œä¸¤ç§ç”¨æ³•ã€‚ åˆ é™¤å•ä¸ªå…ƒç´ æŒ‰ç…§è¿™ä¸ªå…ƒç´ çš„è¿­ä»£å™¨è¿›è¡Œåˆ é™¤ï¼š1st.erase(it); åˆ é™¤å•ä¸ªå€¼ä¸º value çš„å…ƒç´ ï¼š1st.erase(value); åˆ é™¤ä¸€ä¸ªåŒºé—´çš„å…ƒç´ éœ€è¦æä¾›åŒºé—´é¦–å°¾çš„è¿­ä»£å™¨ï¼š12st.erase(it1, it2);st.erase(it1, st.end()); sizesize å‡½æ•°ç”¨æ¥è¿”å›žé›†åˆå†…å…ƒç´ ä¸ªæ•°ã€‚1st.size(); clearclear å‡½æ•°ç”¨æ¥æ¸…ç©º set å†…çš„æ‰€æœ‰å…ƒç´ ã€‚1st.clear(); lower_boundlower_bound å‡½æ•°æ˜¯ set å†…é›†æˆçš„ä¸€ä¸ªäºŒåˆ†æŸ¥æ‰¾å‡½æ•°ï¼ŒåŠŸèƒ½ä¸Žstd::lower_boundå‡½æ•°çš„åŠŸèƒ½æ˜¯ç±»ä¼¼çš„ã€‚å¯¹ set è€Œè¨€ï¼Œä½¿ç”¨å…¶å†…éƒ¨çš„ lower_bound å‡½æ•°çš„æ•ˆçŽ‡ä¼šæ›´é«˜ï¼Œç”¨èµ·æ¥ä¹Ÿæ›´æ–¹ä¾¿ï¼Œåªç”¨æä¾›ä¸€ä¸ª value å³å¯ï¼Œä½†å‰ææ˜¯è¦ç¡®ä¿ value çš„ç±»åž‹ä¸Ž set å®¹å™¨å†…å…ƒç´ ç±»åž‹ä¸€è‡´ã€‚å¦å¤–ï¼Œlower_bound å‡½æ•°çš„è¿”å›žå€¼æ˜¯ set çš„è¿­ä»£å™¨ã€‚12345set&lt;int&gt; st;st.insert(1);st.insert(2);st.insert(3);st.lower_bound(2); upper_boundä¸Žä¸Šè¿° lower_bound å‡½æ•°çš„ç”¨æ³•ä¸€è‡´ï¼Œä¸Žstd::upper_boundåŠŸèƒ½ç±»ä¼¼ã€‚ æ‰©å±•æœ‰æ—¶å€™å¯èƒ½ä¸éœ€è¦ set å®¹å™¨çš„åŽ»é‡åŠŸèƒ½ï¼Œå¯ä»¥ä½¿ç”¨ multisetï¼›æœ‰æ—¶å€™ä¸éœ€è¦æŽ’åºåŠŸèƒ½ï¼Œå°±å¯ä»¥ä½¿ç”¨ unordered_setï¼Œæ­¤æ—¶ç”±äºŽæ²¡æœ‰æŽ’åºæ“ä½œäº†ï¼Œè¿è¡Œé€Ÿåº¦ä¼šå¿«å¾ˆå¤šã€‚unordered_set åœ¨æŸäº›åœºåˆä¸‹ï¼Œè¿˜å¯ä»¥å½“ä½œå“ˆå¸Œè¡¨æ¥ç”¨ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>Set</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 80 åœºåŒå‘¨èµ›]]></title>
    <url>%2F2022%2F06%2F13%2FLeetcode-%E7%AC%AC-80-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šå‘¨çš„åŒå‘¨èµ›~è¿˜æ˜¯ 3 é¢˜é€‰æ‰‹ï¼Œè¿™æ¬¡å‘¨èµ›çš„é¢˜å¥½åƒä¹Ÿç®€å•äº†ä¸€ç‚¹... 2299. Strong Password Checker IIAnalysisæ€è·¯å¾ˆç›´æŽ¥ï¼Œåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦ç¬¦åˆè¦æ±‚å³å¯ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š1234567891011121314151617class Solution &#123;public: bool strongPasswordCheckerII(string password) &#123; string ht = "!@#$%^&amp;*()-+"; int n = password.size(); if(n &lt; 8) return false; bool lower = false, upper = false, num = false, spec = false, consective = false; for(int i = 0; i &lt; n; i++) &#123; if(isupper(password[i])) upper = true; if(islower(password[i])) lower = true; if(isdigit(password[i])) num = true; if(ht.find(password[i]) != string::npos) spec = true; if(i != 0 &amp;&amp; password[i] == password[i - 1]) consective = true; &#125; return lower &amp;&amp; upper &amp;&amp; num &amp;&amp; spec &amp;&amp; !consective; &#125;&#125;; å¯æƒœçš„æ˜¯ï¼Œä¸€å¼€å§‹ç”¨çš„æ˜¯if-else ifå¯¼è‡´ WA äº†ä¸€æ¬¡ã€‚å…¶å®žåªè¦å°†æ˜¯å¦å‡ºçŽ°è¿žç»­å­—ç¬¦å•ç‹¬æ‹¿å‡ºæ¥åˆ¤æ–­å°±å¯ä»¥äº†ã€‚å®žé™…ä¸Šä¹Ÿå¯ä»¥ç”¨äºŒè¿›åˆ¶ä½æ¥å–ä»£boolå˜é‡ï¼š12345678910111213141516class Solution &#123;public: bool strongPasswordCheckerII(string password) &#123; int n = password.size(); if(n &lt; 8) return false; int flag = 0; for(int i = 0; i &lt; n; i++) &#123; if(i &gt; 0 &amp;&amp; password[i] == password[i - 1]) return false; if(isupper(password[i])) flag |= 1; else if(islower(password[i])) flag |= 2; else if(isdigit(password[i])) flag |= 4; else flag |= 8; &#125; return flag == 15; &#125;&#125;; è¿™ç§æŠ€å·§ä¼šè¢«ç”¨åœ¨çŠ¶æ€åŽ‹ç¼©ç­‰å…¶ä»–é«˜çº§è§£æ³•ä¸­ã€‚ 2300. Successful Pairs of Spells and PotionsAnalysisç®€å•æ¥è®²ï¼Œè¿™ä¸ªé¢˜å°±æ˜¯åœ¨ç®—ç¬›å¡å°”ç§¯ï¼Œç„¶åŽç»Ÿè®¡å¯¹åº”çš„ç¬¦åˆæ¡ä»¶çš„ç»“æžœå³å¯ã€‚å¦‚æžœç›´æŽ¥æš´åŠ›ï¼Œå¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œæ•°é‡çº§åœ¨ $10^{10}$ï¼Œè‚¯å®šä¼šè¶…æ—¶ã€‚ä¸ºäº†é¿å…è¶…æ—¶ï¼Œå°±ä¸èƒ½ç›´æŽ¥ç®—ç¬›å¡å°”ç§¯ï¼Œå¯ä»¥å…ˆå¯¹ pairs è¿›è¡ŒæŽ’åºï¼Œç„¶åŽéåŽ† spells æ—¶ï¼ŒäºŒåˆ†æŸ¥æ‰¾ pairs ä¸­ç¬¬ä¸€ä¸ªæ»¡è¶³æ¡ä»¶çš„è§£ï¼Œè¿™æ ·å°±å¯ä»¥ç›´æŽ¥å¾—åˆ°ç¬¦åˆæ¡ä»¶çš„ç»„åˆæ•°ç›®äº†ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213class Solution &#123;public: vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, long long success) &#123; int n = spells.size(); vector&lt;int&gt; ans(n); sort(potions.begin(), potions.end()); for(int i = 0; i &lt; n; i++) &#123; long long tmp = (success % spells[i] == 0 ? success / spells[i] : success / spells[i] + 1); ans[i] = potions.end() - lower_bound(potions.begin(), potions.end(), tmp); &#125; return ans; &#125;&#125;; è¿™ä¸ªé¢˜ä¸€å¼€å§‹ä¹Ÿ WA äº†ä¸€æ¬¡ï¼ŒåŽŸå› æ˜¯ tmp ç”¨çš„intï¼Œæ²¡æœ‰è€ƒè™‘åˆ° spells ä¸­çš„æ•°ä¸º 1ï¼Œè€Œ success ä¸ºè¶…å‡ºintèŒƒå›´çš„æƒ…å†µã€‚å®žé™…ä¸Šï¼Œå½“æ—¶æ¯”èµ›çš„æ—¶å€™ï¼Œå…¶å®žä¸€çœ‹åˆ° WA å°±ååº”è¿‡æ¥æ˜¯ tmp æ²¡ç”¨long longçš„é—®é¢˜ã€‚è€Œä¸”ï¼Œå‡ºé”™çš„é‚£ä¸ªç”¨ä¾‹æ­£å¥½æ˜¯å¾ˆé•¿çš„é‚£ä¸ªï¼Œä¸€çœ‹å°±çŸ¥é“æ˜¯æœ€åŽä¸“é—¨ç”¨æ¥å¡è¾¹ç•Œçš„ã€‚ä½†æ˜¯ï¼Œè‡ªå·±è¿˜æ˜¯æ­»æ­»çš„ç›¯ç€è¾“å‡ºå’Œé¢„æœŸç»“æžœå¾ˆä¹…ï¼Œæµªè´¹äº†ä¸å°‘æ—¶é—´ðŸ˜ã€‚å®žé™…ä¸Šï¼Œä¸Šé¢çš„è¿™æ®µä»£ç æ˜¯å‘ä¸Šå–æ•´çš„æ€è·¯ã€‚å¯¹äºŽæ­£æ•´æ•°è€Œè¨€ï¼Œ$xy \geqslant success$ ç­‰ä»·äºŽ $y \geqslant \lceil \frac {success} x \rceil$ï¼Œä¹Ÿç­‰ä»·äºŽ $ y &gt; \lfloor \frac {success - 1} x \rfloor$ã€‚é‚£ä¹ˆï¼Œä¸Šé¢çš„ä»£ç å¯ä»¥æ”¹æˆï¼š123456789101112class Solution &#123;public: vector&lt;int&gt; successfulPairs(vector&lt;int&gt;&amp; spells, vector&lt;int&gt;&amp; potions, long long success) &#123; int n = spells.size(); vector&lt;int&gt; ans(n); sort(potions.begin(), potions.end()); for(int i = 0; i &lt; n; i++) &#123; ans[i] = potions.end() - upper_bound(potions.begin(), potions.end(), (success - 1) / spells[i]); &#125; return ans; &#125;&#125;; 2302. Count Subarrays With Score Less Than KAnalysisè¿™æ˜¯ç¬¬å››ä¸ªé¢˜ï¼Œä½†æ˜¯ç¬¬ä¸‰ä¸ªæäº¤çš„é¢˜ã€‚ä¸ºä»€ä¹ˆç¬¬ä¸‰ä¸ªæäº¤å‘¢ï¼Ÿå› ä¸ºå·®ä¸å¤šæ˜¯åŽŸé¢˜...ðŸ˜‚ç±»ä¼¼çš„é¢˜æ˜¯ï¼š713. Subarray Product Less Than Kã€‚æ‰€ä»¥è¿™ä¸ªé¢˜çš„è§£æ³•ä¹Ÿå¾ˆå¤šï¼Œå½“æ—¶çš„æ€è·¯æ˜¯æ»‘åŠ¨çª—å£ + å‰ç¼€å’Œçš„æ€è·¯ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š1234567891011121314151617181920class Solution &#123;public: long long countSubarrays(vector&lt;int&gt;&amp; nums, long long k) &#123; long long ans = 0, sum = 0; int n = nums.size(); int left = 0, right = 0; while(right &lt; n) &#123; sum += nums[right]; long long product = sum * (right - left + 1); while(left &lt;= right &amp;&amp; product &gt;= k) &#123; sum -= nums[left]; left++; product = sum * (right - left + 1); &#125; ans += right - left + 1; right++; &#125; return ans; &#125;&#125;; ä¸Žå…¶è¯´æ˜¯å‰ç¼€å’Œçš„æ€è·¯ï¼Œå€’ä¸å¦‚è¯´æ˜¯åœ¨æ¨¡æ‹Ÿï¼Œä¸è¿‡ä¹Ÿç›¸å·®æ— å‡ ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 296 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F06%2F05%2FLeetcode-%E7%AC%AC-296-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[è¿™æ¬¡å‘¨èµ›çš„é¢˜ç›®æ„Ÿè§‰ç®€å•äº†ä¸€ç‚¹ã€‚æˆäº†ä¸‰é¢˜é€‰æ‰‹äº†...ðŸ˜‚ï¼Œç¬¬å››é¢˜è¢«å¡åœ¨ç¬¬ 68 ä¸ªç”¨ä¾‹äº†ï¼Œå¯æƒœäº†ã€‚ 6090. Min Max GameAnalysisç›´æŽ¥æŒ‰ç…§é¢˜ç›®æ¥æ¨¡æ‹Ÿå°±è¡Œã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516171819class Solution &#123;public: int minMaxGame(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); if(n == 1) return nums[0]; while(n != 1) &#123; n = nums.size(); vector&lt;int&gt; tmp; for(int i = 0; i &lt; n / 2; i++) &#123; int t; if(i % 2 == 0) t = min(nums[2 * i], nums[2 * i + 1]); else t = max(nums[2 * i], nums[2 * i + 1]); tmp.push_back(t); &#125; nums = tmp; &#125; return nums[0]; &#125;&#125;; æ”¹ç›´è§‚ä¸€ç‚¹ï¼š123456789101112131415161718class Solution &#123;public: int minMaxGame(vector&lt;int&gt;&amp; nums) &#123; int n; while(n != 1) &#123; n = nums.size(); vector&lt;int&gt; tmp; for(int i = 0; i &lt; n / 2; i++) &#123; int t; if(i % 2 == 0) t = min(nums[2 * i], nums[2 * i + 1]); else t = max(nums[2 * i], nums[2 * i + 1]); tmp.push_back(t); &#125; nums = tmp; &#125; return nums[0]; &#125;&#125;; 6091. Partition Array Such That Maximum Difference Is KAnalysisæ€è·¯æ˜¯æŽ’åº + è´ªå¿ƒã€‚ä¸ºäº†ä½¿åˆ†æˆçš„åºåˆ—å°½å¯èƒ½å°‘ï¼Œéœ€è¦å°†å·®å€¼æ»¡è¶³æ¡ä»¶çš„æ•°å°½å¯èƒ½å¤šçš„æ”¾åœ¨ä¸€ä¸ªåºåˆ—ä¸­ã€‚å®žé™…ä¸Šä¹Ÿå°±æ˜¯å°æ•°ä¸Žå°ä¸€ç‚¹çš„æ•°æ”¾ä¸€ä¸ªåºåˆ—ï¼Œå¤§æ•°ä¸Žå¤§ä¸€ç‚¹çš„æ•°æ”¾åœ¨ä¸€ä¸ªåºåˆ—ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516class Solution &#123;public: int partitionArray(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(); int cnt = 0; int left = 0, right; while(left &lt; n) &#123; int right = left; while(right &lt; n &amp;&amp; nums[right] - nums[left] &lt;= k) right++; cnt++; left = right; &#125; return cnt; &#125;&#125;; è¿™æ ·å†™æœ‰ç‚¹æ»‘åŠ¨çª—å£çš„å‘³é“ï¼Œå…¶å®žå¯ä»¥æ”¹çš„æ›´ç®€å•ä¸€ç‚¹ï¼š1234567891011121314class Solution &#123;public: int partitionArray(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int n = nums.size(), cnt = 0; for(int i = 0, j = 0; j &lt; n; j++) &#123; if(nums[j] - nums[i] &gt; k) &#123; cnt++; i = j; &#125; &#125; return cnt + 1; &#125;&#125;; 6092. Replace Elements in an ArrayAnalysisæ€è·¯æ˜¯å“ˆå¸Œ + æ¨¡æ‹Ÿã€‚å› ä¸ºéœ€è¦å°†numsä¸­çš„operation[i][0]æ›¿æ¢æˆoperation[i][1]ï¼Œä¸ºäº†æ–¹ä¾¿æŸ¥æ‰¾å…ƒç´ ï¼Œç”¨å“ˆå¸Œè¡¨ä¿å­˜ä¸€ä¸‹numsä¸­å…ƒç´ çš„ä¸‹æ ‡ã€‚æ¯æ¬¡å®Œæˆæ›¿æ¢æ“ä½œåŽï¼Œå“ˆå¸Œè¡¨ä¼šåˆ é™¤è¢«æ›¿æ¢çš„é‚£ä¸ªæ•°å­—çš„ä¸‹æ ‡ï¼ˆä¹Ÿå¯ä»¥ä¸åˆ é™¤ï¼‰ï¼Œç„¶åŽæ›´æ–°æ–°å…ƒç´ çš„ä¸‹æ ‡ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; arrayChange(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; operations) &#123; int n = nums.size(), m = operations.size(); unordered_map&lt;int, int&gt; indices; for(int i = 0; i &lt; n; i++) &#123; indices[nums[i]] = i; &#125; for(int i = 0; i &lt; m; i++) &#123; int x = operations[i][0], y = operations[i][1]; int index = indices[x]; nums[index] = y; indices[y] = index; indices.erase(x); &#125; return nums; &#125;&#125;; å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜å¯ä»¥åç€æ€è€ƒã€‚æ¯”å¦‚æœ‰ 3 æ¬¡æ“ä½œï¼Œåˆ†åˆ«æ˜¯[1, 3]ã€[2, 1]å’Œ[3, 2]ï¼Œé‚£ä¹ˆå¯ä»¥ä»ŽåŽæ¨¡æ‹Ÿè¿™äº›æ“ä½œï¼Œæœ€ç»ˆ mp ä¸­çš„å…ƒç´ å°±æ˜¯ï¼šmp[3] = 2, mp[2] = 1, mp[1] = mp[3] = 2ã€‚ç„¶åŽå†éåŽ†ä¸€æ¬¡ nums æ•°ç»„ï¼Œç›´æŽ¥ä¿®æ”¹å¯¹åº”çš„å…ƒç´ å³å¯ã€‚123456789101112131415class Solution &#123;public: vector&lt;int&gt; arrayChange(vector&lt;int&gt;&amp; nums, vector&lt;vector&lt;int&gt;&gt;&amp; operations) &#123; unordered_map&lt;int, int&gt; mp; int m = operations.size(); for(int i = m - 1; i &gt;= 0; i--) &#123; if(!mp.count(operations[i][1])) mp[operations[i][0]] = operations[i][1]; else mp[operations[i][0]] = mp[operations[i][1]]; &#125; for(int &amp;i: nums) &#123; if(mp.count(i)) i = mp[i]; &#125; return nums; &#125;&#125;; é€†åºéåŽ† operations æ•°ç»„çš„å¥½å¤„åœ¨äºŽï¼Œå¦‚æžœä¸€ä¸ªæ•°å­—ä¼šè¢«å¤šæ¬¡ä¿®æ”¹ï¼Œé‚£è¿™ä¸ªæ•°å­—å†é€†åºéåŽ†çš„è¿‡ç¨‹ä¸­ä¼šç›´æŽ¥å¾—åˆ°å®ƒæœ€ç»ˆè¢«ä¿®æ”¹çš„é‚£ä¸ªæ•°å­—ï¼Œè¿™æ ·å°±é¿å…äº†å¾ˆå¤šä¸éœ€è¦çš„ä¿®æ”¹ã€‚åŒæ—¶éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œå› ä¸ºé¢˜ç›®é™å®šäº† nums ä¸­çš„æ‰€æœ‰æ•°å­—äº’ä¸ç›¸åŒã€operations ä¸­çš„æ•°å­—ä¹Ÿæ˜¯åœ¨ nums ä¸­ä¸å­˜åœ¨çš„ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä¸åŠ åŒºåˆ†çš„æ­£å‘ä¿®æ”¹ï¼Œä¹Ÿå°±æ˜¯æœ€ä¸Šé¢çš„åšæ³•ï¼Œä½†é€†å‘æ€è€ƒçš„æ–¹æ³•ä¹Ÿé€‚ç”¨æœ‰é‡å¤æ•°å­—çš„å‡ºçŽ°ã€‚ æœ€åŽä¸€ä¸ªé¢˜ï¼Œæ˜Žå¤©åœ¨æ¥~ 2296. Design a Text EditorAnalysisé¢˜ç›®æ„æ€å¾ˆæ¸…æ™°ï¼Œå½“æ—¶çš„æ€è·¯æ˜¯çº¯æ¨¡æ‹Ÿã€‚ Codeæš´åŠ›æ¨¡æ‹Ÿè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class TextEditor &#123; string te; int pos;public: TextEditor() : pos(-1)&#123; &#125; void addText(string text) &#123; if(pos == -1) &#123; pos = text.length(); for(int i = 0; i &lt; te.size(); i++) &#123; text.push_back(te[i]); &#125; te = text; &#125; else if(pos == te.length()) &#123; te += text; pos = te.length(); &#125; else &#123; string tmp = ""; for(int i = 0; i &lt; pos; i++) &#123; tmp.push_back(te[i]); &#125; tmp += text; int t = pos; pos = tmp.length(); while(t &lt; te.length()) &#123; tmp.push_back(te[t]); t++; &#125; te = tmp; &#125; &#125; int deleteText(int k) &#123; int cnt = 0; for(int i = 0; i &lt; k; i++) &#123; if(pos &gt; 0) &#123; te.erase(te.begin() + pos - 1); pos--; cnt++; &#125; else break; &#125; return cnt; &#125; string cursorLeft(int k) &#123; string tmp = ""; pos -= k; if(pos &lt; 0) &#123; pos = -1; return tmp; &#125; int tpos = pos - 1, i = 10; while(tpos &gt;= 0 &amp;&amp; i &gt; 0) &#123; tmp.push_back(te[tpos]); tpos--; i--; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorRight(int k) &#123; string tmp = ""; if(pos == -1) pos = k; else pos += k; if(pos &gt; te.length()) pos = te.length(); int tpos = pos - 1, i = 10; while(tpos &gt;= 0 &amp;&amp; i &gt; 0) &#123; tmp.push_back(te[tpos]); tpos--; i--; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125;&#125;; çº¯çº¯çš„æ¨¡æ‹Ÿæ€è·¯ï¼Œæ­»åœ¨ç¬¬ 68 ä¸ªç”¨ä¾‹çš„åŽŸå› æ˜¯å†™äº†å¾ˆå¤šè¾“å‡ºè¯­å¥æ¥è°ƒè¯•ä»£ç ï¼ˆLeetcode è¿”å›žçš„é”™è¯¯ä¿¡æ¯æ˜¯è¶…å‡ºè¾“å‡ºé™åˆ¶ï¼‰ã€‚åˆ é™¤å¤šä½™çš„è¾“å‡ºè¯­å¥åŽï¼Œè¿˜æ˜¯æ­»åœ¨äº†ç¬¬ 72 ä¸ªç”¨ä¾‹ï¼ŒåŽŸå› æ˜¯è¶…æ—¶äº†ï¼Œæƒ³æƒ³å†™äº†è¿™ä¹ˆå¤š reverseï¼Œä¸è¶…æ—¶æ€ªäº†ã€‚è¿™ä¸ªé¢˜ç”¨æ¨¡æ‹Ÿç¡®ç¡®å®žå®žæ˜¯å¯ä»¥åšå‡ºæ¥çš„ï¼Œåªæ˜¯æˆ‘çš„æ€è·¯æœ‰ç‚¹é—®é¢˜ï¼Œå‚è€ƒäº†åˆ«äººçš„æš´åŠ›è§£æ³•ï¼š123456789101112131415161718192021222324252627282930313233class TextEditor &#123;public: TextEditor() : curpos(0) &#123;&#125; void addText(string text) &#123; te.insert(curpos, text); curpos += text.length(); &#125; int deleteText(int k) &#123; int pos = max(0, curpos - k); int num = curpos - pos; text.erase(pos, num); curpos = pos; return num; &#125; string cursorLeft(int k) &#123; curpos = max(0, curpos - k); int num = min(10, curpos); return te.substr(curpos - num, num); &#125; string cursorRight(int k) &#123; int len = te.length(); curpos = min(len, curpos + k); int num = min(10, curpos); return te.substr(curpos - num, num); &#125;private: string te; int curpos;&#125;; ä¸å¾—ä¸è¯´ï¼Œè¿˜æ˜¯è‡ªå·± API ç”¨çš„ä¸ç†Ÿç»ƒ...å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜çš„æ­£ç¡®åšæ³•åº”è¯¥æ˜¯ç”¨åŒå‘é“¾è¡¨æˆ–è€…æ ˆæ¥åšã€‚ é“¾è¡¨æ¨¡æ‹Ÿä¸ºä»€ä¹ˆè¦ä½¿ç”¨åŒå‘é“¾è¡¨ï¼Ÿå› ä¸ºéœ€è¦å·¦ç§»æˆ–å³ç§»å…‰æ ‡ï¼ŒåŒå‘é“¾è¡¨å¯ä»¥å¾ˆå®¹æ˜“çš„å®Œæˆè¿™ä¸ªæ“ä½œã€‚å…ˆè€ƒè™‘é“¾è¡¨åˆ›å»ºçš„è¿‡ç¨‹ä¸­éœ€è¦çš„ä¸œè¥¿ã€‚é¦–å…ˆæ˜¯ç»“ç‚¹çš„å®šä¹‰å’Œæž„é€ å‡½æ•°ï¼š12345struct Node &#123; char ch; Node *pre, *next; Node(char _ch): ch(_ch), pre(nullptr), next(nullptr)&#123;&#125;&#125;; åˆ›å»ºé“¾è¡¨è‚¯å®šè¦æ’å…¥ç»“ç‚¹ï¼š1234567Node* insert(Node* pos, Node* node) &#123; node-&gt;pre = pos; node-&gt;next = pos-&gt;next; node-&gt;pre-&gt;next = node; node-&gt;next-&gt;pre = node; return node;&#125; é¢˜ç›®è¿˜è¦æ±‚è¦åˆ é™¤ï¼Œæ‰€ä»¥åˆ é™¤ç»“ç‚¹çš„æ“ä½œä¹Ÿéœ€è¦ï¼š1234void remove(Node* pos) &#123; pos-&gt;pre-&gt;next = pos-&gt;next; pos-&gt;next-&gt;pre = pos-&gt;pre;&#125; å·ä¸‹æ‡’ï¼Œä¸åšçœŸæ­£çš„åˆ é™¤ï¼Œåªæ–­é“¾...ï¼ˆå®žé™…é¡¹ç›®ä¸­å¯åˆ«è¿™æ ·å¹²ï¼‰æŽ¥ä¸‹æ¥è¦è€ƒè™‘çš„é—®é¢˜å°±æ˜¯ TextEditor éœ€è¦ä»€ä¹ˆã€‚é¦–å…ˆè‚¯å®šéœ€è¦ä¸€ä¸ªå…‰æ ‡ä½ç½®curï¼Œè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘å…‰æ ‡ä½ç½®å·¦è¾¹çš„ç¬¬ä¸€ä¸ªç»“ç‚¹ã€‚æ—¢ç„¶æ˜¯é“¾è¡¨ï¼Œä¸å¦¨åˆ›å»ºä¸€ä¸ªå¤´ï¼ˆå“‘ï¼‰ç»“ç‚¹æ¥æ–¹ä¾¿æ’å…¥ã€‚12345678910class TextEditor &#123;public: TextEditor() &#123; head = new Node(); head-&gt;pre = head-&gt;next = head; cur = head; &#125;private: Node *cur, *head;&#125; ä¹‹æ‰€ä»¥æŠŠå¤´ç»“ç‚¹çš„æŒ‡å‘è‡ªèº«ï¼Œæ˜¯ä¸ºäº†æ–¹ä¾¿åŽé¢ç§»åŠ¨å…‰æ ‡çš„æ“ä½œï¼Œæ³¨æ„æ•´ä¸ªé“¾è¡¨æ˜¯æˆçŽ¯çš„ã€‚æ’å…¥ä¸Žåˆ é™¤æ–‡æœ¬å°±å¾ˆç®€å•äº†ï¼š12345678910111213141516void addText(string text) &#123; for(char ch: text) &#123; Node *tmp = new Node(ch); cur = insert(cur, tmp); &#125;&#125;int deleteText(int k) &#123; int tmp = k; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; remove(cur-&gt;next); k--; &#125; return tmp - k;&#125; å…‰æ ‡å·¦ç§»ä¸Žå³ç§»çš„æ“ä½œéƒ½éœ€è¦è¿”å›žä¸€æ®µæ–‡æœ¬ï¼Œä¸å¦¨æŠŠè¿™ä¸ªåŠŸèƒ½å°è£…èµ·æ¥ï¼Œè®©å·¦ç§»ä¸Žå³ç§»åªå®Œæˆç§»åŠ¨çš„åŠŸèƒ½ã€‚è¿”å›žçš„å­—ç¬¦ä¸²é•¿åº¦æ˜¯ 10 å’Œå…‰æ ‡å·¦è¾¹å­—ç¬¦æ•°ä¹‹é—´çš„æœ€å°å€¼ã€‚å› ä¸ºå‰é¢è®©å¤´ç»“ç‚¹æŒ‡å‘äº†è‡ªèº«ï¼Œæ‰€ä»¥å¯ä»¥è®©å¤´ç»“ç‚¹ä½œä¸ºå·¦è¾¹æœ€å°å­—ç¬¦çš„è¾¹ç•Œæ¡ä»¶ã€‚å¦å¤–ï¼Œåˆ«å¿˜äº†è¦ç¿»è½¬å­—ç¬¦ä¸²ã€‚123456789101112string text() &#123; Node *p = cur; string tmp = ""; int k = 10; while(k &amp;&amp; p != head) &#123; tmp.push_back(p-&gt;ch); k--; p = p-&gt;pre; &#125; reverse(tmp.begin(), tmp.end()); return tmp;&#125; ç„¶åŽæ˜¯å·¦ç§»æ“ä½œï¼Œå…‰æ ‡æœ€å¤šåªèƒ½ç§»åŠ¨åˆ°å¤´ç»“ç‚¹å¤„ï¼š1234567string cursorLeft(int k) &#123; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; k--; &#125; return text();&#125; æœ€åŽæ˜¯å³ç§»ï¼Œå…‰æ ‡åªèƒ½ç§»åŠ¨åˆ°æœ€åŽä¸€ä¸ªç»“ç‚¹å¤„ï¼ŒåŒæ ·å¯ä»¥ç”¨æœ€åŽä¸€ä¸ªç»“ç‚¹çš„nextæ˜¯å¦æ˜¯å¤´ç»“ç‚¹æ¥åˆ¤æ–­æ˜¯å¦åˆ°äº†é“¾è¡¨æœ«å°¾ï¼š1234567string cursorRight(int k) &#123; while(k &amp;&amp; cur-&gt;next != head) &#123; cur = cur-&gt;next; k--; &#125; return text();&#125; åˆå¹¶ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class TextEditor &#123;public: struct Node &#123; char ch; Node *pre, *next; Node()&#123;&#125; Node(char _ch): ch(_ch), pre(nullptr), next(nullptr)&#123;&#125; &#125;; Node* insert(Node* pos, Node* node) &#123; node-&gt;pre = pos; node-&gt;next = pos-&gt;next; node-&gt;pre-&gt;next = node; node-&gt;next-&gt;pre = node; return node; &#125; void remove(Node* pos) &#123; pos-&gt;pre-&gt;next = pos-&gt;next; pos-&gt;next-&gt;pre = pos-&gt;pre; &#125; TextEditor() &#123; head = new Node(); head-&gt;pre = head-&gt;next = head; cur = head; &#125; void addText(string text) &#123; for(char ch: text) &#123; Node *tmp = new Node(ch); cur = insert(cur, tmp); &#125; &#125; int deleteText(int k) &#123; int tmp = k; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; remove(cur-&gt;next); k--; &#125; return tmp - k; &#125; string text() &#123; Node *p = cur; string tmp = ""; int k = 10; while(k &amp;&amp; p != head) &#123; tmp.push_back(p-&gt;ch); k--; p = p-&gt;pre; &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorLeft(int k) &#123; while(k &amp;&amp; cur != head) &#123; cur = cur-&gt;pre; k--; &#125; return text(); &#125; string cursorRight(int k) &#123; while(k &amp;&amp; cur-&gt;next != head) &#123; cur = cur-&gt;next; k--; &#125; return text(); &#125;private: Node *cur, *head;&#125;; å¦‚æžœæ˜¯ C++ çš„è¯ï¼Œå¯ä»¥ç”¨ STL å†…çš„ list æ¥å®Œæˆï¼Œæ€è·¯æ˜¯ä¸€è‡´çš„ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445class TextEditor &#123;private: list&lt;char&gt; l; list&lt;char&gt;::iterator cur = l.begin();public: TextEditor() &#123;&#125; void addText(string text) &#123; for(char ch: text) &#123; l.insert(cur, ch); &#125; &#125; int deleteText(int k) &#123; int k0 = k; for(; k &amp;&amp; cur != l.begin(); k--) &#123; cur = l.erase(prev(cur)); &#125; return k0 - k; &#125; string text() &#123; string tmp; auto it = cur; for(int k = 10; k &amp;&amp; it != l.begin(); k--) &#123; it = prev(it); tmp.push_back(*it); &#125; reverse(tmp.begin(), tmp.end()); return tmp; &#125; string cursorLeft(int k) &#123; for(; k &amp;&amp; cur != l.begin(); k--) &#123; cur = prev(cur); &#125; return text(); &#125; string cursorRight(int k) &#123; for(; k &amp;&amp; cur != l.end(); k--) &#123; cur = next(cur); &#125; return text(); &#125;&#125;; æ ˆæ¨¡æ‹Ÿå‡†ç¡®æ¥è¯´ï¼Œåº”è¯¥æ˜¯ç”¨åŒæ ˆæ¥æ¨¡æ‹Ÿï¼Œè¯´çš„æ›´ç›´è§‚ä¸€ç‚¹å°±æ˜¯å¯¹é¡¶æ ˆï¼Œä¹Ÿå°±æ˜¯è¿™ä¸¤ä¸ªæ ˆçš„æ ˆé¡¶æ˜¯æ‹¼åœ¨ä¸€èµ·çš„ï¼Œè¿™æ ·é¢˜ç›®è¦æ±‚çš„å…‰æ ‡ä½ç½®å°±æ˜¯è¿™ä¸¤ä¸ªæ ˆå¯¹é¡¶çš„ä½ç½®ï¼Œè€Œç§»åŠ¨å…‰æ ‡çš„æ“ä½œå°±æ˜¯ä¸¤ä¸ªæ ˆæ¥å›žå€’çš„è¿‡ç¨‹äº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class TextEditor &#123;private: stack&lt;char&gt; left, right;public: TextEditor() &#123;&#125; void addText(string text) &#123; for(char ch: text) &#123; left.push(ch); &#125; &#125; int deleteText(int k) &#123; int k0 = k; while(k &amp;&amp; !left.empty()) &#123; left.pop(); k--; &#125; return k0 - k; &#125; string text() &#123; int k = 10; string tmp; while(k &amp;&amp; !left.empty()) &#123; tmp.push_back(left.top()); k--; left.pop(); &#125; reverse(tmp.begin(), tmp.end()); for(char &amp;ch: tmp) &#123; left.push(ch); &#125; return tmp; &#125; string cursorLeft(int k) &#123; while(k &amp;&amp; !left.empty()) &#123; k--; right.push(left.top()); left.pop(); &#125; return text(); &#125; string cursorRight(int k) &#123; while(k &amp;&amp; !right.empty()) &#123; k--; left.push(right.top()); right.pop(); &#125; return text(); &#125;&#125;; ä¸ºäº†æ›´å¥½çš„ä½¿ç”¨ APIï¼Œå…¶å®žç›´æŽ¥ç”¨ string å®¹å™¨æ¥å½“ä½œæ ˆæ›´å¥½ã€‚123456789101112131415161718192021222324252627282930313233343536373839class TextEditor &#123; string left, right;public: TextEditor() &#123; left = right = ""; &#125; void addText(string text) &#123; left += text; &#125; int deleteText(int k) &#123; int k0 = k; for(; k &amp;&amp; left.length() &gt; 0; k--) &#123; left.pop_back(); &#125; return k0 - k; &#125; string cursorLeft(int k) &#123; if(left.length() &lt; k) k = left.length(); for(int i = 0; i &lt; k; i++) &#123; right.push_back(left.back()); left.pop_back(); &#125; string ans(left.end() - min(10, (int)left.length()), left.end()); return ans; &#125; string cursorRight(int k) &#123; if(right.length() &lt; k) k = right.length(); for(int i = 0; i &lt; k; i++) &#123; left.push_back(right.back()); right.pop_back(); &#125; string ans(left.end() - min(10, (int)left.length()), left.end()); return ans; &#125;&#125;; Summaryè¿™æ¬¡å‘¨èµ›æ¯”è¾ƒç®€å•ï¼Œæ²¡ AK è¯´æ˜Žè‡ªå·±è¿˜æ˜¯å¤ªå¼±äº†...ðŸ˜‚æœ€åŽä¸€ä¸ªé¢˜æŒºä¸é”™çš„ï¼Œè§£æ³•æŒºå¤šçš„ï¼Œè™½ç„¶æ²¡æœ‰å¡æŽ‰æš´åŠ›è§£æ³•ï¼Œä½†æ˜¯é¢˜ç›®å€’æ˜¯å¾ˆèƒ½æ‰“å¼€æ€è·¯ï¼Œéš¾åº¦ç®—åœ¨ä¸­ç­‰æ¯”è¾ƒå¥½ã€‚ç¬¬ 2ã€3 é¢˜ç®—æ˜¯ä¸­ç­‰é¢˜ä¸­çš„ç®€å•é¢˜äº†...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 295 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F06%2F01%2FLeetcode-%E7%AC%AC-295-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šå‘¨å‘¨èµ›ã€‚åŒé¢˜é€‰æ‰‹ã€‚ 2287. Rearrange Characters to Make Target StringAnalysisç»Ÿè®¡ s ä¸­å’Œ target ç›¸åŒçš„å­—ç¬¦æ¬¡æ•°ï¼Œç„¶åŽæ¨¡æ‹Ÿæž„æˆ target å­ä¸²å³å¯ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516171819202122232425class Solution &#123;public: int rearrangeCharacters(string s, string target) &#123; vector&lt;int&gt; cnt(26); int len = s.length(); for(int i = 0; i &lt; len; i++) &#123; cnt[s[i] - 'a']++; &#125; int ret = 0; bool flag = true; while(true) &#123; len = target.length(); for(int i = 0; i &lt; len; i++) &#123; cnt[target[i] - 'a']--; if(cnt[target[i] - 'a'] &lt; 0) &#123; flag = false; break; &#125; &#125; if(!flag) break; ret++; &#125; return ret; &#125;&#125;; å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜å¯ä»¥é€šè¿‡ç»´æŠ¤ä¸¤ä¸ªå“ˆå¸Œè¡¨åšé™¤æ³•æ¥ç¡®å®šæœ€å¤šèƒ½ç»„æˆå‡ ä¸ª targetã€‚123456789101112131415161718class Solution &#123;public: int rearrangeCharacters(string s, string target) &#123; vector&lt;int&gt; cnt1(26), cnt2(26); int len = s.length(); for(char c: s) &#123; cnt1[c - 'a']++; &#125; for(char c: target) &#123; cnt2[c - 'a']++; &#125; int min_val = INT_MAX; for(char c: target) &#123; min_val = min(min_val, cnt1[c - 'a'] / cnt2[c - 'a']); &#125; return min_val; &#125;&#125;; 2288. Apply Discount to PricesAnalysisè¿™ä¸ªé¢˜å®žé™…ä¸Šç®—æ˜¯ä¸ªæŠ«ç€ä¸­ç­‰é¢˜å¤–è¡£çš„ç®€å•é¢˜ï¼Œéš¾ç‚¹åœ¨äºŽå¯¹ä¸åŒæƒ…å†µçš„åˆ†ç±»ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“ WAï¼ˆWA äº† 5 æ¬¡ðŸ˜“ï¼‰ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: string discountPrices(string sentence, int discount) &#123; int len = sentence.length(); string ret = ""; for(int i = 0; i &lt; len; i++) &#123; if(sentence[i] != '$') ret.push_back(sentence[i]); else &#123; ret.push_back(sentence[i]); if(i &gt; 0 &amp;&amp; sentence[i - 1] != ' ') continue; i++; if(i == len) break; if(!isdigit(sentence[i])) &#123; ret.push_back(sentence[i]); continue; &#125; double tmp = 0; bool flag = true; int pos = i; while(i &lt; len &amp;&amp; sentence[i] != ' ') &#123; if(!isdigit(sentence[i]) &amp;&amp; sentence[i] != ' ') &#123; flag = false; break; &#125; tmp = tmp * 10 + sentence[i] - '0'; i++; &#125; if(flag) &#123; tmp = tmp * (1 - discount / 100.0) + 0.005; string t = to_string(tmp); int j = 0; while(j &lt; t.length() &amp;&amp; t[j] != '.') &#123; ret.push_back(t[j]); j++; &#125; ret.push_back(t[j]); ret.push_back(t[j + 1]); ret.push_back(t[j + 2]); if(i != len) &#123; ret.push_back(sentence[i]); &#125; &#125; else &#123; ret += sentence.substr(pos, i - pos + 1); &#125; &#125; &#125; return ret; &#125;&#125;; è¢«é‚£å‡ ä¸ªç”¨ä¾‹æ¥å›žæŠ˜ç£¨...ç¨å¾®æ”¹ä¸€ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: string discountPrices(string sentence, int discount) &#123; int len = sentence.length(); string ret = ""; for(int i = 0; i &lt; len; i++) &#123; if(sentence[i] != '$') ret.push_back(sentence[i]); else &#123; ret.push_back(sentence[i]); if(i &gt; 0 &amp;&amp; sentence[i - 1] != ' ') continue; i++; if(i == len) break; if(!isdigit(sentence[i])) &#123; ret.push_back(sentence[i]); continue; &#125; double tmp = 0; bool flag = true; int pos = i; while(i &lt; len &amp;&amp; sentence[i] != ' ') &#123; if(!isdigit(sentence[i]) &amp;&amp; sentence[i] != ' ') &#123; flag = false; break; &#125; tmp = tmp * 10 + sentence[i] - '0'; i++; &#125; if(flag) &#123; tmp = tmp * (1 - discount / 100.0) + 0.005; string t = to_string(tmp); int j = 0; while(j &lt; t.length() &amp;&amp; t[j] != '.') &#123; ret.push_back(t[j]); j++; &#125; for(int k = j; k &lt; j + 3; k++) &#123; ret.push_back(t[k]); &#125; if(i != len) ret.push_back(sentence[i]); &#125; else &#123; ret += sentence.substr(pos, i - pos + 1); &#125; &#125; &#125; return ret; &#125;&#125;; é¢˜ç›®è¦ä¿ç•™ 2 ä½å°æ•°ï¼Œé‚£ä¹ˆç¬¬ 3 ä½å°æ•°å°±è¦å››èˆäº”å…¥ï¼Œä¸€ä¸ªè§£å†³åŠžæ³•æ˜¯ç›´æŽ¥åŠ ä¸Š 0.005ï¼Œå¦å¤–ä¸€ä¸ªè§£å†³åŠžæ³•æ˜¯ç”¨long doubleã€‚PSï¼šC++ çš„å­—ç¬¦ä¸²èƒ½åŠ›ç¡®å®žä¸å¦‚å…¶ä»–è¯­è¨€...è¿™ä¸ªé¢˜å†™çš„æœ‰ç‚¹æŠ˜ç£¨äººã€‚ 2289. Steps to Make Array Non-decreasingAnalysisè¿™ä¸ªé¢˜æƒ³äº†æŒºä¹…çš„ï¼Œå¯æƒœæ²¡æƒ³å‡ºæ¥...å½“æ—¶æŠŠç¬¬äºŒä¸ªé¢˜æ”¹å¥½ï¼Œå°±å·²ç»æ¯«æ— è€å¿ƒäº†ï¼Œçœ‹äº†ä¸¤çœ¼åŽé¢ä¸¤ä¸ªé¢˜å°±æºœäº†ðŸ˜‚ã€‚çŽ°åœ¨å†å›žæ¥å€’è…¾ä¸€ä¸‹ã€‚ Codeemï¼Œå…ˆç¢ç£¨ä¸€ä¸‹æš´åŠ›è§£æ³•ã€‚1234567891011121314151617181920class Solution &#123;public: int totalSteps(vector&lt;int&gt;&amp; nums) &#123; int cnt = 0; while(true) &#123; int n = nums.size(); vector&lt;int&gt; tmp; bool flag = true; tmp.push_back(nums[0]); for(int i = 1; i &lt; n; i++) &#123; if(nums[i] &lt; nums[i - 1]) flag = false; else tmp.push_back(nums[i]); &#125; if(!flag) cnt++; else break; nums = tmp; &#125; return cnt; &#125;&#125;; æš´åŠ›è§£æ³•è¿˜ç®—æ˜¯æ¯”è¾ƒå®¹æ˜“æƒ³åˆ°ï¼ˆå¥½åƒå‰å‡ å‘¨çš„å‘¨èµ›çš„ç¬¬ä¸€é“è·Ÿè¿™ä¸ªå·®ä¸å¤šï¼‰ï¼Œæ€è·¯å°±æ˜¯æš´åŠ›æ¨¡æ‹Ÿï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œæ­»åœ¨ç¬¬ 79 ä¸ªç”¨ä¾‹äº†ã€‚å‚è€ƒäº†ä¸€ä¸‹å¤§ä½¬çš„é¢˜è§£ï¼šç­‰ä»·è½¬æ¢ + åˆ©ç”¨å•è°ƒæ€§ï¼ˆPython/Java/C++/Goï¼‰ã€‚åŽŸæ¥è¿™æ˜¯ä¸ªå•è°ƒæ ˆçš„é¢˜ï¼Œä½†æ˜¯æƒ³åˆ°ç”¨å•è°ƒæ ˆæ¥å¤„ç†ä¸ç®—å®¹æ˜“ã€‚é¦–å…ˆè¦èƒ½æƒ³åˆ°çš„æ˜¯å°†é—®é¢˜æ˜¯ä¸€ä¸ªæ•°å­—èƒ½å¦â€œæ´»åˆ°â€æœ€åŽï¼Œåªå–å†³äºŽè¿™ä¸ªæ•°å­—çš„å·¦è¾¹æœ‰æ²¡æœ‰æ¯”å®ƒæ›´å¤§çš„æ•°å­—ã€‚å¦‚æžœæœ‰ï¼Œé‚£è¿™ä¸ªæ•°å­—ä¸€å®šä¼šè¢«æ‹¿æŽ‰ï¼›åä¹‹ï¼Œè¿™ä¸ªæ•°å­—ä¸€å®šä¼šå‡ºçŽ°åœ¨ç»“æžœåºåˆ—ä¸­ã€‚ç„¶åŽéœ€è¦è€ƒè™‘çš„æ˜¯è¢«æ‹¿æŽ‰çš„æ•°å­—ä¼šåœ¨é‚£ä¸€è½®ç­›é€‰ä¸­è¢«æ‹¿æŽ‰ã€‚è§‚å¯Ÿç”¨ä¾‹å¯ä»¥å‘çŽ°ï¼Œè¢«æ‹¿æŽ‰çš„æ•°å­—è‚¯å®šæ˜¯è¿™ä¸ªæ•°å­—ä¸Žå…¶å·¦è¾¹ç¬¬ä¸€ä¸ªå¤§äºŽå®ƒçš„æ•°å­—ä¸­é—´çš„æ•°è¢«æ‹¿æŽ‰ä¹‹åŽæ‰ä¼šè¢«æ‹¿æŽ‰ï¼ˆæˆ‘åœ¨è¯´ä»€ä¹ˆå‘¢ï¼ŸðŸ˜‚ï¼‰ã€‚ä»¥5, 3, 4, 5, 7, 3, 6, 11, 8, 5, 11ä¸ºä¾‹ï¼Œ6ä¸€å®šä¼šè¢«æ‹¿æŽ‰ï¼Œä½†æ˜¯6ä¸€å®šæ˜¯åœ¨å…¶å‰é¢çš„3è¢«æ‹¿æŽ‰åŽçš„ä¸‹ä¸€è½®ç­›é€‰ä¸­è¢«æ‹¿æŽ‰ã€‚æ¢å¥è¯è¯´ï¼Œæ‹¿æŽ‰6éœ€è¦çš„æ“ä½œæ•°å°±æ˜¯æ‹¿æŽ‰3éœ€è¦çš„æ“ä½œæ•°åŠ  1ã€‚ æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªå•è°ƒé€’å‡æ ˆæ¥å­˜å‚¨å…ƒç´ åŠå…¶å¯¹åº”è¢«æ‹¿æŽ‰çš„è½®æ¬¡ï¼ˆç”¨æ—¶åˆ»æ¥è¡¨ç¤ºä¹Ÿæ˜¯å¯ä»¥çš„ï¼‰ã€‚å½“æ ˆé¡¶å…ƒç´ å°äºŽå½“å‰å…ƒç´ æ—¶ï¼Œå°±å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼ŒåŒæ—¶å–è¢«å¼¹å‡ºå…ƒç´ è½®æ¬¡çš„æœ€å¤§å€¼maxtï¼Œç„¶åŽå°†å½“å‰å…ƒç´ ä¸Žmaxt + 1å…¥æ ˆã€‚å¦‚æžœæ­¤æ—¶æ ˆä¸ºç©ºï¼Œè¯´æ˜Žå½“å‰å…ƒç´ ä¸ä¼šè¢«æ‹¿æŽ‰ï¼Œmaxt = 0ï¼Œç„¶åŽå…¥æ ˆã€‚123456789101112131415161718class Solution &#123;public: int totalSteps(vector&lt;int&gt;&amp; nums) &#123; int ans = INT_MIN; stack&lt;pair&lt;int, int&gt;&gt; st; for(int i: nums) &#123; int maxt = 0; while(!st.empty() &amp;&amp; st.top().first &lt;= i) &#123; maxt = max(maxt, st.top().second); st.pop(); &#125; maxt = st.empty() == true ? 0 : maxt + 1; st.emplace(i, maxt); ans = max(ans, maxt); &#125; return ans; &#125;&#125;; éš¾ç‚¹åœ¨æ€è·¯ä¸Šï¼Œæœ¬èº«çš„å®žçŽ°è¿‡ç¨‹å…¶å®žå¹¶ä¸å¤æ‚ã€‚ 2290. Minimum Obstacle Removal to Reach CornerAnalysisç¬¬ä¸€çœ¼çœ‹åˆ°è¿™ä¸ªé¢˜çš„æ—¶å€™ï¼Œå°±æ„è¯†åˆ°äº†è¿™æ˜¯ä¸ªä¸Žå›¾ç›¸å…³çš„èµ°è¿·å®«çš„é¢˜ç›®ã€‚è·Ÿå›¾ç›¸å…³çš„å†…å®¹ï¼Œå·²ç»æ˜¯å¿˜çš„å·®ä¸å¤š... Codeå®žé™…ä¸Šè¿™æ˜¯ä¸ªæœ€çŸ­è·¯çš„é—®é¢˜ï¼Œgridå¯ä»¥ç›´æŽ¥å½“ä½œè¿™ä¸ªå›¾çš„é‚»æŽ¥çŸ©é˜µï¼Œé‚£ä¹ˆæ•´ä¸ªé¢˜çš„æ±‚è§£è¿‡ç¨‹å°±å¯ä»¥ç›´æŽ¥ç”¨ bfs æ¥å®Œæˆã€‚123456789101112131415161718192021222324class Solution &#123;public: int dirs[4][2] = &#123;&#123;0, 1&#125;, &#123;0, -1&#125;, &#123;1, 0&#125;, &#123;-1, 0&#125;&#125;; int minimumObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n, INT_MAX)); queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(0, 0); dist[0][0] = 0; while(!q.empty()) &#123; auto u = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int newx = u.first + dirs[i][0]; int newy = u.second + dirs[i][1]; if(0 &lt;= newx &amp;&amp; newx &lt; m &amp;&amp; 0 &lt;= newy &amp;&amp; newy &lt; n &amp;&amp; dist[newx][newy] &gt; dist[u.first][u.second] + grid[u.first][u.second]) &#123; dist[newx][newy] = dist[u.first][u.second] + grid[u.first][u.second]; q.emplace(newx, newy); &#125; &#125; &#125; return dist[m - 1][n - 1]; &#125;&#125;; è¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨å…¶ä»–æ±‚æœ€çŸ­è·¯çš„æ–¹æ³•æ¥å¤„ç†ï¼Œç•™ä½œä»¥åŽçš„ç»ƒä¹ ã€‚ Summaryç¬¬äºŒä¸ªé¢˜å‡ºä¸Žå­—ç¬¦ä¸²ç›¸å…³çš„é¢˜çœŸæ˜¯å¤ªéº»çƒ¦äº†...å†™å®Œäº†å°±æ²¡è€å¿ƒå†™åŽé¢çš„é¢˜äº†ã€‚ç¬¬ä¸‰ä¸ªé¢˜çš„æ€è€ƒéš¾åº¦è¿˜æ˜¯æŒºå¤§çš„ï¼Œæƒ³ä¸å‡ºæ¥è¿˜æ˜¯åšå¾—å°‘ã€‚ç¬¬å››ä¸ªé¢˜å…¶å®žç®—æ˜¯ä¸ªé€åˆ†çš„å›°éš¾é¢˜ï¼Œæ²¡æŠ“ä½ã€‚ðŸ˜‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 79 åœºåŒå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F31%2FLeetcode-%E7%AC%AC-79-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šå‘¨çš„åŒå‘¨èµ›~åˆæˆåŒé¢˜é€‰æ‰‹äº†~ 2283. Check if Number Has Equal Digit Count and Digit ValueAnalysisè¿™ä¸ªç®€å•é¢˜å¾ˆå¥‡æ€ª...å¤§æ¦‚æ„æ€æ˜¯å¦‚æžœæ‰€æœ‰çš„ä¸‹æ ‡iåœ¨å­—ç¬¦ä¸²numä¸­å‡ºçŽ°çš„æ¬¡æ•°ä¸Žnum[i] - &#39;0&#39;ç›¸ç­‰ï¼Œå°±è¿”å›ž trueï¼Œåä¹‹è¿”å›ž falseã€‚æ„Ÿè§‰æ€ªçš„å¾ˆ...å‡ºé¢˜äººæ˜¯ä¸æ˜¯ä¸çŸ¥é“æ€Žä¹ˆå‡ºç®€å•é¢˜äº†ï¼ŸðŸ˜‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213class Solution &#123;public: bool digitCount(string num) &#123; vector&lt;int&gt; cnt(10); for(char &amp;ch: num) &#123; cnt[ch - '0']++; &#125; for(int i = 0; i &lt; num.length(); i++) &#123; if(num[i] - '0' != cnt[i]) return false; &#125; return true; &#125;&#125;; é¢˜ç›®å…¶å®žçœ‹äº†æŒºä¹…çš„ï¼Œç”Ÿæ€• WA äº†ã€‚å®žé™…ä¸Šï¼Œè¿™é‡Œä¹Ÿå¯ä»¥æ¢æˆä½è¿ç®—ï¼š12345678910111213class Solution &#123;public: bool digitCount(string num) &#123; vector&lt;int&gt; cnt(10); for(char &amp;ch: num) &#123; cnt[ch &amp; 15]++; &#125; for(int i = 0; i &lt; num.length(); i++) &#123; if((num[i] &amp; 15) != cnt[i]) return false; &#125; return true; &#125;&#125;; æ³¨æ„è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ã€‚ 2284. Sender With Largest Word CountAnalysisè¿™ä¸ªé¢˜å®žé™…ä¸Šæ˜¯ä¸¤ä¸ªé¢˜çš„ç»“åˆç‰ˆï¼Œä¸€ä¸ªæ˜¯ç»Ÿè®¡å•è¯ï¼Œä¸€ä¸ªæ˜¯åˆ†å‰²å•è¯ã€‚æ‰€ä»¥ï¼Œè¿™ä¸ªé¢˜ç®—æ˜¯åœ¨è€ƒ hash å’Œ splitã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š123456789101112131415161718192021222324252627class Solution &#123;public: string largestWordCount(vector&lt;string&gt;&amp; messages, vector&lt;string&gt;&amp; senders) &#123; map&lt;string, int&gt; mp; int n = messages.size(), mmax = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; int cnt = 0; bool flag = true; for(char &amp;ch: messages[i]) &#123; if(flag &amp;&amp; ch != ' ') &#123; cnt++; flag = false; &#125; else if(ch == ' ') flag = true; &#125; mp[senders[i]] += cnt; mmax = max(mmax, mp[senders[i]]); &#125; string ret = ""; for(auto it = mp.rbegin(); it != mp.rend(); it++) &#123; if(it-&gt;second == mmax) &#123; ret = it-&gt;first; break; &#125; &#125; return ret; &#125;&#125;; å› ä¸ºé¢˜ç›®è§„å®šå¤§å†™å­—æ¯çš„å­—å…¸åºå°äºŽå°å†™å­—æ¯ï¼Œæ‰€ä»¥è¦æŒ‘å‡ºé¢˜ç›®è§„å®šçš„å­—å…¸åºæœ€å¤§çš„é‚£ä¸ªäººã€‚é¢˜ç›®è™½ç„¶è¯´äº†å¼€å¤´å’Œç»“å°¾æ²¡æœ‰å¤šä½™çš„ç©ºæ ¼ï¼Œä½†æ˜¯ä¸­é—´æ²¡ä¿è¯ï¼Œæ‰€ä»¥æ²¡æœ‰ç›´æŽ¥ç»Ÿè®¡ç©ºæ ¼æ•°ï¼Œè€Œæ˜¯å½“é‡åˆ°å•è¯æ—¶ç»Ÿè®¡ã€‚å¦å¤–ï¼Œæ³¨æ„åå‘è¿­ä»£å™¨çš„éåŽ†æ“ä½œã€‚çœ‹äº†å…¶ä»–äººçš„é¢˜è§£ï¼Œå‘çŽ°è¿™é¢˜åŽ‹æ ¹æ²¡æœ‰ä¸­é—´æœ‰å¤šä½™ç©ºæ ¼çš„ç”¨ä¾‹...ðŸ˜‚æ‰€ä»¥ï¼Œæ”¹ç®€å•ä¸€ç‚¹ï¼š123456789101112131415161718192021222324class Solution &#123;public: string largestWordCount(vector&lt;string&gt;&amp; messages, vector&lt;string&gt;&amp; senders) &#123; map&lt;string, int&gt; mp; int n = messages.size(), mmax = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; int cnt = 0; bool flag = true; for(char &amp;ch: messages[i]) &#123; if(ch == ' ') cnt++; &#125; mp[senders[i]] += ++cnt; mmax = max(mmax, mp[senders[i]]); &#125; string ret = ""; for(auto it = mp.rbegin(); it != mp.rend(); it++) &#123; if(it-&gt;second == mmax) &#123; ret = it-&gt;first; break; &#125; &#125; return ret; &#125;&#125;; 2285. Maximum Total Importance of RoadsAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹æ„æ€ï¼Œå¤§è‡´é¢˜æ„æ˜¯å¦‚ä½•å®‰æŽ’ç»“ç‚¹çš„å€¼æ‰èƒ½ä½¿å¾—æ¯æ¡è·¯ä¸Šç»“ç‚¹å’Œçš„æ€»å’Œæœ€å¤§ã€‚å½“æ—¶ä¸€çœ¼çœ‹åˆ°é¢˜ç›®ï¼Œä»¥ä¸ºæ˜¯æœ€çŸ­è·¯çš„é€†æ€ç»´â€”â€”æœ€é•¿è·¯ï¼Œæƒ³äº†ä¸€ä¼šï¼Œæ²¡ä»€ä¹ˆå…·ä½“çš„æ€è·¯ï¼Œå°±æ”¾å¼ƒäº†ã€‚çŽ°åœ¨çœ‹äº†æç¤ºåŽï¼Œå‘çŽ°è¿™ä¸ªé¢˜å…¶å®žè·Ÿæœ€çŸ­è·¯æ²¡æœ‰å…³ç³»ï¼Œç®—æ˜¯æ¶‰åŠåˆ°å›¾çš„ç»“ç‚¹çš„åº¦çš„è´ªå¿ƒé¢˜ã€‚ä¸ºäº†ä½¿ç»“æžœèƒ½è¾¾åˆ°æœ€å¤§ï¼Œéœ€è¦æŒ‰ç…§ç»“ç‚¹çš„åº¦æ¥ç»™ç»“ç‚¹å®‰æŽ’å€¼ï¼Œåº¦è¶Šå¤§çš„ç»“ç‚¹å…¶å€¼å°±è¶Šå¤§ï¼Œè¿™æ ·åœ¨æœ€ç»ˆè®¡ç®—æ—¶ï¼Œæ‰èƒ½å¾—åˆ°æœ€å¤§å€¼ã€‚ Codeæ€è·¯æ˜¯ç»Ÿè®¡ + æŽ’åº + è´ªå¿ƒï¼Œçœ‹äº†æç¤ºåŽæ‰æƒ³åˆ°çš„ï¼š12345678910111213141516171819202122class Solution &#123;public: long long maximumImportance(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; cities(n); for(auto &amp;v: roads) &#123; cities[v[0]]++; cities[v[1]]++; &#125; vector&lt;int&gt; indices(n); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return cities[i] &gt; cities[j]; &#125;); int val = n; for(int i = 0; i &lt; n; i++) &#123; cities[indices[i]] = val--; &#125; long long ret = 0; for(auto &amp;v: roads) &#123; ret += (cities[v[0]] + cities[v[1]]); &#125; return ret; &#125;&#125;; å…ˆç»Ÿè®¡ç»“ç‚¹çš„åº¦ï¼Œç„¶åŽå†æŒ‰ç…§ç»“ç‚¹åº¦çš„å¤§å°å¯¹ä¸‹æ ‡æŽ’åºï¼Œå†æŒ‰ç…§åº¦çš„å¤§å°ç»™ç»“ç‚¹èµ‹å€¼ï¼Œæœ€åŽç´¯åŠ æ‰€æœ‰é“è·¯çš„é‡è¦æ€§å³å¯ã€‚è¿™ç§å¯¹ä¸‹æ ‡æŽ’åºçš„æ–¹æ³•æ˜¯ç¬¬ä¸€æ¬¡å‚åŠ å‘¨èµ›æ—¶ï¼Œä»Žå¤§ä½¬å†™çš„ç¬¬ä¸‰ä¸ªé¢˜çš„é¢˜è§£å­¦æ¥çš„ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜å®Œå…¨å¯ä»¥ä¸ç”¨æŒ‰ç…§åº¦ç»™ä¸‹æ ‡æŽ’åºï¼Œå¯¹åº¦æŽ’åºåŽç›´æŽ¥åšè®¡ç®—å°±å¯ä»¥äº†ï¼Œå› ä¸ºæ¯ä¸ªç»“ç‚¹è¢«è®¡ç®—çš„æ¬¡æ•°å°±æ˜¯å…¶åº¦çš„å€¼ï¼Œæ‰€ä»¥å¯ä»¥å†™çš„ç®€å•ä¸€äº›ï¼š12345678910111213141516class Solution &#123;public: long long maximumImportance(int n, vector&lt;vector&lt;int&gt;&gt;&amp; roads) &#123; vector&lt;int&gt; degree(n + 1); for(auto &amp;v: roads) &#123; degree[v[0]]++; degree[v[1]]++; &#125; sort(degree.begin(), degree.end()); long long ret = 0; for(int i = 0; i &lt;= n; i++) &#123; ret += i * (long long)degree[i]; &#125; return ret; &#125;&#125;; PSï¼šæ³¨æ„ç›¸ä¹˜æ—¶å¯èƒ½ä¼šæº¢å‡ºã€‚ 2286. Booking Concert Tickets in GroupsAnalysisè·Ÿä¸Šå‘¨ä¸€æ ·ï¼Œæœ€åŽä¸€ä¸ªé¢˜ä¹Ÿæ˜¯è®¾è®¡é¢˜ã€‚æƒ³äº†æŒºä¹…çš„ï¼Œè¿˜æ˜¯æ²¡æƒ³å‡ºæ¥ðŸ˜­ï¼Œé¢˜æ„å°±ä¸è¯´äº†ã€‚çœ‹äº†ä¸‹æç¤ºè·Ÿæ ‡ç­¾ï¼Œè¿™ä¸ªé¢˜å¥½åƒè¿˜æ˜¯åœ¨è€ƒçº¿æ®µæ ‘... Codeå‚è€ƒé¢˜è§£ï¼šçº¿æ®µæ ‘äºŒåˆ†ï¼ˆPython/Java/C++/Goï¼‰ çœ‹äº†åŠå¤©é¢˜è§£è·Ÿè§†é¢‘æ²¡çœ‹æ‡‚ï¼Œä¼°è®¡æ˜¯å†…åŠ›ä¸å¤ªå¤Ÿï¼Œå…ˆç•™ç€å§ðŸ˜‚ã€‚ Summaryçº¿æ®µæ ‘çœ‹çš„æ™•ä¹Žä¹Žçš„ã€‚ã€‚å¯æƒœè¿™ä¸ªç¬¬ä¸‰ä¸ªé¢˜æ²¡åšå‡ºæ¥ï¼Œæœ¬æ¥åº”è¯¥å¥½åƒå·®ä¸å¤šç®—æ˜¯å¯ä»¥åšå‡ºæ¥çš„å§ðŸ˜‚ï¼Œä¸‹æ¬¡äº‰å–ä¸€å®šã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€ŠHeart of Goldã€‹ç®€æ˜“å‰ä»–è°±]]></title>
    <url>%2F2022%2F05%2F29%2F%E3%80%8AHeart-of-Gold%E3%80%8B%E7%AE%80%E6%98%93%E5%90%89%E4%BB%96%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[æ‘‡æ»šè€ç‚® Neil Young 1971 å¹´ 26 å²å†™çš„æ­Œ... ç›¸å½“å–œæ¬¢è¿™é¦–æ­Œ...ä¸èƒ½ç®—æ˜¯è‡ªå·±ä¸¥æ ¼å•ç‹¬é è€³æœµå¬æ‰’ä¸‹æ¥çš„ï¼Œç»“åˆäº†åˆ«äººçš„æ¼”å¥ç¤ºèŒƒæ‰’çš„ã€‚ ç¤ºèŒƒï¼š æ•´é¦–æ­Œéƒ½æŒºå®¹æ˜“çš„ï¼Œåªæ˜¯æœ‰ä¸€äº›åœ°æ–¹è¦æ³¨æ„ä¸€ä¸‹ã€‚å‰å¥ï¼š123456Em7 D EmEm7 D EmEm C D GEm C D GEm C D GEm7 D Em å‰å¥æ³¨æ„çš„åœ°æ–¹å°±æ˜¯ Em å’Œå¼¦çš„å‡»å¼¦ï¼ŒEm7 -&gt; D çš„è¿žç»­ä¸‹æ‰«ï¼Œ4åˆ†ã€8 åˆ†éŸ³ç¬¦å’Œ 16 åˆ†éŸ³ç¬¦çš„åˆ‡æ¢ã€‚æ€»ä½“æ¥è¯´ï¼Œéš¾ç‚¹åœ¨èŠ‚å¥æ„Ÿè·Ÿå³æ‰‹åŠŸå¤«ä¸Šã€‚æ¼”å”± + é—´å¥ + ç»“å°¾ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Heart of gold1 = G Tepo 4/4Em C D G I want to live, I want to giveEm C D G I&apos;ve been a miner for a heart of goldEm C D G It&apos;s these expressions i never giveEm7 G C G keep me searching for a heart of gold, and I&apos;m getting oldEm7 G C G keep me searching for a heart of gold, and I&apos;m getting old(interlude start)Em C D GEm C D GEm C D GEm7 D Em(end)Em C D G I&apos;ve to been to Hollywood, I&apos;ve been to RedwoodEm C D G I Crossed the ocean for a heart of goldEm C D G I&apos;ve been in my mind, it&apos;s such a fine lineEm7 G C G keep me searching for a heart of gold, and I&apos;m getting oldEm7 G C G keep me searching for a heart of gold, and I&apos;m getting old(interlude start)Em C D GEm C D GEm C D GEm7 D Em(end)Em7 D Em keep me searching for a heart of goldEm7 D Em You keep me searching and I&apos;m growing oldEm7 D Em keep me searching for a heart of goldEm7 G C G I&apos;ve been a miner of heart of gold é¦–å…ˆæ˜¯é—´å¥ï¼Œå’Œå¼¦èµ°å‘å’ŒèŠ‚å¥ä¸Žå‰å¥ä¸€æ ·ï¼›ä¸­é—´ä¸¤æ®µæ¼”å”±éƒ¨åˆ†ä¹Ÿä¸€æ ·ï¼Œéš¾ç‚¹åœ¨ Em7 -&gt; G -&gt; C -&gt; G è¿™é‡Œï¼Œéœ€è¦æ³¨æ„è¿žç»­çš„ 8 åˆ† + åŽ 16 çš„è¿žç»­æ‰«å¼¦å’Œ C å’Œå¼¦çš„ç©ºæ‹ä¸Žå»¶éŸ³ï¼Œéœ€è¦ä¸€å®šçš„èŠ‚å¥æ„Ÿï¼›æœ€åŽä¸€æ®µ Em7 -&gt; D -&gt; Em çš„èŠ‚å¥ä¸Žé—´å¥æœ‰å·®åˆ«ï¼Œä½†ä¸Ž Em7 -&gt; G -&gt; C -&gt; G ç±»ä¼¼ï¼Œå¤šçœ‹çœ‹è§†é¢‘å°±å¯ä»¥äº†ã€‚å¦å¤–ï¼Œåœ¨è¿žç»­ä¸‹æ‰«çš„æ—¶å€™ï¼Œä¸ºäº†çªå‡ºå±‚æ¬¡æ„Ÿï¼Œå¯ä»¥åœ¨ä¸€æ‹è¿žæ‰« 2 ä¸‹ 4 5 å¼¦ï¼ˆæˆ–è€… 4 5 6 ï¼‰å¼¦ã€‚ æ€»ä½“æ¥è¯´ï¼Œè¿™é¦–æ­Œæ²¡æ¨ªæŒ‰ï¼Œæ‰€ä»¥å·¦æ‰‹åŸºæœ¬æ²¡éš¾åº¦ï¼Œéš¾ç‚¹åœ¨å³æ‰‹çš„æ‰«å¼¦ä¸ŽèŠ‚å¥æ„Ÿä¸Šã€‚ä¸è¿‡è¦æƒ³è·ŸåŽŸç‰ˆå·®ä¸å¤šï¼Œéœ€è¦ä¸€æŠŠæ‰«å¼¦å£°éŸ³é›†ä¸­ã€ç²—çŠ·ä¸€ç‚¹çš„ç´ï¼Œå¹¶ä¸”æ’ä¸ŠéŸ³å“ï¼Œç”¨æ‹¨ç‰‡æ‰«ã€‚ è¯´å›žæ¥è¿™é¦–æ­Œï¼Œå†™çš„ç›¸å½“ä¸é”™ï¼Œåˆå¥½å¼¹ï¼Œåˆå¥½å¬ï¼Œåˆæœ‰æ·±åº¦ï¼Œå…¶ä¸­çš„ä¸€å¥æ­Œè¯è¿˜è´´åœ¨æˆ‘å³è¾¹çš„ç®€ä»‹é‡Œé¢ã€‚Heart of gold å•Šï¼Œæ€Žä¹ˆæ ·æ‰èƒ½æ‰¾åˆ° Heart of gold å•Šï¼Œè¿™å¯¹æ¯ä¸ªäººè€Œè¨€éƒ½æ˜¯å€¼å¾—ç”¨ä¸€ç”Ÿæ€è€ƒçš„é—®é¢˜ã€‚ä¹Ÿè®¸å¯¹è€æ¨è€Œè¨€ï¼ŒHeart of gold æ˜¯ç»™è‡ªå·±çš„ä¸€ç§è¿½æ±‚ï¼Œå¹¶ä¸”æ˜¯è¦æ—¶æ—¶åˆ»åˆ»è´¯å½»çš„è¿™ç§è¿½æ±‚ã€‚æ­£å¦‚æ­¤ï¼Œä»–æ‰èƒ½åœ¨ã€ŠHey hey my myã€‹ä¸­å¤§å”± Rockâ€™nâ€™Roll can never dieï¼Œçˆ†å‘å‡ºæ¥çš„ç”Ÿå‘½åŠ›ã€æ„ŸæŸ“åŠ›å¦‚æ­¤ä¹‹å¼ºã€‚ æƒ³æƒ³è€æ¨ 26 å²å†™çš„è¿™é¦–æ­Œï¼ŒDylan 20 å²å†™çš„ã€ŠBlowing in the windã€‹ï¼Œç½—å¤§ä½‘ 20 å²å†™çš„ã€Šæ­Œã€‹ï¼Œè¿™äº›å®¶ä¼™æ€Žä¹ˆéƒ½æ˜¯å¹´çºªè½»è½»å°±èƒ½å†™å‡ºè¿™ä¹ˆæœ‰æ·±åº¦çš„æ­ŒðŸ˜­ã€‚ ...ä¸å†™ï¼Œæˆ‘æ€Žä¹ˆå¬å•ŠðŸ˜‚ã€‚è¯è¯´ï¼Œæ‰‹å¤´ä¸Š G è°ƒå£ç´æ­‡èœäº†ï¼Œç­‰æ—¥åŽåœ¨æ‰’æ‰’å£ç´çš„è°±å­ã€‚ å¿˜è®°åˆ†æžä¸€ä¸‹å’Œå¼¦äº†ï¼šè¿™æ˜¯é¦– G è°ƒçš„æ­Œï¼Œæ€»ä½“æ¥è®²ï¼Œæœ‰ 3 ä¸ªå’Œå¼¦èµ°å‘ï¼š Em7 -&gt; D -&gt; Emï¼Œä¹Ÿå°±æ˜¯ 6/7 -&gt; 5 -&gt; 6ï¼ŒEm7 çš„ç»„æˆéŸ³æ˜¯ 3ã€5ã€7ã€2ï¼Œæ­£å¥½å¯ä»¥ç”¨ D æ¥è¡”æŽ¥ã€‚ Em -&gt; C -&gt; D -&gt; Gï¼Œä¹Ÿå°±æ˜¯ 6 -&gt; 4 -&gt; 5 -&gt; 1ï¼Œè€å¥—è·¯äº†ã€‚ Em7 -&gt; G -&gt; C -&gt; Gï¼Œä¹Ÿå°±æ˜¯ 6/7 -&gt; 1 -&gt; 4 -&gt; 1ï¼Œè¿™ä¸ªåº”è¯¥åªæ˜¯ä¸ºäº†ç¬¦åˆä¸»æ—‹å¾‹ç¼–çš„å§ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 294 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F29%2FLeetcode-%E7%AC%AC-294-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šå‘¨çš„å‘¨èµ›...è¿™å‘¨é€€åŒ–æˆå•é¢˜é€‰æ‰‹äº†ðŸ˜‚ 2278. Percentage of Letter in StringAnalysisç¬¬ä¸€ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œç»Ÿè®¡ä¸‹æ¬¡æ•°ï¼Œå†ç®—ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š12345678910class Solution &#123;public: int percentageLetter(string s, char letter) &#123; int cnt = 0; for(char c: s) &#123; if(c == letter) cnt++; &#125; return cnt * 100 / s.length(); &#125;&#125;; 2280. Minimum Lines to Represent a Line ChartAnalysisè¿™æ˜¯ç¬¬ä¸‰ä¸ªé¢˜ï¼Œä½†æ˜¯æ˜¯è‡ªå·±ç¬¬äºŒä¸ªæäº¤çš„é¢˜ã€‚é¢˜æ„ä¸éš¾ç†è§£ï¼Œå°±æ˜¯æ‰¾å‡ºæ•´ä¸ªæŠ˜çº¿å›¾ä¸­æ‰€æœ‰æ–œçŽ‡ä¸åŒçš„çº¿æ®µã€‚å½“æ—¶çš„æ€è·¯æ˜¯ï¼Œç”¨ä¸€ä¸ªå˜é‡ç»Ÿè®¡çº¿æ®µæ•°ï¼ŒæŒ¨ä¸ªç®—ç›¸é‚»ç‚¹æž„æˆçš„ç›´çº¿çš„æ–œçŽ‡ï¼Œç›¸åŒå°±å¿½ç•¥ï¼Œä¸åŒå°±åŠ  1ã€‚æœ¬æ¥ä¸€å¼€å§‹æ˜¯æ‰“ç®—ç›´æŽ¥ç”¨ set çš„ï¼Œä½†æ˜¯åŽæ¥æƒ³åˆ°ï¼Œæ–œçŽ‡ç›¸ç­‰ä½†ä¸æ˜¯ç›¸é‚»çš„çº¿æ®µï¼Œæ˜¯ä¸åŒçš„ä¸¤æ¡çº¿æ®µã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼Œæ­»åœ¨ 58 ä¸ªç”¨ä¾‹äº†ã€‚1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; int cnt = 1; int prek = (stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); int curk; sort(stockPrices.begin(), stockPrices.end()); for(int i = 2; i &lt; size; i++) &#123; curk = (stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; ä¸Šé¢çš„ä»£ç æœ‰ç‚¹å°é—®é¢˜ï¼Œé‚£å°±æ˜¯åœ¨å¼€å§‹è®¡ç®—ä¹‹å‰ï¼Œå°±åº”è¯¥æŽ’åºã€‚1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; int prek = (stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); int curk; for(int i = 2; i &lt; size; i++) &#123; curk = (stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; æ¢äº†ä¸‹ä½ç½®ï¼Œåˆè¢«å¡åœ¨ç¬¬ 62 ä¸ªç”¨ä¾‹äº†ã€‚çœ‹äº†ä¸‹é¢˜è§£ï¼Œå‘çŽ°è¿™æ˜¯ä¸ªç²¾åº¦é—®é¢˜ï¼Œç›´æŽ¥ç”¨é™¤æ³•ä¼šæŸå¤±å°æ•°ï¼Œé€ æˆæœ¬ä¸è¯¥ç›¸ç­‰çš„æ–œçŽ‡ç›¸ç­‰äº†ï¼Œè¿™æ ·å°±æ¼è§£äº†ã€‚å°†intæ¢æˆdoubleä¼šè¢«å¡åœ¨ç¬¬ 80 ä¸ªç”¨ä¾‹ã€‚å¹¸è¿çš„æ˜¯ï¼ŒC++ æä¾›äº†long doubleè¿™ç§ 16 ä¸ªå­—èŠ‚çš„åŸºæœ¬ç±»åž‹ï¼Œå°±å¯ä»¥ç›´æŽ¥ç”¨é™¤æ³•äº†ã€‚1234567891011121314151617class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; long double prek = (long double)(stockPrices[1][1] - stockPrices[0][1]) / (stockPrices[1][0] - stockPrices[0][0]); long double curk; for(int i = 2; i &lt; size; i++) &#123; curk = (long double)(stockPrices[i][1] - stockPrices[i - 1][1]) / (stockPrices[i][0] - stockPrices[i - 1][0]); if(curk != prek) cnt++; prek = curk; &#125; return cnt; &#125;&#125;; ä½†è¿™ä¸ªé¢˜ï¼Œè¿˜å¯ä»¥ä»Žåˆ¤æ–­ 3 ç‚¹æ˜¯å¦å…±çº¿çš„è§’åº¦æ€è€ƒï¼Œä¹Ÿå°±æ˜¯å‘é‡çš„å‰ç§¯ã€‚123456789101112131415class Solution &#123;public: int minimumLines(vector&lt;vector&lt;int&gt;&gt;&amp; stockPrices) &#123; int size = stockPrices.size(); if(size == 1) return 0; sort(stockPrices.begin(), stockPrices.end()); int cnt = 1; for(int i = 2; i &lt; size; i++) &#123; long long x1 = stockPrices[i][0] - stockPrices[i - 1][0], y1 = stockPrices[i][1] - stockPrices[i - 1][1]; long long x2 = stockPrices[i - 1][0] - stockPrices[i - 2][0], y2 = stockPrices[i - 1][1] - stockPrices[i - 2][1]; if(y1 * x2 != y2 * x1) cnt++; &#125; return cnt; &#125;&#125;; å½“ç„¶ï¼Œåˆ¤æ–­ 3 ç‚¹æ˜¯å¦å…±çº¿è¿˜å¯ä»¥è®¡ç®—è¿™ 3 ä¸ªç‚¹ç»„æˆçš„ä¸‰è§’å½¢é¢ç§¯æ˜¯å¦ä¸º 0ï¼Œè€Œä¸‰è§’å½¢çš„é¢ç§¯è®¡ç®—å…¬å¼æ—¢å¯ä»¥ç”¨å‘é‡ï¼Œä¹Ÿå¯ä»¥ç”¨æµ·ä¼¦å‡¯å‹’å…¬å¼ã€‚ 2279. Maximum Bags With Full Capacity of RocksAnalysisè¿™æ˜¯ç¬¬äºŒä¸ªé¢˜ï¼Œä¸€çœ‹å°±æ˜¯èƒŒåŒ…é—®é¢˜ï¼ŒåŸºæœ¬æ²¡åšè¿‡ç±»ä¼¼çš„é¢˜ï¼Œå°±ç›´æŽ¥å¼ƒäº†ã€‚ä¸Šä¸€æ¬¡åšçš„æ—¶å€™ï¼Œæ˜¯æ˜¥èµ›çš„ç¬¬äºŒé¢˜ï¼Œè¿™æ¬¡å¾—æŠŠä¸¤ä¸ªé¢˜éƒ½æžå®šã€‚ä»”ç»†ä¸€çœ‹è¿™ä¸ªé¢˜ï¼Œå®žé™…ä¸Šæ˜¯ä¸ªè´ªå¿ƒçš„é¢˜ç›®ã€‚ä¸ºäº†å¾—åˆ°è£…æ»¡çŸ³å¤´çš„èƒŒåŒ…çš„æœ€å¤§æ•°é‡ï¼Œæœ€å¼€å§‹æ”¾çŸ³å¤´çš„èƒŒåŒ…ä¸€å®šæ˜¯å¿«è£…æ»¡çš„èƒŒåŒ…ã€‚ Codeæ²¡æƒ³åˆ°å›žè¿‡ç¥žæ¥æƒ³åˆ°çš„ç¬¬ä¸€ç§è§£æ³•æ˜¯é‡æ–°æž„é€ ç»“æž„ä½“åœ¨æŽ’åº...1234567891011121314151617181920212223242526class Solution &#123;public: struct package&#123; long long remain, size, now; package(): remain(0), size(0), now(0)&#123;&#125; &#125;; int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; int n = capacity.size(); package pak[n]; for(int i = 0; i &lt; n; i++) &#123; pak[i].size = capacity[i]; pak[i].now = rocks[i]; pak[i].remain = pak[i].size - pak[i].now; &#125; sort(pak, pak + n, [](package a, package b) &#123; return a.remain &lt; b.remain; &#125;); int cnt = 0; for(int i = 0; i &lt; n; i++) &#123; if(pak[i].remain != 0) &#123; additionalRocks -= pak[i].remain; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(pak[i].remain == 0) cnt++; &#125; return cnt; &#125;&#125;; å®žé™…ä¸Šç”¨ multiset å°±å¯ä»¥äº†ã€‚12345678910111213141516171819class Solution &#123;public: int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; multiset&lt;int&gt; remains; int n = capacity.size(); for(int i = 0; i &lt; n; i++) &#123; remains.insert(capacity[i] - rocks[i]); &#125; int cnt = 0; for(auto &amp;i: remains) &#123; if(i != 0) &#123; additionalRocks -= i; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(i == 0) cnt++; &#125; return cnt; &#125;&#125;; ä½¿ç”¨ multiset å®¹å™¨çš„æ—¶é—´ã€ç©ºé—´æ¶ˆè€—éƒ½å¾ˆå¤§ï¼Œä¸å¦‚ç›´æŽ¥æ¢æˆ vectorï¼Œç„¶åŽæŽ’åºã€‚1234567891011121314151617181920class Solution &#123;public: int maximumBags(vector&lt;int&gt;&amp; capacity, vector&lt;int&gt;&amp; rocks, int additionalRocks) &#123; vector&lt;int&gt; remains; int n = capacity.size(); for(int i = 0; i &lt; n; i++) &#123; remains.push_back(capacity[i] - rocks[i]); &#125; sort(remains.begin(), remains.end()); int cnt = 0; for(auto &amp;i: remains) &#123; if(i != 0) &#123; additionalRocks -= i; if(additionalRocks &gt;= 0) cnt++; else break; &#125; else if(i == 0) cnt++; &#125; return cnt; &#125;&#125;; æžœç„¶ï¼Œå¿«å¤šäº†...è¿™ä¹ˆä¸€çœ‹çš„è¯ï¼Œè¿™ä¸ªé¢˜å½“æ—¶æ˜¯å¯ä»¥åšå‡ºæ¥çš„ï¼Œæ²¡ç»è¿‡ä»”ç»†æ€è€ƒï¼Œç›´æŽ¥è®¤ä¸ºè¿™ä¸ªé¢˜éœ€è¦ç”¨ dfs æ¥æ±‚è§£...å¤§æ„å¤±è†å·žäº†å•Š~ 2281. Sum of Total Strength of WizardsAnalysisé¢˜æ„ä¸éš¾ç†è§£ï¼Œå°±æ˜¯ç®—å‡ºæ‰€æœ‰å­æ•°ç»„æœ€å°å€¼ä¸Žå¯¹åº”çš„å’Œçš„ç§¯ç„¶åŽå†ç›¸åŠ ã€‚ å‚è€ƒæ€è·¯ï¼šè®¡ç®—æ¯ä¸ªæ•°å­—ä½œä¸ºæœ€å°å€¼çš„è´¡çŒ®ã€‚ å¦‚è¿™ç¯‡é¢˜è§£æ‰€è¯´å…ˆåšä¸€ä¸‹ 907 æ¯”è¾ƒå¥½ã€‚ä»”ç»†æ‹†åˆ†ä¸‹æ¥è¿™ä¸ªé¢˜å®žé™…ä¸Šæ˜¯å‰ç¼€å’Œ + å•è°ƒæ ˆ + æ•°å­¦ï¼Œä¸è¿‡è‡ªå·±èƒ½å•ç‹¬åšå‡ºæ¥ï¼Œä¼°è®¡å¾—å¾ˆé•¿ä¸€æ®µæ—¶é—´åŽäº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: const int mod = 1e9 + 7; int totalStrength(vector&lt;int&gt;&amp; strength) &#123; int n = strength.size(); stack&lt;int&gt; st; vector&lt;int&gt; left(n, -1), right(n, n); for(int i = 0; i &lt; n; i++) &#123; while(!st.empty() &amp;&amp; strength[st.top()] &gt; strength[i]) &#123; right[st.top()] = i; st.pop(); &#125; if(!st.empty()) left[i] = st.top(); st.push(i); &#125; vector&lt;int&gt; psum = strength; for(int i = 1; i &lt; n; i++) &#123; psum[i] = (psum[i] + psum[i - 1]) % mod; &#125; vector&lt;int&gt; ppsum = psum; for(int i = 1; i &lt; n; i++) &#123; ppsum[i] = (ppsum[i] + ppsum[i - 1]) % mod; &#125; auto f = [&amp;](int l, int r) &#123; if(r &lt; 0) return 0; if(l &lt; 0) return ppsum[r]; return (ppsum[r] - ppsum[l] + mod) % mod; &#125;; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; int l = left[i] + 1, r = right[i] - 1; long long sleft = 1ll * f(l - 2, i - 1) * (r - i + 1) % mod; long long sright = 1ll * f(i - 1, r) * (i - l + 1) % mod; ret += 1ll * strength[i] * (((sright - sleft) + mod) % mod) % mod; ret %= mod; &#125; return ret; &#125;&#125;; Summaryè¿™æ¬¡å‘¨èµ›å¤§æ„äº†ï¼Œæœ¬æ¥ç¬¬äºŒä¸ªé¢˜å¯ä»¥åšçš„ï¼Œç»“æžœæŠŠæ—¶é—´éƒ½èŠ±åœ¨ç¬¬ä¸‰ä¸ªé¢˜ä¸Šäº†ï¼ˆå¤§è‡´æ€è·¯æ˜¯å¯¹çš„ï¼Œä½†æ²¡åšå‡ºæ¥ï¼‰ã€‚ç¬¬äºŒé¢˜çš„ä¸»è¦é—®é¢˜æ˜¯ï¼Œæžé”™é¢˜ç›®ç±»åž‹äº†ï¼Œç„¶åŽå°±æ”¾æŽ‰äº†...ç¬¬ä¸‰é¢˜å…¶å®žæ˜¯æ¯æ—¥ä¸€é¢˜è§è¿‡çš„ç±»ä¼¼é¢˜ç›®ï¼Œä½†æ˜¯å‡çº§åˆ°ä¸­ç­‰é¢˜å°±åšä¸å‡ºæ¥äº†...ç¬¬å››é¢˜æ˜¯ä¸ªå¾ˆä¸é”™çš„å•è°ƒæ ˆ + å‰ç¼€å’Œçš„ç»¼åˆé¢˜ï¼ŒèŠ±æ—¶é—´æŠŠè¿™ä¸ªé¢˜åƒé€åº”è¯¥èƒ½æœ‰æ‰€å€¼ã€‚ æ€»ä¹‹ï¼Œè¿™å‘¨çš„å‘¨èµ›æœ‰ç‚¹äºðŸ˜­ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_vector å®¹å™¨çš„å¸¸è§ç”¨æ³•]]></title>
    <url>%2F2022%2F05%2F28%2FC-vector-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[æ¢³ç†ä¸€ä¸‹ vector çš„å¸¸è§ç”¨æ³•ã€‚C++ çš„ vector æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªåŠ¨æ€æ•°ç»„ï¼Œä¹Ÿå°±æ˜¯å¯ä»¥è‡ªåŠ¨æ‰©å®¹çš„æ•°ç»„ï¼Œå…·ä½“å¦‚ä½•å®žçŽ°è¿™é‡Œä¸æ·±ç©¶ã€‚å¦‚æžœè¦ä½¿ç”¨ vectorï¼Œéœ€è¦æ·»åŠ  vector å¤´æ–‡ä»¶ã€‚ åˆå§‹åŒ–vector çš„åˆå§‹åŒ–æœ‰å¾ˆå¤šç§æ–¹å¼ï¼ˆæœ¬è´¨ä¸Šå°±æ˜¯å¦‚ä½•å¦‚ä½•ä½¿ç”¨ vector æä¾›çš„æž„é€ å‡½æ•°ï¼‰ï¼š123456789101112vector&lt;int&gt; v1; // v1 æ˜¯ä¸€ä¸ªç©º vectorï¼Œå†…éƒ¨å…ƒç´ éƒ½æ˜¯ int ç±»åž‹çš„vector&lt;int&gt; v2(v1); // v2 ä¸­åŒ…å«äº† v1 æ‰€æœ‰å…ƒç´ çš„å‰¯æœ¬vector&lt;int&gt; v2 = v1; // åŒä¸Švector&lt;int&gt; v3(size, val); // v3 æ˜¯å¤§å°ä¸º sizeï¼Œå†…éƒ¨å…ƒç´ å…¨æ˜¯ val çš„ vectorvector&lt;int&gt; v4(size); // v4 çš„å¤§å°æ˜¯ sizeï¼Œå†…éƒ¨å…ƒç´ å…¨æ˜¯ 0vector&lt;int&gt; v5&#123;a, b, c, ...&#125; // v5 åŒ…å«äº†åˆå§‹å€¼ä¸ªæ•°çš„å…ƒç´ ï¼Œå‰å‡ ä¸ªå…ƒç´ è¢«èµ‹äºˆç›¸åº”çš„å€¼vector&lt;int&gt; v5=&#123;a, b, c, ...&#125; // åŒä¸Švector&lt;int&gt; v6[size] // v6 çš„å¤§å°ä¸º sizeï¼Œå†…éƒ¨æ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯å•ç‹¬çš„ vectorï¼Œé•¿åº¦ä¸é™vector&lt;vector&lt;int&gt;&gt; v6(size) //åŒä¸Švector&lt;int&gt; v7(v1.begin(), v1.begin() + k); // v7çš„å¤§å°ä¸º kï¼Œå†…éƒ¨å…ƒç´ é¡ºåºä¸Ž v1 çš„å‰ kä¸ªå…ƒç´ ä¸€è‡´vector&lt;vector&lt;int&gt;&gt; v7; // ä¸é™å®šé•¿åº¦çš„äºŒç»´ vectorvector&lt;vector&lt;int&gt;&gt; v8(size, vector&lt;int&gt;(size)); // åŒæ—¶é™å®šä¸€ç»´å’ŒäºŒç»´çš„å¤§å° ä¸Šé¢çš„intéƒ½å¯ä»¥æ¢æˆå…¶ä»–åŸºæœ¬ç±»åž‹ã€ç±»æˆ–å®¹å™¨ã€‚ è®¿é—®ä¸‹æ ‡vector è®¿é—®å…ƒç´ çš„æ–¹å¼æœ‰å¾ˆå¤šï¼Œå¯ä»¥ç”¨ç±»ä¼¼æ•°ç»„ä¸‹æ ‡çš„æ–¹å¼è®¿é—®ï¼Œæ­¤æ—¶ä¸‹æ ‡èŒƒå›´æ˜¯[0, v.size() - 1]ã€‚1234vector&lt;int&gt; v(5);v[0] = 0;v[1] = 1;v[2] = 2; è¿­ä»£å™¨STL å®¹å™¨éƒ½å¯ä»¥ç”¨è¿­ä»£å™¨æ¥è®¿é—®ã€‚12345678910111213141516#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;int&gt; v&#123;1, 2, 3, 4, 5&#125;; auto it = v.begin(); cout &lt;&lt; *it &lt;&lt; endl; cout &lt;&lt; *(++it) &lt;&lt; endl; cout &lt;&lt; *(v.begin() + 1) &lt;&lt; endl; return 0;&#125; /*out:122*/ é™¤äº†è¿­ä»£å™¨ä¸Žä¸‹æ ‡ï¼Œvector è¿˜å¯ä»¥ç”¨ä¸€äº›æˆå‘˜å‡½æ•°æ¥è®¿é—®ã€‚ è¿ç®—ç¬¦ä¸¤ä¸ª vector å¯ä»¥ç›´æŽ¥ç”¨==å’Œ!=æ¥åˆ¤æ–­ç›¸åŒä¸Žå¦ï¼Œä¹Ÿå³å…¶å†…éƒ¨å…ƒç´ æ˜¯å¦éƒ½ä¸€è‡´ã€‚123456789101112#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;int&gt; v1&#123;1, 2, 3&#125;; vector&lt;int&gt; v2&#123;1, 2, 3&#125;; if(v1 == v2) cout &lt;&lt; "Same" &lt;&lt; endl; return 0;&#125; /*out:Same*/ ç±»ä¼¼çš„è¿ç®—ç¬¦è¿˜æœ‰&lt;ã€&lt;=ã€&gt;å’Œ&gt;=ï¼Œæ¯”è¾ƒè§„åˆ™æ˜¯å†…éƒ¨å…ƒç´ çš„å­—å…¸åºã€‚ å¸¸ç”¨å‡½æ•°push_backå‘ vector å®¹å™¨æœ«å°¾æ·»åŠ å…ƒç´ ã€‚1v.push_back(x); emplace_backC++ 11 å¼•å…¥çš„æ–°å‡½æ•°ï¼Œä¸Ž push_back ç›¸æ¯”æ›´é«˜æ•ˆï¼Œç”¨æ³•åŸºæœ¬ç›¸åŒã€‚å› ä¸º push_back åªèƒ½æŽ¥å—ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æžœä¼ å…¥ä¸æ˜¯ä¸€ä¸ªåŸºç¡€æ•°æ®ç±»åž‹ï¼Œé‚£ä¹ˆå°±éœ€è¦å…ˆå°†å¯¹è±¡æž„é€ å¥½ï¼Œpush_back æ‰ä¼šå°†è¿™ä¸ªå¯¹è±¡ä¼ å…¥ vector ä¸­ã€‚12345678#include &lt;bits/stdc++.h&gt; using namespace std;int main() &#123; vector&lt;pair&lt;int, int&gt;&gt; v; v.push_back(make_pair(1, 2)); v.emplace_back(1, 2); return 0;&#125; pop_backåˆ é™¤ vector å®¹å™¨å†…æœ«å°¾å…ƒç´ ã€‚1v.pop_back(); clearæ¸…é™¤ vector å®¹å™¨å†…æ‰€æœ‰å…ƒç´ ã€‚1v.clear(); resizeé‡æ–°è®¾ç½® vector å®¹å™¨çš„å¤§å°ã€‚12vector&lt;int&gt; v(2);v.resize(5); æ³¨æ„ï¼Œresize å‡½æ•°ä¸ä¼šçœŸçš„æ”¹å˜å½“å‰å®¹å™¨çš„å¤§å°ï¼Œåªæ˜¯å°†è®°å½•å½“å‰å®¹å™¨å¤§å°çš„é‚£ä¸ªå˜é‡æ”¹æˆé‡æ–°è®¾ç½®çš„å¤§å°ã€‚ sizesize å‡½æ•°è¿”å›žå®¹å™¨çš„å¤§å°ï¼Œåœ¨æœªè®¾ç½®å¤§å°çš„æƒ…å†µä¸‹ï¼Œè¿”å›žå®¹å™¨å†…å…ƒç´ çš„ä¸ªæ•°ã€‚1v.size(); beginè¿”å›ž vector ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ã€‚1v.begin(); endè¿”å›žè¶Šç•ŒåŽçš„ç¬¬ä¸€ä¸ªä½ç½®çš„è¿­ä»£å™¨ã€‚1v.end(); rbeginè¿”å›ž vector å®¹å™¨é€†åºåŽçš„ç¬¬ä¸€ä¸ªå…ƒç´ çš„è¿­ä»£å™¨ï¼Œä¹Ÿå°±æ˜¯åŽŸåºåˆ—çš„æœ€åŽä¸€ä¸ªå…ƒç´ ã€‚1v.rbegin(); rendè¿”å›ž vector å®¹å™¨é€†åºåŽï¼Œè¶Šç•Œçš„ç¬¬ä¸€ä¸ªä½ç½®çš„è¿­ä»£å™¨ï¼Œä¹Ÿå°±æ˜¯åŽŸåºåˆ—ç¬¬ä¸€ä¸ªå…ƒç´ çš„å‰ä¸€ä¸ªä½ç½®ã€‚1v.end(); æ³¨æ„ï¼šrbegin å’Œ rend å‡½æ•°è¿”å›žçš„è¿­ä»£å™¨éƒ½æ˜¯åå‘è¿­ä»£å™¨ï¼Œ++è¿ç®—ç¬¦æ˜¯å‘å‰è¿­ä»£ï¼Œ--è¿ç®—ç¬¦æ˜¯å‘åŽè¿­ä»£ï¼Œè¿™ä¸Žæ­£å‘è¿­ä»£å™¨æ˜¯ä¸åŒçš„ï¼æ‰€ä»¥ï¼Œå¦‚æžœéœ€è¦å¯¹ vector é™åºæŽ’åºï¼Œå¯ä»¥ç›´æŽ¥å†™æˆsort(v.rbegin(), v.rend());ã€‚ frontfront å‡½æ•°è¿”å›ž vector ç¬¬ä¸€ä¸ªå…ƒç´ çš„å€¼ã€‚1v.front(); backback å‡½æ•°è¿”å›ž vector æœ€åŽä¸€ä¸ªå…ƒç´ çš„å€¼ã€‚1v.back(); insertå‘ä»»æ„è¿­ä»£å™¨ä½ç½®æ’å…¥å…ƒç´ ã€‚1v.insert(it, val); æ³¨æ„ï¼Œè¿­ä»£å™¨ it å¿…é¡»æ˜¯ v å†…çš„ã€‚ eraseåˆ é™¤è¿­ä»£å™¨ä¸º it çš„å…ƒç´ ã€‚1v.erase(it); åˆ é™¤è¿­ä»£å™¨åŒºé—´[first, last)å†…çš„æ‰€æœ‰å…ƒç´ ã€‚1v.erase(first, last);]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>Vector</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 293 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F28%2FLeetcode-%E7%AC%AC-293-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[åˆæ˜¯ä¹‹å‰çš„å‘¨èµ›~ 2273. Find Resultant Array After Removing AnagramsAnalysisä¸çŸ¥é“ä¸ºä»€ä¹ˆç®€å•é¢˜çš„é¢˜ç›®éƒ½å¥½é•¿å•Š...é¢˜æ„å°±æ˜¯åˆ é™¤è¿žç»­å‡ºçŽ°çš„å­—æ¯å¼‚ä½è¯ï¼Œåªä¿ç•™æœ€å¼€å§‹çš„å“ªä¸€ä¸ªã€‚ä½†æ˜¯è¦æ³¨æ„ï¼Œå¦‚æžœæ˜¯ç›¸éš”çš„å­—æ¯å¼‚ä½è¯ï¼Œæ˜¯ä¸ç”¨åˆ é™¤çš„ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516171819202122class Solution &#123;public: vector&lt;string&gt; removeAnagrams(vector&lt;string&gt;&amp; words) &#123; int size = words.size(); vector&lt;string&gt; ret; int i = 0; while(i &lt; size) &#123; string s1 = words[i]; ret.push_back(words[i]); sort(s1.begin(), s1.end()); int j = i + 1; while(j &lt; size) &#123; string s2 = words[j]; sort(s2.begin(), s2.end()); if(s2 != s1) break; j++; &#125; i = j; &#125; return ret; &#125;&#125;; å½“æ—¶ WA äº†ä¸€æ¬¡çš„åŽŸå› æ˜¯ï¼Œä¸€æ¬¡æ€§æŠŠæ‰€æœ‰çš„å­—æ¯å¼‚ä½è¯éƒ½åˆ é™¤äº†ï¼Œæ²¡æœ‰æ³¨æ„åªåˆ é™¤ç›¸é‚»çš„ã€‚åˆ¤æ–­æ˜¯å¦æ˜¯å¼‚ä½è¯ï¼Œå¯ä»¥ç»Ÿè®¡ä¹Ÿå¯ä»¥æŽ’åºï¼Œç›´æŽ¥æŽ’åºä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼Œä½†ç»Ÿè®¡çš„æ—¶é—´å¤æ‚åº¦æ›´ä½Žã€‚æ—¢ç„¶ä½¿ç®€å•é¢˜ï¼Œé‚£å°±æ€Žä¹ˆæ–¹ä¾¿æ€Žä¹ˆæ¥å¥½äº†ã€‚ 2274. Maximum Consecutive Floors Without Special FloorsAnalysisè¿™ä¸ªé¢˜è·Ÿä¸Šä¸€æ¬¡å‘¨èµ›çš„é¢˜ç›®å¾ˆåƒï¼Œä¸€æ ·è·ŸåŒºé—´æœ‰å…³ï¼Œæ‰€ä»¥è¿™ä¸ªé¢˜å®žé™…ä¸Šå°±æ˜¯åœ¨æ±‚åˆ†å‰²åŽçš„æœ€å¤§åŒºé—´ã€‚ Codeä¸€å¼€å§‹ä½¿ç”¨çš„æš´åŠ›æ¨¡æ‹Ÿ + hash çš„æ€è·¯ï¼š1234567891011121314151617181920class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); unordered_set&lt;int&gt; ht; for(int &amp;i: special) &#123; ht.insert(i); &#125; int maxstairs = 0; while(bottom &lt;= top) &#123; while(ht.count(bottom) &amp;&amp; bottom &lt; top) bottom++; if(bottom == top) break; int i = bottom + 1; while(i &lt;= top &amp;&amp; !ht.count(i)) i++; maxstairs = max(maxstairs, i - bottom); bottom = i; &#125; return maxstairs; &#125;&#125;; å› ä¸º special ä¸­çš„å€¼èŒƒå›´æ˜¯ $[1, 10^9]$ï¼Œæ‰€ä»¥è¶…æ—¶äº†ã€‚åŽé¢ä»”ç»†ä¸€æƒ³ï¼Œå…¶å®žåªéœ€è¦æŠŠæ¯ä¸ªåŒºé—´çš„é—´éš”ç®—å‡ºæ¥ï¼Œå…¶ä¸­çš„æœ€å¤§å€¼å°±æ˜¯éœ€è¦çš„ç»“æžœäº†ã€‚ä½†è¿™ç§åšæ³•éœ€è¦æå‰å¯¹ special æŽ’åºï¼Œå¹¶ä¸”è¦é¢å¤–è€ƒè™‘æœ€åŽçš„ topã€‚1234567891011121314151617181920212223class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); vector&lt;int&gt; tmp = special; sort(tmp.begin(), tmp.end()); if(tmp[size - 1] != top) &#123; tmp.push_back(top + 1); size++; &#125; int maxstairs = 0; for(int i = 0; i &lt; size &amp;&amp; bottom &lt; top; i++) &#123; int end = tmp[i]; if(end == bottom) &#123; bottom++; continue; &#125; maxstairs = max(maxstairs, end - bottom); bottom = ++end; &#125; return maxstairs; &#125;&#125;; å½“æ—¶èŽ«åå…¶å¦™çš„ä¸æƒ³å¯¹ special è¿™ä¸ªæ•°ç»„åšä¿®æ”¹ï¼Œå°±å¦å¤–æ‹·è´äº†ä¸€ä¸ªï¼ŒçŽ°åœ¨åˆ æŽ‰æ‹·è´ï¼š12345678910111213141516171819202122class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; int size = special.size(); sort(special.begin(), special.end()); if(special[size - 1] != top) &#123; special.push_back(top + 1); size++; &#125; int maxstairs = 0; for(int i = 0; i &lt; size &amp;&amp; bottom &lt; top; i++) &#123; int end = special[i]; if(end == bottom) &#123; bottom++; continue; &#125; maxstairs = max(maxstairs, end - bottom); bottom = ++end; &#125; return maxstairs; &#125;&#125;; å®žé™…ä¸Šï¼Œå¯ä»¥å°† bottom - 1 å’Œ top + 1 ä¹Ÿæ”¾åœ¨æ•°ç»„å†…ï¼Œä¸€èµ·è¿›è¡ŒæŽ’åºï¼Œè¿™æ ·å°±ä¸ç”¨å•ç‹¬è€ƒè™‘ top äº†ã€‚1234567891011121314class Solution &#123;public: int maxConsecutive(int bottom, int top, vector&lt;int&gt;&amp; special) &#123; special.push_back(bottom - 1); special.push_back(top + 1); sort(special.begin(), special.end()); int n = special.size(); int maxstairs = 0; for(int i = 0; i &lt; n - 1; i++) &#123; maxstairs = max(maxstairs, special[i + 1] - special[i] - 1); &#125; return maxstairs; &#125;&#125;; 2275. Largest Combination With Bitwise AND Greater Than ZeroAnalysisé¢˜æ„æ˜¯é€‰å–ç»™å®šæ•°ç»„ä¸­çš„æ•°ï¼Œè¦æ±‚è¿™äº›æ•°æŒ‰ä½ä¸ŽåŽçš„ç»“æžœå¤§äºŽ 0ï¼Œè¿”å›žæœ€é•¿ç»„åˆçš„é•¿åº¦ã€‚å®žé™…ä¸Šï¼Œè¦æƒ³æŒ‰ä½ä¸Žçš„ç»“æžœä¸ä¸º 0ï¼Œé‚£ä¹ˆåªéœ€è¦ä¿è¯æœ€åŽçš„ç»“æžœæŸä¸€ä½ä¸ä¸º 0 å³å¯ã€‚æ¢å¥è¯è¯´ï¼Œæœ€é•¿ç»„åˆçš„ä¸­çš„æ‰€æœ‰æ•°å­—è‚¯å®šåœ¨æŸä¸ª bit ä¸Šéƒ½æ˜¯ 1ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æœ€åŽçš„ç»“æžœä¸ä¸º 0ã€‚æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œåˆ†åˆ«ç»Ÿè®¡æ¯ä¸€ä½ä¸Šä¸ä¸º 0 çš„æ•°å­—ä¸ªæ•°ï¼Œä¸ªæ•°æœ€å¤šçš„å°±æ˜¯éœ€è¦è¿”å›žçš„ç»“æžœã€‚å¯æƒœè¿™ä¸ªé¢˜ï¼Œå½“æ—¶æ²¡åšå‡ºæ¥ï¼Œå¯èƒ½æ˜¯æƒ³å¤ªå¤šäº†ï¼Œæˆ–è€…è¿˜æ˜¯å¯¹ä½è¿ç®—çš„ç†è§£ä¸å¤Ÿæ·±åˆ»ã€‚ Code1234567891011121314151617class Solution &#123;public: int largestCombination(vector&lt;int&gt;&amp; candidates) &#123; int cnt[24] = &#123;0&#125;; int n = candidates.size(); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; 24; j++) &#123; if((1 &lt;&lt; j) &amp; candidates[i]) cnt[j]++; &#125; &#125; int ret = 0; for(int i = 0; i &lt; 24; i++) &#123;w reerv ret = max(ret, cnt[i]); &#125; return ret; &#125;&#125;; 2276. Count Integers in IntervalsAnalysisè¿™ä¸ªé¢˜è¿˜æ˜¯è·ŸåŒºé—´ç›¸å…³çš„é¢˜ç›®ï¼Œä¸è¿‡æ¯”ç¬¬äºŒä¸ªé¢˜å¤æ‚äº†ä¸€äº›ã€‚å½“æ—¶è¯»é¢˜çš„æ—¶å€™ï¼Œæ²¡æžæ‡‚countè¿™ä¸ªå‡½æ•°åˆ°åº•æ˜¯ä»€ä¹ˆæ„æ€ï¼Œä¸»è¦æ˜¯æ²¡è¯»æ‡‚Returns the number of integers that are present in at least one intervalã€‚äº‹åŽçœ‹äº†é¢˜è§£æ‰å‘çŽ°ï¼Œå°±æ˜¯å½“å‰åŒºé—´å†…æ•°çš„ä¸ªæ•°ã€‚æ‰€ä»¥è¿™ä¸ªå€¼å¯ä»¥å•ç‹¬ç”¨ä¸€ä¸ªå˜é‡æ¥è¿›è¡Œè®°å½•ï¼Œå¹¶åœ¨æ¯æ¬¡è°ƒç”¨addå‡½æ•°çš„æ—¶å€™ï¼Œæ›´æ–°è¿™ä¸ªå€¼ã€‚ä¸è¿‡ï¼Œæ€è€ƒè¿™ä¸ªé¢˜ç¡®å®žéœ€è¦çº¿æ®µæ ‘çš„ç›¸å…³çŸ¥è¯†ã€‚ Code12345678910111213141516171819202122232425class CountIntervals &#123; int cnt = 0; set&lt;pair&lt;int, int&gt;&gt; st;public: CountIntervals() &#123; &#125; void add(int left, int right) &#123; int l = left, r = right; auto it = st.lower_bound(&#123;left - 1, -2e9&#125;); while(it != st.end() &amp;&amp; it-&gt;second &lt;= right) &#123; l = min(l, it-&gt;second); r = max(r, it-&gt;first); cnt -= it-&gt;first - it-&gt;second + 1; st.erase(it++); &#125; cnt += r - l + 1; st.insert(&#123;r, l&#125;); &#125; int count() &#123; return cnt; &#125;&#125;; å§‘ä¸”ç®—æ˜¯ç†è§£äº†è¿™ç§åšæ³•äº†ï¼Œå¾—åœ¨åšå‡ ä¸ªç±»ä¼¼çš„é¢˜åŠ æ·±ä¸€ä¸‹å°è±¡ã€‚ Summaryå¾—å†å¼€ä¸€ä¸ªå­¦ä¹ è®¡åˆ’äº†~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 78 åœºåŒå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F25%2FLeetcode-%E7%AC%AC-78-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šä¸Šå‘¨çš„åŒå‘¨èµ›~è¿‡ 2 ä¸ªé¢˜å°±è°¢å¤©è°¢åœ°äº†ðŸ˜‚... 2269. Find the K-Beauty of a NumberAnalysisé¢˜ç›®æ„æ€ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå½“æ—¶åšçš„æ—¶å€™æ„Ÿè§‰ä¸­æ–‡çš„é¢˜å¹²å¥½åƒè¯»ä¸é€šé¡ºðŸ˜‚ã€‚æ€»ä¹‹ï¼Œç†è§£èµ·æ¥èŠ±äº†ç‚¹æ—¶é—´...é¦–å…ˆè¦æŠŠ num å½“ä½œå­—ç¬¦ä¸²ï¼Œç„¶åŽå†æ‰¾å‡ºå­—ç¬¦ä¸² num ä¸­é•¿åº¦ä¸º k ä¸”èƒ½æ•´é™¤ num çš„å­ä¸²ï¼Œè¿”å›žè¿™äº›å­ä¸²çš„ä¸ªæ•°ã€‚ç„¶åŽè¿˜æœ‰ä¸¤ä¸ªé™åˆ¶æ¡ä»¶ï¼š å…è®¸æœ‰å‰ç¼€ 0ã€‚ 0 ä¸èƒ½æ•´é™¤ä»»ä½•å€¼ã€‚ ç¬¬ä¸€ä¸ªæ¡ä»¶çœ‹ç¤ºä¾‹å¾ˆå®¹æ˜“æ˜Žç™½ï¼Œç¬¬äºŒä¸ªä¹Ÿæ˜¯å¸¸è¯†ã€‚ Codeç«žèµ›åšçš„æ—¶å€™ï¼Œè¿™ä¸ªé¢˜ WA äº†ä¸¤æ¬¡ï¼Œä¸€æ˜¯é¢˜ç›®æ²¡ç†è§£æ¸…æ¥šå°±å¼€å§‹åšäº†ï¼ŒäºŒæ˜¯æœ‰ç‚¹ç€æ€¥äº†ï¼Œå†™å¥½äº†å°±ç›´æŽ¥æäº¤ï¼Œæ²¡æœ‰è‡ªå·±ç¼–ä¸ªæ ·ä¾‹è¯•è¯•...è¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213class Solution &#123;public: int divisorSubstrings(int num, int k) &#123; string str = to_string(num); int len = str.length(), ret = 0; for(int i = 0; i &lt;= len - k; i++) &#123; string tmp = str.substr(i, k); int t = stoi(tmp); if(t != 0 &amp;&amp; num % t == 0) ret++; &#125; return ret; &#125;&#125;; ä¸ç®¡æ€Žä¹ˆè¯´ï¼ŒWA ä¸¤æ¬¡çœŸæ˜¯ä¸åº”è¯¥ã€‚å¦å¤–ï¼Œè¿™ä¸ªé¢˜ä¹Ÿå¯ä»¥ä»Žæ•°å­¦è§’åº¦æ€è€ƒï¼Œä¾æ¬¡ä»Ž num çš„æœ«å°¾å–ä¸‹ k ä½æ•°å­—ç»„æˆæ•´æ•°è¿›è¡Œåˆ¤æ–­å³å¯ã€‚1234567891011class Solution &#123;public: int divisorSubstrings(int num, int k) &#123; long long ret = 0, mask = pow(10, k); for(int x = num; x &gt;= mask / 10; x /= 10) &#123; int tmp = x % mask; if(tmp != 0 &amp;&amp; num % tmp == 0) ret++; &#125; return ret; &#125;&#125;; 2270. Number of Ways to Split ArrayAnalysisè¿™ä¸ªé¢˜ä¸€çœ‹å°±æ˜¯å‰ç¼€å’Œçš„é¢˜ç›®...å¯æƒœåˆ WA äº†ä¸€æ¬¡...WA çš„åŽŸå› æ˜¯å‰ç¼€å’Œæ•°ç»„ç”¨çš„intï¼Œåº”è¯¥è¦ç”¨long longã€‚å®žé™…ä¸Šï¼Œè¿™æ˜¯ç¬¬äºŒæ¬¡åœ¨å‘¨èµ›ä¸Šåšå‰ç¼€å’Œçš„é¢˜ç›®çŠ¯è¿™ä¸ªé”™è¯¯äº†...æ€è·¯å°±æ˜¯ç®—å‡ºå‰ç¼€å’Œï¼Œç„¶åŽä¾æ¬¡åˆ¤æ–­å³å¯ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤é€šè¿‡çš„ä»£ç ï¼š12345678910111213141516171819class Solution &#123;public: int waysToSplitArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;long long&gt; prefixsum(size); int ret = 0; prefixsum[0] = nums[0]; for(int i = 1; i &lt; size; i++) &#123; prefixsum[i] = prefixsum[i - 1] + nums[i]; &#125; for(int i = 0; i &lt; size; i++) &#123; if(i &lt; size - 1 &amp;&amp; prefixsum[i] &gt;= (prefixsum[size - 1] - prefixsum[i])) &#123; ret++; cout &lt;&lt; prefixsum[i] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; endl; &#125; &#125; return ret; &#125;&#125;; è™½ç„¶å¯ä»¥é€šè¿‡ï¼Œä½†æ˜¯ä»£ç æ€è·¯ä¸å¤Ÿæ¸…æ™°ï¼Œæ”¹ä¸€ä¸‹ï¼š12345678910111213class Solution &#123;public: int waysToSplitArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), ret = 0; long long left = 0, right = accumulate(nums.begin(), nums.end(), 0LL); for(int i = 0; i &lt; size - 1; i++) &#123; left += nums[i]; right -= nums[i]; if(left &gt;= right) ret++; &#125; return ret; &#125;&#125;; 2271. Maximum White Tiles Covered by a CarpetAnalysisé¢˜æ„å¾ˆæ¸…æ™°ï¼Œè¿”å›žç›–ä½æœ€å¤šçš„ç“·ç –æ•°ç›®ã€‚æ¢æˆæ•°å­¦è¯­è¨€å°±æ˜¯ï¼Œå¦‚ä½•è®©æ›´å¤šçš„ç¬¦åˆæ¡ä»¶çš„æ•°ï¼ˆç“·ç –ï¼‰è½åœ¨åŒºé—´é•¿åº¦ä¸º carpetlen çš„åŒºé—´ä¸­ã€‚è¿™ä¸ªé¢˜æƒ³äº†æŒºä¹…çš„ï¼Œç†è§£æ¸…æ¥šé¢˜ç›®æ„æ€åŽï¼Œå°±æ„Ÿè§‰è¿™æ˜¯ä¸ªåŒºé—´è´ªå¿ƒçš„é—®é¢˜ï¼Œä½†æ˜¯æ²¡åšè¿‡ç±»ä¼¼çš„é—®é¢˜...è¿˜æ˜¯é¢˜åšå°‘äº†ã€‚ Codeè¿™ä¸ªé¢˜çš„æ€è·¯æ˜¯æŽ’åº + æ»‘åŠ¨çª—å£ + è´ªå¿ƒï¼š1234567891011121314151617class Solution &#123;public: int maximumWhiteTiles(vector&lt;vector&lt;int&gt;&gt;&amp; tiles, int carpetLen) &#123; sort(tiles.begin(), tiles.end()); long long now = 0, ans = 0; for(int i = 0, j = 0; i &lt; tiles.size(); i++) &#123; while(j &lt; tiles.size() &amp;&amp; tiles[j][1] + 1 - tiles[i][0] &lt;= carpetLen) &#123; now += tiles[j][1] - tiles[j][0] + 1; j++; &#125; if(j &lt; tiles.size()) ans = max(ans, now + max(0, tiles[i][0] + carpetLen - tiles[j][0])); else ans = max(ans, now); now -= tiles[i][1] - tiles[i][0] + 1; &#125; return ans; &#125;&#125;; å¤§è‡´è¿‡ç¨‹æ˜¯æžšä¸¾ç“·ç –åŒºé—´ï¼Œä¸è¶…è¿‡æ¯¯å­é•¿åº¦çš„æƒ…å†µä¸‹ï¼Œå°†å°½å¯èƒ½å¤šçš„ç“·ç –æ”¾å…¥æ¯¯å­ä¸‹ï¼Œæ•´ä¸ªçª—å£çš„å¤§å°å°±æ˜¯æ¯¯å­çš„é•¿åº¦ã€‚å½“æœ€åŽä¸€å—ç“·ç –åªèƒ½éƒ¨åˆ†æ”¾å…¥æ¯¯å­ä¸‹æ—¶ï¼Œéœ€è¦å•ç‹¬åŠ ä¸Šè¿™éƒ¨åˆ†é•¿åº¦ã€‚ä¸Šé¢çš„æ€è·¯æ˜¯ä»Žç“·ç –åŒºé—´çš„å³ç«¯ç‚¹æ¥æ€è€ƒçš„ï¼Œä¹Ÿå¯ä»¥ä»Žç“·ç –åŒºé—´çš„å·¦ç«¯ç‚¹æ¥æ€è€ƒï¼š12345678910111213141516class Solution &#123;public: int maximumWhiteTiles(vector&lt;vector&lt;int&gt;&gt;&amp; tiles, int carpetLen) &#123; sort(tiles.begin(), tiles.end()); long long now = 0, ans = 0, left = 0; for(auto &amp;v: tiles) &#123; now += v[1] - v[0] + 1; while(tiles[left][1] &lt; v[1] - carpetLen + 1) &#123; now -= tiles[left][1] - tiles[left][0] + 1; left++; &#125; ans = max(ans, now - max(v[1] - carpetLen + 1 - tiles[left][0], 0)); &#125; return ans; &#125;&#125;; è™½ç„¶è¿™ä¸ªæ€è·¯ç®€æ´ä¸€äº›ï¼Œä½†æ˜¯æ„Ÿè§‰è¦éš¾æƒ³ä¸€äº›ã€‚ 2272. Substring With Largest VarianceAnalysisé¢˜ç›®è¿˜ç®—ç›´æŽ¥ï¼Œå°±æ˜¯æ±‚å­ä¸²ä¸­å‡ºçŽ°æ¬¡æ•°æœ€å¤šä¸Žæœ€å°‘çš„å­—ç¬¦çš„æ¬¡æ•°å·®ã€‚å¾ˆå®¹æ˜“æƒ³åˆ°æš´åŠ›è§£æ³•ï¼Œæžšä¸¾æ¯ä¸€ä¸ªå­ä¸²ï¼Œå†ç»Ÿè®¡å…¶ä¸­å‡ºçŽ°çš„æ¬¡æ•°ï¼Œä½œå·®å³å¯ã€‚å€ŸåŠ© mapï¼Œæš´åŠ›è§£æ³•çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯ $O(n^2log\Sigma)$ï¼Œæ•°æ®èŒƒå›´æ˜¯ $10^4$ï¼Œå¤šåŠæ˜¯è¦è¶…æ—¶ã€‚å®žé™…ä¸Šï¼Œå½“æ—¶çœ‹åˆ°è¿™ä¸ªé¢˜ç›®ç¬¬ä¸€ååº”å°±æ˜¯å­—ç¬¦ä¸²å’Œ dp çš„ç»“åˆé¢˜ï¼Œä¸è¿‡è¿˜æ˜¯æŠŠæš´åŠ›çš„æ€è·¯å†™ä¸‹æ¥äº†ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„æš´åŠ›ä»£ç ï¼š1234567891011121314151617181920class Solution &#123;public: int largestVariance(string s) &#123; int len = s.length(); int maxlv = INT_MIN; for(int i = 0; i &lt; len; i++) &#123; unordered_map&lt;char, int&gt; cnt; for(int j = i; j &lt; len; j++) &#123; cnt[s[j] - 'a']++; int maxappear = INT_MIN, minappear = INT_MAX; for(auto &amp;[c, i]: cnt) &#123; if(i &gt; maxappear) maxappear = i; if(i &lt; minappear) minappear = i; &#125; maxlv = max(maxlv, maxappear - minappear); &#125; &#125; return maxlv; &#125;&#125;; å½“æ—¶æ²¡æœ‰å€ŸåŠ© mapï¼Œç”¨çš„æ˜¯ unordered_mapï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2\Sigma)$ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—æƒ³åŠžæ³•ç”¨ dpã€‚çœ‹äº†ä¸‹å¤§ä½¬çš„é¢˜è§£ï¼Œå‘çŽ°è¿™ä¸ªé¢˜çš„éš¾ç‚¹åœ¨é—®é¢˜çš„ç†è§£ä¸Žè½¬åŒ–ä¸Šã€‚æŒ‰ç…§é¢˜æ„ï¼Œæœ€å¤§æ³¢åŠ¨å€¼åªæœ‰ 2 ä¸ªå­—ç¬¦ï¼ˆä¸€ä¸ªå‡ºçŽ°çš„æ¬¡æ•°æœ€å¤šï¼Œä¸€ä¸ªå‡ºçŽ°çš„æ¬¡æ•°æœ€å°‘ï¼‰å†³å®šï¼Œè‡³äºŽæ˜¯å“ªä¸¤ç§ï¼Œæ²¡åŠžæ³•ç›´æŽ¥ç¡®å®šï¼Œæ‰€æœ‰çš„å¯èƒ½å…±æœ‰ $26 \times 25 = 650$ ç§ã€‚å‡è®¾æžšä¸¾åˆ°äº†ç»„åˆï¼ˆaï¼Œbï¼‰ï¼ˆå¹¶ä¸æ˜¯&#39;a&#39;å’Œbï¼‰ï¼Œåœ¨å­ä¸²ä¸­ï¼Œå°† a çœ‹ä½œæ˜¯ 1ï¼Œb çœ‹ä½œæ˜¯ -1ï¼Œå…¶ä»–å­—ç¬¦çœ‹ä½œ 0ï¼Œé—®é¢˜å°±è½¬åŒ–ä¸ºæ±‚è¿™ä¸ªæ•°ç»„æœ€å¤§çš„è¿žç»­å­åˆ—å’Œã€‚åœ¨æ•´ä¸ªæžšä¸¾çš„è¿‡ç¨‹ä¸­ï¼Œè¿˜éœ€è¦æ³¨æ„å­—ç¬¦ a å’Œ b éƒ½å¿…é¡»å‡ºçŽ°åœ¨å­å­—ç¬¦ä¸²ä¸­ï¼Œä¸èƒ½å°†åªåŒ…å«å­—ç¬¦ a æˆ– b çš„å­å­—ç¬¦ä¸²ä½œä¸ºç­”æ¡ˆã€‚åŒæ—¶ï¼Œç”¨ä¸€ä¸ªå˜é‡ diff æ¥è®°å½•å­—ç¬¦ a å’Œå­—ç¬¦ b å‡ºçŽ°æ¬¡æ•°ä¹‹å·®ï¼Œåˆå§‹å€¼ä¸º 0ï¼Œå†ç”¨å¦ä¸€ä¸ªå˜é‡ diff_with_b æ¥è®°å½• b æ˜¯å¦å‡ºçŽ°å’Œ aã€b å‡ºçŽ°æ¬¡æ•°ä¹‹å·®ï¼Œåˆå§‹åŒ–ä¸ºè´Ÿæ— ç©·ã€‚1234567891011121314151617181920212223class Solution &#123;public: int largestVariance(string s) &#123; int ans = 0; for(char a = 'a'; a &lt;= 'z'; a++) &#123; for(char b = 'a'; b &lt;= 'z'; b++) &#123; if(a == b) continue; int diff = 0, diff_with_b = -s.length(); for(char c: s) &#123; if(c == a) &#123; diff++; diff_with_b++; &#125; else if(c == b) &#123; diff_with_b = --diff; diff = max(diff, 0); &#125; ans = max(ans, diff_with_b); &#125; &#125; &#125; return ans; &#125;&#125;; å°† $s[i]$ å½“ä½œå­—ç¬¦ a å’Œ bï¼Œè¿˜å¯ä»¥è¿›ä¸€æ­¥ä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ï¼š1234567891011121314151617181920class Solution &#123;public: int largestVariance(string s) &#123; int ans = 0; int diff[26][26] = &#123;0&#125;, diff_with_b[26][26]; memset(diff_with_b, 0x80, sizeof(diff_with_b)); for(char ch: s) &#123; ch -= 'a'; for(int i = 0; i &lt; 26; i++) &#123; if(i == ch) continue; diff[ch][i]++; diff_with_b[ch][i]++; diff_with_b[i][ch] = --diff[i][ch]; diff[i][ch] = max(diff[i][ch], 0); ans = max(ans, max(diff_with_b[ch][i], diff_with_b[i][ch])); &#125; &#125; return ans; &#125;&#125;; è¿™ä¸ªä¼˜åŒ–æœ‰ç‚¹æ²¡çœ‹æ‡‚... Summaryå¾—æ•´ä¸ªä¸“é¢˜è®­ç»ƒä¸‹...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 292 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F21%2FLeetcode-%E7%AC%AC-292-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[ä¸Šä¸Šå‘¨çš„å‘¨èµ›äº†...ä¸€å¦‚æ—¢å¾€çš„åŒé¢˜é€‰æ‰‹...æ¯æ¬¡å¤ç›˜éƒ½è¦æ‹–å¥½ä¹…ðŸ¤ 2264. Largest 3-Same-Digit Number in StringAnalysisæ‰¾å‡ºå­ä¸²ä¸­æœ€å¤§çš„ 3 ä½æ•°ï¼Œä¸”è¿™ä¸ª 3 ä½æ•°ï¼Œå¿…é¡»å„æ•°ä½ç›¸ç­‰ã€‚ Codeå½“æ—¶æäº¤çš„ä»£ç ï¼š1234567891011121314class Solution &#123;public: string largestGoodInteger(string num) &#123; vector&lt;string&gt; nums; int len = num.length(); for(int i = 0; i &lt; len - 2; i++) &#123; if(num[i] == num[i + 1] &amp;&amp; num[i] == num[i + 2]) nums.push_back(num.substr(i, 3)); &#125; int size = nums.size(); sort(nums.begin(), nums.end()); if(size == 0) return ""; else return nums[size - 1]; &#125;&#125;; çŽ°åœ¨å†çœ‹ï¼Œå†™çš„éº»çƒ¦äº†ä¸€ç‚¹ï¼Œæ”¹ç®€å•ä¸€ç‚¹ï¼š1234567891011121314class Solution &#123;public: string largestGoodInteger(string num) &#123; string ans = ""; int len = num.length(); for(int i = 0; i &lt; len - 2; i++) &#123; if(num[i] == num[i + 1] &amp;&amp; num[i] == num[i + 2]) &#123; string tmp = num.substr(i, 3); if(tmp &gt; ans) ans = tmp; &#125; &#125; return ans; &#125;&#125;; 2265. Count Nodes Equal to Average of SubtreeAnalysisç»Ÿè®¡å‡ºæ‰€æœ‰ç»“ç‚¹çš„å€¼ä¸Žä»¥å¯¹åº”ç»“ç‚¹ä¸ºæ ¹ç»“ç‚¹çš„æ ‘çš„ç»“ç‚¹å€¼ä¹‹å’Œçš„å¹³å‡å€¼ç›¸ç­‰çš„ç»“ç‚¹æ•°ç›®...è¯»èµ·æ¥ç›¸å½“æ‹—å£ï¼Œä¸è¿‡é¢˜ç›®æ„æ€å°±æ˜¯å¦‚æ­¤ã€‚ Codeå½“æ—¶åšçš„æ—¶å€™æ²¡ä»€ä¹ˆå¥½æƒ³æ³•ï¼Œå°±æ˜¯æŠŠæ‰€æœ‰ç»“ç‚¹æž„æˆçš„æ ‘çš„ç»“ç‚¹å’Œéƒ½ç®—å‡ºæ¥ï¼Œæ±‚å‡ºå¹³å‡å€¼ï¼Œå†è¿›è¡Œæ¯”è¾ƒï¼Œè¿™æ ·åšæ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼Œå‹‰å¼ºé€šè¿‡ã€‚è¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š1234567891011121314151617181920212223242526class Solution &#123;public: int averageOfSubtree(TreeNode* root) &#123; if(!root-&gt;left &amp;&amp; !root-&gt;right) return 1; queue&lt;TreeNode*&gt; q1; q1.push(root); int cnt = 0; while(!q1.empty()) &#123; TreeNode *node = q1.front(); q1.pop(); queue&lt;TreeNode*&gt; q2; q2.push(node); int sum = 0, nodecnt = 0; while(!q2.empty()) &#123; TreeNode *tmp = q2.front(); q2.pop(); sum += tmp-&gt;val; nodecnt++; if(tmp-&gt;left) q2.push(tmp-&gt;left); if(tmp-&gt;right) q2.push(tmp-&gt;right); &#125; if(sum / nodecnt == node-&gt;val) cnt++; if(node-&gt;left) q1.push(node-&gt;left); if(node-&gt;right) q1.push(node-&gt;right); &#125; return cnt; &#125;&#125;; éåŽ†æ€è·¯æ˜¯ bfs çš„æ€è·¯ï¼Œç”¨ dfs ä¹Ÿèƒ½å®žçŽ°ç±»ä¼¼çš„æ€è·¯ï¼Œä¸å†å†™äº†ã€‚çŽ°åœ¨è¦è€ƒè™‘ä¸€ä¸‹ï¼Œèƒ½ä¸èƒ½è¾¹è®¡ç®—ï¼Œè¾¹åˆ¤å®šã€‚ä»Žé¢˜ç›®çš„ç¤ºä¾‹æ¥åˆ†æžï¼Œæ‰€æœ‰çš„å¶å­ç»“ç‚¹éƒ½æ˜¯æ»¡è¶³æ¡ä»¶çš„ï¼Œéžå¶å­ç»“ç‚¹æ‰éœ€è¦åˆ¤å®šã€‚è€Œå®Œæˆåˆ¤å®šéœ€è¦ä¸¤ä¸ªæ¡ä»¶ï¼Œä¸€æ˜¯çŸ¥é“ä»¥å½“å‰ç»“ç‚¹ä¸ºå­æ ‘çš„ç»“ç‚¹å€¼ä¹‹å’Œï¼Œè€Œæ˜¯è¿™é¢—å­æ ‘çš„ç»“ç‚¹æ€»æ•°ã€‚æŒ‰ç…§ dfs çš„æ€è·¯ï¼Œå¦‚æžœä¸€å¼€å§‹åˆ¤æ–­çš„æ˜¯å¶ç»“ç‚¹ï¼Œç„¶åŽå†å°†å€¼è¿”å›žç»™éžå¶ç»“ç‚¹ï¼Œè¿™æ ·å°±ä¸ç”¨é‡å¤è®¡ç®—äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ¯æ¬¡éœ€è¦è¿”å›žä¸¤ä¸ªå€¼ï¼Œä¸€ä¸ªæ˜¯å­æ ‘æ‰€æœ‰ç»“ç‚¹å€¼ä¹‹å’Œï¼Œè€Œæ˜¯ç»“ç‚¹çš„æ•°é‡ã€‚1234567891011121314151617181920class Solution &#123;public: pair&lt;int, int&gt; dfs(TreeNode *root, int &amp;ans) &#123; if(root == nullptr) &#123; return &#123;0, 0&#125;; &#125; pair&lt;int, int&gt; left, right; left = dfs(root-&gt;left, ans); right = dfs(root-&gt;right, ans); int sum = left.first + right.first + root-&gt;val; int cnt = left.second + right.second + 1; if(sum / cnt == root-&gt;val) ans++; return &#123;sum, cnt&#125;; &#125; int averageOfSubtree(TreeNode* root) &#123; int ans = 0; dfs(root, ans); return ans; &#125;&#125;; æ³¨æ„åœ¨ averageOfSubtree è¿™ä¸ªå‡½æ•°ä¸­ï¼Œå¿½ç•¥æŽ‰äº† dfs çš„è¿”å›žå€¼ï¼Œå®žé™…é¡¹ç›®ä¸­å¯åˆ«è¿™æ ·å†™ã€‚å›žå¤´å†çœ‹è¿™ä¸ªé¢˜ç›®ï¼Œdfs çš„æ€è·¯è·ŸåŽåºéåŽ†å¾ˆåƒï¼Œæ•´ä½“çš„æ€è·¯è·Ÿæ ‘å½¢ dp ä¹Ÿå¾ˆåƒã€‚ 2266. Count Number of TextsAnalysisé¢˜ç›®ä¿¡æ¯æœ‰ç‚¹å¤šï¼Œå¤§è‡´æ„æ€å°±æ˜¯ç»™ä¸€ä¸²ä»£è¡¨ä¹å®«æ ¼é”®ç›˜æŒ‰é”®é¡ºåºçš„å­—ç¬¦ä¸²ï¼Œç®—å‡ºè¿™ä¸ªå­—ç¬¦ä¸²å¯ä»¥è¢«è§£ç æˆå¤šå°‘ç§å¯èƒ½ã€‚ Codeè¿™ä¸ªé¢˜å½“æ—¶æƒ³äº†æŒºä¹…çš„ï¼Œä½†æ˜¯æ²¡æƒ³å‡ºæ¥ï¼Œå±žäºŽæ˜¯æœ‰æ€è·¯ï¼Œä½†æ˜¯æ€è·¯åˆä¸æ˜¯é‚£ä¹ˆå®Œå…¨çš„é‚£ç§é¢˜ç›®ã€‚å½“æ—¶çš„æ€è·¯æ˜¯ï¼ŒæŒ‰ç…§æ•°å­—åˆ†ç±»ï¼Œä¹Ÿå°±æ˜¯ 7 å’Œ 9 ä¸€ç±»ï¼Œå‰©ä¸‹çš„ä¸€ç±»ï¼Œç„¶åŽåˆ†å‰²å­—ç¬¦ä¸²ï¼Œä¸€ä¸ªä¸€ä¸ªæ‰¾å‡ºæ‰€æœ‰çš„è¿žç»­ä¸”å­—ç¬¦éƒ½ç›¸ç­‰çš„å­ä¸²ã€‚å› ä¸º 7 å’Œ 9 æœ€å¤šæŒ‰ 4 ä¸‹ï¼Œå…¶ä»–æ•°å­—æœ€å¤šæŒ‰ 3 ä¸‹ï¼Œæ‰€ä»¥è®¡ç®—å‡ºå¯¹åº”çš„å¯èƒ½ï¼Œç„¶åŽä¾æ¬¡ä¹˜èµ·æ¥ï¼Œå°±æ˜¯æ€»çš„å¯èƒ½æ•°ï¼ŒåŒæ—¶åˆ«å¿˜äº†å–ä½™ã€‚ä½†æ˜¯ï¼Œçœ‹åˆ°ç¤ºä¾‹ 2 åˆæƒ³åˆ°äº†æ•°å­—å¯èƒ½å‡ºçŽ°å¾ˆå¤šæ¬¡ï¼Œé‚£è¿™æ ·ç»Ÿè®¡å°±ä¸å¯¹äº†ï¼Œæ€è·¯å°±ææµ…äº†... çœ‹äº†ä¸‹åˆ«äººçš„é¢˜è§£ï¼Œå‘çŽ°è¿™æ˜¯ä¸ªå­—ç¬¦ä¸²å’Œ dp ç»“åˆçš„é¢˜ï¼ˆå®Œå…¨æ²¡å¾€ dp ä¸Šæƒ³...ï¼‰ï¼Œæ•°å­—éœ€è¦åˆ†ç±»çš„æƒ³æ³•å€’æ˜¯æ²¡é”™ã€‚å…¶å®žï¼Œå½“æ—¶æ€è€ƒè¿™ä¸ªé¢˜çš„æ—¶å€™ï¼Œåº”è¯¥å¯Ÿè§‰åˆ°äº†å‰é¢çš„é€‰æ‹©ä¼šå½±å“åŽé¢çš„é€‰æ‹©ï¼Œè¿™ä¹Ÿå°±æ˜¯ dp çš„ç‰¹ç‚¹ã€‚è¿™ä¸ªäººçš„é¢˜è§£æŠŠè¿™ä¸ªé¢˜çš„ dp æ€è·¯è¯´çš„å¾ˆæ¸…æ¥šï¼Œè¿™é‡Œä¸èµ˜è¿°äº†ã€‚123456789101112131415161718192021222324class Solution &#123;public: int countTexts(string pressedKeys) &#123; int mod = 1e9 + 7; int len = pressedKeys.length(); vector&lt;long long&gt; dp(len); dp[0] = 1; for(int i = 1; i &lt; len; i++) &#123; dp[i] = dp[i - 1]; if(pressedKeys[i] == pressedKeys[i - 1]) &#123; dp[i] += i &gt;= 2 ? dp[i - 2] : 1; if(i &gt;= 2 &amp;&amp; pressedKeys[i] == pressedKeys[i - 2]) &#123; dp[i] += i &gt;= 3 ? dp[i - 3] : 1; if((pressedKeys[i] == '7' || pressedKeys[i] == '9') &amp;&amp; i &gt;= 3 &amp;&amp; pressedKeys[i] == pressedKeys[i - 3]) &#123; dp[i] += i &gt;= 4 ? dp[i - 4] : 1; &#125; &#125; &#125; dp[i] %= mod; &#125; return dp[len - 1]; &#125;&#125;; å›žå¤´å†çœ‹è¿™é“é¢˜ï¼Œé¦–å…ˆçš„é—®é¢˜æ˜¯æ²¡æ„è¯†åˆ°æ˜¯ dpï¼Œå†è€…å°±æ˜¯è¿™ä¸ªçŠ¶æ€è½¬ç§»æ–¹ç¨‹å¯èƒ½å†™ä¸å‡ºæ¥ï¼ŒåŽŸå› å¯èƒ½æ˜¯æ²¡åšè¿‡ç±»ä¼¼çš„å­—ç¬¦ä¸² + dp çš„é¢˜ï¼ˆä¸Šå‘¨é‚£ä¸ªå›°éš¾é¢˜è¿˜æ²¡æžæ‡‚å•Š...ï¼‰ã€‚ä»”ç»†æƒ³æƒ³ï¼Œè¿™ä¸ªé¢˜çš„ dp æ€è·¯ä¸Žè·³å°é˜¶ã€é’è›™è¿‡æ²³æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯ä¸€ç»´ dp çš„æ€è·¯ï¼Œåªæ˜¯è¿™ä¸ªé¢˜éœ€è¦è€ƒè™‘ä¸€ä¸‹å­—ç¬¦çš„ä¸åŒæƒ…å†µã€‚å†å›žåˆ°é¢˜ç›®ä¸­ï¼Œä¸Šé¢çš„æ€è·¯ä¸­ï¼Œ$dp[i]$ ä»£è¡¨çš„å°±æ˜¯ä»¥ $pressedKeys[i]$ ç»“å°¾çš„å¯èƒ½æ•°ï¼Œè¿™æ ·åšå¯èƒ½ä¼šä½¿ $dp[i - k], k = 2, 3, 4$ ä¸å­˜åœ¨ã€‚æ‰€ä»¥éœ€è¦å°† $dp[i]$ çš„å®šä¹‰ä¿®æ”¹æˆä»¥ $pressedKeys[i - 1]$ ç»“å°¾çš„å¯èƒ½æ•°ï¼Œå°±å¯ä»¥é¿å¼€è¿™ä¸ªé—®é¢˜äº†ï¼Œè¿™ä¸ªç»†èŠ‚ï¼Œä»¥åŽæ€è€ƒ dp ç±»é—®é¢˜çš„æ—¶å€™åƒä¸‡ä¸è¦å¿˜äº†ã€‚123456789101112131415161718192021222324class Solution &#123;public: int countTexts(string pressedKeys) &#123; int mod = 1e9 + 7; int len = pressedKeys.length(); vector&lt;long long&gt; dp(len + 1); dp[0] = 1, dp[1] = 1; for(int i = 2; i &lt;= len; i++) &#123; dp[i] = dp[i - 1]; if(pressedKeys[i - 1] == pressedKeys[i - 2]) &#123; dp[i] += dp[i - 2]; if(i &gt;= 3 &amp;&amp; pressedKeys[i - 1] == pressedKeys[i - 3]) &#123; dp[i] += dp[i - 3]; if((pressedKeys[i - 1] == '7' || pressedKeys[i - 1] == '9') &amp;&amp; i &gt;= 4 &amp;&amp; pressedKeys[i - 1] == pressedKeys[i - 4]) &#123; dp[i] += dp[i - 4]; &#125; &#125; &#125; dp[i] %= mod; &#125; return dp[len]; &#125;&#125;; ç±»ä¼¼çš„ï¼Œä¸€ç»´ dp è¿˜å¯ä»¥é€šè¿‡æ»šåŠ¨æ•°ç»„çš„æ€æƒ³æ¥è§£å†³ï¼Œå°±ä¸å†™äº†... æœ€åŽä¸€ä¸ªé¢˜ï¼Œåˆè¦æƒ³å¾ˆä¹…äº†ï¼Œæ˜Žå¤©å†å†™... åˆæ‹–äº†å‡ å¤©~ 2267. Check if There Is a Valid Parentheses String PathAnalysisåŒæ ·æ˜¯èƒ½è¯»æ‡‚é¢˜æ„ï¼Œä½†æ˜¯ä¸çŸ¥é“å¦‚ä½•ä¸‹æ‰‹çš„é¢˜ç›®...åªèƒ½å­¦ä¹ ä¸€ä¸‹å¤§ä½¬ä»¬çš„æ€è·¯äº†ã€‚ Codeå‚è€ƒæ€è·¯ï¼šDPã€‚123456789101112131415161718192021222324252627class Solution &#123;public: bool hasValidPath(vector&lt;vector&lt;char&gt;&gt;&amp; grid) &#123; if(grid[0][0] == ')') return false; int n = grid.size(), m = grid[0].size(); vector&lt;vector&lt;vector&lt;bool&gt;&gt;&gt; f; for(int i = 0; i &lt; n; i++) &#123; f.push_back(vector&lt;vector&lt;bool&gt;&gt;()); for(int j = 0; j &lt; m; j++) &#123; f.back().push_back(vector&lt;bool&gt;(n + m)); &#125; &#125; f[0][0][1] = true; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; int t = grid[i][j] == '(' ? 1 : -1; for(int k = 0; k &lt; n + m; k++) &#123; int kk = k - t; if(kk &lt; 0 || kk &gt;= n + m) continue; if(i &gt; 0) f[i][j][k] = f[i][j][k] || f[i - 1][j][kk]; if(j &gt; 0) f[i][j][k] = f[i][j][k] || f[i][j - 1][kk]; &#125; &#125; &#125; return f[n - 1][m - 1][0]; &#125;&#125;; è¿™ç§ä¸‰ç»´ dp çš„æ€è·¯å¯å¤ªå¼ºäº†ï¼Œå°±æ˜¯æœ‰ç‚¹æ²¡ç†è§£... Summaryå‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼šè™½ç„¶å‚åŠ å‘¨èµ›æŒºå¥½çŽ©çš„ï¼Œä½†æ˜¯æ¯æ¬¡åŽé¢ 2 ä¸ªéš¾ä¸€ç‚¹çš„é¢˜åšä¸å‡ºæ¥ï¼Œäº‹åŽçœ‹é¢˜è§£ï¼Œæ„Ÿè§‰å­¦ä¹ æ•ˆæžœä¸æ˜¯å¾ˆå¥½ï¼Ÿï¼Ÿï¼Ÿå¾—æŠŠæ—¶é—´é›†ä¸­åœ¨ä¸“é¢˜è®­ç»ƒä¸Šæ‰è¡Œ...ðŸ˜]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ã€Šç¾Žä¸½çš„æ¢­ç½—æ²³ã€‹ç®€æ˜“å‰ä»–è°±]]></title>
    <url>%2F2022%2F05%2F20%2F%E3%80%8A%E7%BE%8E%E4%B8%BD%E7%9A%84%E6%A2%AD%E7%BD%97%E6%B2%B3%E3%80%8B%E7%AE%80%E6%98%93%E5%90%89%E4%BB%96%E8%B0%B1%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯åŽŸæ¥æ‰’çš„æ­Œï¼Œæ˜¯é»„ç§‹ç”Ÿåœ¨ç”µå½±ã€Šå¤ªé˜³ç…§å¸¸å‡èµ·ã€‹æ¼”å”±çš„ç‰ˆæœ¬... è¿™å‡ å¤©çªç„¶åˆæƒ³èµ·äº†è¿™é¦–æ­Œï¼Œè®°å¾—åŽŸæ¥æ‰’è¿™ä¸ªæ­Œçš„æ—¶å€™ï¼Œçº¯é è€³æœµå¬å’Œåˆ«äººæç¤ºçš„å’Œå¼¦èµ°å‘ï¼Œæ‰æŠŠå¤§è‡´çš„æŒ‡æ³•å¼„æ¸…æ¥šã€‚çŽ°åœ¨ï¼Œè¡¥å……äº†ä¸€å®šçš„ä¹ç†åŽï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯åˆä¼šå¯¹è¿™é¦–æ­Œæœ‰ä¸åŒçš„çœ‹æ³•å‘¢ï¼Ÿæ‰€ä»¥ï¼Œå°±å†æ¥ç ”ç©¶ä¸€ä¸‹è¿™é¦–æ­Œã€‚ åŽŸç‰ˆç”µå½±ç‰‡æ®µï¼š ç®€æ˜“è°±ï¼š12345678910111213141516171819 ç¾Žä¸½çš„æ¢­ç½—æ²³1 = GTempo 4/4 G G Gç¾Ž ä¸½ çš„ æ¢­ ç½— æ²³ï¼Œæˆ‘ ä¸º ä½  æ­Œ å”±ï¼G D D7 Gä½  çš„ å…‰ è£ åŽ† å²ï¼Œæˆ‘ æ°¸ è¿œ è®° åœ¨ å¿ƒ ä¸Šã€‚G G G G G D D7 G æ—± å­£ æ¥ ä¸´ï¼Œä½  è½» è½» æµ æ·Œï¼Œé›¨ å­£ æ—¶ï¼Œæ³¢ æ¶› æ»š æ»šï¼Œä½  æµ å‘ è¿œ æ–¹ã€‚G C D G A A A D D ä½  çš„ èˆ¹ å‘˜ æ¥ è‡ª æ¢­ ç½—ï¼Œä¸‡ é‡ å±± é€ ä½  ä¸€ è·¯ å‰ å¾€ï¼Œæ»š æ»š çš„ æ³¢ æ¶› æµ å‘ è¿œ æ–¹ï¼Œä¸€ ç›´ æµ å…¥ æµ· æ´‹ã€‚G G G G G D D7 G ä½  çš„ åŽ† å²ï¼Œå°± æ˜¯ ä¸€ åª èˆ¹ï¼Œå•† äºº ä»¬ ä¹˜ èˆ¹ è¿œ èˆª åœ¨ ç¾Ž ä¸½ çš„ æ²³ é¢ ä¸Šã€‚G C D G A A A D D(arpeggio) ä½  çš„ èˆ¹ å‘˜ æ¥ è‡ª æ¢­ ç½—ï¼Œä¸‡ é‡ å±± é€ ä½  ä¸€ è·¯ å‰ å¾€ï¼Œæ»š æ»š çš„ æ³¢ æ¶› æµ å‘ è¿œ æ–¹ï¼Œä¸€ ç›´ æµ å…¥ æµ· æ´‹ã€‚ G G Gç¾Ž ä¸½ çš„ æ¢­ ç½— æ²³ï¼Œæˆ‘ ä¸º ä½  æ­Œ å”±ï¼G D D7 G G(arpeggio)ä½  çš„ å…‰ è£ åŽ† å²ï¼Œæˆ‘ æ°¸ è¿œ è®° åœ¨ å¿ƒ ä¸Šã€‚ è¯´æ˜Žï¼š å³æ‰‹æŒ‡æ³•å°±æ˜¯å¸¸è§çš„ 4/4 æ‹çš„åˆ†è§£å’Œå¼¦ä¼´å¥æŒ‡æ³•ï¼Œä¹Ÿå³ T3231323ã€‚ è°±å­ä¸­å­˜åœ¨å¾ˆå¤š G å’Œ Aï¼Œå®žé™…å¼¹çš„æ—¶å€™ï¼Œæœ‰çš„æ˜¯åŽŸä½å’Œå¼¦ï¼Œæœ‰çš„æ˜¯è¯¥å’Œå¼¦çš„ç¬¬äºŒè½¬ä½ã€‚æ¯”å¦‚ç¬¬ä¸€å¥æ­Œè¯çš„ Gï¼Œå…¶å®žéƒ½æ˜¯ G/Dï¼Œä¹Ÿå°±æ˜¯ G çš„ç¬¬äºŒè½¬ä½ï¼ˆG å’Œå¼¦çš„ç»„æˆéŸ³æ˜¯ G B Dï¼‰ï¼Œå¯¹åº”çš„ï¼Œæ­¤æ—¶çš„ T è¡¨ç¤ºçš„å°±æ˜¯ 4 å¼¦ã€‚å½“ç„¶ï¼ŒæŒ‰ç…§ 63231323 æ¥å¼¹ä¹Ÿè¡Œï¼Œå°±æ˜¯å¬ç€ä¸æ˜¯å¾ˆå’Œè°ã€‚ è¿™ä¸ªæ­Œæœ‰å¾ˆå¤šåœ°æ–¹æ˜¯ä»Žåæ‹å¼€å§‹å”±çš„ã€‚ æ•´é¦–æ­Œçš„å’Œå¼¦èµ°å‘å¤§æ¦‚æ˜¯ï¼šG -&gt; D -&gt; D7 -&gt; G å’Œ G -&gt; C -&gt; D -&gt; G -&gt; A -&gt; D -&gt; Gã€‚å‰ä¸€ä¸ªå’Œå¼¦èµ°å‘æ˜¯ç¼–é…çš„ç»å…¸å¥—è·¯ï¼Œä¸»å’Œå¼¦ç›´æŽ¥åˆ°å±žå’Œå¼¦ï¼Œå†è¿‡æ¸¡åˆ°å±žä¸ƒå’Œå¼¦ï¼Œæœ€åŽå›žåˆ°ä¸»å’Œå¼¦ã€‚åŽä¸€ä¸ªå’Œå¼¦èµ°å‘æœ‰ä¸€ä¸ªå¥‡æ€ªçš„åœ°æ–¹ï¼Œå°±æ˜¯ A å’Œå¼¦ä¸æ˜¯ G å¤§è°ƒçš„é¡ºé˜¶å’Œå¼¦ã€‚ä½†é»„ sir è¿˜æ˜¯è¿™ä¹ˆå¼¹äº†ï¼ŒåŽŸå› åº”è¯¥æ˜¯å› ä¸ºè¿™ä¸€æ®µçš„æ—‹å¾‹éŸ³å…¨éƒ¨æ˜¯ reï¼Œå¦‚æžœç”¨ Am å¬èµ·æ¥å°±å¾ˆæ€ªï¼ˆå°½ç®¡ Am æ˜¯ G å¤§è°ƒçš„é¡ºé˜¶å’Œå¼¦ï¼‰ï¼Œè€Œç”¨ A è¿™ä¸ªå¤§ä¸‰å’Œå¼¦å¬èµ·æ¥å°±ä¼šå’Œè°å¾ˆå¤šï¼Œ è™½ç„¶è¿™é¦–æ­Œæ˜¯å°å°¼çš„æ°‘è°£ï¼Œä½†æ˜¯å¬çš„æ—¶å€™ï¼Œæƒ³çš„å…¨æ˜¯ long river å’Œ yellow riverã€‚ç”µå½±ä¸­ï¼Œé»„ sir çš„å”±æ³•å¾ˆç¬¦åˆçŽ°ä»£äººçš„å¬è§‰æ„Ÿå—ï¼Œä½†æ˜¯ä¸Žå½“æ—¶èƒŒæ™¯ä¸‹çš„å”±æ³•æ˜¯å¤©å·®åœ°åˆ«çš„ã€‚å¯¹äºŽå§œå¯¼æƒ³è¦è¡¨è¾¾ä»€ä¹ˆä¸œè¥¿ï¼Œå·²ç»ä¸æƒ³åŽ»æ·±ç©¶äº†ã€‚ä½†å€Ÿç€è¿™é¦–æ­Œï¼Œèƒ¸ä¸­å‡èµ·çš„æ˜¯å¯¹è„šä¸‹è¿™å—â€œåœŸåœ°â€åˆçˆ±åˆæ¨çš„çŸ›ç›¾æƒ…æ„Ÿ... æ‰¯è¿œäº†ã€‚æ€»ä¹‹ï¼Œè¿™é¦–æ­Œå¾ˆé€‚åˆåˆå­¦è€…ç»ƒä¹ ï¼Œæ¯•ç«ŸæŒ‡æ³•å¾ˆç®€å•ï¼Œä¹Ÿæ²¡æœ‰æ¨ªæŒ‰ï¼Œå”¯ä¸€çš„éš¾ç‚¹åº”è¯¥æ˜¯åœ¨å¼¹å”±é…åˆä¸Šã€‚ä½œä¸ºæ‰’æ­Œçš„åˆçº§ç»ƒä¹ ï¼Œä¹ŸæŒºåˆé€‚çš„ï¼Œå’Œå¼¦èµ°å‘ç®€å•ï¼Œéƒ½æ˜¯å¸¸ç”¨çš„ä¸€äº›å’Œå¼¦ï¼Œæ¯”è¾ƒå®¹æ˜“åˆ†è¾¨ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day20]]></title>
    <url>%2F2022%2F05%2F19%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day20%2F</url>
    <content type="text"><![CDATA[æœ€åŽä¸€å¤©~3 ä¸ªè®¾è®¡é¢˜... 380. Insert Delete GetRandom O(1)Analysisè¿™ä¸ªå¥½åƒåœ¨æ¯æ—¥ä¸€é¢˜åšè¿‡...é¢˜ç›®è¦æ±‚å®žçŽ°ä¸€ä¸ªå«éšæœºé›†åˆçš„ç±»ï¼ŒåŒæ—¶è¦æ±‚æ¯ä¸ªå‡½æ•°çš„æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯$O(1)$ã€‚ Codeconstructorå…ˆæ€è€ƒä¸€ä¸‹å®žçŽ°è¿™ä¸ªç±»çš„åº•å±‚æ•°æ®ç»“æž„æ˜¯ä»€ä¹ˆã€‚å› ä¸ºé¢˜ç›®è¦æ±‚æ’å…¥ã€åˆ é™¤éƒ½æ˜¯$O(1)$ï¼Œæ‰€ä»¥å¿…é¡»è¦å€ŸåŠ©å“ˆå¸Œè¡¨ï¼Œé‚£å­˜å‚¨æ•°æ®ç”¨ vector å°±å¯ä»¥äº†ã€‚åŒæ—¶ï¼Œå› ä¸ºé¢˜ç›®è¿˜è¦æ±‚èƒ½ä»¥ç­‰æ¦‚çŽ‡å–åˆ°æ‰€æœ‰çš„æ•°ï¼Œæ‰€ä»¥åœ¨æž„é€ å‡½æ•°å†…ï¼Œéœ€è¦ç”Ÿæˆä¸€ä¸‹éšæœºæ•°ç§å­ã€‚123456789class RandomizedSet &#123;public: RandomizedSet() &#123; srand((unsigned)time(NULL)); &#125;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; indices;&#125;; insertå“ˆå¸Œè¡¨ç›´æŽ¥ä¿å­˜å…ƒç´ çš„åœ¨ vector ä¸­çš„ä¸‹æ ‡ï¼Œå¦‚æžœå“ˆå¸Œè¡¨å†…å·²ç»å­˜åœ¨è¿™ä¸ªå…ƒç´ ï¼Œå°±ä¸å†è¿›è¡Œæ’å…¥æ“ä½œäº†ã€‚1234567bool insert(int val) &#123; if(indices.count(val)) return false; int index = nums.size(); nums.push_back(val); indices[val] = index; return true;&#125; removeä¸ºäº†é¿å…åˆ é™¤ vector ä¸­çš„å…ƒç´ åŽè¦ç§»åŠ¨å…ƒç´ ï¼Œæ¯æ¬¡åˆ é™¤å…ƒç´ å‰ï¼Œå…ˆå°†æœ€æœ«å°¾çš„å…ƒç´ ç§»åŠ¨åˆ°è¦åˆ é™¤çš„å…ƒç´ ä½ç½®ï¼Œç„¶åŽå†åˆ é™¤è¿™ä¸ªå…ƒç´ ã€‚å½“ç„¶ï¼Œè¿™é‡Œè¯´çš„åˆ é™¤ï¼Œå®žé™…ä¸Šéƒ½ä¸æ˜¯çœŸæ­£æ„ä¹‰ä¸Šçš„åˆ é™¤ï¼Œè¿™ç‚¹ä¸Žç£ç›˜çš„å·¥ä½œåŽŸç†æ˜¯ç±»ä¼¼çš„ã€‚12345678910bool remove(int val) &#123; if(!indices.count(val)) return false; int index = indices[val]; int last = nums.back(); nums[index] = last; indices[last] = index; nums.pop_back(); indices.erase(val); return true;&#125; getRandomæž„é€ å‡½æ•°å†…å·²ç»ç”Ÿæˆäº†éšæœºæ•°ç§å­ï¼Œè¿™é‡Œç›´æŽ¥ç”¨å°±å¯ä»¥äº†ã€‚1234int getRandom() &#123; int randomindex = rand() % nums.size(); return nums[randomindex];&#125; Summary123456789101112131415161718192021222324252627282930313233class RandomizedSet &#123;public: RandomizedSet() &#123; srand((unsigned)time(NULL)); &#125; bool insert(int val) &#123; if(indices.count(val)) return false; int index = nums.size(); nums.push_back(val); indices[val] = index; return true; &#125; bool remove(int val) &#123; if(!indices.count(val)) return false; int index = indices[val]; int last = nums.back(); nums[index] = last; indices[last] = index; nums.pop_back(); indices.erase(val); return true; &#125; int getRandom() &#123; int randomindex = rand() % nums.size(); return nums[randomindex]; &#125;private: vector&lt;int&gt; nums; unordered_map&lt;int, int&gt; indices;&#125;; 622. Design Circular QueueAnalysisåˆæ˜¯ä¸€å †é¢˜ç›®è¯´æ˜Žï¼Œå®žé™…ä¸Šå°±æ˜¯è®¾è®¡å¾ªçŽ¯é˜Ÿåˆ—ï¼Œåªæ˜¯åœ¨ä¸€äº›åœ°æ–¹ä¸Žæ™®é€šé˜Ÿåˆ—æœ‰æ‰€å·®åˆ«ã€‚ Codeconstructorç±»ä¼¼æ™®é€šé˜Ÿåˆ—ï¼Œåº•å±‚æ•°æ®ç»“æž„ç”¨ vector å°±å¯ä»¥äº†ï¼ŒåŒæ—¶éœ€è¦æœ‰ä¸¤ä¸ªæŒ‡é’ˆ front å’Œ rearï¼Œåˆ†åˆ«æŒ‡å‘é˜Ÿé¦–å’Œé˜Ÿå°¾å…ƒç´ ã€‚åœ¨æž„é€ å‡½æ•°é‡Œé¢ï¼Œåˆå§‹åŒ–è¿™ä¸¤ä¸ªæŒ‡é’ˆï¼Œé¡ºä¾¿è®¾ç½®æ•°ç»„çš„å®¹é‡ä¸ºk + 1ã€‚1234567891011class MyCircularQueue &#123;public: MyCircularQueue(int k) &#123; maxsize = k + 1; data.resize(maxsize); front = rear = -1; &#125;private: vector&lt;int&gt; data; int front, rear, maxsize;&#125;; isEmptyè€ƒè™‘å…¶ä»–å‡½æ•°ä¹‹å‰ï¼Œå…ˆæ€è€ƒå¦‚ä½•åˆ¤æ–­é˜Ÿåˆ—ä¸ºç©ºå’Œæ»¡ã€‚å¾ˆå®¹æ˜“æƒ³åˆ°çš„æ˜¯ï¼Œå½“é¦–å°¾æŒ‡é’ˆç›¸ç­‰æ—¶ï¼Œé˜Ÿåˆ—å°±ä¸ºç©ºäº†ã€‚123bool isEmpty() &#123; return front == rear;&#125; isFullä¸Žåˆ¤ç©ºä¸€æ ·ï¼Œå½“é¦–å°¾æŒ‡é’ˆç›¸ç­‰æ—¶ï¼Œä¹Ÿä¼šå‡ºçŽ°é˜Ÿåˆ—æ»¡çš„æƒ…å†µã€‚æ‰€ä»¥ä¸ºäº†åŒºåˆ†è¿™ä¸¤ç§æƒ…å†µï¼Œå°±éœ€è¦ vector å†…ç©ºä¸€ä¸ªä½ç½®å½“ä½œæ ‡å¿—ä½ï¼Œæ¥åˆ¤æ–­æ˜¯å¦é˜Ÿæ»¡ã€‚123bool isFull() &#123; return (rear + 1) % maxsize == front;&#125; enQueueå…¥é˜Ÿæ—¶ï¼Œç§»åŠ¨é˜Ÿå°¾æŒ‡é’ˆï¼Œå…ˆåˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºæ»¡ï¼Œç„¶åŽæ”¾å…¥å…ƒç´ æˆ–è€…è¿”å›žfalseã€‚123456bool enQueue(int value) &#123; if(isFull()) return false; rear = (rear + 1) % maxsize; data[rear] = value; return true;&#125; æ³¨æ„ï¼Œè¿™é‡Œæ˜¯å…ˆç§»åŠ¨æŒ‡é’ˆåœ¨æ”¾å…¥å…ƒç´ ã€‚ deQueueå‡ºé˜Ÿæ—¶ï¼Œç§»åŠ¨é˜Ÿé¦–æŒ‡é’ˆï¼Œå…ˆåˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œç„¶åŽç§»åŠ¨é˜Ÿé¦–æŒ‡é’ˆå³å¯ã€‚12345bool deQueue() &#123; if(isEmpty()) return false; front = (front + 1) % maxsize; return true;&#125; Frontå…ˆåˆ¤ç©ºï¼Œç„¶åŽå–å…ƒç´ ã€‚ç”±äºŽå…¥é˜Ÿæ—¶ï¼Œæ˜¯å…ˆç§»åŠ¨æŒ‡é’ˆï¼Œæ‰€ä»¥è¿™é‡Œä¹Ÿå–çš„æ˜¯frontæŒ‡é’ˆçš„ä¸‹ä¸€ä¸ªä½ç½®ã€‚1234int Front() &#123; if(isEmpty()) return -1; return data[(front + 1) % maxsize];&#125; Rearå…ˆåˆ¤æ–­ç©ºï¼Œç„¶åŽå–å…ƒç´ ã€‚ç”±äºŽå…¥é˜Ÿæ—¶å·²ç»ç§»åŠ¨è¿‡æŒ‡é’ˆäº†ï¼Œæ‰€ä»¥rearæŒ‡å‘çš„å°±æ˜¯é˜Ÿå°¾çš„å…ƒç´ ï¼Œç›´æŽ¥è¿”å›žå³å¯ã€‚1234int Rear() &#123; if(isEmpty()) return -1; else return data[rear];&#125; åœ¨è¿™é‡Œå¯ä»¥çœ‹å‡ºï¼Œå¦‚æžœå…¥é˜Ÿæ—¶å…ˆæ”¾å…¥å…ƒç´ ï¼Œåœ¨ç§»åŠ¨æŒ‡é’ˆï¼Œå¯èƒ½ä¼šæ— æ³•ç›´æŽ¥é€šè¿‡rearæ¥æ‰¾åˆ°é˜Ÿå°¾å…ƒç´ ã€‚æŒ‰ç…§å…ˆæ”¾å…¥å…ƒç´ åœ¨ç§»åŠ¨æŒ‡é’ˆçš„æ€è·¯ï¼Œå½“rearä¸º 0ã€frontä¸ä¸º 0 æ—¶ï¼Œé˜Ÿå°¾å…ƒç´ åœ¨æ•°ç»„çš„æœ«å°¾ï¼Œå¥½åƒæ²¡åŠžæ³•ç›´æŽ¥é€šè¿‡å–ä½™æ¥å¾—åˆ°é˜Ÿå°¾å…ƒç´ çš„æŒ‡é’ˆ...è§£å†³æ–¹æ³•å°±æ˜¯ç‰¹åˆ¤ä¸€ä¸‹ï¼Œç„¶åŽç”¨frontæ¥å¯»æ‰¾é˜Ÿå°¾å…ƒç´ ï¼Œæ‰€ä»¥ä¸å¦‚ç›´æŽ¥å…ˆç§»åŠ¨æŒ‡é’ˆï¼Œåœ¨æ”¾å…¥å…ƒç´ ï¼Œå†ç§»åŠ¨æŒ‡é’ˆã€‚ Summary123456789101112131415161718192021222324252627282930313233343536class MyCircularQueue &#123;public: MyCircularQueue(int k) &#123; maxsize = k + 1; data.resize(maxsize); front = rear = 0; &#125; bool enQueue(int value) &#123; if(isFull()) return false; rear = (rear + 1) % maxsize; data[rear] = value; return true; &#125; bool deQueue() &#123; if(isEmpty()) return false; front = (front + 1) % maxsize; return true; &#125; int Front() &#123; if(isEmpty()) return -1; return data[(front + 1) % maxsize]; &#125; int Rear() &#123; if(isEmpty()) return -1; else return data[rear]; &#125; bool isEmpty() &#123; return front == rear; &#125; bool isFull() &#123; return (rear + 1) % maxsize == front; &#125;private: vector&lt;int&gt; data; int front, rear, maxsize;&#125;; 729. My Calendar IAnalysisæ„Ÿè§‰è¿™æ˜¯ä¸€ä¸ªè·ŸåŒºé—´ç›¸å…³çš„é¢˜ç›®... Codemethod 1åº•å±‚å°±ç”¨ vectorï¼Œæ—¥æœŸæ˜¯ä¸€å¯¹ä¸€å¯¹å‡ºçŽ°çš„ï¼Œæ‰€ä»¥ç›´æŽ¥ç”¨ pair å³å¯ã€‚12345678class MyCalendar &#123;public: MyCalendar() &#123; &#125;private: vector&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; ä¸é€ æˆé‡å¤é¢„è®¢çš„æ¡ä»¶æ˜¯å¼€å§‹æ—¥æœŸå’Œç»“æŸæ—¥æœŸéƒ½ä¸ä¼šè¢«å ç”¨ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥åˆ¤æ–­ã€‚1234567bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(!(start &gt;= e || end &lt;= s)) return false; &#125; calendar.push_back(make_pair(start, end)); return true;&#125; åšä¸€ä¸‹é€»è¾‘è¿ç®—ï¼ŒåŒ–ç®€ä¸€ä¸‹åˆ¤æ–­æ¡ä»¶ï¼Œå°±æ˜¯ï¼š1234567bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(start &lt; e &amp;&amp; end &gt; s) return false; &#125; calendar.push_back(make_pair(start, end)); return true;&#125; æœ€åŽåˆå¹¶åˆ°ä¸€èµ·ï¼š123456789101112131415class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; for(auto &amp;[s, e]: calendar) &#123; if(start &lt; e &amp;&amp; end &gt; s) return false; &#125; calendar.push_back(make_pair(start, end)); return true; &#125;private: vector&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; method 2æ³¨æ„åˆ°ï¼Œå¦‚æžœé¢„è®¢çš„æ—¥æœŸæ˜¯æŒ‰ç…§æ—¶é—´é¡ºåºæ¥æŽ’åºçš„è¯ï¼Œå†æ’å…¥ä¸‹ä¸€ä¸ªæ—¥æœŸæ—¶ï¼Œå°±å¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾ï¼Œæ¥å¯»æ‰¾åˆç†çš„æ’å…¥ä½ç½®äº†ã€‚123456789101112131415161718192021222324252627282930313233343536class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; if(calendar.size() == 0) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else &#123; auto pos = calendar.lower_bound(make_pair(start, 0)); if(pos == calendar.end()) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else if(pos == calendar.begin()) &#123; if(pos-&gt;first &gt;= end) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else &#123; if(pos-&gt;first &gt;= end) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(make_pair(start, end)); return true; &#125; else return false; &#125; else return false; &#125; &#125; &#125;private: set&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; ç®€åŒ–ä¸€ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536class MyCalendar &#123;public: MyCalendar() &#123; &#125; bool book(int start, int end) &#123; if(calendar.size() == 0) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else &#123; auto pos = calendar.lower_bound(&#123;start, 0&#125;); if(pos == calendar.end()) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else if(pos == calendar.begin()) &#123; if(pos-&gt;first &gt;= end) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else &#123; if(pos-&gt;first &gt;= end) &#123; pos--; if(pos-&gt;second &lt;= start) &#123; calendar.insert(&#123;start, end&#125;); return true; &#125; else return false; &#125; else return false; &#125; &#125; &#125;private: set&lt;pair&lt;int, int&gt;&gt; calendar; &#125;; ä¸è¿‡è¿™æ ·å†™äºŒåˆ†å®žåœ¨æ˜¯ä¸å¤ªç¾Žè§‚...å®žé™…ä¸Šï¼Œè¦è€ƒè™‘çš„æƒ…å†µä¹Ÿä¸éœ€è¦è¿™ä¹ˆå¤š...æ¢ç”¨ map æ¥ä¿å­˜ï¼Œç”¨ end æ¥è¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œæ‰¾åˆ°çš„å…ƒç´ çš„ start ä¸€å®šå¤§äºŽç­‰äºŽ end çš„ã€‚æ­¤æ—¶ï¼Œè¦åˆ¤æ–­çš„æ˜¯ï¼Œè¿™ä¸ªå…ƒç´ ä¹‹å‰çš„ end æ˜¯å¦å°äºŽç­‰äºŽè¦æ’å…¥çš„å…ƒç´ çš„ startï¼Œæ»¡è¶³ï¼Œé‚£å°±ç›´æŽ¥æ’å…¥å³å¯ã€‚å› ä¸º map æ˜¯æœ‰åºï¼ˆä»¥ key ä¸ºæŽ’åºä¾æ®ï¼Œè¿™é‡Œå°±æ˜¯æ¯ä¸ªå…ƒç´ çš„ startï¼‰çš„ï¼Œæ‰€ä»¥è¿™ä¸ªå…ƒç´ å°±å¯ä»¥è¢«æ’å…¥åœ¨è¿™é‡Œã€‚12345678910111213141516class MyCalendar &#123;public: MyCalendar() &#123; calendar[-1] = -1; &#125; bool book(int start, int end) &#123; auto pos = calendar.lower_bound(end); if((--pos)-&gt;second &lt;= start) &#123; calendar[start] = end; return true; &#125; return false; &#125;private: map&lt;int, int&gt; calendar;&#125;; Summaryè®¾è®¡çš„é¢˜ç›®ï¼Œæ„Ÿè§‰åšèµ·æ¥æœ‰ç‚¹æ— èŠ...å“ˆï¼Œè¿™ä¸ªå­¦ä¹ è®¡åˆ’å®Œæˆäº†ï¼Œå€’æ˜¯ä¸ªè®©äººè§‰å¾—è½»æ¾çš„äº‹æƒ…ã€‚ä¸è¿‡ï¼Œä¸æ˜¯å¾ˆç†Ÿæ‚‰äºŒåˆ†çš„åº”ç”¨ï¼Œéœ€è¦ç»ƒä¹ ä¸€ä¸‹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day19]]></title>
    <url>%2F2022%2F05%2F18%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day19%2F</url>
    <content type="text"><![CDATA[å€’æ•°ç¬¬äºŒå¤©~ 1797. Design Authentication ManagerAnalysisè¿™ç§è®¾è®¡ç±»å¾—é¢˜ç›®éƒ½è¿™ä¹ˆé•¿çš„å—ï¼Ÿå®žé™…é—®é¢˜ä¸å¤æ‚ï¼Œç†è§£é¢˜æ„è¦æƒ³åŠå¤©...è¯è¯´å›žæ¥ï¼Œè¿™ä¸ªé¢˜å®žé™…ä¸Šæ˜¯ä¸ªæ•£åˆ—é¢˜ï¼Œéœ€è¦ç”¨ä¸€ä¸ªå˜é‡timetoliveæ¥è®°å½•éªŒè¯ç çš„â€œå­˜æ´»â€æ—¶é—´ï¼ŒåŒæ—¶ï¼Œåˆ©ç”¨ map æ¥ä¿å­˜éªŒè¯ç ä¸Žå…¶å¯¹åº”çš„â€œæ­»äº¡â€æ—¶åˆ»ï¼ˆæ³¨æ„è¿™é‡Œæ˜¯æ—¶åˆ»ï¼‰ï¼Œä¹Ÿå°±æ˜¯currentTime + timetoliveã€‚æœ€åŽè¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯è¿‡æœŸäº‹ä»¶ä¼˜å…ˆäºŽå…¶ä»–æ“ä½œï¼Œä¹Ÿå°±æ˜¯è¯´åœ¨t = 10ï¼ŒæŸä¸ªéªŒè¯ç â€œæ­»äº¡â€äº†ï¼ŒåŒæ—¶å¯¹è¿™ä¸ªéªŒè¯ç æ‰§è¡Œrenewæ“ä½œï¼Œæ­¤æ—¶ä¸ä¼šæ”¹å˜ä»»ä½•ä¸œè¥¿ã€‚ Code1234567891011121314151617181920212223242526class AuthenticationManager &#123; unordered_map&lt;string, int&gt; ht; int timetolive;public: AuthenticationManager(int timeToLive) &#123; timetolive = timeToLive; &#125; void generate(string tokenId, int currentTime) &#123; ht[tokenId] = currentTime + timetolive; &#125; void renew(string tokenId, int currentTime) &#123; if(ht.count(tokenId) != 0 &amp;&amp; ht[tokenId] &gt; currentTime) &#123; ht[tokenId] = currentTime + timetolive; &#125; &#125; int countUnexpiredTokens(int currentTime) &#123; int cnt = 0; for(auto &amp;[_, time]: ht) &#123; if(time &gt; currentTime) cnt++; &#125; return cnt; &#125;&#125;; 707. Design Linked ListAnalysiså®žçŽ°é“¾è¡¨ï¼Œemï¼Œè€ç”Ÿå¸¸è°ˆçš„é—®é¢˜ï¼Œä¸è¿‡è¦å®žçŽ°çš„å‡½æ•°å¤ªå¤šï¼Œæœ€å¥½åˆ†å¼€æ€è€ƒã€‚é¦–å…ˆåº”è¯¥æ˜Žç¡®é¢˜ç›®çš„è¦æ±‚ï¼š é“¾è¡¨ç»“ç‚¹å…·æœ‰ä¸¤ä¸ªå±žæ€§ï¼šval å’Œ nextã€‚ é“¾è¡¨ç»“ç‚¹çš„ä¸‹æ ‡æ˜¯ä»Ž 0 å¼€å§‹çš„ã€‚ Codeæ€»å…±è¦å®žçŽ° 5 ä¸ªå‡½æ•°ï¼Œå…ˆå¤§è‡´åˆ†æžä¸€ä¸‹æ¯ä¸ªå‡½æ•°å¦‚ä½•å®žçŽ°ï¼š èŽ·å–ç¬¬ index ä¸ªç»“ç‚¹çš„å€¼ï¼Œè¿™ä¸ªç›´æŽ¥éåŽ†é“¾è¡¨å°±å¯ä»¥å¾—åˆ°ï¼Œæ‰€ä»¥éœ€è¦æœ‰é“¾è¡¨çš„å¤´æŒ‡é’ˆã€‚ é“¾è¡¨çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä¹‹å‰æ·»åŠ ç»“ç‚¹ï¼ŒåŒæ ·éœ€è¦å¤´æŒ‡é’ˆã€‚ é“¾è¡¨çš„æœ€åŽä¸€ä¸ªå…ƒç´ ä¹‹åŽæ·»åŠ ç»“ç‚¹ï¼Œå¯ä»¥ä»Žå¤´éåŽ†åˆ°å°¾ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨å°¾æŒ‡é’ˆè§£å†³ã€‚ ç¬¬ index ä¸ªç»“ç‚¹ä¹‹å‰æ·»åŠ ç»“ç‚¹ï¼ŒéåŽ†é“¾è¡¨ï¼Œç„¶åŽæ’å…¥å³å¯ï¼Œéœ€è¦å¤´æŒ‡é’ˆã€‚ åˆ é™¤ç¬¬ index ä¸ªç»“ç‚¹ï¼ŒéåŽ†é“¾è¡¨ï¼Œåˆ é™¤å³å¯ã€‚ æŒ‰ç…§å¯¹å‡½æ•°çš„åˆ†æžï¼Œé€‰æ‹©ç”¨å¸¦å¤´ï¼ˆå“‘ï¼‰ç»“ç‚¹å’Œå°¾æŒ‡é’ˆçš„æ–¹å¼æ¥å®Œæˆè¿™ä¸ªé“¾è¡¨ã€‚ constructoré¦–å…ˆæ˜¯ç»“ç‚¹çš„æž„é€ ä»¥åŠå¯¹åº”çš„æž„é€ å‡½æ•°çš„ä¹¦å†™ï¼Œè¿™é‡Œçš„åŽŸåˆ™æ˜¯æ€Žä¹ˆæ–¹ä¾¿æ€Žä¹ˆæ¥ðŸ˜‚ã€‚1234567891011121314151617class MyLinkedList &#123;public: struct ListNode &#123; int val; ListNode *next; ListNode(int val): val(val), next(nullptr)&#123;&#125;; &#125;; MyLinkedList()&#123; size = 0; dummyhead = new ListNode(0); tail = dummyhead; &#125;private: int size; ListNode *dummyhead; ListNode *tail;&#125; æ³¨æ„ç§æœ‰æˆå‘˜å¾—å†™åœ¨åŽé¢ï¼Œå› ä¸ºListNodeçš„å£°æ˜Žï¼ˆdeclarationï¼‰å’Œå®šä¹‰ï¼ˆdefinitionï¼‰åœ¨ public é‡Œé¢ã€‚ä¸è¿‡ï¼Œå¦‚æžœæƒ³è¦å†™åœ¨å‰é¢åº”è¯¥ä¹Ÿèƒ½ç”¨ typedef æ¥å®Œæˆå§ï¼Ÿæ‡’å¾—å°è¯•äº†...å¤šå†™ä¸€ä¸ªListNodeçš„æž„é€ å‡½æ•°ï¼Œè¿™æ ·æ–¹ä¾¿æ–°å»ºç»“ç‚¹ï¼ŒåŒæ—¶MyLinkedListçš„æž„é€ å‡½æ•°ä¹Ÿéœ€è¦åˆå§‹åŒ–å½“å‰é“¾è¡¨çš„å“‘ç»“ç‚¹ã€å°¾æŒ‡é’ˆå’Œç»“ç‚¹æ€»æ•°äº†ã€‚ addAtHeadå…ˆæ€è€ƒ addAtHead å‡½æ•°çš„å†™æ³•ï¼Œå› ä¸ºæœ‰äº†å“‘ç»“ç‚¹ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªä½ç½®æ’å…¥å°±å¾ˆç®€å•ï¼š123456void addAtHead(int val) &#123; ListNode *newnode = new ListNode(val); newnode-&gt;next = dummyhead-&gt;next; dummyhead-&gt;next = newnode; size++;&#125; ä½†æ˜¯è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å°¾æŒ‡é’ˆæ˜¯å¦ä¼šå—åˆ°å½±å“ã€‚æ˜¾ç„¶ï¼Œå¦‚æžœæ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹æ’å…¥ï¼Œé‚£ä¹ˆå°¾æŒ‡é’ˆåŒæ—¶ä¹Ÿéœ€è¦å˜æˆæŒ‡å‘ç¬¬ä¸€ä¸ªç»“ç‚¹ã€‚é‚£å¦‚æžœæ’å…¥ç¬¬äºŒä¸ªç»“ç‚¹å‘¢ï¼Ÿå½“ç„¶å°±ä¸éœ€è¦åœ¨æ”¹å˜å°¾æŒ‡é’ˆäº†ã€‚1234567void addAtHead(int val) &#123; ListNode *newnode = new ListNode(val); newnode-&gt;next = dummyhead-&gt;next; dummyhead-&gt;next = newnode; size++; if(size == 1) tail = newnode;&#125; addAtTailå†æ¥æ€è€ƒå¦‚ä½•åœ¨å°¾éƒ¨æ’å…¥ç»“ç‚¹ã€‚ä¸Žå‰é¢çš„æ€è€ƒä¸€æ ·ï¼Œå› ä¸ºæœ‰äº†å°¾æŒ‡é’ˆï¼Œæ‰€ä»¥å°±å¾ˆå®¹æ˜“çš„åœ¨å°¾éƒ¨æ’å…¥ç»“ç‚¹äº†ï¼š123456void addAtTail(int val) &#123; ListNode *newnode = new ListNode(val); tail-&gt;next = newnode; tail = newnode; size++;&#125; addAtIndexæŒ‰ç…§é¢˜ç›®çš„è§£é‡Šï¼Œå½“ index ç­‰äºŽé“¾è¡¨é•¿åº¦æ—¶ï¼Œç›´æŽ¥åœ¨æœ«å°¾æ’å…¥ç»“ç‚¹ï¼›å½“ index å¤§äºŽé“¾è¡¨é•¿åº¦æ—¶ï¼Œå½“ä½œè¾“å…¥çš„é”™è¯¯ï¼Œå¿½ç•¥æŽ‰å³å¯ï¼›å½“ index å°äºŽ 0 æ—¶ï¼Œåœ¨å¤´éƒ¨æ’å…¥ï¼›å½“ index å¤§äºŽ 0 å°äºŽ index æ—¶ï¼Œåœ¨é“¾è¡¨ä¸­é—´æ’å…¥ç»“ç‚¹ã€‚å¯¹åº”çš„ï¼Œé’ˆå¯¹è¿™ 4 ç§æƒ…å†µï¼š ç›´æŽ¥åœ¨å°¾éƒ¨æ’å…¥ã€‚ å¿½ç•¥ã€‚ ç›´æŽ¥åœ¨å¤´éƒ¨æ’å…¥ç»“ç‚¹ã€‚ å…ˆæ‰¾åˆ°è¦æ’å…¥çš„ä½ç½®çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œç„¶åŽæ’å…¥ç»“ç‚¹ã€‚ 1234567891011121314void addAtIndex(int index, int val) &#123; if(index &gt; size) return; ListNode *newnode = new ListNode(val); if(index == size) &#123; tail-&gt;next = newnode; tail = newnode; &#125; else &#123; ListNode *cur = dummyhead; while(index--) cur = cur-&gt;next; newnode-&gt;next = cur-&gt;next; cur-&gt;next = newnode; &#125; size++; &#125; å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜å¹¶æ²¡æœ‰ç»™ index å°äºŽ 0 çš„æƒ…å†µï¼Œæ‰€ä»¥å°±ç›´æŽ¥è¿™ä¹ˆå†™äº†ã€‚çœ‹äº†ä¸‹è¯„è®ºåŒºï¼Œå½“æ—¶å¥½åƒæ˜¯ç»™äº†çš„ï¼Œç»“æžœè¢«å¤ªå¤šäººåæ§½ï¼Œå°±åˆ é™¤äº†å§ðŸ˜‚ï¼Ÿä¸è¿‡ï¼Œé¢˜ç›®æœ¬èº«å°±è¯´äº† index æ˜¯ä»Ž 0 å¼€å§‹çš„ï¼Œå‡ºçŽ°è´Ÿæ•°ç¡®å®žå¯ä»¥å½“ä½œé”™è¯¯çš„è¾“å…¥ç»™ pass æŽ‰ã€‚è™½ç„¶ï¼Œé¢˜ç›®ä¹Ÿå¯¹è¿™ä¸ªå‡½æ•°çš„åŠŸèƒ½è¿›è¡Œäº†è§£é‡Šï¼Œä½†æ˜¯æ„Ÿè§‰ä¸å¯¹è´Ÿæ•°åšå¤„ç†ï¼Œæ‰æ˜¯æ­£å¸¸äººçš„æ€è€ƒæ¨¡å¼ðŸ¤”ï¼Ÿ å¦å¤–ï¼Œå› ä¸ºæœ‰å“‘ç»“ç‚¹çš„å­˜åœ¨ï¼Œæ‰€ä»¥å¯»æ‰¾æ’å…¥ä½ç½®æ—¶ï¼Œç›´æŽ¥ä»Žå“‘ç»“ç‚¹å¼€å§‹ï¼Œè¿™æ ·å½“ index ä¸º 0ï¼Œæ‰¾åˆ°çš„ç»“ç‚¹ï¼Œå°±æ˜¯è¦æ’å…¥ä½ç½®çš„å‰ä¸€ä¸ªç»“ç‚¹ã€‚è¿˜è¦æ³¨æ„çš„ä¸€ä¸ªåœ°æ–¹æ˜¯åœ¨å°¾éƒ¨æ’å…¥ç»“ç‚¹åŽï¼Œä¸€å®šè¦è®°å¾—ä¿®æ”¹å°¾æŒ‡é’ˆã€‚ getèŽ·å–é“¾è¡¨ä¸­ç¬¬ index ä¸ªç»“ç‚¹çš„å€¼ï¼Œç›´æŽ¥éåŽ†é“¾è¡¨å³å¯ã€‚ç”±äºŽä¿å­˜äº†é“¾è¡¨å½“å‰çš„ç»“ç‚¹æ€»æ•°ï¼Œæ‰€ä»¥åœ¨æŸ¥æ‰¾å‰å¯ä»¥ç®€å•åˆ¤æ–­ä¸€ä¸‹ã€‚123456int get(int index) &#123; if(index &lt; 0 || index &gt; size - 1) return -1; ListNode *cur = dummyhead-&gt;next; while(index--) cur = cur-&gt;next; return cur-&gt;val;&#125; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œè¦è¿”å›žçš„æ˜¯ä¸‹æ ‡ä¸º index ç»“ç‚¹çš„å€¼ï¼Œæ‰€ä»¥å¾ªçŽ¯å¼€å§‹æ—¶curå¾—æŒ‡å‘ç¬¬ä¸€ä¸ªçœŸå®žçš„ç»“ç‚¹ã€‚ deleteAtIndexåŒæ ·ï¼Œåˆ é™¤ä¹‹å‰ä¹Ÿå¯ä»¥å…ˆå¯¹ index è¿›è¡Œåˆ¤æ–­ã€‚12345678910void deleteAtIndex(int index) &#123; if(index &lt; 0 || index &gt; size - 1) return; ListNode *cur = dummyhead; while(index--) cur = cur-&gt;next; ListNode *tmp = cur-&gt;next; if(tmp == tail) tail = cur; cur-&gt;next = cur-&gt;next-&gt;next; delete tmp; size--;&#125; åˆ é™¤æ—¶ï¼Œéœ€è¦å¯»æ‰¾çš„åŒæ ·æ˜¯è¢«åˆ é™¤ç»“ç‚¹çš„å‰ä¸€ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥å¾ªçŽ¯å¼€å§‹æ—¶curæŒ‡å‘å“‘ç»“ç‚¹å³å¯ã€‚åŒæ ·ï¼Œæ³¨æ„å½“åˆ é™¤çš„æ˜¯æœ€åŽä¸€ä¸ªç»“ç‚¹æ—¶ï¼Œå°¾æŒ‡é’ˆè¦æ”¹æˆæŒ‡å‘æœ€åŽä¸€ä¸ªç»“ç‚¹çš„å‰é©±ç»“ç‚¹ã€‚ Summaryè·Ÿè®¾è®¡ç›¸å…³çš„é¢˜ç›®çš„éš¾ç‚¹ä¸åœ¨ç®—æ³•å¤æ‚åº¦ä¸Šï¼Œè€Œæ˜¯åœ¨ç†è§£é¢˜æ„å’Œå¦‚ä½•å®žçŽ°ä¸Šã€‚ç‰¹åˆ«æ˜¯ç¬¬äºŒä¸ªé¢˜ç›®ï¼Œæœ‰äº›åœ°æ–¹å…¶å®žäº¤ä»£çš„ä¸æ˜¯å¾ˆæ¸…æ¥šã€‚ç‰¹åˆ«æ˜¯â€œç¬¬ index ä¸ªâ€è¿™ç§è¯´æ³•ï¼Œå¾ˆå®¹æ˜“è®©äººäº§ç”Ÿè¯¯è§£ã€‚å‡å¦‚ index æ˜¯ 3ï¼Œåˆ°åº•æ˜¯ç¬¬ 3 ä¸ªç»“ç‚¹å‘¢ï¼Œè¿˜æ˜¯ç¬¬ 4ï¼ˆ0ï¼Œ1ï¼Œ2ï¼Œ3ï¼‰ ä¸ªç»“ç‚¹å‘¢ï¼Ÿå½“ç„¶ï¼Œè¿™ä¸ªé¢˜ç›®æ˜¯ç¬¬ 4 ä¸ªã€‚å…¶å®žï¼Œä¸ç®¡æ˜¯ 3 è¿˜æ˜¯ 4ï¼Œå¦‚æžœåœ¨è¿™ç§é—®é¢˜ä¸Šè€—è´¹å¤ªå¤šæ—¶é—´ï¼Œå°±æ²¡æœ‰æ„ä¹‰äº†...å°½ç®¡è¿™ä¸ªé¢˜æŠŠé“¾è¡¨çš„å¤§éƒ¨åˆ†æ“ä½œéƒ½è€ƒåˆ°äº†ï¼Œä½†æ˜¯è¿˜æ˜¯è§‰å¾—æœ‰ä¸è¶³çš„åœ°æ–¹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day18]]></title>
    <url>%2F2022%2F05%2F17%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day18%2F</url>
    <content type="text"><![CDATA[è¿˜æœ‰ä¸¤å¤©å“¦~ 155. Min StackAnalysiså®žçŽ°ä¸€ä¸ªæœ€å°æ ˆï¼Œç›¸æ¯”æ ˆè€Œè¨€ï¼Œå…¶å®žå°±å¤šäº†ä¸€ä¸ªè¿”å›žæ ˆå†…æœ€å°å€¼çš„åŠŸèƒ½ï¼Œå¯ä»¥ç›´æŽ¥ç”¨ä¸€ä¸ªå˜é‡æ¥è®°å½•æœ€å°å€¼ã€‚ Codeåº•å±‚æ•°æ®ç»“æž„å°±ç”¨æ•°ç»„å°±å¯ä»¥äº†ï¼Œç”¨ä¸€ä¸ªå˜é‡ tp ä½œä¸ºæ ˆé¡¶æŒ‡é’ˆï¼Œå†ç”¨å˜é‡ minimumofstk è®°å½•æ ˆå†…æœ€å°å€¼ã€‚123456789101112131415161718192021222324252627282930313233class MinStack &#123; int stk[30010]; int tp, minimumofstk;public: MinStack() &#123; tp = -1; minimumofstk = INT_MAX; &#125; void push(int val) &#123; stk[++tp] = val; if(val &lt; minimumofstk) minimumofstk = val; &#125; void pop() &#123; int tmp = stk[tp--]; if(tp == -1) minimumofstk = INT_MAX; else if(tmp == minimumofstk) &#123; minimumofstk = stk[tp]; for(int i = 0; i &lt; tp; i++) &#123; if(stk[i] &lt; minimumofstk) minimumofstk = stk[i]; &#125; &#125; &#125; int top() &#123; return stk[tp]; &#125; int getMin() &#123; return minimumofstk; &#125;&#125;; è¿™ç§æ€è·¯ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯æ¯æ¬¡ pop æ“ä½œä¹‹åŽéƒ½éœ€è¦æ›´æ–°æœ€å°å€¼ï¼ˆå°½ç®¡ getMin æ“ä½œçš„ç¡®æ˜¯å¸¸æ•°æ—¶é—´å†…å®Œæˆçš„ï¼‰ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(n)$ã€‚å®žé™…ä¸Šï¼Œå¸¸æ•°æ—¶é—´å†…èŽ·å–æœ€å°å€¼çš„æ“ä½œå¯ä»¥å€ŸåŠ©ä¸€ä¸ªè¾…åŠ©æ ˆå®Œæˆã€‚æ¯æ¬¡å°†å…ƒç´ å…¥æ ˆæ—¶ï¼Œéƒ½å°†è¯¥å…ƒç´ ä¸Žè¾…åŠ©æ ˆæ ˆé¡¶å…ƒç´ æ¯”è¾ƒï¼Œå¦‚æžœå°äºŽï¼Œå³å°†è¯¥å…ƒç´ æ”¾å…¥è¾…åŠ©æ ˆï¼Œæ­¤æ—¶è¾…åŠ©æ ˆæ ˆé¡¶çš„å…ƒç´ å°±æ˜¯ä¸»æ ˆå†…çš„æœ€å°å€¼ã€‚1234567891011121314151617181920212223242526class MinStack &#123; stack&lt;int&gt; stk; stack&lt;int&gt; min_stk;public: MinStack() &#123; min_stk.push(INT_MAX); &#125; void push(int val) &#123; stk.push(val); min_stk.push(min(min_stk.top(), val)); &#125; void pop() &#123; stk.pop(); min_stk.pop(); &#125; int top() &#123; return stk.top(); &#125; int getMin() &#123; return min_stk.top(); &#125;&#125;; 341. Flatten Nested List IteratorAnalysisæ²¡çœ‹æ‡‚è¿™é¢˜åˆ°åº•ä»€ä¹ˆæ„æ€...ç›´æŽ¥å†²å‘é¢˜è§£åŒºðŸ˜‚ã€‚ Codeå®žé™…ä¸Šå°±æ˜¯æ ‘å½¢ç»“æž„çš„æ‰å¹³åŒ–ï¼Œåªä¸è¿‡åœ¨æ•´ä¸ªè¿‡ç¨‹ä¸­éœ€è¦å€ŸåŠ©ä¸€ä¸‹è¿™ä¸ªç±»çš„å†…éƒ¨å‡½æ•°ã€‚1234567891011121314151617181920212223242526class NestedIterator &#123; vector&lt;int&gt; vals; vector&lt;int&gt;::iterator cur; void dfs(const vector&lt;NestedInteger&gt; &amp;nestedList) &#123; for(auto &amp;nest: nestedList) &#123; if(nest.isInteger()) &#123; vals.push_back(nest.getInteger()); &#125; else &#123; dfs(nest.getList()); &#125; &#125; &#125;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; dfs(nestedList); cur = vals.begin(); &#125; int next() &#123; return *cur++; &#125; bool hasNext() &#123; return cur != vals.end(); &#125;&#125;; å°†å…¨éƒ¨å…ƒç´ å…¨éƒ¨æ‰å¹³åŒ–çš„æ€è·¯ï¼Œå…¶å®žæœ‰ç‚¹æŠ•æœºäº†ã€‚å› ä¸ºé¢˜ç›®çš„åç§°æ˜¯ list iteratorï¼Œæ‰€ä»¥å®žçŽ°çš„åŠŸèƒ½åº”è¯¥æ˜¯è¿­ä»£åˆ°å“ªä¸€æ­¥äº†ï¼Œå°±æŠŠé‚£ä¸€æ­¥å±•å¼€ã€‚12345678910111213141516171819202122232425262728class NestedIterator &#123; stack&lt;NestedInteger&gt; st;public: NestedIterator(vector&lt;NestedInteger&gt; &amp;nestedList) &#123; for(int i = nestedList.size() - 1; i &gt;= 0; i--) &#123; st.push(nestedList[i]); &#125; &#125; int next() &#123; NestedInteger cur = st.top(); st.pop(); return cur.getInteger(); &#125; bool hasNext() &#123; while(!st.empty()) &#123; NestedInteger cur = st.top(); if(cur.isInteger()) &#123; return true; &#125; st.pop(); for(int i = cur.getList().size() - 1; i &gt;= 0; i--) &#123; st.push(cur.getList()[i]); &#125; &#125; return false; &#125;&#125;; å…¶å®žè¿™ä¸ªé¢˜ï¼Œå†™èµ·æ¥å¾ˆå®¹æ˜“ï¼Œå°±æ˜¯ç€é‡ç†è§£é¢˜ç›®çš„æ„æ€ã€‚ Summaryä¸Žè®¾è®¡æ¨¡å¼ç›¸å…³çš„é¢˜ï¼Œéœ€è¦è¯»ç‚¹ç›¸å…³ä¹¦ç±æ‰èƒ½ç†è§£çš„æ›´é€å½»...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day17]]></title>
    <url>%2F2022%2F05%2F16%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day17%2F</url>
    <content type="text"><![CDATA[è¦æ²¡äº†ã€‚ 1845. Seat Reservation ManagerAnalysisé¢˜ç›®çš„æ„æ€å¾ˆç›´æŽ¥ï¼Œä»Ž reverse å‡½æ•°çš„åŠŸèƒ½æ¥çœ‹ï¼Œå°±æ˜¯æœ€å°å †çš„å‡ºå †æ“ä½œäº†ã€‚æ‰€ä»¥ï¼Œè¿™ä¸ªé¢˜æ˜¯è¦æž„é€ æœ€å°å †ã€‚ Codeå †çš„åŠŸèƒ½å¯ä»¥ç›´æŽ¥ç”¨ä¼˜å…ˆé˜Ÿåˆ—æ¥å®Œæˆã€‚C++ çš„ä¼˜å…ˆé˜Ÿåˆ—é»˜è®¤æ˜¯å¤§æ ¹å †ï¼Œå¦‚æžœè¦ç”¨å°æ ¹å †å°±å¾—å†™æˆpriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;ï¼Œå…¶ä¸­ç¬¬äºŒä¸ªå‚æ•°å°±æ˜¯ä¼˜å…ˆé˜Ÿåˆ—çš„åº•å±‚æ•°æ®ç»“æž„ï¼Œè€Œç¬¬ä¸‰ä¸ªå‚æ•°è¡¨ç¤ºå€¼è¶Šå°è¶Šä¼˜å…ˆï¼Œå¯¹åº”çš„less&lt;int&gt;åˆ™è¡¨ç¤ºå€¼è¶Šå¤§è¶Šä¼˜å…ˆã€‚12345678910111213141516171819class SeatManager &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; q;public: SeatManager(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; q.push(i); &#125; &#125; int reserve() &#123; int tmp = q.top(); q.pop(); return tmp; &#125; void unreserve(int seatNumber) &#123; q.push(seatNumber); &#125;&#125;; 860. Lemonade ChangeAnalysisé»˜è®¤çš„æ‰¾é’±è§„åˆ™æ˜¯èƒ½æ‰¾å¤§çš„å°½é‡æ‰¾å¤§çš„ï¼Œæ‰€ä»¥è¿™æ˜¯ä¸€ä¸ªè·Ÿè´ªå¿ƒç›¸å…³çš„é—®é¢˜ã€‚ç”¨ 2 ä¸ªå˜é‡æ¥è®°å½•èƒ½è¢«æ‰¾å‡ºåŽ»çš„ 5 å—å’Œ 10 å—çš„æ•°ç›®ï¼Œæ¨¡æ‹Ÿæ‰¾é’±ã€‚å¦‚æžœé¡¾å®¢ç»™äº† 20 å—ï¼Œæ­¤æ—¶æœ‰ä¸¤ç§æ‰¾é’±æ–¹æ³•ï¼Œä½†æ˜¯å¾—æŒ‰ç…§è§„åˆ™æ¥è¿›è¡Œã€‚ä¸€æ—¦æŸä¸ªå˜é‡ä¸ºè´Ÿäº†ï¼Œè¯´æ˜Žæ²¡åŠžæ³•æ­£ç¡®æ‰¾é›¶ã€‚ Code1234567891011121314151617181920212223class Solution &#123;public: bool lemonadeChange(vector&lt;int&gt;&amp; bills) &#123; int five, ten; five = ten = 0; int size = bills.size(); for(int i = 0; i &lt; size; i++) &#123; if(bills[i] == 10) &#123; five--; ten++; if(five &lt; 0) return false; &#125; else if(bills[i] == 20) &#123; if(ten == 0) five -= 3; else &#123; ten--; five--; &#125; if(ten &lt; 0 || five &lt; 0) return false; &#125; else five++; &#125; return true; &#125;&#125;; Summaryç¬¬ä¸€ä¸ªé¢˜å¦‚æžœè¦æ˜¯è‡ªå·±å†™å †ï¼Œä¼°è®¡æŒºåºŸåŠ²çš„ðŸ˜‚ã€‚ç¬¬äºŒä¸ªé¢˜è¿˜ WA äº†ä¸€æ¬¡ï¼Œæœ‰ç‚¹äº...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day16]]></title>
    <url>%2F2022%2F05%2F15%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day16%2F</url>
    <content type="text"><![CDATA[go on, go on! 61. Rotate ListAnalysiså¥½åƒåšè¿‡è·Ÿè¿™ä¸ªé¢˜ç±»ä¼¼çš„æ—‹è½¬æ•°ç»„çš„é¢˜ï¼ŒæŠŠç»™å®šçš„é“¾è¡¨å½“æˆå¾ªçŽ¯é“¾è¡¨ï¼Œç„¶åŽç§»åŠ¨ä½ç½®å°±å¯ä»¥äº†ã€‚ Codeå…ˆç”¨æ•°ç»„æ¥å¤„ç†ï¼Œå¯èƒ½æ€è·¯ä¼šç®€å•ä¸€ç‚¹ã€‚1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; tmp, list; ListNode *p = head; while(p != nullptr) &#123; tmp.push_back(p); p = p-&gt;next; &#125; int size = tmp.size(); k %= size; if(k == 0) return head; for(int i = size - k; i &lt; size; i++) &#123; list.push_back(tmp[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; list.push_back(tmp[i]); &#125; for(int i = 0; i &lt; size - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - 1]-&gt;next = nullptr; return list[0]; &#125;&#125;; è„‘å­æŠ½äº†ï¼Œåœ¨æ•°ç»„çš„ä¸‹æ ‡ä¸Šè¿·ç³Šäº†å¥½ä¹…...è¿˜æ˜¯åŽŸæ¥åšè¿‡çš„ç±»ä¼¼é¢˜å•Šï¼ŒåºŸäº†ðŸ™ƒã€‚æ”¹æˆåªç”¨ä¸€ä¸ªæ•°ç»„çš„ï¼š123456789101112131415161718192021222324class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; list; ListNode *p = head; while(p != nullptr) &#123; list.push_back(p); p = p-&gt;next; &#125; int size = list.size(); k %= size; if(k == 0) return head; for(int i = size - k; i &lt; size - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - 1]-&gt;next = list[0]; for(int i = 0; i &lt; size - k - 1; i++) &#123; list[i]-&gt;next = list[i + 1]; &#125; list[size - k - 1]-&gt;next = nullptr; return list[size - k]; &#125;&#125;; å†æ”¹æˆçº¯æŒ‡é’ˆçš„ï¼š1234567891011121314151617181920212223242526class Solution &#123;public: ListNode* rotateRight(ListNode* head, int k) &#123; if(head == nullptr) return nullptr; ListNode *p = head; int cnt = 0; while(p != nullptr) &#123; cnt++; p = p-&gt;next; &#125; k %= cnt; if(k == 0) return head; p = head; ListNode *pre; int tmp = cnt - k; while(tmp--) &#123; pre = p; p = p-&gt;next; &#125; pre-&gt;next = nullptr; pre = p; while(p-&gt;next != nullptr) p = p-&gt;next; p-&gt;next = head; return pre; &#125;&#125;; å¥½åƒpreä¹Ÿå¯ä»¥çœä¸‹ï¼Ÿé¢ï¼Œå¥½åƒä¸è¡Œã€‚ 173. Binary Search Tree IteratorAnalysisè¯»å®Œä¸€éé¢˜ç›®ï¼Œå…¶å®žæ²¡å¤ªæ˜Žç™½é¢˜ç›®çš„æ„æ€ã€‚å°è¯•çš„å†™äº†ä¸€ä¸‹ï¼Œç«Ÿç„¶é€šè¿‡äº†ï¼Œä»”ç»†ä¸€çœ‹è¿™ä¸ªé¢˜ 80% çš„é€šè¿‡çŽ‡å•Š~ Code12345678910111213141516171819202122232425class BSTIterator &#123; vector&lt;int&gt; seq; int pointer, count;public: void inorder(TreeNode *root) &#123; if(root == nullptr) return; inorder(root-&gt;left); seq.push_back(root-&gt;val); inorder(root-&gt;right); &#125; BSTIterator(TreeNode* root) &#123; inorder(root); pointer = 0; count = seq.size(); &#125; int next() &#123; return seq[pointer++]; &#125; bool hasNext() &#123; if(pointer &lt; count) return true; else return false; &#125;&#125;; æ€è·¯å¾ˆç®€å•ï¼Œå¾—åˆ°ä¸­åºåºåˆ—åŽï¼Œè®¾ç½®ä¸€ä¸ªæŒ‡é’ˆpointerç”¨äºŽ next å‡½æ•°ï¼Œå†è®¾ç½®ä¸€ä¸ªcountè®°å½•ç»“ç‚¹æ€»ä¸ªæ•°ï¼Œç”¨äºŽ hasNext å‡½æ•°ã€‚çœ‹äº†ä¸‹å®˜æ–¹é¢˜è§£ï¼Œè¿™ç§æ–¹æ³•æœ‰ä¸ªå¤§åå«æ‰å¹³åŒ–ðŸ˜‚ã€‚è¿˜å¯ä»¥ç”¨æ ˆæ¥æ¨¡æ‹Ÿå•æ¬¡éåŽ†äºŒå‰æ ‘ï¼Œå°±ä¸å†™äº†å§ã€‚ Summaryæˆ‘ç®—æ˜¯å‘çŽ°äº†ï¼Œè¿™ä¸ªç³»åˆ—ï¼Œå¥½åƒæ•°å­¦é¢˜æ˜¯æœ€å¤šçš„ï¼Œæ¶‰åŠçš„ç®—æ³•æ€æƒ³å’Œæ•°æ®ç»“æž„åè€Œå¾ˆå°‘...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day15]]></title>
    <url>%2F2022%2F05%2F14%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day15%2F</url>
    <content type="text"><![CDATA[è¿˜æ˜¯ä¸¤é“é“¾è¡¨é¢˜ã€‚ 2. Add Two NumbersAnalysisæŠ«ç€é“¾è¡¨å¤–å£³çš„å¤§æ•°åŠ æ³•é¢˜ï¼Œç®—æ˜¯æ¨¡æ‹ŸåŠ æ³•ä¸Žåˆå¹¶é“¾è¡¨ä¸¤ä¸ªé¢˜çš„ç»“åˆç‰ˆã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr &amp;&amp; l2 != nullptr) &#123; int sum = l1-&gt;val + l2-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l1 = l1-&gt;next; l2 = l2-&gt;next; &#125; while(l1 != nullptr) &#123; int sum = l1-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l1 = l1-&gt;next; &#125; while(l2 != nullptr) &#123; int sum = l2-&gt;val + carry; if(sum &gt; 9) &#123; sum -= 10; carry = 1; &#125; else carry = 0; ListNode *tmp = new ListNode(sum); p-&gt;next = tmp; p = tmp; l2 = l2-&gt;next; &#125; if(carry) &#123; ListNode *tmp = new ListNode(carry); p-&gt;next = tmp; &#125; p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; è¿™æ ·å†™è™½ç„¶å¾ˆæ€è·¯æ¸…æ¥šï¼Œä½†æ˜¯çœ‹ç€å¾ˆç¹çï¼ˆä¸»è¦æ˜¯å¤ªé•¿ï¼‰ï¼Œæ”¹çŸ­ä¸€ç‚¹ï¼š123456789101112131415161718192021222324class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr || l2 != nullptr) &#123; int n1 = l1 != nullptr ? l1-&gt;val : 0; int n2 = l2 != nullptr ? l2-&gt;val : 0; int sum = n1 + n2 + carry; ListNode *tmp = new ListNode(sum % 10); carry = sum / 10; p-&gt;next = tmp; p = tmp; if(l1 != nullptr) l1 = l1-&gt;next; if(l2 != nullptr) l2 = l2-&gt;next; &#125; if(carry) p-&gt;next = new ListNode(carry); p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; 445. Add Two Numbers IIAnalysisè¿™æ˜¯ä¸Šä¸ªé¢˜çš„å‡çº§ç‰ˆï¼Œå·®åˆ«åœ¨äºŽè¿™é‡Œå°†æ•°å­—çš„æ¯ä¸€ä½æ­£åºå­˜åœ¨é“¾è¡¨ä¸­äº†ï¼Œæ‰€ä»¥è®¡ç®—ä¹‹å‰å¾—å…ˆé€†ç½®é“¾è¡¨ã€‚ Codeç›´æŽ¥æŠŠä¸Šé¢çš„ä»£ç ä¸ŽåŽŸæ¥å†™è¿‡çš„åè½¬é“¾è¡¨ä»£ç æŠ„è¿‡æ¥ðŸ˜‚ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; l1 = reverseList(l1); l2 = reverseList(l2); return reverseList(addTwoNumbers1(l1, l2)); &#125; ListNode* addTwoNumbers1(ListNode* l1, ListNode* l2) &#123; ListNode *L = new ListNode(); ListNode *p = L; int carry = 0; while(l1 != nullptr || l2 != nullptr) &#123; int n1 = l1 != nullptr ? l1-&gt;val : 0; int n2 = l2 != nullptr ? l2-&gt;val : 0; int sum = n1 + n2 + carry; ListNode *tmp = new ListNode(sum % 10); carry = sum / 10; p-&gt;next = tmp; p = tmp; if(l1 != nullptr) l1 = l1-&gt;next; if(l2 != nullptr) l2 = l2-&gt;next; &#125; if(carry) p-&gt;next = new ListNode(carry); p = L; L = L-&gt;next; delete(p); return L; &#125; ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125;&#125;; è¿˜æœ‰ä¸€ä¸ªè¿›é˜¶æç¤ºæ˜¯ä¸åè½¬é“¾è¡¨å¦‚ä½•åšã€‚å¦‚æžœä¸åè½¬é“¾è¡¨çš„è¯ï¼Œå¯ä»¥ç”¨æ ˆæ¥ä¿å­˜é“¾è¡¨èŠ‚ç‚¹ï¼Œç„¶åŽä¾æ¬¡å–æ ˆé¡¶ç»“ç‚¹æ¥è¿›è¡Œè®¡ç®—ï¼Œè®¡ç®—æ€è·¯ä¸Žä¸Šä¸€ä¸ªé¢˜æ˜¯ä¸€æ ·çš„ã€‚ä¸è¿‡ä¸ºäº†ç›´æŽ¥å¾—åˆ°æ­£åºçš„ç»“æžœï¼Œåœ¨æž„é€ æ–°é“¾è¡¨çš„æ—¶å€™ï¼Œéœ€è¦å°†æœ€å…ˆæ’å…¥çš„ç»“ç‚¹æ”¾åˆ°æœ€åŽé¢ï¼Œæ‰€ä»¥è¿™é‡Œçš„æŒ‡é’ˆä½¿ç”¨ä¸Žä¸Šä¸€ä¸ªé¢˜ä¸ä¸€æ ·ï¼ˆå®žé™…ä¸Šå°±æ˜¯é“¾è¡¨çš„å¦ä¸€ç§å»ºç«‹æ–¹æ³•ï¼‰ã€‚å·ä¸ªæ‡’ï¼Œä¸å†™äº†å§ðŸ˜ã€‚ Summaryæ„Ÿè§‰é“¾è¡¨çš„é¢˜åšçš„æœ‰ç‚¹ä¹å‘³ï¼Œå› ä¸ºæ˜¯åŸºç¡€çš„ç¼˜æ•…ï¼Œå¥½åƒä¹Ÿæ²¡æœ‰ç¼–ä¸€äº›å¤æ‚æ•°æ®ç»“æž„çš„é¢˜åˆ°è¿™ä¸ªç³»åˆ—å—ï¼Ÿ]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day14]]></title>
    <url>%2F2022%2F05%2F13%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day14%2F</url>
    <content type="text"><![CDATA[ç»§ç»­ï¼Œç»§ç»­ã€‚ 143. Reorder ListAnalysisæŒ‰ç…§é¢˜ç›®ç»™å®šçš„æ–¹å¼æ¥é‡æŽ’é“¾è¡¨ï¼Œå°±æ˜¯å¤´ä¸€ä¸ªï¼Œå°¾ä¸€ä¸ªï¼Œäº¤æ›¿æŽ’åˆ—ã€‚ Codeå¾ˆå®¹æ˜“æƒ³åˆ°ç”¨æ ˆæ¥ä¿å­˜å€’åºçš„é“¾è¡¨ï¼Œè¿™æ ·é‡æŽ’æ—¶å°±å¯ä»¥ç›´æŽ¥æ‹¿æ¥ç”¨äº†ã€‚12345678910111213141516171819202122232425class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head-&gt;next) return; stack&lt;ListNode*&gt; st; ListNode *p = head; int cnt = 0; while(p) &#123; st.push(p); cnt++; p = p-&gt;next; &#125; p = head; for(int i = 1; i &lt; cnt; i++) &#123; if(i % 2) &#123; ListNode *tmp = p-&gt;next; p-&gt;next = st.top(); st.pop(); p = p-&gt;next; p-&gt;next = tmp; &#125; else p = p-&gt;next; &#125; p-&gt;next = nullptr; &#125;&#125;; æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ã€‚çœ‹äº†ä¸‹å®˜æ–¹é¢˜è§£ï¼Œè¿˜æœ‰å¦å¤–ä¸€ç§è§£æ³•ï¼šå°†é“¾è¡¨æŒ‰ç…§ä¸­é—´ç»“ç‚¹åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œå°†åŽåŠéƒ¨åˆ†é“¾è¡¨ç¿»è½¬ï¼Œç„¶åŽåˆå¹¶ä¸¤ä¸ªå­é“¾è¡¨å°±å¯ä»¥å¾—åˆ°ç»“æžœäº†ã€‚æŠŠåŽŸæ¥å†™è¿‡çš„é¢˜çš„ä»£ç ç›´æŽ¥ copy è¿‡æ¥ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/* find middle node + reverse list + merge list */class Solution &#123;public: void reorderList(ListNode* head) &#123; if(!head-&gt;next) return; ListNode *mid = middleNode(head); ListNode *L1 = head; ListNode *L2 = mid-&gt;next; mid-&gt;next = nullptr; L2 = reverseList(L2); mergeTwoLists(L1, L2); &#125; ListNode* middleNode(ListNode* head) &#123; ListNode *slow = head, *fast = head; while(fast-&gt;next != nullptr &amp;&amp; fast-&gt;next-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125; ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head != nullptr) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125; void mergeTwoLists(ListNode* list1, ListNode* list2) &#123; ListNode *p1; ListNode *p2; while(list1 != nullptr &amp;&amp; list2 != nullptr) &#123; p1 = list1-&gt;next; p2 = list2-&gt;next; list1-&gt;next = list2; list1 = p1; list2-&gt;next = list1; list2 = p2; &#125; &#125;&#125;; æ—¶é—´å¤æ‚åº¦ï¼š$O(n)$ï¼Œç©ºé—´å¤æ‚åº¦ï¼š$O(1)$ï¼Œè™½ç„¶ä¼˜åŒ–äº†ç©ºé—´å¤æ‚åº¦ï¼Œä½†æ˜¯å¥½éº»çƒ¦ï¼Œæœ‰æ²¡æœ‰ã€‚PSï¼šç©ºæŒ‡é’ˆçš„åˆ¤æ–­æœ€å¥½ä¸è¦ç”¨!ï¼Œå†™æˆ!= nullptræ¯”è¾ƒå¥½ã€‚ 138. Copy List with Random PointerAnalysisé¢˜ç›®å¥½é•¿å•Š...emâ€¦è¿™ä¸ªé¢˜å¦‚æžœå¯¹æ·±æ‹·è´å’ŒæŒ‡é’ˆç†è§£çš„æ¯”è¾ƒæ¸…æ™°çš„è¯ï¼Œåº”è¯¥å¾ˆå®¹æ˜“è¯»æ‡‚é¢˜ç›®è¦å¹²ä»€ä¹ˆã€‚å…¶å®žå°±æ˜¯å°†åŽŸé“¾è¡¨ copy ä¸€ä»½ï¼Œä½†æ˜¯æ–°é“¾è¡¨æ¯ä¸ªçš„ random çš„å€¼è¦å˜æˆæ–°é“¾è¡¨çš„å¯¹åº”ç»“ç‚¹çš„åœ°å€ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯æ–°é“¾è¡¨ç»“ç‚¹çš„ç›¸å¯¹ä½ç½®ä¸Žæ—§é“¾è¡¨æ˜¯ä¸€æ ·çš„ã€‚ Codemethod 11234567891011121314151617181920212223242526272829303132class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, int&gt; ht; vector&lt;Node*&gt; nodes; Node *p = head; int index = 0; while(p) &#123; ht[p] = index++; Node *node = new Node(p-&gt;val); nodes.push_back(node); p = p-&gt;next; &#125; int indices[1005]; memset(indices, -1, sizeof(indices)); p = head; index = 0; while(p) &#123; if(p-&gt;random != nullptr) indices[index] = ht[p-&gt;random]; index++; p = p-&gt;next; &#125; for(int i = 1; i &lt; index; i++) &#123; nodes[i - 1]-&gt;next = nodes[i]; &#125; for(int i = 0; i &lt; index; i++) &#123; if(indices[i] != -1) nodes[i]-&gt;random = nodes[indices[i]]; &#125; return nodes[0]; &#125;&#125;; è¿™é¢˜å¤ªéº»çƒ¦äº†ï¼Œè€Œä¸”å®¹æ˜“æŠŠäººç»•æ™•ðŸ˜µã€‚å› ä¸º random æ˜¯ä¸ªæŒ‡é’ˆï¼Œæ‰€ä»¥ä¸ºäº†çŸ¥é“åŽŸé“¾è¡¨ä¸­æ¯ä¸ªç»“ç‚¹ä¸­ random åˆ°åº•æŒ‡å‘çš„æ˜¯å½“å‰é“¾è¡¨çš„ç¬¬å‡ ä¸ªç»“ç‚¹ï¼Œå¿…é¡»è¦å°†åŽŸé“¾è¡¨ç»“ç‚¹çš„åœ°å€æŒ‰ç…§[address, index]çš„æ ¼å¼æ•£åˆ—ã€‚ç„¶åŽå†é‡æ–°éåŽ†åŽŸé“¾è¡¨ï¼Œè¿™æ ·å°±çŸ¥é“æ¯ä¸ªç»“ç‚¹çš„ random åˆ°åº•æŒ‡å‘çš„æ˜¯å½“å‰é“¾è¡¨çš„ç¬¬å‡ ä¸ªç»“ç‚¹äº†ã€‚è¿™æ ·åœ¨å¤åˆ¶å¥½æ–°é“¾è¡¨åŽï¼Œè¿™æ ·é‡æ–°éåŽ†ä¸€æ¬¡æ–°é“¾è¡¨å°±å¯ä»¥å°†æ‰€æœ‰æ–°ç»“ç‚¹çš„ random æŒ‡é’ˆå…¨éƒ¨è®¾ç½®å¥½ã€‚ ä»”ç»†æƒ³æƒ³ï¼Œæœ‰å¿…è¦ç”¨ hash æ¥ä¿å­˜ç»“ç‚¹çš„åœ°å€ä¸Žç´¢å¼•çš„æ˜ å°„å—ï¼Ÿç›´æŽ¥æŒ‰ç…§æ—§ç»“ç‚¹ä¸Žæ–°ç»“ç‚¹åœ°å€çš„æ˜ å°„æ¥ä¿å­˜ä¸æ˜¯æ›´å¥½å—ï¼Ÿå› ä¸ºè¿™æ ·åœ¨éåŽ†æ–°é“¾è¡¨çš„æ—¶å€™ä¾ç„¶å¯ä»¥ä¸€æ¬¡æ€§ä¿®æ”¹æ‰€æœ‰æ–°ç»“ç‚¹çš„ random æŒ‡é’ˆã€‚12345678910111213141516171819202122232425class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, Node*&gt; ht; vector&lt;Node*&gt; nodes; Node *p = head; int cnt = 0; while(p) &#123; Node *node = new Node(p-&gt;val); node-&gt;random = p-&gt;random; ht[p] = node; nodes.push_back(node); p = p-&gt;next; cnt++; &#125; for(int i = 0; i &lt; cnt; i++) &#123; nodes[i]-&gt;random = ht[nodes[i]-&gt;random]; &#125; for(int i = 1; i &lt; cnt; i++) &#123; nodes[i - 1]-&gt;next = nodes[i]; &#125; return nodes[0]; &#125;&#125;; å†å›žå¤´æƒ³æƒ³ï¼Œä¹‹æ‰€ä»¥è¦ç”¨åˆ° vectorï¼Œæ˜¯ä¸ºäº†ä¿å­˜æ¯ä¸ªæ–°ç»“ç‚¹ï¼Œç„¶åŽå†éåŽ† vector å°†æ–°èŠ‚ç‚¹è¿žæˆé“¾è¡¨ã€‚æœ‰åŠžæ³•ä¸ç”¨ vectorï¼ŒåŒæ—¶ä¹Ÿå°†é“¾è¡¨è¿žèµ·æ¥å—ï¼Ÿå›žé¡¾é“¾è¡¨çš„å»ºç«‹ï¼Œå¾ˆå®¹æ˜“ä¼šæƒ³åˆ°å»ºç«‹é“¾è¡¨çš„å‡ ç§æ–¹æ³•ï¼šå¤´æ’æ³•ã€å°¾æ’æ³•ç­‰ï¼Œä¸è¿‡æ„Ÿè§‰æœ€å¥½ç”¨çš„è¿˜æ˜¯å¸¦å¤´ï¼ˆå“‘ï¼‰ç»“ç‚¹çš„å°¾æ’æ³•ï¼ˆé“¾è¡¨å»ºç«‹çš„æ–¹æ³•å¾ˆå¤šï¼Œå«æ³•å¯èƒ½ä¸ä¸€è‡´ï¼Œæ€»ä¹‹ä¼šå°±è¡Œäº†ðŸ˜‚ï¼‰ã€‚123456789101112131415161718192021222324252627class Solution &#123;public: Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; unordered_map&lt;Node*, Node*&gt; ht; Node *L = new Node(INT_MAX); Node *p = head, *t = L; while(p) &#123; Node *node = new Node(p-&gt;val); node-&gt;random = p-&gt;random; t-&gt;next = node; t = t-&gt;next; ht[p] = node; p = p-&gt;next; &#125; t = L; L = L-&gt;next; delete(t); t = L; while(t) &#123; if(ht.count(t-&gt;random)) t-&gt;random = ht[t-&gt;random]; t = t-&gt;next; &#125; cout &lt;&lt; endl; return L; &#125;&#125;; è¿™ä¸ªå†™å®Œä¹‹åŽï¼Œå…¶å®žå¯ä»¥å‘çŽ°å‰é¢å†™çš„ä»£ç æœ‰ç‚¹é—®é¢˜ã€‚é—®é¢˜åœ¨äºŽä¿®æ”¹æ–°é“¾è¡¨çš„ random æ—¶ï¼Œæ²¡æœ‰å…ˆç”¨ map çš„ count å‡½æ•°åšåˆ¤æ–­ï¼Œä½†ä¾ç„¶å¯ä»¥æäº¤é€šè¿‡ã€‚ä¸ºä»€ä¹ˆå‘¢ï¼Ÿå› ä¸ºåœ¨ä¹‹å‰çš„ä»£ç ä¸­ï¼Œå“ˆå¸Œè¡¨htä¸­æ²¡æœ‰ä¿å­˜ key ä¸ºnullptr çš„é”®å€¼å¯¹ï¼Œåœ¨æ‰§è¡Œht[nullptr] = xxxæ—¶ï¼Œä¼šè‡ªåŠ¨æ·»åŠ è¿™ä¸€é¡¹ï¼Œä½†å¯¹åº”çš„ value é»˜è®¤æ˜¯0ï¼Œè€Œè¿™ä¸ª0ä¸Ž C/C++ çš„NULLå’Œnullptrè¡¨ç¤ºçš„å€¼ï¼ˆä»…å°±å€¼è€Œè¨€ï¼‰æ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥ï¼Œåº”è¯¥æ˜¯ç¼–è¯‘å™¨è‡ªåŠ¨çš„å°†è¿™ä¸ª 0 è½¬æ¢ä¸ºç©ºæŒ‡é’ˆèµ‹ç»™äº† randomï¼ˆæ²¡é”™ï¼Œg++ ä¼šè‡ªå·±åšå¼ºåˆ¶ç±»åž‹è½¬æ¢ï¼Œå°†èµ‹å€¼è¯­å¥å³è¾¹çš„å˜é‡ç±»åž‹è½¬æ¢ä¸ºèµ‹å€¼è¯­å¥å·¦è¾¹çš„å˜é‡ç±»åž‹ï¼‰ã€‚è€Œå·§åˆçš„æ˜¯ï¼Œå¤åˆ¶è¿™äº›æ–°ç»“ç‚¹çš„æ—§ç»“ç‚¹çš„randomæœ¬æ¥å°±æ˜¯nullptr ðŸ˜‚ï¼Œæ‰€ä»¥æ˜¯ä¸å½±å“ç»“æžœçš„æ­£ç¡®æ€§çš„ã€‚ å› ä¸ºè¿™ä¸ªé¢˜åªç»™äº†å¸¦å‚çš„æž„é€ å‡½æ•°ï¼Œæ‰€ä»¥è¦å¸¦ä¸ªå‚æ•°ðŸ˜ã€‚çœ‹äº†ä¸€çœ¼å®˜æ–¹é¢˜è§£ï¼Œæžœç„¶ï¼Œè¿™ç§æ€è·¯å¯ä»¥æ”¹æˆé€’å½’ã€‚1234567891011121314class Solution &#123;public: unordered_map&lt;Node*, Node*&gt; ht; Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; if(!ht.count(head)) &#123; Node *node = new Node(head-&gt;val); ht[head] = node; node-&gt;next = copyRandomList(head-&gt;next); node-&gt;random = copyRandomList(head-&gt;random); &#125; return ht[head]; &#125;&#125;; è¯´æ˜¯é€’å½’ï¼Œå®žé™…ä¸Šæ˜¯å›žæº¯ + å“ˆå¸Œçš„æ€è·¯ã€‚ method 2å®˜æ–¹é¢˜è§£ç»™çš„ç¬¬äºŒç§æ€è·¯ï¼Œå€’æ˜¯æŒºæœ‰æ„æ€ã€‚ä»¥A-&gt;B-&gt;C-&gt;Dä¸ºä¾‹ï¼Œå…ˆæ”¹æˆA-&gt;A&#39;-&gt;B-&gt;B&#39;-&gt;C-&gt;C&#39;-&gt;D-&gt;D&#39;ã€‚è¿™æ ·æ”¹äº†ä¹‹åŽï¼Œå¯¹äºŽæ–°é“¾è¡¨è€Œè¨€ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„æ‰¾åˆ°æ–°é“¾è¡¨ç»“ç‚¹ä¹‹é—´ä¸ŽåŽŸé“¾è¡¨ç»“ç‚¹ä¹‹é—´ä¸€è‡´çš„ç›¸å¯¹ä½ç½®ï¼Œä¹Ÿå°±æ˜¯node-&gt;random-&gt;nextã€‚1234567891011121314151617181920212223class Solution &#123;public: unordered_map&lt;Node*, Node*&gt; ht; Node* copyRandomList(Node* head) &#123; if(head == nullptr) return nullptr; for(Node *node = head; node != nullptr; node = node-&gt;next-&gt;next) &#123; Node *nodenew = new Node(node-&gt;val); nodenew-&gt;next = node-&gt;next; node-&gt;next = nodenew; &#125; for(Node *node = head; node != nullptr; node = node-&gt;next-&gt;next) &#123; Node *nodenew = node-&gt;next; nodenew-&gt;random = (node-&gt;random != nullptr) ? node-&gt;random-&gt;next : nullptr; &#125; Node *headnew = head-&gt;next; for(Node *node = head; node != nullptr; node = node-&gt;next) &#123; Node *nodenew = node-&gt;next; node-&gt;next = node-&gt;next-&gt;next; nodenew-&gt;next = (nodenew-&gt;next != nullptr) ? nodenew-&gt;next-&gt;next : nullptr; &#125; return headnew; &#125;&#125;; Summrayè¿™ä¸¤ä¸ªä¸Žé“¾è¡¨ç›¸å…³çš„ä¸­ç­‰é¢˜è¿˜æœ‰ç‚¹æ„æ€ï¼ŒåŸºæœ¬ä¸Šå¯ä»¥æƒ³åˆ°åšæ³•ï¼Œè™½ç„¶å¯ä»¥é€šè¿‡ï¼Œä½†ä¸æ˜¯æ¯”è¾ƒä¼˜ç§€çš„è§£æ³•ã€‚çªç„¶å‘çŽ°ï¼Œä¸­ç­‰é¢˜ï¼Œå¥½åƒå°±æ˜¯æŠŠå•ä¸€çš„çŸ¥è¯†ç‚¹ç»“åˆèµ·æ¥äº†ã€‚å°±åƒè¿™ä¸¤ä¸ªé¢˜ï¼Œæ—¢éœ€è¦é“¾è¡¨çš„çŸ¥è¯†ï¼Œä¹Ÿéœ€è¦å“ˆå¸Œã€æ ˆçš„ä¸€äº›çŸ¥è¯†ã€‚æ‰€ä»¥ï¼Œè¿˜æ˜¯è¦è§å¤šè¯†å¹¿ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day13]]></title>
    <url>%2F2022%2F05%2F12%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day13%2F</url>
    <content type="text"><![CDATA[ä¸çŸ¥é“å†™ä»€ä¹ˆå¥½äº†...ðŸ˜ 304. Range Sum Query 2D - ImmutableAnalysisè¿™æ˜¯ä¸ªå‰ç¼€å’Œçš„é¢˜ï¼Œè€Œä¸”æ˜¯äºŒç»´æ•°ç»„çš„å‰ç¼€å’Œã€‚ Codemethod 1è¿™ç§é¢˜å¦‚æžœçŸ¥é“æŽ¨å¯¼çš„å…¬å¼çš„è¯ï¼Œå°±å¾ˆç®€å•äº†ã€‚ä¸è¿‡ï¼Œè¿˜æ˜¯è‡ªå·±å…ˆåšä¸€ä¸‹ã€‚å› ä¸ºçŸ¥é“äº†æ˜¯å‰ç¼€å’Œçš„é¢˜ï¼Œæ‰€ä»¥å…ˆæŒ‰ç…§ä¸€ç»´å‰ç¼€å’Œçš„æ€è·¯æ¥å¤„ç†ã€‚1234567891011121314151617181920class NumMatrix &#123;public: vector&lt;vector&lt;int&gt;&gt; prefixsum = vector&lt;vector&lt;int&gt;&gt;(205, vector&lt;int&gt;(205)); NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; prefixsum[i][j + 1] = prefixsum[i][j] + matrix[i][j]; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; int sum = 0; while(row1 &lt;= row2) &#123; sum += prefixsum[row1][col2 + 1] - prefixsum[row1][col1]; row1++; &#125; return sum; &#125;&#125;; emï¼Œä¸€ç»´å‰ç¼€å’Œçš„æ€è·¯ï¼Œå‹‰å¼ºé€šè¿‡äº†ã€‚ method 2å†å›žå¤´è€ƒè™‘äºŒç»´å‰ç¼€å’Œçš„æ€è·¯ï¼Œé¦–å…ˆåº”è¯¥æ˜Žç¡®çš„äºŒç»´å‰ç¼€å’Œä¸­çš„å’Œï¼Œæ˜¯ä»¥å½“å‰åæ ‡çš„å…ƒç´ ä¸ºå³ä¸‹è§’ï¼ˆä¹Ÿå°±æ˜¯æœ€åŽä¸€ä¸ªï¼‰å…ƒç´ çš„çŸ©é˜µçš„å…ƒç´ ä¹‹å’Œã€‚æŒ‰ç…§æŽ¨å¯¼å…¬å¼ï¼ˆå…·ä½“æ€Žä¹ˆæŽ¨å¯¼ä¸è®¨è®ºäº†ï¼‰å¯ä»¥çŸ¥é“ï¼š123prefixsum[i + 1][j + 1] = prefixsum[i - 1][j] + prefixsum[i][j - 1] - prefixsum[i - 1][j - 1] + matrix[i][j] ä¹‹æ‰€ä»¥è¦å†™æˆ i + 1 ä¸Ž j + 1 çš„å½¢å¼ï¼Œæ˜¯ä¸ºäº†é¿å…å½“ row = 0ï¼Œcol = 0 æ—¶çš„ç‰¹æ®Šåˆ¤æ–­ï¼Œè¿™ç‚¹ä¸Žä¸€ç»´å‰ç¼€å’Œçš„æ€è·¯æ˜¯ä¸€è‡´çš„ã€‚å¯¹åº”çš„ï¼š123sumRegion(row1, col1, row2, col2)= prefixsum[row2 + 1][col2 - 1] - prefixsum[row1][col2 + 1] - prefixsum[row2 + 1][col1] + prefixsum[row1][col1] å°±å¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç äº†ï¼š1234567891011121314151617181920class NumMatrix &#123;public: vector&lt;vector&lt;int&gt;&gt; prefixsum = vector&lt;vector&lt;int&gt;&gt;(205, vector&lt;int&gt;(205)); NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(); if(m &gt; 0) &#123; int n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; prefixsum[i + 1][j + 1] = prefixsum[i][j + 1] + prefixsum[i + 1][j] - prefixsum[i][j] + matrix[i][j]; &#125; &#125; &#125; &#125; int sumRegion(int row1, int col1, int row2, int col2) &#123; return prefixsum[row2 + 1][col2 + 1] - prefixsum[row1][col2 + 1] - prefixsum[row2 + 1][col1] + prefixsum[row1][col1]; &#125;&#125;; PSï¼šç”»ä¸€ä¸ªçŸ©å½¢ï¼Œç”¨æ±‚çŸ©å½¢å°å—é¢ç§¯çš„æ€è·¯æ¥ç†è§£äºŒç»´å‰ç¼€å’Œæ¯”è¾ƒç›´è§‚ï¼Œçœ‹å…¬å¼å®¹æ˜“çœ‹æ™•ã€‚ 910. Smallest Range IIAnalysisè¿™ä¸ªé¢˜æ˜¯ 908. Smallest Range I çš„åŠ å¼ºç‰ˆï¼Œå·®åˆ«åœ¨äºŽè¿™ä¸ªé¢˜æ—¢å¯ä»¥å¯¹æ•°ç»„å…ƒç´ åŠ  kï¼Œä¹Ÿå¯ä»¥å¯¹æ•°ç»„å…ƒç´ å‡ kã€‚æ‰€ä»¥ï¼Œä¸ºäº†ä¿æŒæ“ä½œç»“æŸåŽçš„æ•°ç»„çš„æœ€å€¼å·®æœ€å°ï¼Œå°±å¾—è®©æ•°ç»„ä¸­å¤§çš„æ•°å‡ kï¼Œå°çš„æ•°åŠ  kã€‚ä½†éš¾ç‚¹åœ¨äºŽï¼Œè¯¥å¦‚ä½•ç•Œå®šè¿™é‡Œæåˆ°çš„å¤§å’Œå°å‘¢ï¼Ÿ Codeè™½ç„¶ï¼Œè¿™ä¸ªé¢˜çš„æ ‡ç­¾æ˜¯è´ªå¿ƒã€æŽ’åºå’Œæ•°å­¦ï¼Œä½†ä¸ªäººæ„Ÿè§‰æ˜¯ä¸ªæŠ–æœºçµé¢˜ç›®ã€‚è¿™ä¸ªäººçš„é¢˜è§£å†™çš„å¾ˆæ¸…æ¥šï¼šå¤ªéš¾äº†ï¼Œåªèƒ½ç”»å›¾å‡­ç›´è§‰ã€‚1234567891011121314class Solution &#123;public: int smallestRangeII(vector&lt;int&gt;&amp; nums, int k) &#123; sort(nums.begin(), nums.end()); int mymin, mymax, size = nums.size(); int ans = nums[size - 1] - nums[0]; for(int i = 0; i &lt; size - 1; i++) &#123; mymin = min(nums[0] + k, nums[i + 1] - k); mymax = max(nums[size - 1] - k, nums[i] + k); ans = min(ans, mymax - mymin); &#125; return ans; &#125;&#125;; Summaryå‰ç¼€å’Œçš„é¢˜ç›®æŒºå¸¸è§„ï¼Œç¬¬äºŒä¸ªé¢˜æœ‰ç‚¹å¥‡æ€ª~é¡ºè·¯å†æŠŠä¸€ç»´å‰ç¼€å’Œçš„é¢˜ç›®ç»™åšäº†ï¼š303. Range Sum Query - Immutableã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day12]]></title>
    <url>%2F2022%2F05%2F11%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day12%2F</url>
    <content type="text"><![CDATA[20 å¤©æ‰èƒ½ç»“æŸï¼Œæ‰åˆ° 12 å¤©å•Šã€‚ 438. Find All Anagrams in a StringAnalysisæ‰¾å‡ºå­—ç¬¦ä¸² s ä¸­å­˜åœ¨çš„ p çš„å­—æ¯å¼‚ä½è¯ã€‚ Codeè¿™ç§é¢˜å¾ˆå®¹æ˜“æƒ³åˆ° $O(n^2)$ çš„æš´åŠ›è§£æ³•ï¼Œä½†æ˜¯æ•°æ®è§„æ¨¡æ˜¯ $[1, 3 Ã— 10^4]$ï¼Œæ¯«æ— ç–‘é—®ä¼šè¶…æ—¶ã€‚æŒ‰ç…§é¢˜ç›®çš„ç±»åž‹æ¥çœ‹ï¼Œåº”è¯¥æ˜¯æ»‘åŠ¨çª—å£çš„é¢˜ç›®ï¼Œå…ˆæŠŠæš´åŠ›è§£æ³•å†™å‡ºæ¥å§ã€‚12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt;= slen - plen; i++) &#123; vector&lt;int&gt; tmp(26); for(int j = i; j &lt; i + plen; j++) &#123; tmp[s[j] - 'a']++; &#125; if(tmp == cnt) ret.push_back(i); &#125; return ret; &#125;&#125;; æ²¡æƒ³åˆ°ï¼Œè¿™ä¸ªæš´åŠ›è§£æ³•ä¹Ÿèƒ½è¿‡ã€‚åˆ¤æ–­æ˜¯å¦æ˜¯å­—æ¯å¼‚ä½è¯ä¹Ÿå¯ä»¥ç”¨æŽ’åºæ¥å®žçŽ°ï¼Œè¿™æ˜¯ä»Žæ˜¨å¤©çš„é¢˜ä¸­å­¦æ¥çš„ï¼Œä½†æ˜¯æŽ’åºçš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlogn)$ï¼Œä¸å¦‚ $O(n)$ çš„æ•£åˆ—æ¥çš„å¿«ã€‚çŽ°åœ¨å†å›žå¤´è€ƒè™‘å¦‚ä½•ç”¨æ»‘åŠ¨çª—å£æ¥å¤„ç†ï¼š12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26), tmp(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; tmp[s[i] - 'a']++; &#125; if(cnt == tmp) ret.push_back(0); for(int i = 0; i &lt; slen - plen; i++) &#123; tmp[s[i]- 'a']--; tmp[s[i + plen] - 'a']++; if(tmp == cnt) ret.push_back(i + 1); &#125; return ret; &#125;&#125;; æ»‘åŠ¨çª—å£çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•ç†è§£çª—å£ï¼Œå°±è¿™ä¸ªé¢˜æ¥è®²ï¼Œçª—å£çš„å¤§å°å°±æ˜¯å­—ç¬¦ä¸² p çš„é•¿åº¦ã€‚æ¯æ¬¡æ»‘åŠ¨çª—å£çš„æ—¶å€™ï¼Œå°±æŠŠå·¦ç«¯çš„å­—ç¬¦ä»Žçª—å£ç§»å‡ºåŽ»ï¼Œå†æŠŠå³ç«¯çš„å­—ç¬¦åŠ å…¥åˆ°çª—å£ä¸­æ¥ã€‚å®˜æ–¹é¢˜è§£è¿˜æä¾›äº†ä¸€ç§ä¼˜åŒ–ç‰ˆçš„æ»‘åŠ¨çª—å£æ€è·¯ï¼Œå³ä¸å†ç»Ÿè®¡çª—å£å†…å­—ç¬¦çš„æ•°é‡ï¼Œåªç”¨ä¸€ä¸ªå˜é‡ diff æ¥è®°å½•å½“å‰çª—å£å­—ç¬¦ä¸²ä¸Ž p ä¸­æ•°é‡ä¸åŒçš„å­—æ¯çš„ä¸ªæ•°ã€‚123456789101112131415161718192021222324252627282930class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[s[i] - 'a']++; cnt[p[i] - 'a']--; &#125; int diff = 0; for(int i = 0; i &lt; 26; i++) &#123; if(cnt[i] != 0) diff++; &#125; if(diff == 0) ret.push_back(0); for(int i = 0; i &lt; slen - plen; i++) &#123; // left if(cnt[s[i] - 'a'] == 1) diff--; else if(cnt[s[i] - 'a'] == 0) diff++; cnt[s[i] - 'a']--; // right if(cnt[s[i + plen] - 'a'] == -1) diff--; else if(cnt[s[i + plen] - 'a'] == 0) diff++; cnt[s[i + plen] - 'a']++; // judge if(diff == 0) ret.push_back(i + 1); &#125; return ret; &#125;&#125;; æ³¨æ„ä¸‹æ ‡ä¸º 0 æ—¶çš„åˆ¤æ–­å¾—å†™åœ¨å¤–é¢ï¼Œç›®çš„æ˜¯ä¸ºäº†åœ¨æ»‘åŠ¨çª—å£çš„å¾ªçŽ¯ä¸­å…ˆæ»‘åŠ¨çª—å£ï¼Œå†è¿›è¡Œåˆ¤æ–­ï¼Œè¿™æ ·å°±å¯ä»¥å–åˆ°ä¸‹æ ‡ä¸º slen - plen çš„ä½ç½®äº†ï¼Œä¸”ä¸è‡³äºŽè¶Šç•Œã€‚ç¿»äº†ä¸‹è¯„è®ºåŒºï¼Œå¥½åƒè¿˜æœ‰ä¸€ç§æ»‘åŠ¨çª—å£çš„è§£æ³•ï¼š12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; findAnagrams(string s, string p) &#123; int slen = s.length(), plen = p.length(); if(slen &lt; plen) return &#123;&#125;; vector&lt;int&gt; ret, cnt(26); for(int i = 0; i &lt; plen; i++) &#123; cnt[p[i] - 'a']++; &#125; int left = 0, right = 0; while(right &lt; slen) &#123; cnt[s[right] - 'a']--; while(cnt[s[right] - 'a'] &lt; 0) &#123; cnt[s[left] - 'a']++; left++; &#125; if(right - left + 1 == plen) ret.push_back(left); right++; &#125; return ret; &#125;&#125;; æ„Ÿè§‰è¿™ç§è§£æ³•ä¸å¤ªå¥½æƒ³ï¼Œæœ€å¥½æƒ³çš„è§£æ³•è¿˜æ˜¯ä¸€å¼€å§‹çš„æ»‘åŠ¨çª—å£è§£æ³•ã€‚æ»‘åŠ¨çª—å£çš„è§£æ³•ï¼Œåº”è¯¥æ˜¯ä»ŽåŒæŒ‡é’ˆè¡ç”Ÿå‡ºæ¥çš„è§£æ³•ã€‚éš¾ç‚¹åœ¨äºŽï¼Œå¦‚ä½•ç§»åŠ¨çª—å£çš„å·¦ç«¯ç‚¹ leftï¼Œå¹¶åŒæ—¶å°†ç¬¦åˆæ¡ä»¶çš„è§£æ‰¾å‡ºæ¥ã€‚å›žåˆ°ä¸Šé¢çš„è§£æ³•æ¥ï¼Œå·§å¦™ä¹‹å¤„åœ¨äºŽåœ¨ç§»åŠ¨ left çš„åŒæ—¶ï¼Œè®©ç»Ÿè®¡ï¼ˆä¹Ÿå¯ä»¥å« hashï¼‰æ•°ç»„ cnt è¿˜åŽŸäº†ã€‚ 713. Subarray Product Less Than KAnalysisæ‰¾å‡ºä¹˜ç§¯å°äºŽ k ä¸”å…ƒç´ è¿žç»­çš„å­æ•°ç»„ï¼Œè¿™ä¸ªé¢˜ä¸€çœ‹ä¹Ÿæ˜¯æ»‘åŠ¨çª—å£çš„é¢˜ï¼Œä¹Ÿæ˜¯ 5 æœˆ 5 æ—¥çš„æ¯æ—¥ä¸€é¢˜ã€‚ Codeæš´åŠ›è§£æ³•æ­»åœ¨ 93 ä¸ªç”¨ä¾‹äº†ðŸ˜‚ã€‚12345678910111213141516class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(), cnt = 0; for(int i = 0; i &lt; size; i++) &#123; int product = 1; for(int j = i; j &lt; size; j++) &#123; product *= nums[j]; if(product &lt; k) cnt++; else break; &#125; &#125; return cnt; &#125;&#125;; ç›´æŽ¥æ¢æ»‘åŠ¨çª—å£ï¼š123456789101112131415161718class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(), cnt = 0; int left = 0, right = 0, product = 1; while(right &lt; size) &#123; product *= nums[right]; while(left &lt;= right &amp;&amp; product &gt;= k) &#123; product /= nums[left]; left++; &#125; cnt += right - left + 1; right++; &#125; return cnt; &#125;&#125;; è¿™é‡Œçš„éš¾ç‚¹åœ¨äºŽç†è§£å­æ•°ç»„ä¸ªæ•° cnt çš„è®¡ç®—ï¼Œè¿™ä¸ªå€¼æ˜¯éšç€æ»‘åŠ¨çª—å£çš„æ”¹å˜è€Œæ”¹å˜çš„ï¼Œæ¯ä¸€æ¬¡å¾ªçŽ¯ï¼ŒåŠ å…¥æˆ–è€…å‡å°‘å…ƒç´ ï¼Œè¿™ä¸ªå€¼éƒ½éœ€è¦åŠ ä¸Šå½“å‰çª—å£å†…å…ƒç´ èƒ½æž„æˆçš„å­æ•°ç»„ä¸ªæ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå½“å‰çª—å£ $[left, right]$ èƒ½æž„æˆçš„ç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ä¸ªæ•°å°±æ˜¯ $right - left + 1$ ä¸ªï¼ŒæŠŠæ‰€æœ‰çª—å£çš„æƒ…å†µå…¨åŠ èµ·æ¥å°±æ˜¯è¦æ±‚çš„ç»“æžœäº†ï¼ˆè¿™ä¹Ÿæ˜¯å¤„ç†è¿™ç±»è¿žç»­é—®é¢˜çš„å…³é”®ï¼‰ã€‚å®˜æ–¹é¢˜è§£è¿˜æä¾›äº†ä¸€ç§æœ‰è¶£çš„å¯ä»¥ç”¨äºŒåˆ†æ¥è§£å†³çš„æ–¹æ³•ï¼š123456789101112131415161718class Solution &#123;public: int numSubarrayProductLessThanK(vector&lt;int&gt;&amp; nums, int k) &#123; if(k == 0) return 0; int size = nums.size(); vector&lt;double&gt; logprefix(size + 1); for(int i = 0; i &lt; size; i++) &#123; logprefix[i + 1] = logprefix[i] + log(nums[i]); &#125; double logk = log(k); int cnt = 0; for(int r = 0; r &lt; size; r++) &#123; int l = upper_bound(logprefix.begin(), logprefix.begin() + r + 1, logprefix[r + 1] - logk + 1e-10) - logprefix.begin(); cnt += r + 1 - l; &#125; return cnt; &#125;&#125;; è¿™ç§æ–¹æ³•éœ€è¦ç”¨åˆ°å‰ç¼€å’Œã€äºŒåˆ†æŸ¥æ‰¾å’Œæ•°å­¦çŸ¥è¯†ï¼Œå¾ˆçµæ´»ï¼Œä¸æ˜¯é‚£ä¹ˆå¥½æƒ³ã€‚ Summaryæ»‘åŠ¨çª—å£æŽŒæ¡çš„è¿˜ä¸ç†Ÿç»ƒï¼Œè¿˜å¾—å†æ¥ç‚¹é¢˜ç›®æ‰è¡Œã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day11]]></title>
    <url>%2F2022%2F05%2F10%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day11%2F</url>
    <content type="text"><![CDATA[ç»§ç»­ï¼Œç»§ç»­ã€‚ 1376. Time Needed to Inform All EmployeesAnalysisé¢˜ç›®çœŸé•¿ï¼Œä¸è¿‡æ„æ€è¿˜ç®—ç®€å•ï¼Œå®žè´¨ä¸Šå°±æ˜¯åœ¨æ±‚æ ‘çš„æœ€é•¿è·¯å¾„ï¼Œè€Œé€šçŸ¥æ—¶é—´å°±æ˜¯ç»“ç‚¹ä¸Žç»“ç‚¹ä¹‹é—´çš„è¾¹æƒï¼Œè¿™ä¸Žå›¾å¾ˆç±»ä¼¼ã€‚ Codebfsä»Ž bfs çš„è§’åº¦æ¥æ€è€ƒå¯èƒ½ä¼šå®¹æ˜“ä¸€äº›ã€‚12345678910111213141516171819202122232425class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int i = 0; i &lt; n; i++) &#123; if(manager[i] == node) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; &#125; &#125; &#125; int maxtime = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; if(maxtime &lt; totaltime[i]) maxtime = totaltime[i]; &#125; return maxtime; &#125;&#125;; å¯æƒœï¼Œè¿™æ®µä»£ç æäº¤ä¸ŠåŽ»è¶…æ—¶äº†ï¼ŒåŽŸå› æ˜¯æ‰¾å­ç»“ç‚¹çš„æ—¶å€™æ˜¯åˆé‡å¤éåŽ†äº†ä¸€æ¬¡æ•°ç»„ã€‚æ—¢ç„¶è¿™æ ·ï¼Œé‚£å°±æŒ‰ç…§æ ¹ç»“ç‚¹æ¥ç»Ÿè®¡ä¸€ä¸‹å­ç»“ç‚¹çš„ä¸‹æ ‡ï¼š123456789101112131415161718192021222324252627class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); unordered_map&lt;int, vector&lt;int&gt;&gt; indices; for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) indices[manager[i]].push_back(i); &#125; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int &amp;i: indices[node]) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; &#125; &#125; int maxtime = INT_MIN; for(int i = 0; i &lt; n; i++) &#123; if(maxtime &lt; totaltime[i]) maxtime = totaltime[i]; &#125; return maxtime; &#125;&#125;; è¿™ç§æ€è·¯è™½ç„¶å¯ä»¥é€šè¿‡ï¼Œä½†æ˜¯æ—¶é—´ã€ç©ºé—´æ¶ˆè€—éƒ½æ¯”è¾ƒå¤§ã€‚ä»”ç»†ä¸€çœ‹ï¼Œè¿™ç§æ€è·¯å®žé™…ä¸Šæ˜¯åˆ©ç”¨é‚»æŽ¥è¡¨éåŽ†å›¾ï¼Œå¹¶æ±‚å‡ºæœ€é•¿è·¯å¾„ï¼Œé‚£å¹²è„†ç›´æŽ¥æŒ‰ç…§å›¾çš„æ–¹å¼æ¥å†™ï¼š12345678910111213141516171819202122232425class Solution &#123;public: int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;int&gt; totaltime(n); vector&lt;vector&lt;int&gt;&gt; adj(n); for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) adj[manager[i]].push_back(i); &#125; queue&lt;int&gt; q; q.push(root); int maxtime = INT_MIN; while(!q.empty()) &#123; int node = q.front(); q.pop(); int tmptime = informTime[node]; for(int &amp;i: adj[node]) &#123; q.push(i); totaltime[i] = tmptime + totaltime[node]; if(totaltime[i] &gt; maxtime) maxtime = totaltime[i]; &#125; &#125; return maxtime; &#125;&#125;; æŠŠ unordered_map æ¢æˆ vector æ—¶é—´ã€ç©ºé—´æ¶ˆè€—éƒ½å‡å°‘å¾ˆå¤šðŸ˜‚ã€‚å¦å¤–ï¼Œå› ä¸ºä¸å­˜åœ¨çŽ¯ï¼ˆé¢˜ç›®ç»™çš„éƒ½æ˜¯æ ‘ï¼‰ï¼Œæ‰€ä»¥ visit æ•°ç»„å°±å¯ä»¥çœåŽ»äº†ã€‚ dfså†å›žå¤´æƒ³æƒ³ dfs æ€Žä¹ˆå†™ï¼ŒæŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œå½“ä½œå›¾æ¥å†™ dfsï¼š1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; totaltime = vector&lt;int&gt;(1e5); int maxtime = INT_MIN; void dfs(int u, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; informTime) &#123; for(int i = 0; i &lt; adj[u].size(); i++) &#123; int v = adj[u][i]; totaltime[v] = informTime[u] + totaltime[u]; if(maxtime &lt; totaltime[v]) maxtime = totaltime[v]; dfs(v, adj, informTime); &#125; &#125; int numOfMinutes(int n, int headID, vector&lt;int&gt;&amp; manager, vector&lt;int&gt;&amp; informTime) &#123; int root = headID; if(n == 1) return 0; vector&lt;vector&lt;int&gt;&gt; adj(n); for(int i = 0; i &lt; n; i++) &#123; if(manager[i] != -1) adj[manager[i]].push_back(i); &#125; dfs(headID, adj, informTime); return maxtime; &#125;&#125;; åŒæ ·ï¼Œå› ä¸ºæ²¡æœ‰çŽ¯ï¼Œæ‰€ä»¥ä¹Ÿä¸éœ€è¦ visit æ•°ç»„ã€‚ 49. Group AnagramsAnalysisè¿™ä¸ªé¢˜ç¬¬ä¸€çœ¼çœ‹è¿‡åŽ»ï¼Œæ²¡è¯»æ‡‚ï¼Œä»”ç»†åˆè¯»äº†ä¸€ä¸‹ï¼ŒåŽŸæ¥æ˜¯ä¸ªåˆ†ç±»çš„é¢˜ç›®ï¼Œåªéœ€è¦å°†å­—æ¯å¼‚ä½è¯ç»„åˆåœ¨ä¸€èµ·å°±å¯ä»¥äº†ã€‚è¯è¯´ï¼Œæ±‚å­—æ¯å¼‚ä½è¯å¥½åƒå°±æ˜¯æ±‚å­—æ¯çš„å…¨æŽ’åˆ—ï¼Œä¸å¾—ä¸åˆè”æƒ³åˆ°æ˜¨å¤©åšçš„é‚£ä¸ªé¢˜ðŸ˜‚ã€‚ä¸è¿‡è¿™ä¸ªé¢˜ï¼Œæ„Ÿè§‰ç”¨ hash ä¼šå¥½ä¸€ç‚¹ã€‚ Codeä¸€å¼€å§‹æ€»æ•°æƒ³è®© hash ç›´æŽ¥æ˜ å°„æˆä¸åŒç±»åž‹å­—æ¯å¼‚ä½è¯çš„ä¸‹æ ‡ï¼Œå€’è…¾åŠå¤© map&lt;vector&lt;int&gt;, int&gt;ï¼Œæ²¡å€’è…¾å‡ºæ¥ï¼Œåªèƒ½ç”¨æš´åŠ›ä¸€ç‚¹çš„è§£æ³•äº†ã€‚123456789101112131415161718192021222324252627282930313233class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); vector&lt;bool&gt; ht(size); vector&lt;vector&lt;string&gt;&gt; ret; int amount = 0; while(amount &lt; size) &#123; vector&lt;int&gt; cnt1(26); int index = 0; while(index &lt; size &amp;&amp; ht[index] == true) index++; int len = strs[index].length(); for(int i = 0; i &lt; len; i++) &#123; cnt1[strs[index][i] - 'a']++; &#125; vector&lt;string&gt; tmp; for(int i = 0; i &lt; size; i++) &#123; len = strs[i].length(); vector&lt;int&gt; cnt2(26); for(int j = 0; j &lt; len; j++) &#123; cnt2[strs[i][j] - 'a']++; &#125; if(cnt2 == cnt1) &#123; tmp.push_back(strs[i]); ht[i] = true; &#125; &#125; amount += tmp.size(); ret.push_back(tmp); &#125; return ret; &#125;&#125;; è¿™æ®µä»£ç å§‘ä¸”ç®—æ˜¯èƒ½å‡ºç»“æžœäº†ï¼Œå¯æƒœæäº¤ä¸ŠåŽ»è¶…æ—¶äº†ã€‚çªç„¶å‘çŽ°ï¼Œè‡ªå·±æœ‰ç‚¹è¢«é¢˜ç›®ç»•æ™•äº†ã€‚è€Œä¸”ï¼Œè¿™ä¸ªé¢˜çš„éš¾ç‚¹å¥½åƒæ˜¯åœ¨å¦‚ä½•åˆç†ä½¿ç”¨ STL æ¥è¡¨ç¤º hash ä¸Šã€‚çœåŽ»äº†ä¸€äº›é‡å¤çš„åˆ¤æ–­ï¼š1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); vector&lt;bool&gt; ht(size); vector&lt;vector&lt;string&gt;&gt; ret; int amount = 0; while(amount &lt; size) &#123; vector&lt;int&gt; cnt1(26); int index = 0; vector&lt;string&gt; tmp; while(index &lt; size &amp;&amp; ht[index] == true) index++; int len = strs[index].length(); for(int i = 0; i &lt; len; i++) &#123; cnt1[strs[index][i] - 'a']++; &#125; ht[index] = true; tmp.push_back(strs[index++]); while(index &lt; size) &#123; vector&lt;int&gt; cnt2(26); int tmplen = strs[index].length(); if(ht[index] == false &amp;&amp; len == tmplen) &#123; for(int i = 0; i &lt; tmplen; i++) &#123; cnt2[strs[index][i] - 'a']++; &#125; if(cnt2 == cnt1) &#123; tmp.push_back(strs[index]); ht[index] = true; &#125; &#125; index++; &#125; amount += tmp.size(); ret.push_back(tmp); &#125; return ret; &#125;&#125;; è¿˜æ˜¯è¶…æ—¶çš„ï¼Œæ˜¯æˆ‘æŠŠè¿™ä¸ªé—®é¢˜æƒ³çš„å¤ªå¤æ‚äº†å—ï¼Ÿåˆ†æžä¸€ä¸‹ä¸Šé¢çš„ä»£ç ï¼Œåˆ¤æ–­ä¸¤ä¸ªè¯æ˜¯å­—æ¯å¼‚ä½è¯æ˜¯åŸºäºŽä¸¤ä¸ªè¯çš„å­—ç¬¦ä¸ªæ•°ç›¸åŒï¼Œè¿™å°±éœ€è¦åˆ†åˆ«å¯¹ä¸¤ä¸ªè¯ä¸­çš„å­—ç¬¦è¿›è¡Œç»Ÿè®¡å¹¶åˆ¤æ–­æ˜¯å¦ç›¸åŒã€‚åŒæ—¶ï¼Œè®¾ç½®äº†ä¸€ä¸ª hash è¡¨æ¥æ ‡è®°è¿™ä¸ªè¯æ˜¯å¦è¢«ç»Ÿè®¡è¿‡ï¼Œç»Ÿè®¡è¿‡äº†å°±è¯´æ˜Žæ˜¯å…¶ä»–è¯çš„å­—æ¯å¼‚ä½è¯ï¼Œå°±ä¸å†ç»Ÿè®¡äº†ã€‚strs çš„é•¿åº¦èŒƒå›´æ˜¯ $[1, 10^4]$ï¼Œè¯çš„é•¿åº¦èŒƒå›´æ˜¯ $[0, 100]$ï¼Œæžç«¯æƒ…å†µä¸‹ï¼Œå°±æ˜¯ $10^6$ï¼ŒæŒ‰ç†è¯´è¿™ç§æ€è·¯ï¼Œè™½ç„¶å¾ˆæ…¢ï¼Œåº”è¯¥æ˜¯å¯ä»¥è¿‡çš„ã€‚ä¸è¿‡ï¼Œè¿™ç§æ€è·¯ä¸‹ï¼Œå¯èƒ½ä¼šäº§ç”Ÿå¾ˆå¤šæ— æ•ˆç»Ÿè®¡ã€‚æ—¢ç„¶äº‹å®žå·²ç»è¯æ˜Žï¼Œè¿™ç§æ–¹æ³•ä¸è¡Œäº†ï¼Œå°±å¾—æ¢ä¸ªæ€è·¯äº†ã€‚çž…äº†ä¸¤çœ¼å®˜æ–¹é¢˜è§£ï¼Œçªç„¶å‘çŽ°å®˜æ–¹é¢˜è§£ä¸æ˜¯ç”¨å­—ç¬¦ä¸²çš„å­—æ¯ç»Ÿè®¡ç»“æžœå½“ä½œ map çš„æ˜ å°„ï¼Œè€Œæ˜¯å°†å­—ç¬¦ä¸²å…ˆæŽ’åºï¼Œå¦‚æžœå­—ç¬¦ä¸²çš„æŽ’åºç»“æžœä¸€è‡´å°±è¯´æ˜Žæ˜¯å­—æ¯å¼‚ä½è¯ï¼ŒçœŸé¸¡è´¼å•ŠðŸ˜‚~ç­‰ç­‰ï¼Œå¥½åƒå‘çŽ°äº†ä»€ä¹ˆä¸œè¥¿ï¼Œå›žåˆ°ä¸€å¼€å§‹çš„æ€è·¯ï¼Œé‡æ–°å†™äº†ä¸€ä¸‹ï¼š123456789101112131415161718192021222324252627class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); map&lt;vector&lt;int&gt;, int&gt; indices; vector&lt;vector&lt;string&gt;&gt; ret(size); int index = 0; for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; cnt(26); int len = strs[i].length(); for(int j = 0; j &lt; len; j++) &#123; cnt[strs[i][j] - 'a']++; &#125; if(indices.count(cnt)) &#123; ret[indices[cnt]].push_back(strs[i]); &#125; else &#123; ret[index].push_back(strs[i]); indices[cnt] = index++; &#125; &#125; vector&lt;vector&lt;string&gt;&gt; ans; for(auto &amp;v: ret) &#123; if(v.size() != 0) ans.push_back(move(v)); &#125; return ans; &#125;&#125;; å¹²ï¼Œä¸€å¼€å§‹çš„æ€è·¯æ˜¯å¯ä»¥é€šè¿‡çš„ï¼Œå°½ç®¡æ—¶é—´å’Œç©ºé—´æ¶ˆè€—ä¸å¿ç›´è§†ã€‚çªç„¶å‘çŽ°å¥½åƒä¸€å¼€å§‹å€’è…¾åŠå¤©æ²¡å‡ºæ¥çš„åŽŸå› æ˜¯è¯­æ³•å†™é”™äº†ï¼Œæ„Ÿè§‰ä»Šå¤©ä¸åœ¨çŠ¶æ€ï¼ˆæˆ‘è¿˜å‚»å‚»çš„ä¸€ä¸ªä¸€ä¸ªåŽ»åˆ¤æ–­ðŸ™ƒï¼‰ã€‚æ—¢ç„¶æ˜Žç¡®äº†è¿™ä¸ªæ€è·¯ï¼Œé‚£ä¸å¦¨å†™çš„æ›´ç®€å•ä¸€ç‚¹ï¼š1234567891011121314151617181920class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); map&lt;vector&lt;int&gt;, vector&lt;string&gt;&gt; ht; vector&lt;vector&lt;string&gt;&gt; ret; for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; cnt(26); int len = strs[i].length(); for(int j = 0; j &lt; len; j++) &#123; cnt[strs[i][j] - 'a']++; &#125; ht[cnt].push_back(strs[i]); &#125; for(auto &amp;[v1, v2]: ht) &#123; ret.push_back(v2); &#125; return ret; &#125;&#125;; ...è¿˜çœŸèƒ½è¿™æ ·å†™å•Šï¼ˆC++ çš„è¯­æ³•è·Ÿ STL çš„çŸ¥è¯†è¿˜å¾—è¡¥ðŸ™ƒï¼‰ã€‚å¦å¤–ï¼Œunordered_map å¥½åƒä¸èƒ½æŠŠ vector å½“ä½œ keyã€‚çŽ°åœ¨å›žåˆ°å®˜æ–¹é¢˜è§£çš„æ€è·¯ä¸Šæ¥ï¼š1234567891011121314151617class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; int size = strs.size(); unordered_map&lt;string, vector&lt;string&gt;&gt; mp; for(string &amp;s: str) &#123; string key = s; sort(key.begin(), key.end()); mp[key].push_back(s); &#125; vector&lt;vector&lt;string&gt;&gt; ret; for(auto &amp;[s, v]: mp) &#123; ret.push_back(v); &#125; return ret; &#125;&#125;; ç›¸æ¯”è‡ªå·±çš„æ€è·¯ï¼Œæ—¶é—´ã€ç©ºé—´æ¶ˆè€—éƒ½å°‘äº†ä¸€åŠã€‚å®˜æ–¹é¢˜è§£çš„ç¬¬äºŒç§æ€è·¯ä¸Žè‡ªå·±çš„æ€è·¯æ˜¯ä¸€æ ·çš„ï¼Œåªæ˜¯ç”¨äº†ç¨å¾®å¤æ‚ä¸€ç‚¹çš„è¯­æ³•ï¼š123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) &#123; auto arrayHash = [fn = hash&lt;int&gt;&#123;&#125;] (const array&lt;int, 26&gt;&amp; arr) -&gt; size_t &#123; return accumulate(arr.begin(), arr.end(), 0u, [&amp;](size_t acc, int num) &#123; return (acc &lt;&lt; 1) ^ fn(num); &#125;); &#125;; unordered_map&lt;array&lt;int, 26&gt;, vector&lt;string&gt;, decltype(arrayHash)&gt; mp(0, arrayHash); for(string &amp;str: strs) &#123; array&lt;int, 26&gt; counts&#123;&#125;; int len = str.length(); for(int i = 0; i &lt; len; i++) &#123; counts[str[i] - 'a']++; &#125; mp[counts].push_back(str); &#125; vector&lt;vector&lt;string&gt;&gt; ret; for(auto it = mp.begin(); it != mp.end(); it++) &#123; ret.push_back(it-&gt;second); &#125; return ret; &#125;&#125;; æœ‰å¥½å¤šçœ‹ä¸æ‡‚çš„è¯­æ³•...æš‚æ—¶æ”¾ç€å§ã€‚ Summaryæ„Ÿè§‰ä»Šå¤©è„‘å­æœ‰ç‚¹è¿·è¿·ç³Šç³Šçš„ï¼Œä¸å¤ªæ¸…é†’ã€‚è¯è¯´ï¼Œè€æ˜¯åšé¢˜ï¼Œéƒ½æ²¡æœ‰å…·ä½“çš„çœ‹çœ‹ä¹¦ï¼Œä¹Ÿæ²¡æœ‰å¥½å¥½çš„æ€»ç»“ä¸€ä¸‹]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 291 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F09%2FLeetcode-%E7%AC%AC-291-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[è¿™æ˜¯ä¸Šä¸Šå‘¨çš„å‘¨èµ›äº†...è¿™åœºå‘¨èµ›ä¾ç„¶æ˜¯åŒé¢˜é€‰æ‰‹... 2259. Remove Digit From Number to Maximize ResultAnalysisç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œåœ¨ä¸æ”¹å˜å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œè¿”å›žåˆ é™¤ä¸€ä¸ªç»™å®šå­—ç¬¦åŽï¼Œèƒ½å¾—åˆ°çš„åè¿›åˆ¶ä¸‹çš„æœ€å¤§ç»“æžœã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š1234567891011121314151617181920212223class Solution &#123;public: string removeDigit(string number, char digit) &#123; vector&lt;int&gt; indices; int len = number.length(); for(int i = 0; i &lt; len; i++) &#123; if(number[i] == digit) indices.push_back(i); &#125; if(indices.size() == 1) &#123; number.erase(number.begin() + indices[0]); return number; &#125; else &#123; string max = number; max.erase(max.begin() + indices[0]); for(int i = 1; i &lt; indices.size(); i++) &#123; string t = number; t.erase(t.begin() + indices[i]); if(max &lt; t) max = t; &#125; return max; &#125; &#125;&#125;; çœ‹äº†ä¸‹åˆ«äººçš„æ€è·¯ï¼Œå…¶å®žè¿™ä¸ªé¢˜å®Œå…¨å¯ä»¥ä¸é‡æ–°æž„é€ å­ä¸²ã€‚éœ€è¦è€ƒè™‘çš„é—®é¢˜æ˜¯å¯¹äºŽæœ‰å¤šä¸ª digit çš„å­—ç¬¦ä¸²è€Œè¨€ï¼Œåˆ é™¤å“ªä¸€ä¸ªä½ç½®çš„ digit åŽå¾—åˆ°çš„æ•°æ˜¯æœ€å¤§çš„ã€‚åˆ†æžä¸€ä¸‹ï¼Œè¢«åˆ é™¤çš„ digit å¯èƒ½é å‰ï¼Œæ¯”å¦‚ 1231ï¼Œåˆ é™¤ 1ï¼›ä¹Ÿå¯èƒ½é åŽï¼Œæ¯”å¦‚ 1323ï¼Œåˆ é™¤ 3ã€‚è¿™ä¸¤ç§æƒ…å†µå…¶å®žæœ‰ä¸ªå¾ˆå®¹æ˜“å¿½ç•¥çš„ç»†èŠ‚åœ¨å†…ï¼Œå³åˆ é™¤çš„ digit çš„åŽé¢çš„å­—ç¬¦ä¸€å®šæ˜¯å¤§äºŽ digit çš„ï¼Œæˆ–è€…åˆ é™¤çš„æ˜¯æœ«å°¾çš„ digitã€‚ä¸ºä»€ä¹ˆä¼šå‡ºçŽ°è¿™ç§æƒ…å†µå‘¢ï¼Ÿå› ä¸ºå‰é¢çš„æ•°å­—æ˜¯åœ¨é«˜ä½çš„ï¼Œå‡å°‘äº†ä¸€ä½åŽï¼Œæ¯ä¸€ä½ä¸Šçš„æ•°å­—å°±å˜äº†ï¼Œå®žé™…æ”¹å˜çš„å°±æ˜¯ç»“æžœæ•°å­—çš„å¤§å°ã€‚æ¯”å¦‚ 1231ï¼Œå¦‚æžœåˆ é™¤åŽé¢çš„ 1ï¼Œé‚£ä¹ˆ 2 å°±å˜æˆäº†ç™¾åä½ï¼Œ3 å°±å˜æˆäº†ä¸ªä½ï¼Œä½†æ˜¯å¦‚æžœåˆ é™¤å‰é¢çš„ 1 ï¼Œ2 å°±å˜æˆäº†ç™¾ä½ï¼Œ3 å°±å˜æˆäº†åä½ã€‚ç»“æžœå°±æ˜¯ï¼Œè¿™ä¸ªæ•°å­—æ˜¯åˆ é™¤åŽçš„æ•°å­—ä¸­æœ€å¤§çš„ã€‚1234567891011121314class Solution &#123;public: string removeDigit(string number, char digit) &#123; int len = number.length(), pos = -1; for(int i = 0; i &lt; len; i++) &#123; if(number[i] == digit) &#123; pos = i; if(i + 1 &lt; len &amp;&amp; number[i] &lt; number[i + 1]) break; &#125; &#125; number.erase(number.begin() + pos); return number; &#125;&#125;; å®žè´¨ä¸Šæ˜¯ä¸€ç§è´ªå¿ƒçš„è¿‡ç¨‹ã€‚ 2260. Minimum Consecutive Cards to Pick UpAnalysisæ‰¾å‡ºå·¦å³è¾¹ç•Œç›¸ç­‰çš„æœ€çŸ­è¿žç»­å­åºåˆ—ã€‚ Codemethod 1è¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š12345678910111213141516171819202122class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); map&lt;int, vector&lt;int&gt;&gt; ht; for(int i = 0; i &lt; size; i++) &#123; ht[cards[i]].push_back(i); &#125; int minimum = INT_MAX; for(auto &amp;[x, v]: ht) &#123; if(v.size() &gt; 1) &#123; int tmp = v[1] - v[0] + 1, s = v.size(); for(int i = 1; i &lt; s - 1; i++) &#123; if(tmp &gt; v[i + 1] - v[i]) tmp = v[i + 1] - v[i] + 1; &#125; if(minimum &gt; tmp) minimum = tmp; &#125; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; æœ¬è´¨ä¸Šæ˜¯å“ˆå¸Œ + æš´åŠ›æœç´¢çš„æ€è·¯ï¼Œå³æ‰¾å‡ºæ¯ä¸€å¯¹è¾¹ç•Œç›¸åŒçš„å­åˆ—ï¼Œæ¯”è¾ƒå®ƒä»¬çš„å¤§å°ï¼Œè¿”å›žæœ€å°å€¼ã€‚æ¢æˆ unordered_map åº”è¯¥ä¼šå¥½ä¸€äº›ï¼š12345678910111213141516171819202122class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, vector&lt;int&gt;&gt; ht; for(int i = 0; i &lt; size; i++) &#123; ht[cards[i]].push_back(i); &#125; int minimum = INT_MAX; for(auto &amp;[x, v]: ht) &#123; if(v.size() &gt; 1) &#123; int tmp = v[1] - v[0] + 1, s = v.size(); for(int i = 1; i &lt; s - 1; i++) &#123; if(tmp &gt; v[i + 1] - v[i]) tmp = v[i + 1] - v[i] + 1; &#125; if(minimum &gt; tmp) minimum = tmp; &#125; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; æžœç„¶ï¼Œæ—¶é—´å‡å°‘äº†å¤§çº¦ä¸€åŠã€‚å¤šç”¨äº†ä¸€ä¸ª hashmapï¼Œæ—¶é—´æ²¡æ€Žä¹ˆå‡å°‘ï¼Œå†…å­˜å€’æ˜¯å‡å°‘äº†ï¼š123456789101112131415161718class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, set&lt;int&gt;&gt; ht1; unordered_map&lt;int, int&gt; ht2; for(int i = 0; i &lt; size; i++) &#123; if(ht2.count(cards[i])) ht1[cards[i]].insert(i - ht2[cards[i]] + 1); ht2[cards[i]] = i; &#125; int minimum = INT_MAX; for(auto &amp;[x, s]: ht1) &#123; if(minimum &gt; *s.begin()) minimum = *s.begin(); &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; ç†è®ºåˆ†æžæ—¶é—´å¤æ‚åº¦åº”è¯¥æ˜¯è¦ä¼˜äºŽä¸Šé¢åªç”¨ä¸€ä¸ª hashmap çš„è§£æ³•ã€‚ä»”ç»†æƒ³æƒ³ï¼Œæœ‰å¿…è¦æŠŠæ¯ä¸€ä¸ªå·¦å³è¾¹ç•Œç›¸ç­‰çš„å­åºåˆ—çš„é•¿åº¦éƒ½ç®—å‡ºæ¥å—ï¼Ÿå…¶å®žæ˜¯æ²¡æœ‰çš„ï¼Œåªéœ€è¦ hashmap ä¿å­˜ä¸Šä¸€æ¬¡çš„ç›¸ç­‰å…ƒç´ çš„ä¸‹æ ‡å³å¯ï¼Œè¦å¾—åˆ°æœ€è¿‘çš„ä¸¤ä¸ªç›¸ç­‰å…ƒç´ çš„é•¿åº¦ï¼Œç›´æŽ¥ä½œå·®å°±å¯ä»¥äº†ï¼Œç„¶åŽå†ä»Žè¿™äº›å€¼ä¸­æ‰¾å‡ºæœ€å°å€¼å³å¯ã€‚1234567891011121314class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_map&lt;int, int&gt; ht; int minimum = INT_MAX; for(int i = 0; i &lt; size; i++) &#123; if(ht.count(cards[i])) minimum = min(minimum, i - ht[cards[i]] + 1); ht[cards[i]] = i; &#125; if(minimum == INT_MAX) return -1; else return minimum; &#125;&#125;; ...è¿˜æ˜¯è‡ªå·±å¤ªæ†¨äº†ðŸ˜“ã€‚ method 2çœ‹äº†ä¸‹è¿™é“é¢˜çš„æ ‡ç­¾ï¼Œå¥½åƒä¹Ÿæ˜¯ä¸ªæ»‘åŠ¨çª—å£çš„é¢˜ç›®ã€‚123456789101112131415161718192021class Solution &#123;public: int minimumCardPickup(vector&lt;int&gt;&amp; cards) &#123; int size = cards.size(); unordered_set&lt;int&gt; ht; int left, right, ans; left = right = 0; ans = INT_MAX; while(right &lt; size) &#123; while(ht.count(cards[right])) &#123; ans = min(ans, right - left + 1); ht.erase(cards[left]); left++; &#125; ht.insert(cards[right]); right++; &#125; if(ans == INT_MAX) return -1; else return ans; &#125;&#125;; æ»‘åŠ¨çª—å£ä¹Ÿéœ€è¦ç”¨ä¸€ä¸ª hashmap æ¥åˆ¤æ–­ï¼Œå½“å‰æ•°å­—æ˜¯ä¸æ˜¯ä¹‹å‰å‡ºçŽ°è¿‡ï¼ˆå‡ºçŽ°è¿‡æ‰å¯ä»¥æž„æˆç¬¦åˆæ¡ä»¶çš„å­åºåˆ—ï¼‰ã€‚PSï¼šè¿™ä¸ªé¢˜çš„ $cards[i]$ çš„èŒƒå›´æ˜¯ $[0, 10^6]$ï¼Œæ‰€ä»¥ç›´æŽ¥å¼€ä¸ªå¾ˆå¤§çš„æ•°ç»„å½“ hashmap æ¥ç”¨ï¼Œè¿è¡Œæ—¶é—´ä¼šå¿«å¾ˆå¤šã€‚ 2022å¹´5æœˆ14æ—¥ï¼Œæ¶ˆåœäº†å‡ å¤©ï¼Œæˆ‘åˆå›žæ¥äº†ã€‚ 2261. K Divisible Elements SubarraysAnalysisè™½ç„¶é¢˜ç›®å¾ˆçŸ­ï¼Œä½†æ˜¯æ„Ÿè§‰æ˜¯ä¸ªæ¯”è¾ƒéº»çƒ¦çš„é¢˜ç›®ã€‚é¦–å…ˆéœ€è¦æ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„å­æ•°ç»„ï¼Œä½†æ˜¯ä¸ºäº†ç¡®ä¿å”¯ä¸€æ€§ï¼Œè¿˜éœ€è¦æ£€æŸ¥æ˜¯å¦å­æ•°ç»„æ˜¯å¦å‡ºçŽ°è¿‡ï¼Œæ‰€ä»¥è¿™ä¸ªé¢˜ä¸èƒ½ç®€å•çš„ç”¨æ»‘åŠ¨çª—å£çš„æ€è·¯æ¥å¤„ç†ã€‚ Codeæš´åŠ›è§£æ³•è¿˜æ˜¯å¾ˆå®¹æ˜“æƒ³åˆ°çš„ï¼ˆå½“æ—¶æ¯”èµ›æ€Žä¹ˆæ²¡æƒ³åˆ°å•ŠðŸ˜‚ï¼‰ã€‚1234567891011121314151617181920212223class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; map&lt;vector&lt;int&gt;, bool&gt; ht; int ret = 0, size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; tmp; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; tmp.push_back(nums[j]); if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; else &#123; if(!ht.count(tmp)) &#123; ht[tmp] = true; ret++; &#125; &#125; &#125; &#125; return ret; &#125;&#125;; æœ¬ä»¥ä¸º nums çš„é•¿åº¦èŒƒå›´åªæœ‰ $[1, 200]$ï¼Œæš´åŠ›è§£æ³•åº”è¯¥ä¹Ÿå¯ä»¥é€šè¿‡ï¼Œç»“æžœè¿˜æ˜¯æ— æ³•é€šè¿‡ã€‚ä¸ºäº†ç¡®ä¿è§£çš„å”¯ä¸€æ€§ï¼Œhash è¡¨æ²¡åŠžæ³•æ‹¿æŽ‰ï¼Œæƒ³è¦æé«˜æ—¶é—´æ•ˆçŽ‡ï¼Œå°±å¾—åœ¨æ‰¾è§£çš„æ–¹æ³•ä¸Šä¸‹åŠŸå¤«ã€‚çœ‹äº†ä¸‹å®˜æ–¹é¢˜è§£ï¼Œæ²¡æœ‰ç”¨å­æ•°ç»„æ¥ä½œä¸ºå“ˆå¸Œçš„ keyï¼Œè€Œæ˜¯å°†å­æ•°ç»„åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸²ï¼Œè®©è¿™ä¸ªå­—ç¬¦ä¸²ä½œä¸ºå“ˆå¸Œå…ƒç´ ï¼Œå…¶ä»–çš„æ€è·¯åŸºæœ¬ä¸Šæ˜¯ä¸€è‡´çš„ã€‚12345678910111213141516171819class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; unordered_set&lt;string&gt; arrs; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; string s; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; s.append(to_string(nums[j])); s.push_back('#'); arrs.insert(s); &#125; &#125; return arrs.size(); &#125;&#125;; è¿™æ®µä»£ç æ˜¯å¯ä»¥é€šè¿‡çš„ã€‚å›žå¤´æƒ³æƒ³ï¼Œåº”è¯¥æ˜¯ç›´æŽ¥å°†å­æ•°ç»„ä½œä¸º map çš„ key å¯¼è‡´æ¶ˆè€—çš„æ—¶é—´å¤ªå¤šäº†ã€‚æ›´è¦å‘½çš„æ˜¯ï¼Œæˆ‘è¿˜ç”¨äº†countå‡½æ•°ï¼Œä¸å¦‚ç›´æŽ¥ht[cnt] = xxx;ï¼Œæœ€åŽç›´æŽ¥è¿”å›žht.size()ã€‚123456789101112131415161718class Solution &#123;public: int countDistinct(vector&lt;int&gt;&amp; nums, int k, int p) &#123; map&lt;vector&lt;int&gt;, bool&gt; ht; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; vector&lt;int&gt; tmp; int cnt = 0; for(int j = i; j &lt; size; j++) &#123; tmp.push_back(nums[j]); if(nums[j] % p == 0) cnt++; if(cnt &gt; k) break; ht[tmp] = true; &#125; &#125; return ht.size(); &#125;&#125;; æ²¡æƒ³åˆ°ï¼Œæ”¹äº†ä¸‹è¿˜çœŸçš„å¯ä»¥é€šè¿‡äº†ðŸ˜‚ï¼Œå°±æ˜¯æ—¶é—´ã€ç©ºé—´æ¶ˆè€—æƒ¨ä¸å¿ç¹ã€‚å°±è¿™ä¸ªé¢˜è€Œè¨€ï¼Œæ²¡åŠžæ³•é€šè¿‡çš„åŽŸå› ï¼Œå¾ˆå¤§ä¸€éƒ¨åˆ†æ˜¯å¯¹ mapã€set è¿™ç±»å®¹å™¨çš„ä¸äº†è§£... 2262. Total Appeal of A StringAnalysisè¿™ä¸ªé¢˜æ˜¯å‰é¢å‡ ä¸ªé¢˜çš„è¿›åŒ–ç‰ˆðŸ˜‚ï¼Œæ„Ÿè§‰ç”¨ç¬¬ 3 ä¸ªé¢˜çš„æ€è·¯ï¼Œå®Œå…¨å¯ä»¥ã€‚ä¸è¿‡æ•°æ®èŒƒå›´æ˜¯ $10^5$ï¼Œ$O(n^2)$ é“å®šå¾—è¶…æ—¶ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„è¶…æ—¶ä»£ç ï¼š123456789101112131415161718192021222324class Solution &#123;public: long long appealSum(string s) &#123; long long ret = s.length(); int len = s.length(); unordered_set&lt;char&gt; ht; for(int i = 0; i &lt; len; i++) &#123; ht.insert(s[i]); &#125; ret += ht.size(); for(int step = 2; step &lt; len; step++) &#123; for(int i = 0; i &lt;= len - step; i++) &#123; unordered_set&lt;char&gt; ht; int start = i, end = i + step; while(start &lt; end) &#123; ht.insert(s[start]); start++; &#125; ret += ht.size(); &#125; &#125; return ret; &#125;&#125;; çŽ°åœ¨çœ‹ï¼Œæ„Ÿè§‰å½“æ—¶æƒ³å¤æ‚äº†ï¼Œæ€è·¯æ˜¯æŒ‰ç…§ä¸åŒé•¿åº¦æ¥æžšä¸¾å­å­—ç¬¦ä¸²ï¼Œç»“æžœæ­»åœ¨ 52 ä¸ªç”¨ä¾‹äº†ã€‚è¿™æ˜¯åˆšåˆšå†™çš„ï¼š12345678910111213141516171819202122232425262728class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; vector&lt;int&gt; cnt(26); int l = str.length(); for(int i = 0; i &lt; l; i++) &#123; cnt[str[i] - 'a']++; &#125; int count = 0; for(int i = 0; i &lt; 26; i++) &#123; if(cnt[i] &gt; 0) count++; &#125; ret += count * times; &#125; return ret; &#125;&#125;; ç”¨äº†ä¸‹å“ˆå¸Œçš„æ€è·¯ï¼Œæ­»åœ¨ 55 ä¸ªç”¨ä¾‹äº†ï¼Œå°½é‡ä¸€ä¸ªå¾ªçŽ¯å°±æŠŠå•ä¸ªå­—ç¬¦ä¸²çš„å¼•åŠ›ç®—å‡ºã€‚12345678910111213141516171819202122232425262728class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; vector&lt;int&gt; cnt(26); int l = str.length(); int count = 0; for(int i = 0; i &lt; l; i++) &#123; if(cnt[str[i] - 'a'] == 0) &#123; count++; &#125; cnt[str[i] - 'a']++; &#125; ret += count * times; &#125; return ret; &#125;&#125;; ç»“æžœæ­»åœ¨ 53 ä¸ªç”¨ä¾‹äº†ï¼Œç­‰ç­‰ï¼Œç”¨ set ä¸æ˜¯æ›´é¦™ðŸ˜‚ï¼Ÿ1234567891011121314151617181920212223class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); unordered_map&lt;string, int&gt; ht; for(int i = 0; i &lt; len; i++) &#123; string tmp; for(int j = i; j &lt; len; j++) &#123; tmp.push_back(s[j]); ht[tmp]++; &#125; &#125; for(auto &amp;[str, times]: ht) &#123; unordered_set&lt;char&gt; se; for(auto &amp;c: str) &#123; se.insert(c); &#125; ret += se.size() * times; &#125; return ret; &#125;&#125;; ç»“æžœæ­»åœ¨ 52 ä¸ªç”¨ä¾‹äº†ðŸ˜‚ï¼Œset æ¯” vector çœäº‹äº†ä¸å°‘ï¼Œå°±æ˜¯æ—¶é—´æ¶ˆè€—è¶Šæ¥è¶Šå¤šäº†ã€‚çœ‹äº†ä¸‹åˆ«äººçš„é¢˜è§£ï¼Œè¿™ä¸ªé¢˜å¥½åƒæ˜¯ dp å’Œ å­—ç¬¦ä¸²çš„ç»“åˆé¢˜ã€‚123456789101112131415class Solution &#123;public: long long appealSum(string s) &#123; long long ret = 0; int len = s.length(); vector&lt;int&gt; last(26, -1); for(int i = 0, sum_g = 0; i &lt; s.length(); i++) &#123; int c = s[i] - 'a'; sum_g += i - last[c]; ret += sum_g; last[c] = i; &#125; return ret; &#125;&#125;; æš‚æ—¶ç†è§£ä¸äº†è¿™ç§æ€è·¯ï¼Œå†åšç‚¹é¢˜äº†ï¼Œå›žå¤´çœ‹çœ‹ã€‚ Summaryè¿™æ¬¡ç«žèµ›ï¼Œå¯æƒœçš„æ˜¯ç¬¬ä¸‰ä¸ªé¢˜æ²¡åšå‡ºæ¥ã€‚ä¸€èˆ¬æ¥è®²ï¼Œæš´åŠ›è§£æ³•åº”è¯¥æ˜¯æƒ³å¾—åˆ°çš„ã€‚æƒ³åˆ°äº†æš´åŠ›è§£æ³•ï¼Œç„¶åŽæ¢ä¸ª STL å®¹å™¨ä¼°è®¡å°±å¯ä»¥é€šè¿‡äº†ðŸ˜‚ã€‚å¯æƒœäº†~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day10]]></title>
    <url>%2F2022%2F05%2F09%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day10%2F</url>
    <content type="text"><![CDATA[ç»§ç»­å†²~ 503. Next Greater Element IIAnalysisè¿™è·Ÿä¹‹å‰åšçš„é‚£ä¸ªæ¸©åº¦é¢˜å¾ˆåƒï¼Œåº”è¯¥éƒ½æ˜¯å•è°ƒæ ˆçš„é¢˜ç›®ã€‚ä¸è¿‡ä¸åŒçš„æ˜¯ï¼Œè¿™ä¸ªé¢˜è¿”å›žçš„å€¼æ˜¯éåŽ†é¡ºåºçš„ç¬¬ä¸€ä¸ªå¤§çš„å€¼ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æžœè¿™ä¸ªå…ƒç´ åŽé¢ä¸å­˜åœ¨æ¯”å®ƒå¤§çš„æ•°ï¼Œé‚£ä¹ˆå°±å¾ªçŽ¯çš„ä»Žå¼€å¤´éåŽ†åˆ°è¿™ä¸ªå…ƒç´ ï¼Œæ‰¾å‡ºæ¯”å®ƒå¤§çš„ç¬¬ä¸€ä¸ªå…ƒç´ ã€‚ Codemethod 1å¾ˆè‡ªç„¶å°±æƒ³åˆ°æš´åŠ›è§£æ³•äº†ï¼š12345678910111213141516class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int left = 0, right = i + 1; while(right &lt; size &amp;&amp; nums[right] &lt;= nums[i]) right++; while(left &lt; i &amp;&amp; nums[left] &lt;= nums[i]) left++; if(right != size) ret[i] = nums[right]; else if(left != i) ret[i] = nums[left]; else ret[i] = -1; &#125; return ret; &#125;&#125;; å—¯ï¼Œè¿™ä¸ªè§£æ³•æ˜¯å¯ä»¥é€šè¿‡çš„ã€‚å®žé™…ä¸Šï¼Œåœ¨å‘å³éåŽ†çš„è¿‡ç¨‹ä¸­å¦‚æžœæ‰¾åˆ°äº†ï¼Œå°±æ²¡æœ‰å¿…è¦å†å‘å·¦æ‰¾äº†ï¼Œæ‰€ä»¥å¯ä»¥ä¼˜åŒ–ä¸€ä¸‹ï¼š12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int pre = 0, rear = i + 1; bool flag = false; while(rear &lt; size) &#123; if(nums[rear] &gt; nums[i]) &#123; ret[i] = nums[rear]; flag = true; break; &#125; rear++; &#125; if(flag) continue; else &#123; while(pre &lt; i) &#123; if(nums[pre] &gt; nums[i]) &#123; ret[i] = nums[pre]; break; &#125; pre++; &#125; if(pre == i) ret[i] = -1; &#125; &#125; return ret; &#125;&#125;; ç›¸æ¯”ä¸Šä¸€æ®µä»£ç è€Œè¨€ï¼Œæ—¶é—´æ¶ˆè€—å‡å°‘äº† 3 å€...ä¸è¿‡ä¾ç„¶ä¸æ˜¯ä¸€ä¸ªå¥½è§£æ³•ã€‚ method 2æ­£å¦‚å‰é¢æ‰€è¯´ï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨å•è°ƒæ ˆçš„æ€è·¯æ¥è§£å†³ã€‚ä¸è¿‡ï¼Œè¿™ä¸ªé¢˜è¿˜æœ‰ä¸€ä¸ªä¸ä¸€æ ·çš„åœ°æ–¹ï¼Œå¦‚æžœè¿™ä¸ªæ•°å­—åŽæ²¡æœ‰æ¯”å®ƒæ›´å¤§çš„æ•°äº†ï¼Œå°±éœ€è¦å¾ªçŽ¯çš„ä»Žå¤´å¼€å§‹æŸ¥æ‰¾ã€‚ä½†æ˜¯ï¼Œå•è°ƒæ ˆåªèƒ½æ‰¾åˆ°è¿™ä¸ªå…ƒç´ åŽé¢ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„å…ƒç´ å•Šã€‚å®žé™…ä¸Šï¼Œè¿™é‡Œæœ‰ä¸€ä¸ªç®€å•çš„åšæ³•ï¼Œé‚£å°±æ˜¯é‡æ–°åœ¨éåŽ†ä¸€æ¬¡ï¼Œè¿™æœ‰ç‚¹ç±»ä¼¼å¾ªçŽ¯é˜Ÿåˆ—ã€‚12345678910111213141516class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size, -1); stack&lt;int&gt; st; for(int i = 0; i &lt; size * 2 - 1; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i % size]) &#123; ret[st.top()] = nums[i % size]; st.pop(); &#125; st.push(i % size); &#125; return ret; &#125;&#125;; é‡å¤çš„éåŽ†è¿‡ç¨‹ï¼Œå¯ä»¥ç”¨å–ä½™è¿ç®—æ›¿ä»£ã€‚ä»”ç»†æƒ³æƒ³ï¼Œä¸€æ¬¡éåŽ†ç»“æŸåŽï¼Œå¯¹äºŽä¸€ä¸ªå…ƒç´ è€Œè¨€ï¼Œå¦‚æžœå…¶åŽé¢å­˜åœ¨æ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œé‚£ä¹ˆæ¯”è¿™ä¸ªå…ƒç´ å¤§çš„ç¬¬ä¸€ä¸ªå…ƒç´ å°±æ‰¾åˆ°äº†ã€‚å¯¹åº”çš„ï¼Œç¬¬äºŒæ¬¡éåŽ†çš„æ—¶å€™å°±ä¸ç”¨å…¥æ ˆäº†ï¼Œæ‰€ä»¥ï¼ŒæŠŠä¸¤æ¬¡éåŽ†çš„è¿‡ç¨‹åˆ†å¼€ï¼š12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; nextGreaterElements(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; ret(size, -1); stack&lt;int&gt; st; for(int i = 0; i &lt; size; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) &#123; ret[st.top()] = nums[i]; st.pop(); &#125; st.push(i % size); &#125; for(int i = 0; i &lt; size; i++) &#123; while(!st.empty() &amp;&amp; nums[st.top()] &lt; nums[i]) &#123; ret[st.top()] = nums[i]; st.pop(); &#125; &#125; return ret; &#125;&#125;; 556. Next Greater Element IIIAnalysisé¢˜æ„å¾ˆç®€å•ï¼Œç»™ä¸€ä¸ªæ•°ï¼Œå°†è¿™ä¸ªæ•°å­—çš„æ¯ä¸€ä½é‡æ–°ç»„åˆå½¢æˆä¸€ä¸ªæ–°çš„æ•°ï¼Œåœ¨æ‰€æœ‰çš„è¿™äº›æ–°æ•°ä¸­ï¼Œæ‰¾å‡ºæ¯”ç»™å®šçš„æ•°å¤§ä¸”æ˜¯è¿™äº›æ•°ä¸­æœ€å°çš„æ•°ï¼ˆè¯éƒ½ä¸ä¼šè¯´äº†ï¼‰ã€‚ Codeç»™çš„ n çš„èŒƒå›´æ˜¯ $[1, 2^{31} - 1]$ï¼Œä¹Ÿå°±æ˜¯æœ€å¤šä¸è¶…è¿‡ 10 ä½ã€‚10 ä¸ªæ•°å­—æž„æˆåä½æ•°ï¼Œä¸€å…±æœ‰ 10! ç§ï¼Œè¿™æ˜¯æžç«¯æƒ…å†µä¸‹ï¼Œä¸€èˆ¬æ˜¯å°äºŽè¿™ä¸ªæ•°çš„ï¼Œå› ä¸ºå¯èƒ½å­˜åœ¨é‡å¤çš„æ•°å­—ã€‚å¦‚æžœ dfs æœç´¢å‡ºæ‰€æœ‰ç»“æžœï¼Œç„¶åŽå†é€‰å‡ºç¬¦åˆæ¡ä»¶çš„æœ€å°å€¼ï¼Œå †æ ˆå¯èƒ½ä¼šçˆ†ã€‚æ¢ä¸ªè§’åº¦ç†è§£ï¼Œé‡æ–°æž„é€ æ•°å­—çš„è¿‡ç¨‹ï¼Œå®žé™…ä¸Šä¹Ÿæ˜¯æ¯ä¸€ä½ä¸Šçš„æ•°å­—é‡æ–°æŽ’åˆ—çš„è¿‡ç¨‹ã€‚ é¦–å…ˆæ€è€ƒä¸€ä¸‹ä»€ä¹ˆæ ·æ•°å­—æ²¡æœ‰æ¯”å®ƒå¤§çš„æ•°ï¼Ÿæ˜¾ç„¶ï¼Œæ•°ä½ä¸Šçš„æ•°å­—æ˜¯é€†åºæŽ’åˆ—çš„æ•°å­—ï¼Œæ¯”å¦‚ï¼š321ã€872 å’Œ 9991 ç­‰ï¼Œè¿™ç±»æ•°å­—å·²ç»æ˜¯è¿™äº›æ•°å­—ç»„åˆçš„æœ€å¤§æŽ’åˆ—äº†ã€‚å†æ¥æ€è€ƒå¦‚ä½•ç»„æˆæ¯”ç»™å®šæ•°ä¸‹ä¸€ä¸ªå¤§çš„æ•°ï¼Œä¸‹ä¸€ä¸ªå¤§æ¢å¥è¯è¯´ï¼Œå°±æ˜¯åˆšåˆšå¤§ã€å¤§äº†ä¸€ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªè¿™ä¸ªæ–°æ•°å­—ä¸ŽåŽŸæ•°å­—æ˜¯æœ‰éƒ¨åˆ†ç›¸åŒçš„æ•°ä½çš„ï¼Œè€Œä¸”ä¸ºäº†ä¿è¯æ˜¯â€œä¸‹ä¸€ä¸ªå¤§â€ï¼Œé«˜ä½ä¸Šçš„æ•°å­—ä¸€å®šæ˜¯ç›¸åŒçš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦ä»Žä½Žä½å¼€å§‹æ‰¾ã€‚å“ªæ‰¾ä»€ä¹ˆæ ·å­çš„å‘¢ï¼ŸæŒ‰ç…§å‰é¢çš„åˆ†æžï¼Œå¦‚æžœæ˜¯é€†åºæŽ’åˆ—çš„æ•°å­—ï¼Œä¸å­˜åœ¨æ¯”å®ƒå¤§çš„æ•°ã€‚æ‰€ä»¥ï¼Œè¦æ‰¾çš„é‚£ä¸ªæ•°å­—å°±æ˜¯ç¬¬ä¸€ä¸ªä¸æž„æˆé€†åºçš„æ•°å­—ã€‚è¿˜æ˜¯ä¸¾ä¾‹å­ï¼Œæ¯”å¦‚ 943765ï¼Œå€’æ•°è¿‡æ¥ï¼Œç¬¬ä¸€ä¸ªä¸æž„æˆé€†åºçš„æ•°å­—å°±æ˜¯ 3ã€‚æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æž„æˆé€†åºçš„æ•°ä¹‹åŽå‘¢ï¼ŸåŒæ ·ä¸ºäº†ä¿è¯â€œä¸‹ä¸€ä¸ªå¤§â€ï¼Œä¸èƒ½åŽ»åŠ¨å‰é¢çš„æ•°å­—ï¼Œæ‰€ä»¥åªèƒ½æ‰¾åŽé¢çš„æ•°æ¥ä¸Žè¿™ä¸ªæ•°äº¤æ¢ã€‚å®žé™…ä¸Šï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“çš„çœ‹å‡º 943765 çš„â€œä¸‹ä¸€ä¸ªå¤§â€çš„æ•°å­—å°±æ˜¯ 945367ï¼Œä¹Ÿå°±æ˜¯è®© 3 ä¸Žå…¶åŽé¢æ¯”å®ƒç¬¬ä¸€ä¸ªå¤§çš„ 5 è¿›è¡Œäº¤æ¢ï¼Œç„¶åŽå†é€†åºå¾—åˆ°çš„ 763 è¿™ä¸ªåºåˆ—ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå°±å¯ä»¥å¾—åˆ°ä¸‹ä¸€ä¸ªå¤§çš„æ•°å­—äº†ã€‚123456789101112131415161718192021class Solution &#123;public: int nextGreaterElement(int n) &#123; string s = to_string(n); int len = s.length(); if(len == 1) return -1; int pos = len - 2; while(pos &gt;= 0 &amp;&amp; s[pos] &gt;= s[pos + 1]) pos--; if(pos &lt; 0) return -1; int nextpost = len - 1; while(nextpost &gt;= 0 &amp;&amp; s[nextpost] &lt;= s[pos]) nextpost--; swap(s[pos], s[nextpost]); reverse(s.begin() + pos + 1, s.end()); long long ret = 0; for(int i = 0; i &lt; len; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; if(ret &gt; INT_MAX) return -1; return ret; &#125;&#125;; æœ€åŽåˆ«å¿˜è®°äº†ï¼Œé¢˜ç›®é™å®šäº†æ•°å­—çš„ç»“æžœæ˜¯ $[1, 2^{31} - 1]$ çš„èŒƒå›´å†…ã€‚å¦å¤–ï¼Œè½¬æ¢æ•´æ•°çš„è¿‡ç¨‹å¯ä»¥è°ƒç”¨åº“å‡½æ•° stoll å®Œæˆï¼š1long long ret = stoll(s); 31. Next PermutationAnalysisé¡ºè·¯æŠŠè¿™ä¸ªé¢˜ä¹Ÿè§£å†³äº†ï¼Œå¥½åƒä¸Žä¸Šé¢çš„é¢˜ç›®æ˜¯ä¸€æ ·çš„ã€‚è¯»äº†ä¸€ä¸‹é¢˜ç›®ï¼Œæžœç„¶æ˜¯ä¸€æ ·çš„ã€‚è§£é¢˜çš„æ€è·¯åŸºæœ¬ä¸Šæ˜¯ä¸€è‡´çš„ï¼Œåªæ˜¯ä¸éœ€è¦åœ¨åš int æº¢å‡ºåˆ¤æ–­äº†ã€‚ Codeemï¼Œæ€è·¯å®Œå…¨ä¸€è‡´...12345678910111213141516class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); int pos = size - 2; while(pos &gt;= 0 &amp;&amp; nums[pos] &gt;= nums[pos + 1]) pos--; if(pos == -1) &#123; reverse(nums.begin(), nums.end()); &#125; else &#123; int nextpos = size - 1; while(nextpos &gt;= 0 &amp;&amp; nums[nextpos] &lt;= nums[pos]) nextpos--; swap(nums[pos], nums[nextpos]); reverse(nums.begin() + pos + 1, nums.end()); &#125; &#125;&#125;; å®¹æ˜“å¿½ç•¥çš„åœ°æ–¹è¿˜æœ‰ä¸€ç‚¹ï¼Œé‚£å°±æ˜¯åœ¨å¯»æ‰¾è¿™ä¸¤ä¸ªæ•°æ—¶ï¼Œä¸€å®šè¦ä¸¥æ ¼å¤§äºŽæˆ–å°äºŽï¼Œä¸èƒ½ç­‰äºŽã€‚å®žé™…ä¸Šï¼ŒC++ å†…æœ‰çŽ°æˆçš„å‡½æ•°å¯ä»¥ç”¨ðŸ˜ã€‚123456class Solution &#123;public: void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; next_permutation(nums.begin(), nums.end()); &#125;&#125;; Summaryä¸çŸ¥é“è¯´ä»€ä¹ˆå¥½äº†...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 77 åœºåŒå‘¨èµ›]]></title>
    <url>%2F2022%2F05%2F08%2FLeetcode-%E7%AC%AC-77-%E5%9C%BA%E5%8F%8C%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[RT...å¥½ä¸å®¹æ˜“æ˜¨å¤©æŠŠ 290 åœºå‘¨èµ›çš„é—®é¢˜å†™å®Œäº†~è¿™ä¹Ÿæ˜¯å‰é¢å‚åŠ çš„å‘¨èµ›ç³»åˆ—... 2255. Count Prefixes of a Given StringAnalysisé¢˜æ„æ¯”è¾ƒç›´æŽ¥ï¼Œç»™ä¸€ç³»åˆ—å­—ç¬¦ä¸²ï¼Œåˆ¤æ–­è¿™äº›å­—ç¬¦ä¸²æ˜¯ä¸æ˜¯ s çš„å‰ç¼€ã€‚å®žé™…ä¸Šï¼Œéœ€è¦æ»¡è¶³ 2 ä¸ªæ¡ä»¶ï¼š ç¬¬ä¸€ä¸ªå­—ç¬¦ç›¸åŒã€‚ æ˜¯ s çš„å­ä¸²ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š12345678910class Solution &#123;public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int size = words.size(), cnt = 0; for(int i = 0; i &lt; size; i++) &#123; if(s.find(words[i]) == 0) cnt++; &#125; return cnt; &#125;&#125;; å…¶å®žä¸ç”¨ find å‡½æ•°ï¼Œç”¨ substr å‡½æ•°ä¹Ÿæ˜¯å¯ä»¥çš„ï¼š12345678910class Solution &#123;public: int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int cnt = 0; for(auto &amp;w: words) &#123; if(s.substr(0, w.length()) == w) cnt++; &#125; return cnt; &#125;&#125;; ä¹Ÿå¯ä»¥å…¨éƒ¨è‡ªå·±å†™ï¼š1234567891011121314151617class Solution &#123;public: bool isprefix(string &amp;w, string &amp;s) &#123; if(w.length() &gt; s.length()) return false; for(int i = 0; i &lt; w.length(); i++) &#123; if(w[i] != s[i]) return false; &#125; return true; &#125; int countPrefixes(vector&lt;string&gt;&amp; words, string s) &#123; int cnt = 0; for(string &amp;w: words) &#123; if(isprefix(w, s)) cnt++; &#125; return cnt; &#125;&#125;; æ€è·¯éƒ½æ˜¯ä¸€æ ·çš„... 2256. Minimum Average DifferenceAnalysisé¢˜ç›®ç¨å¾®æœ‰ç‚¹é•¿ï¼Œä¸è¿‡æ„æ€ä¹Ÿå¾ˆç›´æŽ¥ï¼Œå°±æ˜¯å°†å…ƒç´ åˆ†æˆä¸¤éƒ¨åˆ†ï¼Œç®—å‡ºå¹³å‡å€¼åŽï¼Œä½œå·®å–ç»å¯¹å€¼ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š1234567891011121314151617181920class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; vector&lt;long long&gt; pre(size + 1), ave(size + 1); for(int i = 0; i &lt; size; i++) &#123; pre[i + 1] = pre[i] + nums[i]; &#125; for(int i = 0; i &lt; size - 1; i++) &#123; ave[i] = abs(pre[i + 1] / (i + 1) - (pre[size] - pre[i + 1]) / (size - i - 1)); &#125; ave[size - 1] = pre[size] / size; int pos = 0; for(int i = 1; i &lt; size; i++) &#123; if(ave[i] &lt; ave[pos]) pos = i; &#125; return pos; &#125;&#125;; åŸºæœ¬æ€è·¯æ˜¯æ±‚å‰ç¼€å’Œï¼Œç„¶åŽå†éåŽ†æ•°ç»„ç®—å‡ºæ‰€æœ‰çš„ç»å¯¹å·®ï¼Œå†æŸ¥æ‰¾æœ€å°çš„ã€‚å½“æ—¶æ²¡çœ‹æ•°æ®è§„æ¨¡æ˜¯ $1 \le nums.length \le 10^5$ï¼Œ$0 \le nums[i] \le 10^5$ï¼Œå¿½ç•¥äº†åœ¨è®¡ç®—è¿‡ç¨‹ä¸­å¯èƒ½å‡ºçŽ°çš„æº¢å‡ºï¼Œç»“æžœ WA äº†ä¸€æ¬¡ï¼ŒæŠŠ vector çš„ç±»åž‹æ”¹æˆ long long åŽå°±é€šè¿‡äº†ï¼Œå‘çˆ¹å•Šã€‚ å½“æ—¶æ€è€ƒçš„æ—¶å€™ï¼Œåœ¨ä¸‹æ ‡çš„è¿ç®—ä¸Šæ€è€ƒäº†ä¸€ä¼šã€‚å…¶å®žæ˜¯æœ€åŽä¸€ä¸ªæ•°å­—ï¼Œå‡ºçŽ°äº† 0 ä½œä¸ºé™¤æ•°çš„æƒ…å†µï¼Œç‰¹åˆ«å¤„ç†ä¸€ä¸‹å°±å¯ä»¥äº†ã€‚çŽ°åœ¨çœ‹æ¥å°±æ²¡æœ‰å¿…è¦ç”¨é‡æ–°åœ¨ç”¨æ•°ç»„ä¿å­˜æ¯ä¸€ä¸ªå…ƒç´ çš„ç»å¯¹å·®äº†ï¼š1234567891011121314151617181920212223class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; vector&lt;long long&gt; pre(size + 1); for(int i = 0; i &lt; size; i++) &#123; pre[i + 1] = pre[i] + nums[i]; &#125; long long minabsave = LONG_MAX, tmp; int pos = -1; for(int i = 0; i &lt; size - 1; i++) &#123; tmp = abs(pre[i + 1] / (i + 1) - (pre[size] - pre[i + 1]) / (size - i - 1)); if(tmp &lt; minabsave) &#123; minabsave = tmp; pos = i; &#125; &#125; tmp = pre[size] / size; if(tmp &lt; minabsave) pos = size - 1; return pos; &#125;&#125;; ä»”ç»†è§‚å¯Ÿå¯ä»¥å‘çŽ°ï¼Œå¦‚æžœä¸€å¼€å§‹å°±æŠŠæ•°ç»„çš„å’Œæ±‚å‡ºæ¥ï¼Œé‚£ä¹ˆå¥½åƒå‰ç¼€å’Œæ•°ç»„ä¹Ÿä¸éœ€è¦äº†ã€‚1234567891011121314151617181920212223class Solution &#123;public: int minimumAverageDifference(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return 0; long long minabsave = LONG_MAX, tmp, sum = 0, pre = 0; for(int i = 0; i &lt; size; i++) &#123; sum += nums[i]; &#125; int pos = -1; for(int i = 0; i &lt; size - 1; i++) &#123; pre += nums[i]; tmp = abs(pre / (i + 1) - (sum - pre) / (size - i - 1)); if(tmp &lt; minabsave) &#123; minabsave = tmp; pos = i; &#125; &#125; tmp = sum / size; if(tmp &lt; minabsave) pos = size - 1; return pos; &#125;&#125;; 2257. Count Unguarded Cells in the GridAnalysisé¢˜ç›®æ„æ€å…¶å®žå¾ˆç®€å•ï¼Œè­¦å«æ‰€æœ‰èƒ½çœ‹è§çš„æ ¼å­éƒ½æ˜¯è¢«ä¿å«çš„ï¼Œè¢«å¢™å µç€ï¼Œçœ‹ä¸è§çš„å°±æ˜¯æ²¡è¢«ä¿å«çš„ã€‚å½“æ—¶åšçš„æ—¶å€™ï¼Œæ€»ä»¥ä¸ºæ˜¯ä¸ªå›¾çš„é¢˜ç›®ï¼Œç»“æžœå†™åŠå¤© bfsã€‚å†™å®Œè¿è¡Œå‘çŽ°ï¼Œç»“æžœä¸å¯¹ï¼Œä»”ç»†ä¸€æƒ³ï¼Œè¿™å¥½åƒå°±æ˜¯ä¸ªæ¨¡æ‹Ÿé¢˜ï¼Ÿç»“æžœåˆå…¨åˆ äº†ï¼Œé‡æ–°å†å†™ã€‚ Codeè¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(); for(int i = 0; i &lt; walls.size(); i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 2) break; matrix[tmpx][tmpy] = 1; tmpy++; &#125; &#125; int cnt = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) cnt++; &#125; &#125; return cnt; &#125;&#125;; ä¸Šé¢æ˜¯å½“æ—¶å†™çš„æš´åŠ›è§£æ³•ï¼Œå¯æƒœæ­»åœ¨ç¬¬ 38 ä¸ªç”¨ä¾‹äº†ã€‚åŸºæœ¬æ€è·¯å°±æ˜¯ç”¨ä¸åŒçš„æ ‡è®°æ¥è¡¨ç¤ºæŸä¸ªæ ¼å­æ˜¯è¢«ä¿å«çš„ã€å¢™ã€è­¦å«æˆ–æ²¡è¢«ä¿å«çš„ï¼Œè¿™ä¸ŽçŽ°åœ¨é¢˜ç›®ç»™å‡ºçš„æç¤ºæ˜¯ä¸€è‡´çš„æ€è·¯ã€‚ä»”ç»†çœ‹ä¸‹ä¸Šé¢è¿™æ®µä»£ç ï¼Œå®žé™…ä¸Šæœ€åŽä¸€ä¸ª $O(n^2)$ çš„å¾ªçŽ¯å¯ä»¥çœåŽ»ï¼Œç›´æŽ¥ç”¨çŸ©é˜µæ€»æ•°å‡åŽ»è¢«æ ‡è®°çš„æ ¼å­æ•°ç›®å³å¯ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 2) break; else if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; tmpy++; &#125; &#125; return m * n - cnt; &#125;&#125;; å¯æƒœè¿™æ ·è¿˜æ˜¯è¿‡ä¸åŽ» 38 ä¸ªç”¨ä¾‹ã€‚ä»”ç»†æƒ³æƒ³ï¼Œæ¯ä¸ªè­¦å«å¯èƒ½å­˜åœ¨æ¨ªåæ ‡æˆ–è€…çºµåæ ‡ç›¸åŒçš„æ—¶å€™ï¼Œè¿™æ ·æŒ‰ç…§ä¸Šé¢çš„ä»£ç å°±ä¼šäº§ç”Ÿé‡å¤æ ‡è®°çš„è¿‡ç¨‹ã€‚å¾—æƒ³åŠžæ³•åŽ»é™¤è¿™éƒ¨åˆ†é‡å¤çš„è¿‡ç¨‹ï¼Œå¯ä»¥ä½¿ç”¨ set å­˜å…¥æ‰€æœ‰çš„æ¨ªåæ ‡ä¸Žçºµåæ ‡ï¼Œç„¶åŽå†åˆ†åˆ«éåŽ†ï¼Œä½†è¿™æ ·æ— æ³•åˆ¤æ–­å¢™æ˜¯åœ¨ç‚¹çš„å·¦è¾¹è¿˜æ˜¯å³è¾¹ï¼ˆä¸Šè¾¹è¿˜æ˜¯ä¸‹è¾¹ï¼‰ï¼Œè¿™æ ·å°±ä¼šæ¼è§£äº†ã€‚çœ‹äº†åˆ«äººçš„é¢˜è§£ï¼Œæ‰å‘çŽ°è‡ªå·±å¿½ç•¥äº†ä¸€ä¸ªç»†èŠ‚...é‚£å°±æ˜¯ä»Žè­¦å«å¼€å§‹éåŽ†çš„æ—¶å€™ï¼Œå¦‚æžœé‡åˆ°è­¦å«äº†ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥é€€å‡ºå¾ªçŽ¯ï¼ˆä¸Žå¢™æ˜¯ä¸€æ ·çš„ï¼‰ã€‚å› ä¸ºï¼Œé‡åˆ°çš„è¿™ä¸ªè­¦å«ä¹‹å‰çš„éåŽ†è¿‡ç¨‹ä¹Ÿæ˜¯è¿™æ ·çš„ðŸ˜‚ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; matrix[x][y] = 3; // up tmpx = x - 1, tmpy = y; while(tmpx &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpx--; &#125; // down tmpx = x + 1, tmpy = y; while(tmpx &lt; m) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpx++; &#125; // left tmpx = x, tmpy = y - 1; while(tmpy &gt;= 0) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpy--; &#125; // right tmpx = x, tmpy = y + 1; while(tmpy &lt; n) &#123; if(matrix[tmpx][tmpy] == 0) &#123; matrix[tmpx][tmpy] = 1; cnt++; &#125; else if(matrix[tmpx][tmpy] != 1) break; tmpy++; &#125; &#125; return m * n - cnt; &#125;&#125;; emï¼Œæ€»ç®—æ˜¯é€šè¿‡äº†...å¿½ç•¥äº†ç»†èŠ‚å•Š...ä¸è¿‡è¿™æ®µä»£ç çœ‹çš„æœ‰ç‚¹åºŸåŠ²ï¼Œå€Ÿç”¨ä¸€ä¸‹å›¾çš„ bfs å†™æ³•ï¼Œæ”¹ä¸€ä¸‹ï¼š12345678910111213141516171819202122232425262728293031class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int countUnguarded(int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; guards, vector&lt;vector&lt;int&gt;&gt;&amp; walls) &#123; vector&lt;vector&lt;int&gt;&gt; matrix(m, vector&lt;int&gt;(n)); int size = guards.size(), cnt = walls.size(); for(int i = 0; i &lt; cnt; i++) &#123; matrix[walls[i][0]][walls[i][1]] = 2; &#125; for(int i = 0; i &lt; size; i++) &#123; matrix[guards[i][0]][guards[i][1]] = 3; &#125; cnt += size; for(int i = 0; i &lt; size; i++) &#123; int x = guards[i][0], y = guards[i][1], tmpx, tmpy; for(int j = 0; j &lt; 4; j++) &#123; int newx = x + X[j], newy = y + Y[j]; while(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n) &#123; if(matrix[newx][newy] == 0) &#123; matrix[newx][newy] = 1; cnt++; &#125; else if(matrix[newx][newy] != 1) break; newx += X[j]; newy += Y[j]; &#125; &#125; &#125; return m * n - cnt; &#125;&#125;; å¥½å¤šäº†ï¼Œçœ‹æ¥è¿˜æ˜¯è·Ÿ bfs æœ‰ç‚¹ç“œè‘›çš„...ðŸ˜‘ 2258. Escape the Spreading FireAnalysisé¢˜ç›®ç•¥é•¿ï¼Œè¯»å®Œä¹‹åŽï¼Œæ„Ÿè§‰åƒæ˜¯ç¬¬ 3 é¢˜çš„åŠ å¼ºç‰ˆ...ä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯èµ°è¿·å®«çš„åŠ å¼ºç‰ˆï¼ŒçŸ¥é“æ˜¯è·Ÿ bfs ç›¸å…³çš„é¢˜ï¼Œæ— å¥ˆï¼Œæ²¡ä»€ä¹ˆæ€è·¯... Codeè¯»äº†ä¸€ä¸‹å¤§ä½¬ä»¬çš„æ€è·¯ï¼Œè®°å½•ä¸€ä¸‹ã€‚é¦–å…ˆè¦æ³¨æ„åˆ°é¢˜ç›®è¦æ±‚çš„æ˜¯åˆå§‹ä½ç½®å¯ä»¥åœç•™çš„æœ€å¤šåˆ†é’Ÿæ•°ï¼Œæ‰€ä»¥åœ¨æžšä¸¾æ—¶é—´çš„æ—¶å€™ï¼Œéœ€è¦æ‰¾åˆ°ä¸€ä¸ªåˆé€‚çš„æ–¹å¼æ¥æžšä¸¾ã€‚å¦å¤–ï¼Œé¢˜ç›®è¯´æ˜Žäº†ä»€ä¹ˆæ ·çš„æƒ…å†µç®—æ˜¯å®‰å…¨åˆ°è¾¾äº†â€”â€”åœ¨ç«è”“å»¶åˆ°ä¹‹å‰åˆ°è¾¾å®‰å…¨å±‹ã€‚é‚£ä¹ˆä¹Ÿå°±æ˜¯è¯´ï¼Œäººåœ¨æŸä¸ªæ—¶åˆ» t å¼€å§‹é€ƒç”Ÿï¼Œåªè¦èƒ½åœ¨ç«åŠ¿è”“å»¶ä¹‹å‰åˆ°è¾¾å®‰å…¨å±‹å³å¯ã€‚ ä½†æ˜¯è¦æ³¨æ„äººé€ƒç”Ÿä¸Žç«åŠ¿è”“å»¶çš„å·®åˆ«ï¼Œäººæ˜¯åœ¨ t æ—¶åˆ»ä¹‹åŽæ‰å¼€å§‹é€ƒç”Ÿï¼ˆå¼€å§‹åŠ¨ï¼‰ï¼Œç«æ˜¯ä»Ž 0 æ—¶åˆ»å°±å¼€å§‹è”“å»¶äº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦å…ˆç”¨ bfs è®©ç«åŠ¿è”“å»¶ t æ—¶åˆ»ï¼Œç„¶åŽå†ç”¨ bfs å¾—å‡ºäººé€ƒç”Ÿçš„è·¯å¾„çš„åŒæ—¶è®©ç«åŠ¿ç»§ç»­è”“å»¶ï¼Œæ¯”å¯¹äºŒè€…ä¹‹é—´åˆ°è¾¾ç›¸åŒæ ¼å­çš„æ—¶åˆ»ã€‚ å¦‚æžœäººåœ¨ä¸­é€”ä¸Žç«ç›¸é‡äº†ï¼Œé‚£è‚¯å®šå°±æ— æ³•é€ƒç”Ÿäº†ï¼Œä½†äººè‹¥æ˜¯ä¸Žç«åŒæ—¶åˆ°è¾¾å®‰å…¨å±‹ï¼Œé‚£ä¹Ÿæ˜¯å¯ä»¥é€ƒç”Ÿçš„ã€‚ å†å›žå¤´æƒ³æƒ³å¦‚ä½•æžšä¸¾æ—¶é—´æ¯”è¾ƒåˆç†ï¼ŒæŒ‰ç…§ $O(n)$ çš„æ—¶é—´æ¥æžšä¸¾è‚¯å®šä¸å¤ªè¡Œï¼Œæ¯”å®ƒæ›´çŸ­çš„æ—¶é—´å°±æ˜¯ $O(logn)$ äº†ï¼Œæƒ³åˆ°è¿™é‡Œï¼Œè„‘å­é‡Œè‡ªç„¶å°±ä¼šæµ®çŽ°äºŒåˆ†çš„å½±å­ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class Solution &#123; const int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;0, -1&#125;&#125;;public: bool check(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int t) &#123; int m = grid.size(), n = grid[0].size(); bool fire[m][n]; memset(fire, 0, sizeof(fire)); vector&lt;pair&lt;int, int&gt;&gt; f, q; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == 1) &#123; fire[i][j] = true; f.emplace_back(i, j); &#125; &#125; &#125; auto separate_fire = [&amp;] () &#123; vector&lt;pair&lt;int, int&gt;&gt; nf; for(auto &amp;[i, j]: f) &#123; for(auto [dx, dy]: dirs) &#123; int x = i + dx, y = j + dy; if(0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; !fire[x][y] &amp;&amp; grid[x][y] != 2) &#123; fire[x][y] = true; nf.emplace_back(x, y); &#125; &#125; &#125; f = move(nf); &#125;; while(t-- &amp;&amp; !f.empty()) separate_fire(); if(fire[0][0]) return false; bool vis[m][n]; memset(vis, 0, sizeof(vis)); vis[0][0] = true; q.emplace_back(0, 0); while(!q.empty()) &#123; vector&lt;pair&lt;int, int&gt;&gt; nq; for(auto &amp;[i, j]: q) &#123; if(!fire[i][j]) &#123; for(auto [dx, dy]: dirs) &#123; int x = i + dx, y = j + dy; if(0 &lt;= x &amp;&amp; x &lt; m &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; n &amp;&amp; !fire[x][y] &amp;&amp; !vis[x][y] &amp;&amp; grid[x][y] != 2) &#123; if(x == m - 1 &amp;&amp; y == n - 1) return true; vis[x][y] = true; nq.emplace_back(x, y); &#125; &#125; &#125; &#125; q = move(nq); separate_fire(); &#125; return false; &#125; int maximumMinutes(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); int left = -1, right = m * n; while(left &lt; right) &#123; int mid = (left + right + 1) / 2; if(check(grid, mid)) left = mid; else right = mid - 1; &#125; return left &lt; m * n ? left : 1e9; &#125;&#125;; å§‘ä¸”ç®—æ˜¯æžæ¸…æ¥šäº†å¤§è‡´çš„æ±‚è§£è¿‡ç¨‹ã€‚ä¸è¿‡å¾ˆæ˜¾ç„¶ï¼Œå¯¹äºŽå›¾çš„å†…å®¹æ—©å¿˜å®Œäº†çš„æˆ‘ï¼ŒçŽ°åœ¨ç¢ç£¨è¿™ä¸ªé—®é¢˜æœ‰ç‚¹æµªè´¹æ—¶é—´äº†ï¼Œæš‚æ—¶å…ˆæ”¾ç€ã€‚ Summaryé¢ï¼Œè¿™æ¬¡å‘¨èµ›ä¹‹åŽï¼Œä»Žåšä¸€ä¸ªé¢˜ç­¾ä¸ªåˆ°ï¼Œå˜æˆäº†åšäºŒä¸ªé¢˜ï¼Œå†ç­¾åˆ°äº†ï¼Œå“ˆå“ˆðŸ¤£ã€‚å›žè¿‡å¤´æ¥çœ‹ï¼Œç¬¬ä¸‰ä¸ªé¢˜å…¶å®žå·²ç»æƒ³åˆ°äº†åšæ³•äº†ï¼Œåªæ˜¯åœ¨å¦‚ä½•ä¼˜åŒ–æ—¶é—´ä¸Šæ²¡æœ‰ç»éªŒå•Šã€‚ç›´æŽ¥åŽŸå› æ˜¯å¿½ç•¥äº†ä¸€äº›ç»†èŠ‚ï¼Œæ ¹æœ¬åŽŸå› è¿˜æ˜¯ä¸ç†Ÿç»ƒã€‚ä»”ç»†æƒ³æƒ³ï¼Œç¬¬ 3 é¢˜è·Ÿç¬¬ 4 é¢˜å¥½åƒæ˜¯é€’è¿›å…³ç³»çš„é¢˜ç›®ï¼Œç¬¬ 4 é¢˜å¥½åƒæ˜¯ç¬¬ 3 é¢˜çš„åŠ å¼ºç‰ˆä¸€æ ·ï¼Œéƒ½æ˜¯ bfsã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day9]]></title>
    <url>%2F2022%2F05%2F08%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day9%2F</url>
    <content type="text"><![CDATA[ä»Žå‘¨èµ›å›žæ¥äº†~ 1630. Arithmetic SubarraysAnalysisé¢˜ç›®æœ‰ç‚¹é•¿ï¼Œå¤§æ¦‚æ„æ€å°±æ˜¯åˆ¤æ–­ç»™å®šä¸‹æ ‡åŒºé—´å†…çš„æ•°èƒ½ä¸èƒ½æž„æˆç­‰å·®æ•°åˆ—ã€‚ Codeå¦‚æžœè¿™ä¸ªé¢˜è¦ä¼˜åŒ–æ—¶é—´ï¼Œæ„Ÿè§‰å¯ä»¥ä»Žæž„æˆç­‰å·®æ•°åˆ—çš„æœ€å¤§åŒºé—´å…¥æ‰‹å‘¢ï¼Ÿå…ˆæš´åŠ›å†è¯´ðŸ˜‚ã€‚123456789101112131415161718192021222324class Solution &#123;public: vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123; int size = nums.size(), rangesize = l.size(); vector&lt;bool&gt; ret(rangesize); for(int i = 0; i &lt; rangesize; i++) &#123; int left = l[i], right = r[i]; vector&lt;int&gt; tmp; while(left &lt;= right) tmp.push_back(nums[left++]); sort(tmp.begin(), tmp.end()); int diff = tmp[1] - tmp[0]; bool flag = true; for(int j = 1; j &lt; tmp.size() - 1; j++) &#123; if(diff != tmp[j + 1] - tmp[j]) &#123; ret[i] = false; flag = false; break; &#125; &#125; if(flag) ret[i] = true; &#125; return ret; &#125;&#125;; emï¼Œæš´åŠ›è¿‡äº†...ðŸ¤£æƒ³æƒ³å¦‚ä½•ä¼˜åŒ–ï¼Œä»”ç»†æƒ³æƒ³æž„æˆç­‰å·®æ•°åˆ—çš„æœ€å¤§åŒºé—´ï¼Œå…¶å†…éƒ¨çš„å°åŒºé—´ä¸ä¸€å®šèƒ½æž„æˆç­‰å·®æ•°åˆ—ï¼Œæ‰€ä»¥è¿™ä¸ªæ€è·¯å¯èƒ½ä¸å¤ªè¡Œã€‚è¿™æ ·çœ‹æ¥ï¼Œä¸€å®šè¦å¾—æŠŠç»™å®šçš„å°åŒºé—´èŒƒå›´å†…çš„æ•°æŒ‘å‡ºæ¥åŽï¼Œæ‰èƒ½è¿›è¡Œåˆ¤æ–­ã€‚çœ‹äº†ä¸€ä¸‹åˆ«äººçš„æ€è·¯ï¼Œå…¶å®žå¯ä»¥é¿å…æŽ’åºã€‚æŒ‰ç…§ç­‰å·®æ•°åˆ—çš„æ€§è´¨ï¼Œæ•°åˆ—ä¸­æ¯ä¸€é¡¹å‡åŽ»é¦–é¡¹åŽï¼Œå¾—åˆ°çš„ç»“æžœå…¨éƒ¨æ˜¯å…¬å·®çš„å€æ•°ï¼Œè¿™æ ·å°±åªç”¨åˆ¤æ–­è¿™äº›å·®æ˜¯å¦èƒ½åˆ«ç¬¬ä¸€é¡¹å…¬å·®æ•´é™¤å³å¯ï¼Œå°±ä¸ç”¨æŽ’åºäº†ã€‚ä½†æ˜¯è¦æ³¨æ„å…¬å·® d ä¸º 0 æ—¶ï¼Œæ— æ³•å½“ä½œé™¤æ•°ï¼Œä½†ç­‰å·®æ•°åˆ—çš„å…¬å·®æ˜¯å¯ä»¥ä¸º 0 çš„ï¼ˆæ­¤æ—¶æ•°åˆ—ä¸ºå¸¸æ•°åˆ—ï¼‰ã€‚12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;bool&gt; checkArithmeticSubarrays(vector&lt;int&gt;&amp; nums, vector&lt;int&gt;&amp; l, vector&lt;int&gt;&amp; r) &#123; int rangesize = l.size(); vector&lt;bool&gt; ret(rangesize); for(int i = 0; i &lt; rangesize; i++) &#123; int left = l[i], right = r[i]; int min1 = INT_MAX, min2 = INT_MAX; for(int j = left; j &lt;= right; j++) &#123; if(nums[j] &lt; min1 &amp;&amp; nums[j] &lt; min2) &#123; min2 = min1; min1 = nums[j]; &#125; else if(nums[j] &gt;= min1 &amp;&amp; nums[j] &lt; min2) &#123; min2 = nums[j]; &#125; &#125; int size = right - left + 1; if(size &lt;= 2) &#123; ret[i] = true; continue; &#125; int d = min2 - min1; bool flag = true; vector&lt;bool&gt; visited(size, false); for(int j = left; j &lt;= right; j++) &#123; int tmp = nums[j] - min1; if((d == 0 &amp;&amp; tmp != 0) || (d != 0 &amp;&amp; (tmp % d != 0 || tmp / d &gt;= size || visited[tmp / d]))) &#123; flag = false; break; &#125; if(d != 0) visited[tmp / d] = true; &#125; ret[i] = flag; &#125; return ret; &#125;&#125;; å°±è¿™ä¸ªé¢˜è€Œè¨€ï¼Œè¿è¡Œé€Ÿåº¦ç¡®å®žæå‡äº†ä¸å°‘... 429. N-ary Tree Level Order TraversalAnalysisè¿™ä¸ªé¢˜å¥½åƒæ˜¯ä¹‹å‰æ¯æ—¥ä¸€é¢˜åšè¿‡çš„é¢˜å“ˆ...å¸¸è§„é¢˜åž‹ï¼ŒN å‰æ ‘çš„å±‚åºéåŽ†ã€‚ Codeè¿™æ˜¯åŽŸæ¥å†™çš„ï¼š1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; if(!root) return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; ret; queue&lt;Node*&gt; q; q.push(root); while(!q.empty()) &#123; int cnt = q.size(); vector&lt;int&gt; level; for(int i = 0; i &lt; cnt; i++) &#123; Node* cur = q.front(); q.pop(); level.push_back(cur-&gt;val); for(auto child: cur-&gt;children) &#123; q.push(child); &#125; &#125; ret.push_back(level); &#125; return ret; &#125;&#125;; çŽ°åœ¨å†™çš„ï¼š12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;Node*&gt; q; q.push(root); ret.push_back(&#123;root-&gt;val&#125;); while(!q.empty()) &#123; queue&lt;Node*&gt; tmp; vector&lt;int&gt; v; while(!q.empty()) &#123; Node *node = q.front(); q.pop(); int size = node-&gt;children.size(); for(int i = 0; i &lt; size; i++) &#123; tmp.push(node-&gt;children[i]); v.push_back(node-&gt;children[i]-&gt;val); &#125; &#125; q = tmp; if(v.size() != 0) ret.push_back(v); &#125; return ret; &#125;&#125;; è™½ç„¶çŽ°åœ¨è‡ªå·±å†™ä¹Ÿé€šè¿‡äº†ï¼Œä¸è¿‡è¿˜æ˜¯æœ‰ä¸è¶³çš„åœ°æ–¹å•Š...é¦–å…ˆæ˜¯æ²¡æœ‰å¿…è¦å†ç”¨ä¸€ä¸ªé˜Ÿåˆ—æ¥ä¿å­˜ä¸‹ä¸€å±‚çš„ç»“ç‚¹é¡ºåºï¼Œåªéœ€è¦æ¯æ¬¡å¾ªçŽ¯å‰è®°å½•ä¸‹é˜Ÿåˆ—çš„å¤§å°å°±å¯ä»¥äº†ã€‚å…¶æ¬¡ï¼Œå°±æ˜¯æœ‰äº›åœ°æ–¹è¿˜å¯ä»¥å†å†™çš„ç®€å•ç‚¹...12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(Node* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;Node*&gt; q; q.push(root); while(!q.empty()) &#123; int cnt = q.size(); vector&lt;int&gt; level; for(int i = 0; i &lt; cnt; i++) &#123; Node* node = q.front(); q.pop(); level.push_back(node-&gt;val); for(auto &amp;child: node-&gt;children) &#123; q.push(child); &#125; &#125; ret.push_back(move(level)); &#125; return ret; &#125;&#125;; ç”¨äº†ä¸€ä¸‹ move å‡½æ•°ï¼Œæå‡ä¸€ä¸‹é€Ÿåº¦ã€‚ Summaryæ„Ÿè§‰è¿™ä¸¤ä¸ªé¢˜çš„éš¾åº¦å¤§æ¦‚æ˜¯å‘¨èµ›ç¬¬äºŒé“é¢˜çš„éš¾åº¦...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day8]]></title>
    <url>%2F2022%2F05%2F07%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day8%2F</url>
    <content type="text"><![CDATA[æ€Žä¹ˆä»Šå¤©è¿˜æ˜¯æ•°å­¦é¢˜ï¼Ÿ 54. Spiral MatrixAnalysisè¿™ä¸ªé¢˜æ˜¯åœ¨ PTA ä¸Šåšè¿‡çš„é¢˜ï¼Œé¢˜æ„å¾ˆç®€å•ï¼Œå…¶å®žå°±æ˜¯æŒ‰ç…§èžºæ—‹é¡ºåºè¾“å‡ºæ•°ç»„ã€‚ Codeä¸¤ä¸ªæ³¨æ„çš„åœ°æ–¹ï¼š å½“çŸ©é˜µåªæœ‰ä¸€ä¸ªå…ƒç´ æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤ä¸€ä¸‹ã€‚ å½“çŸ©é˜µæ˜¯ $n Ã— n$ çš„æ–¹é˜µæ—¶ï¼Œä¸­é—´çš„å…ƒç´ éœ€è¦ç‰¹åˆ¤ä¸€ä¸‹ï¼Œä¸ç„¶ä¼šæ­»å¾ªçŽ¯ã€‚ 1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); int index = 0, count = m * n, r = 0, c = 0; if(count == 1) return matrix[0]; int U = 0, D = m - 1, L = 0, R = n - 1; vector&lt;int&gt; ret(count); while(index &lt; count) &#123; while(index &lt; count &amp;&amp; c &lt; R) ret[index++] = matrix[r][c++]; while(index &lt; count &amp;&amp; r &lt; D) ret[index++] = matrix[r++][c]; while(index &lt; count &amp;&amp; c &gt; L) ret[index++] = matrix[r][c--]; while(index &lt; count &amp;&amp; r &gt; U) ret[index++] = matrix[r--][c]; r++, c++; U++, D--, L++, R--; if(index == count - 1) &#123; ret[index++] = matrix[r][c]; break; &#125; &#125; return ret; &#125;&#125;; 973. K Closest Points to OriginAnalysisæ‰¾å‡ºè·ç¦»åŽŸç‚¹æœ€è¿‘çš„ k ä¸ªç‚¹ï¼Œæœ‰ç‚¹æŒ‰ç…§è·ç¦»æŽ’åºçš„å‘³é“ã€‚ Codemethod 1å…ˆæŽ’åºå†è¯´ï¼š123456789101112131415161718class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; int size = points.size(); vector&lt;int&gt; dis(size); vector&lt;int&gt; indices(size); for(int i = 0; i &lt; size; i++) &#123; dis[i] = points[i][0] * points[i][0] + points[i][1] * points[i][1]; &#125; iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return dis[i] &lt; dis[j]; &#125;); vector&lt;vector&lt;int&gt;&gt; ret; for(int i = 0; i &lt; k; i++) &#123; ret.push_back(points[indices[i]]); &#125; return ret; &#125;&#125;; å¥½å§ï¼Œæžœç„¶æ˜¯æŽ’åºå•Šï¼Œä»Žå‘¨èµ›é¢˜å­¦æ¥çš„æ€è·¯ç”¨åˆ°äº†ã€‚ä»”ç»†æƒ³æƒ³ï¼Œé‡æ–°ç”¨æ•°ç»„æŽ’åºï¼Œä¸å¦‚ç›´æŽ¥æ‹¿åŽŸæ•°ç»„æŽ’åºðŸ˜“ï¼š123456789class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; sort(points.begin(), points.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] * a[0] + a[1] * a[1] &lt; b[0] * b[0] + b[1] * b[1]; &#125;); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; è®°å¾—æŽ’åºæ—¶è¦å¼•ç”¨ï¼Œä¸ç„¶æ—¶é—´ã€å†…å­˜æ¶ˆè€—æƒ¨ä¸å¿ç¹...è¿™æ ·æŽ’åºå…¶å®žæ²¡æœ‰ä¸Šé¢å¿«ï¼Œå¯èƒ½æ˜¯å› ä¸ºè®¡ç®—è¿‡ç¨‹åœ¨æŽ’åºå†…éƒ¨çš„åŽŸå› ã€‚ method 2è¿™ä¸ªé¢˜è¿˜å¯ä»¥ä»Žå †çš„è§’åº¦æ¥æ€è€ƒã€‚ç”±äºŽ C++ çš„ priority queue é»˜è®¤çš„æ˜¯å¤§æ ¹å †ï¼Œå¯ä»¥å…ˆå°†å‰ k ä¸ªå…ƒç´ æ”¾å…¥å †å†…ï¼Œç„¶åŽéåŽ†å‰©ä½™ n - k ä¸ªå…ƒç´ ã€‚æ¯ä¸ªå…ƒç´ ä¸Žå †é¡¶å…ƒç´ æ¯”è¾ƒï¼Œå¦‚æžœè·ç¦»å¤§äºŽå †é¡¶å…ƒç´ ï¼Œå°±å¼¹å‡ºå †é¡¶å…ƒç´ ï¼Œå¹¶å°†å½“å‰å…ƒç´ å…¥é˜Ÿã€‚è¿™æ ·ï¼ŒéåŽ†ç»“æŸåŽï¼Œå †å†…çš„å…ƒç´ å°±æ˜¯éœ€è¦çš„ç»“æžœã€‚1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; priority_queue&lt;pair&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; k; i++) &#123; q.emplace(points[i][0] * points[i][0] + points[i][1] * points[i][1], i); &#125; int size = points.size(); for(int i = k; i &lt; size; i++) &#123; int dis = points[i][0] * points[i][0] + points[i][1] * points[i][1]; if(dis &lt; q.top().first) &#123; q.pop(); q.emplace(dis, i); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; ret; while(!q.empty()) &#123; ret.push_back(points[q.top().second]); q.pop(); &#125; return ret; &#125;&#125;; method 3æŒ‰ç…§å®˜æ–¹é¢˜è§£çš„æ€è·¯ï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥ä»Žå¿«æŽ’çš„è§’åº¦æ¥æ€è€ƒï¼š1234567891011121314151617181920212223242526class Solution &#123; mt19937 gen&#123;random_device&#123;&#125;()&#125;;public: void random_select(vector&lt;vector&lt;int&gt;&gt;&amp; points, int left, int right, int k) &#123; int pivot_id = uniform_int_distribution&lt;int&gt;&#123;left, right&#125;(gen); int pivot = points[pivot_id][0] * points[pivot_id][0] + points[pivot_id][1] * points[pivot_id][1]; swap(points[right], points[pivot_id]); int i = left - 1; for(int j = left; j &lt; right; j++) &#123; int dis = points[j][0] * points[j][0] + points[j][1] * points[j][1]; if(dis &lt;= pivot) &#123; i++; swap(points[i], points[j]); &#125; &#125; i++; swap(points[i], points[right]); if(k &lt; i - left + 1) random_select(points, left, i - 1, k); else if( k &gt; i - left + 1) random_select(points, i + 1, right, k - (i - left + 1)); &#125; vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; int size = points.size(); random_select(points, 0, size - 1, k); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; å¯¹ç›®å‰çš„è‡ªå·±ä¿¡æ¯é‡æœ‰ç‚¹å¤§ï¼Œå…ˆæ”¾ç€äº†ðŸ˜‘ã€‚ä½†æ˜¯å¾—å…ˆè®°ç€ç›´æŽ¥è°ƒç”¨åº“å‡½æ•°çš„è§£å†³æ–¹æ³•ï¼š123456789class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; kClosest(vector&lt;vector&lt;int&gt;&gt;&amp; points, int k) &#123; nth_element(points.begin(), points.begin() + k - 1, points.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] * a[0] + a[1] * a[1] &lt; b[0] * b[0] + b[1] * b[1]; &#125;); return &#123;points.begin(), points.begin() + k&#125;; &#125;&#125;; å¤ªé¡¶äº†ðŸ˜‚ã€‚ SummaryçŸ©é˜µçš„é¢˜åšçš„æœ‰ç‚¹æ— èŠäº†ï¼Œç¬¬äºŒä¸ªé¢˜æ„Ÿè§‰è¿˜å¯ä»¥ï¼Œæœ‰ç‚¹æ„æ€~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day7]]></title>
    <url>%2F2022%2F05%2F06%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day7%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©ä¸å‡ºé—¨äº†... 48. Rotate ImageAnalysisé¢˜æ„å¾ˆç®€å•ï¼Œå°†çŸ©é˜µé¡ºæ—¶é’ˆæ—‹è½¬ 90Â° å³å¯ã€‚ Codemethod 1å°½ç®¡é¢˜ç›®é™å®šäº†åŽŸåœ°äº¤æ¢ï¼Œä½†è¿˜æ˜¯å…ˆä¸æŒ‰ç…§è¦æ±‚åšä¸€ä¸‹ã€‚æŠ›å¼€é™åˆ¶æ¡ä»¶ä¹‹åŽï¼Œè¿™å®žé™…ä¸Šå°±æ˜¯çŸ©é˜µçš„è¡Œè½¬åˆ—é—®é¢˜ã€‚1234567891011121314class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), r = 0, c = 0; vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n)); for(int i = n - 1; i &gt;= 0; i--) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[r++][c] = matrix[i][j]; &#125; r = 0, c++; &#125; matrix = ret; &#125;&#125;; è™½ç„¶è¿™æ®µä»£ç ä¹Ÿèƒ½è¿‡ï¼Œä½†æ˜¯æ²¡æœ‰æ‰¾å‡ºè½¬æ¢è§„å¾‹ï¼ŒæŠŠè¡Œåˆ—äº’æ¢çš„æ€æƒ³å¸¦å…¥åˆ°ä»£ç å†…ï¼š12345678910111213class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); vector&lt;vector&lt;int&gt;&gt; ret(n, vector&lt;int&gt;(n)); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[j][n - 1 - i] = matrix[i][j]; &#125; &#125; matrix = ret; &#125;&#125;; è¿™æ ·å°±å¯ä»¥çœ‹å‡º matrix ä¸Žè½¬æ¢åŽçš„çŸ©é˜µçš„åæ ‡è§„å¾‹äº†ã€‚ method 2çŽ°åœ¨ï¼Œå†æ¥æ€è€ƒä¸€ä¸‹åŠ å…¥é™åˆ¶æ¡ä»¶åŽçš„æ–¹æ³•ã€‚æŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œå¯¹äºŽçŸ©é˜µä¸­çš„ä»»æ„å…ƒç´ ï¼Œå¯ä»¥å¾—åˆ°ï¼š$ret[c][n - 1 - r] = matrix[r][c]$ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œéœ€è¦åœ¨ $(c, n - 1 - r)$ è¿™ä¸ªä½ç½®å¡«å…¥ $matrix[r][c]$ã€‚è¿™æ ·ï¼Œå¦‚æžœç›´æŽ¥äº¤æ¢ $matrix[r][c]$ å’Œ $matrix[c][n - 1 - r]$ ä¸å°±å¯ä»¥è¾¾åˆ°åŽŸåœ°äº¤æ¢çš„æ•ˆæžœäº†å—ï¼Ÿä½†é—®é¢˜æ˜¯ $matrix[c][n - 1 - r]$ è½¬æ¢åŽçš„ä½ç½®ä¸æ˜¯ $(r, c)$ï¼Œé‚£æ˜¯ä»€ä¹ˆï¼ŸæŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œ$matrix[c][n - 1 - r]$ çš„ä½ç½®åº”è¯¥æ˜¯ $matrix[n - 1 - r][n - 1 - c]$ã€‚æ­¤æ—¶ï¼Œå¯ä»¥å‘çŽ°ç”±äºŽçŸ©é˜µæœ‰ 4 æ¡è¾¹ï¼Œæ‰€ä»¥æ¯ä¸€è½®äº¤æ¢ä¸­ä¹Ÿæ˜¯ 4 ä¸ªæ•°åœ¨è¿›è¡Œäº¤æ¢ã€‚æŒ‰ç…§è§„å¾‹ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„æ‰¾åˆ°è¿™ 4 ä¸ªæ•°ï¼Œå¹¶ä¸”ç›¸äº’äº¤æ¢ï¼Œè¿™æ ·å¯ä»¥å¾—åˆ°ä¸‹é¢çš„è¿‡ç¨‹ï¼š123swap(matrix[r][c], matrix[c][n - 1 - r])swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c])swap(matrix[r][c], matrix[n - 1 - c][r]) æ³¨æ„å› ä¸ºäº¤æ¢ä½ç½®ä¹‹åŽï¼ŒåŽŸæ¥ä½äºŽå…¶ä»–ä½ç½®çš„å…ƒç´ åœ¨è¿›è¡Œäº¤æ¢åŽéƒ½åˆ°äº† $(r, c)$ è¿™ä¸ªä½ç½®ï¼Œæ‰€ä»¥å®žé™…ä¸Šæ¯æ¬¡éƒ½æ˜¯è¿™ä¸ªä½ç½®åœ¨è¿›è¡Œäº¤æ¢ã€‚æ˜Žç¡®äº¤æ¢è¿‡ç¨‹åŽï¼Œè¿˜éœ€è¦è§£å†³ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å¦‚ä½•æžšä¸¾éœ€è¦äº¤æ¢çš„å…ƒç´ å‘¢ï¼Ÿæ­¤æ—¶ï¼ŒæŒ‰ç…§çŸ©é˜µçš„è¾¹é•¿åˆå¯ä»¥åˆ†æˆ 2 ç§æƒ…å†µï¼š å¥‡æ•°ï¼ŒçŸ©é˜µä¸­å¿ƒçš„å…ƒç´ ä¸ç”¨äº¤æ¢ï¼Œå‰©ä½™å…ƒç´ éœ€è¦äº¤æ¢ã€‚ å¶æ•°ï¼ŒçŸ©é˜µæ‰€æœ‰å…ƒç´ éƒ½éœ€è¦äº¤æ¢ã€‚ å¦å¤–ï¼Œç”±äºŽæ¯æ¬¡äº¤æ¢æ˜¯ 4 ä¸ªå…ƒç´ ä¸€èµ·äº¤æ¢ï¼Œæ‰€ä»¥æžšä¸¾äº† 1 ä¸ªä¹‹åŽï¼Œå‰©ä¸‹çš„å…ƒç´ æ˜¯å·²ç»äº¤æ¢å®Œæˆäº†ï¼Œå°±ä¸ç”¨å†æžšä¸¾äº†ï¼Œé‚£ä¹Ÿå°±æ˜¯è¯´å®žé™…ä¸Šåªç”¨æžšä¸¾çš„å…ƒç´ ä¸ªæ•°æ˜¯ï¼š$$\begin{cases}\frac {n^2}{4} &amp; n æ˜¯å¶æ•° \\\frac {n^2 - 1}{4} &amp; n æ˜¯å¥‡æ•° \\\end{cases}$$æ˜¾ç„¶ï¼Œr çš„å–å€¼èŒƒå›´æ˜¯ $[0, n / 2)$ï¼Œé‚£ c å‘¢ï¼Ÿå®žé™…ä¸Šï¼Œæžšä¸¾çš„æ–¹æ³•ä¹Ÿæœ‰å¤šç§ï¼Œæ‰€ä»¥ c çš„èŒƒå›´ä¹Ÿæœ‰åŒºåˆ«ã€‚è¿™é‡Œä¸¾ä¸¤ç§æžšä¸¾æ–¹æ³•ï¼šä¸€ç§æ˜¯ä»Žå¤–å±‚æžšä¸¾åˆ°å†…å±‚çš„æ–¹æ³•ï¼ˆä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯é¡ºæ—¶é’ˆäº¤æ¢ï¼‰ï¼Œæ­¤æ—¶ c çš„èŒƒå›´æ˜¯ $[r, end - 1)$ï¼Œend - 1 å°±æ˜¯å†…å±‚çŸ©é˜µåˆ—çš„è¾¹ç•Œï¼Œend è¿™ä¸ªå€¼ä¸€å¼€å§‹æ˜¯ç­‰äºŽ n çš„ï¼Œä½†æ˜¯äº¤æ¢å®Œä¸€å±‚å…ƒç´ åŽï¼Œéœ€è¦å‡ 1ï¼Œå†æŠŠåæ ‡ç§»åˆ°å†…å±‚è¿›è¡Œäº¤æ¢ã€‚1234567891011121314class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(), end = n; for(int r = 0; r &lt; n / 2; r++) &#123; for(int c = r; c &lt; end - 1; c++) &#123; swap(matrix[r][c], matrix[c][n - 1 - r]); swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c]); swap(matrix[r][c], matrix[n - 1 - c][r]); &#125; end--; &#125; &#125;&#125;; è¿™ç§æ€è·¯ç¨å¾®å¯èƒ½ç¨å¾®æœ‰ç‚¹ç»•...è¿˜æœ‰ä¸€ç§æ˜¯å°†çŸ©é˜µåˆ†å—ï¼Œå°†çŸ©é˜µæŒ‰ç…§å…ƒç´ ä¸ªæ•°ç›¸ç­‰çš„è§„åˆ™åˆ†æˆ 4 å—ï¼Œè¿™æ ·åªç”¨æžšä¸¾ç¬¬ä¸€å—çš„å…ƒç´ ï¼Œå°±å¯ä»¥å®Œæˆæ•´ä¸ªçŸ©é˜µçš„äº¤æ¢äº†ï¼Œæ­¤æ—¶ c çš„èŒƒå›´å°±æ˜¯ $[0, \frac{n + 1}{2})$ äº†ã€‚12345678910111213class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int r = 0; r &lt; n / 2; r++) &#123; for(int c = 0; c &lt; (n + 1) / 2; c++) &#123; swap(matrix[r][c], matrix[c][n - 1 - r]); swap(matrix[r][c], matrix[n - 1 - r][n - 1 - c]); swap(matrix[r][c], matrix[n - 1 - c][r]); &#125; &#125; &#125;&#125;; æ„Ÿè§‰è¿™ç§æ€è·¯æ›´ç›´æŽ¥ä¸€ç‚¹ã€‚ method 3çŽ°åœ¨å†æ¥å›žå¤´çœ‹è¿™ä¸ªé—®é¢˜ï¼Œåˆ©ç”¨çŸ©é˜µå˜æ¢ï¼ˆå‰é¢æåˆ°çš„è¡Œåˆ—äº’æ¢ï¼‰ï¼Œå¯ä»¥å¾ˆè½»æ¾çš„å¾—åˆ°ç»“æžœï¼Œä½†éœ€è¦æ¶ˆè€—é¢å¤–ç©ºé—´ï¼›ä¸ºäº†ä¸æ¶ˆè€—é¢å¤–ç©ºé—´ï¼Œå°±æ— æ³•è¡Œåˆ—äº’æ¢ï¼Œåªèƒ½æ‰¾å‡ºåæ ‡è§„å¾‹ï¼Œç›´æŽ¥äº¤æ¢ã€‚å¦‚æžœèƒ½æŠŠçŸ©é˜µçš„å˜æ¢ä¸Žæ‰¾è§„å¾‹ç»“åˆèµ·æ¥ï¼Œèƒ½ä¸èƒ½å®žçŽ°åŽŸåœ°äº¤æ¢å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„...ä»¥æ ·ä¾‹ä¸­çš„çŸ©é˜µ $$\begin{bmatrix}5 &amp; 1 &amp; 9 &amp; 11 \\2 &amp; 4 &amp; 8 &amp; 10 \\13 &amp; 3 &amp; 6 &amp; 7 \\15 &amp; 14 &amp; 12 &amp; 16 \\\end{bmatrix}$$ æŒ‰ç…§æ°´å¹³è½´ç¿»è½¬ï¼Œå¾—åˆ° $$\begin{bmatrix}15 &amp; 14 &amp; 12 &amp; 16 \\13 &amp; 3 &amp; 6 &amp; 7 \\2 &amp; 4 &amp; 8 &amp; 10 \\5 &amp; 1 &amp; 9 &amp; 11 \\\end{bmatrix}$$ å†æŒ‰ä¸»å¯¹è§’çº¿ç¿»è½¬ï¼ˆä¹Ÿå°±æ˜¯æ±‚çŸ©é˜µçš„è½¬ç½®çŸ©é˜µï¼‰ï¼Œå¾—åˆ° $$\begin{bmatrix}15 &amp; 13 &amp; 2 &amp; 5 \\14 &amp; 3 &amp; 4 &amp; 1 \\12 &amp; 6 &amp; 8 &amp; 9 \\16 &amp; 7 &amp; 10 &amp; 11 \\\end{bmatrix}$$ è¿™å°±æ˜¯éœ€è¦çš„ç»“æžœ...ðŸ˜‚æ°´å¹³è½´ç¿»è½¬åªéœ€è¦æžšä¸¾ä¸€åŠçš„çŸ©é˜µå…ƒç´ å³å¯ï¼š12345for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125;&#125; åŒæ ·ï¼Œä¸»å¯¹è§’çº¿ç¿»è½¬ä¹Ÿåªéœ€è¦æžšä¸¾ä¸€åŠçš„çŸ©é˜µå…ƒç´ ï¼š12345for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125;&#125; è”ç«‹èµ·æ¥ï¼Œå°±å¯ä»¥å¾—åˆ°å®Œæ•´çš„é€šè¿‡ä»£ç äº†ï¼š12345678910111213141516class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125;&#125;; ä¸ºä»€ä¹ˆå¯ä»¥è¿™æ ·åšå‘¢ï¼Ÿæ°´å¹³è½´ç¿»è½¬æ—¶åæ ‡çš„å˜æ¢è§„å¾‹æ˜¯ï¼š$matrix[r][c] &lt;=&gt; matrix[n - 1 - r][c]$ã€‚ä¸»å¯¹è§’çº¿ç¿»è½¬æ—¶åæ ‡çš„å˜æ¢è§„å¾‹æ˜¯ï¼š$matrix[r][c] &lt;=&gt; matrix[c][r] = matrix[c][n - 1 - r]$ã€‚è¿™ä¸Žå‰é¢çš„è§„å¾‹å®žé™…ä¸Šæ˜¯ä¸€è‡´çš„...åªä¸è¿‡æ°´å¹³è½´ç¿»è½¬æ—¶ï¼Œåªæœ‰ä¸»å¯¹è§’çº¿ä¸Šçš„å…ƒç´ è¢«äº¤æ¢åˆ°äº†æœ€ç»ˆä½ç½®ã€‚å†å›žå¤´æƒ³æƒ³ï¼Œå¦‚æžœä¸€å¼€å§‹å°†çŸ©é˜µè½¬ç½®ï¼Œç„¶åŽå†å°†çŸ©é˜µç«–ç›´ç¿»è½¬ä¸ä¹Ÿå¯ä»¥å¾—åˆ°æœ€ç»ˆç»“æžœå—ï¼Ÿå“ˆå“ˆå¦å¤–ï¼Œå†è¯´ç‚¹é¢˜å¤–è¯ã€‚æŒ‰ç…§çº¿æ€§ä»£æ•°çš„ç†è®ºï¼Œåƒè¿™æ ·çš„çŸ©é˜µå˜æ¢åº”è¯¥å¯ä»¥é€šè¿‡ä¹˜ä»¥ä¸€ä¸ªç‰¹æ®Šçš„å•ä½çŸ©é˜µå¾—åˆ°...ä¹Ÿè®¸è¿˜æœ‰æ›´ç®€å•çš„æ–¹æ³•å§... 1886. Determine Whether Matrix Can Be Obtained By RotationAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹åƒä¸Šé¢é‚£ä¸ªé¢˜çš„å‡çº§ç‰ˆï¼Œä¾æ¬¡é¡ºæ—¶é’ˆè½¬æ¢ 90Â°ï¼Œå¦‚æžœä¸Žç»™å®šçŸ©é˜µç›¸åŒï¼Œå°±è¿”å›ž trueï¼Œå¦åˆ™è¿”å›ž falseã€‚æœ‰äº†å‰é¢çš„æ€è€ƒï¼Œè¿™ä¸ªé¢˜ç®€ç›´ä¸è¦å¤ªç®€å•å“ˆã€‚ä¸€ä¸ªçŸ©é˜µæœ€å¤šæŒ‰ 90Â° æ—‹è½¬ 4 æ¬¡å°±å›žåˆ°å®ƒæœ€åˆçš„æ ·å­äº†ï¼Œæ‰€ä»¥ï¼Œè¿™ä¸ªé¢˜æœ€å¤šæ—‹è½¬ 3 æ¬¡å°±å¯ä»¥å¾—åˆ°ç»“æžœäº†ã€‚ Codeç›´æŽ¥å¤åˆ¶ç²˜è´´äº†ðŸ˜...1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123;public: bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123; if(mat == target) return true; int n = mat.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(mat[i][j], mat[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(mat[i][j], mat[j][i]); &#125; &#125; if(mat == target) return true; return false; &#125;&#125;; æŠŠä¸Šé¢å†™çš„å‡½æ•°æŠ„è¿‡æ¥ï¼Œå°è£…ä¸€ä¸‹ï¼š123456789101112131415161718192021222324class Solution &#123;public: void rotate(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int n = matrix.size(); for(int i = 0; i &lt; n / 2; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[n - 1 - i][j]); &#125; &#125; for(int i = 0; i &lt; n; i++) &#123; for(int j = i; j &lt; n; j++) &#123; swap(matrix[i][j], matrix[j][i]); &#125; &#125; &#125; bool findRotation(vector&lt;vector&lt;int&gt;&gt;&amp; mat, vector&lt;vector&lt;int&gt;&gt;&amp; target) &#123; if(mat == target) return true; for(int i = 0; i &lt; 3; i++) &#123; rotate(mat); if(mat == target) return true; &#125; return false; &#125;&#125;; å—¯ï¼Œçœ‹èµ·æ¥èˆ’æœå¤šäº†... Summaryä¸çŸ¥é“è¿™ç§çŸ©é˜µå˜æ¢çš„å®žé™…åº”ç”¨åœºæ™¯æ˜¯ä»€ä¹ˆ...çªç„¶æœ‰ç‚¹å¥½å¥‡äº†...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day6]]></title>
    <url>%2F2022%2F05%2F05%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day6%2F</url>
    <content type="text"><![CDATA[å†²å•Š~ 739. Daily TemperaturesAnalysisæ‰¾å‡ºæ¯ä¸€å¤©ä¹‹åŽå†è¿‡å‡ å¤©çš„æ¸©åº¦ä¼šæ¯”è¿™ä¸€å¤©é«˜ï¼ˆæˆ‘åœ¨å†™å•¥å‘¢ðŸ˜‚ï¼‰ï¼Œæ„Ÿè§‰æœ‰ç‚¹ dp çš„å‘³é“ï¼Ÿ Codemethod 1å…ˆæš´åŠ›å†è¯´ï¼š12345678910111213class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int index = i + 1; while(index &lt; size &amp;&amp; temperatures[index] &lt;= temperatures[i]) index++; if(index != size) ret[i] = index - i; &#125; return ret; &#125;&#125;; å¥½å§ï¼Œæžœä¸å…¶ç„¶çš„è¶…æ—¶äº†ã€‚è¿™ä¸ªæš´åŠ›åšæ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œå¾ˆéš¾ä¸è¶…æ—¶ã€‚æ¢ä¸ªè§’åº¦æƒ³ä¸€ä¸‹ï¼Œå¦‚æžœä»ŽåŽå¾€å‰éåŽ†æ•°ç»„ä¼šæ€Žä¹ˆæ ·ï¼Ÿè¿™æ ·æœ€åŽä¸€ä¸ªæ•°å­—çš„è¿”å›žå€¼ä¸€å®šæ˜¯ 0ï¼Œç„¶åŽï¼Œç»§ç»­å‘å‰éåŽ†ï¼Œå¦‚æžœé‡åˆ°ä¸Žä¹‹å‰éåŽ†è¿‡çš„æ•°å­—å°çš„æ•°å­—ï¼Œé‚£è¦æ€Žä¹ˆè®¡ç®—å½“å‰æ•°å­—çš„è¿”å›žå€¼å‘¢ï¼Ÿæ‰€ä»¥éœ€è¦æå‰å°†å‡ºçŽ°è¿‡çš„æ•°å­—çš„ä¸‹æ ‡è®°å½•ä¸‹æ¥ã€‚ç”±äºŽæ˜¯ä»ŽåŽå¾€å‰éåŽ†ï¼Œå³ä½¿æ˜¯å­˜åœ¨é‡å¤å…ƒç´ ï¼Œä¹Ÿå¯ä»¥ä¿è¯è®°å½•çš„ä¸‹æ ‡æ˜¯å½“å‰æ•°å­—åŽè·ç¦»å…¶æœ€è¿‘çš„é‚£ä¸ªæ•°å­—ï¼Œä¹Ÿå°±å¯ä»¥æ»¡è¶³æ˜¯ç¬¬ä¸€ä¸ªæ¯”å½“å‰æ•°å­—å¤§çš„æ•°å­—çš„æ¡ä»¶äº†ã€‚1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; int size = temperatures.size(); vector&lt;int&gt; ret(size), indices(101, INT_MAX); for(int i = size - 1; i &gt;= 0; i--) &#123; int warmerindex = INT_MAX; for(int tem = temperatures[i] + 1; tem &lt;= 100; tem++) &#123; warmerindex = min(warmerindex, indices[tem]); &#125; if(warmerindex == INT_MAX) ret[i] = 0; else ret[i] = warmerindex - i; indices[temperatures[i]] = i; &#125; return ret; &#125;&#125;; è¿™ä¸ªæ˜¯å¯ä»¥é€šè¿‡çš„ï¼Œå¯¹åº”çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n \times D)$ï¼Œå…¶ä¸­ $n$ æ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ï¼Œ$D$ æ˜¯ 100 ä¸Žæ•°ç»„å…ƒç´ çš„å·®ï¼Œæœ€åæƒ…å†µä¸‹æ˜¯ 70ã€‚å¯¹åº”çš„ç©ºé—´å¤æ‚åº¦æ˜¯ $O(c)$, å…¶ä¸­ c æ˜¯ $100$ã€‚ method 2å®žé™…ä¸Šè¿™ä¸ªé¢˜å¯ä»¥ç”¨å•è°ƒæ ˆçš„æ€æƒ³æ¥å¤„ç†ï¼Œä¸è¿‡åœ¨è§£å†³è¿™é“é¢˜ä¹‹å‰å¯ä»¥ç”¨å¦å¤–ä¸€é“é¢˜ç†Ÿæ‚‰ä¸€ä¸‹å•è°ƒæ ˆçš„æ€æƒ³ï¼š496. Next Greater Element Iã€‚123456789101112131415class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; stack&lt;int&gt; st; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = size - 1; i &gt;= 0; i--) &#123; int tmp = temperatures[i]; while(!st.empty() &amp;&amp; temperatures[st.top()] &lt;= tmp) st.pop(); ret[i] = st.empty() ? 0 : st.top() - i; st.push(i); &#125; return ret; &#125;&#125;; æ„Ÿè§‰ä»ŽåŽå¾€å‰éåŽ†æ¯”è¾ƒå¥½ç†è§£ï¼Œå§‹ç»ˆè®©æ ˆé¡¶ä¿å­˜æ¯”å½“å‰å…ƒç´ å¤§ä¸”è·ç¦»æœ€è¿‘çš„å…ƒç´ çš„ä¸‹æ ‡ã€‚å¦‚æžœæ ˆç©ºï¼Œè¯´æ˜Žå½“å‰å…ƒç´ åŽæ²¡æœ‰æ›´å¤§çš„å…ƒç´ äº†ï¼Œå°±è¿”å›ž 0ï¼›å¦‚æžœæ ˆä¸ç©ºï¼Œå°±åˆ¤æ–­æ ˆé¡¶å…ƒç´ æ˜¯ä¸æ˜¯æ¯”å½“å‰å…ƒç´ å¤§ï¼Œæ»¡è¶³æ¡ä»¶ï¼ŒäºŒè€…ä¸‹æ ‡ä¹‹å·®å°±æ˜¯è¿”å›žå€¼ï¼Œä¸æ»¡è¶³å°±å‡ºæ ˆï¼Œåˆ¤æ–­æ ˆå†…å…¶ä»–å…ƒç´ æ˜¯å¦æ»¡è¶³ã€‚å¦‚æžœè¦ä»Žå‰å¾€åŽåšä¹Ÿä¸æ˜¯ä¸è¡Œï¼Œä½†æ˜¯ç”±äºŽæœ€å¤§å€¼æ˜¯åŽé¢æ‰å‡ºçŽ°çš„ï¼Œæ‰€ä»¥åªèƒ½åœ¨å‡ºçŽ°æ›´å¤§å€¼åŽï¼Œå†æ›´æ–°å‰é¢çš„å€¼éœ€è¦è¿”å›žçš„ä¸‹æ ‡ï¼š123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; temperatures) &#123; stack&lt;int&gt; st; int size = temperatures.size(); vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int tem = temperatures[i]; while(!st.empty() &amp;&amp; tem &gt; temperatures[st.top()]) &#123; int previousindex = st.top(); ret[previousindex] = i - previousindex; st.pop(); &#125; st.push(i); &#125; return ret; &#125;&#125;; ä¸¤ä¸ªéåŽ†è¿‡ç¨‹æ¯”è¾ƒä¸€ä¸‹ï¼Œå¯ä»¥å‘çŽ°ï¼Œä»ŽåŽå¾€å‰éåŽ†ï¼Œæ ˆä¸­ä¸‹æ ‡ä»£è¡¨çš„å…ƒç´ å€¼ä»Žæ ˆé¡¶åˆ°æ ˆåº•æ˜¯é€’å¢žçš„ï¼Œè€Œä»Žå‰å¾€åŽéåŽ†ï¼Œå…ƒç´ å€¼ä»Žæ ˆé¡¶åˆ°æ ˆåº•æ˜¯é€’å‡çš„ã€‚ 58. Length of Last WordAnalysisæ‰¾å‡ºå­—ç¬¦ä¸²æœ€åŽä¸€ä¸ªå•è¯çš„é•¿åº¦ï¼Œå­—ç¬¦ä¸²çš„å‰é¢å’ŒåŽé¢éƒ½å¯èƒ½å­˜åœ¨å¤šä¸ªç©ºæ ¼ã€‚ Codeå—¯ï¼Œå¥½åƒæ‰¾åˆ°æœ€åŽä¸€ä¸ªå­—ç¬¦çš„ä¸‹æ ‡ä¸Žæœ€åŽä¸€ä¸ªç©ºæ ¼çš„ä¸‹æ ‡ï¼Œåšå·®å°±è¡Œäº†ï¼Ÿ12345678910111213141516class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = s.length(); int lastspaceindex = INT_MAX, lastcharindex = INT_MAX; for(int i = len - 1; i &gt;= 0; i--) &#123; if(isalpha(s[i]) &amp;&amp; lastcharindex == INT_MAX) lastcharindex = i; if(s[i] == ' ' &amp;&amp; lastcharindex != INT_MAX) &#123; lastspaceindex = i; break; &#125; &#125; if(lastspaceindex == INT_MAX) return lastcharindex + 1; else return lastcharindex - lastspaceindex; &#125;&#125;; æ„Ÿè§‰è¿™ä¸ªæ€è·¯ä¸æ˜¯å¾ˆæ¸…æ™°...æŠŠæŸ¥æ‰¾æœ€åŽä¸€ä¸ªå•è¯çš„ä¸‹æ ‡ä¸ŽæŸ¥æ‰¾æœ€åŽä¸€ä¸ªå•è¯å‰ç©ºæ ¼çš„ä¸‹æ ‡åˆ†å¼€å†™å§ï¼š1234567891011121314151617181920class Solution &#123;public: int lengthOfLastWord(string s) &#123; int len = s.length(); int spaceindex, lastcharindex = len - 1; for(int i = len - 1; i &gt;= 0; i--) &#123; if(isalpha(s[i])) &#123; lastcharindex = i; break; &#125; &#125; spaceindex = lastcharindex - 1; while(spaceindex &gt;= 0) &#123; if(s[spaceindex] == ' ') break; spaceindex--; &#125; if(spaceindex == -1) return lastcharindex + 1; else return lastcharindex - spaceindex; &#125;&#125;; åŒæ ·æ˜¯ä¸€ä¸ªå¾ªçŽ¯ï¼Œä¸ºä»€ä¹ˆè¿™ä¸ªæäº¤ä¸ŠåŽ»æ—¶é—´ä¼šæ¯”ä¸Šä¸€ä¸ªå¿«ä¸å°‘ï¼Ÿæ˜¯å› ä¸ºä¸Šä¸€æ®µä»£ç  if å†™å¤ªå¤šäº†å—ï¼Ÿå†™åˆ°è¿™é‡Œï¼Œå¯ä»¥å‘çŽ°ï¼Œå…¶å®žä¸åšå·®ä¹Ÿè¡Œï¼Œå¼„ä¸€ä¸ªè®¡æ•°å˜é‡ç»Ÿè®¡ä¸€ä¸‹å°±è¡Œäº†ã€‚å·ä¸‹æ‡’ï¼Œä¸å†™äº†å§... Summaryå•è°ƒæ ˆçš„æ€æƒ³æ„Ÿè§‰å¾ˆä¸å¤šï¼Œç”¨æ¥æ±‚ä¸‹ä¸€ä¸ªæœ€å¤§æˆ–æœ€å°å¥½åƒæŒºå¥½ç”¨çš„ï¼Ÿçªç„¶æƒ³èµ·æ¥ä¸Šä¸ªæœˆåšçš„ PAT çœŸé¢˜äº†...ç­‰ä¸‹åŽ»å†™ä¸€ä¸‹ã€‚è¯è¯´å›žæ¥ï¼Œå¯¹å•è°ƒæ ˆçš„æŽŒæ¡è¿˜ä¸æ˜¯å¾ˆç‰¢å›ºï¼Œè¿˜å¾—å¤šæ¥ç‚¹é¢˜ç›®å·©å›ºä¸€ä¸‹ã€‚åšä¸Šé¢é‚£ä¸ªé¢˜ç›®çš„æ—¶å€™ï¼Œè¿˜æƒ³åˆ°äº†ä¸Šå‘¨å‘¨èµ›æŽ’åº + äºŒåˆ†çš„æ€è·¯äº†ï¼Œç»“æžœå†™å®Œï¼Œå‘çŽ°æœ‰é‡å¤å…ƒç´ å°±ä¸è¡Œäº†ðŸ˜‚ï¼Œæ–¹æ³•æ²¡é€‰å¯¹ï¼Œå°±å¾ˆéš¾å—äº†ã€‚ä¸è¿‡ï¼Œä¹Ÿè¯´æ˜Žè‡ªå·±å¯¹æŽ’åº + äºŒåˆ†çš„æ€è·¯ç†è§£çš„ä¸å¤Ÿæ·±åˆ»å§ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day5]]></title>
    <url>%2F2022%2F05%2F04%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day5%2F</url>
    <content type="text"><![CDATA[åœ¨å¤–é¢å¾…äº†ä¸€å¤©...è¿˜å¥½æ˜¯ä¸¤ä¸ªç®€å•é¢˜å“ˆ~ 67. Add BinaryAnalysisäºŒè¿›åˆ¶åŠ æ³•ï¼Œåº”è¯¥ä¸éš¾å“ˆã€‚ Codeå› ä¸ºé¢˜ç›®ç»™å®šçš„ a å’Œ b çš„é•¿åº¦è§„æ¨¡åœ¨ $[1, 10^4]$ï¼Œæ‰€ä»¥ä¸èƒ½è½¬æ¢æˆåè¿›åˆ¶æ±‚å’ŒåŽå†è½¬æ¢ä¸ºäºŒè¿›åˆ¶ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution &#123;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int p1 = 0, p2 = 0, carry = 0; while(p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123; int tmp = a[p1++] + b[p2++] + carry - 2 * '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else if(tmp == 2) &#123; ans.push_back('0'); carry = 1; &#125; else &#123; ans.push_back('1'); carry = 1; &#125; &#125; while(p1 &lt; len1) &#123; int tmp = carry + a[p1++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; while(p2 &lt; len2) &#123; int tmp = carry + b[p2++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; å…ˆé€†ç½®å­—ç¬¦ä¸²ä¼šæ–¹ä¾¿è®¡ç®—ï¼Œå› ä¸ºä¸çŸ¥é“é‚£ä¸ªæ•°æ›´å¤§ï¼Œæ‰€ä»¥å¹²è„†éƒ½å†™ä¸€ä¸ªå¾ªçŽ¯ç®—äº†ã€‚å—¯ï¼ŒçŽ°åœ¨æŠŠé‡å¤çš„éƒ¨åˆ†å°è£…ä¸€ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; void addremains(string &amp;s, int &amp;pos, string &amp;ans, int &amp;carry) &#123; while(pos &lt; s.length()) &#123; int tmp = carry + s[pos++] - '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else &#123; ans.push_back('0'); carry = 1; &#125; &#125; &#125;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int p1 = 0, p2 = 0, carry = 0; while(p1 &lt; len1 &amp;&amp; p2 &lt; len2) &#123; int tmp = a[p1++] + b[p2++] + carry - 2 * '0'; if(tmp == 0) &#123; ans.push_back('0'); carry = 0; &#125; else if(tmp == 1) &#123; ans.push_back('1'); carry = 0; &#125; else if(tmp == 2) &#123; ans.push_back('0'); carry = 1; &#125; else &#123; ans.push_back('1'); carry = 1; &#125; &#125; if(p1 != len1) addremains(a, p1, ans, carry); if(p2 != len2) addremains(b, p2, ans, carry); if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; æ„Ÿè§‰è¿™æ ·å†™ä¸å¤ªç¾Žè§‚å“ˆã€‚å®žé™…ä¸Šï¼Œä¹Ÿä¸æ˜¯ä¸€å®šéžè¦å†™åˆ°å¤–é¢åŽ»ï¼Œcarry å¯¹åº”çš„ä¸åŒæƒ…å†µä¹Ÿå¯ä»¥é€šè¿‡å–ä½™è¿ç®—å’Œé™¤è¿ç®—æ±‡æ€»åˆ°ä¸€èµ·ã€‚12345678910111213141516171819class Solution &#123;public: string addBinary(string a, string b) &#123; reverse(a.begin(), a.end()); reverse(b.begin(), b.end()); string ans; int len1 = a.length(), len2 = b.length(); int maxlen = max(len1, len2), carry = 0; for(int i = 0; i &lt; maxlen; i++) &#123; carry += i &lt; len1 ? (a[i] == '1') : 0; carry += i &lt; len2 ? (b[i] == '1') : 0; ans.push_back((carry % 2) ? '1' : '0'); carry /= 2; &#125; if(carry) ans.push_back('1'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; å¦‚æžœé¢˜ç›®é™åˆ¶äº†å››åˆ™è¿ç®—ï¼Œé‚£è¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨ä½è¿ç®—æ¥è§£å†³ï¼Œä¹‹åŽè¡¥ä¸€ä¸‹å§ã€‚ 989. Add to Array-Form of IntegerAnalysisä¸€ä¸ªä»¥æ•°ç»„å½¢å¼å‚¨å­˜çš„æ•´æ•°å’Œä¸€ä¸ª int åž‹æ•´æ•°ï¼Œè®¡ç®—äºŒè€…ä¹‹å’Œã€‚ Codeå› ä¸º k çš„å–å€¼èŒƒå›´æ˜¯ $[1, 10^4]$ï¼Œæ‰€ä»¥ k æœ€å¤šä¹Ÿå°±æ˜¯ 5 ä½ï¼Œé‚£ä¹ˆå®žé™…ä¸Šåªç”¨è®¡ç®—æ•°ç»„çš„æœ€åŽå‡ ä½ä¸Ž k çš„å’Œï¼Œç„¶åŽåœ¨åŠ å›žæ•°ç»„ä¸ŠåŽ»å°±å¯ä»¥äº†ã€‚ä½†æ˜¯åˆå¯èƒ½å­˜åœ¨ num æ¯” k å°çš„æƒ…å†µï¼Œè¿™æ ·ç»¼åˆè€ƒè™‘ä¸‹æ¥ï¼Œä¸å¦‚ç›´æŽ¥ä¸¤ä¸ªæ•°ç»„åšå¤§æ•°åŠ æ³•å¾—äº†ðŸ˜“ã€‚æŒ‰ç…§ä¸Šä¸€ä¸ªé¢˜çš„æ€è·¯æ¥å®Œæˆå°±å¯ä»¥äº†ï¼š12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; vector&lt;int&gt; knum, ans; while(k) &#123; knum.push_back(k % 10); k /= 10; &#125; reverse(num.begin(), num.end()); int carry = 0, size1 = num.size(), size2 = knum.size(); int maxsize = max(size1, size2); for(int i = 0; i &lt; maxsize; i++) &#123; carry += i &lt; size1 ? num[i] : 0; carry += i &lt; size2 ? knum[i] : 0; ans.push_back(carry % 10); carry /= 10; &#125; if(carry) ans.push_back(carry); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; ä½†æ˜¯é’ˆå¯¹è¿™ä¸ªé—®é¢˜è€Œè¨€ï¼ŒçœŸçš„éœ€è¦ç”¨ä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜ k å—ï¼Ÿåº”è¯¥æ˜¯ä¸éœ€è¦çš„å§ã€‚12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; vector&lt;int&gt; ans; int size = num.size(); for(int i = size - 1; i &gt;= 0; i--) &#123; int sum = num[i] + k % 10; k /= 10; if(sum &gt;= 10) &#123; k++; sum -= 10; &#125; ans.push_back(sum); &#125; while(k) &#123; ans.push_back(k % 10); k /= 10; &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; çœ‹äº†ä¸‹å®˜æ–¹çš„é¢˜è§£ï¼Œè¿™ä¸ªé¢˜å¥½åƒè¿˜æœ‰ä¸€ç§æ€è·¯ï¼Œé‚£å°±æ˜¯ç›´æŽ¥æŠŠ k åŠ åˆ°æœ€åŽä¸€ä½ï¼Œè®©ä¸ªä½æ•°å­—ä¸ºè¿™ä¸€ä½çš„ç»“æžœï¼Œå‰©ä¸‹çš„æ•°å­—åœ¨åŠ ä¸Šå‰ä¸€ä½ï¼š12345678910111213class Solution &#123;public: vector&lt;int&gt; addToArrayForm(vector&lt;int&gt;&amp; num, int k) &#123; int size = num.size(); vector&lt;int&gt; ans; for(int i = size - 1; i &gt;= 0 || k &gt; 0; i--, k /= 10) &#123; if(i &gt;= 0) k += num[i]; ans.push_back(k % 10); &#125; reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; è¿™æ®µä»£ç å¥½åƒçœ‹èµ·æ¥æ›´ç²¾ç®€ä¸€ç‚¹ã€‚ Summaryè¿™ä¸¤å¤©åšçš„é¢˜æ€Žä¹ˆéƒ½æ˜¯è¿™ç§å¤§æ•°å››åˆ™è¿ç®—çš„é¢˜ç›®ï¼Ÿæ„Ÿè§‰æ²¡ä»€ä¹ˆè¶£å‘³æ€§...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day4]]></title>
    <url>%2F2022%2F05%2F03%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day4%2F</url>
    <content type="text"><![CDATA[åˆé’“äº†ä¸€å¤©é±¼...å¿˜è®°åšé˜²æ™’äº†ï¼Œèƒ³è†Šè‚˜å­éƒ½æ™’çº¢äº†... 1367. Linked List in Binary TreeAnalysisåˆ¤æ–­é“¾è¡¨åºåˆ—æ˜¯å¦å­˜åœ¨äºŽæ ‘çš„è·¯å¾„ä¸­ã€‚ Codeå…ˆç”¨å®˜æ–¹é¢˜è§£çš„æ€è·¯æ°´è¿‡åŽ»äº†...12345678910111213class Solution &#123; bool dfs(TreeNode *rt, ListNode *head) &#123; if(head == nullptr) return true; if(rt == nullptr) return false; if(rt-&gt;val != head-&gt;val) return false; return dfs(rt-&gt;left, head-&gt;next) || dfs(rt-&gt;right, head-&gt;next); &#125;public: bool isSubPath(ListNode* head, TreeNode* root) &#123; if(root == nullptr) return false; return dfs(root, head) || isSubPath(head, root-&gt;left) || isSubPath(head, root-&gt;right); &#125;&#125;; emï¼ŒçŽ°åœ¨å†æ¥æŠŠè¿™ä¸ªé¢˜åšä¸€ä¸‹ã€‚ç¬¬ä¸€çœ¼çœ‹åˆ°è¿™ä¸ªé¢˜ç›®çš„æ—¶å€™ï¼Œæƒ³åˆ°çš„åšæ³•å…¶å®žæ˜¯å…ˆæ±‚å‡ºæ‰€æœ‰å¶ç»“ç‚¹çš„è·¯å¾„ï¼Œç„¶åŽå†åˆ¤æ–­é“¾è¡¨åºåˆ—æ˜¯ä¸æ˜¯è·¯å¾„çš„å­ä¸²å³å¯ã€‚å¯æƒœï¼Œå¿˜è®°è·¯å¾„æ€Žä¹ˆæ±‚çš„äº†ã€‚æ‰€ä»¥ï¼Œåˆé‡æ–°åšäº†ä¸€ä¸‹å¦å¤–ä¸€ä¸ªé¢˜ï¼š257. Binary Tree Pathsã€‚åšå®Œè¿™ä¸ªé¢˜ä¹‹åŽï¼Œå°±å¯ä»¥å†æŒ‰ç…§è¿™ä¸ªæ€è·¯æ¥åšäº†ã€‚PSï¼šå› ä¸ºè·¯å¾„å¯ä»¥é€šè¿‡ bfs å’Œ dfs æ¥æ±‚ï¼Œæ‰€ä»¥ä¹Ÿå†™å‡ºç±»ä¼¼çš„æ€è·¯å§ã€‚dfsï¼š12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;string&gt; paths; void dfs(TreeNode *root, string path) &#123; if(!root) return; if(!root-&gt;left &amp;&amp; !root-&gt;right) &#123; path += to_string(root-&gt;val); paths.push_back(path); return; &#125; path += to_string(root-&gt;val); dfs(root-&gt;left, path); dfs(root-&gt;right, path); &#125; bool isSubPath(ListNode* head, TreeNode* root) &#123; string listseq; while(head) &#123; listseq += to_string(head-&gt;val); head = head-&gt;next; &#125; dfs(root, ""); int size = paths.size(); for(int i = 0; i &lt; size; i++) &#123; if(paths[i].find(listseq) != string::npos) return true; &#125; return false; &#125;&#125;; è™½ç„¶å¯ä»¥é€šè¿‡ï¼Œä½†æ˜¯æ—¶é—´æ¶ˆè€—è·Ÿå†…å­˜æ¶ˆè€—å®žåœ¨æ˜¯æƒ¨ä¸å¿ç¹äº†...bfsï¼š12345678910111213141516171819202122232425262728293031class Solution &#123;public: bool isSubPath(ListNode* head, TreeNode* root) &#123; string listseq; while(head) &#123; listseq += to_string(head-&gt;val); head = head-&gt;next; &#125; queue&lt;TreeNode*&gt; q; queue&lt;string&gt; path; q.push(root); path.push(to_string(root-&gt;val)); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); string tmp = path.front(); path.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) tmp += to_string(node-&gt;val); if(tmp.length() &gt;= listseq.length()) &#123; if(tmp.find(listseq) != string::npos) return true; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); path.push(tmp + to_string(node-&gt;left-&gt;val)); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); path.push(tmp + to_string(node-&gt;right-&gt;val)); &#125; &#125; return false; &#125;&#125;; ç”¨ bfs æ¶ˆè€—çš„æ—¶é—´ä¼šæ¯”ä¸Šé¢çš„ dfs è¦å°‘ï¼ˆå°½ç®¡ä¾ç„¶æƒ¨ä¸å¿ç¹ï¼‰ï¼Œå› ä¸ºä½¿ç”¨ bfs å¹¶ä¸æ˜¯ä¸€å®šè¦æ±‚å‡ºæ‰€æœ‰çš„è·¯å¾„ï¼Œåªéœ€è¦åˆ¤æ–­å½“å‰å¾—åˆ°çš„æ ‘çš„ç»“ç‚¹åºåˆ—æ˜¯å¦åŒ…å«äº†é“¾è¡¨åºåˆ—å³å¯ã€‚çŽ°åœ¨å›žå¤´æ¥æƒ³ä¸€ä¸‹å®˜æ–¹é¢˜è§£ä¸­ç”¨åˆ°çš„æ–¹æ³•ï¼Œå®žé™…æ˜¯å°±æ˜¯ dfs æ±‚ç»“ç‚¹è·¯å¾„çš„åŒæ—¶éåŽ†é“¾è¡¨ï¼Œè¿™æ ·æ—¶é—´æ¶ˆè€—æ‰ä¼šé™ä½Žã€‚ 43. Multiply StringsAnalysiså¤§æ•°ä¹˜æ³•ï¼ŒæŒ‰ç…§åˆ—ç®—å¼åšä¹˜æ³•çš„è§„åˆ™ï¼Œç®—å‡ºæ¯ä¸€ä½ä¸Žå¦å¤–ä¸€ä¸ªæ•°çš„ç§¯ï¼Œç„¶åŽä¾æ¬¡åŠ èµ·æ¥å°±å¯ä»¥å¾—åˆ°æœ€åŽç»“æžœäº†ã€‚åšè¿™ä¸ªé¢˜çš„åŒæ—¶ç®—æ˜¯æŠŠå¤§æ•°åŠ æ³•ä¹Ÿå¤ä¹ äº†ä¸€ä¸‹ã€‚ Codemethod 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; string ans = "0"; int len1 = num1.length(), len2 = num2.length(); for(int i = len2 - 1; i &gt;= 0; i--) &#123; string curr; int add = 0; for(int j = len2 - 1; j &gt; i; j--) &#123; curr.push_back(0); &#125; int y = num2.at(i) - '0'; for(int j = len1 - 1; j &gt;= 0; j--) &#123; int x = num1.at(j) - '0'; int product = x * y + add; curr.push_back(product % 10); add = product / 10; &#125; while(add != 0) &#123; curr.push_back(add % 10); add /= 10; &#125; reverse(curr.begin(), curr.end()); for(auto &amp;c: curr) &#123; c += '0'; &#125; ans = addStrings(ans, curr); &#125; return ans; &#125; string addStrings(string &amp;num1, string &amp;num2) &#123; int i = num1.size() - 1, j = num2.size() - 1, add = 0; string ans; while (i &gt;= 0 || j &gt;= 0 || add != 0) &#123; int x = i &gt;= 0 ? num1.at(i) - '0' : 0; int y = j &gt;= 0 ? num2.at(j) - '0' : 0; int result = x + y + add; ans.push_back(result % 10); add = result / 10; i--; j--; &#125; reverse(ans.begin(), ans.end()); for (auto &amp;c: ans) &#123; c += '0'; &#125; return ans; &#125;&#125;; å­—ç¬¦ä¸²ç›¸åŠ çš„å‡½æ•°æ˜¯è¿™ä¸ªé¢˜ï¼š415. Add Stringsã€‚åšå®Œ 415 ä¹‹åŽï¼ŒåˆæŠŠè¿™ä¸ªé¢˜é‡æ–°åšäº†ä¸€ä¸‹ï¼Œæ€è·¯ä¸Šæ²¡æœ‰ä»€ä¹ˆå˜åŒ–ï¼Œåªæ˜¯æŒ‰ç…§è‡ªå·±çš„é£Žæ ¼å†™äº†ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; string ans = "0"; int len1 = num1.length(), len2 = num2.length(); for(int i = len2 - 1; i &gt;= 0; i--) &#123; string tmp; int number = num2[i] - '0', carry = 0; for(int j = len2 - 1; j &gt; i; j--) &#123; tmp.push_back('0'); &#125; for(int j = len1 - 1; j &gt;= 0; j--) &#123; int res = number * (num1[j] - '0') + carry; if(res &gt; 9) &#123; carry = res / 10; res %= 10; &#125; else carry = 0; tmp.push_back(res + '0'); &#125; while(carry) &#123; tmp.push_back(carry % 10 + '0'); carry /= 10; &#125; reverse(tmp.begin(), tmp.end()); ans = addStrings(ans, tmp); &#125; return ans; &#125; string addStrings(string num1, string num2) &#123; string ans; int len1 = num1.length(), len2 = num2.length(), carry = 0; for(int i = len1 - 1, j = len2 - 1; i &gt;= 0 || j &gt;= 0; i--, j--) &#123; int sum = carry; sum += i &gt;= 0 ? num1[i] - '0' : 0; sum += j &gt;= 0 ? num2[j] - '0' : 0; if(sum &gt;= 10) &#123; carry = 1; sum -= 10; &#125; else carry = 0; ans.push_back(sum + '0'); &#125; if(carry) ans.push_back(carry + '0'); reverse(ans.begin(), ans.end()); return ans; &#125;&#125;; æŒ‰ç…§å‰é¢æåˆ°çš„ï¼Œè¿™ç§æ–¹æ³•æœ¬è´¨ä¸Šæ˜¯åœ¨åšåŠ æ³•ã€‚ method 2çœ‹äº†ä¸€ä¸‹å®˜æ–¹è§£æ³•çš„ç¬¬äºŒç§æ–¹æ³•ï¼Œæœ¬è´¨ä¸Šæ˜¯å…ˆè½¬æ¢ä¸ºæ•°ç»„ï¼Œç„¶åŽè¿›è¡Œä¹˜æ³•è¿ç®—ã€‚å…·ä½“çš„è®¡ç®—è¿‡ç¨‹å…¶å®žä¸ŽåšåŠ æ³•æ˜¯å·®ä¸å¤šçš„ï¼Œåªæ˜¯åœ¨å¤„ç†æ¯ä¸€ä½ä¸Žå¦ä¸€ä¸ªæ•°çš„æ¯ä¸€ä½ç›¸ä¹˜çš„ç»“æžœæ—¶ï¼Œåšäº†ä¸€ç‚¹ä¼˜åŒ–ã€‚æŒ‰ç…§ä¹˜æ³•çš„è®¡ç®—è§„åˆ™ï¼Œæ¯æ¬¡è¿ç®—å¾—åˆ°çš„ç»“æžœåœ¨æœ€åŽç»“æžœçš„å“ªä¸€ä½ï¼ˆåã€ç™¾ã€åƒä½ç­‰ï¼‰ä¸Šæ˜¯å¯ä»¥ç¡®å®šï¼Œæ‰€ä»¥ç›´æŽ¥ç´¯åŠ èµ·æ¥å°±å¥½äº†ï¼Œè€Œä¸”è¿™ä¸ªæ•°å­—è‚¯å®šæ˜¯ä¸å¤§äºŽ 100 çš„ï¼Œä½†å¯èƒ½æ˜¯ 2 ä½æ•°æˆ– 1 ä½æ•°ã€‚ç„¶åŽå†ç»Ÿä¸€å¤„ç†è¿›ä½ï¼Œå°±ä¼šæ¯”è¾ƒæ–¹ä¾¿ã€‚æœ€åŽå°±æ˜¯æŠŠæ¯ä¸€ä½æ•°å­—è½¬æ¢ä¸ºå­—ç¬¦äº†ã€‚è¿˜æœ‰ä¸€ç‚¹è¦æ³¨æ„çš„æ˜¯ï¼Œä¸€ä¸ª m ä½æ•°å’Œä¸€ä¸ª n ä½æ•°ï¼ŒäºŒè€…çš„ç»“æžœä¸€å®šæ˜¯ä¸€ä¸ª m + n - 1 ä½æ•°æˆ– m + n ä½æ•°ï¼Œä¹Ÿå°±æ˜¯è¯´ç»“æžœçš„é•¿åº¦æœ€å¤šä¸è¶…è¿‡ m + nã€‚12345678910111213141516171819202122232425class Solution &#123;public: string multiply(string num1, string num2) &#123; if(num1 == "0" || num2 == "0") return "0"; int len1 = num1.length(), len2 = num2.length(); vector&lt;int&gt; ansarr(len1 + len2); for(int i = len1 - 1; i &gt;= 0; i--) &#123; int x = num1[i] - '0'; for(int j = len2 - 1; j &gt;= 0; j--) &#123; int y = num2[j] - '0'; ansarr[i + j + 1] += x * y; &#125; &#125; for(int i = len1 + len2 - 1; i &gt; 0; i--) &#123; ansarr[i - 1] += ansarr[i] / 10; ansarr[i] %= 10; &#125; int index = ansarr[0] == 0 ? 1 : 0; string ans; while(index &lt; len1 + len2) &#123; ans.push_back(ansarr[index++] + '0'); &#125; return ans; &#125;&#125;; Summaryä»Šå¤©çš„ä¸¤ä¸ªé¢˜éƒ½æ˜¯æ°´è¿‡åŽ»çš„ðŸ˜‘ï¼Œæ˜Žå¤©è¿˜æœ‰ç‚¹äº‹ï¼Œæ—©ç‚¹ç¡äº†ï¼ŒåŽé¢å†è¡¥å§... 2022-5-5 23:50 è¡¥äº†ä¸‹ç¬¬äºŒä¸ªé¢˜ã€‚2022-5-6 21:04 è¡¥äº†ä¸‹ç¬¬ä¸€ä¸ªé¢˜ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day3]]></title>
    <url>%2F2022%2F05%2F02%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day3%2F</url>
    <content type="text"><![CDATA[é’“é±¼åŽ»äº†ï¼Œæ™šä¸Šæ‰å›žæ¥~ èµ¶ç´§ï¼Œèµ¶ç´§ã€‚ 150. Evaluate Reverse Polish NotationAnalyisemï¼Œé¦–å…ˆå¾—çŸ¥é“ï¼ŒReverse Polish Notation å°±æ˜¯åŽç¼€è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ˜¯ä¸ªåŽç¼€è¡¨è¾¾å¼æ±‚å€¼çš„é—®é¢˜ã€‚ä¸€èˆ¬è€Œè¨€ï¼ŒåŽç¼€è¡¨è¾¾å¼çš„é—®é¢˜æ˜¯ç”¨æ ˆæ¥æ±‚è§£çš„ã€‚ Codeç›´æŽ¥ç”¨æ ˆåšã€‚123456789101112131415161718192021222324252627282930313233class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; int size = tokens.size(); for(int i = 0; i &lt; size; i++) &#123; if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") &#123; int a, b, res; a = st.top(); st.pop(); b = st.top(); st.pop(); if(tokens[i] == "+") res = a + b; else if(tokens[i] == "-") res = b - a; else if(tokens[i] == "*") res = a * b; else if(tokens[i] == "/") res = b / a; st.push(res); &#125; else &#123; int tmp = 0, len = tokens[i].length(); int index = 0, flag = true; if(tokens[i][index] == '-') &#123; flag = false; index++; &#125; while(index &lt; len) &#123; tmp = tmp * 10 + tokens[i][index] - '0'; index++; &#125; if(!flag) tmp = -tmp; st.push(tmp); &#125; &#125; return st.top(); &#125;&#125;; éœ€è¦æ³¨æ„çš„åœ°æ–¹å°±æ˜¯å‡ï¼ˆé™¤ï¼‰æ³•æ—¶ï¼Œåˆ†æ¸…æ¥šå‡ï¼ˆé™¤ï¼‰æ•°ä¸Žè¢«å‡ï¼ˆé™¤ï¼‰æ•°ã€‚emï¼Œå€Ÿç”¨ä¸€ä¸‹åº“å‡½æ•°ï¼Œå†ç²¾ç®€ä¸€ä¸‹ï¼š123456789101112131415161718192021class Solution &#123;public: int evalRPN(vector&lt;string&gt;&amp; tokens) &#123; stack&lt;int&gt; st; int size = tokens.size(); for(int i = 0; i &lt; size; i++) &#123; if(isdigit(tokens[i][0]) || isdigit(tokens[i][1])) &#123; st.push(atoi(tokens[i].c_str())); &#125; else &#123; int a, b; a = st.top(); st.pop(); b = st.top(); st.pop(); if(tokens[i] == "+") st.push(a + b); else if(tokens[i] == "-") st.push(b - a); else if(tokens[i] == "*") st.push(a * b); else st.push(b / a); &#125; &#125; return st.top(); &#125;&#125;; ç”¨ isdigit å‡½æ•°åˆ¤æ–­æ˜¯å¦æ˜¯æ•°å­—æ—¶ï¼Œä¸è¦ç›´æŽ¥åˆ¤æ–­ç¬¬äºŒä¸ªå­—ç¬¦ï¼Œè¿™æ ·å¯èƒ½ä¼šè¶Šç•Œã€‚å› ä¸º Leetcode ç»™çš„ä¸€å®šæ˜¯åˆæ³•çš„åŽç¼€è¡¨è¾¾å¼ï¼Œæ‰€ä»¥å¯ä»¥å†™çš„è¿™ä¹ˆâ€œè‚†æ— å¿Œæƒ®â€ðŸ˜œã€‚ 66. Plus OneAnalysisä¸ç®—å¤§æ•°åŠ æ³•çš„å¤§æ•°åŠ æ³•é¢˜ã€‚ Code12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(), i = 0; reverse(digits.begin(), digits.end()); int carry = 1; while(i &lt; size) &#123; digits[i] += carry; if(digits[i] &gt;= 10) &#123; digits[i] -= 10; carry = 1; &#125; else carry = 0; i++; &#125; if(carry) digits.push_back(carry); reverse(digits.begin(), digits.end()); return digits; &#125;&#125;; å…ˆé€†ç½®çš„åŽŸå› æ˜¯ï¼Œå¦‚æžœå­˜åœ¨è¿›ä½ï¼Œå¯ä»¥ç›´æŽ¥åœ¨æ•°ç»„æœ«å°¾æ·»åŠ ï¼Œé‡æ–°é€†ç½®åŽå°±æ˜¯ç»“æžœäº†ã€‚å‰ªä¸€ä¸‹æžï¼š1234567891011121314151617181920212223242526class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(), i = 0; if(digits[size - 1] + 1 &lt; 10) &#123; digits[size - 1] += 1; return digits; &#125; reverse(digits.begin(), digits.end()); int carry = 1; while(i &lt; size) &#123; digits[i] += carry; if(digits[i] &gt;= 10) &#123; digits[i] -= 10; carry = 1; &#125; else &#123; carry = 0; break; &#125; i++; &#125; if(carry) digits.push_back(carry); reverse(digits.begin(), digits.end()); return digits; &#125;&#125;; çœ‹äº†åˆ«äººçš„åšæ³•ï¼Œè¿™ä¸ªé¢˜å¯ä»¥ä»Žåˆ¤æ–­æ¯ä¸€ä½è®¡ç®—åŽæ˜¯ä¸æ˜¯ 0 æ¥æ€è€ƒï¼Œå¦‚æžœæ˜¯ 0 é‚£ä¹ˆè¯´æ˜Žæœ‰è¿›ä½ï¼Œç»§ç»­è®¡ç®—ï¼Œå¦‚æžœæ²¡æœ‰ï¼Œå°±å¯ä»¥é€€å‡ºå¾ªçŽ¯äº†ï¼š123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; plusOne(vector&lt;int&gt;&amp; digits) &#123; int size = digits.size(); int i = size - 1; while(i &gt;= 0) &#123; digits[i]++; if(digits[i] == 10) digits[i] = 0; else break; i--; &#125; if(digits[0] == 0) &#123; digits.push_back(0); digits[0] = 1; &#125; return digits; &#125;&#125;; ä¸å¾—ä¸è¯´ï¼Œè¿™ä¸ªæ€è·¯ç¡®å®žæ¯”è¾ƒå¥½ã€‚ Summaryé’“é±¼å›žæ¥æœ‰ç‚¹ç´¯ï¼Œè¿˜å¥½é—®é¢˜è½»æ¾è§£å†³ï¼Œå¯ä»¥æ—©ç‚¹ç¡è§‰äº†ðŸ˜‚ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day2]]></title>
    <url>%2F2022%2F05%2F01%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day2%2F</url>
    <content type="text"><![CDATA[æˆ‘å‘çŽ°åœ¨è¿™ä¸ªç³»åˆ—ä¸ç»™æ¯æ—¥çš„ä¸»é¢˜äº†ã€‚ 110. Balanced Binary TreeAnalysisåˆ¤æ–­ä¸€é¢—æ ‘æ˜¯å¦æ˜¯å¹³è¡¡äºŒå‰æ ‘ã€‚ Codebfsç”¨ dfs å†™äº†åŠå¤©è¿˜æ˜¯ WA äº†ï¼Œæ”¹ç”¨ bfs äº†ðŸ˜¤ã€‚bfsï¼š12345678910111213141516171819class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(abs(getdepth(node-&gt;left) - getdepth(node-&gt;right)) &gt; 1) return false; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return true; &#125;&#125;; ç”¨ bfs æ„Ÿè§‰æ€è€ƒèµ·æ¥è½»æ¾å¾ˆå¤šå•Šã€‚ dfsemï¼Œç”¨ bfs é€šè¿‡ä¹‹åŽï¼Œæ€è·¯æ¸…æ™°äº†å¾ˆå¤šï¼ŒåˆæŠŠ dfs æ”¹äº†ä¸€ä¸‹é€šè¿‡äº†ã€‚dfsï¼š12345678910111213class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1; if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1; return abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; æ”¹ä¸€ä¸‹ï¼š1234567891011121314class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1; if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1; if(abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &gt; 1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; æ„Ÿè§‰æ€è·¯è¿˜æ˜¯ä¸å¤Ÿæ¸…æ™°ï¼Œå†æ”¹ä¸‹ï¼š1234567891011121314class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; if(!root-&gt;left) return getdepth(root-&gt;right) &lt;= 1 &amp;&amp; isBalanced(root-&gt;right); if(!root-&gt;right) return getdepth(root-&gt;left) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left); if(abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &gt; 1) return false; return isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; è¯•äº†ä¸‹ï¼Œä¹Ÿå¯ä»¥ä¸å†™è¿™ä¹ˆå¤š ifï¼ˆXDï¼‰ï¼š1234567891011class Solution &#123;public: int getdepth(TreeNode *root) &#123; if(!root) return 0; return max(getdepth(root-&gt;left), getdepth(root-&gt;right)) + 1; &#125; bool isBalanced(TreeNode* root) &#123; if(!root) return true; return abs(getdepth(root-&gt;left) - getdepth(root-&gt;right)) &lt;= 1 &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right); &#125;&#125;; ä»¥ä¸Šä»£ç çš„æ€è·¯å®žé™…ä¸Šæ˜¯åŸºäºŽå…ˆåºéåŽ†çš„æ€è·¯æ¥å®Œæˆçš„ï¼Œè¿™ç§æ€è·¯çš„ç¼ºç‚¹åœ¨äºŽæ¯é‡åˆ°ä¸€ä¸ªç»“ç‚¹å°±è¦è®¡ç®—å‡ºå…¶å­æ ‘çš„æ·±åº¦ï¼Œåœ¨è®¡ç®—æ·±åº¦çš„è¿‡ç¨‹ä¸­ï¼Œå°±ä¼šé‡å¤çš„éåŽ†é‚£äº›å¶å­ç»“ç‚¹ã€‚ä¸ºäº†é¿å…è¿™ä¸ªç¼ºç‚¹ï¼Œå¯ä»¥ä½¿ç”¨åŽåºéåŽ†çš„æ€è·¯æ¥å®Œæˆï¼š12345678910111213class Solution &#123;public: int height(TreeNode *root) &#123; if(!root) return 0; int leftheight = height(root-&gt;left); int rightheight = height(root-&gt;right); if(leftheight == -1 || rightheight == -1 || abs(leftheight - rightheight) &gt; 1) return -1; else return max(leftheight, rightheight) + 1; &#125; bool isBalanced(TreeNode* root) &#123; return height(root) &gt;= 0; &#125;&#125;; ä¸¤ç§æ€è€ƒæ–¹æ³•å…¶å®žå¤§åŒå°å¼‚ã€‚ 459. Repeated Substring PatternAnalysisåˆ¤æ–­ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯å¦å¯ä»¥ç”±å…¶å­ä¸²é‡å¤æž„æˆã€‚ Codemethod 1å…ˆæš´åŠ›åšä¸€ä¸‹ï¼š12345678910111213141516class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; int len = s.length(); for(int i = 1; i &lt;= len / 2; i++) &#123; if(len % i == 0) &#123; for(int j = 0; j &lt; len - i; j += i) &#123; string tmp = s.substr(j, i), t; while(t.length() &lt; len) t += tmp; if(t == s) return true; &#125; &#125; &#125; return false; &#125;&#125;; æžœç„¶è¶…æ—¶äº†ã€‚è§‚å¯Ÿä¸€ä¸‹ä¸Šé¢çš„æš´åŠ›è§£æ³•ï¼Œåœ¨ç¬¬äºŒå±‚å¾ªçŽ¯å†…ï¼ŒæŒ‰é—´éš”åŽ»é™¤å­ä¸²åŽï¼ŒåˆæŒ‰ç…§åŽŸå­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå°†å­ä¸²æž„é€ æˆç­‰é•¿çš„å­—ç¬¦ä¸²ï¼Œæœ€åŽå†åˆ¤æ–­æ˜¯å¦ä¸€è‡´ï¼Œä»Žè€Œæ¥åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼Œæ‰€ä»¥è¿™æ®µä»£ç çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$ã€‚å¯é—®é¢˜åœ¨äºŽï¼ŒçœŸçš„éœ€è¦é‡æ–°æž„é€ ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ¥è¿›è¡Œåˆ¤æ–­å—ï¼Ÿç­”æ¡ˆæ˜¯ä¸ç”¨ï¼Œå› ä¸ºæ¯æ¬¡æžšä¸¾çš„æ˜¯å­ä¸²çš„é•¿åº¦ï¼Œæ‰€ä»¥åªéœ€è¦æ ¹æ®è¿™ä¸ªé•¿åº¦æ¥åˆ¤æ–­ä¸åŒå­ä¸²çš„å­—ç¬¦æ˜¯å¦ä¸€è‡´å³å¯ã€‚12345678910111213141516class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; int len = s.length(); for(int i = 1; i &lt;= len / 2; i++) &#123; if(len % i == 0) &#123; for(int j = 0; j &lt; len - i; j += i) &#123; string tmp = s.substr(j, i), t; while(t.length() &lt; len) t += tmp; if(t == s) return true; &#125; &#125; &#125; return false; &#125;&#125;; è¿™æ®µä»£ç çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œæ˜¯å¯ä»¥é€šè¿‡çš„ã€‚ method 2æœ‰äº†ä¸Šé¢çš„æ€è€ƒï¼Œåº”è¯¥å°±è®¤è¯†åˆ°è¿™ä¸ªé¢˜æ˜¯ä¸ªå­—ç¬¦ä¸²åŒ¹é…çš„é—®é¢˜ï¼Œæ¯«æ— ç–‘é—®ï¼Œå¯ä»¥ç”¨ KMP æ¥å®Œæˆã€‚ä½† KMP æ—©å°±å¿˜äº†ï¼Œä»¥åŽå†çœ‹å§ã€‚ä»”ç»†è§‚å¯Ÿä¸€ä¸‹æ ·ä¾‹ï¼Œç¬¦åˆæ¡ä»¶çš„å­—ç¬¦ä¸²éƒ½æœ‰ä¸€ä¸ªç‰¹ç‚¹ï¼Œé‚£å°±æ˜¯å…¶æ»¡è¶³æ¡ä»¶çš„å­ä¸²ä¸€å®šæ˜¯å‡ºçŽ°å¤šæ¬¡çš„ï¼ˆå®žé™…ä¸Šæœ€å°‘å¾—å‡ºçŽ° 2 æ¬¡ï¼Œæ­¤æ—¶å­ä¸²çš„é•¿åº¦æ˜¯åŽŸä¸²çš„ä¸€åŠï¼‰ã€‚è¿™æ ·ï¼Œä¸å¦¨åŽŸä¸² s æ‹¼æŽ¥æˆ s+sï¼Œç„¶åŽç¬¬ä¸€ä¸ªå­—ç¬¦ä¸Žæœ€åŽä¸€ä¸ªå­—ç¬¦ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°å­—ç¬¦ä¸² newsï¼Œæ­¤æ—¶å†æ¥åˆ¤æ–­ s æ˜¯å¦æ˜¯ news çš„å­ä¸²ã€‚å¦‚æžœæ˜¯ï¼Œé‚£ä¹ˆå°±æ˜¯æ»¡è¶³æ¡ä»¶çš„ï¼Œåä¹‹åˆ™ä¸æ»¡è¶³æ¡ä»¶ã€‚123456class Solution &#123;public: bool repeatedSubstringPattern(string s) &#123; return (s + s).find(s, 1) != s.length(); &#125;&#125;; ç›´æŽ¥è°ƒç”¨åº“å‡½æ•°å°±å¯ä»¥å®Œæˆï¼Œä¹Ÿä¸ç”¨ä¸¥æ ¼æ„ä¹‰ä¸Šçš„åˆ é™¤ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸Žæœ€åŽä¸€ä¸ªå­—ç¬¦ã€‚ Summaryè™½ç„¶æ˜¯ 2 ä¸ªç®€å•é¢˜ï¼Œä¸è¿‡éƒ½å¾—åŠ¨åŠ¨è„‘å­æ‰èƒ½é€šè¿‡å•Šã€‚å¦‚æžœè¿˜æƒ³è¦æ›´ä¼˜çš„è§£æ³•ï¼Œè¿˜å¾—ä¸‹æ›´å¤šåŠŸå¤«...å¦å¤–ï¼Œè‡³äºŽ KMPï¼Œæ—¥åŽå†è¯´äº†...ðŸ˜‘]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode ç¬¬ 290 åœºå‘¨èµ›]]></title>
    <url>%2F2022%2F04%2F30%2FLeetcode-%E7%AC%AC-290-%E5%9C%BA%E5%91%A8%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[å¦‚é¢˜... è¿™æ˜¯ç¬¬ä¸€æ¬¡åœ¨ Leetcode ä¸Šå‚åŠ å‘¨èµ›ï¼Œç­¾äº†ä¸€ä¸‹åˆ°ðŸ˜†ã€‚ 2248. Intersection of Multiple ArraysAnalysisç¬¬ä¸€ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œæ‰¾å‡ºæ•°ç»„çš„äº¤é›†å³å¯ã€‚ Code12345678910111213141516class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int size = nums.size(); vector&lt;int&gt; cnt(1005), ret; for(int i = 0; i &lt; size; i++) &#123; for(int j = 0; j &lt; nums[i].size(); j++) &#123; cnt[nums[i][j]]++; &#125; &#125; for(int i = 0; i &lt; 1005; i++) &#123; if(cnt[i] == size) ret.push_back(i); &#125; return ret; &#125;&#125;; è¿™æ˜¯å½“æ—¶è‡ªå·±çš„åšæ³•ã€‚æ—¶é—´å¤æ‚åº¦ä¸Žç©ºé—´å¤æ‚åº¦éƒ½æ˜¯ $O(n)$ã€‚è¿™æ ·å†™å…¶å®žæœ‰ä¸ªç¼ºé™·ï¼Œé‚£å°±æ˜¯å—é™äºŽæ•°ç»„å…ƒç´ çš„å¤§å°ï¼Œå¦‚æžœå‡ºçŽ°è´Ÿæ•°æˆ–è€…å¤ªå¤§çš„æ•°ï¼Œå°±æœ‰é—®é¢˜äº†ã€‚æ‰€ä»¥ï¼Œåº”è¯¥ç”¨ map å–ä»£æ™®é€šçš„æ•°ç»„ã€‚å¦‚æžœä¸è¦æ±‚æœ‰åºï¼Œç”¨ unordered_map å¯èƒ½ä¼šæ›´å¥½ï¼š123456789101112131415class Solution &#123;public: vector&lt;int&gt; intersection(vector&lt;vector&lt;int&gt;&gt;&amp; nums) &#123; int size = nums.size(); map&lt;int, int&gt; cnt; for(auto v: nums) &#123; for(int x: v) cnt[x]++; &#125; vector&lt;int&gt; ret; for(auto [key, val]: cnt) &#123; if(val == size) ret.push_back(key); &#125; return ret; &#125;&#125;; è¿™ä¸ªé¢˜è¿˜å¯ä»¥ä½¿ç”¨ set æ¥æ¨¡æ‹Ÿï¼Œä¾æ¬¡æ±‚å½“å‰æ•°ç»„ä¸Ž set å†…å…ƒç´ çš„äº¤é›†ï¼Œå¾—åˆ°çš„äº¤é›†å†ä¸Žä¸‹ä¸€ä¸ªæ•°ç»„æ±‚äº¤é›†ï¼ˆéœ€è¦æœ‰ä¸€ä¸ª tmpset æ¥ä¿å­˜ç»“æžœï¼‰ï¼Œä¾æ¬¡æ±‚å®Œï¼Œæœ€åŽçš„ç»“æžœå°±æ˜¯æ‰€æœ‰æ•°ç»„çš„äº¤é›†ã€‚ä¸è¿‡è¿™ç§åšæ³•æ²¡æœ‰ç”¨ map çš„æ–¹æ³•ç›´æŽ¥æ˜Žäº†ï¼Œæ‰€ä»¥å°±ä¸å†™äº†ã€‚ 6043. Count Number of Rectangles Containing Each PointAnalysisè¿™æ˜¯ç¬¬ 3 ä¸ªé¢˜ï¼Œä¸è¿‡æ˜¯ç¬¬äºŒä¸ªæäº¤çš„é¢˜ã€‚é¢˜æ„ç†è§£èµ·æ¥è¿˜ç®—å®¹æ˜“ï¼Œå°±æ˜¯æ±‚å‡ºæ¯ä¸ªç‚¹è¢«å¤šå°‘ä¸ªçŸ©å½¢åŒ…æ‹¬ã€‚ Codeç†è§£é¢˜æ„åŽï¼Œå…¶å®žå¯ä»¥å‘çŽ°è¿™ä¸æ˜¯ä¸ªå¾ˆå¤æ‚çš„é¢˜ç›®ã€‚åˆ¤æ–­ä¸€ä¸ªç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…ï¼Œåªéœ€è¦è¿™ä¸ªç‚¹çš„æ¨ªçºµåæ ‡åˆ†åˆ«å°äºŽç­‰äºŽçŸ©å½¢å³ä¸Šç«¯ç‚¹ï¼ˆä¹Ÿå°±æ˜¯é¢˜ç›®ç»™çš„ç‚¹ï¼‰çš„æ¨ªçºµåæ ‡å³å¯ï¼Œé‚£ä¹ˆå¾ˆå®¹æ˜“çš„å°±ä¼šæƒ³åˆ°æš´åŠ›è§£æ³•ï¼š123456789101112131415class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; vector&lt;int&gt; ret; int pointnums = points.size(), rectanglenums = rectangles.size(); for(int i = 0; i &lt; pointnums; i++) &#123; int x = points[i][0], y = points[i][1], cnt = 0; for(int j = 0; j &lt; rectanglenums; j++) &#123; if(x &lt;= rectangles[j][0] &amp;&amp; y &lt;= rectangles[j][1]) cnt++; &#125; ret.push_back(cnt); &#125; return ret; &#125;&#125;; è¿™æ˜¯å½“æ—¶æäº¤çš„ä»£ç ï¼Œæžœç„¶ï¼Œæäº¤ä¸ŠåŽ»è¶…æ—¶äº†ã€‚æ²¡æƒ³åˆ°æ€Žä¹ˆä¼˜åŒ–æ—¶é—´å¤æ‚åº¦ï¼Œå°±æ”¾å¼ƒäº†...ðŸ˜‚ç®€å•åˆ†æžä¸€ä¸‹ï¼Œå¯ä»¥çŸ¥é“ä¸Šè¿°ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(m \times n)$ï¼Œå…¶ä¸­ $m$ æ˜¯ç‚¹ä¸ªæ•°ï¼Œ$n$ æ˜¯çŸ©å½¢çš„ä¸ªæ•°ï¼Œè¿™ä¸è¶…æ—¶å°±æ€ªäº†ã€‚åŽé¢çœ‹äº†åˆ«äººçš„è§£é¢˜æ€è·¯åŽï¼Œå‘çŽ°å…¶å®žè¿™ä¸ªï¼ˆå‡†ç¡®è¯´æ˜¯è¿™ç±»ï¼‰é—®é¢˜å…¶å®žå¯ä»¥åˆ†è§£æˆ 2 ä¸ªå­é—®é¢˜ï¼š åˆ¤æ–­å½“å‰ç‚¹çš„æ¨ªåæ ‡æ˜¯ä¸æ˜¯éƒ½å°äºŽç­‰äºŽæ‰€æœ‰çŸ©å½¢çš„æ¨ªåæ ‡ã€‚ åˆ¤æ–­å½“å‰ç‚¹çš„çºµåæ ‡æ˜¯ä¸æ˜¯éƒ½å°äºŽç­‰äºŽæ‰€æœ‰çŸ©å½¢çš„çºµåæ ‡ã€‚ å¦‚æžœèƒ½æŠŠè¿™ä¸¤ä¸ªäº‹æƒ…æ”¾åœ¨ä¸¤ä¸ªå•ç‹¬çš„å¾ªçŽ¯å®Œæˆï¼Œæˆ–è€…è¯´åˆ†å¼€è¿›è¡Œï¼Œç„¶åŽåˆå¹¶ 2 ä¸ªç»“æžœæ˜¯ä¸æ˜¯å°±èƒ½ç¼©çŸ­æ—¶é—´å¤æ‚åº¦äº†å‘¢ï¼Ÿå½“ç„¶æ˜¯çš„å•Šï¼è™½ç„¶è¿™ä¸ªé—®é¢˜çš„è§£å†³è¿‡ç¨‹è‚¯å®šä¸å¯èƒ½è¿™ä¹ˆç†æƒ³åŒ–ï¼Œä¸è¿‡è¿™æ˜¯ä¸€ä¸ªä¸é”™çš„æ€è€ƒæ€è·¯ã€‚è¿›ä¸€æ­¥è§‚å¯Ÿé¢˜ç›®ï¼Œå¯ä»¥å‘çŽ°çºµåæ ‡çš„è§„æ¨¡æ˜¯ $[1, 100]$ï¼Œæ¨ªåæ ‡çš„è§„æ¨¡æ˜¯ $[1, 10^9]$ã€‚ä¸ºä»€ä¹ˆçºµåæ ‡è§„æ¨¡è¿™ä¹ˆå°ï¼Ÿæ˜¾ç„¶æœ‰çŒ«è…»å•Šï¼Œä¸å¦¨å…ˆæŒ‰ç…§ç›¸åŒçš„çºµåæ ‡ï¼Œç»Ÿè®¡æ‰€æœ‰ä¸åŒçš„æ¨ªåæ ‡çš„çŸ©å½¢ï¼š1234vector&lt;vector&lt;int&gt;&gt; rec(110);for(auto &amp;v: rectangles) &#123; rec[v[1]].push_back(v[0]);&#125; ç”±äºŽçºµåæ ‡è§„æ¨¡è¾ƒå°ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥æ‹¿æ¥å½“ä½œæ•°ç»„çš„ä¸‹æ ‡ã€‚å¾—åˆ°è¿™æ ·çš„ç»“æžœåŽï¼Œè¿›ä¸€æ­¥æ€è€ƒå¦‚ä½•è¿›è¡Œåˆ¤æ–­ã€‚ å› ä¸ºçºµåæ ‡æ˜¯ä¸‹æ ‡ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥æ‰¾å‡ºçºµåæ ‡å¤§äºŽç­‰äºŽç‚¹çš„çºµåæ ‡çš„æ‰€æœ‰çŸ©å½¢ï¼ˆæ—¶é—´å¤æ‚åº¦ $O(1)$ï¼‰ï¼Œä¹Ÿå³ $rec[i], i &gt;= h$ã€‚ä½†å¦‚æžœçŸ©å½¢çš„æ¨ªåæ ‡ä¸æ»¡è¶³æ¡ä»¶ä¹Ÿæ˜¯ä¸ç¬¦åˆé¢˜æ„çš„ï¼Œæ‰€ä»¥ä¹Ÿè¦åœ¨è¿™äº›çºµåæ ‡ç¬¦åˆæ¡ä»¶çš„çŸ©å½¢ä¸­ï¼Œå¿«é€Ÿæ‰¾å‡ºæ‰€æœ‰æ¨ªåæ ‡ç¬¦åˆæ¡ä»¶çš„çŸ©å½¢ã€‚å®žé™…ä¸Šï¼Œåœ¨ rec è¿™ä¸ªæ•°ç»„ä¸­ï¼Œæ¯ä¸€ä¸ªå…ƒç´ éƒ½æ˜¯çºµåæ ‡ç›¸ç­‰çš„çŸ©å½¢çš„æ¨ªåæ ‡çš„é›†åˆã€‚è¦å®Œæˆä¸Šé¢è¯´çš„äº‹æƒ…ï¼Œå…¶å®žåªéœ€è¦éåŽ†è¿™äº›é›†åˆå³å¯ï¼ˆæ­¤æ—¶é—®é¢˜å·²ç»è½¬åŒ–äº†ï¼‰ã€‚ åˆ°è¿™é‡Œï¼Œå›žè¿‡å¤´çœ‹å¯ä»¥å‘çŽ°ï¼Œä¸Šé¢æåˆ°çš„ 2 ä¸ªé—®é¢˜ï¼Œå·²ç»è¢«æ‹†å¼€æ¥åˆ†åˆ«è§£å†³äº†ã€‚ ç»§ç»­æ€è€ƒä¸‹åŽ»ï¼ŒéåŽ†æ¨ªåæ ‡ï¼ˆä¸Šé¢æåˆ°çš„é›†åˆï¼‰ï¼Œä¸€èˆ¬æ˜¯ç›´æŽ¥éåŽ†ï¼Œé‚£æ ·æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(n)$ã€‚å› ä¸ºï¼Œå¤–å±‚è¿˜æœ‰ m ä¸ªç‚¹ï¼Œå¦‚æžœç›´æŽ¥è¿™æ ·éåŽ†ï¼Œä¼°è®¡è¿˜æ˜¯å¤Ÿå‘›ã€‚æœ‰ä»€ä¹ˆåŠžæ³•ï¼Ÿç­”æ¡ˆæ˜¯å…ˆæŽ’åºï¼Œæ±‚æ»¡è¶³æ¡ä»¶çŸ©å½¢ä¸ªæ•°æ—¶å†ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚æŽ’åºï¼š123for(auto &amp;v: rec) &#123; sort(v.begin(), v.end());&#125; æ˜¯çš„ï¼ŒæŽ’åºå¯ä»¥åœ¨éåŽ†ç‚¹çš„å¾ªçŽ¯å¤–åšå®Œï¼Œè¿™æ ·å°±å¯ä»¥ç›´æŽ¥ç”¨äº†ðŸ˜‚ã€‚å‰©ä¸‹å°±æ˜¯éåŽ†ç‚¹ï¼Œç„¶åŽç»Ÿè®¡å‡ºæ‰€æœ‰çš„çŸ©å½¢å°±å¥½äº†ï¼š1234567891011121314151617181920212223class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int size = points.size(); vector&lt;vector&lt;int&gt;&gt; rec(110); for(auto &amp;v: rectangles) &#123; rec[v[1]].push_back(v[0]); &#125; for(auto &amp;v: rec) &#123; sort(v.begin(), v.end()); &#125; vector&lt;int&gt; ret(size); for(int i = 0; i &lt; size; i++) &#123; int x = points[i][0], y = points[i][1]; for(int j = y; j &lt;= 100; j++) &#123; if(!rec[j].empty()) &#123; ret[i] += rec[j].end() - (lower_bound(rec[j].begin(), rec[j].end(), x)); &#125; &#125; &#125; return ret; &#125;&#125;; äºŒåˆ†æŸ¥æ‰¾ç›´æŽ¥è°ƒç”¨ lower_bound å‡½æ•°æ¥å®Œæˆï¼Œåšå·®çš„ç»“æžœå°±æ˜¯å½“å‰çºµåæ ‡ä¸‹ï¼Œæ‰€æœ‰å¤§äºŽç­‰äºŽç‚¹çš„æ¨ªåæ ‡çš„çŸ©å½¢ä¸ªæ•°ã€‚ä¸å®¹æ˜“å•Šï¼Œå¥½æ­¹ç®—æ˜¯é€šè¿‡äº†ã€‚çŽ°åœ¨å›žè¿‡å¤´æ¥çœ‹ä¸€ä¸‹è¿™ä¸ªç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š é¦–å…ˆæŒ‰ç…§çºµåæ ‡æ¥ç»Ÿè®¡æ¨ªåæ ‡ï¼Œ$O(m)$ã€‚ æŽ’åºï¼Œ$O(nlogn)$ã€‚ æœ€åŽå°±æ˜¯ç»Ÿè®¡æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„ä¸ªæ•°ï¼Œ$O(m Ã— 100 Ã— logn)$ï¼Œè¿™ä¸ª 100 å¯ä»¥æ¢æˆå­—æ¯ï¼Œè¡¨ç¤ºæ¨ªåæ ‡æˆ–çºµåæ ‡è§„æ¨¡å°çš„é‚£ä¸ªã€‚ åˆè®¡å°±æ˜¯ï¼š$O(m) + O(nlogn) + O(H_{min} m logn)$ã€‚å¯¹åº”çš„ç©ºé—´å¤æ‚åº¦ï¼š$O(m + n)$ã€‚ æ²¡åšè¿‡è¿™ç±»é¢˜ï¼Œè¿˜çœŸä¸å¤ªå¥½æƒ³ã€‚è¿˜å‰© 2 é“é¢˜ï¼Œæ˜Žå¤©å†å†™ã€‚ å—¯ï¼Œåˆçž…äº†å‡ çœ¼å…¶ä»–äººçš„é¢˜è§£ï¼Œå‘çŽ°ä¸Šé¢è¿™ç§æ€è·¯æ˜¯ä¸€ç§å«åšæŒ‰è¡Œç»Ÿè®¡çš„æ€è·¯ã€‚è¿™ç§æ€è·¯æ˜¯å°†çºµåæ ‡çœ‹ä½œè¡Œï¼Œæå‰å°†æ¨ªåæ ‡æå‰æŽ’å¥½åºå¹¶æŒ‰çºµåæ ‡å¤§å°ï¼Œä¸€è¡Œä¸€è¡Œçš„ä¿å­˜èµ·æ¥ï¼Œç„¶åŽå†é€è¡Œè¿›è¡ŒäºŒåˆ†æŸ¥æ‰¾æ¥ç»Ÿè®¡ç¬¦åˆæ¡ä»¶çš„çŸ©å½¢æ€»æ•°ã€‚ å¦‚æžœæŒ‰ç…§åªçºµåæ ‡æŽ’åºï¼Œé‚£ä¹ˆéœ€è¦æå‰å°†çŸ©å½¢å’Œç‚¹æŒ‰çºµåæ ‡ä»Žå¤§åˆ°å°æŽ’åºã€‚ç„¶åŽåœ¨éåŽ†ç‚¹çš„åŒæ—¶ï¼Œå°†çºµåæ ‡ç¬¦åˆæ¡ä»¶çš„çŸ©å½¢æ¨ªåæ ‡æ”¾å…¥åˆ°ä¸€ä¸ªæ–°çš„æ•°ç»„ arr ä¸­ï¼Œç›´åˆ°ä¸æ»¡è¶³æ¡ä»¶ã€‚æ­¤æ—¶ï¼Œarr ä¸­æ”¾çš„å°±æ˜¯æ‰€æœ‰çºµåæ ‡ç¬¦åˆæ¡ä»¶çš„çŸ©å½¢æ¨ªåæ ‡ï¼Œå¯¹å…¶æŽ’åºåŽäºŒåˆ†æŸ¥æ‰¾ï¼Œä¹Ÿä¸€æ ·å¯ä»¥ç®—å‡ºæ»¡è¶³æ¡ä»¶çš„çŸ©å½¢æ€»æ•°ã€‚å› ä¸ºçºµåæ ‡æ˜¯é€’å‡ï¼Œæ‰€ä»¥ä¸‹ä¸€ä¸ªç‚¹çš„çºµåæ ‡ä¸€å®šæ˜¯å°äºŽå·²ç»æ”¾å…¥ arr çŸ©å½¢çš„çºµåæ ‡çš„ã€‚å‰©ä¸‹è¦åšçš„äº‹æƒ…ï¼Œå°±æ˜¯ä»Žå‰©ä½™çš„çŸ©å½¢ä¸­æ‰¾å‡ºç¬¦åˆå½“å‰ç‚¹çš„æ¨ªåæ ‡çš„çŸ©å½¢æ¨ªåæ ‡ï¼Œç„¶åŽæ”¾å…¥ arr ä¸­ï¼ŒæŽ’åºåŽäºŒåˆ†ã€‚ å›žè¿‡å¤´æ¥æƒ³ä¸€æƒ³ï¼Œå¦‚æžœåœ¨ä¸Šé¢è¿™ç§æ€è·¯ä¸­ä¹Ÿå°†çŸ©å½¢æŒ‰çºµåæ ‡ä»Žå¤§åˆ°å°æŽ’å¥½åºï¼Œé‚£åœ¨å‘ arr æ•°ç»„ä¸­æ·»åŠ çŸ©å½¢æ¨ªåæ ‡æ—¶ï¼Œä¸å°±åªç”¨éåŽ†ä¸€æ¬¡çŸ©å½¢æ¨ªåæ ‡äº†å—ï¼Ÿæ²¡é”™ï¼Œç¡®å®žæ˜¯è¿™æ ·çš„ã€‚æ‰€ä»¥ï¼Œè¿˜æ˜¯éƒ½æå‰æŽ’å¥½åºæ¯”è¾ƒå¥½ï¼š123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(rectangles.begin(), rectangles.end(), [](auto &amp;a, auto &amp;b) &#123; return a[1] &gt; b[1]; &#125;); int size = points.size(); vector&lt;int&gt; indices(size); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return points[i][1] &gt; points[j][1]; &#125;); vector&lt;int&gt; ans(size), arr; int i = 0; for(int id: indices) &#123; int start = i; while(i &lt; rectangles.size() &amp;&amp; rectangles[i][1] &gt;= points[id][1]) &#123; arr.push_back(rectangles[i++][0]); &#125; if(start &lt; i) sort(arr.begin(), arr.end()); ans[id] = arr.end() - lower_bound(arr.begin(), arr.end(), points[id][0]); &#125; return ans; &#125;&#125;; å¦‚æžœåªæŒ‰ç…§æ¨ªåæ ‡æŽ’åºå‘¢ï¼ŸåŒæ ·çš„ï¼Œéœ€è¦å…ˆå¯¹çŸ©å½¢ä¸Žç‚¹æŒ‰æ¨ªåæ ‡ä»Žå¤§åˆ°å°æŽ’åºã€‚å¦å¤–ï¼Œç”±äºŽçºµåæ ‡çš„èŒƒå›´æ¯”è¾ƒå°ï¼ˆ$[1, 100]$ï¼‰ï¼Œå°±ç®—ä¸ç”¨äºŒåˆ†ä¹Ÿæ˜¯å¯ä»¥æŽ¥å—çš„ï¼Œæ‰€ä»¥ä¸å¦‚ç›´æŽ¥å°†çºµåæ ‡ç›¸åŒçš„çŸ©å½¢å…¨éƒ¨ç»Ÿè®¡å‡ºæ¥ã€‚ç„¶åŽéåŽ†ç‚¹çš„æ—¶å€™ï¼Œå°†çºµåæ ‡æ»¡è¶³æ¡ä»¶çš„çŸ©å½¢ä¸ªæ•°é€ä¸ªç›¸åŠ å³å¯ã€‚è¿™ä¸ªæ–¹æ³•æœ‰ç‚¹ç±»ä¼¼å‰é¢æåˆ°çš„æŒ‰è¡Œç»Ÿè®¡ï¼Œä½†æ˜¯è¿™ç§æ–¹æ³•åœ¨è®¡ç®—ä¸ªæ•°æ—¶ä¼šæ›´å¿«ä¸€ç‚¹ã€‚12345678910111213141516171819class Solution &#123;public: vector&lt;int&gt; countRectangles(vector&lt;vector&lt;int&gt;&gt;&amp; rectangles, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; sort(rectangles.begin(), rectangles.end(), [](auto &amp;a, auto &amp;b) &#123; return a[0] &gt; b[0]; &#125;); int size = points.size(); vector&lt;int&gt; indices(size); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return points[i][0] &gt; points[j][0]; &#125;); vector&lt;int&gt; ans(size), cnt(101); int i = 0; for(int id: indices) &#123; while(i &lt; rectangles.size() &amp;&amp; rectangles[i][0] &gt;= points[id][0]) &#123; ++cnt[rectangles[i++][1]]; &#125; ans[id] = accumulate(cnt.begin() + points[id][1], cnt.end(), 0); &#125; return ans; &#125;&#125;; åŒæ ·çš„ï¼Œå› ä¸ºæå‰å°†ç‚¹æŒ‰æ¨ªåæ ‡ä»Žå¤§åˆ°å°æŽ’åºäº†ï¼Œæ‰€ä»¥ä¹Ÿä¸å­˜åœ¨é—æ¼ä¸Žé”™è§£çš„æƒ…å†µã€‚em...ä¸Šé¢æåˆ°çš„è¿™äº›æ€è·¯å¥½åƒæ˜¯ä»Žæ ‘çŠ¶æ•°ç»„ä¸­æ¥çš„ï¼Œæ ‘çŠ¶æ•°ç»„çš„æ¦‚å¿µç­‰ä»¥åŽçœŸçš„ç”¨åˆ°äº†ï¼Œå†è¯´å§ï¼Œè¿™ä¸ªé¢˜å°±åˆ°æ­¤ä¸ºæ­¢äº†ã€‚ 2251. Number of Flowers in Full BloomAnalysisè¿™æ˜¯ç¬¬ 4 ä¸ªé¢˜ï¼Œä¸è¿‡æ˜¯ç¬¬ä¸‰ä¸ªæäº¤çš„é¢˜ã€‚åŒæ ·ï¼Œä¹Ÿæ˜¯å› ä¸ºé¢˜æ„ç†è§£èµ·æ¥æ¯”è¾ƒå®¹æ˜“ï¼Œå°±å¾ˆå®¹æ˜“æƒ³åˆ°æš´åŠ›è§£æ³•ã€‚ Codeæš´åŠ›è§£æ³•å…¶å®žå¾ˆç®€å•ï¼Œåªéœ€è¦åˆ¤æ–­äººåˆ°è¾¾çš„å¤©æ•°ï¼Œåœ¨é‚£äº›èŠ±å„¿çš„èŠ±æœŸå†…å³å¯ï¼Œè¿™æ˜¯å½“æ—¶å†™çš„ï¼š123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; int fsize = flowers.size(), psize = persons.size(); unordered_map&lt;int, int&gt; ht; for(int i = 0; i &lt; fsize; i++) &#123; int start = flowers[i][0], end = flowers[i][1]; while(start &lt;= end) &#123; ht[start++]++; &#125; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt; psize; i++) &#123; ret.push_back(ht[persons[i]]); &#125; return ret; &#125;&#125;; ä¸Šé¢è¿™ä¸ªæš´åŠ›è§£æ³•çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^2)$ï¼Œå°½ç®¡æ˜ŽçŸ¥é“æ˜¯è¶…æ—¶çš„ï¼Œè¿˜æ˜¯æäº¤ä¸€ä¸‹ï¼Œç­¾ä¸ªåˆ°ðŸ˜‚ã€‚çœ‹äº†ä¸€ä¸‹å¤§ä½¬ä»¬çš„æ€è·¯ï¼Œåˆå›žå¤´æƒ³äº†æƒ³ï¼Œå½“æ—¶å·²ç»æƒ³åˆ°äº†è¿™ä¸ªé¢˜æ˜¯æŒ‰ç…§åŒºé—´ï¼ˆä¹Ÿå°±æ˜¯èŠ±æœŸï¼‰æ¥ç»Ÿè®¡å‡ºæ¯ä¸€å¤©ç››å¼€çš„èŠ±çš„æ•°ç›®ï¼Œåªæ˜¯æš´åŠ›éåŽ†çš„æ–¹æ³•æ—¶é—´æ¶ˆè€—å¤ªå¤§äº†ã€‚å®žé™…ä¸Šï¼Œè¿™é‡Œå…¶å®žå¯ä»¥ç”¨å·®åˆ†çš„æ€æƒ³æ¥åšï¼Œå¯æƒœï¼Œå½“æ—¶æˆ‘ä¸æ‡‚ï¼ˆè‡ªä¿¡ç‚¹ï¼Œæ‡‚äº†å¯èƒ½ä¹Ÿä¸ä¼šç”¨ðŸ˜‚ï¼‰...å—¯ï¼Œå…·ä½“è¦æ€Žä¹ˆåšå‘¢ï¼Ÿå®žé™…ä¸Šä¸Žæš´åŠ›ä»£ç å†…çš„ç»Ÿè®¡æ¬¡æ•°ç±»ä¼¼ï¼Œä½†æ˜¯åªç»Ÿè®¡ä¸¤ä¸ªå€¼ï¼šstart å’Œ end + 1ã€‚å› ä¸ºï¼ŒèŠ±å„¿çš„èŠ±æœŸæ˜¯åœ¨ $[start, end]$ å†…ï¼Œæ‰€ä»¥è¿™ä¸ªåŒºé—´å†…çš„èŠ±å„¿çš„ç››å¼€æ•°é‡è¦å…¨éƒ¨åŠ  1ï¼Œä¹Ÿå°±æ˜¯ start åŠ  1ã€‚è¿‡äº†èŠ±æœŸä¹‹åŽï¼ŒèŠ±å„¿ç››å¼€æ•°é‡å°±å‡ 1ï¼Œå¯¹åº”çš„å°±æ˜¯ end + 1 å‡ 1ã€‚12345map&lt;int, int&gt; ht;for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--;&#125; è¿™æ ·å°±å¯ä»¥æŠŠä¸åŒèŠ±æœŸå†…èŠ±å„¿çš„ç››å¼€æ•°é‡ç»Ÿè®¡å‡ºæ¥äº†ã€‚æŽ¥ä¸‹æ¥è¦åšçš„äº‹æƒ…å°±æ˜¯ï¼ŒæŠŠæ¯äººåˆ°è¾¾çš„é‚£ä¸€å¤©ç››å¼€çš„èŠ±å„¿æ•°é‡ç®—å‡ºæ¥å°±å¯ä»¥äº†ï¼ŒåŒæ ·ï¼Œä¸æ–­ç´¯åŠ å°±è¡Œã€‚12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; map&lt;int, int&gt; ht; for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--; &#125; int psize = persons.size(); vector&lt;int&gt; ans(psize); int index = 0; for(int &amp;i: persons) &#123; int sum = 0; auto it = ht.begin(); while(it != ht.end() &amp;&amp; it-&gt;first &lt;= i) &#123; sum += it++-&gt;second; &#125; ans[index++] = sum; &#125; return ans; &#125;&#125;; ä½†è¿™æ®µä»£ç å†™ä¸ŠåŽ»è¿˜æ˜¯è¶…æ—¶çš„ï¼Œä¸ºä»€ä¹ˆï¼Ÿçœ‹ä¸€ä¸‹å…·ä½“ç»“æžœï¼Œå‰é¢æš´åŠ›è§£æ³•è¢«å¡åœ¨äº†æ ·ä¾‹ 32ï¼Œè¿™ä¸ªè§£æ³•è¢«å¡åœ¨äº†æ ·ä¾‹ 45ï¼Œè¯´æ˜Žè¿™ç§æ–¹æ³•åœ¨æ—¶é—´ä¸Šæ˜¯æ›´ä¼˜ç§€çš„ã€‚é‚£ä¹ˆï¼Œè¿˜æœ‰ä»€ä¹ˆåœ°æ–¹å¯ä»¥ç»§ç»­ä¼˜åŒ–ä¸€ä¸‹å‘¢ï¼Ÿæ³¨æ„åˆ°ï¼Œåœ¨éåŽ†æ¯äººåˆ°è¾¾çš„å¤©æ•°æ—¶ï¼Œæ¯æ¬¡éƒ½è¦ä»Ž ht çš„å¼€å¤´ç®—åˆ°å°¾ï¼Œèƒ½æƒ³åŠžæ³•ä¼˜åŒ–è¿™ä¸ªè¿‡ç¨‹å—ï¼Ÿå› ä¸º ht æœ¬èº«å·²ç»æœ‰åºäº†ï¼Œæ‰€ä»¥å®Œå…¨å¯ä»¥å…ˆæ±‚å‡º ht çš„å‰ç¼€å’Œï¼ˆå½“ç„¶ä¸ç®¡æœ‰åºæ— åºï¼Œéƒ½å¯ä»¥ç®—å‰ç¼€å’Œï¼‰ï¼Œè¿™æ ·å°±ä¸ç”¨é‡å¤å†ç®—äº†ã€‚ä½†æ˜¯å¯æƒœçš„æ˜¯ï¼Œé¢˜ç›®è§„å®šçš„ $persons[i]$ çš„èŒƒå›´æ˜¯ $[1, 10^9]$ï¼Œå“ªé‡Œèƒ½å¼€è¿™ä¹ˆå¤§çš„æ•°ç»„å‘¢...å›žæƒ³ä¸€ä¸‹ä¸Šä¸ªé¢˜ï¼Œç´¯åŠ è®¡ç®—æ—¶åšçš„ä¼˜åŒ–æ˜¯ä»€ä¹ˆï¼Ÿæ˜¯å¯¹ä¸‹æ ‡å’Œç´¯åŠ çš„æ•°ç»„æå‰æŽ’åºï¼Œç„¶åŽå†ç´¯åŠ å°±å¯ä»¥äº†ã€‚çŽ°åœ¨ï¼Œç”¨åˆ°è¿™é‡Œæ¥ï¼š123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; map&lt;int, int&gt; ht; for(auto &amp;f: flowers) &#123; ht[f[0]]++; ht[f[1] + 1]--; &#125; int psize = persons.size(); vector&lt;int&gt; ans(psize); vector&lt;int&gt; indices(psize); iota(indices.begin(), indices.end(), 0); sort(indices.begin(), indices.end(), [&amp;](int i, int j) &#123; return persons[i] &lt; persons[j]; &#125;); int sum = 0; auto it = ht.begin(); for(int &amp;i: indices) &#123; while(it != ht.end() &amp;&amp; it-&gt;first &lt;= persons[i]) &#123; sum += it++-&gt;second; &#125; ans[i] = sum; &#125; return ans; &#125;&#125;; åŒæ ·ï¼Œindices ä¹Ÿéœ€è¦æŒ‰ä¸‹æ ‡ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åºã€‚è¿™æ ·ï¼Œht å°±åªç”¨éåŽ†ä¸€æ¬¡å°±å¯ä»¥ç®—å‡ºæ‰€æœ‰ $persons[i]$ çš„å€¼äº†ï¼ˆæ„Ÿè§‰æœ¬è´¨è¿˜æ˜¯å‰ç¼€å’Œçš„æ€æƒ³ï¼‰ã€‚æäº¤ä¸ŠåŽ»æ˜¯å¯ä»¥é€šè¿‡çš„...ç®€å•åˆ†æžä¸€ä¸‹ï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯ $O(nlogn) + O(mlogm) + O(n) + O(m)$ï¼Œn æ˜¯ flowers çš„é•¿åº¦ï¼Œm æ˜¯ persons çš„é•¿åº¦ï¼Œå‰ä¸€ä¸ª $O(nlogn)$ æ˜¯ ht åº•å±‚æŽ’åºæ¶ˆè€—çš„æ—¶é—´ï¼ŒåŽé¢çš„å°±ä¸è¯´äº†ï¼Œå®žé™…ä¸Šå¯ä»¥ç›´æŽ¥å†™æˆ $O(nlogn) + O(mlogm)$ï¼›ç©ºé—´å¤æ‚åº¦å°±æ˜¯ $O(n + m)$ã€‚ åˆ°è¿™é‡Œï¼Œè¿™ä¸ªé¢˜å·²ç»ç®—æ˜¯ç”¨æ¯”è¾ƒç®€å•çš„æ–¹æ³•è§£å†³äº†ã€‚å†å›žé¡¾ä¸€ä¸‹å·®åˆ†çš„æ€æƒ³ï¼Œæ˜¯å°†æ¯å¤©å¼€èŠ±çš„æ•°ç›®ä¸Žæ¯å¤©å‡‹è°¢çš„æ•°ç›®å…¨éƒ¨ç´¯åŠ èµ·æ¥çš„ã€‚æ¢ä¸ªè§’åº¦æ¥æ€è€ƒï¼Œå¯¹äºŽæŸä¸€å¤©è€Œè¨€ï¼Œè¿™ä¸€å¤©å¼€èŠ±çš„æ•°ç›®å…¶å®žç­‰äºŽè¿™ä¸€å¤©ä¹‹å‰å¼€èŠ±çš„æ€»æ•°ç›®å‡åŽ»è¿™ä¸€å¤©ä¹‹å‰å‡‹è°¢çš„èŠ±å„¿çš„æ€»æ•°ç›®ã€‚å¦‚æžœèƒ½å¾—åˆ°å½“å‰å¤©ä¹‹å‰å‡‹è°¢çš„èŠ±å„¿æ€»æ•°ç›®ä¸Žè¿™ä¸€å¤©å¼€èŠ±çš„æ€»æ•°ç›®ï¼ŒäºŒè€…ä½œå·®ä¹‹åŽï¼Œä¸å°±æ˜¯è¿™ä¸€å¤©èƒ½çœ‹åˆ°çš„èŠ±å„¿æ€»æ•°ç›®å—ï¼Ÿé‚£ä¹ˆå¦‚ä½•ç»Ÿè®¡æ¯å¤©å¼€èŠ±çš„æ•°ç›®ä¸Žå‡‹è°¢çš„æ•°ç›®å‘¢ï¼Ÿä¸Žå‰é¢ä¸€æ ·ï¼Œç”¨ map è®©å¤©æ•°ä¸Žå¼€èŠ±æ•°ç›®ç›¸äº’æ˜ å°„å—ï¼Ÿè¿™æ ·ï¼Œå°±åˆå›žåˆ°æš´åŠ›è§£æ³•åŽ»äº†...å®žé™…ä¸Šç”¨ 2 ä¸ªæ•°ç»„å°±å¯ä»¥å®Œæˆäº†ã€‚123456int fsize = flowers.size();vector&lt;int&gt; starts(fsize), ends(fsize);for(auto &amp;v: flowers) &#123; starts.push_back(v[0]); ends.push_back(v[1]);&#125; æŽ¥ç€ï¼Œå†ç”¨ä¸Šä¸€é¢˜æ±‚å’Œçš„æ–¹æ³•ï¼šæŽ’åºå’ŒäºŒåˆ†ã€‚å‰ä¸€å¤©å¼€èŠ±çš„æ•°ç›®ï¼Œ12345678sort(starts.begin(), starts.end());sort(ends.begin(), ends.end());int psize = persons.size();vector&lt;int&gt; ans(psize);for(int i = 0; i &lt; psize; i++) &#123; ans[i] = (upper_bound(starts.begin(), starts.end(), persons[i]) - starts.begin()) - (lower_bound(ends.begin(), ends.end(), persons[i]) - ends.begin());&#125; æœ€åŽåˆå¹¶èµ·æ¥ï¼š1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; fullBloomFlowers(vector&lt;vector&lt;int&gt;&gt;&amp; flowers, vector&lt;int&gt;&amp; persons) &#123; int fsize = flowers.size(); vector&lt;int&gt; starts(fsize), ends(fsize); for(auto &amp;v: flowers) &#123; starts.push_back(v[0]); ends.push_back(v[1]); &#125; sort(starts.begin(), starts.end()); sort(ends.begin(), ends.end()); int psize = persons.size(); vector&lt;int&gt; ans(psize); for(int i = 0; i &lt; psize; i++) &#123; ans[i] = (upper_bound(starts.begin(), starts.end(), persons[i]) - starts.begin()) - (lower_bound(ends.begin(), ends.end(), persons[i]) - ends.begin()); &#125; return ans; &#125;&#125;; å°±å¯ä»¥æ±‚å¾—æœ€ç»ˆç»“æžœäº†...æ—¶é—´å¤æ‚åº¦ï¼š$O((n + m)logn)$ã€‚ç©ºé—´å¤æ‚åº¦ï¼š$O(n)$ã€‚ 2249. Count Lattice Points Inside a CircleAnalysiså¥½çš„ï¼ŒçŽ°åœ¨å†å›žåˆ°ç¬¬äºŒé¢˜ã€‚è¿™ä¸ªé¢˜å½“æ—¶æ²¡ä»€ä¹ˆæ€è·¯ï¼ŒåŽŸå› æ˜¯ä¸çŸ¥é“æ€Žä¹ˆæžšä¸¾ã€‚é¢˜æ„å€’æ˜¯æ¯”è¾ƒç®€å•ï¼Œç»™å®šä¸€å®šæ•°é‡çš„åœ†ï¼Œè¿”å›žè‡³å°‘å‡ºçŽ°åœ¨ä¸€ä¸ªåœ†å†…çš„æ ¼ç‚¹æ•°ç›®ã€‚æ ¼ç‚¹çš„å®šä¹‰é¢˜ç›®å·²ç»è§£é‡Šäº†ï¼Œå…¶å®žå°±æ˜¯åæ ‡ä¸ºæ•´æ•°çš„ç‚¹ï¼Œå¹¶ä¸”ç¦»åœ†å¿ƒçš„è·ç¦»å°äºŽç­‰äºŽåŠå¾„ã€‚ CodeçŽ°åœ¨æƒ³æƒ³ï¼Œå…¶å®žå¯ä»¥æƒ³å‡ºæš´åŠ›è§£æ³•ï¼ˆå¯èƒ½æ˜¯åˆ†æžå‰é¢é¢˜ç›®çš„ç»éªŒå§ï¼‰ã€‚å› ä¸ºåœ†å¿ƒã€åŠå¾„ç»™çš„éƒ½æ˜¯æ•´æ•°ï¼Œæ‰€ä»¥ï¼Œæ¯ä¸ªåœ†ä¸€å®šä¼šå¤–åˆ‡ä¸€ä¸ªçŸ©å½¢ï¼ŒæŒ‰ç…§è¿™ä¸ªçŸ©å½¢çš„å·¦ä¸‹ç«¯ç‚¹å’Œè¾¹é•¿è¿›è¡Œæžšä¸¾ï¼Œå†åˆ¤æ–­æ˜¯å¦æ»¡è¶³æ¡ä»¶ã€‚ä¸ºäº†é¿å…é‡å¤ï¼Œå¯ä»¥åˆ©ç”¨ setã€‚1234567891011121314151617class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; map&lt;pair&lt;int, int&gt;, int&gt; points; for(auto v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2], r = v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; for(int i = leftlowerx; i &lt;= l; i++) &#123; for(int j = leftlowery; j &lt;= h; j++) &#123; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= r * r) points[make_pair(i, j)] = 1; &#125; &#125; &#125; return points.size(); &#125;&#125;; å› ä¸º set ä¸Ž pair ä¸€èµ·ä½¿ç”¨æ—¶è¦é‡æ–°å†™ä¸‹ hash å‡½æ•°ï¼ˆé—æ†¾çš„æ˜¯...æˆ‘ä¸çŸ¥é“ C++ è¿™ä¸ªæ€Žä¹ˆå†™ðŸ˜‚ï¼‰ï¼Œå°±ç›´æŽ¥ç”¨ map äº†ã€‚å¯æƒœçš„æ˜¯ï¼Œæ–¹å‘æ˜¯æ‰¾å¯¹äº†ï¼Œå°±æ˜¯è¿˜æ˜¯è¶…æ—¶äº†ï¼Œæ­»åœ¨ç¬¬ 57 ä¸ªæ ·ä¾‹äº†ã€‚çœ‹äº†ä¸‹æç¤ºï¼šSince you need to reduce the search space, consider the minimum and maximum possible values of the coordinates of a lattice point contained in any circle.ã€‚æƒ³äº†ä¸‹ï¼Œæžšä¸¾æ¯ä¸ªåœ†çš„å¤–åˆ‡çŸ©å½¢ä¸€å®šä¼šæœ‰å¾ˆå¤šé‡å¤çš„ç‚¹ï¼Œå¦‚æžœæˆ‘ä»¬ç›´æŽ¥ä»Žèƒ½å®¹çº³æ‰€æœ‰åœ†çš„é‚£ä¸ªæœ€å¤§çš„å¤–åˆ‡çŸ©å½¢åæ ‡å¼€å§‹æžšä¸¾ï¼Œå†åˆ©ç”¨ hash ä¸å°±å¯ä»¥å‡å°‘é‡å¤æ¯”è¾ƒçš„æ¬¡æ•°äº†å—ï¼Ÿæ˜¯çš„ï¼Œå°±æ˜¯è¿™æ ·çš„...æ„Ÿè°¢æç¤º~1234567891011121314151617181920212223242526272829class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; int leftlowerxmin = INT_MAX, leftlowerymin = INT_MAX; int lmax = INT_MIN, hmax = INT_MIN; for(auto &amp;v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; if(l &gt; lmax) lmax = l; if(h &gt; hmax) hmax = h; if(leftlowerx &lt; leftlowerxmin) leftlowerxmin = leftlowerx; if(leftlowery &lt; leftlowerymin) leftlowerymin = leftlowery; &#125; map&lt;pair&lt;int, int&gt;, int&gt; latticepoints; for(int i = leftlowerxmin; i &lt;= lmax; i++) &#123; for(int j = leftlowerymin; j &lt;= hmax; j++) &#123; if(latticepoints.count(make_pair(i, j))) break; for(auto &amp;v: circles) &#123; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= v[2] * v[2]) &#123; latticepoints[make_pair(i, j)] = 1; break; &#125; &#125; &#125; &#125; return latticepoints.size(); &#125;&#125;; è¿™ä¸ªå…¶å®žä¹Ÿæ˜¯æš´åŠ›è§£æ³•ï¼Œåªæ˜¯è½¬æ¢äº†ä¸€ä¸‹æ€è€ƒçš„è§’åº¦...çªç„¶å‘çŽ°ï¼Œå¥½åƒå‰é¢çš„æš´åŠ›è§£æ³•ï¼Œå¿˜è®°ç”¨ hash çš„æ€§è´¨äº†...123456789101112131415161718class Solution &#123;public: int countLatticePoints(vector&lt;vector&lt;int&gt;&gt;&amp; circles) &#123; map&lt;pair&lt;int, int&gt;, int&gt; points; for(auto v: circles) &#123; int l = v[0] + v[2], h = v[1] + v[2], r = v[2]; int leftlowerx = v[0] - v[2], leftlowery = v[1] - v[2]; for(int i = leftlowerx; i &lt;= l; i++) &#123; for(int j = leftlowery; j &lt;= h; j++) &#123; if(points.count(make_pair(i, j))) continue; int dis = (i - v[0]) * (i - v[0]) + (j - v[1]) * (j - v[1]); if(dis &lt;= r * r) points[make_pair(i, j)] = 1; &#125; &#125; &#125; return points.size(); &#125;&#125;; åŠ ä¸Š hash åŽç«Ÿç„¶é€šè¿‡äº†...ðŸ˜‚ï¼Œå°±æ˜¯æ—¶é—´ã€ç©ºé—´æ¶ˆè€—æƒ¨ä¸å¿ç¹ã€‚çœ‹äº†ä¸‹å¤§ä½¬ä»¬çš„æ€è·¯ï¼Œè¿™ä¸ªé¢˜å¥½åƒè¿˜æœ‰å…¶ä»–è§£æ³•ï¼Œæ‡’å¾—ç»§ç»­æ€è€ƒäº†ï¼Œè¿™ä¸ªé¢˜å°±åˆ°æ­¤ä¸ºæ­¢äº†... SummaryçŽ°åœ¨å›žå¤´çœ‹ä¸€ä¸‹è¿™æ¬¡åœºå‘¨èµ›çš„é¢˜ç›®ï¼Œæ„Ÿè§‰ 4 ä¸ªé¢˜æœ‰ç‚¹ç±»ä¼¼ï¼Œç‰¹åˆ«æ˜¯ç¬¬ 2 é¢˜ã€ç¬¬ 3 é¢˜å’Œç¬¬ 4 é¢˜ï¼Œéƒ½æœ‰æ•°å­¦çš„å½±å­åœ¨é‡Œé¢ã€‚å¦å¤–ï¼Œè¿™å‡ ä¸ªé¢˜å¥½åƒçš„é¢˜ç›®å½¢å¼éƒ½ä¸Žæ ‘çŠ¶æ•°ç»„æœ‰ç‚¹å…³ç³»ï¼Œç­‰ä¹‹åŽç ”ç©¶ä¸€ä¸‹å†æ¥çœ‹çœ‹å§ã€‚ä¸è¿‡çŽ°åœ¨å†å›žå¤´çœ‹çœ‹ï¼Œæ„Ÿè§‰å¥½åƒä¹Ÿä¸æ˜¯ç‰¹åˆ«å¤æ‚çš„é¢˜ç›®ï¼ˆæˆ‘åœ¨è¯´ä»€ä¹ˆ P è¯ðŸ˜‚ï¼‰ã€‚å“ˆå“ˆï¼Œå½“æ—¶åšçš„æ—¶å€™è¿˜æ˜¯é—®é¢˜å¾ˆå¤šçš„ï¼ŒçŽ°åœ¨ç–‘æƒ‘å·®ä¸å¤šå°±è§£å†³äº†ï¼Œåè€Œè§‰å¾—ä¸éš¾äº†...çœŸæ˜¯åº”äº†é‚£å¥è¯äº†ï¼šéš¾è€…ä¸ä¼šï¼Œä¼šè€…ä¸éš¾ã€‚ä¸è¿‡ï¼Œæˆ‘æƒ³ï¼ŒçŽ°åœ¨çš„â€œä¼šè€…â€ä¹Ÿæ˜¯ä»Žæ›¾ç»çš„â€œéš¾è€…â€ä¸€æ­¥ä¸€æ­¥è¿‡æ¥çš„å§...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode weekly contest</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_20 å¤©ç¼–ç¨‹èƒ½åŠ›åŸºç¡€_day1]]></title>
    <url>%2F2022%2F04%2F30%2FLeetcode-20-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%9F%BA%E7%A1%80-day1%2F</url>
    <content type="text"><![CDATA[ä¸ºä»€ä¹ˆè¿™ä¸ªéœ€è¦ 20 å¤©æ‰èƒ½ç»“æŸï¼Œæ„Ÿè§‰ 14 å¤©è¶³å¤Ÿäº†å•Šï¼Œåªæ˜¯æƒ³åšç‚¹ä¸­ç­‰é¢˜ã€‚ç¬¬ä¸€å¤©ï¼Œä¸¤ä¸ªç®€å•é¢˜è¯•è¯•æ°´~ 896. Monotonic ArrayAnalysisé¢˜æ„æ˜¯åˆ¤æ–­ç»™å®šçš„æ•°ç»„æ˜¯ä¸æ˜¯å•è°ƒçš„ï¼Œæ„Ÿè§‰æ¯”è¾ƒç®€å•ï¼Œä¸€ä¸ªå¾ªçŽ¯å°±æžå®šäº†ã€‚ Codemethod 1å› ä¸ºè¦ç¡®å®šæ•°ç»„æ˜¯é€’å‡çš„è¿˜æ˜¯é€’å¢žçš„ï¼Œæ‰€ä»¥å¯¹å‰ä¸¤ä¸ªå‡ºçŽ°çš„ä¸ç›¸ç­‰å…ƒç´ è¿›è¡Œæ¯”è¾ƒã€‚æ‰€ä»¥è¿™é‡Œå°±æœ‰ä¸€ä¸ªå‘ï¼Œä¸èƒ½ç›´æŽ¥é‚£æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ è·Ÿç¬¬äºŒä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒã€‚1234567891011121314151617181920class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 1) return true; int p1 = 0, p2 = 1; while(p1 &lt; size &amp;&amp; p2 &lt; size &amp;&amp; nums[p1] == nums[p2]) p1++, p2++; if(p2 == size) return true; if(nums[p1] &gt;= nums[p2]) &#123; for(int i = p1; i &lt; size - 1; i++) &#123; if(nums[i] &lt; nums[i + 1]) return false; &#125; &#125; else &#123; for(int i = p1; i &lt; size - 1; i++) &#123; if(nums[i] &gt; nums[i + 1]) return false; &#125; &#125; return true; &#125;&#125;; æ³¨æ„è¿™ç§æ–¹æ³•åªç”¨éåŽ†ä¸€æ¬¡æ•°ç»„ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ã€‚å®žé™…ä¸Šï¼Œå¯ä»¥ç²¾ç®€ä¸€ä¸‹è¿™ç§æ€è€ƒæ¨¡å¼ã€‚å¯¹äºŽä¸€ä¸ªæ•°ç»„è€Œè¨€ï¼Œå…¶å†…éƒ¨ç›¸é‚»çš„å…ƒç´ å¯èƒ½å­˜åœ¨ 3 ç§å…³ç³»ï¼šç›¸ç­‰ã€å¤§äºŽå’Œå°äºŽã€‚æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œå•è°ƒçš„æ•°ç»„åªå­˜åœ¨ä¸¤ç§æƒ…å†µï¼š ç›¸é‚»å…ƒç´ å¤§äºŽç­‰äºŽ ç›¸é‚»å…ƒç´ å°äºŽç­‰äºŽ å¹¶ä¸”è¿™ä¸¤ç§æƒ…å†µåªå¯èƒ½å‡ºçŽ°ä¸€ç§ï¼Œå¦‚æžœä¸¤ç§åŒæ—¶å‡ºçŽ°ï¼Œé‚£è¿™ä¸ªæ•°ç»„ä¸€å®šä¸æ˜¯å•è°ƒçš„ã€‚æ­¤æ—¶ï¼Œé—®é¢˜å°±è½¬åŒ–åˆ¤æ–­æ•°ç»„å†…ç›¸é‚»å…ƒç´ çš„æƒ…å†µäº†ï¼Œé‚£ä¹ˆå°±å¯ä»¥è¿™æ ·å†™äº†ï¼š123456789101112class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; bool inc = true, dec = true; int size = nums.size(); for(int i = 0; i &lt; size - 1; i++) &#123; if(nums[i] &gt; nums[i + 1]) inc = false; if(nums[i] &lt; nums[i + 1]) dec = false; &#125; return inc || dec; &#125;&#125;; method 2å®žé™…ä¸Šï¼Œåˆ¤æ–­å•è°ƒå°±æ˜¯åˆ¤æ–­æ•°ç»„æ˜¯å¦æœ‰åºï¼Œé‚£å°±å¯ä»¥ç›´æŽ¥æŽ¥ç”¨çŽ°æˆçš„åº“å‡½æ•°ã€‚123456class Solution &#123;public: bool isMonotonic(vector&lt;int&gt;&amp; nums) &#123; return is_sorted(nums.begin(), nums.end()) || is_sorted(nums.rbegin(), nums.rend()); &#125;&#125;; æ³¨æ„è¿™æ ·éœ€è¦éåŽ† 2 æ¬¡æ•°ç»„ï¼Œä½†æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯ $O(n)$ã€‚ 28. Implement strStr()Analysisé¢˜æ„å¾ˆç›´æŽ¥ï¼Œå®žçŽ° strstr å‡½æ•°å³å¯ã€‚è¯è¯´ï¼Œè¿™ä¸ªæŸ¥æ‰¾å­ä¸²çš„é¢˜è®©æˆ‘æƒ³åˆ°äº† KMP...ä¸è¿‡ï¼Œè¿™æ˜¯é“ easy é¢˜ã€‚å¦‚æžœç›®çš„æ˜¯é”»ç‚¼ä¸€ä¸‹ KMP çš„è¯ï¼Œä¼°è®¡æ˜¯ hard äº†ã€‚æ—¥åŽå¤ä¹  KMP çš„æ—¶å€™å†è¡¥ä¸€ä¸‹è¿™ä¸ªé¢˜å§ã€‚ Codemethod 1å…ˆæš´åŠ›åšä¸€ä¸‹ï¼š1234567891011121314151617181920class Solution &#123;public: int strStr(string haystack, string needle) &#123; int pos = -1, len1 = haystack.length(), len2 = needle.length(); if(len2 == 0) return 0; for(int i = 0; i &lt; len1; i++) &#123; if(haystack[i] == needle[0]) &#123; int tmp = i + 1, j; for(j = 1; j &lt; len2; j++, tmp++) &#123; if(needle[j] != haystack[tmp]) break; &#125; if(j == len2) &#123; pos = i; break; &#125; &#125; &#125; return pos; &#125;&#125;; æ³¨æ„åˆ«ä¸¢äº† needle ä¸ºç©ºä¸²çš„æƒ…å†µã€‚ method 2å¤ä¹ ä¸€ä¸‹ string å®¹å™¨çš„åº“å‡½æ•°ðŸ˜‚ï¼š123456class Solution &#123;public: int strStr(string haystack, string needle) &#123; return haystack.find(needle); &#125;&#125;; Summaryæ€»å…± 20 å¤©ï¼Œ41 ä¸ªé¢˜ï¼Œä¸€å¤©æ‰ 2 ä¸ªé¢˜ï¼Œä¸ºä»€ä¹ˆä¸è®¾ç½®æˆ 14 å¤©ï¼Œä¸€å¤© 2 - 3 ä¸ªé¢˜å‘¢ï¼Ÿè™½è¯´æ˜¯åŸºç¡€ï¼Œä¸€å¤© 3 ä¸ªä¸­ç­‰é¢˜åº”è¯¥æ˜¯ä¹Ÿå¯ä»¥æŽ¥å—çš„å§ï¼Ÿ]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day10]]></title>
    <url>%2F2022%2F04%2F29%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªä¹Ÿè¦ç»“æŸäº†å•Šã€‚ 182. Duplicate EmailsAnalysisé¢˜æ„æ¯”è¾ƒç®€å•ï¼Œæ‰¾å‡ºé‡å¤çš„ç”µå­é‚®ä»¶å³å¯ã€‚ Codeå…ˆç»Ÿè®¡é‚®ä»¶åœ°å€çš„å‡ºçŽ°æ¬¡æ•°ï¼š123select distinct email, count(email) as cntfrom Persongroup by email åœ¨æ‰¾å‡ºå‡ºçŽ°æ¬¡æ•°å¤§äºŽ 2 çš„é‚®ä»¶åœ°å€ï¼š1234567select email as emailfrom ( select distinct email, count(email) as cnt from Person group by email) as twhere t.cnt &gt; 1 å› ä¸º WHERE æ— æ³•ä¸Žèšåˆå‡½æ•°ä¸€èµ·ç”¨ï¼Œä½† HAVING å¯ä»¥ï¼Œé‚£å°±å­˜åœ¨å¦å¤–ä¸€ç§åšæ³•äº†ï¼š1234select email as Emailfrom Persongroup by Emailhaving count(email) &gt; 1 1050. Actors and Directors Who Cooperated At Least Three TimesAnalysisæ‰¾å‡ºæ¼”å‘˜ä¸Žå¯¼æ¼”åˆä½œæ¬¡æ•°å¤§äºŽ 3 æ¬¡çš„ä¸€å¯¹æ¼”å‘˜ id ä¸Žå¯¼æ¼” idã€‚ Codeæ€è·¯è·Ÿä¸Šä¸ªé¢˜ä¸€æ ·ï¼š1234567select actor_id, director_idfrom ( select actor_id, director_id, count(director_id) as cnt from ActorDirector as ad group by actor_id, director_id) as twhere t.cnt &gt; 2 1234select actor_id, director_idfrom ActorDirector as adgroup by actor_id, director_idhaving count(director_id) &gt; 2 1587. Bank Account Summary IIAnalysisæ‰¾å‡ºä½™é¢å¤§äºŽ 10000 çš„äººã€‚ Codeå…ˆç»Ÿè®¡è´¦æˆ·çš„æ€»å…±ä½™é¢ï¼š123select account, sum(amount) as balancefrom Transactionsgroup by account æŽ¥ç€ç”¨å·¦è¿žæŽ¥æŸ¥è¯¢ä½™é¢å¤§äºŽ 10000 çš„ç”¨æˆ·ä¸Žå¯¹åº”ä½™é¢ï¼š12345678select name, balancefrom Users as uleft join ( select account, sum(amount) as balance from Transactions group by account) as ton t.balance &gt; 10000 and t.account = u.account æ­¤æ—¶å¾—åˆ°çš„ç»“æžœæ˜¯æ‰€æœ‰äººçš„åå­—ï¼Œä½™é¢å°‘äºŽ 10000 çš„ä½™é¢æ åˆ™ä¼šå¡«å…¥ nullï¼Œå®žé™…ä¸Šè¿™æ˜¯è¿žæŽ¥å¯¼è‡´çš„ç¬›å¡å°”ç§¯ï¼Œæ‰€ä»¥å¾—å†æ¬¡æŸ¥è¯¢ä¸€ä¸‹ï¼š123456789101112select name as NAME, balance as BALANCEfrom ( select name, balance from Users as u left join ( select account, sum(amount) as balance from Transactions group by account ) as t on t.balance &gt; 10000 and t.account = u.account) as awhere balance is not null å®žé™…ä¸Šå¯ä»¥å†™çš„æ›´ç®€å•ä¸€ç‚¹ï¼š123456789select name, balancefrom Users as uleft join ( select account, sum(amount) as balance from Transactions group by account) as ton t.account = u.accountwhere balance &gt; 10000 1084. Sales Analysis IIIAnalysisè·Ÿå‰é¢å‡ ä¸ªé¢˜å·®ä¸å¤šï¼Œä½†æ˜¯éº»çƒ¦çš„åœ°æ–¹åœ¨äºŽéœ€è¦åˆ¤æ–­ä¸€ä¸‹â€œä»…â€ã€‚ Codeä¸ºäº†åˆ¤æ–­å”¯ä¸€æ€§ï¼Œå¯ä»¥ç”¨ MAX å’Œ MIN å‡½æ•°æ¥å®Œæˆï¼š123456select product_id, product_namefrom Sales as sjoin Product as pon s.product_id = p.product_idgroup by s.product_idhaving min(sale_date) &gt;= '2019-01-01' and max(sale_date) &lt;= '2019-03-31' Summaryè¯è¯´ï¼Œæ„Ÿè§‰ä»Šå¤©åšçš„å‡ ä¸ªé¢˜éƒ½æ¯”è¾ƒç®€å•ï¼Œå¯èƒ½æ˜¯å·²ç»åšäº†ä¸€äº›é¢˜ï¼Œç†Ÿæ‚‰äº†çš„ç¼˜æ•…ã€‚è¯è¯´ï¼ŒçœŸå¿«å•Šï¼Œè¿™ä¸ªä¹Ÿåšå®Œäº†ï¼Œä¸è¿‡ï¼Œè¿™äº›ä¸œè¥¿æ„Ÿè§‰å¥½åƒå¾ˆå®¹æ˜“å¿˜è®°ï¼Œå¥½åƒå·²ç»æœ‰ç‚¹è®°ä¸æ¸…å‰å‡ å¤©åšçš„ä»€ä¹ˆé¢˜äº†ðŸ˜‚ã€‚æ€»ä¹‹ï¼Œè¿˜æ˜¯è¦å¤šå¤ä¹ å¤ä¹ ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day9]]></title>
    <url>%2F2022%2F04%2F28%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ä¸»é¢˜æ˜¯æŽ§åˆ¶æµã€‚ 1393. Capital Gain/LossAnalysisæŒ‰ç…§ä¹°å–çš„ä¸åŒä»·æ ¼ï¼Œç®—å‡ºè‚¡ç¥¨çš„æ€»ç›ˆåˆ©ã€‚ Codeä¸€å¼€å§‹æƒ³é€šè¿‡è¿žæŽ¥æŸ¥è¯¢ç„¶åŽå†åšå·®æ±‚å’Œå¾—åˆ°ç»“æžœï¼Œç»“æžœè¿žæŽ¥è¿‡ç¨‹ä¸­æ¶ˆé™¤ä¸æŽ‰ç¬›å¡å°”ç§¯ï¼Œåªèƒ½å°è¯•å…¶ä»–æ€è·¯äº†ã€‚123select stock_name, sum(if(operation = 'Sell', price, 0)) - sum(if(operation = 'Buy', price, 0)) as capital_gain_lossfrom Stocksgroup by stock_name å†å›žå¤´çœ‹è¿™é“é¢˜çš„æ€è·¯ï¼Œæžœç„¶æ˜¯å¯¹åº”æŽ§åˆ¶æµçš„ä¸»é¢˜å•Šã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜ç”¨ CASE WHEN ä¹Ÿæ˜¯å¯ä»¥è§£å†³çš„ï¼š123select stock_name, sum(case operation when 'Sell' then price else -price end) as capital_gain_lossfrom Stocksgroup by stock_name 1407. Top TravellersAnalysisç®—å‡ºæ¯ä¸ªäººçš„æ—…è¡Œæ€»è·¯ç¨‹ã€‚ CodeæŒ‰ç…§ä¸Šä¸€é¢˜çš„ç±»ä¼¼çš„æ€è·¯ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š12345select name, sum(distance) as travelled_distancefrom Users as u, Rides as rwhere u.id = r.user_idgroup by nameorder by travelled_distance desc, name ä½†æ˜¯çŽ°åœ¨æœ‰ä¸€ä¸ªé—®é¢˜ï¼Œæœ‰ä¸€ä¸ªäººçš„è·¯ç¨‹æ˜¯ 0ï¼Œè¿™ä¸ªæ²¡æŸ¥è¯¢å‡ºæ¥ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªé¢˜éœ€è¦ç”¨åˆ°è¿žæŽ¥æŸ¥è¯¢ï¼Œå¹¶ä¸”åœ¨æŸä¸ªè¡¨ä¸­æ²¡æœ‰åŒ¹é…æ—¶ï¼Œè¿”å›ž 0ã€‚é‚£ä¹ˆï¼Œä¸å¦¨ç”¨å·¦è¿žæŽ¥æ¥åšè¿™ä¸ªäº‹æƒ…ï¼š123456select name, ifnull(sum(distance), 0) as travelled_distancefrom Users as uleft join Rides as ron u.id = r.user_idgroup by nameorder by travelled_distance desc, name 1158. Market Analysis IAnalysisç»™äº† 3 ä¸ªè¡¨ï¼Œé¢˜æ„æ˜¯æ±‚å‡º 2019 å¹´å†…å‘˜å·¥çš„è®¢å•æ•°ï¼Œå¹¶ä¸”ç»™å‡ºå‘˜å·¥å…¥èŒæ—¥æœŸï¼ŒåŒæ—¶æ²¡æœ‰è®¢å•çš„éœ€è¦è¿”å›ž 0ã€‚ Codeå…ˆç»Ÿè®¡å‡ºè®¢å•æ•°ï¼š1234select buyer_id, count(order_id) as cntfrom Orders as owhere o.order_date &gt;= '2019-01-01' and o.order_date &lt;= "2019-12-31"group by buyer_id ç„¶åŽç”¨ LEFT JOIN è¿žæŽ¥æŸ¥è¯¢ï¼Œæ²¡æœ‰åŒ¹é…å°±è¿”å›ž 0ï¼š123456789select u.user_id as buyer_id, join_date, ifnull(t1.cnt, 0) as orders_in_2019from Users as uleft join ( select buyer_id, count(order_id) as cnt from Orders as o where o.order_date &gt;= '2019-01-01' and o.order_date &lt;= "2019-12-31" group by buyer_id) as t1on u.user_id = t1.buyer_id Summaryè¿žæŽ¥æŸ¥è¯¢ç”¨çš„ä¸æ˜¯å¾ˆç†Ÿç»ƒ...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day8]]></title>
    <url>%2F2022%2F04%2F27%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[è¿˜æ˜¯è®¡ç®—å‡½æ•°å“ˆ~ 586. Customer Placing the Largest Number of OrdersAnalysisæŒ‘å‡ºè®¢å•æ•°æœ€å¤šçš„é¡¾å®¢å³å¯ã€‚ Codemethod 1å…ˆç»Ÿè®¡å‡ºç›¸åŒ customer_number æ‹¥æœ‰çš„ä¸åŒçš„ order_number çš„ä¸ªæ•°ï¼š123select distinct customer_number, count(order_number) as order_numberfrom Ordersgroup by customer_number æŒ‰ order_number çš„ä¸ªæ•°å€’åºæŽ’åˆ—ï¼š1234select distinct customer_number, count(order_number) as order_numberfrom Ordersgroup by customer_numberorder by order_number desc å¯ä»¥å‘çŽ°ï¼Œç¬¬ä¸€è¡Œå°±æ˜¯è¦çš„ç­”æ¡ˆäº†ï¼Œæ­¤æ—¶å†ä»Žè¿™ä¸ªè¡¨ä¸­æŒ‘å‡ºéœ€è¦çš„ä¿¡æ¯ï¼š12345678select customer_numberfrom ( select distinct customer_number, count(order_number) as order_number from Orders group by customer_number order by order_number desc ) as t1limit 1 å®žé™…ä¸Šå¯ä»¥å†™çš„æ›´ç®€å•ä¸€ç‚¹ï¼š12345select distinct customer_numberfrom Ordersgroup by customer_numberorder by count(order_number) desclimit 1 method 2åœ¨ç»Ÿè®¡å‡º order_number çš„ä¸ªæ•°åŽï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥æŒ‘å‡ºæœ€å¤§å€¼ï¼š1234567select customer_numberfrom ( select distinct customer_number, count(order_number) as order_number from Orders group by customer_number ) as t1where t1.order_number = (select max(order_number) from t1) ä½†é—æ†¾çš„æ˜¯ï¼Œè¿™æ ·å†™ä¼šæŠ¥é”™ï¼ŒåŽŸå› æ˜¯ä¸åˆè¯­æ³•ã€‚å®žé™…ä¸Šï¼Œè¿™æ˜¯ä¸€ä¸ªæ‰§è¡Œé¡ºåºçš„é—®é¢˜ã€‚åœ¨ SQL ä¸­ï¼ŒWHERE æ˜¯å…ˆäºŽ SELECT æ‰§è¡Œï¼Œä¹Ÿå°±æ˜¯è¯´ SQL server åœ¨æ‰§è¡Œè¯­å¥çš„æ—¶å€™ï¼Œå®ƒä¸çŸ¥é“ t1 æ˜¯ä»€ä¹ˆï¼Œå°±æ²¡åŠžæ³•æ‰§è¡Œäº†ï¼ˆæœ‰ç‚¹æ— åŠ›åæ§½ SQL å¥‡å¥‡æ€ªæ€ªçš„è¯­æ³•äº†ðŸ˜‘ï¼‰ã€‚å¦‚æžœè¿˜æƒ³è¦ç”¨è¿™ä¸ªæ€è·¯æ¥è§£å†³é—®é¢˜ï¼Œå°±å¾—å…ˆå°† order_number çš„ä¸ªæ•°ç»Ÿè®¡å‡ºæ¥ï¼Œå°±éœ€è¦ç”¨åˆ° WITH AS äº†ã€‚1234with t1 as (select customer_number, count(order_number) as order_number from Orders group by customer_number)select customer_numberfrom t1where t1.order_number = (select max(order_number) from t1) 511. Game Play Analysis IAnalysisæ‰¾å‡ºç”¨æˆ·çš„æœ€æ—©æ³¨å†Œæ—¥æœŸã€‚ Code123select distinct player_id, min(event_date) as first_loginfrom Activitygroup by player_id emï¼Œè¿™ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œæœ¬ä»¥ä¸ºæœ€å°æ—¥æœŸä¸èƒ½ç›´æŽ¥ç”¨ MIN å‡½æ•°ï¼Œæ²¡æƒ³åˆ°å¯ä»¥ç”¨ã€‚ 1890. The Latest Login in 2020Analysisæ‰¾å‡ºåœ¨ 2020 å¹´å†…ç”¨æˆ·çš„æœ€åŽä¸€æ¬¡ç™»å½•ä¿¡æ¯ã€‚ Codemethod 1æ‰¾å‡ºæœ€åŽçš„ä¸€æ¬¡ä¿¡æ¯ï¼Œå¯ä»¥å€ŸåŠ© MAX å‡½æ•°ï¼Œé™å®š 2020 å¹´å†…ï¼Œå¯ä»¥å€ŸåŠ© WHEREã€‚1234select distinct user_id, max(time_stamp) as last_stampfrom Loginswhere time_stamp &gt;= '2020-01-01 00:00:00' and time_stamp &lt; '2021-01-01 00:00:00'group by user_id method 2å®žé™…ä¸Šï¼Œé™å®šå¹´ä»½çš„æ—¶å€™ï¼Œå¯ä»¥å€ŸåŠ©æ—¥æœŸå‡½æ•° YEARã€‚1234select user_id, max(time_stamp) as last_stampfrom Loginswhere year(time_stamp) = 2020group by user_id 1741. Find Total Time Spent by Each EmployeeAnalysisæ‰¾å‡ºä¸åŒæ—¥æœŸï¼Œä¸åŒäººå¾…åœ¨åŠžå…¬å®¤çš„æ€»æ—¶é—´ã€‚ Codeå…ˆæ±‚å‡ºæ¯ä¸ªäººç•™åœ¨åŠžå…¬å®¤çš„æ—¶é—´ï¼Œç”¨ out_time å‡åŽ» in_time å³å¯ã€‚12select event_day, emp_id, (out_time - in_time) as difffrom Employees ç„¶åŽç®—å‡ºæ€»å’Œï¼ŒæŒ‰ç…§ä¸åŒçš„äººå’Œä¸åŒçš„æ—¥æœŸå°†ç»“æžœé›†ç»„åˆåˆ°ä¸€èµ·ã€‚123456select distinct event_day as day, emp_id, sum(diff) as total_timefrom ( select event_day, emp_id, (out_time - in_time) as diff from Employees ) as t1group by event_day, emp_id ä¹Ÿå¯ä»¥å†™çš„æ›´ç®€å•ä¸€ç‚¹ï¼š123select distinct event_day as day, emp_id, sum(out_time - in_time) as total_timefrom Employeesgroup by event_day, emp_id Summaryé™¤äº†ç¬¬ä¸€ä¸ªé¢˜çš„ LIMIT æ²¡æƒ³åˆ°å¤–ï¼Œå¦å¤– 3 ä¸ªé¢˜æ¯”è¾ƒç®€å•ã€‚å¦å¤–ï¼Œç¬¬ä¸€ä¸ªé¢˜çš„ç¬¬äºŒç§æ€è·¯æ„Ÿè§‰æ¯”è¾ƒåˆç†ä¸€ç‚¹ï¼ˆå°±å®žé™…è¿ç”¨è€Œè¨€ï¼‰ï¼Œä½†æ˜¯éœ€è¦ç”¨åˆ° WITH ASï¼ŒSQL è¯­æ³•çœŸæ˜¯å¥‡æ€ªå•Šã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day7]]></title>
    <url>%2F2022%2F04%2F26%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[emï¼Œä»Šå¤©çš„ä¸»é¢˜æ˜¯è®¡ç®—å‡½æ•°å•Šã€‚ 1141. User Activity for the Past 30 Days IAnalysisä¸çŸ¥é“ä¸ºä»€ä¹ˆï¼Œæ€»æ˜¯å¾ˆæŠ—æ‹’æè¿°æ•°æ®åº“çš„é¢˜ç›®ã€‚é¢˜ç›®å¤§æ¦‚æ„æ€å°±æ˜¯ç»Ÿè®¡å‡ºæ´»è·ƒç”¨æˆ·ï¼ˆ2019-07-27 å‰ 30 å¤©å†…åªè¦æœ‰ä¸€æ¬¡æ´»åŠ¨çš„éƒ½ç®—æ´»è·ƒç”¨æˆ·ï¼‰äººæ•°ã€‚ Codeé¦–å…ˆè¦æ€è€ƒçš„ç¬¬ä¸€ä¸ªé—®é¢˜æ˜¯å¦‚ä½•æŒ‘å‡ºä¸Ž 2019-07-27 ç›¸å·®ä¸è¶…è¿‡ 30 å¤©çš„æ•°æ®ï¼š123select *from Activity as actwhere datediff(act.activity_date, '2019-07-27')&gt;-30 ä¹Ÿå¯ä»¥å†™æˆï¼š123select *from Activity as actwhere datediff('2019-07-27', act.activity_date)&lt;30 æŽ¥ä¸‹æ¥è¦è§£å†³çš„é—®é¢˜æ˜¯ï¼ŒæŒ‘å‡ºå‡ºä¸åŒçš„æ—¥æœŸï¼š123456select distinct activity_date as dayfrom ( select * from Activity as act where datediff(act.activity_date, '2019-07-27')&gt;-30 ) as t1 æ³¨æ„ï¼Œæ´¾ç”Ÿè¡¨å¿…é¡»è¦å‘½åï¼Œè€Œä¸”å¿…é¡»è¦å†™åœ¨å¤–é¢ã€‚æ­¤æ—¶ï¼Œå¾—åˆ°çš„ç»“æžœåªæœ‰ç¬¦åˆæ¡ä»¶çš„æ—¥æœŸï¼Œè¿˜éœ€è¦ç»Ÿè®¡ä¸åŒ id çš„ç”¨æˆ·ä¸ªæ•°ï¼Œä½¿ç”¨ COUNT å¯ä»¥å®Œæˆç»Ÿè®¡ï¼Œå†ç”¨ GROUP BY ç»„åˆå°±å¯ä»¥äº†ï¼š1234567select distinct activity_date as day, count(distinct user_id) as active_usersfrom ( select * from Activity as act where datediff(act.activity_date, '2019-07-27')&gt;-30 ) as t1group by activity_date emï¼Œå®žé™…ä¸Šï¼Œå¯ä»¥ä¸å†™é‚£ä¹ˆéº»çƒ¦ï¼š1234select activity_date as day, count(distinct user_id) as active_usersfrom Activitywhere datediff('2019-07-27', Activity.activity_date) &lt; 30group by activity_date 1693. Daily Leads and PartnersAnalysisæŒ‰ç…§æ—¥æœŸæ‰¾å‡ºä¸åŒäº§å“é”€å”®æ—¶ä¸åŒçš„ lead_id å’Œ partner_idã€‚ Code123select date_id, make_name, count(distinct lead_id) as unique_leads, count(distinct partner_id) as unique_partnersfrom DailySalesgroup by date_id, make_name å—¯ï¼Œè¿™ä¸ªé¢˜è·Ÿä¸Šä¸ªé¢˜ä¸€æ ·çš„ã€‚ 1729. Find Followers CountAnalysisè¿™ä¸ªé¢˜å¥½åƒæ˜¯æœ€ç®€å•çš„ã€‚ Code1234select user_id, count(distinct follower_id) as followers_countfrom Followersgroup by user_idorder by user_id Summaryæˆ‘å‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æžœè¦æ˜¯ä»Žå®žé™…åŽ»ç†è§£è¿™äº›é¢˜ç›®åšæ³•çš„ç”¨æ„ï¼Œæ— ç–‘æ˜¯æ²¡æœ‰æ„ä¹‰çš„ðŸ˜‚ï¼Œå› ä¸ºæ²¡æ³•æžæ¸…æ¥šè¿™æ ·åšæ˜¯ä¸ºäº†ä»€ä¹ˆã€‚ä½†æ˜¯å‡ºäºŽåšé¢˜å’Œç†Ÿæ‚‰ SQL è¯­æ³•çš„ç›®çš„ï¼ŒæŒ‰ç…§è¦æ±‚åšæŒ‘å‡ºç¬¦åˆæ¡ä»¶çš„æ•°æ®å°±å¥½ã€‚å¦å¤–ï¼ŒæŸ¥è¯¢å¾—åˆ°ä¸åŒçš„ä¿¡æ¯åŽï¼Œéœ€è¦ç”¨ GROUP BY ç»„åˆåˆ°ä¸€èµ·ï¼Œä»Šå¤©çš„ 3 ä¸ªé¢˜éƒ½æ˜¯è¿™æ ·çš„ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day6]]></title>
    <url>%2F2022%2F04%2F25%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©è¿˜æ˜¯åˆå¹¶å‘¢ã€‚ 197. Rising TemperatureAnalysisæ‰¾å‡ºåŽä¸€ä¸ªæ•°æ®æ¯”å‰ä¸€ä¸ªæ•°æ®å¤§çš„æ•°æ®ï¼ˆæˆ‘åœ¨å†™ä»€ä¹ˆçŽ©æ„å‘¢ï¼ŸðŸ˜‚ï¼‰ï¼Œå…¶å®žå°±æ˜¯æ¯”è¾ƒç›¸é‚»çš„æ•°æ®ï¼ŒæŒ‘å‡ºåŽé¢æ¯”å‰é¢å¤§çš„é‚£ä¸ªã€‚ Code123select Weather.idfrom Weatherjoin Weather as w on datediff(Weather.recordDate, w.recordDate) = 1 and Weather.temperature &gt; w.temperature å®žé™…ä¸Šè¿™ä¸ªé¢˜ï¼Œå…¶å®žæ˜¯ä¸€ä¸ªæ—¥æœŸæ¯”è¾ƒçš„é¢˜ï¼Œå½“æ—¥æœŸçš„å·®æ˜¯ 1 çš„æ—¶å€™ï¼Œè¯´æ˜Žæ˜¯ç›¸é‚»çš„ 2 å¤©ã€‚ 607. Sales PersonAnalysisè¿™ä¸ªé¢˜çœŸé•¿ï¼Œç†è§£èµ·æ¥ä¹Ÿä¸å¤ªå®¹æ˜“ã€‚å¤§æ¦‚æ„æ€å°±æ˜¯å°† com_id ä¸º 1 çš„ sales_id çš„ name æŒ‘å‡ºæ¥ï¼ˆæˆ‘åœ¨å†™ä»€ä¹ˆä¸œè¥¿å•ŠðŸ˜‚ï¼‰ã€‚ Code12345678select S.namefrom SalesPerson as Swhere s.sales_id not in ( select O.sales_id from Orders as O left join Company as C on O.com_id = C.com_id where C.name = 'RED') Summaryæˆ‘å‘è§‰è¿™ä¸ªç³»åˆ—çš„æ•°æ®åº“ä¾‹é¢˜æ˜¯çœŸä¸é”™ï¼Œå¥½åƒå·¥ä½œä¸­éƒ½ç”¨çš„åˆ°ï¼Ÿï¼Ÿï¼Ÿ]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day5]]></title>
    <url>%2F2022%2F04%2F24%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ä¸»é¢˜æ˜¯åˆå¹¶å‘¢ï¼Œæ„Ÿè§‰å¥½åƒä¼šç”¨åˆ° UNIONã€‚ 175. Combine Two TablesAnalysiså°†ä¸¤ä¸ªè¡¨è¿žæŽ¥ï¼Œè¿›è¡Œç»„åˆæŸ¥è¯¢ã€‚ Code123select firstName, lastName, city, statefrom Person left join Addresson Person.personId = Address.personId 1581. Customer Who Visited but Did Not Make Any TransactionsAnalysisæ‰¾å‡ºåªå‡ºçŽ°åœ¨ Visits å†…è€Œä¸å‡ºçŽ°åœ¨ Transactions å†…çš„ visit_idï¼ŒåŒæ—¶ç›¸åŒ customer_id çš„ä¸ªæ•°ã€‚ Codemethod 1å¯ä»¥ä½¿ç”¨ GROUP BY æ¥å°†ä¸¤ä¸ªæŸ¥è¯¢çš„ç»“æžœç»„åˆèµ·æ¥ã€‚1234select customer_id, count(customer_id) as count_no_transfrom Visitswhere Visits.visit_id not in (select visit_id from Transactions)group by customer_id method 2ä¹Ÿå¯ä»¥è¿žæŽ¥æŸ¥è¯¢åœ¨ç»„åˆã€‚12345select customer_id, count(customer_id) as count_no_transfrom Visits left join Transactionson Visits.visit_id = Transactions.visit_idwhere amount is nullgroup by customer_id 1148. Article Views IAnalysisæ‰¾å‡ºè‡ªå·±çœ‹è¿‡è‡ªå·±æ–‡ç« çš„ä½œè€…ï¼Œé‡å¤å‡ºçŽ°çš„ï¼Œåªåˆ—å‡º 1 æ¬¡è®°å½•ï¼Œæ„Ÿè§‰è¿™ä¸ªä»Šå¤©æœ€ç®€å•çš„é¢˜äº†ã€‚ Code1234select distinct viewer_id as idfrom Viewswhere Views.author_id = Views.viewer_idorder by id Summaryè¿˜æ˜¯ä¸ç†Ÿæ‚‰å•Šã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day4]]></title>
    <url>%2F2022%2F04%2F23%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[çœ‹äº†ä¸‹ä»Šå¤©çš„ä¸»é¢˜ï¼šç»„åˆæŸ¥è¯¢å’ŒæŒ‡å®šé€‰å–ï¼Œæ„Ÿè§‰æœ‰ç‚¹å¤æ‚ã€‚ 1965. Employees With Missing InformationAnalysisæ‰¾å‡ºç¼ºå¤±ä¿¡æ¯çš„æ•°æ®ï¼Œéœ€è¦ 2 ä¸ªè¡¨ä¸€èµ·ç»„åˆæŸ¥è¯¢ã€‚å®žé™…ä¸Šï¼Œå°±æ˜¯æŒ‘å‡º 2 ä¸ªè¡¨ä¸­åªå‡ºçŽ°äº† 1 æ¬¡çš„ employee_idã€‚ Code123456789select employee_idfrom ( select employee_id from Employees union all select employee_id from Salaries) as ansgroup by employee_idhaving count(employee_id) = 1order by employee_id 1795. Rearrange Products TableAnalysisè¿™ä¸ªé¢˜æ˜¯éœ€è¦å°†è¡¨çš„æ•°æ®é‡æ–°æŽ’åˆ—ï¼Œæœ‰ç‚¹åƒæ˜¯åœ¨åšè¡Œåˆ—è½¬æ¢ã€‚ Codeå®žé™…ä¸Šæ˜¯è¡Œåˆ—è½¬æ¢ï¼Œç„¶åŽå†ç»„åˆæˆä¸€å¼ è¡¨ã€‚1234567891011select product_id, 'store1' as store, store1 as pricefrom Productswhere store1 is not nullunion allselect product_id, 'store2' as store, store2 as pricefrom Productswhere store2 is not nullunion allselect product_id, 'store3' as stroe, store3 as pricefrom Productswhere store3 is not null 608. Tree NodeAnalysisSQL ä¸Ž æ ‘çš„ç»“åˆé¢˜ï¼Ÿ Codemethod 1ç¬¬ä¸€ç§æ–¹æ³•æ˜¯åˆ†åˆ«æŒ‘å‡º 3 ç§ä¸åŒçš„ç»“ç‚¹ï¼Œç„¶åŽç»„åˆåˆ°ä¸€èµ·ã€‚1234567891011121314151617181920212223select id, 'Root' as typefrom Treewhere p_id is nullunionselect id, 'Leaf' as typefrom Treewhere id not in ( select distinct p_id from Tree where p_id is not null) and p_id is not nullunionselect id, 'Inner' as typefrom Treewhere id in ( select distinct p_id from tree where p_id is not null) and p_id is not null method 2å¯ä»¥ä½¿ç”¨ CASE WHEN æ¥ç²¾ç®€ä¸€ä¸‹ä»£ç ï¼š12345678910select id as 'id', case when tree.id = (select atree.id from tree atree where atree.p_id is null) then 'Root' when tree.id in (select atree.p_id from tree atree) then 'Inner' else 'Leaf' end as typefrom treeorder by 'id' method 3è¿˜å¯ä»¥ä½¿ç”¨ IF å‡½æ•°ï¼š123456select atree.id, if(isnull(atree.p_id), 'Root', if(atree.id in (select p_id from tree), 'Inner', 'Leaf')) typefrom tree atreeorder by atree.id 176. Second Highest SalaryAnalysisé¢˜æ„å¾ˆç®€å•ï¼Œæ‰¾å‡ºç¬¬äºŒå°çš„å€¼ã€‚æ€Žä¹ˆè¿™ç§é¢˜ï¼Œä¸€é“æ•°æ®åº“äº†ï¼Œå°±æ„Ÿè§‰è¿™ä¹ˆéš¾åšå‘¢ï¼Ÿ Codemethod 1å¯ä»¥ä½¿ç”¨ LIMIT OFFSET æ¥å®Œæˆå–ç¬¬äºŒçš„æ“ä½œã€‚ä½†æ˜¯ï¼Œå¦‚æžœåªæœ‰ä¸€ä¸ªæ•°æ®ï¼Œç»“æžœå°±æ˜¯ NULL äº†ã€‚æ‰€ä»¥ï¼Œéœ€è¦å°†ç¬¬ä¸€ä¸ªè¡¨ä½œä¸ºä¸´æ—¶è¡¨ã€‚123456select ( select distinct salary from Employee order by salary desc limit 1 offset 1 ) as SecondHighestSalary method 2ä¹Ÿå¯ä»¥ä½¿ç”¨ IFNULL ç›´æŽ¥è¿”å›ž NULLï¼š12345select ifnull( (select distinct salary from Employee order by salary desc limit 1 offset 1), null) as SecondHighestSalary Summaryæ€Žä¹ˆæ„Ÿè§‰æœ‰ç‚¹éš¾å‘¢ï¼Ÿè¿˜æ˜¯ç”¨çš„å°‘äº†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day3]]></title>
    <url>%2F2022%2F04%2F22%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[æ„Ÿè§‰ SQL çš„é¢˜ç›®éƒ½æŒºå®¹æ˜“çš„... 1667. Fix Names in a TableAnalysisè¿™ä¸ªé¢˜æ˜¯åœ¨è€ƒå¯Ÿå¦‚ä½•ä¿®æ”¹æ•°æ®ï¼Œå¹¶ä¸”éœ€è¦å°†é¦–å­—ç¬¦ä¸Žå‰©ä½™å­—ç¬¦åšåŒºåˆ†ã€‚ Code123select user_id, concat(upper(left(name, 1)), lower(substring(name, 2))) as name from Usersorder by user_id 1484. Group Sold Products By The DateAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹éº»çƒ¦ï¼Œéœ€è¦ä¾æ¬¡è§£å†³ 3 ä¸ªé—®é¢˜ï¼š é€‰å‡ºä¸åŒçš„æ—¥æœŸ æŒ‰ç…§ä¸åŒæ—¥æœŸç»Ÿè®¡å–å‡ºçš„å•†å“ç±»åž‹ å°†ä¸åŒæ—¥æœŸå–å‡ºçš„æ‰€æœ‰å•†å“åˆå¹¶æˆä¸€ä¸ªå­—ç¬¦ä¸² Code1234select distinct sell_date, count(distinct product) as num_sold, group_concat(distinct product) as productsfrom Activitiesgroup by sell_dateorder by sell_date 1527. Patients With a ConditionAnalysisæŒ‘å‡ºå«æœ‰å«æœ‰ç‰¹å®šå­ä¸²çš„è¡Œã€‚ Code123select patient_id, patient_name, conditionsfrom Patientswhere conditions regexp '^DIAB1|\\sDIAB1' å…¶ä¸­çš„\\så°±æ˜¯ç©ºæ ¼ï¼Œæ‰€ä»¥ç”¨ç©ºæ ¼ä»£æ›¿ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ Summaryæ¯å¤©éƒ½ç†Ÿæ‚‰ä¸€ç‚¹æ•°æ®åº“çš„ç”¨æ³•ï¼Œæ±—ðŸ˜“ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day2]]></title>
    <url>%2F2022%2F04%2F21%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[ç»§ç»­ï¼Œç»§ç»­ã€‚ 1873. Calculate Special BonusAnalysisæŒ‘å‡ºæ»¡è¶³ä¸¤ä¸ªæ¡ä»¶çš„æ•°æ®ï¼š name ä¸æ˜¯ä»¥ M å¼€å¤´ id æ˜¯å¥‡æ•° Code123select employee_id, if(employee_id % 2 = 0 or name like 'M%', 0, salary) as bonusfrom Employees 627. Swap SalaryAnalysissex ä¸º m å°±æ”¹ä¸º fï¼Œä¸º f å°±æ”¹ä¸º mã€‚ Codemethod 11update Salary set sex = if(sex = 'm', 'f', 'm') method 2ä¹Ÿå¯ä»¥ç”¨ CASE WHEN æ¥å®Œæˆã€‚123456update Salaryset sex = CASE sex WHEN 'm' THEN 'f' ELSE 'm' END; 196. Delete Duplicate EmailsAnalysisåˆ é™¤é‡å¤å…ƒç´ å³å¯ã€‚ Codemethod 1123delete p1.*from Person p1, Person p2where p1.Email = p2.Email and p1.id &gt; p2.id method 2å¦‚æžœè¿™ä¸ªé¢˜ä¸é™åˆ¶ select çš„è¯ï¼Œå…¶å®žè¿˜æœ‰å¦å¤–ä¸€ç§æ–¹æ³•ï¼š12delete from Personwhere id not in (select dt.id from (select min(id) as id from Person group by email) dt) Summaryä»Šå¤©çš„å†…å®¹ä¸»è¦æ˜¯åˆ é™¤å’Œä¿®æ”¹çš„å†…å®¹ï¼Œä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä¸»è¦è¿˜æ˜¯ç†Ÿæ‚‰åŸºæœ¬ç”¨æ³•ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL çš„ä¸€äº›åŸºç¡€çŸ¥è¯†ç‚¹]]></title>
    <url>%2F2022%2F04%2F20%2FSQL-%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[è®°å½•ä¸€ä¸‹ SQL çš„ä¸€äº›ç›¸å…³çŸ¥è¯†ã€‚ ConceptSQLï¼Œå…¨ç§° Structured Query Languageï¼Œç›´è¯‘å°±æ˜¯ç»“æž„åŒ–çš„æŸ¥è¯¢è¯­è¨€ã€‚æŒ‰ç…§ç™¾åº¦ç™¾ç§‘çš„è§£é‡Šï¼Œè¿™æ˜¯ä¸€ç§ç‰¹æ®Šç›®çš„çš„ç¼–ç¨‹è¯­è¨€ï¼Œæ˜¯ä¸€ç§æ•°æ®åº“æŸ¥è¯¢å’Œç¨‹åºè®¾è®¡è¯­è¨€ã€‚ç›®å‰ï¼Œå¯¹å®ƒçš„è®¤è¯†åˆ°è¿™é‡Œå°±å¯ä»¥äº†ã€‚ Compositionä¸€ä¸ªæ•°æ®åº“é€šå¸¸åŒ…å«ä¸€ä¸ªæˆ–å¤šä¸ªè¡¨ã€‚æ¯ä¸ªè¡¨ç”±ä¸€ä¸ªåå­—æ ‡è¯†ï¼ˆæœ‰ç‚¹åƒå˜é‡ï¼‰ï¼Œè¡¨å†…åŒ…å«å¸¦æœ‰æ•°æ®çš„è®°å½•ï¼Œä½¿ç”¨ SQL è¯­å¥å°±å¯ä»¥å¯¹è¿™äº›æ•°æ®è¿›è¡Œå¢žã€åˆ ã€æ”¹ã€æŸ¥ã€‚ SQL LanguageSQL å¯ä»¥åˆ†æˆä¸¤ä¸ªéƒ¨åˆ†ï¼šæ•°æ®æ“ä½œè¯­è¨€ï¼ˆDMLï¼‰å’Œæ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰ã€‚æ³¨æ„ï¼ŒSQL å¯¹å¤§å°å†™ä¸æ•æ„Ÿï¼æŸ¥è¯¢å’Œæ›´æ–°æŒ‡ä»¤æž„æˆäº† SQL çš„ DML éƒ¨åˆ†ï¼ŒåŒ…æ‹¬ï¼šSELECTã€UPDATEã€DELETEã€INSERT INTO ç­‰ã€‚æ•°æ®å®šä¹‰è¯­è¨€ï¼ˆDDLï¼‰ä½¿ç”¨æˆ·å¯ä»¥åˆ›å»ºæˆ–åˆ é™¤è¡¨æ ¼ï¼Œæˆ–è€…æ˜¯å®šä¹‰ç´¢å¼•ï¼ˆé”®ï¼‰ï¼Œè§„å®šè¡¨ä¹‹é—´çš„é“¾æŽ¥ï¼Œä»¥åŠæ–½åŠ è¡¨é—´çš„çº¦æŸã€‚è¿™ç±»è¯­å¥åŒ…æ‹¬ï¼šCREATE DATABASEã€ALTER DATABASEã€CREATE TABLEã€ALTER TABLEã€DROP TABLEã€CREATE INDEXã€DROP INDEX ç­‰ã€‚ SELECTSELECT è¯­å¥ç”¨äºŽä»Žè¡¨ä¸­é€‰å–æ•°æ®ã€‚123SELECT åˆ—åç§° FROM è¡¨åç§°SELECT * FROM è¡¨åç§°SELECT name1,name2 FROM è¡¨åç§° DISTINCTDISTINCT ç®—æ˜¯ä¸€ä¸ªå…³é”®è¯ï¼Œç”¨äºŽè¿”å›žå”¯ä¸€ä¸åŒçš„å€¼ï¼Œå¯ä»¥ç”¨æ¥ä¿®é¥° SELECTã€‚1SELECT DISTINCT åˆ—åç§° FROM è¡¨åç§° WHEREå¦‚æžœéœ€è¦æœ‰æ¡ä»¶åœ°ä»Žè¡¨ä¸­é€‰å–æ•°æ®ï¼Œå¯å°† WHERE å­å¥æ·»åŠ åˆ° SELECT è¯­å¥ã€‚1SELECT åˆ—åç§° FROM è¡¨åç§° WHERE åˆ— è¿ç®—ç¬¦ å€¼ WHERE èƒ½ä½¿ç”¨çš„è¿ç®—ç¬¦åŒ…æ‹¬ä»¥ä¸‹å‡ ç§ï¼š æ“ä½œç¬¦ æè¿° = ç­‰äºŽ &lt;&gt; ä¸ç­‰äºŽ &gt; å¤§äºŽ &lt; å°äºŽ &gt;= å¤§äºŽç­‰äºŽ &lt;= å°äºŽç­‰äºŽ BETWEEN åœ¨æŸä¸ªèŒƒå›´å†… LIKE æœç´¢æŸç§æ¨¡å¼ æ³¨æ„ï¼šåœ¨æŸäº›ç‰ˆæœ¬çš„ SQL ä¸­ï¼Œ&lt;&gt; ä¹Ÿå¯ä»¥å†™æˆ !=ã€‚ä¸€èˆ¬è¯­æ³•ï¼š1SELECT * FROM è¡¨åç§° WHERE åˆ—åç§°='xxx' æ³¨æ„ï¼šSQL ä½¿ç”¨å•å¼•å·æ¥çŽ¯ç»•æ–‡æœ¬å€¼ï¼ˆå¤§éƒ¨åˆ†æ•°æ®åº“ç³»ç»Ÿä¹ŸæŽ¥å—åŒå¼•å·ï¼‰ï¼Œæ•°æ®å°±ä¸ç”¨ä½¿ç”¨å¼•å·äº†ã€‚ AND &amp; ORAND å’Œ OR è¿ç®—ç¬¦(æ²¡é”™ï¼Œè¿™æ˜¯ä¿©è¿ç®—ç¬¦ï¼Œè‡³å°‘åœ¨ SQL é‡Œé¢æ˜¯çš„)ç”¨äºŽåŸºäºŽä¸€ä¸ªä»¥ä¸Šçš„æ¡ä»¶å¯¹è®°å½•è¿›è¡Œè¿‡æ»¤ã€‚ä¸€èˆ¬è¯­æ³•ï¼š12SELECT * FROM è¡¨åç§° WHERE åˆ—åç§°='xxx' OR\AND åˆ—åç§°='xxx'SELECT * FROM è¡¨åç§° WHERE (åˆ—åç§°='x' OR åˆ—åç§°='y') AND åˆ—åç§°='z' ORDER BYORDER BY è¯­å¥ç”¨äºŽæ ¹æ®æŒ‡å®šçš„åˆ—å¯¹ç»“æžœé›†è¿›è¡ŒæŽ’åºï¼Œé»˜è®¤æŒ‰ç…§å‡åºå¯¹è®°å½•è¿›è¡ŒæŽ’åºã€‚å¦‚æžœå¸Œæœ›æŒ‰ç…§é™åºå¯¹è®°å½•è¿›è¡ŒæŽ’åºï¼Œå¯ä»¥ä½¿ç”¨ DESC å…³é”®å­—ã€‚ä¸€èˆ¬è¯­æ³•ï¼š1234SELECT åˆ—åç§° FROM è¡¨åç§° ORDER BY åˆ—åç§°SELECT åˆ—åç§° FROM è¡¨åç§° ORDER BY åˆ—åç§°1,åˆ—åç§°2SELECT åˆ—åç§° FROM è¡¨åç§° ORDER BY åˆ—åç§° DESCSELECT åˆ—åç§° FROM è¡¨åç§° ORDER BY åˆ—åç§°1 DESC,åˆ—åç§°2 ASC INSERT INTOINSERT INTO ç”¨äºŽå‘è¡¨æ ¼ä¸­æ’å…¥æ–°çš„è¡Œï¼Œä¸€èˆ¬è¯­æ³•ï¼š12INSERT INTO è¡¨åç§° VALUES (å€¼1, å€¼2,...)INSERT INTO è¡¨åç§° (åˆ—1, åˆ—2,...) VALUES(å€¼1,å€¼2,...) UPDATEUPDATE è¯­å¥ç”¨äºŽä¿®æ”¹è¡¨ä¸­çš„æ•°æ®ï¼Œä¸€èˆ¬è¯­æ³•ï¼š12UPDATE è¡¨åç§° SET åˆ—åç§° = æ–°å€¼ WHERE åˆ—åç§° = æŸå€¼UPDATE è¡¨åç§° SET åˆ—åç§° = æ–°å€¼,... WHERE åˆ—åç§° = æŸå€¼ DELETEDELETE è¯­å¥ç”¨äºŽåˆ é™¤è¡¨ä¸­çš„è¡Œï¼Œä¸€èˆ¬è¯­æ³•ï¼š1DELETE FROM è¡¨åç§° WHERE åˆ—åç§° = å€¼ å¦‚æžœéœ€è¦åˆ é™¤æ‰€æœ‰è¡Œï¼Œå¯ä»¥å†™æˆï¼š12DELETE FROM è¡¨åç§°DELETE * FROM è¡¨åç§° æ­¤æ—¶ï¼Œè¡¨çš„ç»“æž„ã€å±žæ€§å’Œç´¢å¼•éƒ½æ˜¯å®Œæ•´çš„ã€‚ é€šé…ç¬¦é€šé…ç¬¦çš„ä½œç”¨æœ‰ç‚¹ç±»ä¼¼æ­£åˆ™è¡¨è¾¾å¼ï¼Œéœ€è¦ä¸Ž LIKE è¿ç®—ç¬¦ä¸€èµ·ä½¿ç”¨ï¼ŒåŒ…å«ä»¥ä¸‹å‡ ç§ï¼š é€šé…ç¬¦ æè¿° % ä»£è¡¨é›¶ä¸ªæˆ–å¤šä¸ªå­—ç¬¦ - ä»…æ›¿ä»£ä¸€ä¸ªå­—ç¬¦ [charlist] å­—ç¬¦åˆ—ä¸­çš„ä»»ä½•å•ä¸€å­—ç¬¦ [^charlist] æˆ–è€… [!charlist] ä¸åœ¨å­—ç¬¦ä¸­çš„ä»»ä½•å•ä¸€å­—ç¬¦ ä¸€èˆ¬è¯­æ³•ï¼š123456789101112# é€‰å‡ºå­˜åœ¨ä»¥ xx å¼€å¤´çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE 'xx%'# é€‰å‡ºå­˜åœ¨åŒ…å« xx çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE '%xx%'# é€‰å‡ºå­˜åœ¨ç¬¬ä¸€ä¸ªå­—ç¬¦åŽæ˜¯ xx çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE '_xx%'# é€‰å‡ºå­˜åœ¨å½¢å¦‚ X_x çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE 'X_x%'# é€‰å‡ºå­˜åœ¨ X/Y/Z å¼€å¤´çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE '[XYZ]%'# é€‰å‡ºä¸å­˜åœ¨ X/Y/Z å¼€å¤´çš„åˆ—çš„è¡ŒSELECT * FROM è¡¨åç§° WHERE åˆ—åç§° LIKE '[!XYZ]%' IFIF ç”¨æ¥æž„æˆæ¡ä»¶è¡¨è¾¾å¼ï¼Œä¸€èˆ¬è¯­æ³•ï¼š12# expr1 ä¸º trueï¼Œè¿”å›žå€¼ä¸º expr2, å¦åˆ™ä¸º expr3IF(expr1, expr2, expr3) IFNULLä½œç”¨ç±»ä¼¼ IFï¼Œä¸€èˆ¬è¯­æ³•ï¼š12# expr1 ä¸ä¸º null æ—¶ï¼Œè¿”å›ž expr1ï¼Œå¦åˆ™è¿”å›ž expr2IFNULL(expr1, expr2) ASç®€å•æ¥è®²ï¼ŒAS å°±æ˜¯ç”¨æ¥ä¿®æ”¹åå­—çš„ï¼Œä¸€èˆ¬è¯­æ³•ï¼š12# SELECT åˆ—åç§° AS åˆ«å FROM è¡¨åç§°SELECT xx AS yy FROM è¡¨åç§° CASE WHENCASE WHEN çš„ç”¨æ³•ä¸Žä¸€èˆ¬ç¼–ç¨‹è¯­è¨€çš„ switch è¯­å¥ç±»ä¼¼ï¼Œä¸€èˆ¬è¯­æ³•ï¼š123456CASE WHEN condition1 THEN result1 WHEN condition2 THEN result2 WHEN condition3 THEN result3 ELSE resultEND; ä¸åŒçš„æ˜¯ï¼Œswitch è¯­å¥éœ€è¦ç”¨ breakï¼Œä½†æ˜¯ CASE WHEN åªä¼šè¿”å›žä¸€ä¸ª resultã€‚ GROUP BYGROUP BY çš„ä½œç”¨æ˜¯æ ¹æ®ä¸€ä¸ªæˆ–å¤šä¸ªåˆ—å¯¹ç»“æžœé›†è¿›è¡Œåˆ†ç»„ï¼Œä¸€èˆ¬è¯­æ³•ï¼š123SELECT åˆ—åç§°, åŠŸèƒ½å‡½æ•° FROM è¡¨åç§°WHERE xxxGROUP BY åˆ—åç§° MINMIN å‡½æ•°ç”¨æ¥è¿”å›žä¸€åˆ—ä¸­çš„æœ€å°å€¼ï¼ŒNULL ä¸åŒ…æ‹¬åœ¨å†…ï¼Œä¸€èˆ¬è¯­æ³•ï¼š1SELECT MIN(åˆ—åç§°) FROM è¡¨åç§° UPPERå°†å­—ç¬¦è½¬æ¢ä¸ºå°å†™ï¼Œä¸€èˆ¬è¯­æ³•ï¼š1UPPER(å­—ç¬¦ä¸²) LOWERå°†å­—ç¬¦è½¬æ¢ä¸ºå¤§å†™ï¼Œä¸€èˆ¬è¯­æ³•ï¼š1LOWER(å­—ç¬¦ä¸²) CONCATç”¨äºŽå°† 2 ä¸ªå­—ç¬¦ä¸²è¿žæŽ¥èµ·æ¥ï¼Œä¸€èˆ¬è¯­æ³•ï¼š1CONCAT(string1, string2) GROUP_CONCATGROUP_CONCAT ç”¨æ¥è¿žæŽ¥å¤šä¸ªå­—ç¬¦ä¸²ï¼ˆå­—æ®µï¼‰ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š123456# ä¼šå°†æ‰€æœ‰åˆ—åç§°è¿žæŽ¥èµ·æ¥ï¼Œé»˜è®¤ç”¨ , éš”å¼€GROUP_CONCAT(åˆ—åç§°)# ä¼šå°†æ‰€æœ‰ä¸åŒåˆ—åç§°è¿žæŽ¥èµ·æ¥ï¼Œé»˜è®¤ç”¨ , éš”å¼€GROUP_CONCAT(DISTINCT åˆ—åç§°)# ä¼šå°†æ‰€æœ‰åˆ—åç§°è¿žæŽ¥èµ·æ¥ï¼Œè‡ªè¡Œè®¾ç½®åˆ†éš”ç¬¦GROUP_CONCAT(åˆ—åç§°, åˆ†éš”ç¬¦) SUBSTRINGç”¨äºŽæˆªå–å­—ç¬¦ä¸²ï¼Œä¸€èˆ¬è¯­æ³•ï¼š12345678# æˆªå– string çš„ç¬¬ 1 ä¸ªå­—ç¬¦åŽçš„æ‰€æœ‰å­—ç¬¦SUBSTRING(string, 1)# æˆªå– string çš„ç¬¬ 1 ä¸ªå­—ç¬¦åŽçš„ 3 ä¸ªå­—ç¬¦SUBSTRING(string, 1, 3)# æˆªå– string çš„å€’æ•°ç¬¬ 3 ä¸ªå­—ç¬¦SUBSTRING(string, -3)# æˆªå– string ä»Žå€’æ•°ç¬¬ 3 ä¸ªå­—ç¬¦å¼€å§‹å– 2 ä¸ªå­—ç¬¦SUBSTRING(string, -3, 2) è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç”¨æ³•ï¼Œä¸ä¸€ä¸€åˆ—ä¸¾äº†ã€‚ LEFTç®—æ˜¯ SUBSTRING çš„ç®€åŒ–ç‰ˆï¼Œä¸€èˆ¬è¯­æ³•ï¼š12# æˆªå– string å·¦è¾¹çš„ 4 ä¸ªå­—ç¬¦LEFT(string, 4) RIGHTç®—æ˜¯ SUBSTRING çš„ç®€åŒ–ç‰ˆï¼Œä¸€èˆ¬è¯­æ³•ï¼š12# æˆªå– string å³è¾¹çš„ 4 ä¸ªå­—ç¬¦RIGHT(string, 4) COUNTCOUNT å‡½æ•°ç”¨æ¥è¿”å›žæŒ‡å®šäº†åˆ—çš„å€¼çš„æ•°ç›®ï¼ˆNULL ä¸è®¡å…¥ï¼‰ï¼Œä¸€èˆ¬è¯­æ³•ï¼š12345SELECT COUNT(åˆ—åç§°) FROM è¡¨åç§°# è¿”å›žè¡¨ä¸­çš„è®°å½•æ•°SELECT COUNT(*) FROM table_name# è¿”å›žæŒ‡å®šåˆ—çš„ä¸åŒå€¼çš„æ•°ç›®SELECT COUNT(DISTINCT åˆ—åç§°) FROM è¡¨åç§° IN / NOT INè¿™ä¸ªä¸¤ä¸ªæ“ä½œç¬¦ä¸Žå­—é¢æ„æ€ä¸€æ ·ï¼Œåˆ¤æ–­æ•°æ®åœ¨ä¸åœ¨å­é›†åˆå†…ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š12SELECT * FROM è¡¨åç§° WHERE åˆ—åç§° IN ('xx', 'yy', 'zz')SELECT * FROM è¡¨åç§° WHERE åˆ—åç§° NOT IN ('xx', 'yy', 'zz') UNION / UNION ALLUNION æ“ä½œç¬¦ç”¨æ¥åˆå¹¶ä¸¤ä¸ªæˆ–å¤šä¸ª SELECT è¯­å¥çš„ç»“æžœé›†ã€‚ä½†æ˜¯è¦æ³¨æ„ï¼ŒUNION å†…éƒ¨çš„ SELECT è¯­å¥å¿…é¡»æ‹¥æœ‰ç›¸åŒæ•°é‡çš„åˆ—ï¼Œåˆ—ä¹Ÿå¿…é¡»æ‹¥æœ‰ç›¸ä¼¼çš„æ•°æ®ç±»åž‹ã€‚åŒæ—¶ï¼Œæ¯æ¡ SELECT è¯­å¥ä¸­çš„åˆ—çš„é¡ºåºå¿…é¡»ç›¸åŒã€‚ä¸€èˆ¬ç”¨æ³•ï¼š123SELECT åˆ—å FROM è¡ŒåUNIONSELECT åˆ—å FROM è¡Œå UNION ALL ä¸Ž UNION çš„ç”¨å¤„æ˜¯ä¸€æ ·çš„ï¼Œä½†æ˜¯ UNION ALL ä¼šåˆ—å‡ºæ‰€æœ‰å€¼ï¼ŒåŒ…æ‹¬é‡å¤çš„ï¼ŒUNION åˆ™ä¸ä¼šã€‚ HAVINGHAVING çš„ç”¨å¤„ç±»ä¼¼ WHEREï¼Œä¹Ÿæ˜¯åœ¨æŒ‰æ¡ä»¶é€‰å–æ•°æ®ã€‚ä½†æ˜¯ WHERE å…³é”®å­—æ— æ³•ä¸Žåˆè®¡å‡½æ•°ä¸€èµ·ä½¿ç”¨ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š1234SELECT åˆ—å, å‡½æ•°()FROM è¡¨åGROUP BY åˆ—åHAVING å‡½æ•°() LIMITLIMIT ä¸€èˆ¬ç”¨æ¥æŸ¥è¯¢æ•°æ®ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š1234# è¯»å– y æ¡æ•°æ®LIMIT y# è·³è¿‡ x æ¡æ•°æ®ï¼Œè¯»å– y æ¡æ•°æ®LIMIT x, y OFFSETOFFSET ä¸€èˆ¬å’Œ LIMIT ä¸€èµ·ä½¿ç”¨ï¼š12# è·³è¿‡ x æ¡æ•°æ®ï¼Œè¯»å– y æ¡æ•°æ®LIMIT y OFFSET x JOINJOIN ç”¨äºŽæ ¹æ®ä¸¤ä¸ªæˆ–å¤šä¸ªè¡¨ç§çš„åˆ—ä¹‹é—´çš„å…³ç³»ï¼Œä»Žè¿™äº›è¡¨ç§æŸ¥è¯¢æ•°æ®ã€‚å®ƒè¿˜æœ‰ 3 ä½å…„å¼Ÿï¼šLEFT JOINã€RIGHT JOIN å’Œ FULL JOINï¼ŒåŒºåˆ«æ˜¯ï¼š JOINï¼šå¦‚æžœè¡¨ç§è‡³å°‘ä¸€ä¸ªåŒ¹é…ï¼Œåˆ™è¿”å›žè¡Œã€‚ LEFT JOINï¼šå³ä½¿å³è¡¨ç§æ²¡æœ‰åŒ¹é…ï¼Œä¹Ÿä»Žå·¦è¡¨ä¸­è¿”å›žæ‰€æœ‰çš„è¡Œã€‚ RIGHT JOINï¼šå³ä½¿å·¦è¡¨ä¸­æ²¡æœ‰åŒ¹é…ï¼Œä¹Ÿä»Žå³è¡¨ä¸­è¿”å›žæ‰€æœ‰çš„è¡Œã€‚ FULL JOINï¼šåªè¦å…¶ä¸­ä¸€ä¸ªè¡¨ä¸­å­˜åœ¨åŒ¹é…ï¼Œå°±è¿”å›žè¡Œã€‚ æ’ä¸€å¼ å›¾ï¼šå®ƒä»¬çš„ç”¨æ³•éƒ½å·®ä¸å¤šï¼š1234SELECT xxfrom è¡¨å1JOIN è¡¨å2ON æ¡ä»¶ DATEDIFFDATEDIFF æ˜¯ç”¨æ¥è®¡ç®—æ—¶é—´å·®çš„ SQL å‡½æ•°ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š12345# startdate å’Œ enddate å‚æ•°æ˜¯åˆæ³•çš„æ—¥æœŸè¡¨è¾¾å¼# datepart å‚æ•°å¯ä»¥æ˜¯å¹´ã€æœˆã€æ—¥ã€å­£åº¦ç­‰å€¼SELECT DATEDIFF(datepart, startdate, enddate) AS DIFFDATE# è¿”å›žç»“æžœä¸º 1 SELECT DATEDIFF(day, '2008-12-29', '2008-12-30') AS DIFFDATE YEARYEAR å‡½æ•°ç”¨æ¥èŽ·å–å­—ç¬¦ä¸²ä¸­çš„å¹´ä»½ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š12# è¿”å›ž 2018SELECT YEAR('2018-10-10') WITH ASWITH AS ç”¨æ¥å®šä¹‰ä¸€ä¸ª SQL ç‰‡æ®µï¼Œè¿™ä¸ªç‰‡æ®µä¼šè¢«æ•´ä¸ª SQL è¯­å¥æ‰€ç”¨åˆ°ï¼Œæœ‰ç‚¹ç±»ä¼¼ C è¯­è¨€é‡Œé¢çš„é¢„ç¼–è¯‘ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š123# æ‰§è¡Œ select * from xxx å¾—åˆ°ä¸€ä¸ªç‰‡æ®µï¼Œè¿™ä¸ªç‰‡æ®µåå« A# æ³¨æ„ï¼Œè¿™ä¸ªç‰‡æ®µå®žé™…ä¸Šä¹Ÿæ˜¯ä¸€ä¸ªè¡¨WITH A AS (select * from xxx) MAX/MINä¸¤ä¸ªæœ€å€¼å‡½æ•°ï¼ŒåŠŸèƒ½ä¸è¯´äº†ï¼Œä¸€èˆ¬ç”¨æ³•ï¼š12SELECT MAX(åˆ—å) FROM è¡¨åSELECT MIN(åˆ—å) FROM è¡¨å]]></content>
      <categories>
        <category>Programming</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_10 å¤© SQL å…¥é—¨_day1]]></title>
    <url>%2F2022%2F04%2F20%2FLeetcode-10-%E5%A4%A9-SQL-%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªç³»åˆ—å¥½åƒæ˜¯å’Œæ•°æ®åº“ç›¸å…³çš„å†…å®¹ï¼Œéœ€è¦è¡¥å……ä¸€ç‚¹è¿™äº›çŸ¥è¯†ã€‚åšè¿™äº›é¢˜ç›®å‰ï¼Œéœ€è¦äº†è§£ä¸€äº› SQL è¯­æ³•ã€‚ 595. Big CountriesAnalysis2 ä¸ªæ³¨æ„ç‚¹ï¼š åªè¦æŒ‘å‡ºéœ€è¦æ˜¾ç¤ºçš„åˆ— ä¸å°‘äºŽæŒ‡å®šçš„æ•°å€¼å³æ»¡è¶³æ¡ä»¶ Code1select name, area, population from World where area &gt;= 3000000 or population &gt;= 25000000 ä¹Ÿå¯ä»¥ä½¿ç”¨ UNION æ¥è¿žæŽ¥ä¸¤ä¸ªå­æŸ¥è¯¢ã€‚123select name, area, population from World where area &gt;= 3000000 union select name, area, population from World where population &gt;= 25000000 1757. Recyclable and Low Fat ProductsAnalysisè¿™ä¸ªé¢˜è·Ÿä¸Šä¸ªé¢˜å·®ä¸å¤šã€‚ Coed1select product_id from Products where low_fats='Y' and recyclable='Y' ä½†æ˜¯è¿™é¢˜æ²¡åŠžæ³•ç”¨ UNION æ¥è¿žæŽ¥ä¸¤ä¸ªå­æŸ¥è¯¢ï¼Œå› ä¸ºè¿™ä¸ªé¢˜è¦ç”¨ ANDã€‚ 584. Find Customer RefereeAnalysisä¹Ÿæ˜¯å·®ä¸å¤šçš„é¢˜ï¼Œä½†æ˜¯è¦æ³¨æ„å¦‚ä½•å¾—åˆ° nullã€‚ Code1select name from Customer where referee_id != 2 or referee_id is null æ³¨æ„ä¸è¦å†™æˆï¼šreferee_id = nullã€‚ 183. Customers Who Never OrderAnalysisè¿™ä¸ªé¢˜è¦å¤æ‚ä¸€äº›ï¼Œè¿™ä¸ªé—®é¢˜å®žè´¨ä¸Šæ˜¯ä»Ž 2 ä¸ªè¡¨ä¸­ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æ•°æ®ï¼Œæ‰€ä»¥æœ‰å‡ ä¸ªè¦è§£å†³çš„é—®é¢˜ï¼š ä»Žè¡¨ 1 ä¸­æŒ‘å‡ºåç§°ï¼Œä»Žè¡¨ 2 ä¸­æ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æ•°æ® æœ€åŽå¾—åˆ°çš„ç»“æžœçš„è¡¨å¤´è¦æ”¹å˜ å¦‚ä½•åˆ¤æ–­ä¸æ»¡è¶³æ¡ä»¶ Code1select name as 'Customers' from Customers where id not in (select customerID from Orders) Summaryé—®é¢˜éƒ½æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯ä¸æ‡‚è¯­æ³•å°±å¾ˆéš¾å—äº†ã€‚å¾—æ‰¾æœ¬ä¹¦çœ‹çœ‹æ•°æ®åº“çš„ç›¸å…³è¯­æ³•ï¼Œä¸ç„¶æœ‰ç‚¹æ‡µé€¼ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day12]]></title>
    <url>%2F2022%2F04%2F19%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªä¹Ÿè¦ç»“æŸäº†å—ï¼Ÿ 1603. Design Parking SystemAnalysisè®¾è®¡ä¸€ä¸ªåœè½¦ç‚¹çš„ç±»ã€‚ Codeæ²¡å•¥è¯´çš„ï¼Œè¿™ä¸ªå¾ˆç®€å•ã€‚1234567891011121314151617181920212223/** * Your ParkingSystem object will be instantiated and called as such: * ParkingSystem* obj = new ParkingSystem(big, medium, small); * bool param_1 = obj-&gt;addCar(carType); */class ParkingSystem &#123;public: vector&lt;int&gt; park = vector&lt;int&gt;(4); ParkingSystem(int big, int medium, int small) &#123; park[1] = big; park[2] = medium; park[3] = small; &#125; bool addCar(int carType) &#123; if(!park[carType]) return false; else &#123; park[carType]--; return true; &#125;; &#125;&#125;; 303. Range Sum Query - ImmutableAnalysisè¿™ä¸ªé¢˜ä¹Ÿå¾ˆç®€å•ï¼Œå› ä¸ºæ•°é‡çº§å¾ˆå°ï¼Œç›´æŽ¥ç”¨ vector å°±è¡Œã€‚ä½†è¿™æ ·æ²¡ä»€ä¹ˆæ„æ€ï¼Œç”¨æ™®é€šçš„æ•´åž‹æ•°ç»„ç®—äº†ã€‚ Codemethod 1ç›´æŽ¥ç”¨æ•´åž‹æ•°ç»„ã€‚123456789101112131415161718192021222324/** * Your NumArray object will be instantiated and called as such: * NumArray* obj = new NumArray(nums); * int param_1 = obj-&gt;sumRange(left,right); */class NumArray &#123;public: int numbers[10005] = &#123;0&#125;; NumArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; numbers[i] = nums[i]; &#125; &#125; int sumRange(int left, int right) &#123; int sum = 0; while(left &lt;= right) &#123; sum += numbers[left++]; &#125; return sum; &#125;&#125;; æäº¤ä¹‹åŽï¼Œæ—¶é—´ä¸Žç©ºé—´çš„æ¶ˆè€—å¾ˆå¤§ï¼Œè¿™æ ·çš„åšæ³•æ˜¾ç„¶æœ‰ç‚¹ä¸å€¼å¾—ã€‚ method 2å› ä¸ºè¿™ä¸ªé¢˜ç›®åªè¦æ±‚æ±‚å’Œï¼Œæ‰€ä»¥ï¼Œå¯ä»¥ä½¿ç”¨å‰ç¼€å’Œçš„æ€æƒ³æ¥åšã€‚ç²—ç•¥ä¼°ç®—ä¸€ä¸‹æžç«¯æƒ…å†µçš„æ•°å€¼ï¼Œ$nums[i]$ æœ€å¤§æ˜¯ $10^5$ï¼Œ$nums$ çš„å¤§å°æœ€å¤§ä¸º $10^4$ï¼Œé‚£ä¹ˆè®¡ç®—æƒ…å†µå°±æ˜¯ $10^9$ å’Œ $10^{-9}$ï¼Œè¿™æ˜¯åœ¨ int èŒƒå›´å†…çš„æ•°å­—ã€‚1234567891011121314class NumArray &#123;public: int numbers[10005] = &#123;0&#125;; NumArray(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; numbers[i + 1] = nums[i] + numbers[i]; &#125; &#125; int sumRange(int left, int right) &#123; return numbers[right + 1] - numbers[left]; &#125;&#125;; Summaryæ²¡å•¥è¯´çš„ï¼Œæœ€åŽä¸€å¤©çš„é¢˜ï¼Œéƒ½æ˜¯æ¯”è¾ƒç®€å•çš„é¢å¯¹å¯¹è±¡çš„æ€ç»´ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day11]]></title>
    <url>%2F2022%2F04%2F18%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[4 ä¸ªä¸Žå®¹å™¨å’Œåº“ç›¸å…³çš„é¢˜ã€‚ 1356. Sort Integers by The Number of 1 BitsAnalysisæŒ‰ç…§æ•°å­—çš„äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°è¿›è¡ŒæŽ’åºï¼Œå¦‚æžœ 1 çš„ä¸ªæ•°ç›¸ç­‰å°±æŒ‰ç…§è‡ªç„¶æ•°å¤§å°æŽ’åºã€‚åˆ†æžä¸€ä¸‹ï¼Œå®Œæˆè¿™é“é¢˜ï¼Œå…¶å®žéœ€è¦è§£å†³ 2 ä¸ªé—®é¢˜ï¼š ç®—å‡ºæ¯ä¸ªæ•°å­—ä¸­ 1 çš„ä¸ªæ•° æŽ’åº ç”±äºŽæ•°å­—ä¸Žå…¶äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°æ˜¯å¯¹åº”çš„å…³ç³»ï¼Œæ‰€ä»¥ä½¿ç”¨ map æ¥ä¿å­˜è¿™äº›æ•°å­—æ¯”è¾ƒæ–¹ä¾¿ï¼ˆmap å¯ä»¥è‡ªåŠ¨æŽ’åºï¼‰ã€‚ä½†æ˜¯ä½¿ç”¨ map ä¼šè‡ªåŠ¨åŽ»é™¤é‡å¤å…ƒç´ ï¼Œè¿™æ ·ç»“æžœå°±ä¸å¯¹äº†ã€‚æ³¨æ„åˆ°è¿™ä¸ªé¢˜ç›®çš„æœ€å¤§å€¼æ˜¯ $10^4$ï¼Œè¿™ä¸ªæ•°çš„äºŒè¿›åˆ¶æ€»å…±æœ‰ 14 ä½ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™ä¸ªé¢˜ç›®çš„æµ‹è¯•æ•°æ®ä¸­ä¸ä¼šå­˜åœ¨ 1 çš„ä¸ªæ•°è¶…è¿‡ 14 çš„æ•°ï¼ˆå®žé™…ä¸Šä¸å¯èƒ½æœ‰ 14 ä½éƒ½æ˜¯ 1 çš„æ•°ï¼Œå› ä¸ºè¿™ä¸ªæ•°è¶…è¿‡äº† $10^4$ï¼‰ã€‚é‚£å°±å¯ä»¥æŒ‰ç…§è¿™äº›æ•°æ®çš„äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°åˆ†åˆ«å­˜æ”¾ï¼Œç„¶åŽåœ¨æŽ’åºï¼Œè¿™æ ·å°±å¯ä»¥è§£å†³é‡å¤çš„é—®é¢˜äº†ã€‚ Codemethod 11234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), maxcount = 0; vector&lt;vector&lt;int&gt;&gt; res(14, vector&lt;int&gt;()); for(int i = 0; i &lt; size; i++) &#123; int tmp = __builtin_popcount(arr[i]); res[tmp].push_back(arr[i]); if(tmp &gt; maxcount) maxcount = tmp; &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt;= maxcount; i++) &#123; sort(res[i].begin(), res[i].end()); for(int j: res[i]) &#123; ret.push_back(j); &#125; &#125; return ret; &#125;&#125;; method 2çŽ°åœ¨ï¼Œå†å›žåˆ°é¢˜ç›®ä¸Šï¼Œè¦æ±‚æŒ‰ç…§æ•°å­—äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°è¿›è¡ŒæŽ’åºã€‚å¯¹äºŽé¢å¯¹å¯¹è±¡çš„è¯­è¨€æ¥è®²ï¼Œå¦‚æžœèƒ½æŠŠè¿™ä¸ªæ•°å­—çš„äºŒè¿›åˆ¶ä¸­ 1 çš„ä¸ªæ•°ä½œä¸ºè¿™ä¸ªç±»çš„ä¸€ä¸ªæˆå‘˜å˜é‡ï¼Œç„¶åŽå†ç”¨è¿™ä¸ªæˆå‘˜å˜é‡æŽ’åºï¼Œä¸ä¹Ÿå¯ä»¥å¾—åˆ°ç»“æžœå—ï¼Ÿä½†é—æ†¾çš„æ˜¯ï¼ŒLeetcode å¹¶ä¸èƒ½è‡ªè¡Œæž„é€ ç±»ï¼Œæ‰€ä»¥åªèƒ½â€œå‡‘â€ä¸€ä¸‹äº†ã€‚123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; bits(10001, 0); for(int i = 0; i &lt; size; i++) &#123; bits[arr[i]] = __builtin_popcount(arr[i]); &#125; sort(arr.begin(), arr.end(), [&amp;](int a, int b) &#123; if(bits[a] != bits[b]) return bits[a] &lt; bits[b]; else return a &lt; b; &#125;); return arr; &#125;&#125;; å®žé™…ä¸Šï¼Œæ±‚å– bits æ•°ç»„çš„è¿‡ç¨‹å¯ä»¥æå‰åšå¥½ã€‚123456789101112131415class Solution &#123;public: vector&lt;int&gt; sortByBits(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(); vector&lt;int&gt; bits(10001, 0); for(int i = 1; i &lt;= 10000; i++) &#123; bits[i] = bits[i &gt;&gt; 1] + (i &amp; 1); &#125; sort(arr.begin(), arr.end(), [&amp;](int a, int b) &#123; if(bits[a] != bits[b]) return bits[a] &lt; bits[b]; else return a &lt; b; &#125;); return arr; &#125;&#125;; 232. Implement Queue using Stacksè¿™ä¸ªé¢˜æ˜¯åšè¿‡çš„é¢˜äº†ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day9ã€‚ 242. Valid Anagramè¿™ä¸ªä¹Ÿæ˜¯åšè¿‡çš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day6ã€‚ 217. Contains Duplicateè¿˜æ˜¯åšè¿‡çš„ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day1ã€‚ Summaryä»Šå¤©çš„é¢˜å¥½åƒéƒ½åšè¿‡äº†å•Š...è¯è¯´ï¼Œä¸Žå®¹å™¨å’Œåº“ç›¸å…³çš„é¢˜ï¼Œå°±æ˜¯ä¸“é—¨è®©ç”¨åº“å‡½æ•°å’Œå®¹å™¨çš„é¢˜ç›®å—ï¼Ÿ]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day14]]></title>
    <url>%2F2022%2F04%2F18%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day14%2F</url>
    <content type="text"><![CDATA[å¥½å¿«å•Šï¼Œè¿™ä¸ªè¦åšå®Œäº†ã€‚ 98. Validate Binary Search TreeAnalysisåˆ¤æ–­ä¸€æ£µæ ‘æ˜¯å¦æ˜¯äºŒå‰æœç´¢æ ‘ã€‚ Codemethod 1ç”¨é€’å½’æ¥è§£å†³è¿™ä¸ªé—®é¢˜çš„å…³é”®åœ¨äºŽï¼Œå¦‚ä½•åˆ¤æ–­å·¦å­æ ‘æ‰€æœ‰ç»“ç‚¹éƒ½å°äºŽæ ¹èŠ‚ç‚¹ï¼ˆå¯¹åº”çš„ï¼Œå³å­æ ‘æ‰€æœ‰ç»“ç‚¹éƒ½å¤§äºŽæ ¹èŠ‚ç‚¹ï¼‰ï¼Œæ‰€ä»¥ï¼Œéœ€è¦è®¾ç½®ä¸€ä¸ªåŒºé—´ï¼Œåœ¨åˆ†åˆ«éåŽ†å·¦ã€å³å­æ ‘æ—¶ï¼Œå¯¹åº”æ”¹å˜åŒºé—´çš„å€¼ï¼Œä¸€æ—¦æŸä¸ªç»“ç‚¹çš„å€¼ä¸åœ¨åŒºé—´å†…ï¼Œè¯´æ˜Žè¿™ä¸ªç»“ç‚¹ä¸€å®šä¸æ»¡è¶³äºŒå‰æœç´¢æ ‘çš„è¦æ±‚ã€‚1234567891011class Solution &#123;public: bool judge(TreeNode *root, long long lower, long long upper) &#123; if(!root) return true; if(root-&gt;val &lt;= lower || root-&gt;val &gt;= upper) return false; return judge(root-&gt;left, lower, root-&gt;val) &amp;&amp; judge(root-&gt;right, root-&gt;val, upper); &#125; bool isValidBST(TreeNode* root) &#123; return judge(root, LONG_MIN, LONG_MAX); &#125;&#125;; method 2å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜è¿˜æœ‰ä¸€ç§æ›´ç›´æŽ¥çš„æ–¹æ³•ï¼Œå› ä¸ºäºŒå‰æœç´¢æ ‘çš„ä¸­åºéåŽ†åºåˆ—æ˜¯æœ‰åºçš„ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥å¾—åˆ°è¿™æ£µæ ‘çš„åºåˆ—ï¼Œç„¶åŽåˆ¤æ–­åºåˆ—æ˜¯å¦æœ‰åºå³å¯ã€‚1234567891011121314151617class Solution &#123;public: void inorder(TreeNode *root, vector&lt;int&gt;&amp; v) &#123; if(!root) return; inorder(root-&gt;left, v); v.push_back(root-&gt;val); inorder(root-&gt;right, v); &#125; bool isValidBST(TreeNode* root) &#123; vector&lt;int&gt; tmp; inorder(root, tmp); for(int i = 0; i &lt; tmp.size() - 1; i++) &#123; if(tmp[i + 1] &lt;= tmp[i]) return false; &#125; return true; &#125;&#125;; 653. Two Sum IV - Input is a BSTAnalysisè¿™æ˜¯ä¸¤æ•°ä¹‹å’Œçš„ç¬¬ 4 ä»£å‡çº§ç‰ˆå—ï¼ŸðŸ˜‚ Codemethod 112345678910class Solution &#123;public: unordered_set&lt;int&gt; ht; bool findTarget(TreeNode* root, int k) &#123; if(!root) return false; if(ht.find(root-&gt;val) != ht.end()) return true; else ht.insert(k - root-&gt;val); return findTarget(root-&gt;left, k) || findTarget(root-&gt;right, k); &#125;&#125;; method 212345678910111213141516class Solution &#123;public: unordered_set&lt;int&gt; ht; bool findTarget(TreeNode* root, int k) &#123; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(ht.find(node-&gt;val) != ht.end()) return true; ht.insert(k - node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return false; &#125;&#125;; 235. Lowest Common Ancestor of a Binary Search TreeAnalysisåšè¿™ä¸ªé¢˜ä¹‹å‰ï¼Œé¦–å…ˆè¦æ˜Žç¡® LCA çš„æ¦‚å¿µï¼Œè™½ç„¶è‹±æ–‡æ˜¯ Lowest Common Ancestorï¼Œä½†å¹¶ä¸èƒ½ç›´æŽ¥ç†è§£æˆæœ€å°å…¬å…±ç¥–å…ˆï¼Œè€Œæ˜¯è¦ç†è§£æˆæœ€è¿‘ï¼ˆæœ€ä½Žï¼‰å…¬å…±ç¥–å…ˆã€‚ Codemethod 1è¦æ±‚æœ€è¿‘å…¬å…±ç¥–å…ˆï¼Œé‚£å¾—å…ˆçŸ¥é“ç¥–å…ˆæ˜¯ä»€ä¹ˆã€‚æ‰€ä»¥ï¼Œè¿™ä¸ªé—®é¢˜å®žé™…ä¸Šæ˜¯ä¸€ä¸ªæ±‚å­ç»“ç‚¹è·¯å¾„çš„é—®é¢˜ã€‚åˆ†åˆ«å¾—åˆ° 2 ä¸ªå­ç»“ç‚¹çš„è·¯å¾„åŽï¼Œå°±å¯ä»¥å¾ˆå®¹æ˜“çš„æ‰¾åˆ° 2 ä¸ªå­ç»“ç‚¹è·¯å¾„ä¸­çš„æœ€è¿‘å…¬å…±ç»“ç‚¹äº†ï¼Œè¿™å°±æ˜¯å®ƒä»¬çš„æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚12345678910111213141516171819202122class Solution &#123;public: void getpath(TreeNode *root, TreeNode *target, vector&lt;TreeNode*&gt;&amp; path) &#123; path.push_back(root); if(root == target) return; if(root-&gt;val &gt; target-&gt;val) getpath(root-&gt;left, target, path); if(root-&gt;val &lt; target-&gt;val) getpath(root-&gt;right, target, path); &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; ppath, qpath; getpath(root, p, ppath); getpath(root, q, qpath); TreeNode *lca; int index = 0; while(index &lt; ppath.size() &amp;&amp; index &lt; qpath.size()) &#123; if(ppath[index] == qpath[index]) lca = ppath[index]; else break; index++; &#125; return lca; &#125;&#125;; æ±‚è·¯å¾„çš„è¿‡ç¨‹ï¼Œä¹Ÿå¯ä»¥ä¸ç”¨é€’å½’æ¥åšï¼Œç›´æŽ¥æ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨æ¥ï¼š123456789101112131415161718192021222324class Solution &#123;public: void getpath(TreeNode *root, TreeNode *target, vector&lt;TreeNode*&gt;&amp; path) &#123; while(root) &#123; path.push_back(root); if(root-&gt;val == target-&gt;val) return; else if(root-&gt;val &gt; target-&gt;val) root = root-&gt;left; else root = root-&gt;right; &#125; &#125; TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; vector&lt;TreeNode*&gt; ppath, qpath; getpath(root, p, ppath); getpath(root, q, qpath); TreeNode *lca; int index = 0; while(index &lt; ppath.size() &amp;&amp; index &lt; qpath.size()) &#123; if(ppath[index] == qpath[index]) lca = ppath[index]; else break; index++; &#125; return lca; &#125;&#125;; method 2ä»”ç»†æƒ³æƒ³è¿™ä¸ªé—®é¢˜ï¼Œå®žé™…ä¸Šæ˜¯ä¸éœ€è¦åˆ†åˆ«æ±‚å‡ºä¸¤ä¸ªå­ç»“ç‚¹çš„è·¯å¾„çš„ï¼Œå¯ä»¥ç›´æŽ¥ä¸€æ¬¡æ€§æ±‚ 2 ä¸ªç»“ç‚¹çš„è·¯å¾„ï¼Œä½†ä¸æ˜¯çœŸæ­£çš„æ±‚å‡ºæ¥ã€‚å¦‚æžœå½“å‰ç»“ç‚¹æ¯” 2 ä¸ªç»“ç‚¹éƒ½å¤§ï¼Œå°±åŽ»éåŽ†å·¦å­æ ‘ï¼›åä¹‹éƒ½å°ï¼Œå°±åŽ»éåŽ†å³å­æ ‘ã€‚ä¸€æ—¦ä¸æ»¡è¶³è¿™ 2 ç§æƒ…å†µï¼Œå°±è¯´æ˜Žè¿™ä¸ªç»“ç‚¹æ˜¯è¿™ä¸¤æ¡è·¯å¾„çš„åˆ†å²”ç‚¹ï¼Œé‚£è¿™ä¸ªç»“ç‚¹å°±æ˜¯ LCA äº†ã€‚æ¢å¥è¯è¯´ï¼Œå°±æ˜¯è¿™ 2 ä¸ªç»“ç‚¹çš„å…¬å…±è·¯å¾„çš„æœ€åŽä¸€ä¸ªç»“ç‚¹å°±æ˜¯ LCAã€‚1234567891011class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; while(root) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) root = root-&gt;left; else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) root = root-&gt;right; else break; &#125; return root; &#125;&#125;; æœ‰æ„æ€çš„æ˜¯ï¼Œpã€q è¿™ 2 ä¸ªç»“ç‚¹è¦ä¹ˆæ˜¯åœ¨è¿™ä¸ªåˆ†å²”ç‚¹çš„ä¸åŒå­æ ‘ä¸­ï¼Œè¦ä¹ˆå…¶ä¸­ä¸€ä¸ªå°±æ˜¯è¿™ä¸ªåˆ†å²”ç‚¹ã€‚æœ‰äº†ä¸Šé¢çš„æ€è·¯ï¼Œé€’å½’çš„æ€è·¯è‡ªç„¶ä¹Ÿæœ‰äº†ï¼š12345678class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(root-&gt;val &gt; p-&gt;val &amp;&amp; root-&gt;val &gt; q-&gt;val) return lowestCommonAncestor(root-&gt;left, p, q); else if(root-&gt;val &lt; p-&gt;val &amp;&amp; root-&gt;val &lt; q-&gt;val) return lowestCommonAncestor(root-&gt;right, p, q); else return root; &#125;&#125;; è‡ªç„¶ï¼Œbfs çš„æ€è·¯ä¹Ÿå‡ºæ¥äº†ï¼š123456789101112131415class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; queue&lt;TreeNode*&gt; qu; qu.push(root); TreeNode *lca; while(!qu.empty()) &#123; lca = qu.front(); qu.pop(); if(lca-&gt;val &gt; p-&gt;val &amp;&amp; lca-&gt;val &gt; q-&gt;val) qu.push(lca-&gt;left); else if(lca-&gt;val &lt; p-&gt;val &amp;&amp; lca-&gt;val &lt; q-&gt;val) qu.push(lca-&gt;right); else break; &#125; return lca; &#125;&#125;; Summaryä¸åŒçš„æ ‘å…·æœ‰ä¸åŒçš„æ€§è´¨ï¼Œé¢˜ç›®æ˜¯æ ¹æ®è¿™äº›æ€§è´¨å‡ºçš„ï¼Œè‡ªç„¶ä¹Ÿå¾—æ ¹æ®è¿™äº›æ€§è´¨æ¥æ±‚è§£ï¼Œé¢˜ç›®æ˜¯åšä¸å®Œçš„ï¼Œæ‰€ä»¥ï¼Œæ›´å¤šçš„æ˜¯æŠ“ä½é¢˜ç›®çš„æœ¬è´¨ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day10]]></title>
    <url>%2F2022%2F04%2F17%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[é“¾è¡¨ä¸Žæ ‘ç›¸å…³çš„é¢˜ã€‚ 1290. Convert Binary Number in a Linked List to IntegerAnalysisæŒ‰ç…§é“¾è¡¨ç»“ç‚¹çš„å€¼ï¼Œè®¡ç®—å‡ºå…¶è¡¨ç¤ºçš„äºŒè¿›åˆ¶æ•°ã€‚ Codemethod 1å¾ˆè‡ªç„¶çš„å°±ä¼šæƒ³åˆ°è¿™æ ·çš„è¿­ä»£åšæ³•ï¼š12345678910111213141516171819class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode *p = head; int ret = 0, cnt = 0; while(p) &#123; cnt++; p = p-&gt;next; &#125; p = head; cnt--; while(p) &#123; if(p-&gt;val) ret += (1 &lt;&lt; cnt); cnt--; p = p-&gt;next; &#125; return ret; &#125;&#125;; method 2å®žé™…ä¸Šï¼Œå¹¶ä¸æ˜¯ä¸€å®šéžè¦æ±‚å‡ºé“¾è¡¨çš„ç»“ç‚¹æ•°ï¼Œåªéœ€è¦æ¯æ¬¡è®¡ç®—å‰ï¼Œå…ˆä¹˜ä»¥ 2ï¼Œå†ç›¸åŠ å³å¯ã€‚12345678910111213class Solution &#123;public: int getDecimalValue(ListNode* head) &#123; ListNode *p = head; int ret = 0; while(p) &#123; ret &lt;&lt;= 1; ret |= p-&gt;val; p = p-&gt;next; &#125; return ret; &#125;&#125;; 876. Middle of the Linked Listè¿™ä¸ªé¢˜æ˜¯åšè¿‡çš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©ç®—æ³•å…¥é—¨_day5ã€‚ 104. Maximum Depth of Binary Treeè¿™ä¸ªé¢˜ä¹Ÿæ˜¯åšè¿‡çš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day11ã€‚ 404. Sum of Left LeavesAnalysisæ±‚æ‰€æœ‰å·¦è¾¹å¶å­ç»“ç‚¹ä¹‹å’Œã€‚ Codedfsä½¿ç”¨ dfs çš„éš¾ç‚¹åœ¨äºŽåˆ°è¾¾å¶å­ç»“ç‚¹çš„æ—¶å€™ï¼Œæ— æ³•åˆ¤æ–­æ­¤ç»“ç‚¹æ˜¯å¦æ˜¯å·¦å¶å­ï¼Œæ‰€ä»¥éœ€è¦æå‰åˆ¤æ–­ã€‚12345678910111213141516class Solution &#123;public: bool isleaf(TreeNode *node) &#123; return !node-&gt;left &amp;&amp; !node-&gt;right; &#125; int dfs(TreeNode *root) &#123; int ans = 0; if(root-&gt;left) ans += isleaf(root-&gt;left) ? root-&gt;left-&gt;val : dfs(root-&gt;left); if(root-&gt;right &amp;&amp; !isleaf(root-&gt;right)) ans += dfs(root-&gt;right); return ans; &#125; int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; else return dfs(root); &#125;&#125;; ä¹Ÿå¯ä»¥å†™çš„æ›´ç®€ç•¥ä¸€ç‚¹ï¼š12345678910class Solution &#123;public: bool isleaf(TreeNode *node) &#123; return node &amp;&amp; !node-&gt;left &amp;&amp; !node-&gt;right; &#125; int sumOfLeftLeaves(TreeNode* root) &#123; if(!root) return 0; return sumOfLeftLeaves(root-&gt;left) + sumOfLeftLeaves(root-&gt;right) + (isleaf(root-&gt;left) ? root-&gt;left-&gt;val : 0); &#125;&#125;; bfsbfs çš„æ€è·¯æ„Ÿè§‰è¦æ¸…æ™°å¾ˆå¤šã€‚123456789101112131415161718class Solution &#123;public: int sumOfLeftLeaves(TreeNode* root) &#123; int sum = 0; if(!root) return sum; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;left) &#123; if(!node-&gt;left-&gt;left &amp;&amp; !node-&gt;left-&gt;right) sum += node-&gt;left-&gt;val; else q.push(node-&gt;left); &#125; if(node-&gt;right) q.push(node-&gt;right); &#125; return sum; &#125;&#125;; Summaryæ ‘çš„é€’å½’è¿˜æ˜¯ä¸ç†Ÿç»ƒå•Š...è¿˜å¾—å¤šç»ƒä¹ ä¸€ä¸‹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day13]]></title>
    <url>%2F2022%2F04%2F17%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day13%2F</url>
    <content type="text"><![CDATA[2 ä¸ªè·ŸäºŒå‰æœç´¢æ ‘ç›¸å…³çš„é¢˜ã€‚ 700. Search in a Binary Search TreeAnalysisåœ¨äºŒå‰æœç´¢æ ‘ä¸­ï¼ŒæŸ¥æ‰¾ä¸Žç»™å®šå€¼ç›¸åŒçš„ç»“ç‚¹ï¼Œå¹¶è¿”å›žè¿™ä¸ªç»“ç‚¹ã€‚ Codedfs12345678class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root || root-&gt;val == val) return root; else if(root-&gt;val &gt; val) return searchBST(root-&gt;left, val); else return searchBST(root-&gt;right, val); &#125;&#125;; bfs123456789101112131415class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;val == val) return node; else if(node-&gt;val &gt; val &amp;&amp; node-&gt;left) q.push(node-&gt;left); else if(node-&gt;val &lt; val &amp;&amp; node-&gt;right) q.push(node-&gt;right); &#125; return nullptr; &#125;&#125;; loopç”±äºŽäºŒå‰æœç´¢æ ‘å…·æœ‰å·¦è¾¹å°å³è¾¹å¤§æ€§è´¨ï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥å†™çš„æ›´ç›´æŽ¥ï¼š123456789101112class Solution &#123;public: TreeNode* searchBST(TreeNode* root, int val) &#123; if(!root) return root; while(root) &#123; if(root-&gt;val == val) return root; else if(root-&gt;val &gt; val) root = root-&gt;left; else root = root-&gt;right; &#125; return nullptr; &#125;&#125;; å®žé™…ä¸Šï¼Œè¿™å°±æ˜¯äºŒåˆ†æŸ¥æ‰¾ã€‚ 701. Insert into a Binary Search TreeAnalysisè¿™ä¸ªé¢˜ä¸Žä¸Šé¢çš„é¢˜åŸºæœ¬ä¸€è‡´ï¼Œåªæ˜¯éœ€è¦æ’å…¥ä¸€ä¸ªç»“ç‚¹ï¼Œå®žé™…ä¸Šå°±æ˜¯åœ¨æŸ¥æ‰¾æ’å…¥çš„ä½ç½®ã€‚ Codedfs123456789class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); if(root-&gt;val &gt; val) root-&gt;left = insertIntoBST(root-&gt;left, val); else root-&gt;right = insertIntoBST(root-&gt;right, val); return root; &#125;&#125;; bfs12345678910111213141516171819202122232425class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); if(node-&gt;val &gt; val) &#123; if(node-&gt;left) q.push(node-&gt;left); else &#123; node-&gt;left = new TreeNode(val); break; &#125; &#125; else &#123; if(node-&gt;right) q.push(node-&gt;right); else &#123; node-&gt;right = new TreeNode(val); break; &#125; &#125; &#125; return root; &#125;&#125;; loopåŒæ ·ï¼Œæ ¹æ®äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨å¾ªçŽ¯æ¥åšï¼š1234567891011121314151617181920212223class Solution &#123;public: TreeNode* insertIntoBST(TreeNode* root, int val) &#123; if(!root) return new TreeNode(val); TreeNode *tmp = root; while(root) &#123; if(root-&gt;val &gt; val) &#123; if(root-&gt;left) root = root-&gt;left; else &#123; root-&gt;left = new TreeNode(val); break; &#125; &#125; else &#123; if(root-&gt;right) root = root-&gt;right; else &#123; root-&gt;right = new TreeNode(val); break; &#125; &#125; &#125; return tmp; &#125;&#125;; Summaryè¿™å‡ å¤©æœ‰å…³æ ‘çš„é¢˜éƒ½ä¸éš¾ï¼Œæ‰€ä»¥å°½é‡æŠŠèƒ½æƒ³åˆ°çš„æ–¹æ³•éƒ½å†™å‡ºæ¥ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day12]]></title>
    <url>%2F2022%2F04%2F16%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[æ ‘çš„é¢˜ï¼Œæœ‰ç‚¹æ„æ€å•Šã€‚ 226. Invert Binary TreeAnalysisé¢˜æ„å¾ˆç®€å•ï¼Œç¿»è½¬äºŒå‰æ ‘ã€‚ Codedfs123456789101112class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; TreeNode *tmp = root-&gt;left; root-&gt;left = root-&gt;right; root-&gt;right = tmp; invertTree(root-&gt;left); invertTree(root-&gt;right); return root; &#125;&#125;; bfs1234567891011121314151617181920class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; int size = q.size(); for(int i = 0; i &lt; size; i++) &#123; TreeNode *tmp, *node = q.front(); q.pop(); tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; ä¹Ÿå¯ä»¥å†™çš„æ›´ç®€å•ä¸€ç‚¹ï¼š1234567891011121314151617class Solution &#123;public: TreeNode* invertTree(TreeNode* root) &#123; if(!root) return root; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *tmp, *node = q.front(); q.pop(); tmp = node-&gt;left; node-&gt;left = node-&gt;right; node-&gt;right = tmp; if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; return root; &#125;&#125;; 112. Path SumAnalysisåˆ¤æ–­æ ¹èŠ‚ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯å¾„é•¿åº¦æ˜¯å¦ä¸Žç»™å®šå€¼ç›¸ç­‰ã€‚ Codedfs123456789101112class Solution &#123;public: bool dfs(TreeNode *root, int targetSum, int sum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val + sum == targetSum) return true; return dfs(root-&gt;left, targetSum, sum + root-&gt;val) || dfs(root-&gt;right, targetSum, sum + root-&gt;val); &#125; bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; return dfs(root, targetSum, 0); &#125;&#125;; å—¯ï¼Œè¿™æ ·å†™ï¼Œä¸å¤Ÿä¼˜é›…ï¼Œæ”¹ä¸€ä¸‹ï¼š12345678class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; if(!root-&gt;left &amp;&amp; !root-&gt;right) return targetSum == root-&gt;val; return hasPathSum(root-&gt;left, targetSum - root-&gt;val) || hasPathSum(root-&gt;right, targetSum - root-&gt;val); &#125;&#125;; bfs123456789101112131415161718192021222324252627class Solution &#123;public: bool hasPathSum(TreeNode* root, int targetSum) &#123; if(!root) return false; queue&lt;TreeNode*&gt; q; queue&lt;int&gt; sum; q.push(root); sum.push(root-&gt;val); while(!q.empty()) &#123; TreeNode *node = q.front(); q.pop(); int tmp = sum.front(); sum.pop(); if(!node-&gt;left &amp;&amp; !node-&gt;right) &#123; if(tmp == targetSum) return true; continue; &#125; if(node-&gt;left) &#123; q.push(node-&gt;left); sum.push(node-&gt;left-&gt;val + tmp); &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); sum.push(node-&gt;right-&gt;val + tmp); &#125; &#125; return false; &#125;&#125;; ä½¿ç”¨ bfs ä¼šéº»çƒ¦ä¸€äº›ï¼Œéœ€è¦å°†æ‰€æœ‰æ ¹ç»“ç‚¹åˆ°å¶å­ç»“ç‚¹çš„è·¯åŠ²é•¿åº¦ç®—å‡ºæ¥ï¼Œéœ€è¦ç”¨é˜Ÿåˆ—æ¥ä¿å­˜ä¸­é—´çš„è®¡ç®—ç»“æžœï¼Œå› ä¸ºç»“ç‚¹å‡ºé˜Ÿçš„é¡ºåºä¸Žæ ¹ç»“ç‚¹åˆ°è¿™ä¸ªç»“ç‚¹çš„è·¯åŠ²é•¿åº¦æ˜¯å¯¹åº”çš„ã€‚ Summaryæ ‘çš„é¢˜ç›®æœ‰å¾ˆå¤šï¼Œæœ‰äº›é¢˜ç›®å¾ˆçµæ´»ï¼Œè¦å¤šæƒ³æƒ³ã€‚ä¸è¿‡æœ¬è´¨éƒ½æ˜¯ä¸€æ ·çš„ï¼Œé‚£å°±æ˜¯å¯¹æ ‘çš„éåŽ†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day9]]></title>
    <url>%2F2022%2F04%2F16%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[è¿˜æ˜¯ 3 ä¸ªå­—ç¬¦ä¸²ç›¸å…³çš„é¢˜ç›®ã€‚ 709. To Lower CaseAnalysisåªç”¨å°†å¤§å†™å­—æ¯è½¬æ¢ä¸ºå°å†™å³å¯ã€‚ Code123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(int i = 0; i &lt; s.length(); i++) &#123; if(isupper(s[i])) s[i] = tolower(s[i]); &#125; return s; &#125;&#125;; emï¼Œæ—¢ç„¶ä½¿ç”¨ C++ å†™çš„ï¼Œå°±ç”¨ C++11 çš„å†™æ³•ï¼š123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(char&amp; ch: s) &#123; ch = tolower(ch); &#125; return s; &#125;&#125;; ä¹Ÿå¯ä»¥è‡ªå·±å®žçŽ° tolower çš„åŠŸèƒ½ï¼š123456789class Solution &#123;public: string toLowerCase(string s) &#123; for(char&amp; ch: s) &#123; if(isupper(ch)) ch |= 32; &#125; return s; &#125;&#125;; ä¸ºä»€ä¹ˆå¯ä»¥å†™æˆch |= 32ï¼Ÿå› ä¸ºå¤§å†™å­—æ¯çš„ ASCII ç è¦è½¬æ¢ä¸ºå°å†™å°±æ˜¯åŠ ä¸Š 32ï¼Œè€Œè¿™äº›å¤§å†™å­—æ¯çš„äºŒè¿›åˆ¶è¡¨ç¤ºæœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯è¡¨ç¤º 32 çš„é‚£ä¸€ä½ä¸Šå…¨éƒ¨æ˜¯ 0ã€‚æ¢å¥è¯è¯´ï¼Œè¦è®©è¿™ä¸ªæ•°å­—å¢žåŠ  32ï¼Œåªéœ€è¦å°†è¿™ä¸ªæ•°å­—çš„è¡¨ç¤º 32 çš„äºŒè¿›åˆ¶æ•°ä½ä»Ž 0 å˜æˆ 1 å³å¯ã€‚è¿™æ ·å†™çš„å¥½å¤„å°±æ˜¯ç”¨ä½è¿ç®—å–ä»£äº†åŠ è¿ç®—ï¼Œå¯ä»¥æžå¤§çš„æå‡æ•ˆçŽ‡ã€‚ 1309. Decrypt String from Alphabet to Integer MappingAnalysisè§£ç å­—ç¬¦ä¸²ï¼Œemï¼Œè¿™æ˜¯ä¸ªç®€å•çš„å­—ç¬¦ä¸²åˆ†ç±»è®¨è®ºé¢˜ã€‚ Code12345678910111213141516171819class Solution &#123;public: string freqAlphabets(string s) &#123; string ret; int i = 0; while(i &lt; s.length()) &#123; if(isdigit(s[i])) &#123; if(isdigit(s[i + 1]) &amp;&amp; s[i + 2] == '#') &#123; ret += ((s[i] - '0') * 10 + (s[i + 1] - '0') + 'a' - 1); i += 3; &#125; else &#123; ret += (s[i] - '0' + 'a' - 1); i += 1; &#125; &#125; &#125; return ret; &#125;&#125;; emï¼Œé€»è¾‘è¿‡ç¨‹è¿˜å¯ä»¥æ›´åŠ ç²¾ç‚¼ä¸€ç‚¹ï¼š1234567891011121314151617class Solution &#123;public: string freqAlphabets(string s) &#123; string ret; int i = 0; while(i &lt; s.length()) &#123; if(i + 2 &lt; s.length() &amp;&amp; s[i + 2] == '#') &#123; ret += ((s[i] - '0') * 10 + (s[i + 1] - '0') - 1 + 'a'); i += 3; &#125; else &#123; ret += (s[i] - '0' - 1 + 'a'); i += 1; &#125; &#125; return ret; &#125;&#125;; 953. Verifying an Alien DictionaryAnalysisæŒ‰ç…§ç»™å®šçš„é¡ºåºå¯¹å­—ç¬¦ä¸²æŽ’åºï¼Œemï¼Œè¿™ä¸ªé¢˜å¥½åƒæ˜¯å­—ç¬¦ä¸²æŽ’åºçš„åŽŸç†ã€‚ Code12345678910111213141516171819202122232425class Solution &#123;public: bool isAlienSorted(vector&lt;string&gt;&amp; words, string order) &#123; int seq[26] = &#123;0&#125;; for(int i = 0; i &lt; order.length(); i++) &#123; seq[order[i] - 'a'] = i; &#125; for(int i = 0; i &lt; words.size() - 1; i++) &#123; int minlen = min(words[i].length(), words[i + 1].length()), index = 0; bool flag = true; while(index &lt; minlen) &#123; if(words[i][index] != words[i + 1][index]) &#123; if(seq[words[i][index] - 'a'] &gt; seq[words[i + 1][index] - 'a']) &#123; flag = false; &#125; break; &#125; index++; &#125; if(!flag) return false; else if(index == minlen &amp;&amp; words[i].length() &gt; words[i + 1].length()) return false; &#125; return true; &#125;&#125;; è¿™ä¸ªé¢˜æœ‰ç‚¹éº»çƒ¦ï¼Œä½†ä¸æ˜¯ä¸ªéš¾é¢˜ã€‚å› ä¸ºä¸åŒçš„æ ·ä¾‹ä¼šç»™å‡ºä¸åŒçš„å­—æ¯é¡ºåºï¼Œæ‰€ä»¥æœ€å¥½å°†å­—æ¯é¡ºåºæ•£åˆ—çš„ä¿å­˜èµ·æ¥ï¼ŒåŽé¢æ¯”è¾ƒçš„æ—¶å€™å°±å¯ä»¥ç›´æŽ¥ç”¨äº†ã€‚ Summaryemï¼Œ3 ä¸ªç®€å•çš„å­—ç¬¦ä¸²ç›¸å…³é¢˜ç›®ï¼Œéƒ½æŒºç®€å•çš„ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day11]]></title>
    <url>%2F2022%2F04%2F15%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[è¿˜æ˜¯æ ‘~ 102. Binary Tree Level Order TraversalAnalysiså¤§åé¼Žé¼Žçš„ bfsã€‚ Codebfs123456789101112131415161718192021222324252627282930313233343536373839404142/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;TreeNode*&gt; q; q.push(root); int cnt = 1; while(!q.empty()) &#123; vector&lt;int&gt; tmp; TreeNode *node; int sum = 0; for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) &#123; q.push(node-&gt;left); sum++; &#125; if(node-&gt;right) &#123; q.push(node-&gt;right); sum++; &#125; &#125; cnt = sum; ret.push_back(tmp); &#125; return ret; &#125;&#125;; å› ä¸ºé¢˜ç›®è¦æ±‚æŒ‰å±‚è¾“å‡ºç»“ç‚¹ï¼Œæ‰€ä»¥ä¸€æ¬¡æ€§è¦éåŽ†å®Œä¸€å±‚çš„æ‰€æœ‰ç»“ç‚¹ï¼Œå°±éœ€è¦æå‰å°†ä¸‹ä¸€å±‚çš„ç»“ç‚¹ä¸ªæ•°è®¡ç®—å‡ºæ¥ï¼Œè¿™æ ·æ‰èƒ½ä¿è¯æœ€ç»ˆå¾—åˆ°çš„ç»“æžœç¬¦åˆé¢˜æ„ã€‚å®žé™…ä¸Šï¼Œåœ¨å¼€å§‹å¾ªçŽ¯ä¹‹å‰ï¼Œé˜Ÿåˆ—çš„å¤§å°å°±æ˜¯å½“å‰å±‚çš„ç»“ç‚¹ä¸ªæ•°ï¼Œä¹Ÿå°±å¯ä»¥å†™æˆè¿™æ ·ï¼š1234567891011121314151617181920212223class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; vector&lt;int&gt; tmp; TreeNode *node; int cnt = q.size(); for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); tmp.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; ret.push_back(tmp); &#125; return ret; &#125;&#125;; è¿™æ ·å†™ï¼Œçœ‹ç€ä¼šæ¸…çˆ½å¾ˆå¤šã€‚ dfsæ—¢ç„¶ bfs èƒ½è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒåŒæ · dfs ä¹Ÿå¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚123456789101112131415class Solution &#123;public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, TreeNode *root, int level) &#123; if(ret.size() &lt; level + 1) ret.push_back(vector&lt;int&gt;()); ret[level].push_back(root-&gt;val); if(root-&gt;left) dfs(ret, root-&gt;left, level + 1); if(root-&gt;right) dfs(ret, root-&gt;right, level + 1); &#125; vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; ret; if(!root) return ret; dfs(ret, root, 0); return ret; &#125;&#125;; å®žé™…ä¸Šï¼Œè¿™é‡Œç”¨åˆ°çš„ dfs å°±æ˜¯äºŒå‰æ ‘çš„å…ˆåºéåŽ†ï¼Œä½†è¿™é‡Œçš„å…³é”®åœ¨äºŽï¼Œè¦æŒ‰ç…§å±‚æ•°æ¥è®¿é—®ç»“ç‚¹ï¼ŒåŒæ—¶åœ¨è®¿é—®ç»“ç‚¹å‰ï¼Œéœ€è¦æå‰åˆ›å»ºå¥½æ•°ç»„ã€‚ 104. Maximum Depth of Binary TreeAnalysisæ±‚äºŒå‰æ ‘çš„æ·±åº¦ï¼Œemï¼Œè¿™ä¸ªé¢˜ä¾ç„¶å¯ä»¥ä»Ž dfs å’Œ bfs ä¸¤ä¸ªæ–¹å‘å…¥æ‰‹ã€‚ Codedfså…ˆä»Ž dfs å…¥æ‰‹ã€‚1234567891011121314class Solution &#123;public: void dfs(TreeNode *root, int depth, int &amp;maxdepth) &#123; if(!root) return; if(depth &gt; maxdepth) maxdepth = depth; dfs(root-&gt;left, depth + 1, maxdepth); dfs(root-&gt;right, depth + 1, maxdepth); &#125; int maxDepth(TreeNode* root) &#123; int maxdepth = 0; dfs(root, 1, maxdepth); return maxdepth; &#125;&#125;; å½“ç„¶äº†ï¼Œä¹Ÿå¯ä»¥è¿™æ ·å†™ï¼š12345678910111213class Solution &#123;public: void dfs(TreeNode *root, int depth, int &amp;maxdepth) &#123; if(depth &gt; maxdepth) maxdepth = depth; if(root-&gt;left) dfs(root-&gt;left, depth + 1, maxdepth); if(root-&gt;right) dfs(root-&gt;right, depth + 1, maxdepth); &#125; int maxDepth(TreeNode* root) &#123; int maxdepth = 0; if(root) dfs(root, 1, maxdepth); return maxdepth; &#125;&#125;; çœ‹ç€æ¸…çˆ½äº†ä¸€äº›ï¼Ÿå…¶å®žï¼Œè¿™ä¸ªè¿˜å¯ä»¥å†™çš„æ›´å¤¸å¼ ðŸ˜‚ï¼Œå¦‚ä¸‹ï¼š1234567class Solution &#123;public: int maxDepth(TreeNode* root) &#123; if(!root) return 0; else return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1; &#125;&#125;; å‰é¢å†™çš„é€’å½’çš„æ€è·¯æœ¬è´¨ä¸Šè¿˜æ˜¯éåŽ†äºŒå‰æ ‘çš„æ€è·¯ï¼Œä½†è¿™æ ·å†™çš„æ€è·¯æ˜¯åŸºäºŽåˆ†æ²»çš„ï¼ŒäºŒå‰æ ‘çš„é«˜åº¦å°±æ˜¯å·¦å³å­æ ‘çš„é«˜åº¦åŠ  1ï¼Œæ‰€ä»¥åªéœ€è¦ä¸æ–­çš„åŽ»è®¡ç®—å­æ ‘çš„é«˜åº¦å†è¿”å›žåŠ  1 å°±å¯ä»¥å¾—åˆ°æ•´ä¸ªæ ‘çš„é«˜åº¦äº†ã€‚ bfsäºŒå‰æ ‘çš„æ·±åº¦å¯¹åº”çš„å°±æ˜¯äºŒå‰æ ‘çš„å±‚æ•°ã€‚123456789101112131415161718192021class Solution &#123;public: int maxDepth(TreeNode* root) &#123; int maxdepth = 0; if(!root) return maxdepth; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty()) &#123; TreeNode *node; int cnt = q.size(); for(int i = 0; i &lt; cnt; i++) &#123; node = q.front(); q.pop(); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; maxdepth++; &#125; return maxdepth; &#125;&#125;; 101. Symmetric TreeAnalysisåˆ¤æ–­ä¸€æ£µäºŒå‰æ ‘æ˜¯å¦å¯¹ç§°ï¼Œè¿™ä¸ªé¢˜æ˜¾ç„¶è¦ç”¨ dfs æ¥åšã€‚ Codedfsåˆ¤æ–­äºŒå‰æ ‘æ˜¯å¦å¯¹ç§°ï¼Œå®žé™…ä¸Šå°±æ˜¯è¦åˆ¤æ–­å·¦å³å­æ ‘æ˜¯ä¸æ˜¯ä¸€æ ·çš„ï¼Œæ‰€ä»¥ä½¿ç”¨ 2 ä¸ªæŒ‡é’ˆé€’å½’çš„åŽ»åˆ¤æ–­å³å¯ã€‚123456789101112class Solution &#123;public: bool check(TreeNode *root1, TreeNode *root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if(!root1 || !root2) return false; else return root1-&gt;val == root2-&gt;val &amp;&amp; check(root1-&gt;left, root2-&gt;right) &amp;&amp; check(root1-&gt;right, root2-&gt;left); &#125; bool isSymmetric(TreeNode* root) &#123; if(!root) return true; return check(root-&gt;left, root-&gt;right); &#125;&#125;; æ³¨æ„ï¼Œä¸€å¼€å§‹é€’å½’çš„æ—¶å€™ä¸è¦ç›´æŽ¥å†™check(root, root)ï¼Œè¿™æ ·å°±å¤šåˆ¤æ–­äº†ä¸€éï¼Œå› ä¸ºç¬¬ä¸€æ¬¡é€’å½’ä¸­check(root1-&gt;left, root2-&gt;right)å’Œcheck(root1-&gt;right, root2-&gt;left)æ˜¯ä¸€æ ·çš„ã€‚ bfsåŒæ ·ï¼Œè¿™ä¸ªé¢˜ä¹Ÿå¯ä»¥ç”¨ bfs æ¥åšã€‚123456789101112131415161718192021class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root) return true; queue&lt;TreeNode*&gt; q; q.push(root-&gt;left); q.push(root-&gt;right); TreeNode *u, *v; while(!q.empty()) &#123; u = q.front(); q.pop(); v = q.front(); q.pop(); if(!u &amp;&amp; !v) continue; if((!u || !v) || (u-&gt;val != v-&gt;val)) return false; q.push(u-&gt;left); q.push(v-&gt;right); q.push(u-&gt;right); q.push(v-&gt;left); &#125; return true; &#125;&#125;; åŒæ ·ï¼Œç¬¬ä¸€æ¬¡å…¥é˜Ÿçš„æ—¶å€™ç›´æŽ¥å°†å·¦å³å­ç»“ç‚¹å…¥é˜Ÿã€‚ Summary3 ä¸ªæ ‘çš„ç›¸å…³é¢˜ç›®ï¼Œåšçš„æŒºæœ‰æ„æ€çš„ã€‚æœ‰å…³äºŒå‰æ ‘çš„é¢˜ï¼Œæœ‰æ—¶å€™ç”¨ dfs åšå¾ˆç®€å•ï¼Œæœ‰æ—¶å€™ç”¨ bfs åšå¾ˆç®€å•ï¼Œæ‰€ä»¥ï¼Œæœ€å¥½æ˜¯èƒ½åˆç†çš„é€‰æ‹©æœ€ç®€å•çš„æ–¹æ³•å®Œæˆã€‚å½“ç„¶ï¼Œä¹Ÿä¸æŽ’é™¤å¯èƒ½é¢è¯•æ—¶è¦ç”¨ç‰¹å®šçš„æ–¹æ³•å†™ï¼Œæ‰€ä»¥æœ€å¥½è¿˜æ˜¯éƒ½ä¼šæ¯”è¾ƒå¥½ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day8]]></title>
    <url>%2F2022%2F04%2F15%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[3 ä¸ªå­—ç¬¦ä¸²ç›¸å…³çš„é¢˜ã€‚ 1768. Merge Strings AlternatelyAnalysisäº¤æ›¿åˆå¹¶å­—ç¬¦ä¸²ï¼Œå¤šå‡ºæ¥çš„å­—ç¬¦æ”¾åˆ°æœ«å°¾å³å¯ï¼Œè¿™ä¸ªé¢˜æœ‰ç‚¹ç±»ä¼¼åˆå¹¶é“¾è¡¨çš„é¢˜ç›®ã€‚ Code12345678910111213class Solution &#123;public: string mergeAlternately(string word1, string word2) &#123; string ret; int i = 0, j = 0; while(i &lt; word1.length() &amp;&amp; j &lt; word2.length()) &#123; ret += i &lt;= j ? word1[i++] : word2[j++]; &#125; while(i &lt; word1.length()) ret += word1[i++]; while(j &lt; word2.length()) ret += word2[j++]; return ret; &#125;&#125;; ä¸è¿‡ï¼Œè¿™æ ·å†™å¥½åƒä¸æ˜¯é‚£ä¹ˆä¼˜é›…ï¼Œæ”¹ä¸€ä¸‹ï¼š123456789101112class Solution &#123;public: string mergeAlternately(string word1, string word2) &#123; string ret; int i = 0, j = 0; while(i &lt; word1.length() || j &lt; word2.length()) &#123; if(i &lt; word1.length()) ret += word1[i++]; if(j &lt; word2.length()) ret += word2[j++]; &#125; return ret; &#125;&#125;; 1678. Goal Parser InterpretationAnalysisç®€å•çš„åˆ†è¯å™¨ï¼ŒæŒ‰ç…§ä¸åŒçš„æƒ…å†µåˆ¤æ–­å°±å¥½ã€‚ Code1234567891011121314151617181920class Solution &#123;public: string interpret(string command) &#123; string ret; int i = 0; while(i &lt; command.length()) &#123; if(command[i] == 'G') &#123; ret += "G"; i++; &#125; else if(command[i] == '(' &amp;&amp; command[i + 1] == ')') &#123; ret += "o"; i += 2; &#125; else &#123; ret += "al"; i += 4; &#125; &#125; return ret; &#125;&#125;; 389. Find the DifferenceAnalysisæ‰¾å‡ºå­—ç¬¦ä¸² t ä¸­å¤šå‡ºçš„å­—æ¯å³å¯ã€‚ Codemethod 1ç›´æŽ¥æ•£åˆ—ã€‚12345678910111213class Solution &#123;public: char findTheDifference(string s, string t) &#123; int letters[26] = &#123;0&#125;, i = 0; while(i &lt; s.length()) letters[s[i++] - 'a']++; i = 0; while(i &lt; t.length()) &#123; int tmp = --letters[t[i++] - 'a']; if(tmp &lt; 0) break; &#125; return t[--i]; &#125;&#125;; method 2å½“ç„¶ä¹Ÿå¯ä»¥ä¸ä½¿ç”¨æ•£åˆ—ï¼Œåªéœ€è¦å°† 2 ä¸ªå­—ç¬¦ä¸²å­—ç¬¦çš„å’Œæ±‚å‡ºåšå·®ï¼Œå³å¯å¾—åˆ°éœ€è¦çš„ç»“æžœã€‚123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; int sum1 = 0, sum2 = 0; for(char ch: s) sum1 += ch; for(char ch: t) sum2 += ch; return sum2 - sum1; &#125;&#125;; ä¹‹æ‰€ä»¥èƒ½è¿™ä¹ˆå¹²ï¼Œæ˜¯å› ä¸º ASCII ç æœ¬èº«å°±æ˜¯ä»¥æ•´æ•°çš„å½¢å¼å­˜å‚¨çš„ã€‚ method 3æ—¢ç„¶çŸ¥é“äº† ASCII ç æ˜¯æ•´æ•°å½¢å¼å­˜å‚¨çš„ï¼Œé‚£ä¹ˆè¿™ä¸ªé—®é¢˜å°±è½¬åŒ–ä¸ºäº†ï¼Œå¯»æ‰¾åªå‡ºçŽ°ä¸€æ¬¡çš„æ•°ï¼Œå°±å¯ä»¥åˆ©ç”¨ä½è¿ç®—æ¥å®Œæˆäº†ã€‚123456789class Solution &#123;public: char findTheDifference(string s, string t) &#123; char ret = 0; for(char ch: s) ret ^= ch; for(char ch: t) ret ^= ch; return ret; &#125;&#125;; Summaryç®€å•çš„å­—ç¬¦ä¸²ç›¸å…³é¢˜ç›®ï¼Œåšèµ·æ¥ä¸æ¯«ä¸åºŸåŠ²å•Š...ä¸è¿‡è¿˜æ˜¯è¦æ³¨æ„ä¸€ä¸‹ä¸€é¢˜å¤šè§£çš„æƒ…å†µï¼Œå°½é‡å¼€é˜”è‡ªå·±çš„æ€è·¯ï¼Œè¦èƒ½æƒ³åˆ°å…¶ä»–æ›´ä¼˜ç§€çš„è§£æ³•ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day10]]></title>
    <url>%2F2022%2F04%2F14%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[3 ä¸ªé¢˜ï¼Œæ­£å¥½å¯¹åº”äºŒå‰æ ‘çš„å…ˆã€ä¸­ã€åŽåºéåŽ†ã€‚ 144. Binary Tree Preorder TraversalAnalysisäºŒå‰æ ‘çš„å…ˆåºéåŽ†ï¼ŒéåŽ†é¡ºåºä¸ºï¼šæ ¹å·¦å³ã€‚ Codemethod 1é€’å½’å†™æ³•éžå¸¸ç®€å•ã€‚12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125; * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125; * &#125;; */class Solution &#123;public: void pre(vector&lt;int&gt;&amp; seq, TreeNode *root) &#123; if(!root) return; seq.push_back(root-&gt;val); pre(seq, root-&gt;left); pre(seq, root-&gt;right); &#125; vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; pre(ret, root); return ret; &#125;&#125;; method 2å¦‚æžœä¸ç”¨é€’å½’ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ ˆæ¥æ¨¡æ‹Ÿã€‚1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); ret.push_back(root-&gt;val); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; method 3å®žé™…ä¸Šè¿˜æœ‰ä¸€ç§å«åš Morris éåŽ†çš„æ–¹æ³•ï¼Œèƒ½å°†ç©ºé—´å¤æ‚åº¦é™åˆ° $O(1)$ã€‚12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; preorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; ret.push_back(p1-&gt;val); p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else p2-&gt;right = nullptr; &#125; else ret.push_back(p1-&gt;val); p1 = p1-&gt;right; &#125; return ret; &#125;&#125;; è¿™ç§æ–¹æ³•å¾ˆå¥½ï¼Œä½†æ˜¯ç”¨çš„å¾ˆå°‘ï¼ˆå¤šåŠæ˜¯ä¸ºäº†é¢è¯•ï¼Ÿï¼‰ã€‚è¿™ç§éåŽ†æ–¹æ³•å®žè´¨ä¸Šåªå¹²äº†ä¸€ä»¶äº‹æƒ…ï¼Œé‚£å°±æ˜¯ï¼šåˆ©ç”¨å­æ ‘æœ€å³å­ç»“ç‚¹çš„ç©ºæŒ‡é’ˆæŒ‡å‘å…¶åœ¨ä¸­åºéåŽ†ä¸‹éœ€è¦è®¿é—®çš„ä¸‹ä¸€ä¸ªç»“ç‚¹ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ç”¨é€šè¿‡å›žé€€æ¥è®¿é—®ä¸‹ä¸€ä¸ªç»“ç‚¹äº†ï¼Œç›´æŽ¥ç”¨ä¿®æ”¹å¥½çš„ç©ºæŒ‡é’ˆå°±å¯ä»¥æ‹¿åˆ°ä¸‹ä¸€ä¸ªéœ€è¦è®¿é—®çš„ç»“ç‚¹çš„åœ°å€ï¼Œæ­¤æ—¶ï¼Œä¼šå†æ¬¡ç”¨è¿™ä¸ªç»“ç‚¹è¿›å…¥å¾ªçŽ¯ï¼Œå› ä¸ºè¿™ä¸ªå­æ ‘æœ€å³å­ç»“ç‚¹çš„å³æŒ‡é’ˆå·²ç»è¢«ä¿®æ”¹ä¸ºä¹‹å‰çš„ç»“ç‚¹çš„åœ°å€äº†ï¼Œæ‰€ä»¥è¦å†æ”¹ä¸º nullã€‚ 94. Binary Tree Inorder TraversalAnalysisä¸­åºéåŽ† CodeåŒæ ·å†™ 3 ç§éåŽ†æ–¹æ³•ã€‚ method 11234567891011121314class Solution &#123;public: void inorder(vector&lt;int&gt;&amp; seq, TreeNode* root) &#123; if(!root) return; inorder(seq, root-&gt;left); seq.push_back(root-&gt;val); inorder(seq, root-&gt;right); &#125; vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; inorder(ret, root); return ret; &#125;&#125;; method 21234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); ret.push_back(root-&gt;val); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; method 3123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; inorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else &#123; ret.push_back(p1-&gt;val); p2-&gt;right = nullptr; &#125; &#125; else ret.push_back(p1-&gt;val); p1 = p1-&gt;right; &#125; return ret; &#125;&#125;; 145. Binary Tree Postorder TraversalAnalysisåŽåºéåŽ† Codemethod 11234567891011121314class Solution &#123;public: void postorder(vector&lt;int&gt;&amp; seq, TreeNode* root) &#123; if(!root) return; postorder(seq, root-&gt;left); postorder(seq, root-&gt;right); seq.push_back(root-&gt;val); &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; postorder(ret, root); return ret; &#125;&#125;; åœ¨è¿™å‡ ä¸ªé—®é¢˜ä¸Šï¼Œé€’å½’æ˜¯çœŸçš„é¦™... method 2ä½¿ç”¨æ ˆæ¥æ¨¡æ‹ŸåŽåºéåŽ†ï¼Œä¸Žå‰åºå’Œä¸­åºæœ‰ä¸€ç‚¹ä¸åŒï¼Œæ—¢å¯ä»¥ä½¿ç”¨ 2 ä¸ªæ ˆæ¥å®Œæˆï¼Œä¹Ÿå¯ä»¥åªç”¨ 1 ä¸ªæ ˆæ¥å®Œæˆã€‚åŒæ ˆï¼š123456789101112131415161718192021222324class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; ret.push_back(st2.top()-&gt;val); st2.pop(); &#125; return ret; &#125;&#125;; ä½¿ç”¨åŒæ ˆçš„æ ¸å¿ƒæ€è·¯å°±æ˜¯ï¼šæŒ‰ç…§æ ¹å³å·¦çš„é¡ºåºè¿›è¡Œå…ˆåºéåŽ†ï¼Œç„¶åŽç”¨æ ˆå¼¹å‡ºè¿™ä¸ªéåŽ†é¡ºåºï¼Œè¿™æ ·æ€»ä½“çš„éåŽ†é¡ºåºå°±æ˜¯å·¦å³æ ¹äº†ï¼Œè¿™ä¹Ÿå°±æ˜¯åŽåºéåŽ†çš„é¡ºåºäº†ã€‚å®žé™…ä¸Šï¼Œä¹Ÿå¯ä»¥ä¸ä½¿ç”¨åŒæ ˆï¼Œç›´æŽ¥ç”¨ reverse å‡½æ•°æ¥é€†ç½®éåŽ†å¾—åˆ°çš„ç»“æžœåºåˆ—ã€‚å•æ ˆï¼š12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; stack&lt;TreeNode*&gt; st; TreeNode *pre = nullptr; while(root || !st.empty()) &#123; while(root)&#123; st.push(root); root = root-&gt;left; &#125; root = st.top(); st.pop(); if(!root-&gt;right || root-&gt;right == pre) &#123; ret.push_back(root-&gt;val); pre = root; root = nullptr; &#125; else &#123; st.push(root); root = root-&gt;right; &#125; &#125; return ret; &#125;&#125;; ä½¿ç”¨å•æ ˆå®Œæˆæ¨¡æ‹ŸåŽåºéåŽ†çš„æ€è·¯ä¸Žå…ˆã€ä¸­åºçš„å·®åˆ«åœ¨äºŽï¼šå¦‚ä½•åˆ¤æ–­è¿™ä¸ªç»“ç‚¹å·²ç»é‡åˆ°äº† 3 æ¬¡ï¼Œåªæœ‰å½“ç¬¬ 3 æ¬¡é‡åˆ°è¿™ä¸ªç»“ç‚¹æ—¶ï¼Œæ‰è®¿é—®å®ƒã€‚æ‰€ä»¥ï¼Œè¦ä½¿ç”¨ä¸€ä¸ª pre æŒ‡é’ˆæ¥è®°å½•å…¶å³å­æ ‘æ˜¯å¦å·²ç»è®¿é—®ï¼ˆå› ä¸ºå¼€å§‹æ—¶å°±å·²ç»å°†æ¯ä¸€å±‚æœ€å·¦è¾¹çš„ç»“ç‚¹å…¥æ ˆäº†ï¼Œæ‰€ä»¥åªç”¨åˆ¤æ–­å³ï¼‰ï¼Œå¦‚æžœå·²ç»è®¿é—®äº†å³å­ç»“ç‚¹ï¼Œé‚£ä¹ˆè¯´æ˜Žè¿™æ˜¯ç¬¬ 3 æ¬¡é‡åˆ°è¿™ä¸ªç»“ç‚¹äº†ï¼Œå°±è®¿é—®å®ƒã€‚ method 3åŒæ ·åŽåºéåŽ†ä¹Ÿæœ‰å…¶å¯¹åº”çš„ Morris éåŽ†æ–¹æ³•ã€‚12345678910111213141516171819202122232425262728293031323334class Solution &#123;public: void addpath(vector&lt;int&gt;&amp; seq, TreeNode *node) &#123; int cnt = 0; while(node) &#123; cnt++; seq.push_back(node-&gt;val); node = node-&gt;right; &#125; reverse(seq.end() - cnt, seq.end()); &#125; vector&lt;int&gt; postorderTraversal(TreeNode* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; TreeNode *p1 = root, *p2; while(p1) &#123; p2 = p1-&gt;left; if(p2) &#123; while(p2-&gt;right &amp;&amp; p2-&gt;right != p1) p2 = p2-&gt;right; if(!p2-&gt;right) &#123; p2-&gt;right = p1; p1 = p1-&gt;left; continue; &#125; else &#123; p2-&gt;right = nullptr; addpath(ret, p1-&gt;left); &#125; &#125; p1 = p1-&gt;right; &#125; addpath(ret, root); return ret; &#125;&#125;; Morris çš„åŽåºéåŽ†æ–¹æ³•æœ¬è´¨ä¸Šå…¶å®žä¸ŽåŒæ ˆå®žçŽ°çš„åŽåºéåŽ†æ²¡æœ‰å¤ªå¤§çš„åŒºåˆ«ï¼Œä½†æ˜¯èƒœåœ¨ç©ºé—´å¤æ‚åº¦æ˜¯ $O(1)$ã€‚æ¢å¥è¯è¯´ï¼Œaddpath å‡½æ•°åœ¨åšçš„äº‹æƒ…ï¼Œå°±æ˜¯åœ¨å›žåˆ°æ ¹ç»“ç‚¹çš„æ—¶å€™ï¼Œåˆ©ç”¨æ ¹èŠ‚ç‚¹æŒ‰ç…§æ ¹å³çš„é¡ºåºéåŽ†å·¦å­æ ‘ï¼Œç„¶åŽå†ç”¨ reverse å‡½æ•°é€†ç½®ï¼Œè¿™æ ·æ•´ä½“é¡ºåºå°±æ˜¯å³æ ¹äº†ï¼Œè€Œå·¦è¾¹çš„å¶å­ç»“ç‚¹ä¸€å®šæ˜¯æŽ’åœ¨äºŒè€…å‰é¢çš„ï¼Œæ‰€æ³¨æ„æœ€ç»ˆé¡ºåºå°±æ˜¯å·¦å³æ ¹äº†ã€‚ SummaryäºŒå‰æ ‘çš„éåŽ†çš„é€’å½’åšæ³•ï¼Œå…¶å®žå°±æ˜¯ DFSã€‚å°½ç®¡é€’å½’å¾ˆç®€å•ï¼Œä½†æ˜¯å¯¹éžé€’å½’çš„åšæ³•ä¹Ÿè¦ç†Ÿæ‚‰ï¼ŒMorris å¯èƒ½è¦æ±‚è¾ƒå°‘ï¼Œä½†æ˜¯ç”¨å•æ ˆå®žçŽ°çš„éžé€’å½’åšæ³•ï¼Œå¤šçœ‹çš„è¯ï¼Œåº”è¯¥å¯ä»¥å¾ˆç†Ÿç»ƒçš„èƒŒä¸‹æ¥å§ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day7]]></title>
    <url>%2F2022%2F04%2F14%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[ä¸¤ä¸ªè·ŸçŸ©é˜µç›¸å…³çš„ç®€å•é¢˜ã€‚ 1572. Matrix Diagonal SumAnalysisè¿”å›žå¯¹è§’çº¿å…ƒç´ ä¹‹å’Œå³å¯ã€‚ Code1234567891011class Solution &#123;public: int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(), sum = 0; for(int i = 0, j = n - 1; i &lt; n &amp;&amp; j &gt;= 0; i++, j--) &#123; sum += mat[i][i]; sum += mat[i][j]; &#125; return n % 2 ? sum - mat[n / 2][n / 2] : sum; &#125;&#125;; æ³¨æ„å½“ n æ˜¯å¥‡æ•°æ—¶ï¼Œä¸­é—´çš„å…ƒç´ ä¼šè¢«è®¡ç®— 2 æ¬¡ï¼Œæ‰€ä»¥ç»“æžœè¦å‡åŽ»ã€‚å—¯ï¼Œè¿™æ ·å†™å¯èƒ½ä¸å¤ªç¾Žè§‚ï¼Ÿæ”¹ä¸€ä¸‹ï¼š12345678910class Solution &#123;public: int diagonalSum(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int n = mat.size(), sum = 0; for(int i = 0; i &lt; n; i++) &#123; sum += mat[i][i] + mat[i][n - i - 1]; &#125; return sum - mat[n / 2][n / 2] * (n &amp; 1); &#125;&#125;; 566. Reshape the Matrixè¿™æ˜¯åšè¿‡çš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day4ã€‚ Summaryä»Šå¤©çš„ 2 ä¸ªé¢˜åšçš„å¤ªè½»æ¾å•¦~]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day9]]></title>
    <url>%2F2022%2F04%2F13%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[2 ä¸ªè·Ÿæ ˆã€é˜Ÿåˆ—ç›¸å…³çš„é¢˜ã€‚ 20. Valid ParenthesesAnalysisç»å…¸çš„æ‹¬å·åŒ¹é…é—®é¢˜ã€‚ Code1234567891011121314151617181920class Solution &#123;public: bool isValid(string s) &#123; if(s.length() % 2) return false; stack&lt;char&gt; st; bool flag = true; for(char ch: s) &#123; if(ch == '(' || ch == '[' || ch == '&#123;') st.push(ch); else if(!st.empty()) &#123; char tmp = st.top(); if(ch == ')' &amp;&amp; tmp == '(') st.pop(); else if(ch == ']' &amp;&amp; tmp == '[') st.pop(); else if(ch == '&#125;' &amp;&amp; tmp == '&#123;') st.pop(); else flag = false; &#125; else flag = false; &#125; if(st.empty() &amp;&amp; flag) return true; else return false; &#125;&#125;; æ³¨æ„å¦‚æžœå­—ç¬¦ä¸²é•¿åº¦ä¸ºå¥‡æ•°ï¼Œé‚£ä¹ˆä¸€å®šä¸ç¬¦åˆæ¡ä»¶ã€‚ 232. Implement Queue using StacksAnalysisè¿™ä¹Ÿæ˜¯ä¸ªç»å…¸çš„é—®é¢˜ï¼šç”¨æ ˆå®žçŽ°é˜Ÿåˆ—ã€‚ Codemethod 11234567891011121314151617181920212223242526272829303132333435class MyQueue &#123;public: stack&lt;int&gt; st1, st2; MyQueue() &#123; &#125; void push(int x) &#123; while(!st1.empty()) &#123; st2.push(st1.top()); st1.pop(); &#125; st2.push(x); while(!st2.empty()) &#123; st1.push(st2.top()); st2.pop(); &#125; &#125; int pop() &#123; if(st1.empty()) return false; int front = st1.top(); st1.pop(); return front; &#125; int peek() &#123; if(st1.empty()) return false; else return st1.top(); &#125; bool empty() &#123; return st1.empty(); &#125;&#125;; é‡ç‚¹è€ƒè™‘ push æ“ä½œï¼Œå§‹ç»ˆå°†å…ƒç´ æŒ‰ç…§é˜Ÿåˆ—å‡ºé˜Ÿçš„é¡ºåºæ”¾åœ¨ç¬¬ä¸€ä¸ªæ ˆä¸­ï¼Œè¿™æ ·å¯ä»¥ç®€åŒ–å…¶ä»–æ“ä½œã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œé™¤äº†æ–°å…ƒç´ å¤–ï¼Œå…¶ä»–å…ƒç´ éƒ½éœ€è¦å…¥æ ˆ 2 æ¬¡ï¼Œå‡ºæ ˆ 2 æ¬¡ï¼Œæ€»å…±çš„æ“ä½œæ¬¡æ•°å°±æ˜¯ $4n + 2$ï¼Œå…¶ä¸­ $n$ æ˜¯é˜Ÿåˆ—çš„å¤§å°ã€‚ method 2å®žé™…ä¸Šï¼Œä¹Ÿå¯ä»¥ä¸ç”¨æ¯æ¬¡éƒ½å°†å…ƒç´ å€’æ¢åˆ°ç¬¬ä¸€ä¸ªæ ˆå†…ã€‚è®¾ç½®ä¸€ä¸ª front å˜é‡ï¼Œå§‹ç»ˆä¿å­˜æœ€åŽä¸€ä¸ªå…¥æ ˆçš„å…ƒç´ ã€‚æ¯æ¬¡å‡ºé˜Ÿï¼Œå°±å°†ç¬¬ä¸€ä¸ªæ ˆä¸­çš„å…ƒç´ å…¨éƒ¨å€’å…¥åˆ°ç¬¬äºŒä¸ªæ ˆä¸­ï¼ŒåŒæ—¶å¼¹å‡ºç¬¬äºŒä¸ªæ ˆçš„æ ˆé¡¶å…ƒç´ ï¼Œè¿™æ ·å°±ä¸ç”¨æ¥å›žçš„å€’æ¢å…ƒç´ äº†ï¼Œä½†è¦ç¨å¾®ä¿®æ”¹ä¸‹ peek æ“ä½œå’Œ empty æ“ä½œã€‚å¦å¤–ï¼Œè¿™æ ·åšçš„å®žé™…æ“ä½œæ¬¡æ•°æ˜¯è¿œå°äºŽç¬¬ä¸€ç§æ–¹æ³•çš„ã€‚12345678910111213141516171819202122232425262728293031323334class MyQueue &#123;public: int front; stack&lt;int&gt; st1, st2; MyQueue() &#123; &#125; void push(int x) &#123; if(st1.empty()) front = x; st1.push(x); &#125; int pop() &#123; if(st2.empty()) &#123; while(!st1.empty()) &#123; st2.push(st1.top()); st1.pop(); &#125; &#125; int tmp = st2.top(); st2.pop(); return tmp; &#125; int peek() &#123; if(!st2.empty()) return st2.top(); return front; &#125; bool empty() &#123; return st1.empty() &amp;&amp; st2.empty(); &#125;&#125;; Summaryæ ˆä¸Žé˜Ÿåˆ—éƒ½æ˜¯ç®€å•çš„çº¿æ€§è¡¨ç»“æž„ï¼Œä¸éš¾ç†è§£ï¼Œä½†æ˜¯åœ¨å¤„ç†ä¸€äº›é—®é¢˜çš„æ—¶å€™ï¼Œä¹Ÿè¦çµæ´»ä½¿ç”¨ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œé¢å¯¹å¯¹è±¡çš„ç¨‹åºè¯­è¨€éƒ½ä¼šå°è£…å¥½ç±»ä¼¼çš„å®¹å™¨ï¼Œæ‰€ä»¥è¦ç†Ÿæ‚‰æŽŒæ¡è¿™äº›å®¹å™¨çš„ä½¿ç”¨ã€‚ä¸Žæ ˆç›¸å…³çš„ç»å…¸é¢˜åž‹ï¼Œè¿˜æœ‰è¡¨è¾¾å¼æ±‚å€¼é—®é¢˜ï¼Œä¸Žé˜Ÿåˆ—ç›¸å…³çš„é—®é¢˜ï¼Œè¿˜æœ‰å¾ªçŽ¯é˜Ÿåˆ—ç­‰ã€‚ä¸è¿‡ï¼Œéƒ½æ˜¯ä¸‡å˜ä¸ç¦»å…¶å®—ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Stack</tag>
        <tag>Queue</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day6]]></title>
    <url>%2F2022%2F04%2F13%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[3 ä¸ªç®€å•é¢˜~ 1588. Sum of All Odd Length SubarraysAnalysisé¢˜æ„æ˜¯æ±‚å«æœ‰å¥‡æ•°ä¸ªé¡¹çš„æ‰€æœ‰å­åºåˆ—çš„å’Œï¼Œ100 çš„æ•°é‡çº§ï¼Œåº”è¯¥å¯ä»¥ç›´æŽ¥åšå‡ºæ¥ã€‚ Codemethod 1ç”¨ step æ¥æŽ§åˆ¶æ¯æ¬¡é€‰æ‹©è¿žç»­å¥‡æ•°ä¸ªæ•°ç»„æˆå­åºåˆ—ï¼Œç„¶åŽæ±‚å’Œã€‚12345678910111213141516class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; for(int step = 1; step &lt;= size; step += 2) &#123; for(int i = 0; i &lt; size; i++) &#123; if(i + step &lt;= size) &#123; for(int j = i; j &lt; i + step; j++) &#123; sum += arr[j]; &#125; &#125; else break; &#125; &#125; return sum; &#125;&#125;; è¿™æ ·åšçš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O(n^3)$ã€‚ method 2ä½†æ˜¯ç›´æŽ¥åšæ˜¾ç„¶ä¸å¤Ÿä¼˜é›…ï¼Œè§‚å¯Ÿä¸Šé¢çš„è®¡ç®—è¿‡ç¨‹ï¼Œä»¥ $1, 2, 3$ çš„åºåˆ—ä¸ºä¾‹ï¼Œè®¡ç®—è¿‡ç¨‹æ˜¯ $1 + 2 + 3 + 1 + 2 + 3 = 9$ï¼Œå®žé™…ä¸Šæ˜¯æ±‚äº†ä¸¤æ¬¡æ•°ç»„çš„å…ƒç´ ä¹‹å’Œï¼Œå¦‚æžœèƒ½æƒ³ä¸ªåŠžæ³•åªæ±‚ä¸€æ¬¡å’Œå°±å¥½äº†ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è€ƒæ€è·¯ï¼Œå¯ä»¥ä½¿ç”¨å‰ç¼€å’Œæ€æƒ³æ¥åšã€‚1234567891011121314151617class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; vector&lt;int&gt; prefixnum(size + 1); for(int i = 0; i &lt; size; i++) &#123; prefixnum[i + 1] = prefixnum[i] + arr[i]; &#125; for(int i = 0; i &lt; size; i++) &#123; for(int step = 1; step + i &lt;= size; step += 2) &#123; int tmp = i + step - 1; sum += prefixnum[tmp + 1] - prefixnum[i]; &#125; &#125; return sum; &#125;&#125;; ä½¿ç”¨å‰ç¼€å’Œéœ€è¦å€ŸåŠ© $O(n)$ çš„ç©ºé—´ï¼Œä½†å¯ä»¥å°†æ—¶é—´å¤æ‚åº¦é™åˆ° $O(n^2)$ã€‚ method 3å°½ç®¡åˆ©ç”¨å‰ç¼€å’Œæ€æƒ³è§£å†³äº†é‡å¤æ±‚å’Œçš„é—®é¢˜ï¼Œä½†æ˜¯æ•´ä¸ªè¿‡ç¨‹è¿˜æ˜¯ä¸æ–­çš„å°†å’Œé‡å¤çš„ç›¸åŠ ã€‚æŒ‰ç…§ç»™çš„æ ·ä¾‹ $1, 4, 2, 5, 3$ çš„è®¡ç®—è¿‡ç¨‹å¯ä»¥å‘çŽ°ï¼Œè¿™ 5 ä¸ªå…ƒç´ æ€»æ˜¯ä¸æ–­çš„é‡å¤å‡ºçŽ°ï¼Œæœ€ç»ˆçš„ç»“æžœå¯ä»¥å†™æˆï¼š$1 \times 3 + 4 \times 4 + 2 \times 5 + 5 \times 4 + 3 \times 3 = 58$ï¼Œæ•´ä¸ªæ•°å­—åºåˆ—çš„ç³»æ•°å¯¹åº”å®ƒä»¬çš„å‡ºçŽ°æ¬¡æ•°ï¼Œåˆ†åˆ«æ˜¯ï¼š$3, 4, 5, 4, 3$ã€‚å¦‚æžœèƒ½å¾ˆå®¹æ˜“å¾—åˆ°è¿™äº›ç³»æ•°ï¼Œé‚£ä¹ˆæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ä¸å°±ç®€å•äº†å—ï¼Ÿå®žé™…ä¸Šï¼Œè¿™äº›ç³»æ•°çš„å«ä¹‰æ­£å¥½å°±æ˜¯å½“å‰è¿™ä¸ªæ•°å­—èƒ½ç»„æˆçš„è¿žç»­å¥‡æ•°ä¸ªé¡¹çš„å­åºåˆ—çš„ä¸ªæ•°ï¼ˆè¯´çš„æœ‰ç‚¹ç»•ï¼‰ã€‚é‚£ä¹ˆä»”ç»†æ€è€ƒä¸€ä¸‹ï¼Œå¯¹äºŽä¸€ä¸ªæ•°å­—ï¼Œå¦‚æžœå…¶å‡ºçŽ°åœ¨å¥‡æ•°ä¸ªè¿žç»­æ•°å­—çš„å­åºåˆ—ä¸­ï¼Œé‚£ä¹ˆå…¶å·¦å³ä¸¤è¾¹æ•°çš„ä¸ªæ•°è¦ä¹ˆåŒæ˜¯å¥‡æ•°è¦ä¹ˆåŒæ˜¯å¶æ•°ï¼Œåªæœ‰è¿™æ ·æœ€ç»ˆå¾—åˆ°çš„åºåˆ—çš„é¡¹æ•°æ‰æ˜¯å¥‡æ•°ã€‚é‚£ä¹ˆï¼Œå‡è®¾å½“å‰æ•°å­—ä¸º $arr[i]$ï¼Œå…¶å·¦è¾¹çš„æ•°å­—ä¸ªæ•°ä¸º $leftcount$ï¼Œå³è¾¹çš„æ•°å­—ä¸º $rightcount$ï¼Œåˆ†ç±»è®¨è®ºä¸€ä¸‹ï¼š åŒæ˜¯å¥‡æ•°ï¼Œé‚£ä¹ˆ $arr[i]$ å·¦è¾¹çš„å¥‡æ•°ä¸ªæ•°å°±æ˜¯ $leftodd = \lfloor \frac {leftcount + 1}{2} \rfloor$ï¼Œå³è¾¹å¥‡æ•°çš„ä¸ªæ•°å°±æ˜¯ $rightodd = \lfloor \frac {rightcount + 1}{2} \rfloor$ï¼Œè¿™æ ·ç”± $arr[i]$ ç»„æˆçš„å­åºåˆ—ä¸ªæ•°å°±æ˜¯ $leftodd \times rightodd$ã€‚ åŒæ˜¯å¶æ•°ï¼Œé‚£ä¹ˆ $arr[i]$ å·¦è¾¹çš„å¶æ•°ä¸ªæ•°å°±æ˜¯ $lefteven = \lfloor \frac {leftcount}{2} \rfloor + 1$ï¼Œå³è¾¹å¶æ•°çš„ä¸ªæ•°å°±æ˜¯ $righteven = \lfloor \frac {rightcount}{2} \rfloor + 1$ï¼Œè¿™æ ·ç”± $arr[i]$ ç»„æˆçš„å­åºåˆ—ä¸ªæ•°å°±æ˜¯ $lefteven \times righteven$ã€‚ æœ€ç»ˆç”± $arr[i]$ ç»„æˆçš„ç¬¦åˆæ¡ä»¶çš„å­åºåˆ—ä¸ªæ•°å°±æ˜¯ $leftodd \times rightodd \sum lefteven \times righteven$ï¼Œè¿™ä¹Ÿå°±æ˜¯å®ƒçš„ç³»æ•°ã€‚12345678910111213class Solution &#123;public: int sumOddLengthSubarrays(vector&lt;int&gt;&amp; arr) &#123; int size = arr.size(), sum = 0; for(int i = 0; i &lt; size; i++) &#123; int leftcount = i, rightcount = size - i - 1; int leftodd = (leftcount + 1) / 2, rightodd = (rightcount + 1) / 2; int lefteven = leftcount / 2 + 1, righteven = rightcount / 2 + 1; sum += arr[i] * (leftodd * rightodd + lefteven * righteven); &#125; return sum; &#125;&#125;; 283. Move Zeroesè¿™ä¸ªé¢˜æ˜¯åšè¿‡çš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©ç®—æ³•å…¥é—¨_day3ã€‚å†åšä¸€æ¬¡å§~ 1672. Richest Customer WealthAnalysisè¿™å¥½åƒæ˜¯é“å•çº¯çš„äºŒç»´æ•°ç»„éåŽ†çš„é¢˜ç›®~ Code1234567891011121314class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int max = -1, sum; for(int i = 0; i &lt; accounts.size(); i++) &#123; sum = 0; for(int j = 0; j &lt; accounts[i].size(); j++) &#123; sum += accounts[i][j]; &#125; if(max &lt; sum) max = sum; &#125; return max; &#125;&#125;; å—¯ï¼Œå›žå¿†ä¸€ä¸‹åº“å‡½æ•°çš„ä½¿ç”¨å§ã€‚12345678910class Solution &#123;public: int maximumWealth(vector&lt;vector&lt;int&gt;&gt;&amp; accounts) &#123; int maxwealth = -1, sum; for(int i = 0; i &lt; accounts.size(); i++) &#123; maxwealth = max(maxwealth, accumulate(accounts[i].begin(), accounts[i].end(), 0)); &#125; return maxwealth; &#125;&#125;; Summaryå—¯ï¼Œæˆ‘å‘è§‰è¿™é‡Œé¢çš„ç®€å•é¢˜æ€»æ˜¯æœ‰ä¸é‚£ä¹ˆç®€å•çš„åšæ³•å•Šï¼Œå°±æ‹¿ç¬¬ä¸€ä¸ªé¢˜æ¥è¯´ï¼Œä¸ç®¡æ˜¯å‰ç¼€å’Œçš„æ€è·¯è¿˜æ˜¯æ•°å­¦çš„æ€è·¯ï¼Œéƒ½æ˜¯å¾ˆä¸é”™çš„é”»ç‚¼æ€ç»´çš„æ–¹æ³•ï¼Œå¾—å¤šæ€è€ƒä¸‹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day8]]></title>
    <url>%2F2022%2F04%2F12%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©è¿˜æ˜¯é“¾è¡¨å“¦ 206. Reverse Linked Listè¿™ä¸ªé¢˜åšè¿‡å•¦ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©ç®—æ³•å…¥é—¨_day10å†å†™ä¸€é~ 83. Remove Duplicates from Sorted ListAnalysisåˆ é™¤æœ‰åºé“¾è¡¨çš„é‡å¤å…ƒç´ ï¼Œæ—¢ç„¶ç»™å®šçš„æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆé‡å¤å…ƒç´ ä¸€å®šæ˜¯ç›¸é‚»çš„ï¼Œè¿™æ ·å°±å¥½åŠžäº†ã€‚ Codemethod 1123456789101112131415class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head) return nullptr; ListNode *cur = head, *p; while(cur) &#123; if(cur-&gt;next != nullptr &amp;&amp; cur-&gt;val == cur-&gt;next-&gt;val) &#123; p = cur-&gt;next; cur-&gt;next = p-&gt;next; delete(p); &#125; else cur = cur-&gt;next; &#125; return head; &#125;&#125;; method 2ä¸ç”¨æƒ³ï¼Œè‚¯å®šæœ‰é€’å½’çš„åšæ³•ðŸ˜‚ã€‚123456789class Solution &#123;public: ListNode* deleteDuplicates(ListNode* head) &#123; if(!head || !head-&gt;next) return head; head-&gt;next = deleteDuplicates(head-&gt;next); if(head-&gt;val == head-&gt;next-&gt;val) head-&gt;next = head-&gt;next-&gt;next; return head; &#125;&#125;; é€’å½’æ˜¯åœ¨å›žé€€çš„æ—¶å€™åˆ é™¤çš„ç»“ç‚¹ï¼Œä½†æœ¬è´¨ä¸Šå¹¶æ²¡æœ‰å°†ç»“ç‚¹å ç”¨çš„å†…å­˜æ‰‹åŠ¨é‡Šæ”¾æŽ‰ã€‚ Summaryé“¾è¡¨çš„é¢˜åšäº†ä¸€äº›äº†ï¼ŒåŸºæœ¬æ€è·¯ç®—æ˜¯é½æ´»äº†ï¼Œå°±æ˜¯é€’å½’å†™çš„ä¸ç†Ÿç»ƒ...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linked_list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day5]]></title>
    <url>%2F2022%2F04%2F12%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[keeping going~ 589. N-ary Tree Preorder TraversalAnalysisN å‰æ ‘çš„å…ˆåºéåŽ†ï¼Œç›´æŽ¥é€’å½’ã€‚ Codemethod 1123456789101112131415class Solution &#123;public: void pre(Node *root, vector&lt;int&gt;&amp; ret) &#123; if(!root) return; ret.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++) &#123; pre(root-&gt;children[i], ret); &#125; &#125; vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; pre(root, vector&lt;int&gt;&amp; ret); return ret; &#125;&#125;; å¯¹è¿™é“é¢˜çš„é€’å½’è¿‡ç¨‹å€’æ˜¯å¾ˆæ¸…æ¥šï¼Œå“ˆå“ˆã€‚ method 2å€ŸåŠ©æ ˆä¹Ÿå¯ä»¥æ¥å®Œæˆï¼Œç”±äºŽå­©å­ç»“ç‚¹å¯èƒ½æœ‰å¤šä¸ªï¼Œæ‰€ä»¥éœ€è¦ç”¨ map æ¥è®°å½•ä¸€ä¸‹è®¿é—®åˆ°äº†é‚£ä¸ªå­©å­ç»“ç‚¹ã€‚12345678910111213141516171819202122232425262728293031class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; stack&lt;Node*&gt; st; unordered_map&lt;Node*, int&gt; ht; Node *node = root; while(!st.empty() || node != nullptr) &#123; while(node != nullptr) &#123; ret.push_back(node-&gt;val); st.push(node); if(node-&gt;children.size() &gt; 0) &#123; ht[node] = 0; node = node-&gt;children[0]; &#125; else node = nullptr; &#125; node = st.top(); int index = (ht.count(node) ? ht[node] : -1) + 1; if(index &lt; node-&gt;children.size()) &#123; ht[node] = index; node = node-&gt;children[index]; &#125; else &#123; st.pop(); ht.erase(node); node = nullptr; &#125; &#125; return ret; &#125;&#125;; å¯ä»¥å‘çŽ°ï¼Œå› ä¸ºæ¯æ¬¡éœ€è¦ä¿æŒå·¦è¾¹çš„ç»“ç‚¹å…ˆè®¿é—®ï¼Œæ‰€ä»¥è¦å…ˆå°†å·¦è¾¹ç¬¬ä¸€ä¸ªç»“ç‚¹å…¥æ ˆã€‚ç»“åˆæ ˆå…ˆè¿›åŽå‡ºçš„ç‰¹ç‚¹ï¼Œä¸å¦¨ä¸€æ¬¡æ€§å°†ç»“ç‚¹çš„å­©å­å…¨éƒ¨é€†åºå…¥æ ˆï¼Œè¿™æ ·æ ˆé¡¶å…ƒç´ å°±æ˜¯éœ€è¦è®¿é—®çš„æœ€å·¦è¾¹çš„å…ƒç´ ã€‚123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; ret; if(!root) return ret; stack&lt;Node*&gt; st; st.push(root); while(!st.empty()) &#123; Node *node = st.top(); st.pop(); ret.push_back(node-&gt;val); for(auto it = node-&gt;children.rbegin(); it != node-&gt;children.rend(); it++) &#123; st.push(*it); &#125; &#125; return ret; &#125;&#125;; 496. Next Greater Element IAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹éº»çƒ¦ï¼Œå…ˆæ‰¾å‡º $nums1[i]$ åœ¨ $nums2$ ä¸­çš„ä½ç½®ï¼ˆä¹Ÿå°±æ˜¯ $nums2[j]$ï¼‰ï¼Œç„¶åŽåœ¨æ‰¾å‡º $nums2[j]$ ä¹‹åŽç¬¬ä¸€ä¸ªæ¯” $nums2[j]$ å¤§çš„æ•°ã€‚ Codemethod 1æ•°é‡çº§ä¸å¤§ï¼Œç›´æŽ¥æš´åŠ›è§£å†³ã€‚1234567891011121314151617181920class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; ret.resize(nums1.size()); for(int i = 0;i &lt; nums1.size(); i++) &#123; bool flag1 = false, flag2 = false; for(int j = 0; j &lt; nums2.size(); j++) &#123; if(nums2[j] == nums1[i]) flag1 = true; if(flag1 &amp;&amp; nums2[j] &gt; nums1[i]) &#123; ret[i] = nums2[j]; flag2 = true; break; &#125; &#125; if(!flag2) ret[i] = -1; &#125; return ret; &#125;&#125;; ä½¿ç”¨ 2 ä¸ª bool å˜é‡æ¥ååŠ©æŸ¥æ‰¾ï¼Œå°±ä¸ç”¨é‡å¤éåŽ† nums2 äº†ï¼Œè¿™æ ·æ€»ä½“æ—¶é—´å¤æ‚åº¦æ˜¯ $O(nums1.length Ã— nums2.length)$ã€‚ method 2è¿˜æœ‰ä¸€ä¸ªè¿›é˜¶æç¤ºï¼Œé—®æœ‰æ²¡æœ‰ $O(nums1.length + nums2.length)$ çš„è§£æ³•ï¼Œä¹Ÿä¸çŸ¥é“è¿™ä¸ªæç¤ºè¦æ±‚çš„æ˜¯æ—¶é—´å¤æ‚åº¦è¿˜æ˜¯ç©ºé—´å¤æ‚åº¦ã€‚çœ‹äº†ä¸€ä¸‹é¢˜è§£ï¼ŒåŽŸæ¥æ˜¯æ—¶é—´å¤æ‚åº¦å•Šã€‚è¦è¾¾åˆ°è¿™æ ·çš„æ—¶é—´å¤æ‚åº¦ï¼Œéœ€è¦å€ŸåŠ©ä¸€ç§æ–°çš„æ€æƒ³â€”â€”å•è°ƒæ ˆï¼ˆMonotonic Stackï¼‰ã€‚å½“ç„¶äº†ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯ç”¨æ ˆï¼Œåªä¸è¿‡å…ˆéåŽ† $nums2$ å°†æ‰€æœ‰æ•°å­—åŽé¢ç¬¬ä¸€ä¸ªæ¯”å®ƒå¤§çš„æ•°éƒ½æ‰¾åˆ°ï¼Œç„¶åŽåœ¨éåŽ† $nums1$ï¼Œä¸ºäº†æ–¹ä¾¿æŸ¥è¯¢ï¼Œå€ŸåŠ©ä¸€ä¸‹å“ˆå¸Œè¡¨ã€‚123456789101112131415161718class Solution &#123;public: vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; stack&lt;int&gt; st; unordered_map&lt;int, int&gt; ht; for(int i = nums2.size() - 1; i &gt;= 0; i--) &#123; int num = nums2[i]; while(!st.empty() &amp;&amp; num &gt;= st.top()) st.pop(); ht[num] = st.empty() ? -1 : st.top(); st.push(num); &#125; vector&lt;int&gt; ret; for(int i = 0; i &lt; nums1.size(); i++) &#123; ret.push_back(ht[nums1[i]]); &#125; return ret; &#125;&#125;; em...å¥½å¥½ä½“ä¼šä¸€ä¸‹æ ˆçš„è¿™ç§åº”ç”¨ã€‚ 1232. Check If It Is a Straight LineAnalysisè¿™ä¸ªé¢˜å¥½åƒåœ¨è€ƒä¸€æ¬¡å‡½æ•°çš„çŸ¥è¯†ç‚¹ï¼Œè¿™å¥½åƒæ˜¯åˆä¸­æ•°å­¦ã€‚ Codeç›´æŽ¥ç”¨å‰ 2 ä¸ªç‚¹æ±‚å‡ºä¸€æ¬¡å‡½æ•°çš„æ–¹ç¨‹ï¼Œç„¶åŽéªŒè¯åŽé¢çš„ç‚¹æ˜¯å¦åœ¨ä¸Šé¢å³å¯ã€‚123456789101112131415161718192021222324class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; double k, b, diff1, diff2; diff1 = coordinates[1][1] - coordinates[0][1]; diff2 = coordinates[1][0] - coordinates[0][0]; if(diff1 == 0) &#123; for(int i = 0; i &lt; coordinates.size() - 1; i++) &#123; if(coordinates[i][1] != coordinates[i + 1][1]) return false; &#125; &#125; else if(diff2 == 0) &#123; for(int i = 0; i &lt; coordinates.size() - 1; i++) &#123; if(coordinates[i][0] != coordinates[i + 1][0]) return false; &#125; &#125; else &#123; k = diff1 / diff2; b = coordinates[0][1] - k * coordinates[0][0]; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if(coordinates[i][1] != b + k * coordinates[i][0]) return false; &#125; &#125; return true; &#125;&#125;; æ³¨æ„å‡ ä¸ªç‚¹ï¼š åæ ‡è½´ä¸Šçš„ç‚¹ä¹Ÿèƒ½è¿žæˆä¸€æ¡ç›´çº¿ã€‚ å½¢å¦‚ $y = 2, x = 1$ è¿™æ ·ä¸Žåæ ‡è½´åž‚ç›´çš„çº¿ä¹Ÿç¬¦åˆé¢˜æ„ã€‚ æ³¨æ„æ±‚æ–œçŽ‡æ—¶ï¼Œ$x$ ä¸èƒ½ä¸º 0ã€‚ å®žé™…ä¸Šä¸ºäº†é¿å…ä¸Šé¢çš„é—®é¢˜ï¼Œå®Œå…¨å¯ä»¥ä¸æ±‚æ–œçŽ‡ã€‚å› ä¸ºç›´çº¿è¿˜æœ‰å…¶ä»–å½¢å¼çš„æ–¹ç¨‹ï¼Œæ‰€ä»¥ä½¿ç”¨å…¶ä»–æ–¹ç¨‹å°±å¯ä»¥å¾—åˆ°ä¸ä¸€æ ·çš„ä»£ç ã€‚123456789101112131415class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; int deltax = coordinates[0][0], deltay = coordinates[0][1]; for(int i = 0; i &lt; coordinates.size(); i++) &#123; coordinates[i][0] -= deltax; coordinates[i][1] -= deltay; &#125; int A = coordinates[1][1], B = -coordinates[1][0]; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if(coordinates[i][0] * A + coordinates[i][1] * B != 0) return false; &#125; return true; &#125;&#125;; ä¸Šé¢çš„ä»£ç å°†ç¬¬ä¸€ä¸ªç‚¹å¹³ç§»åˆ°åŽŸç‚¹ï¼Œå…¶ä»–ç‚¹å¹³ç§»äº†ç¬¬ä¸€ä¸ªç‚¹çš„è·ç¦»ã€‚è¿™æ ·åˆ©ç”¨ç›´å…ˆçš„ä¸€èˆ¬å¼ï¼ˆ$y = Ax + By + C$ï¼‰æ±‚ A å’Œ B æ—¶ï¼Œä»»æ„ä¸€ä¸ªç‚¹çš„æ¨ªçºµåæ ‡æ”¹å˜ä¸€ä¸‹ç¬¦å·å°±å¯ä»¥äº†ï¼Œè¿™å°±çœåŽ»äº†æ±‚æ–œçŽ‡çš„è¿‡ç¨‹ã€‚ å½“ç„¶äº†ï¼Œè¿˜å¯ä»¥ç”¨ç›´çº¿çš„ä¸¤ç‚¹å¼ï¼ˆ$\frac{y-y1}{x-x1} = \frac{y-y2}{x-x2}$ï¼‰æ¥æ±‚ã€‚1234567891011121314class Solution &#123;public: bool checkStraightLine(vector&lt;vector&lt;int&gt;&gt;&amp; coordinates) &#123; for(int i = 2; i &lt; coordinates.size(); i++) &#123; if( (coordinates[i][0] - coordinates[0][0]) * (coordinates[i][1] - coordinates[1][1]) != (coordinates[i][0] - coordinates[1][0]) * (coordinates[i][1] - coordinates[0][1]) ) return false; &#125; return true; &#125;&#125;; å¦å¤–ï¼ŒåŠ ä¸€å¥ï¼Œè®¡ç®—æœºåšé™¤æ³•æ¶ˆè€—çš„æ—¶é—´æ˜¯å¤§äºŽä¹˜æ³•çš„ã€‚ Summaryä»Šå¤©çš„ 3 ä¸ªé¢˜ï¼Œè¯´ç®€å•ä¹Ÿä¸æ˜¯é‚£ä¹ˆç®€å•ï¼Œå› ä¸ºéƒ½éœ€è¦åŠ¨ç‚¹è„‘ç­‹åŽæ‰èƒ½å˜å¾—ç®€å•ã€‚ç‰¹åˆ«æ˜¯ç¬¬äºŒä¸ªå’Œç¬¬ä¸‰ä¸ªé¢˜ï¼Œè¿™ä¸¤ä¸ªé¢˜ï¼Œç”¨çš„æ–¹æ³•ä¸ä¸€æ ·ï¼Œå†™å‡ºæ¥çš„ä»£ç ä¹Ÿæ˜¯ä¸ä¸€æ ·çš„ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day7]]></title>
    <url>%2F2022%2F04%2F11%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[ä¹‹å‰é“¾è¡¨çš„é¢˜ç¡®å®žæ²¡åšå¤Ÿå•Š~ 141. Linked List CycleAnalysisåˆ¤æ–­é“¾è¡¨ä¸­æ˜¯å¦å­˜åœ¨çŽ¯ï¼Œå¾ˆç›´è§‚çš„åšæ³•å°±æ˜¯åˆ©ç”¨å“ˆå¸Œè¡¨äº†ï¼Œå¦‚æžœè®¿é—®è¿‡çš„ç»“ç‚¹åˆå†æ¬¡è¢«è®¿é—®äº†ï¼Œé‚£ä¹ˆä¸€å®šå­˜åœ¨çŽ¯ã€‚ Codemethod 1ç›´æŽ¥ç”¨ set å®¹å™¨æ¥æž„é€ ä¸€ä¸ªå“ˆå¸Œè¡¨ã€‚1234567891011121314class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *p = head; unordered_set&lt;ListNode*&gt; ht; while(p) &#123; if(ht.find(p) != ht.end()) return true; ht.insert(p); p = p-&gt;next; &#125; return false; &#125;&#125;; method 2æœ‰ä¸ªè¿›é˜¶æç¤ºï¼Œå¦‚ä½•èƒ½åœ¨å¸¸é‡çš„ç©ºé—´å¤æ‚åº¦è§£å†³è¿™ä¸ªé—®é¢˜ã€‚æœ‰äº†åš 202. Happy Number çš„ç»éªŒï¼Œè¿™é‡Œå¾ˆè‡ªç„¶å°±ä¼šæƒ³åˆ°ç”¨å¿«æ…¢æŒ‡é’ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚123456789101112class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *slow = head, *fast = head-&gt;next; while(fast &amp;&amp; slow != fast) &#123; slow = slow-&gt;next; fast = fast-&gt;next ? fast-&gt;next-&gt;next : fast-&gt;next; &#125; return fast != nullptr; &#125;&#125;; æ³¨æ„ï¼Œå¦‚æžœä¸å­˜åœ¨å¾ªçŽ¯é“¾è¡¨ï¼Œå¹¶ä¸” fast æŒ‡å‘çš„æ˜¯å€’æ•°ç¬¬äºŒä¸ªç»“ç‚¹æ—¶ï¼Œç›´æŽ¥è·³ 2 ä¸ªç»“ç‚¹ä¼šå‡ºé”™ï¼Œå› ä¸ºé‚£ä¸ªç»“ç‚¹æ˜¯ä¸å­˜åœ¨çš„ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­ä¸€ä¸‹ã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥åœ¨å¼€å§‹çš„æ—¶å€™å°†å¿«æ…¢æŒ‡é’ˆè®¾ç½®ä¸€æ ·ã€‚12345678910111213class Solution &#123;public: bool hasCycle(ListNode *head) &#123; if(head == nullptr) return false; ListNode *slow = head, *fast = head; while(fast &amp;&amp; fast-&gt;next) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; if(fast == slow) return true; &#125; return false; &#125;&#125;; 21. Merge Two Sorted Listsè¿™ä¸ªé¢˜æ˜¯åšçš„é¢˜ï¼Œå‚è€ƒï¼šLeetcode_14 å¤©ç®—æ³•å…¥é—¨_day10ã€‚å—¯ï¼Œä»£ç å°±ä¸è´´äº†ï¼Œå†å†™ä¸€ä¸‹å°±è¡Œäº†ã€‚ 203. Remove Linked List ElementsAnalysisæ„Ÿè§‰è¿™ä¸ªé¢˜æ¯”ä¸Šä¸ªé¢˜å®¹æ˜“ï¼Œåªè¦åˆ é™¤é“¾è¡¨ä¸­å€¼ä¸º val çš„ç»“ç‚¹å°±å¯ä»¥äº†ã€‚å…ˆæ‰¾åˆ°ç»“ç‚¹ä½ç½®ï¼Œç„¶åŽåœ¨åˆ é™¤ã€‚ Codemethod 1å€ŸåŠ©å“‘ç»“ç‚¹æ¥å®Œæˆï¼Œæ¯”è¾ƒç®€å•ã€‚1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) &#123;&#125; * ListNode(int x) : val(x), next(nullptr) &#123;&#125; * ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; ListNode *L = new ListNode; ListNode *p = L, *cur; p-&gt;next = head; while(p) &#123; if(p-&gt;next &amp;&amp; p-&gt;next-&gt;val == val) &#123; cur = p-&gt;next; p-&gt;next = cur-&gt;next; delete(cur); &#125; else p = p-&gt;next; &#125; p = L; L = L-&gt;next; delete(p); return L; &#125;&#125;; method 2åŒæ ·ï¼Œè¿™ä¸ªé¢˜ä¾ç„¶å¯ä»¥ç”¨é€’å½’æ¥åšï¼Œå°±æ˜¯æœ‰ç‚¹éš¾æƒ³åˆ°å•Šã€‚12345678class Solution &#123;public: ListNode* removeElements(ListNode* head, int val) &#123; if(head == nullptr) return head; head-&gt;next = removeElements(head-&gt;next, val); return head-&gt;val == val ? head-&gt;next : head; &#125;&#125;; Summaryè¿™å‡ ä¸ªé“¾è¡¨é¢˜æ„Ÿè§‰æ¯”è¾ƒç®€å•ã€å¸¸è§„ï¼Œä¸è¿‡é€’å½’çš„åšæ³•çœŸéš¾æƒ³å•Šã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Linked_list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day4]]></title>
    <url>%2F2022%2F04%2F11%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[è¿™ä¸ªç³»åˆ—å¥½åƒéƒ½æ˜¯ç®€å•é¢˜...æœ‰ç‚¹æ²¡æœ‰æŒ‘æˆ˜æ€§~ 1822. Sign of the Product of an ArrayAnalysisè¿™ä¸ªé¢˜å¦‚æžœç›´æŽ¥ç®—ï¼Œä¼šæº¢å‡ºã€‚å®žé™…ä¸Šï¼Œå¹¶æ²¡æœ‰ç®—å‡ºæ¥çš„å¿…è¦ï¼Œç”¨è´Ÿæ•°çš„ä¸ªæ•°å°±å¯ä»¥æ¥åˆ¤æ–­æœ€ç»ˆç»“æžœæ˜¯å¦ä¸ºè´Ÿã€‚ Code1234567891011class Solution &#123;public: int arraySign(vector&lt;int&gt;&amp; nums) &#123; int negative = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i] == 0) return 0; else if(nums[i] &lt; 0) negative++; &#125; return negative % 2 == 1 ? -1 : 1; &#125;&#125;; è¯è¯´å›žæ¥ï¼Œè¿˜æ˜¯ WA äº†ä¸€æ¬¡ï¼Œè¿˜æ˜¯çœ‹é¢˜ä»”ç»†ä¸€ç‚¹å•Šã€‚ 1502. Can Make Arithmetic Progression From SequenceAnalysisä¸€å¼€å§‹æ²¡çœ‹æ‡‚ arithmetic progressionï¼Œçœ‹äº†ç”¨ä¾‹æ‰çŸ¥é“ï¼ŒåŽŸæ¥æ˜¯ç­‰å·®æ•°åˆ—çš„æ„æ€ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé¢˜ç›®æ„æ€å°±æ˜¯åˆ¤æ–­ç»™å®šæ•°å­—åºåˆ—æ˜¯å¦æž„æˆä¸€ä¸ªç­‰å·®æ•°åˆ—ã€‚è¿™æ ·çš„è¯ï¼Œç›´æŽ¥æŽ’åºç„¶åŽé€ä¸ªåˆ¤æ–­å°±è¡Œäº†ã€‚ Code1234567891011class Solution &#123;public: bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(), arr.end()); int diff = arr[0] - arr[1]; for(int i = 1; i &lt; arr.size() - 1; i++) &#123; if(diff != arr[i] - arr[i + 1]) return false; &#125; return true; &#125;&#125;; 202. Happy NumberAnalysisè¿™ä¸ªé¢˜ç›®åå­—æœ‰ç‚¹å–œæ„Ÿ...é¢˜ç›®æœ‰ PAT çš„å‘³é“äº†ã€‚æŒ‰ç…§é¢˜ç›®çš„æ„æ€ï¼Œå¯¹äºŽæ¯ä¸€ä¸ªæ•°å­—è€Œè¨€ï¼Œå¦‚æžœæ˜¯å¿«ä¹æ•°ï¼Œé‚£ä¹ˆæœ€ç»ˆä¼šå˜æˆ 1ï¼›å¦‚æžœä¸æ˜¯å¿«ä¹æ•°ï¼Œé‚£ä¹ˆæœ€ç»ˆä¼šæ— é™å¾ªçŽ¯ä¸‹åŽ»ã€‚é‚£ä¹ˆï¼Œåº”è¯¥å¦‚ä½•åˆ¤æ–­é™·å…¥æ— é™å¾ªçŽ¯ä¸­äº†å‘¢ï¼Ÿ Codemethod 1è¦åˆ¤æ–­é™·å…¥æ— é™å¾ªçŽ¯ï¼Œå¯ä»¥å€ŸåŠ©å“ˆå¸Œè¡¨ï¼Œåªè¦å‡ºçŽ°è¿‡çš„æ•°å­—åˆä¸€æ¬¡å‡ºçŽ°äº†ï¼Œé‚£ä¹ˆä¸€å®šè¯´æ˜Žè¿™ä¸ªæ•°ä¸æ˜¯å¿«ä¹æ•°ã€‚12345678910111213141516171819class Solution &#123;public: bool isHappy(int n) &#123; int now; set&lt;int&gt; ht; while(1) &#123; now = 0; while(n) &#123; now += pow(n % 10, 2); n /= 10; &#125; if(now == 1) return true; if(ht.find(now) != ht.end()) break; ht.insert(now); n = now; &#125; return false; &#125;&#125;; method 2æ—¢ç„¶çŸ¥é“äº†ä¼šé™·å…¥å¾ªçŽ¯ï¼Œè€Œä¸”é¢˜ç›®åˆç»™å‡ºäº†ä¸€ä¸ªå¾ªçŽ¯çš„ä¾‹å­ï¼Œå¤§å¯ä»¥çœ‹çœ‹å¾ªçŽ¯ä¸­çš„æ•°éƒ½æ˜¯äº›ä»€ä¹ˆã€‚æŒ‰ç…§ $n=2$ è¾“å…¥åŽï¼Œæœ€åŽä¼šå¾—åˆ°ï¼š$4, 16, 37, 58, 89, 145, 42, 20, 4,...$ çš„å¾ªçŽ¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œéžå¿«ä¹æ•°æœ€ç»ˆä¼šé™·å…¥è¿™æ ·çš„æ— é™å¾ªçŽ¯ä¸­ã€‚è¿™æ ·ï¼Œæˆ‘ä»¬å°±å¯ä»¥è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆæ¥è§£å†³è¿™ä¸ªé—®é¢˜ã€‚123456789101112131415161718192021/* method 2 */class Solution &#123;public: int getnumber(int n) &#123; int ret = 0; while(n) &#123; int d = n % 10; n /= 10; ret += d * d; &#125; return ret; &#125; bool isHappy(int n) &#123; int slow = n, fast = getnumber(n); while(fast != 1 &amp;&amp; slow != fast) &#123; slow = getnumber(slow); fast = getnumber(getnumber(fast)); &#125; return fast == 1; &#125;&#125;; å› ä¸ºæœ€ç»ˆé™·å…¥å¾ªçŽ¯çš„æ•°å­—åºåˆ—æ˜¯å›ºå®šçš„ï¼ˆä¹Ÿå¯ä»¥æŠŠè¿™ä¸ªæ•°å­—åºåˆ—çœ‹å‡ºæ˜¯å¾ªçŽ¯çš„ï¼‰ï¼Œæ‰€ä»¥ slow è·Ÿ fast ä¸€å®šä¼šç›¸é‡ã€‚ method 3æœ‰äº†ä¸Šé¢çš„è¿‡ç¨‹ï¼Œå°±å¯ä»¥ç›´æŽ¥è®¾ç½®ä¸€ä¸ªå›ºå®šçš„å“ˆå¸Œè¡¨ï¼Œå¦‚æžœç®—åˆ°è¿™äº›æ•°å­—äº†ï¼Œç›´æŽ¥è¿”å›ž false å³å¯ã€‚12345678910111213141516171819202122class Solution &#123;public: unordered_set&lt;int&gt; numbers &#123;4, 16, 37, 58, 89, 145, 42, 20&#125;; int getnumber(int n) &#123; int ret = 0; while(n) &#123; int d = n % 10; n /= 10; ret += d * d; &#125; return ret; &#125; bool isHappy(int n) &#123; int now; while(n != 1) &#123; now = getnumber(n); if(numbers.find(now) != numbers.end()) return false; n = now; &#125; return true; &#125;&#125;; 1790. Check if One String Swap Can Make Strings EqualAnalysisé¢˜æ„æ¯”è¾ƒç®€å•ï¼Œåªè¦èƒ½é€šè¿‡ä¸è¶…è¿‡ 1 æ¬¡äº¤æ¢å¾—åˆ°ä¸¤ä¸ªç›¸åŒçš„å­—ç¬¦ä¸²ï¼Œå°±è¿”å›ž trueï¼Œæ‰€ä»¥ç›´æŽ¥æ¨¡æ‹Ÿå°±å¯ä»¥äº†ã€‚ Code123456789101112131415class Solution &#123;public: bool areAlmostEqual(string s1, string s2) &#123; if(s1.length() != s2.length()) return false; vector&lt;int&gt; index; for(int i = 0; i &lt; s1.length(); i++) &#123; if(s1[i] != s2[i]) index.push_back(i); if(index.size() == 2) break; &#125; if(index.size() == 0) return true; else if(index.size() == 1) return false; swap(s2[index[0]], s2[index[1]]); return s1 == s2; &#125;&#125;; Summaryç®€å•é¢˜æƒ³è¦ç›´æŽ¥ AC ä¹Ÿéœ€è¦è´¹ä¸€ç‚¹åŠŸå¤«å•Šã€‚ä»Šå¤©çš„ç¬¬ä¸‰ä¸ªé¢˜ï¼Œå…¶å®žåŽé¢çš„ 2 ç§åšæ³•å°±ä¸æ˜¯é‚£ä¹ˆçš„ç®€å•ï¼Œä½†æ˜¯åœ¨æ€§èƒ½ä¸Šæ˜¯æ›´ä¼˜ç§€çš„ï¼Œè¿™å°±æ˜¯å‡¸æ˜¾æŠ€æœ¯èƒ½åŠ›å¼ºå¼±çš„åœ°æ–¹äº†ï¼Œæ‰€ä»¥ï¼Œè¦å¥½å¥½æŠŠæ¡ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è‡ªå­¦å‰ä»–çš„ä¸€ç‚¹å¿ƒå¾—]]></title>
    <url>%2F2022%2F04%2F10%2F%E8%87%AA%E5%AD%A6%E5%90%89%E4%BB%96%E7%9A%84%E4%B8%80%E7%82%B9%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[æœ€è¿‘å†™çš„éƒ½æ˜¯è·Ÿç¼–ç¨‹ç›¸å…³çš„æ–‡ç« ï¼Œæœ‰ç‚¹ä¹å‘³äº†ã€‚æ­£å·§ï¼Œæœ€è¿‘æ„Ÿè§‰è‡ªå·±çš„å‰ä»–æ°´å¹³åˆæœ‰äº†ä¸€ç‚¹è¿›æ­¥ï¼Œæ‰€ä»¥æ€»ç»“ï¼ˆæ„Ÿæ…¨ï¼‰ä¸€ä¸‹ã€‚ æ¥è‡ªæˆ‘å¿ƒ - è€ç‹¼Your browser does not support the audio tag. å…ˆè¯´è¯´ä¸Šé¢è¿™é¦–æ­Œå§ï¼Œæ˜¯ç‹¼å”ç¬¬ä¸€å¼ ä¸“è¾‘ã€Šæ‹æ‹é£Žå°˜ã€‹é‡Œé¢çš„ä¸€é¦–æ­Œï¼Œç”±éƒå†¬ä½œè¯ä½œæ›²ã€‚åœ¨æ”¶è—è¿™å¼ ä¸“è¾‘ä¹‹å‰ï¼Œå…¶å®žæˆ‘åº”è¯¥å¹¶æ²¡æœ‰å¬è¿‡è¿™é¦–æ­Œï¼Œå½“æ—¶æˆ‘å¹¶æ²¡æœ‰æƒ³è¦æŠŠè¿™å¼ ä¸“è¾‘çš„æ­Œå…¨éƒ¨æ”¶è—ï¼Œåªæ˜¯æƒ³æ”¶è—é‡Œé¢çš„å¦å¤–ä¸€é¦–æ­Œâ€”â€”ã€Šæ‹æ‹é£Žå°˜ã€‹ã€‚åŽæ¥æœ‰ä¸€æ¬¡å¸¦ç€è€³æœºï¼ŒèŽ«åçš„å¾ªçŽ¯åˆ°äº†è¿™å¼ ä¸“è¾‘ï¼Œè€ç€æ€§å­å¬äº†ä¸‹åŽ»ã€‚çªç„¶å‘çŽ°ï¼Œè¿™å¼ ä¸“è¾‘çš„æ­Œéƒ½å¾ˆæœ‰ç‰¹è‰²ï¼Œè€Œä¸”åˆ¶ä½œç²¾è‰¯ï¼Œä¹Ÿå¾ˆç¬¦åˆå¹´è½»äººçš„å£å‘³ï¼ˆä¹Ÿè®¸åªæ˜¯æˆ‘çš„å£å‘³ï¼‰ã€‚ç„¶åŽæˆ‘å°±æ”¶è—äº†ï¼Œåˆ°çŽ°åœ¨è¶Šå‘è§‰å¾—è¿™å¼ ä¸“è¾‘çš„æ­Œæ˜¯è¶Šå¬è¶Šè€å¬ã€‚ è¯è¯´å›žæ¥ï¼Œå°±ã€Šæ¥è‡ªæˆ‘å¿ƒã€‹è€Œè¨€ï¼Œè¿™é¦–æ­Œæœ€æ‰“åŠ¨æˆ‘çš„è¿˜æ˜¯å‰ä»–ä¼´å¥ï¼ˆå½“ç„¶è¿™é¦–æ­Œæ•´ä½“æœ¬æ¥å°±å¾ˆå¥½ï¼‰ã€‚è¿™ç§é£Žæ ¼çš„ä¼´å¥ï¼Œç»™äººçš„æ„Ÿè§‰ååˆ†çš„å’Œè°ç”ŸåŠ¨ã€è‡ªç„¶æµç•…ï¼Œå°±å¥½åƒèŠ±å„¿ä»ŽèŠ±è‹žåˆ°é•¿æˆé²œèŠ±çš„è¿‡ç¨‹ä¸€æ ·ã€‚ä¹å¬ä¹‹ä¸‹ï¼Œå¯èƒ½è§‰å¾—å¾ˆç¨€æ¾å¹³å¸¸ï¼Œä½†æ˜¯éšç€è¿™ç§æ—‹å¾‹çš„ä¸æ–­æ·±å…¥ï¼Œå°±å¼€å§‹ç”ŸåŠ¨æ´»æ³¼èµ·æ¥äº†ã€‚ æœ‰ç‚¹å·§åˆçš„æ˜¯ï¼Œæˆ‘åŽæ¥åˆå¾—çŸ¥ï¼ˆå°½ç®¡æˆ‘å·²ç»å¿˜è®°ä»Žä½•å¾—çŸ¥ï¼‰äº†è¿™é¦–æ­Œçš„ä¼´å¥æ˜¯ç”±æ¨ä¹è€å¸ˆç¼–é…çš„ï¼Œè€Œä»–è‡ªå·±çš„å£ç´ä¸“è¾‘â€”â€”ã€Šå£ç´ã€‹ï¼Œåˆæ˜¯æˆ‘éžå¸¸å–œæ¬¢çš„ä¸“è¾‘ã€‚ æ›¾ç»çš„æˆ‘éžå¸¸æƒ³è‡ªå·±æŠŠè¿™é¦–æ­Œçš„ä¼´å¥å¼¹ä¸‹æ¥ï¼ŒçŽ°åœ¨ï¼Œæˆ‘å¿«è¦å®žçŽ°äº†ï¼Œè¿™æ— ç–‘è®©æˆ‘å¾ˆå¼€å¿ƒï¼Œä½†ä¹Ÿè®©æˆ‘å›žå¿†èµ·äº†æ›¾ç»çš„è‡ªå·±ã€‚ åŽŸæ¥çš„è‡ªå·±ï¼Œæ€»æ˜¯å–œæ¬¢æŠŠæ³¨æ„åŠ›æ”¾åœ¨å¼¹å¥ä¸Šã€‚å¿ƒä¸­æƒ³çš„åªæœ‰ä¸€ä»¶äº‹æƒ…ï¼šèƒ½ç‹¬ç«‹å¼¹å¥å‡ºæ¥å°±å¯ä»¥äº†ã€‚å®žé™…ä¸Šï¼Œæˆ‘çŽ°åœ¨è§‰å¾—è¿™å¯¹â€œå­¦ä¹ â€è¿™ä¸ªè¿‡ç¨‹è€Œè¨€ï¼Œå¤ªæ•·è¡ã€‚å› ä¸ºï¼Œèƒ½ç‹¬ç«‹å¼¹å¥å‡ºæ¥å¹¶ä¸æ„å‘³ç€ï¼Œè¿™é¦–æ­Œï¼ˆæˆ–è€…æ›²å­ï¼‰å·²ç»å­¦ä¹ å®Œæˆäº†ã€‚äº‹å®žä¸Šï¼Œä½ å¹¶ä¸æ¸…æ¥šè¿™ä¸ªè°±å­ä¸ºä»€ä¹ˆè¦è¿™æ ·ç¼–ã€‚æ¢å¥è¯è¯´ï¼Œä½ å¯èƒ½åŽ‹æ ¹ä¸çŸ¥é“ä½ åœ¨å¼¹ä»€ä¹ˆä¸œè¥¿ã€‚ä½ å”¯ä¸€èƒ½ç¡®å®šçš„äº‹æƒ…å°±æ˜¯ï¼Œè¿™æ ·å¼¹èƒ½å‡ºæ¥å¥½å¬çš„æ—‹å¾‹ã€‚ç„¶åŽï¼Œä½ è¦åšçš„å‰©ä¸‹çš„äº‹æƒ…å°±æ˜¯ä¸æ–­å¼ºåŒ–è‚Œè‚‰è®°å¿†ã€‚çŽ°åœ¨æƒ³æƒ³ï¼Œè¿™æ ·çš„å­¦ä¹ æ–¹æ³•å¾ˆå®¹æ˜“ç£¨æŽ‰ä¸€ä¸ªäººçš„è€å¿ƒã€‚ ä¸è¿‡ï¼Œæœ‰çš„äººå¯èƒ½å¹¶ä¸æ˜¯æƒ³è¦å­¦åˆ°ä»€ä¹ˆä¸œè¥¿ï¼Œä¹Ÿè®¸åªæ˜¯å•çº¯çš„æ‰“å‘æ—¶é—´ï¼Œæˆ–è€…è‡ªå¨±è‡ªä¹ã€‚å¦‚æžœæ˜¯è¿™æ ·ï¼Œç§ä»¥ä¸ºå®Œå…¨æ²¡å¿…è¦æ¥è‡ªå·±å¼¹å¥ä¹å™¨ï¼Œç»ƒå¥½å”±æ­Œå°±å¥½äº†ðŸ˜‚ã€‚ å¯¹äº†ï¼Œè¿˜æœ‰ä¹ç†ã€‚ ä¹ç†è¿™ä¸ªä¸œè¥¿ï¼Œè‡ªå·±å¾ˆæ—©å°±æŽ¥è§¦è¿‡äº†ï¼Œä½†æ˜¯ä¸€ç›´ä¸æ˜Žç™½åˆ°åº•å¦‚ä½•ç”¨åˆ°æ­Œæ›²å’Œæ—‹å¾‹ä¸­ã€‚è¿™æ®µæ—¶é—´ï¼Œå°è¯•äº†ä¸€ä¸‹æ‰’æ­Œï¼Œç¼–é…å’Œå¼¦ä¹‹åŽï¼Œæ‰æ˜Žç™½ä¸€äº›åŽŸæ¥è‡ªå·±å·²ç»â€œæ˜Žç™½è¿‡â€çš„ä¹ç†æ¦‚å¿µã€‚æ¯”å¦‚ï¼š ä¸»éŸ³æ˜¯ä»€ä¹ˆï¼Ÿå¦‚ä½•æ ¹æ®ä¸»éŸ³æ¥ç¡®å®šä¸€é¦–æµè¡Œæ­Œæ›²æˆ–è€…æ°‘è°£æ­Œæ›²çš„è°ƒæ€§ã€‚ å’Œå¼¦æ˜¯ä»€ä¹ˆï¼Ÿå¸¸ç”¨çš„ä¸€äº›å’Œå¼¦èµ°å‘ã€‚ ä¸åŒè°ƒæ€§çš„æ­Œæ›²å¦‚ä½•äº’ç›¸è½¬åŒ–ï¼Ÿ ç±»ä¼¼çš„é—®é¢˜è¿˜æœ‰å¾ˆå¤šã€‚è™½ç„¶ï¼Œæˆ‘çŽ°åœ¨å·²ç»å¯ä»¥å›žç­”ä¸Šé¢è¿™äº›é—®é¢˜äº†ã€‚ä½†æ˜¯ï¼Œæˆ‘å¹¶ä¸èƒ½å¾ˆå¥½çš„å›žç­”è¿™äº›é—®é¢˜ï¼Œæ¯”å¦‚è¿˜æœ‰å¾ˆå¤šå¸¸ç”¨çš„å’Œå¼¦èµ°å‘æˆ‘ä¸çŸ¥é“ï¼Œç¼–é…æ—¶ä½¿ç”¨çš„å’Œå¼¦å¹¶ä¸å…¨æ˜¯å›ºå®šè°ƒå†…çš„å’Œå¼¦ï¼Œå¸¸ç”¨çš„ä¸€äº›ç¼–é…æ–¹æ³•ç­‰ç­‰ã€‚ æ‰€ä»¥ï¼Œä¸ºäº†å¼ºåŒ–è¿™æ–¹é¢çš„èƒ½åŠ›ï¼Œå°±ä¸èƒ½ä»…ä»…æ˜¯èƒ½å¼¹å¥ä¸€é¦–æ­Œå°±è¶³å¤Ÿäº†ï¼Œè¿˜éœ€è¦åˆ†æžä¸€ä¸‹è°±å­ï¼Œæƒ³æƒ³ä¸ºä»€ä¹ˆè¦è¿™æ ·ç¼–ã€‚å¦å¤–ï¼Œè¦å¤šå°è¯•è‡ªå·±æ‰’æ­Œï¼Œç¼–é…å’Œå¼¦ï¼Œå¤šä½“ä¼šå’Œå¼¦çš„è‰²å½©ã€‚ æƒ³åˆ°è¿™é‡Œï¼Œåˆå‘çŽ°è‡ªå·±ä»ç„¶è¿˜æœ‰å¾ˆå¤šä¸æ‡‚çš„ä¸œè¥¿ã€‚ä½†æ˜¯ï¼Œä¹Ÿå¾ˆæœŸå¾…å°†æ¥è‡ªå·±çš„è¿›æ­¥å•Šã€‚ æœ€åŽï¼Œé™„ä¸Šè‡ªå·±çš„ ls16ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Guitar</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day6]]></title>
    <url>%2F2022%2F04%2F10%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ˜¯ 3 ä¸ªè·Ÿå­—ç¬¦ä¸²ç›¸å…³çš„é¢˜ç›®ã€‚ 387. First Unique Character in a StringAnalysisæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­ç¬¬ä¸€ä¸ªå‡ºçŽ°ä¸”åªå‡ºçŽ°è¿‡ä¸€æ¬¡çš„å­—ç¬¦ã€‚ Codeç›´æŽ¥æ•£åˆ—ã€‚12345678910111213class Solution &#123;public: int firstUniqChar(string s) &#123; int times[26] = &#123;0&#125;; for(auto ch: s) &#123; times[ch - 'a']++; &#125; for(int i = 0; i &lt; s.length(); i++) &#123; if(times[s[i] - 'a'] == 1) return i; &#125; return -1; &#125;&#125;; 383. Ransom NoteAnalysisåˆ¤æ–­ ransomNote è¿™ä¸ªå­—ç¬¦ä¸²æ˜¯å¦èƒ½è¢« magazine è¿™ä¸ªå­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦ç»„æˆã€‚ Codeç›´æŽ¥æ•£åˆ—ï¼Œè·Ÿä¸Šä¸ªé¢˜å·®ä¸å¤šçš„æ€è·¯ã€‚123456789101112131415class Solution &#123;public: bool canConstruct(string ransomNote, string magazine) &#123; if(magazine.length() &lt; ransomNote.length()) return false; int times[26] = &#123;0&#125;; for(auto ch: magazine) &#123; times[ch - 'a']++; &#125; for(auto ch: ransomNote) &#123; times[ch - 'a']--; if(times[ch - 'a'] &lt; 0) return false; &#125; return true; &#125;&#125;; 242. Valid AnagramAnalysisè¿™ä¸ªé¢˜è·Ÿä¸Šä¸ªé¢˜ä¹Ÿæ˜¯ç±»ä¼¼çš„... Codemethod 1123456789101112131415class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; vector&lt;int&gt; count1(26), count2(26); for(auto ch: s) &#123; count1[ch - 'a']++; &#125; for(auto ch: t) &#123; count2[ch - 'a']++; &#125; if(count1 == count2) return true; else return false; &#125;&#125;; ç›´æŽ¥æ¯”è¾ƒ vector çš„éªšæ“ä½œå¿˜è®°æ˜¯ä»Žå“ªé‡Œå­¦çš„äº†ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥é‡‡å–ä¸Žä¸Šä¸€é¢˜ä¸€æ ·çš„æ€è·¯ï¼Œå‡ºçŽ°è´Ÿæ•°å°±è¿”å›ž falseã€‚è¿˜æœ‰ä¸€ä¸ªè¿›é˜¶æç¤ºï¼šå¦‚æžœè¾“å…¥çš„æ˜¯ Unicode å­—ç¬¦æ€Žä¹ˆåŠžï¼Ÿè¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œé¦–å…ˆéœ€è¦çŸ¥é“çš„æ˜¯ Unicode ä¸Ž Ascii çš„ä¸åŒã€‚å½“ç„¶ï¼Œä¸åŒç‚¹å¾ˆå¤šï¼Œä½†æ˜¯åœ¨è¿™ä¸ªé¢˜ç›®çš„èƒŒæ™¯ä¸‹ï¼Œåªéœ€è¦æ³¨æ„ Unicode å­—ç¬¦å  2 ä¸ªå­—èŠ‚ï¼Œè€Œ Ascii åªå  1 ä¸ªå­—èŠ‚ã€‚é‚£ä¹ˆï¼Œå¦‚æžœè¿˜æƒ³ç”¨å“ˆå¸Œçš„æ€è·¯æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå°±éœ€è¦å¯¹å“ˆå¸Œè¡¨çš„ key è¿›è¡Œä¿®æ”¹ã€‚ä¸è¿‡ï¼ŒC++ æœ‰çŽ°æˆçš„ mapï¼Œæ‰€ä»¥ç›´æŽ¥ç”¨ map å°±è¡Œäº†ã€‚ method 2ä¸è¿‡ï¼Œåªæ˜¯è§£å†³è¿™ä¸ªé¢˜çš„è¯ï¼Œå…¶å®žè¿˜æœ‰ä¸€ç§åšæ³•ï¼Œé‚£å°±æ˜¯æŽ’åºï¼Œåªè¦æŽ’åºåŽçš„ 2 ä¸ªå­—ç¬¦ä¸²ä¸€æ ·ï¼Œé‚£å°±æ˜¯ç¬¦åˆæ¡ä»¶çš„ã€‚123456789class Solution &#123;public: bool isAnagram(string s, string t) &#123; if(s.length() != t.length()) return false; sort(s.begin(), s.end()); sort(t.begin(), t.end()); return s == t; &#125;&#125;; Summaryè¿™ 3 ä¸ªå­—ç¬¦ä¸²å¤„ç†çš„é¢˜ï¼Œéƒ½æ¯”è¾ƒç®€å•...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day3]]></title>
    <url>%2F2022%2F04%2F10%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[æ¡ä»¶è¯­å¥ï¼Ÿ 976. Largest Perimeter TriangleAnalysisè¿™ä¸ªé¢˜ä¹ä¸€çœ‹æŒºç®€å•çš„ï¼Œå…¶å®žéœ€è¦ç¨å¾®æ€è€ƒä¸€ä¸‹ã€‚é¦–å…ˆï¼Œèƒ½å¦ç»„æˆä¸‰è§’å½¢ï¼Œå¯ä»¥å€ŸåŠ©ä¸¤è¾¹ä¹‹å’Œæˆ–è€…ä¹‹å·®æ¥è¿›è¡Œåˆ¤æ–­ã€‚æŽ¥ä¸‹æ¥çš„é—®é¢˜å°±æ˜¯å¦‚ä½•å¾—åˆ°å‘¨é•¿æœ€å¤§çš„ä¸‰è§’å½¢ï¼Œè¦ä½¿å‘¨é•¿æœ€å¤§ï¼Œè¾¹é•¿è‚¯å®šå¾—æœ€å¤§ã€‚è‡ªç„¶è€Œç„¶ï¼Œä¸å¦¨å°†æ•°ç»„ä»Žå¤§åˆ°å°æŽ’åºï¼Œç„¶åŽä¾æ¬¡åˆ¤æ–­æ˜¯å¦æ˜¯ä¸‰è§’å½¢ï¼Œç¬¦åˆå°±ç›´æŽ¥è¿”å›žå‘¨é•¿ï¼Œå¯ä»¥ç¡®å®šçš„æ˜¯ï¼Œè¿™ä¸ªå‘¨é•¿ä¸€å®šæ˜¯æœ€å¤§å€¼ã€‚ä¸ºä»€ä¹ˆï¼Ÿå¯ä»¥ç”¨åè¯æ³•æ¥è¯´æ˜Žï¼Œå‡è®¾ $nums[0]$ã€$nums[1]$å’Œ$nums[2]$èƒ½æž„æˆä¸‰è§’å½¢ï¼Œå­˜åœ¨ $nums[i]$ ä½¿å¾—ç”± $nums[0]$ã€$nums[1]$ å’Œ $nums[i]$ æž„æˆçš„ä¸‰è§’å½¢çš„å‘¨é•¿æ›´å¤§ï¼Œå°±å¿…æœ‰ $nums[i] &gt; nums[2]$ï¼Œé‚£ä¹ˆæ­¤æ—¶è¿™ä¸ªæ•°ç»„ä¸€å®šä¸æ˜¯æœ‰åºçš„ã€‚åŒæ ·çš„ï¼Œå¦‚æžœ $nums[0]$ã€$nums[1]$ å’Œ $nums[2]$ ä¸èƒ½æž„æˆä¸‰è§’å½¢ï¼Œé‚£ä¹ˆ $nums[i], 2 &lt; i &lt; n$ ä¹Ÿä¸èƒ½ä¸Ž $nums[1]$ å’Œ $nums[0]$ ç»„æˆä¸‰è§’å½¢ã€‚ CodeæŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå¯ä»¥å†™å‡ºä¸‹é¢çš„ä»£ç ï¼š1234567891011class Solution &#123;public: int largestPerimeter(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(), nums.end(), [](int a, int b) &#123; return a &gt; b; &#125;); for(int i = 0; i &lt; nums.size() - 2; i++) &#123; int a = nums[i], b = nums[i + 1], c = nums[i + 2]; if(a + b &gt; c &amp;&amp; a + c &gt; b &amp;&amp; b + c &gt; a) return a + b + c; &#125; return 0; &#125;&#125;; å›žè¿‡å¤´å†æ¥æƒ³ä¸€ä¸‹ï¼Œå¯ä»¥å‘çŽ°è¿™å®žé™…æ˜¯ä¸ªè´ªå¿ƒé—®é¢˜ã€‚ 1779. Find Nearest Point That Has the Same X or Y CoordinateAnalysisé¢˜ç›®æœ‰ç‚¹é•¿ï¼Œè¦è€å¿ƒçš„è¯»ä¸‹é¢˜ã€‚ Code1234567891011121314151617class Solution &#123;public: int nearestValidPoint(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; points) &#123; int minmd = 0x3fffffff, index = -1; for(int i = 0; i &lt; points.size(); i++) &#123; if(points[i][0] == x &amp;&amp; points[i][1] == y) return i; else if(points[i][0] == x || points[i][1] == y) &#123; int tmp = abs(x - points[i][0]) + abs(y - points[i][1]); if(tmp &lt; minmd) &#123; minmd = tmp; index = i; &#125; &#125; &#125; return index; &#125;&#125;; Summaryè€ƒè´ªå¿ƒçš„é¢˜ç›®ï¼Œæœ‰æ—¶å€™æŒºéš¾æƒ³çš„ï¼Œè€Œä¸”åªè¦æƒ³åˆ°äº†å°±å¾ˆç®€å•ï¼Œæƒ³ä¸åˆ°å°±å¾ˆéš¾...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day5]]></title>
    <url>%2F2022%2F04%2F09%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[ä¸¤ä¸ªä¸­ç­‰é¢˜~ 36. Valid SudokuAnalysisçœ‹åˆ°è¿™ä¸ªé¢˜ç›®ï¼Œç«‹é©¬åŽ»çŽ©äº†ä¸€å±€æ•°ç‹¬ã€‚å¥½åœ¨è¿™ä¸ªé¢˜ç›®å¹¶ä¸æ˜¯æ±‚è§£ï¼Œè€Œæ˜¯åªç”¨åˆ¤æ–­ç»™å®šæ•°ç‹¬çŸ©é˜µçš„åˆæ³•æ€§å³å¯ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¯¹äºŽçŸ©é˜µä¸­å­˜åœ¨çš„å…ƒç´ è€Œè¨€ï¼Œå¿…é¡»æ»¡è¶³ï¼š è¿™ä¸€è¡Œåªæœ‰è¿™ä¸€ä¸ªå…ƒç´  è¿™ä¸€åˆ—åªæœ‰è¿™ä¸€ä¸ªå…ƒç´  9 å®«æ ¼åªæœ‰è¿™ä¸€ä¸ªå…ƒç´  å½“ä¸”ä»…å½“è¿™ 3 ä¸ªæ¡ä»¶éƒ½æ»¡è¶³ï¼Œè¿™ä¸ªæ•°ç‹¬çŸ©é˜µæ‰åˆæ³•ã€‚ Codemethod 1æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œé€ä¸ªåˆ¤æ–­å°±å¯ä»¥äº†ã€‚123456789101112131415161718192021222324252627class Solution &#123;public: bool isvalid(vector&lt;vector&lt;char&gt;&gt;&amp; board, int r, int c) &#123; for(int i = 0; i &lt; 9; i++) &#123; if(i != c &amp;&amp; board[r][i] == board[r][c]) return false; &#125; for(int i = 0; i &lt; 9; i++) &#123; if(i != r &amp;&amp; board[i][c] == board[r][c]) return false; &#125; int R = r &gt;= 3 ? r &gt;= 6 ? 9 : 6 : 3; int C = c &gt;= 3 ? c &gt;= 6 ? 9 : 6 : 3; for(int i = R - 3; i &lt; R; i++) &#123; for(int j = C - 3; j &lt; C; j++) &#123; if(i != r &amp;&amp; j != c &amp;&amp; isdigit(board[i][j]) &amp;&amp; board[i][j] == board[r][c]) return false; &#125; &#125; return true; &#125; bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; for(int i = 0; i &lt; 9; i++) &#123; for(int j = 0; j &lt; 9; j++) &#123; if(isdigit(board[i][j]) &amp;&amp; !isvalid(board, i, j)) return false; &#125; &#125; return true; &#125;&#125;; æŠŠè¡Œä¸Žåˆ—çš„åˆ¤æ–­æ”¾åœ¨å‰é¢ï¼Œå¹¶ä¸”å…ˆå¯¹ä¸‹æ ‡è¿›è¡Œåˆ¤æ–­çš„ç›®çš„ï¼Œæ˜¯ä¸ºäº†èƒ½åœ¨ä¸€å®šç¨‹åº¦ä¸Šå‡å°‘åˆ¤æ–­çš„æ¬¡æ•°ã€‚ method 2å›žè¿‡å¤´æ¥çœ‹è¿™é“é¢˜çš„è¯ï¼Œå…¶å®žä¸ç®—éš¾é¢˜ï¼Œå°±æ˜¯æ¯”è¾ƒéº»çƒ¦ã€‚æŒ‰ç…§ä¸Šé¢çš„ä»£ç ï¼Œå¯ä»¥å‘çŽ°æœ‰å¾ˆå¤šé‡å¤åˆ¤æ–­çš„åœ°æ–¹ï¼Œå¯ä»¥ä½¿ç”¨å“ˆå¸Œè¡¨ä¼˜åŒ–ä¸€ä¸‹ã€‚å¯¹äºŽæ¯ä¸€ä¸ªå…ƒç´ è€Œè¨€ï¼Œéœ€è¦æ»¡è¶³ 3 ä¸ªæ¡ä»¶ï¼ŒæŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œéœ€è¦ç»´æŠ¤çš„å“ˆå¸Œè¡¨ä¸ªæ•°ä¸€å…±æ˜¯ï¼š9 + 9 + 9 = 18ã€‚1234567891011121314151617181920212223class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; int rows[9][9] = &#123;0&#125;; int columns[9][9] = &#123;0&#125;; int submatrix[3][3][9] = &#123;0&#125;; for(int i = 0; i &lt; 9; i++) &#123; for(int j = 0; j &lt; 9; j++) &#123; char c = board[i][j]; if(c != '.') &#123; int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; submatrix[i / 3][j / 3][index]++; if(rows[i][index] &gt; 1 || columns[j][index] &gt; 1 || submatrix[i / 3][j / 3][index] &gt; 1) &#123; return false; &#125; &#125; &#125; &#125; return true; &#125;&#125;; è™½ç„¶ä½¿ç”¨å“ˆå¸Œè¡¨å¾ˆç®€æ´ï¼Œä½†æ˜¯å°±è¿™ä¸ªé—®é¢˜è€Œè¨€ï¼Œä¸€å…±è¦ç»´æŠ¤ 27 ä¸ªå“ˆå¸Œè¡¨ã€‚è¿™ä¸Ž $9Ã—9$ çŸ©é˜µçš„éåŽ†æ‰€æ¶ˆè€—çš„æ—¶é—´ç›¸æ¯”ï¼Œæ„Ÿè§‰å®žé™…ä¸Šè¿˜ä¸å¦‚ç›´æŽ¥æš´åŠ›æ¥çš„åˆ’ç®—ï¼Ÿå®žé™…ç”Ÿäº§çŽ¯å¢ƒä¸­å¤šç­‰ä¸ªé›¶ç‚¹å‡ ç§’ä¼°è®¡ä¹Ÿä¸ä¼šé€ æˆä»€ä¹ˆç»æµŽæŸå¤±ï¼ŸðŸ˜‚ 73. Set Matrix ZeroesAnalysisè¿™ä¸ªé¢˜æœ€å®¹æ˜“æƒ³åˆ°çš„åšæ³•åº”è¯¥æ˜¯å…ˆæ‰¾åˆ°æ‰€æœ‰ 0 çš„ä½ç½®ï¼Œç„¶åŽæ ¹æ®è¿™äº›ä½ç½®å†æ¥å°†ç¬¦åˆæ¡ä»¶çš„å…ƒç´ ç½®é›¶å³å¯ã€‚å°½ç®¡é¢˜ç›®è¦æ±‚åŽŸåœ°ç®—æ³•ï¼Œä½†æ˜¯å…ˆæŠŠæƒ³åˆ°çš„åŠžæ³•å†™å‡ºæ¥å§ Codemethod 1æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå¾ˆå®¹æ˜“å°±å¯ä»¥å¾—åˆ°æš´åŠ›è§£æ³•ã€‚123456789101112131415161718192021class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;pair&lt;int, int&gt;&gt; zeropoints; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) zeropoints.push_back(make_pair(i, j)); &#125; &#125; for(auto it: zeropoints) &#123; int x = it.first, y = it.second; for(int i = 0; i &lt; n; i++) &#123; matrix[x][i] = 0; &#125; for(int i = 0; i &lt; m; i++) &#123; matrix[i][y] = 0; &#125; &#125; &#125;&#125;; ä¹‹æ‰€ä»¥è¦å…ˆå°†ç‚¹æŒ‘å‡ºæ¥ï¼Œæ˜¯å› ä¸ºç½®é›¶ä¹‹åŽä¼šå½±å“åŽé¢çš„åˆ¤æ–­ï¼Œæ‰€ä»¥è¦åˆ†å¼€è¿›è¡Œã€‚å¦å¤–ï¼Œä»Žä¸Šé¢çš„ä»£ç ä¸­ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„å‘çŽ°ï¼Œåœ¨éåŽ† 0 ç‚¹çš„åæ ‡æ—¶ï¼Œxã€y å¯èƒ½ä¼šå‡ºçŽ°ç›¸ç­‰çš„æƒ…å†µï¼Œè¿™æ ·å°±ä¼šäº§ç”Ÿå¾ˆå¤šé‡å¤æ“ä½œã€‚ method 2æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå€ŸåŠ©å“ˆå¸Œè¡¨æ¥ä¼˜åŒ–ä¸€ä¸‹ã€‚$mÃ—n$ çš„çŸ©é˜µä¸€å…±éœ€è¦ $m + n$ä¸ªå“ˆå¸Œè¡¨æ¥ç»´æŠ¤ã€‚12345678910111213141516171819202122232425262728class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;pair&lt;int, int&gt;&gt; zeropoints; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(matrix[i][j] == 0) zeropoints.push_back(make_pair(i, j)); &#125; &#125; int rows[201] = &#123;0&#125;, columns[201] = &#123;0&#125;; for(auto it: zeropoints) &#123; int x = it.first, y = it.second; if(!rows[x]) &#123; rows[x] = 1; for(int i = 0; i &lt; m; i++) &#123; if(i != y) matrix[x][i] = 0; &#125; &#125; if(!columns[y]) &#123; columns[y] = 1; for(int i = 0; i &lt; n; i++) &#123; if(i != x) matrix[i][y] = 0; &#125; &#125; &#125; &#125;&#125;; å®žé™…ä¸Šï¼Œä¹Ÿå¯ä»¥ä¸ç”¨å­˜å‚¨æ¯ä¸ªç‚¹çš„åæ ‡ï¼Œåªéœ€è¦åˆ†åˆ«å­˜å‚¨è¡Œå·å’Œåˆ—å·å³å¯ï¼Œé‚£ä¹ˆä¸å¦¨ç”¨ set æ¥å­˜å‚¨ï¼Œè¿™æ ·è¿˜å¯ä»¥è‡ªåŠ¨åŽ»é™¤é‡å¤çš„è¡Œã€åˆ—ã€‚ç„¶åŽéåŽ† setï¼Œå°†ç¬¦åˆè¦æ±‚çš„è¡Œã€åˆ—çš„æ‰€æœ‰å…ƒç´ å…¨éƒ¨ç½®ä¸ºé›¶å³å¯ã€‚å·ä¸€ä¸‹æ‡’ï¼Œè¿™æ®µä»£ç å°±ä¸å†™äº†ã€‚ method 3ä½†æ˜¯ä¸ç®¡æ˜¯ç”¨ set è¿˜æ˜¯ pairï¼Œéœ€è¦çš„å­˜å‚¨ç©ºé—´éƒ½æ˜¯ $O(m + n)$ï¼Œæœ‰ä»€ä¹ˆåŠžæ³•èƒ½åŽŸåœ°è¿›è¡Œå‘¢ï¼Ÿç­”æ¡ˆæ˜¯ç”¨ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ¥æ›´æ–°çŸ©é˜µå‰©ä½™çš„å…ƒç´ ï¼Œå†ç”¨å‰©ä½™çš„å…ƒç´ æ¥æ›´æ–°ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„å…ƒç´ ã€‚ä½†æ˜¯ï¼Œè¿™æ ·ä¼šæ”¹å˜ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„å…ƒç´ ï¼Œä¼šæ— æ³•åˆ¤æ–­å…¶æœ¬èº«æ˜¯å¦å­˜åœ¨ 0ï¼Œæ‰€ä»¥éœ€è¦ç”¨ 2 ä¸ªå˜é‡æ¥è®°å½•ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—æ˜¯å¦å« 0ã€‚12345678910111213141516171819202122232425262728293031class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); bool frow0 = false, fcol0 = false; for(int i = 0; i &lt; n; i++) &#123; if(!matrix[0][i]) frow0 = true; &#125; for(int i = 0; i &lt; m; i++) &#123; if(!matrix[i][0]) fcol0 = true; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][j]) &#123; matrix[i][0] = matrix[0][j] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0; &#125; &#125; if(frow0) &#123; for(int i = 0; i &lt; n; i++) matrix[0][i] = 0; &#125; if(fcol0) &#123; for(int i = 0; i &lt; m; i++) matrix[i][0] = 0; &#125; &#125;&#125;; å›žè¿‡å¤´æ¥çœ‹çš„è¯ï¼Œè¿™ç§è§£æ³•å°±æ˜¯å°†ç¬¬ä¸€è¡Œã€ç¬¬ä¸€åˆ—å½“æˆäº†æ•£åˆ—è¡¨ã€‚é‚£è¿˜èƒ½ä¸èƒ½æ›´ä¼˜åŒ–å‘¢ï¼Ÿå½“ç„¶å¯ä»¥ï¼Œä¸å¦¨è®¾ fcol0 æ˜¯ç”¨æ¥è®°å½•ç¬¬ä¸€åˆ—æ˜¯å¦å­˜åœ¨ 0ï¼Œä¸Žä¸Šé¢çš„æ€è·¯ç±»ä¼¼ï¼Œåœ¨è®¾ç½®å¥½ fcol0 åŽï¼Œç”¨å‰©ä½™çš„å…ƒç´ å¤„ç†ç¬¬ä¸€è¡Œå’Œç¬¬ä¸€åˆ—çš„å…ƒç´ ï¼ˆè¿™ä¸¤ä»¶äº‹å¯ä»¥åŒæ—¶è¿›è¡Œï¼‰ã€‚ç„¶åŽï¼Œå†ç”¨å¤„ç†åŽçš„ç¬¬ä¸€è¡Œã€ç¬¬ä¸€åˆ—å…ƒç´ æ¥å¤„ç†å‰©ä½™çš„å…ƒç´ ã€‚è¿™é‡Œå¯ä»¥å‘çŽ°ï¼Œç¬¬ä¸€è¡Œæ˜¯å¦å­˜åœ¨ 0 çš„ä¿¡æ¯ä¼šè¢«è®°å½•åœ¨ $matrix[0][0]$ ä¸­ã€‚æŽ¥ä¸‹æ¥ï¼ŒæŒ‰ç…§ä¸Šé¢çš„æ€è·¯æ¥ä¿®æ”¹çŸ©é˜µçš„å€¼å°±å¯ä»¥äº†ã€‚1234567891011121314151617181920212223242526class Solution &#123;public: void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; int m = matrix.size(), n = matrix[0].size(); bool fcol0 = false; for(int i = 0; i &lt; m; i++) &#123; if(!matrix[i][0]) fcol0 = true; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][j]) &#123; matrix[i][0] = matrix[0][j] = 0; &#125; &#125; &#125; for(int i = 1; i &lt; m; i++) &#123; for(int j = 1; j &lt; n; j++) &#123; if(!matrix[i][0] || !matrix[0][j]) matrix[i][j] = 0; &#125; &#125; if(!matrix[0][0]) &#123; for(int i = 1; i &lt; n; i++) matrix[0][i] = 0; &#125; if(fcol0) &#123; for(int i = 0; i &lt; m; i++) matrix[i][0] = 0; &#125; &#125;&#125;; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œæœ€åŽå•ç‹¬å¤„ç†ç¬¬ä¸€è¡Œç¬¬ä¸€åˆ—æ—¶ï¼Œä¸€å®šè¦å…ˆåˆ¤æ–­ç¬¬ä¸€è¡Œæ˜¯å¦å…¨ä¸º 0ï¼Œå› ä¸º fcol0 å¯èƒ½ä¼šä½¿ä¸ä¸º 0 çš„ $matrix[0][0]$ å˜ä¸º 0ï¼Œè¿™å°±å½±å“äº†åŽé¢çš„åˆ¤æ–­äº†ã€‚äº‹å®žä¸Šï¼Œä¹Ÿå¯ä»¥ç”¨ $matrix[0][0]$ æ¥è®°å½•åˆ—æ˜¯å¦å­˜åœ¨ 0ï¼Œè¿™æ ·å°±éœ€è¦è®¾ç½®ä¸€ä¸ª frow0 æ¥è®°å½•ç¬¬ä¸€è¡Œæ˜¯å¦å­˜åœ¨ 0 äº†ã€‚åŒæ ·åœ°ï¼Œä¹Ÿéœ€è¦å…ˆç”¨ $matrix[0][0]$ åˆ¤æ–­ã€‚ Summaryä»Šå¤©çš„ 2 ä¸ªé¢˜éƒ½æŒºæœ‰æ„æ€çš„ã€‚ç¬¬ä¸€ä¸ªé¢˜æ•°ç»„ä¸‹æ ‡çš„è½¬æ¢æ˜¯éœ€è¦ä½“ä¼šçš„ç‚¹ï¼Œè¿™ç§åšæ³•å…¶å®žå¾ˆæ–¹ä¾¿çš„ã€‚ç¬¬äºŒä¸ªé¢˜å¯¹ç©ºé—´çš„ä¼˜åŒ–ä¹Ÿå¾ˆä¸é”™ï¼Œä¸è¿‡ç†è§£èµ·æ¥å¯èƒ½æ²¡æœ‰é‚£ä¹ˆå®¹æ˜“ï¼Œå¾—ä»”ç»†ä½“ä¼šä¸‹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day2]]></title>
    <url>%2F2022%2F04%2F09%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[å¥½åƒæœ‰åšè¿‡çš„é¢˜ï¼Ÿ 191. Number of 1 Bitsè¿™ä¸ªé¢˜åšè¿‡çš„ï¼Œå‚è€ƒ Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day13ã€‚ç›´æŽ¥è°ƒç”¨åº“å‡½æ•°ï¼Œå†åšä¸€æ¬¡ã€‚123456class Solution &#123;public: int hammingWeight(uint32_t n) &#123; return __builtin_popcount(n); &#125;&#125;; 1281. Subtract the Product and Sum of Digits of an IntegerAnalysisç¬¬ä¸€æ¬¡åœ¨ Leetcode ä¸Šè§åˆ°æ•°ä½æ‹†åˆ†çš„é¢˜ã€‚ä¸æ˜¯éš¾é¢˜ï¼Œç›´æŽ¥åšå°±è¡Œäº†ã€‚ Code12345678910111213class Solution &#123;public: int subtractProductAndSum(int n) &#123; int product = 1, sum = 0, digit; do &#123; digit = n % 10; n /= 10; product *= digit; sum += digit; &#125; while(n); return product - sum; &#125;&#125;; Summaryä»Šå¤©è¿™ä¸¤ä¸ªé¢˜å¤ªç®€å•äº†...è¿˜å¥½æœ‰å…¶ä»–çš„å­¦ä¹ è®¡åˆ’ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_12 å¤©ç¼–ç¨‹èƒ½åŠ›å…¥é—¨_day1]]></title>
    <url>%2F2022%2F04%2F08%2FLeetcode-12-%E5%A4%A9%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[æ„Ÿè§‰é¢˜ç›®ä¸å¤Ÿåšï¼Œå†å¼€å¯ä¸€ä¸ªå­¦ä¹ è®¡åˆ’å§~ 1523. Count Odd Numbers in an Interval RangeAnalysisæ‰¾å‡º $[low, high]$ å†…çš„å¥‡æ•°ã€‚ Codeè¿™é¢˜ä¹Ÿå¤ªå®¹æ˜“äº†å§ï¼Ÿ12345678910class Solution &#123;public: int countOdds(int low, int high) &#123; int count = 0; for(; low &lt;= high; low++) &#123; if(low % 2) count++; &#125; return count; &#125;&#125;; ç«Ÿç„¶è¶…æ—¶äº†ï¼Œåˆ¤æ–­å¥‡å¶è¿˜æœ‰ä»€ä¹ˆéªšæ“ä½œå—ï¼Ÿä»”ç»†æƒ³ä¸€ä¸‹ï¼Œè¿™ä¸ªé¢˜åº”è¯¥æ˜¯ä¸ªæ•°å­¦é¢˜ã€‚è‡ªç„¶æ•°ä¸­ï¼Œå¥‡æ•°ä¸Žå¶æ•°éƒ½æ˜¯äº¤æ›¿æŽ’åˆ—çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¥‡æ•°åŽé¢çš„åŽé¢çš„æ•°è¿˜æ˜¯å¥‡æ•°ã€‚é‚£ä¹ˆï¼Œæ ¹æ®ç»™å®šæ•°å­—çš„ä¸åŒï¼Œä¸å¦‚ç›´æŽ¥å°†ä¸­é—´å¥‡æ•°çš„ä¸ªæ•°ç®—å‡ºæ¥ï¼Œå¦‚ä¸‹ï¼š1234567class Solution &#123;public: int countOdds(int low, int high) &#123; if(low % 2 &amp;&amp; high % 2) return (high - low) / 2 + 1; else return (high - low) / 2 + high % 2 + low % 2; &#125;&#125;; è¿™æ ·å†™æ˜¾ç„¶ä¸å¤Ÿä¼˜é›…ï¼Œæ”¹ä¸€ä¸‹ï¼š123456class Solution &#123;public: int countOdds(int low, int high) &#123; return (high - low) / 2 + (high % 2 || low % 2); &#125;&#125;; å—¯ï¼Œå¥½å¤šäº†ã€‚å®žé™…ä¸Šï¼ŒåŒºé—´ $[0, x]$ çš„å¥‡æ•°ä¸ªæ•°å°±ç­‰äºŽ $\lfloor \frac{x + 1}{2} \rfloor$ã€‚é‚£ä¹ˆå¯ä»¥ç”¨å‰ç¼€å’Œæ€æƒ³æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå¦‚ä¸‹ï¼š123456class Solution &#123;public: int countOdds(int low, int high) &#123; return ((high + 1) &gt;&gt; 1) - (low &gt;&gt; 1); &#125;&#125;; 1491. Average Salary Excluding the Minimum and Maximum SalaryAnalysisåœ¨è®¡ç®—æ€»è–ªæ°´çš„åŒæ—¶ï¼Œå¾—åˆ°æœ€å¤§å€¼å’Œæœ€å°å€¼ï¼Œç„¶åŽè¿”å›žç»“æžœå°±å¯ä»¥äº†ã€‚ Code123456789101112class Solution &#123;public: double average(vector&lt;int&gt;&amp; salary) &#123; int size = salary.size(), sum = salary[0], min = salary[0], max = salary[0]; for(int i = 1; i &lt; size; i++) &#123; sum += salary[i]; if(min &gt; salary[i]) min = salary[i]; if(max &lt; salary[i]) max = salary[i]; &#125; return (sum - min - max) * 1.0 / (size - 2); &#125;&#125;; Summaryè™½ç„¶æ˜¯ç®€å•é¢˜ï¼Œä½†æ˜¯å¦‚ä½•æŠŠç®€å•é¢˜åšçš„æ›´ç®€å•ä¹Ÿéœ€è¦å¤šåŠ¨è„‘ç­‹ã€‚å…¶å®žç¬¬äºŒä¸ªé¢˜ï¼Œå¯ä»¥ç›´æŽ¥è°ƒç”¨ APIï¼Œä½†æ˜¯ç›´æŽ¥ä¸€ä¸ªå¾ªçŽ¯è§£å†³ä¼šæ›´å¥½ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day4]]></title>
    <url>%2F2022%2F04%2F08%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[Let`s go go go! 566. Reshape the MatrixAnalysisè¿™ä¸ªé¢˜ç›®æœ‰ç‚¹æŒ‚ç¾Šå¤´å–ç‹—è‚‰çš„æ„Ÿè§‰ã€‚éšçº¦è®°å¾—æ•°æ®ç»“æž„é‚£æœ¬ä¹¦å¥½åƒè®²è¿‡ä¸€ç‚¹å…³äºŽçŸ©é˜µçš„åŽ‹ç¼©å­˜å‚¨çš„çŸ¥è¯†ã€‚ Codeç›´æŽ¥åšå§ã€‚12345678910111213141516171819class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123; int m = mat.size(), n = mat[0].size(); if(m * n != r * c) return mat; int tr = 0, tc = 0; vector&lt;vector&lt;int&gt;&gt; ret(r, vector&lt;int&gt;(c)); for(int i = 0; i &lt; r; i++) &#123; for(int j = 0; j &lt; c; j++) &#123; ret[i][j] = mat[tr][tc++]; if(tc == n) &#123; tr++; tc = 0; &#125; &#125; &#125; return ret; &#125;&#125;; ä¸è¿‡ï¼Œå¥½åƒå¯ä»¥ç»“åˆçŸ©é˜µçš„åŽ‹ç¼©å­˜å‚¨çŸ¥è¯†ä¼˜åŒ–ä¸€ä¸‹ï¼š123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; matrixReshape(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int r, int c) &#123; int m = mat.size(), n = mat[0].size(); if(m * n != r * c) return mat; vector&lt;vector&lt;int&gt;&gt; ret(r, vector&lt;int&gt;(c)); for(int index = 0; index &lt; m * n; index++) &#123; ret[index / c][index % c] = mat[index / n][index % n]; &#125; return ret; &#125;&#125;; 118. Pascalâ€™s TriangleAnalysisdp é¢˜ï¼Œä»–åˆæ¥äº†ðŸ˜‚ã€‚è¿™ä¸ªé¢˜å°±æ˜¯æ±‚æ¨è¾‰ä¸‰è§’ã€‚å¥½åƒä¸æ˜¯å¾ˆå¤æ‚çš„æ ·å­ï¼Œè®¾ç½®ä¸€ä¸ª dp äºŒç»´æ•°ç»„ï¼Œæ˜¾ç„¶ï¼Œ$dp[0][0] = 1$ï¼Œ$dp[1][0] = 1, dp[1][1] = 1$ï¼Œ$dp[2][0] = 1, dp[2][1] = dp[1][0] + dp[1][1] = 2, dp[2][2] = dp[1][1] = 1$ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå¯ä»¥å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i][0] = dp[i - 1][0], dp[i][i] = dp[i - 1][i - 1], dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]$ã€‚ Codeå› ä¸ºæœ€åŽçš„è¾“å‡ºç»“æžœæ€»æ²¡æœ‰å¤šä½™çš„ 0 å­˜åœ¨ï¼Œæ‰€ä»¥ä¸ºäº†è¿”å›žç¬¦åˆæ¡ä»¶çš„çŸ©é˜µï¼Œdp æ•°ç»„åªèƒ½ä¸Žè¿”å›žçš„çŸ©é˜µåˆ†å¼€äº†ã€‚12345678910111213141516171819202122class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int dp[31][31] = &#123;0&#125;; dp[0][0] = 1; ret.push_back(&#123;dp[0][0]&#125;); for(int i = 1; i &lt; numRows; i++) &#123; vector&lt;int&gt; tmp; dp[i][0] = dp[i - 1][0]; tmp.push_back(dp[i][0]); for(int j = 1; j &lt; i; j++) &#123; dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]; tmp.push_back(dp[i][j]); &#125; dp[i][i] = dp[i - 1][i - 1]; tmp.push_back(dp[i][i]); ret.push_back(tmp); &#125; return ret; &#125;&#125;; ä¸è¿‡ï¼Œè¿™æ ·å†™æ€»æ„Ÿè§‰ä¸å¤ªä¼˜é›…ï¼Œå—¯ï¼Œæ”¹ä¸€ä¸‹ï¼š1234567891011121314class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123; vector&lt;vector&lt;int&gt;&gt; ret(numRows); for(int i = 0; i &lt; numRows; i++) &#123; ret[i].resize(i + 1); ret[i][0] = ret[i][i] = 1; for(int j = 1; j &lt; i; j++) &#123; ret[i][j] = ret[i - 1][j - 1] + ret[i - 1][j]; &#125; &#125; return ret; &#125;&#125;; æžœç„¶ï¼Œè¿™æ ·å†™æ¸…çˆ½å¾ˆå¤šã€‚ Summaryä»Šå¤©çš„é¢˜ç›®æ¯”è¾ƒç®€å•ï¼Ÿæ„Ÿè§‰å¥½åƒå¯ä»¥åœ¨å¤šæ¥å‡ é“é¢˜ï¼Ÿè¯è¯´ï¼Œæ¨è¾‰ä¸‰è§’è¿™ä¸ªä¸œè¥¿æ€§è´¨è¿˜æŒºå¤šçš„ï¼Œè¯´ä¸å®šå¯èƒ½ä¼šå‡ºå…¶ä»–æ€§è´¨çš„é¢˜ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day3]]></title>
    <url>%2F2022%2F04%2F07%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[æ¯æ—¥å‡ é“é¢˜ï¼Œä¸è¦å·æ‡’~ 350. Intersection of Two Arrays IIAnalysisè¿™æ˜¯ä¸ªå¾ˆç›´è§‚çš„é¢˜ç›®ï¼Œæ‰¾å‡ºä¸¤ä¸ªæ•°ç»„çš„äº¤é›†å³å¯ã€‚ Codemethod 1åœ¨ä¸è¦æ±‚ä¿ç•™åŽŸæ•°æ®çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ç›´æŽ¥æŸ¥æ‰¾ã€‚ä¹‹æ‰€ä»¥è¦æŠŠæ‰¾åˆ°è¿‡çš„å…ƒç´ æ”¹ä¸º -1ï¼Œæ˜¯ä¸ºäº†é¿å…åœ¨ä¸€ä¸ªæ•°ç»„ä¸­å‡ºçŽ°äº† 2 æ¬¡ï¼Œä½†åœ¨å¦å¤–ä¸€ä¸ªæ•°ç»„ä¸­åªå‡ºçŽ°ä¸€æ¬¡çš„æƒ…å†µã€‚12345678910111213141516171819/* method 1 */class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int m = nums1.size(), n = nums2.size(); for(int i = 0; i &lt; m; i++) &#123; int tmp = nums1[i]; for(int j = 0; j &lt; n; j++) &#123; if(tmp == nums2[j]) &#123; nums2[j] = -1; ret.push_back(tmp); break; &#125; &#125; &#125; return ret; &#125;&#125;; method 2ä¸ºäº†æé«˜æ•ˆçŽ‡ï¼Œä¸å¦¨è®¾ç½®ä¸¤ä¸ªæ•£åˆ—è¡¨ï¼Œç”¨æ¥ç»Ÿè®¡æ¯ä¸ªæ•°ç»„ä¸­æ•°å­—çš„å‡ºçŽ°æ¬¡æ•°ï¼ŒæŽ¥ç€å†ä»Žæ•£åˆ—è¡¨ä¸­æŒ‘å‡ºåŒæ—¶å‡ºçŽ°çš„æ•°å­—å³å¯ã€‚12345678910111213141516171819202122class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int ht1[1005] = &#123;0&#125;, ht2[1005] = &#123;0&#125;; for(int i = 0; i &lt; nums1.size(); i++) &#123; ht1[nums1[i]]++; &#125; for(int i = 0; i &lt; nums2.size(); i++) &#123; ht2[nums2[i]]++; &#125; for(int i = 0; i &lt; 1001; i++) &#123; if(ht1[i] &amp;&amp; ht2[i]) &#123; int tmp = ht1[i] &gt; ht2[i] ? ht2[i] : ht1[i]; for(int j = 0; j &lt; tmp; j++) &#123; ret.push_back(i); &#125; &#125; &#125; return ret; &#125;&#125;; ä½†æ˜¯è¿™æ ·ç”¨æ•£åˆ—è¡¨ä¸å¤Ÿèªæ˜Žï¼Œåº”è¯¥å¯ä»¥åªç”¨ä¸€ä¸ªæ•£åˆ—è¡¨ï¼Œå¦‚ä¸‹ï¼š1234567891011121314151617class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; vector&lt;int&gt; ret; int ht[1005] = &#123;0&#125;; for(int i = 0; i &lt; nums1.size(); i++) &#123; ht[nums1[i]]++; &#125; for(int i = 0; i &lt; nums2.size(); i++) &#123; if(ht[nums2[i]]) &#123; ret.push_back(nums2[i]); ht[nums2[i]]--; &#125; &#125; return ret; &#125;&#125;; è¿™ä¸ªé¢˜è¿˜æœ‰ 3 ä¸ªè¿›é˜¶æç¤ºï¼š ç»™å‡ºçš„æ•°ç»„å¦‚æžœæ˜¯æŽ’åºçš„å¦‚ä½•ä¼˜åŒ–ï¼Ÿå¦‚æžœæ˜¯æŽ’åºçš„ï¼Œå°±å¯ä»¥ç”¨åŒæŒ‡é’ˆäº†ã€‚æ¢å¥è¯è¯´ï¼Œç¬¬ä¸€ç§è§£æ³•å°±å¯ä»¥æ”¹æˆå…ˆæŽ’åºï¼Œåœ¨éåŽ†æ•°ç»„äº†ã€‚ nums1 çš„å®¹é‡å°äºŽ nums2 çš„å®¹é‡ï¼Œå“ªç§æ–¹æ³•æ›´ä¼˜ï¼Ÿå¦‚æžœä¸¤ä¸ªæ•°ç»„çš„å®¹é‡å¤§å°å·®è·è¿‡å¤§ï¼Œé‚£ä¹ˆæŽ’åº + åŒæŒ‡é’ˆä¼šæ›´å¥½ä¸€äº›ã€‚ å†…å­˜æ— æ³•ä¸€æ¬¡æ€§è¯»å–æ•°ç»„çš„å…ƒç´ ï¼Œé‚£ç§æ–¹æ³•æ›´ä¼˜ï¼Ÿæ˜¾ç„¶æ•£åˆ—æ›´ä¼˜ã€‚ 121. Best Time to Buy and Sell StockAnalysisä»Žé—®é¢˜çš„å¤æ‚æ€§æ¥çœ‹ï¼Œè¿™ä¸ªé¢˜çš„é¢˜æ„è¿˜ç®—ç®€å•ã€‚ Codemethod 1æœ€å…ˆæƒ³åˆ°çš„æ°¸è¿œæ˜¯æš´åŠ›è§£æ³•ï¼Œæ¯«æ— ç–‘é—®çš„è¶…æ—¶äº†ðŸ˜‚ã€‚1234567891011121314151617181920class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size = prices.size(), max = 0; vector&lt;int&gt; profit(size); for(int i = 0; i &lt; size; i++) &#123; int index = i, tmax = prices[i]; for(int j = index + 1; j &lt; size; j++) &#123; if(tmax &lt; prices[j]) &#123; tmax = prices[j]; index = j; &#125; &#125; if(index == i) profit[i] = -1; else profit[i] = prices[index] - prices[i]; if(profit[i] &gt; max) max = profit[i]; &#125; return max; &#125;&#125;; æš´åŠ›è§£æ³•çš„æ€è·¯æ˜¯åŸºäºŽè´ªå¿ƒçš„ï¼Œä¸è¿‡å¥½åƒè¿˜å¯ä»¥ä¼˜åŒ–ä¸€ä¸‹ä»£ç ï¼š123456789101112class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int size = prices.size(), ans = 0; for(int i = 0; i &lt; size; i++) &#123; for(int j = i + 1; j &lt; size; j++) &#123; ans = max(ans, prices[j] - prices[i]); &#125; &#125; return ans; &#125;&#125;; method 2å®¹æ˜“å‘çŽ°ï¼Œç¬¬ i å¤©çš„åˆ©æ¶¦åªä¸Žç¬¬ i å¤©ä¹‹å‰çš„æœ€ä½Žä»·æœ‰å…³ã€‚é€‰æ‹©åœ¨ä¸åŒçš„å¤©æ•°è´­ä¹°ï¼Œæœ€ç»ˆä¼šå¾—åˆ°ä¸åŒçš„åˆ©æ¶¦ç»“æžœï¼Œè¿™ç§é¢˜ç›®å¤šåŠè¦ç”¨åŠ¨æ€è§„åˆ’çš„æ€è·¯ã€‚è®¾ç½®ä¸€ä¸ª dp æ•°ç»„ç”¨æ¥è¡¨ç¤ºç¬¬ i å¤©ä¹‹å‰çš„æœ€ä½Žä»·ï¼Œå†è®¾ç½®ä¸€ä¸ªå˜é‡ ans æ¥ç»´æŠ¤å½“å‰æœ€å¤§çš„åˆ©æ¶¦ã€‚12345678910111213class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int days = prices.size(), ans = 0; vector&lt;int&gt; dp(days); dp[0] = prices[0]; for(int i = 1; i &lt; days; i++) &#123; dp[i] = min(dp[i - 1], prices[i]); ans = max(ans, prices[i] - dp[i]); &#125; return ans; &#125;&#125;; è¿™é‡Œï¼Œå†åˆ©ç”¨æ»šåŠ¨æ•°ç»„çš„æ€æƒ³æ¥ä¼˜åŒ–ä¸€ä¸‹ä»£ç ï¼š1234567891011class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; int days = prices.size(), ans = 0, minprice = prices[0]; for(int i = 1; i &lt; days; i++) &#123; minprice = min(minprice, prices[i]); ans = max(ans, prices[i] - minprice); &#125; return ans; &#125;&#125;; Summaryè™½ç„¶æ˜¯ä¸¤é“ç®€å•é¢˜ï¼Œä½†æ˜¯è€ƒå¯Ÿçš„æ€æƒ³æ˜¯å¾ˆé‡è¦çš„æ€æƒ³ã€‚å¦å¤–ï¼ŒåŠ¨æ€è§„åˆ’çš„é¢˜ç›®å¯çœŸæ˜¯çµæ´»å•Š...è¿˜æ˜¯é¢˜ç›®åšå°‘äº†å—ï¼ŸðŸ˜‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day2]]></title>
    <url>%2F2022%2F04%2F06%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[è¿™ä¸¤å¤©çš„ä¸»é¢˜éƒ½æ˜¯æ•°ç»„ï¼Œæ„Ÿè§‰å«çº¿æ€§è¡¨æ›´åˆé€‚ã€‚ 1. Two SumAnalysiså¥½å§ï¼Œè¿™æ˜¯ leetcode ç¬¬ä¸€é¢˜ï¼Œä¼°è®¡æ²¡äººæ²¡åšè¿‡å§ã€‚åšæ³•å¾ˆå¤šï¼Œç”¨æ•£åˆ—åšä¸€ä¸‹å¾—äº†ã€‚ Code123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; map&lt;int, int&gt; ht; vector&lt;int&gt; ret(2); for(int i = 0; i &lt; nums.size(); i++) &#123; if(ht.find(target - nums[i]) != ht.end()) &#123; ret[0] = ht[target - nums[i]], ret[1] = i; break; &#125; ht[nums[i]] = i; &#125; return ret; &#125;&#125;; 88. Merge Sorted ArrayAnalysisè¿™ä¸ªé¢˜è·Ÿåˆå¹¶é“¾è¡¨å¥½åƒæ˜¯ä¸€ä¸ªç±»åž‹çš„é¢˜ã€‚ Codemethod 1å…ˆæŒ‰ç…§å¸¸è§„åšæ³•åšä¸€ä¸‹ã€‚é¢˜ç›®è¦æ±‚æ²¡æœ‰è¿”å›žå€¼ï¼Œæ‰€ä»¥æœ€åŽçš„ç»“æžœåªèƒ½å­˜å‚¨åœ¨ nums1 ä¸­ï¼Œé‚£å°±åªèƒ½æƒ³åŠžæ³•æŠŠ nums2 çš„æ•°æ’åˆ° nums1 ä¸­ã€‚12345678910111213141516171819/* method 1 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; for(int i = 0; i &lt; n; i++) &#123; int tmp = nums2[i], pos = 0; while(pos &lt; m &amp;&amp; tmp &gt; nums1[pos]) pos++; if(pos != m) &#123; int index = m; while(index &gt; pos) &#123; nums1[index] = nums1[index - 1]; index--; &#125; &#125; nums1[pos] = tmp; m++; &#125; &#125;&#125;; ä»Žä¸Šé¢çš„è§£æ³•ä¸­ä¹Ÿå¯ä»¥çœ‹å‡ºé“¾è¡¨ä¸Žçº¿æ€§è¡¨åœ¨æ’å…¥å…ƒç´ ä¸Šçš„æ•ˆçŽ‡å·®å¼‚ã€‚ method 2ä¸‹é¢æ¢ä¸€ç§è§£æ³•ã€‚1234567891011/* method 2 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int index = 0; for(int i = m; i &lt; m + n; i++) &#123; nums1[i] = nums2[index++]; &#125; sort(nums1.begin(), nums1.end()); &#125;&#125;; ç›´æŽ¥æ‹·è´åˆ°åŽé¢ï¼ŒæŽ’åºå®Œäº‹ã€‚ method 3åˆ«å¿˜è®°äº†ï¼Œé¢˜ç›®è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶ï¼Œé‚£å°±æ˜¯ nums1 å’Œ nums2 æœ¬èº«æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆå°±å¯ä»¥æŒ‰ç…§é˜Ÿåˆ—çš„æ€è·¯æ¥åšäº†ã€‚è®© nums1å’Œ nums2 çš„å…ƒç´ æŒ‰å¤§å°ä¾æ¬¡å…¥é˜Ÿï¼Œæœ€åŽç»“æžœå°±æ˜¯æ‰€æ±‚ã€‚123456789101112131415161718192021/* method 3 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; vector&lt;int&gt; queue(m + n); int pos1 = 0, pos2 = 0, index = 0; while(pos1 &lt; m &amp;&amp; pos2 &lt; n) &#123; if(nums1[pos1] &lt; nums2[pos2]) &#123; queue[index] = nums1[pos1]; pos1++; &#125; else &#123; queue[index] = nums2[pos2]; pos2++; &#125; index++; &#125; while(pos1 &lt; m) queue[index++] = nums1[pos1++]; while(pos2 &lt; n) queue[index++] = nums2[pos2++]; nums1 = queue; &#125;&#125;; ä¸Šé¢çš„è§£æ³•å…¶å®žæ˜¯åŒæŒ‡é’ˆçš„ç”¨æ³•ï¼Œä½†æ˜¯é¢å¤–æ¶ˆè€—äº†ç©ºé—´ã€‚ä¹‹æ‰€ä»¥è¦æ¶ˆè€—ç©ºé—´ï¼Œæ˜¯å› ä¸ºå…ˆé€‰å‡ºå°çš„å…ƒç´ ï¼ŒåŽé¢çš„å…ƒç´ å¦‚æžœä¸åŽç§»å°±ä¼šè¢«è¦†ç›–äº†ã€‚é‚£ä¹ˆï¼Œå…ˆé€‰å¤§çš„å…ƒç´ ï¼Œå°±ä¸ç”¨æ‹…å¿ƒè¿™ä¸ªé—®é¢˜äº†ã€‚12345678910111213141516171819/* method 4 */class Solution &#123;public: void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) &#123; int pos1 = m - 1, pos2 = n - 1, index = m + n - 1; while(pos1 &gt;= 0 &amp;&amp; pos2 &gt;= 0) &#123; if(nums1[pos1] &gt; nums2[pos2]) &#123; nums1[index] = nums1[pos1]; pos1--; &#125; else &#123; nums1[index] = nums2[pos2]; pos2--; &#125; index--; &#125; while(pos1 &gt;= 0) nums1[index--] = nums1[pos1--]; while(pos2 &gt;= 0) nums1[index--] = nums2[pos2--]; &#125;&#125;; Summaryä»Šå¤©çš„ä¸¤ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯ç¬¬äºŒä¸ªé¢˜çš„è§£æ³•å¾ˆå¤šï¼Œç‰¹åˆ«æ˜¯åŒæŒ‡é’ˆçš„è§£æ³•ï¼Œå¾ˆçµæ´»ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©æ•°æ®ç»“æž„å…¥é—¨_day1]]></title>
    <url>%2F2022%2F04%2F05%2FLeetcode-14-%E5%A4%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[å†æ¥è¯•è¯•æ•°æ®ç»“æž„å…¥é—¨ï¼Œå…¶å®žå°±æ˜¯æƒ³åšç‚¹æ ‘çš„é¢˜ã€‚ 217. Contains DuplicateAnalysisè¿™ä¸ªé¢˜æŽ’åºå’Œå“ˆå¸Œéƒ½å¯ä»¥åšã€‚ Code1234567891011class Solution &#123;public: bool containsDuplicate(vector&lt;int&gt;&amp; nums) &#123; unordered_set&lt;int&gt; ht; for(auto it: nums) &#123; if(ht.find(it) != ht.end()) return true; ht.insert(it); &#125; return false; &#125;&#125;; æŽ’åºçš„å°±ä¸å†™äº†ã€‚ 53. Maximum SubarrayAnalysisè¿™ä¸ªé¢˜æ˜¯ä¸ªå¾ˆç»å…¸çš„é¢˜ç›®ï¼Œåšæ³•å¾ˆå¤šã€‚ Codemethod 1ç¬¬ä¸€ä¸ªåšæ³•å°±æ˜¯ä»ŽåŠ¨æ€è§„åˆ’çš„è§’åº¦æ¥æ€è€ƒã€‚æ˜¾ç„¶ï¼Œè¾¹ç•Œå°±æ˜¯æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œä¹Ÿå³ï¼š$dp[0] = nums[0]$ï¼›é’ˆå¯¹æ•°ç»„çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼Œæ­¤æ—¶è¿™ä¸ªæ•°å¯èƒ½ä¸Žå‰ä¸€ä¸ªåºåˆ—æž„æˆå’Œæ›´å¤§çš„åºåˆ—ï¼Œä¹Ÿå¯èƒ½æž„æˆå’Œæ›´å°çš„åºåˆ—ï¼ˆä¹Ÿå³å‰ä¸€ä¸ªåºåˆ—å’Œæ˜¯è´Ÿæ•°ï¼Œè¿™ä¸ªæ•°æ­£æ•°ï¼‰ï¼Œé‚£ä¹ˆå°±æœ‰ï¼š$dp[1] = max(dp[0] + nums[1], nums[1])$ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯å°±å¯ä»¥å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i] = max(dp[i - 1] + nums[i], nums[i])$ã€‚12345678910111213class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; int maxsum = dp[0]; for(int i = 1; i &lt; nums.size(); i++) &#123; dp[i] = max(nums[i], nums[i] + dp[i - 1]); if(maxsum &lt; pre) maxsum = dp[i]; &#125; return maxsum; &#125;&#125;; å¯ä»¥å‘çŽ°ï¼Œæ¯æ¬¡è®¡ç®—çš„ $dp[i]$ å…¶å®žåªä¸Ž $dp[i - 1]$ å’Œ $nums[i]$ æœ‰å…³ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä¸ç”¨æ•°ç»„æ¥å®Œæˆäº†ï¼š123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int pre = nums[0]; int maxsum = pre; for(int i = 1; i &lt; nums.size(); i++) &#123; pre = max(nums[i], nums[i] + pre); if(maxsum &lt; pre) maxsum = pre; &#125; return maxsum; &#125;&#125;; method 2å…¶å®žè¿™ä¸ªé¢˜è¿˜å¯ä»¥ä»Žè´ªå¿ƒçš„è§’åº¦æ¥æ€è€ƒï¼Œå¯¹äºŽä¸€ä¸ªåºåˆ—è€Œè¨€ï¼Œè¦ä½¿å…¶å€¼å¢žå¤§ï¼Œå°±å¿…é¡»åŠ ä¸Šä¸€ä¸ªæ­£æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œé‡åˆ°æ­£æ•°å°±åŠ ä¸Šï¼Œé‡åˆ°è´Ÿæ•°å°±æ¸… 0ï¼Œé‡æ–°å¼€å§‹è®¡ç®—ã€‚123456789101112class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int sum = 0, maxsum = INT32_MIN; for(int i = 0; i &lt; nums.size(); i++) &#123; sum += nums[i]; if(sum &gt; maxsum) maxsum = sum; if(sum &lt;= 0) sum = 0; &#125; return maxsum; &#125;&#125;; è™½ç„¶è¿™ä¸ªé¢˜å¯ä»¥ç”¨è´ªå¿ƒçš„è§’åº¦æ¥æ€è€ƒï¼Œä½†æ˜¯ä¸å¦‚ dp ç›´æŽ¥ï¼Œç„¶ä¸”å¾ˆä¸å®¹æ˜“æƒ³åˆ°ã€‚è´ªå¿ƒæ€»æ˜¯æ²¡æœ‰å›ºå®šçš„æ€è€ƒæ–¹æ³•ï¼Œè¦ç»“åˆå®žé™…æ¡ä»¶æ¥æ€è€ƒã€‚ method 3æœ€åŽä¸€ç§æ–¹æ³•ï¼Œå°±æ˜¯åˆ†æ²»ï¼ˆdivede and conquerï¼‰äº†ï¼Œåˆ†æ²»çš„æ€è·¯æš‚æ—¶ä¸å†™äº†ï¼Œå…ˆè®°ä½ï¼Œåˆ†æ²»æ˜¯é€’å½’çš„åŽ»è§£å†³å­é—®é¢˜ã€‚123456789101112131415161718192021222324/* method 3: divide and conquer */class Solution &#123;public: struct Status &#123; int lsum, rsum, msum, isum; &#125; Status pushup(Status l, Status r) &#123; int isum = l.isum + r.isum; int lsum = max(l.lsum, l.isum + r.lsum); int rsum = max(r.rsum, r.isum + l.rsum); int msum = max(max(l.msum, r.msum), l.rsum + r.lsum); return (Status) &#123;lsum, rsum, msum, isum&#125;; &#125; Status get(vector&lt;int&gt; &amp;a, int l, int r) &#123; if(l == r) return (Status)&#123;a[l], a[l], a[l], a[l]&#125;; int m = (l + r) &gt;&gt; 1; Status lsub = get(a, l, m); Status rsub = get(a, m + 1, r); return pushup(lsun, rsub); &#125; int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return get(nums, 0, nums.size() - 1).msum; &#125;&#125;; Summaryç¬¬ä¸€é“é¢˜æ¯”è¾ƒç®€å•ï¼Œç¬¬äºŒä¸ªé¢˜è¦å¤æ‚ä¸€ç‚¹ï¼Œä¸è¿‡ä¹Ÿä¸æ˜¯éš¾åˆ°åšä¸å‡ºæ¥çš„é‚£ç§ã€‚ä¸è¿‡ï¼Œåˆ†æ²»æ³•ç¡®å®žä¸æ˜¯å¾ˆå¥½ç†è§£ã€‚ä»”ç»†æƒ³ä¸€æƒ³ï¼Œæ•°æ®ç»“æž„å…¥é—¨ç¡®å®žæ˜¯æ•°æ®ç»“æž„ç®€å•ï¼Œç®—æ³•æ€æƒ³å¯ä¸ç®€å•å•ŠðŸ˜‚ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day14]]></title>
    <url>%2F2022%2F04%2F05%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day14%2F</url>
    <content type="text"><![CDATA[æœ€åŽä¸€å¤©çš„ä½è¿ç®—äº†ã€‚ 190. Reverse BitsAnalysisè¿™ä¸ªé¢˜å¿…é¡»è¦ç”¨å¾ªçŽ¯æ¥åšï¼Ÿ Codemethod 1è¿™ä¸ªé¢˜å®žé™…ä¸Šæ˜¯ä¸€ä¸ªäºŒè¿›åˆ¶æ•°ä¸²é€†ç½®çš„é—®é¢˜ï¼Œæ‰€ä»¥æŠŠæ¯ä¸€ä½éƒ½æå–å‡ºæ¥å°±å¯ä»¥äº†ã€‚1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t ret = 0; for(int i = 0; i &lt; 32; i++) &#123; if(n &amp; 0x80000000) ret += pow(2, i); n &lt;&lt;= 1; &#125; return ret; &#125;&#125;; å› ä¸ºæœ€åŽå¾—åˆ°çš„ç»“æžœæ˜¯ä¸ªæ•´æ•°ï¼Œæ‰€ä»¥ç›´æŽ¥ç®—å°±è¡Œäº†ã€‚ä¸è¿‡å®žé™…ä¸Šï¼Œæ˜¯æ²¡æœ‰å¿…è¦ç”¨ pow å‡½æ•°çš„ã€‚è€Œä¸”ï¼Œä¹Ÿæ²¡æœ‰å¿…è¦ä¸€å®šéžå¾—æ‰§è¡Œ 32 æ¬¡ã€‚æ‰€ä»¥ï¼Œä¼˜åŒ–ä¸€ä¸‹ï¼š1234567891011class Solution &#123;public: uint32_t reverseBits(uint32_t n) &#123; uint32_t ret = 0; for(int i = 0; i &lt; 32 &amp;&amp; n &gt; 0; i++) &#123; ret |= (n &amp; 1) &lt;&lt; (31 - i); n &gt;&gt;= 1; &#125; return ret; &#125;&#125;; method 2çœ‹äº†é¢˜è§£æ‰çŸ¥é“ï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨åˆ†æ²»çš„æ€è·¯æ¥åšã€‚åˆ†æ²»æ€è·¯çš„æ ¸å¿ƒåœ¨äºŽä¸æ–­äº¤æ¢å¥‡å¶æ•°ä½ï¼Œå…ˆä¾æ¬¡äº¤æ¢ç›¸é‚»çš„ 2 ä¸ªæ•°ä½ï¼Œç„¶åŽæ¯ 4 ä¸ªè¿›è¡Œäº¤æ¢ï¼Œä¾æ¬¡æ‰§è¡Œï¼Œæœ€åŽ 16 ä¸ªæ•°ä½è¿›è¡Œäº¤æ¢ï¼Œå°±å¾—åˆ°äº†ç»“æžœï¼Œè¿™ä¸ªè¿‡ç¨‹æœ‰ç‚¹ç±»ä¼¼å½’å¹¶æŽ’åºã€‚12345678910111213141516class Solution &#123;private: const uint32_t M1 = 0x55555555; const uint32_t M2 = 0x33333333; const uint32_t M3 = 0x0f0f0f0f; const uint32_t M4 = 0x00ff00ff;public: uint32_t reverseBits(uint32_t n) &#123; n = n &gt;&gt; 1 &amp; M1 | (n &amp; M1) &lt;&lt; 1; n = n &gt;&gt; 2 &amp; M2 | (n &amp; M2) &lt;&lt; 2; n = n &gt;&gt; 4 &amp; M3 | (n &amp; M3) &lt;&lt; 4; n = n &gt;&gt; 8 &amp; M4 | (n &amp; M4) &lt;&lt; 8; return n &gt;&gt; 16 | n &lt;&lt; 16; &#125;&#125;; 190. Reverse BitsAnalysisè¿™ä¸ªé¢˜é¦–å…ˆæƒ³åˆ°çš„æ˜¯å€ŸåŠ© hash æ¥å®Œæˆã€‚ Codemethod 1è™½ç„¶é¢˜ç›®é™å®šäº†çº¿æ€§æ—¶é—´å¤æ‚åº¦ä¸Žå¸¸æ•°ç©ºé—´ï¼Œä½†æ˜¯å…ˆåšäº†å†è¯´å§ã€‚ç”¨ hash å°±ä¼šé¢å¤–æ¶ˆè€— $O(n)$ çš„ç©ºé—´ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªé¢˜å…¶å®žä¹Ÿå¯ä»¥ç”¨æŽ’åºæ¥åšï¼Œè¿™ä¸ªå°±ä¸å†™äº†ã€‚123456789101112131415161718/* method 1 */class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int, int&gt; ht; for(int i = 0; i &lt; nums.size(); i++) &#123; ht[nums[i]]++; &#125; int ret = 0; for(auto it: ht) &#123; if(it.second == 1) &#123; ret = it.first; break; &#125; &#125; return ret; &#125;&#125;; æ—¢ç„¶å‡ºçŽ°ä½è¿ç®—è¿™é‡Œï¼Œè‚¯å®šè¿˜æœ‰æ›´ä¼˜çš„è§£æ³•ã€‚ method 2å®žé™…ä¸Šè¿™é‡Œè¦ç”¨åˆ°äº¦æˆ–ï¼ˆ^ï¼‰è¿ç®—çš„æ€§è´¨ï¼Œä¹Ÿå³ï¼š $a \oplus a = 0$ $a \oplus 0 = a$ $a \oplus b \oplus a = a \oplus a \oplus b = 0 \oplus b = b$ è¿™æ ·å°±å¯ä»¥ç›´æŽ¥éåŽ†æ•°ç»„ï¼Œå…¨éƒ¨å…ƒç´ å¼‚æˆ–è¿ç®—ï¼Œæœ€åŽçš„ç»“æžœå°±æ˜¯é‚£ä¸ªåªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­—ã€‚1234567891011/* method 2 */class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int ret = 0; for(auto i: nums) &#123; ret ^= i; &#125; return ret; &#125;&#125;; Summaryè¿™ä¸¤å¤©ç¢°åˆ°çš„ä½è¿ç®—ç›¸å…³çš„é¢˜ç›®éƒ½æ˜¯æ¯”è¾ƒç®€å•çš„é¢˜ç›®ï¼Œåªè¦æŽŒæ¡å¥½è¿ç®—çš„æ€§è´¨å’Œä¸€äº›ç‰¹æ®Šçš„ä½¿ç”¨æŠ€å·§å°±è¡Œäº†ã€‚å¦‚æžœåœ¨ä¸çŸ¥é“è¿™äº›æŠ€å·§å’Œæ€§è´¨çš„æƒ…å†µä¸‹æ¥åšè¿™äº›é¢˜ï¼Œå¯èƒ½å¾ˆéš¾æƒ³åˆ°ä»Žä½è¿ç®—çš„è§’åº¦åŽ»è§£å†³ï¼Œå¤šåŠä¼šç”¨å…¶ä»–æ–¹æ³•æ¥è§£å†³ï¼Œæ‰€ä»¥è¿˜æ˜¯è¦ç†Ÿæ‚‰ä¸€ç‚¹ã€‚ å°½ç®¡è¿™ 14 å¤©çš„é¢˜ç›®éƒ½æ˜¯ä¸€äº›ç®€å•çš„é¢˜ç›®ï¼Œä½†æ˜¯ä¹Ÿæ¶µç›–äº†å¤§éƒ¨åˆ†ç®—æ³•æ€æƒ³ï¼šäºŒåˆ†ã€åŒæŒ‡é’ˆã€é€’å½’ã€åˆ†æ²»ã€åŠ¨æ€è§„åˆ’ã€å›žæº¯ã€DFSã€BFSç­‰ç­‰ï¼Œéœ€è¦åšæ›´å¤šçš„ç›¸å…³ç»ƒä¹ æ¥å·©å›º...ä¸è¿‡æœ€å¥½æ˜¯ç»“åˆä¸€å®šçš„æ•°æ®ç»“æž„ï¼Œè¿™æ ·æ•ˆæžœåº”è¯¥ä¼šæ›´å¥½ã€‚æ˜¯çš„ï¼ŒçŽ°åœ¨å°±èµ¶ç´§å¼€å§‹å¼ºåŒ–ä¸€ä¸‹æ•°æ®ç»“æž„å§ :pã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Bit_Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day13]]></title>
    <url>%2F2022%2F04%2F04%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day13%2F</url>
    <content type="text"><![CDATA[æœ€åŽä¸¤å¤©çš„ä¸»é¢˜éƒ½æ˜¯ä½è¿ç®—ï¼Œé™¤äº† C å¯èƒ½è¿˜ä¼šç”¨åˆ°è¿™äº›ï¼Œå…¶ä»–çš„ç”Ÿäº§çŽ¯å¢ƒè¿˜ä¼šç”¨åˆ°è¿™äº›ä¸œè¥¿å˜›ï¼Ÿ 231. Power of TwoAnalysisé¢˜ç›®å¤§æ„æ˜¯åˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦æ˜¯ 2 çš„ n æ¬¡æ–¹ã€‚ Codemethod 1é¦–å…ˆæƒ³åˆ°çš„æ–¹æ³•ï¼Œè‚¯å®šæ˜¯ç›´æŽ¥æ‹¿å¾ªçŽ¯æ¥åˆ¤æ–­ã€‚ä½†æ˜¯è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸º n çš„ç±»åž‹æ˜¯ intï¼Œä¸ºäº†é¿å…è®¡ç®—è¿‡ç¨‹ç§äº§ç”Ÿçš„æº¢å‡ºï¼Œå°±è¦ä½¿ç”¨ long longã€‚å½“ç„¶ä¹Ÿå¯ä»¥ç”¨ä½è¿ç®—æ¥ä»£æ›¿ pow å‡½æ•°åˆ¤æ–­ï¼Œä¸è¿‡åªè¦ç”¨äº†å¾ªçŽ¯ï¼Œæ„Ÿè§‰éƒ½å¤§åŒå°å¼‚ã€‚12345678910111213/* method 1 */class Solution &#123;public: bool isPowerOfTwo(int n) &#123; long long i = 0, tmp; while(true) &#123; tmp = pow(2, i); if(tmp == n) return true; else if(tmp &gt; n) return false; i++; &#125; &#125;&#125;; method 2ä»”ç»†åˆ†æžä¸€ä¸‹å¯ä»¥å‘çŽ°ï¼Œ2 çš„å¹‚çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸­åªæœ‰ä¸€ä¸ª 1 å­˜åœ¨ã€‚å‡è®¾ n æ˜¯ 2 çš„å¹‚ï¼Œé‚£ä¹ˆ n-1 å°±ä¸æ˜¯ 2 çš„å¹‚ï¼Œä¸” n-1 çš„å¹‚ä¸€å®šæ˜¯ 011...1ï¼Œè¿™ç§æ ·å­ã€‚æ­¤æ—¶å°±æœ‰ n &amp; (n-1) = 0ã€‚1234567/* method 2 */class Solution &#123;public: bool isPowerOfTwo(int n) &#123; return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0 ? true : false; &#125;&#125;; æ³¨æ„ä½¿ç”¨è¿™ç§æ–¹æ³•ä¸€å®šè¦æ³¨æ„è¿ç®—ç¬¦çš„ä¼˜å…ˆçº§ã€‚ 191. Number of 1 BitsAnalysisé¢˜ç›®å¤§æ„æ˜¯æ‰¾å‡ºä¸€ä¸ªäºŒè¿›åˆ¶æ•°ä¸­ 1 çš„ä¸ªæ•°ï¼Œè¿™ä¸ªä¸ªæ•°ä¹Ÿå«Hamming weightã€‚ Codemethod 1æ¯«æ— ç–‘é—®ï¼Œæœ€å…ˆæƒ³åˆ°çš„åšæ³•æ°¸è¿œæ˜¯å¾ªçŽ¯...1234567891011class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n) &#123; if(n &amp; 1) cnt++; n &gt;&gt;= 1; &#125; return cnt; &#125;&#125;; è¿™æ®µä»£ç çš„è¿è¡Œæ—¶é—´å–å†³äºŽ n è¿™ä¸ªæ•°çš„äºŒè¿›åˆ¶é•¿åº¦ã€‚ method 2é¢˜ç›®æç¤ºèƒ½ä¸èƒ½ä¼˜åŒ–è¿è¡Œçš„æ¬¡æ•°ï¼Œå°±ä¸Šé¢çš„ä»£ç è€Œè¨€ï¼Œå…¶å®žå·²ç»æ˜¯å¾ˆå¿«çš„è¿è¡Œé€Ÿåº¦äº†ã€‚ä¸è¿‡ï¼Œè¿˜å¯ä»¥ç»§ç»­å‡å°‘è¿è¡Œçš„æ¬¡æ•°ã€‚è¿™é‡Œè¦å€Ÿç”¨ä¸€ä¸‹ç¬¬ä¸€é“é¢˜é‡Œçš„è®¡ç®—æŠ€å·§ï¼Œå› ä¸º n &amp; n-1 çš„ç»“æžœæ˜¯ n è¿™ä¸ªæ•°åŽ»æŽ‰æœ€ä½Žä½çš„ 1 åŽçš„ç»“æžœã€‚æ‰€ä»¥åˆ©ç”¨è¿™ä¸€ç‚¹ï¼Œè¦è®¡ç®— 1101 è¿™æ ·çš„æ•°ä¸­ 1 çš„ä¸ªæ•°ï¼Œç”¨è¿™ç§æ–¹æ³•å°±å¯ä»¥è·³è¿‡ä¸­é—´çš„ 0 äº†ã€‚123456789101112/* method 2 */class Solution &#123;public: int hammingWeight(uint32_t n) &#123; int cnt = 0; while(n) &#123; n &amp;= (n - 1); cnt++; &#125; return cnt; &#125;&#125;; Summaryä½è¿ç®—çš„ä½¿ç”¨æŠ€å·§è¿˜æœ‰å¾ˆå¤šï¼Œè¿™ç±»è¿ç®—æŠ€å·§åœ¨æ‰§è¡ŒæŸäº›ç®—æ³•çš„æ—¶å€™å¥½åƒå¯ä»¥æžå¤§çš„æå‡æ‰§è¡Œçš„é€Ÿåº¦ã€‚åŽŸå› æ— å®ƒï¼Œåªæ˜¯è¿™æ ·å†™æ›´è´´è¿‘åº•å±‚çš„è¿ç®—ã€‚å½“å¤šä¸ªä¸åŒçš„ä½è¿ç®—ä¸€èµ·ç”¨çš„æ—¶å€™ï¼Œç”±äºŽä¼˜å…ˆçº§çš„å­˜åœ¨ï¼Œäººè„‘ç¡®å®žæœ‰ç‚¹éš¾ç†è§£ã€‚è€Œä¸”ï¼Œæœ‰å¤§éƒ¨åˆ†äººè¯»ä¸æ‡‚...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Bit_Manipulation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day12]]></title>
    <url>%2F2022%2F04%2F03%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day12%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ä¸»é¢˜æ˜¯åŠ¨æ€è§„åˆ’ï¼ˆdpï¼‰ï¼Œä¹‹å‰å°±æƒ³ç¢ç£¨ä¸€ä¸‹è¿™ç±»é—®é¢˜äº†ã€‚ä¸è¿‡ï¼Œä»Šå¤©åº”è¯¥éƒ½æ˜¯æ¯”è¾ƒç®€å•çš„ dp é—®é¢˜ã€‚ 70. Climbing StairsAnalysisè¿™æ˜¯ä¸ªå¾ˆç»å…¸çš„ dp å…¥é—¨é—®é¢˜ï¼Œæ¯æ¬¡è·³å°é˜¶å¯ä»¥é€‰æ‹©è·³ 1 é˜¶æˆ– 2 é˜¶ï¼Œå½“å‰çš„é€‰æ‹©ä¼šå½±å“åˆ°ä¸‹ä¸€è·³çš„é€‰æ‹©ã€‚æ˜¾ç„¶ï¼Œå¦‚æžœåªç”¨è·³ 1 é˜¶ï¼Œé‚£ä¹ˆåªæœ‰ 1 ç§è·³æ³•ï¼›å¦‚æžœè·³ 2 é˜¶ï¼Œå°±æœ‰ 2 ç§è·³æ³•ï¼Œç”±æ­¤å¯å¾—ï¼š$dp[1] = 1, dp[2] = 2$ã€‚æ­¤æ—¶ï¼Œæ‰‹åŠ¨ç®—ä¸€ä¸‹è·³ 3 é˜¶çš„æƒ…å†µï¼Œä¹Ÿå³ï¼š1 1 1ã€1 2å’Œ2 1è¿™ 3 ç§æƒ…å†µï¼Œåˆ™$dp[3] = 3$ï¼ŒåŒç†ï¼Œ$dp[4] = 5$ã€‚è¿™æ ·å°±å¯ä»¥å¾—åˆ°é€’å½’å…¬å¼ï¼ˆä¹Ÿå«çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼‰ï¼š$dp[i] = dp[i - 1] + dp[i - 2]$ã€‚æƒ³åˆ°è¿™é‡Œä¼šå‘çŽ°ï¼Œè¿™æ˜¯ä¸ª fibonacci æ•°åˆ—é—®é¢˜ã€‚ Code1234567891011class Solution &#123;public: int climbStairs(int n) &#123; int dp[50]; dp[1] = 1, dp[2] = 2; for(int i = 3; i &lt;= n; i++) &#123; dp[i] = dp[i - 1] + dp[i - 2]; &#125; return dp[n]; &#125;&#125;; 198. House RobberAnalysisè¿™ä¸ªé¢˜ç®—æ˜¯ä¸Šé¢é‚£ä¸ªé¢˜çš„å˜å¼ï¼Œä»ŽåŽå¾€å‰ç®—å¯èƒ½ä¼šç¨å¾®å¥½ç†è§£ä¸€ç‚¹ï¼Ÿå‡è®¾æ€»å…±æœ‰ n ä¸ªæ•°å­—ï¼Œå¯¹äºŽæœ€åŽä¸€ä¸ªæ•°å­—ï¼Œ$dp[n - 1] = nums[n - 1]$ï¼Œ$dp[n - 2] = nums[n - 2]$ï¼Œå€’æ•°ç¬¬ 3 ä¸ªæ•°å°±æ˜¯$dp[n - 3] = nums[n - 3] + dp[n - 3 + 2]$ï¼Œä½†æ˜¯å€’æ•°ç¬¬å››ä¸ªæ•°å°±ä¸ä¸€æ ·äº†ã€‚é¢˜ç›®åªæ˜¯è¦æ±‚ä¸èƒ½é€‰æ‹©ç›¸é‚»çš„ï¼Œæ²¡è¯´ä¸èƒ½éš” 2 ä¸ªé€‰ï¼Œæ‰€ä»¥$dp[n - 4] = nums[n - 4] + max(dp[n - 4 + 2], dp[n - 4 + 3])$ï¼Œä»Žè€Œå¯ä»¥å¾—åˆ°çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š$dp[i] = nums[i] + max(dp[i + 2], dp[i + 3])$ã€‚ Codeone dimension1234567891011121314151617class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105], size = nums.size(); if(size == 1) return nums[0]; dp[size - 1] = nums[size - 1], dp[size - 2] = nums[size - 2]; int Max = dp[size - 1] &gt; dp[size - 2] ? dp[size - 1] : dp[size - 2]; if(size == 2) return Max; dp[size - 3] = nums[size - 3] + dp[size - 1]; Max = Max &gt; dp[size - 3] ? Max : dp[size - 3]; for(int i = size - 4; i &gt;= 0; i--) &#123; dp[i] = nums[i] + max(dp[i + 2], dp[i + 3]); if(dp[i] &gt; Max) Max = dp[i]; &#125; return Max; &#125;&#125;; å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä»Žå‰å¾€åŽç®—ï¼š1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); if(size == 0) return 0; if(size == 1) return nums[0]; int dp[105]; dp[0] = nums[0], dp[1] = max(dp[0], nums[1]); for(int i = 2; i &lt; size; i++) &#123; dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]); &#125; return dp[size - 1]; &#125;&#125;; two dimensionè¿™ä¸ªé¢˜å…¶å®žä¹Ÿå¯ä»¥ä»Ž 2 ç»´ dp çš„è§’åº¦æ¥è€ƒè™‘ã€‚dp[i][0]è¡¨ç¤ºç¬¬ i å®¶å·ï¼Œdp[i][1]è¡¨ç¤ºç¬¬ i å®¶ä¸å·ï¼Œæ¯ä¸€æ¬¡å·å¾—åˆ°çš„å€¼æ˜¯ç›¸é‚»ä¸€å®¶æœªå·ä¸Žå½“å‰è¿™ä¸€å®¶çš„æ•°å­—ä¹‹å’Œï¼Œè¿™æ˜¯é¢˜ç›®è¦æ±‚çš„ç›¸é‚»ã€‚123456789101112class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; int dp[105][2], size = nums.size(); dp[0][0] = nums[0], dp[0][1] = 0; for(int i = 1; i &lt; size; i++) &#123; dp[i][0] = dp[i - 1][1] + nums[i]; dp[i][1] = max(dp[i - 1][0], dp[i - 1][1]); &#125; return max(dp[size - 1][0], dp[size - 1][1]); &#125;&#125;; æ„Ÿè§‰äºŒç»´ dp å¥½åƒè¿˜éš¾ç†è§£ä¸€ç‚¹ï¼Ÿ 120. TriangleAnalysisè¿™ä¸ªé¢˜ä¹Ÿæ˜¯ç»å…¸çš„ dp æ±‚è§£æ•°å¡”é—®é¢˜ã€‚é‡‡ç”¨è‡ªåº•å‘ä¸Šçš„æ€è·¯æ¥è¿›è¡Œ dpï¼Œè®¾è¿™ä¸ªæ•°å¡”æœ‰ n å±‚ï¼Œé‚£ä¹ˆ$dp[n][j] = triangle[n][j]$ï¼Œæ­¤æ—¶ï¼Œ$dp[n][j]$å°±æ˜¯è¿™ä¸ªé—®é¢˜çš„è¾¹ç•Œï¼Œä¹Ÿå°±æ˜¯æœ€åº•å±‚çš„é‚£ä¸€æŽ’æ•°ã€‚ç»§ç»­å‘ä¸Šä¸€å±‚ï¼Œ$dp[n - 1][j]$å°±æ˜¯$min(dp[n][j], dp[n][j + 1]) + triangle[n - 1][j]$ï¼Œé‚£ä¹ˆçŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±æ˜¯$dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1])$ã€‚ Codebottom-upæŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š1234567891011121314/* bottom-up */class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;vector&lt;int&gt;&gt; dp = triangle; int size = triangle.size(); for(int i = size - 2; i &gt;= 0; i--) &#123; for(int j = 0; j &lt;= i; j++) &#123; dp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle[i][j]; &#125; &#125; return dp[0][0]; &#125;&#125;; top-downåœ¨æŒ‰ç…§è‡ªé¡¶å‘ä¸‹çš„æ€è·¯åšä¸€ä¸‹ï¼šæ˜¾ç„¶è‡ªé¡¶å‘ä¸‹æ—¶ï¼Œ$dp[0][0] = triangle[0][0]$å°±æ˜¯è¾¹ç•Œç¬¬äºŒè¡Œçš„ç¬¬ä¸€ä¸ªæ•°åªèƒ½ä»Žå…¶å³ä¸Šçš„æ•°å¾€ä¸‹ï¼Œæ‰€ä»¥ $dp[i][0] = dp[i - 1][0] + triangle[i][0]$ï¼›åŒç†ï¼Œç¬¬äºŒè¡Œçš„æœ€åŽä¸€ä¸ªæ•°å°±æ˜¯ $dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]$ã€‚é‚£ä¹ˆä¸­é—´çš„æ•°ï¼Œå°±æ˜¯ï¼š$dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]$ï¼Œè¿™å°±æ˜¯è¿™ä¸ªé¢˜çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ã€‚ 12345678910111213141516/* top-down */class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;vector&lt;int&gt;&gt; dp = triangle; int size = triangle.size(); for(int i = 1; i &lt; size; i++) &#123; dp[i][0] = dp[i - 1][0] + triangle[i][0]; for(int j = 1; j &lt; i; j++) &#123; dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]; &#125; dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]; &#125; return *min_element(dp[size - 1].begin(), dp[size - 1].end()); &#125;&#125;; Summaryä»Šå¤©çš„ä¸‰é“ dp é¢˜ï¼Œæ„Ÿè§‰éƒ½ä¸æ˜¯éš¾é¢˜ï¼Œåº”è¯¥éƒ½æ˜¯ååˆ†ç»å…¸çš„å…¥é—¨é¢˜ï¼Œåšçš„æŒºæœ‰æ„æ€ï¼Œç‰¹åˆ«æ˜¯æŽ¨å¯¼çŠ¶æ€è½¬ç§»æ–¹ç¨‹è¿™é‡Œã€‚ç¨å¾®ç»†æƒ³ä¸€ä¸‹ï¼Œè¿™ç§é¢˜å¥½åƒç†è§£äº†é¢˜ç›®æ„æ€ï¼Œå°±çŸ¥é“åº”è¯¥æ˜¯ dp é¢˜äº†ï¼Ÿå¦å¤–ï¼Œä»Žè¿™ 3 ä¸ªé¢˜æ¥è®²ï¼Œdp é¢˜çš„åšæ³•åº”è¯¥å¾ˆå¤šï¼Œä¸è¿‡éƒ½å¤§åŒå°å¼‚ï¼Œé¦–å…ˆè¦æ‰¾åˆ°è¾¹ç•Œï¼Œæ˜Žç¡® dp æ•°ç»„ä¸‹æ ‡çš„å«ä¹‰ï¼Œç„¶åŽæƒ³åŠžæ³•æŽ¨å¯¼å‡ºçŠ¶æ€è½¬ç§»æ–¹ç¨‹å°±å·®ä¸å¤šäº†ã€‚å¤šè¯´æ— ç›Šï¼Œéœ€è¦å†æ¥ç‚¹é¢˜ç›®ç»ƒç»ƒæ‰‹ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Dynamic_Programming</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day11]]></title>
    <url>%2F2022%2F04%2F02%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day11%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ˜¯ 3 é“ä¸­ç­‰é¢˜ï¼Œæœ‰ç‚¹éš¾åº¦ï¼Ÿï¼Ÿï¼Ÿä»Šå¤©çš„ä¸»é¢˜ä¾ç„¶æ˜¯é€’å½’è·Ÿå›žæº¯ã€‚ 77. CombinationsAnalysisè¿™ä¸ªé¢˜çœ‹ç€æŒºç®€å•çš„ï¼Œå…¶å®žä¸æ˜¯ä¸ªç®€å•çš„é¢˜ç›®...æœ€ç›´è§‚çš„æ€è·¯ï¼Œåº”è¯¥æ˜¯å…ˆæŒ‘å‡º 1ï¼Œç„¶åŽä»Žå‰©ä½™å¤§äºŽ 1 çš„æ•°ä¸­æŒ‘é€‰å‡º k - 1 ä¸ªæ•°ï¼Œä¾æ¬¡æŒ‘é€‰å³å¯ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå†™äº†ä¸€ä¸‹ï¼Œè¶Šå†™æ„Ÿè§‰è¶Šä¸å¯¹åŠ²ã€‚åªå‡­å•çº¯çš„å¾ªçŽ¯ï¼Œå¯èƒ½å¹¶ä¸èƒ½å®Œç¾Žçš„è¡¨è¾¾å‡ºè¿™ç§è¿‡ç¨‹ï¼Œè¿˜éœ€è¦ä¸€ç‚¹æ€è€ƒï¼Œè¿˜æ˜¯å…ˆæŒ‰ç…§å¸¸è§„çš„æ€è·¯æ¥å§ã€‚ Codebacktrackingè¿™ä¸ªé¢˜å…¶å®žæ˜¯ä¸ªç»å…¸çš„å›žæº¯æ³•åº”ç”¨é¢˜ï¼Œå¯¹äºŽæ¯ä¸€ä¸ªæ•°å­—åªæœ‰é€‰ä¸Žä¸é€‰ä¸¤ç§å¯èƒ½ï¼Œå½“é€‰å‡ºçš„æ•°çš„ä¸ªæ•°ç­‰äºŽ k æ—¶ï¼Œå°±æ‰¾åˆ°è§£ï¼Œå¯ä»¥è¿”å›žäº†ï¼Œæ³¨æ„å¤§äºŽ n çš„æ•°å­—ä¸èƒ½é€‰ã€‚123456789101112131415161718192021/* dfs */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; if(cur == n + 1) return; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; ä½†æ˜¯ä¸ºä»€ä¹ˆæ€»æ„Ÿè§‰é€’å½’ç”¨çš„è¿™ä¹ˆåˆ«æ‰­å‘¢ï¼ŸæŽ¥ä¸‹æ¥ï¼Œå¯ä»¥ä¿®æ”¹ä¸‹ä»£ç ï¼Œâ€œå‰ªæŽ‰â€æŸäº›æƒ…å†µï¼Œæ¯”å¦‚å½“ tmp çš„å¤§å°ä¸Žå‰©ä½™æ•°å­—ä¹‹å’Œå°äºŽ k æ—¶ï¼Œæ­¤æ—¶ä¸è®ºæ€Žæ ·éƒ½æ˜¯æ— è§£çš„ï¼Œè¿™æ ·å°±æ²¡æœ‰å¿…è¦ç»§ç»­é€’å½’ä¸‹åŽ»äº†ï¼Œè¿™æ ·å°±å¯ä»¥å†™æˆï¼š12345678910111213141516171819202122/* dfs */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() + (n - cur + 1) &lt; k) return; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; if(cur == n + 1) return; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; æŒ‰ç…§ Leetcode ç»™çš„æµ‹è¯•æ ·ä¾‹ï¼Œé€Ÿåº¦çš„æå‡å¾ˆæ˜Žæ˜¾ã€‚å®žé™…ä¸Šï¼Œå½“cur == n + 1æ—¶ï¼Œtmp çš„å¤§å°ä¸Žå‰©ä½™æ•°å­—ä¹‹å’Œä¸€å®šæ˜¯å°äºŽç­‰äºŽ k çš„ï¼Œè¿™æ ·å°±ä¼šè¢«ç¬¬ä¸€ä¸ªæˆ–ç¬¬äºŒä¸ª if è¿”å›žäº†ï¼Œæ‰€ä»¥ï¼Œæœ€ç»ˆçš„ä»£ç å¯ä»¥å†™æˆï¼š123456789101112131415161718192021/* dfs: tmp.size + (n - cur + 1) &lt; k */class Solution &#123;public: vector&lt;int&gt; tmp; void dfs(int cur, int n, int k, vector&lt;vector&lt;int&gt;&gt;&amp; ret) &#123; if(tmp.size() + (n - cur + 1) &lt; k) return; if(tmp.size() == k) &#123; ret.push_back(tmp); return; &#125; tmp.push_back(cur); dfs(cur + 1, n, k, ret); tmp.pop_back(); dfs(cur + 1, n, k, ret); &#125; vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(1, n, k, ret); return ret; &#125;&#125;; iterationè¿™é‡Œä¸å¾—ä¸åœ¨æåˆ°ä¸€ä¸‹ä½¿ç”¨å¾ªçŽ¯ï¼ˆè¿­ä»£ï¼‰çš„æ–¹æ³•ï¼Œä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819/* iteration */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; combine(int n, int k) &#123; vector&lt;vector&lt;int&gt;&gt; ret; int i = 0; vector&lt;int&gt; tmp(k, 0); while(i &gt;= 0) &#123; tmp[i]++; if(tmp[i] &gt; n) i--; else if(i == k - 1) ret.push_back(tmp); else &#123; i++; tmp[i] = tmp[i - 1]; &#125; &#125; return ret; &#125;&#125;; è¿™ä¸ªè§£æ³•å…¶å®žå¹¶æ²¡æœ‰å•çº¯çš„åˆ©ç”¨å¾ªçŽ¯ï¼Œåè€Œæœ‰ä¸€ç‚¹åŠ¨æ€è§„åˆ’çš„å½±å­åœ¨é‡Œé¢ï¼Œåˆæœ‰ä¸€ç‚¹å›žæº¯çš„å½±å­åœ¨é‡Œé¢ã€‚ 46. PermutationsAnalysisçœ‹åˆ°è¿™ä¸ªé¢˜ï¼Œç›´æŽ¥å°±æƒ³åˆ°äº† next_permutation è¿™ä¸ªå‡½æ•°ï¼Œæžœæ–­ç›´æŽ¥ç”¨ã€‚ Codenext_permutation()123456789101112/* next_permutation */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; sort(nums.begin(), nums.end()); do&#123; ret.push_back(nums); &#125; while(next_permutation(nums.begin(), nums.end())); return ret; &#125;&#125;; è¿™é‡Œæœ‰ä¸ªé—®é¢˜ï¼Œä¸€å¼€å§‹æ²¡æœ‰å¯¹ nums è¿›è¡ŒæŽ’åºï¼Œæäº¤æ˜¯æ— æ³•é€šè¿‡çš„ã€‚ç™¾åº¦äº†ä¸€ä¸‹ï¼Œå‘çŽ° next_permutation åœ¨ç”ŸæˆæŽ’åˆ—çš„æ—¶å€™æ˜¯æŒ‰ç…§å½“å‰é¡ºåºç”Ÿæˆä¸‹ä¸€ä¸ªæŽ’åˆ—ï¼Œç›´åˆ°æ•°å­—åºåˆ—æ˜¯é™åºä¸ºæ­¢ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æžœæ•°å­—åºåˆ—ä¸€å¼€å§‹ä¸æ˜¯ä¸¥æ ¼çš„å‡åºåºåˆ—ï¼Œé‚£ä¹ˆå°±å¯èƒ½ä¼šæ¼æŽ‰å¯èƒ½å­˜åœ¨çš„æŽ’åˆ—ç»„åˆï¼Œæ‰€ä»¥è¦å…ˆæŽ’åºï¼Œä¸è¿‡é¢˜ç›®ä¹Ÿä¸æ˜¯æ¯ä¸ªæ ·ä¾‹éƒ½æ˜¯æ— åºåºåˆ—ï¼Œå½“ç„¶äº†ï¼Œç›´æŽ¥æŽ’åºè¿˜æ— è„‘ä¸€ç‚¹ã€‚ backtracking1234567891011121314151617181920/* dfs */class Solution &#123;public: void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; ret, vector&lt;int&gt;&amp; nums, int first, int len) &#123; if(first == len) &#123; ret.push_back(nums); return; &#125; for(int i = first; i &lt; len; i++) &#123; swap(nums[i], nums[first]); dfs(ret, nums, first + 1, len); swap(nums[i], nums[first]); &#125; &#125; vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; ret; dfs(ret, nums, 0, nums.size()); return ret; &#125;&#125;; è™½ç„¶æ˜¯å›žæº¯çš„å…¥é—¨é¢˜ï¼Œä½†æ„Ÿè§‰ä¸æ˜¯å¾ˆå¥½æƒ³å•Š... 784. Letter Case PermutationAnalysisè¿™ä¸ªé¢˜ç®—æ˜¯ä¸Šé¢è¿™ä¸ªé¢˜çš„å˜å¼ï¼Œå¤æ‚åº¦å·®ä¸å¤šã€‚ Codeç›´æŽ¥æŒ‰ç…§ä¸Šé¢çš„æ€è·¯æ¥åšï¼Œæ³¨æ„å¯¹æ¯ä¸€ä¸ªå­—æ¯ï¼Œéœ€è¦è½¬æ¢å¤§å°å†™åŽå†é€‰æ‹©ï¼Œç„¶åŽè¿˜éœ€è¦è¿˜åŽŸï¼ˆå›žæº¯çš„æ€æƒ³ï¼‰ï¼Œä½†æ•°å­—å°±ä¸ç”¨äº†ã€‚12345678910111213141516171819202122232425class Solution &#123;public: string tmp; void dfs(vector&lt;string&gt;&amp; ret, string s, int first, int length) &#123; if(first == length) &#123; ret.push_back(s); return; &#125; if(isupper(s[first])) &#123; s[first] += 32; dfs(ret, s, first + 1, length); s[first] -= 32; &#125; else if(islower(s[first])) &#123; s[frist] -= 32; dfs(ret, s, first + 1, length); s[first] += 32; &#125; dfs(ret, s, first + 1, length); &#125; vector&lt;string&gt; letterCasePermutation(string s) &#123; vector&lt;string&gt; ret; if(s.length() &gt; 0) dfs(ret, s, 0, s.length()); return ret; &#125;&#125;; Summaryä»Šå¤©æ˜¯ 3 é“è€ƒå¯Ÿå›žæº¯ç®—æ³•çš„é¢˜ï¼Œéš¾åº¦ä¸æ˜¯å¾ˆå¤§ï¼Œä½†æ˜¯å…¶ä¸­è•´å«çš„æ€æƒ³è¦å¥½å¥½ä½“ä¼šã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursion&amp;Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day10]]></title>
    <url>%2F2022%2F04%2F01%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day10%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ä¸»é¢˜æ˜¯é€’å½’è·Ÿå›žæº¯ï¼Œæ­£å¥½å¼ºåŒ–ä¸€ä¸‹å¯¹é€’å½’çš„ç†è§£ã€‚ 21. Merge Two Sorted ListsAnalysisè¿™ä¸ªé¢˜æ”¾åœ¨é€’å½’è¿™é‡Œæ€Žä¹ˆæ„Ÿè§‰ä¸æ˜¯å¾ˆåˆç†å‘¢ï¼Ÿçœ‹åˆ°è¿™ä¸ªé¢˜ï¼Œä¸€èˆ¬éƒ½ä¸ä¼šæƒ³åˆ°ç”¨é€’å½’æ¥åšå§ï¼Ÿ Codemethod 1å¦‚æžœä¸ç”¨é€’å½’ï¼Œå°±åªèƒ½éåŽ†é“¾è¡¨äº†ã€‚æŒ‰ç…§æž„é€ ä¸€ä¸ªæ–°é“¾è¡¨çš„æ€è·¯ï¼Œå…ˆè®¾ç½®ä¸€ä¸ªå¤´ç»“ç‚¹ï¼Œç„¶åŽåˆ†åˆ«å°† list1 å’Œ list2 ä¸­ç¬¦åˆæ¡ä»¶çš„ç»“ç‚¹ä¾æ¬¡ä¸²åˆ°å¤´ç»“ç‚¹åŽé¢å³å¯ï¼Œæœ€åŽåˆ«å¿˜äº†é‡Šæ”¾å¤´ç»“ç‚¹ã€‚12345678910111213141516171819202122232425262728/* method 1: no recursion */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; if(list1 == nullptr) return list2; if(list2 == nullptr) return list1; if(list1 == nullptr &amp;&amp; list2 == nullptr) return nullptr; ListNode* head = new ListNode(0); ListNode* p = head; while(list1 &amp;&amp; list2) &#123; if(list1-&gt;val &lt; list2-&gt;val) &#123; p-&gt;next = list1; p = list1; list1 = list1-&gt;next; &#125; else &#123; p-&gt;next = list2; p = list2; list2 = list2-&gt;next; &#125; &#125; if(list1) p-&gt;next = list1; if(list2) p-&gt;next = list2; p = head; p = p-&gt;next; delete(head); return p; &#125;&#125;; method 2ä¸ºä»€ä¹ˆä¼šè§‰å¾—è¿™é€’å½’è¿™ä¹ˆéš¾æƒ³å‘¢ï¼ŸðŸ˜‚1234567891011121314class Solution &#123;public: ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) &#123; if(list1 == nullptr) return list2; else if(list2 == nullptr) return list1; else if(list1-&gt;val &lt; list2-&gt;val) &#123; list1-&gt;next = mergeTwoLists(list1-&gt;next, list2); return list1; &#125; else &#123; list2-&gt;next = mergeTwoLists(list1, list2-&gt;next); return list2; &#125; &#125;&#125;; 206. Reverse Linked ListAnalysisè¿™ä¸ªé¢˜ä¸€çœ‹å°±æƒ³ç”¨æ ˆæ¥åš...é€’å½’æ˜¯ä¸å¯èƒ½é€’å½’çš„ï¼Œè¿™è¾ˆå­éƒ½ä¸å¯èƒ½é€’å½’çš„... Codemethod 1ç”¨æ ˆåšä¼šç¨å¾®éº»çƒ¦ä¸€ç‚¹ï¼Œå› ä¸ºè¦é‡æ–°æž„é€ é“¾è¡¨ã€‚1234567891011121314151617181920212223/* method 1: use stack */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; stack&lt;ListNode*&gt; st; ListNode* p = head; while(p) &#123; st.push(p); p = p-&gt;next; &#125; ListNode* t = st.top(); p = t; st.pop(); while(!st.empty()) &#123; p-&gt;next = st.top(); st.pop(); p = p-&gt;next; &#125; p-&gt;next = nullptr; return t; &#125;&#125;; method 2ä¸ç”¨æ ˆåšçš„è¯ï¼Œéœ€è¦ç”¨åˆ° 3 ä¸ªæŒ‡é’ˆã€‚123456789101112131415/* method 2: no stack */class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *pre = nullptr, *cur = head, *next; while(cur) &#123; next = cur-&gt;next; cur-&gt;next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125;; method 312345678910class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(!head || !head-&gt;next) return head; ListNode* newhead = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return newhead; &#125;&#125;; é€’å½’çœŸé¦™ã€‚æ³¨æ„ä¸Šé¢è¿™æ®µä»£ç ï¼Œnewhead å®žé™…ä¸Šä¸€ç›´éƒ½æŒ‡å‘åŽŸé“¾è¡¨çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ã€‚ method 4123456789101112131415161718class Solution &#123;public: ListNode* reverseList(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode* L = new ListNode(0); ListNode *p = L, *t = L; while(head) &#123; t = head; head = head-&gt;next; t-&gt;next = p-&gt;next; p-&gt;next = t; &#125; p = L; p = p-&gt;next; delete(L); return p; &#125;&#125;; å®žé™…ä¸Šï¼Œè¿™é“é¢˜è¿˜å¯ä»¥ç”¨å¤´æ’æ³•å»ºç«‹ä¸€ä¸ªæ–°é“¾è¡¨ï¼Œè¿™æ ·å»ºç«‹çš„é“¾è¡¨æœ¬èº«å°±æ˜¯é€†ç½®çš„ã€‚ Summaryç”¨ 2 é“é“¾è¡¨çš„é¢˜ç›®æ¥å·©å›ºé€’å½’ï¼Œæ„Ÿè§‰ä¸å¤ªåˆç†ï¼Œä¸è¿‡å¥½åœ¨èƒ½æ•´ç†ä¸€ä¸‹é“¾è¡¨çš„çŸ¥è¯†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Recursion&amp;Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day9]]></title>
    <url>%2F2022%2F03%2F31%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day9%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©å¥½åƒè¿˜çœŸçš„ç»™å›¾ï¼Ÿ 542. 01 MatrixAnalysisçœ‹åˆ°è¿™ä¸ªé¢˜ï¼Œå¾ˆå®¹æ˜“æƒ³åˆ°çš„æ€è·¯å°±æ˜¯ bfsï¼Œæ¯ä¸ªç‚¹é€ä¸€ä½¿ç”¨ bfs ç„¶åŽè¿”å›žç¦»è¿™ä¸ªç‚¹æœ€è¿‘çš„ 0 çš„å±‚æ•°å°±å¥½äº†ã€‚ Codebfså°è¯•ç”¨ bfs å†™äº†ä¸€ä¸‹ï¼Œç»“æžœè¶…æ—¶äº†ï¼Œåº”è¯¥æ˜¯å› ä¸ºæ¯ä¸ªç‚¹é€ä¸€ä½¿ç”¨ bfsï¼Œæœ‰å¾ˆå¤šçš„é‡å¤æ“ä½œã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445/* bfs, these codes will cause time limited exceeded. */class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int x, int y) &#123; if(x &lt; 0 || x &gt;= mat.size() || y &lt; 0 || y &gt;= mat[0].size()) return false; return true; &#125; int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; mat, int sr, int sc) &#123; set&lt;pair&lt;int, int&gt;&gt; ht; int level = 0; if(mat[sr][sc] == 0) return level; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); ht.insert(make_pair(sr, sc)); while(!q.empty()) &#123; int size = q.size(); level++; for(int i = 0; i &lt; size; i++) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int j = 0; j &lt; 4; j++) &#123; int newx = x + X[j], newy = y + Y[j]; if(isvalid(mat, newx, newy) &amp;&amp; ht.find(make_pair(newx, newy)) == ht.end()) &#123; if(mat[newx][newy] == 0) return level; q.emplace(newx, newy); ht.insert(make_pair(newx, newy)); &#125; &#125; &#125; &#125; return -1; &#125; vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; vector&lt;vector&lt;int&gt;&gt; ret = mat; int m = mat.size(), n = mat[0].size(); for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; ret[i][j] = bfs(mat, i, j); &#125; &#125; return ret; &#125;&#125;; å›žå¤´æƒ³æƒ³ï¼Œä¸Šé¢ä»£ç åœ¨åšä»€ä¹ˆäº‹æƒ…ï¼Ÿå°†æ¯ä¸€ä¸ªç‚¹åˆ° 0 çš„è·ç¦»æ±‚å‡ºæ¥ï¼Œæ¢è€Œè¨€ä¹‹ï¼Œå°±æ˜¯åœ¨æ±‚å•æºæœ€çŸ­è·¯å¾„ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå•æºè¶…æ—¶äº†ï¼Œä¸å¦¨åœ¨è¯•è¯•å¤šæºçš„æ€è·¯ã€‚å‡è®¾æ‰€æœ‰çš„ 0 åˆ°ä¸€ä¸ªè¶…çº§ 0 ç‚¹çš„è·ç¦»æ˜¯ 1ï¼Œè¿™æ ·çŸ©é˜µä¸­éž 0 ç‚¹çš„åˆ° 0 ç‚¹çš„è·ç¦»å°±æ˜¯å…¶åˆ°è¾¾è¶…çº§ 0 ç‚¹çš„è·ç¦»å‡ä¸€ã€‚è¿™æ ·åœ¨ bfs å¼€å§‹çš„ç¬¬ä¸€æ­¥ï¼Œå°†æ‰€æœ‰çš„ 0 ç‚¹å…¥é˜Ÿï¼Œè¿™æ ·å°±å¯ä»¥æ‰¾åˆ°æ‰€æœ‰ä¸Ž 0 ç‚¹è·ç¦»ä¸º 1 çš„éž 0 ç‚¹ï¼Œç„¶åŽå†æ ¹æ®è¿™äº›ç‚¹æ‰¾åˆ°è·ç¦»ä¸º 2 çš„éž 0 ç‚¹ï¼Œä¾æ¬¡æ‰§è¡Œå°±å¯ä»¥å¾—åˆ°æœ€ç»ˆçš„ç»“æžœäº†ã€‚123456789101112131415161718192021222324252627282930313233/* bfs: version 2 */class Solution &#123;private: static constexpr int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;public: vector&lt;vector&lt;int&gt;&gt; updateMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; mat) &#123; int m = mat.size(), n = mat[0].size(); vector&lt;vector&lt;int&gt;&gt; dist(m, vector&lt;int&gt;(n)); vector&lt;vector&lt;int&gt;&gt; inq(m, vector&lt;int&gt;(n)); queue&lt;pair&lt;int, int&gt;&gt; q; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(mat[i][j] == 0) &#123; q.emplace(i, j); inq[i][j] = 1; &#125; &#125; &#125; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dirs[d][0], newy = y + dirs[d][1]; if(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; !inq[newx][newy]) &#123; dist[newx][newy] = dist[x][y] + 1; q.emplace(newx, newy); inq[newx][newy] = 1; &#125; &#125; &#125; return dist; &#125;&#125;; æŒ‰ç…§å¤šæºæœ€çŸ­è·¯çš„æ€è·¯å°±å¯ä»¥å¾ˆå¥½çš„è§£å†³è¿™é“é¢˜äº†ï¼Œinq è¿™ä¸ªæ•°ç»„æ˜¯ç”¨æ¥æ ‡è®°æ˜¯å¦å…¥è¿‡é˜Ÿã€‚å®žé™…ä¸Šè¿™ä¸ªé¢˜ï¼Œè¿˜å¯ä»¥ä»Ž dp çš„è§’åº¦æ€è€ƒï¼Œç­‰åšäº† dp çš„ç®€å•é¢˜åŽå†å›žå¤´æ¥çœ‹ã€‚ 994. Rotting OrangesAnalysisè¿™ä¸ªé¢˜è·Ÿä¸Šé¢çš„é¢˜æ˜¯ä¸€æ ·çš„æ€è·¯ï¼Œæ‰€ä»¥å·ä¸€ä¸‹æ‡’ï¼Œç›´æŽ¥ç”¨ä¸Šé¢å†™å¥½çš„ä»£ç ã€‚ä¸è¿‡ï¼Œæœ‰äº›åœ°æ–¹è¦æ”¹æˆæ»¡è¶³è¿™é“é¢˜çš„æ¡ä»¶ã€‚é¦–å…ˆï¼ŒæŒ‰ç…§è¿™ä¸ªé¢˜çš„è¿‡ç¨‹ï¼Œåªéœ€è¦è®¿é—®ä¸º 1 æˆ–è€… 2 çš„ç»“ç‚¹ï¼Œä¸º 0 çš„ç»“ç‚¹ä¸éœ€è¦è®¿é—®ã€‚å†è€…ï¼Œç”±äºŽä¸€å¼€å§‹éœ€è¦å°†æ‰€æœ‰çƒ‚æ©˜å­å…¥é˜Ÿï¼Œæ­¤æ—¶å¯ä»¥åŒæ—¶ç®—å‡ºå¥½æ©˜å­çš„æ€»æ•° cntï¼Œè¿™æ ·åœ¨è…çƒ‚çš„è¿‡ç¨‹ä¸­ï¼Œå¯ä»¥ä¾æ¬¡å‡åŽ»è…çƒ‚çš„æ©˜å­ä¸ªæ•°ã€‚bfs ç»“æŸåŽï¼Œå°±å¯ä»¥ç”¨ cnt æ¥åˆ¤æ–­æ˜¯å¦æ‰€æœ‰çš„æ©˜å­éƒ½è…çƒ‚äº†ï¼Œè¿™æ ·å°±ä¸ç”¨å†é‡æ–°éåŽ† grid ä¸Ž dist æ˜¯å¦å…¨éƒ¨æ©˜å­éƒ½è…çƒ‚äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123;private: static constexpr int dirs[4][2] = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;public: int dist[10][10]; int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); memset(dist, -1, sizeof(dist)); vector&lt;vector&lt;int&gt;&gt; inq(m, vector&lt;int&gt;(n)); queue&lt;pair&lt;int, int&gt;&gt; q; int cnt = 0, ans = 0; for(int i = 0; i &lt; m; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; if(grid[i][j] == 2) &#123; q.emplace(i, j); dist[i][j] = 0; inq[i][j] = 1; &#125; else if(grid[i][j] == 1) cnt++; &#125; &#125; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int d = 0; d &lt; 4; d++) &#123; int newx = x + dirs[d][0], newy = y + dirs[d][1]; if(newx &gt;= 0 &amp;&amp; newx &lt; m &amp;&amp; newy &gt;= 0 &amp;&amp; newy &lt; n &amp;&amp; !inq[newx][newy] &amp;&amp; grid[newx][newy]) &#123; dist[newx][newy] = dist[x][y] + 1; q.emplace(newx, newy); inq[newx][newy] = 1; if(grid[newx][newy] == 1) &#123; cnt--; ans = dist[newx][newy]; if(cnt == 0) break; &#125; &#125; &#125; &#125; return cnt ? -1 : ans; &#125;&#125;; Summaryä»Šå¤©åšçš„ä¸¤é“é¢˜æœ¬è´¨ä¸Šæ˜¯æœ€çŸ­è·¯çš„é—®é¢˜ï¼Œè¿™ç±»é—®é¢˜çš„éš¾ç‚¹åœ¨äºŽç†è§£é¢˜ç›®çš„æ¡ä»¶ï¼Œåªè¦èƒ½ç†è§£é¢˜ç›®ï¼Œå°±æ˜¯ä¸€é“ç®€å•é¢˜ï¼Œä½†æ˜¯ä»£ç é‡ä¸€èˆ¬éƒ½æ¯”è¾ƒé•¿ã€‚æ‰€ä»¥ï¼Œè¿˜æ˜¯éœ€è¦å¤šåšæ‰èƒ½ç†Ÿç»ƒã€‚ä¸å¾—ä¸å†è¯´ä¸€å¥ï¼Œä¸äº†è§£æ ‘å’Œå›¾çš„çŸ¥è¯†ï¼Œåšè¿™ç§é¢˜çš„æ•ˆæžœå°±ä¸æ˜¯å¾ˆå¥½...]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day8]]></title>
    <url>%2F2022%2F03%2F30%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day8%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©çš„ä¸»é¢˜è¿˜æ˜¯æœç´¢~å†²ï¼Œå†²ï¼Œå†²ï¼ 617. Merge Two Binary TreesAnalysisæžœç„¶ï¼Œç®€å•é¢˜éƒ½å¾ˆç›´æŽ¥ï¼Œä¸ä¼šåšå®Œå…¨å°±æ˜¯åŸºç¡€ä¸å¤Ÿæ‰Žå®ž... Codedfs123456789101112/* dfs */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if(root1 == nullptr) return root2; if(root2 == nullptr) return root1; TreeNode* merged_node = new TreeNode(root1-&gt;val + root2-&gt;val); merged_node-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left); merged_node-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right); return merged_node; &#125;&#125;; ç”¨ dfs å†™æ˜¯çœŸçš„ç®€å•ã€‚ bfs12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* bfs */class Solution &#123;public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) &#123; if(root1 == nullptr) return root2; if(root2 == nullptr) return root1; TreeNode* merged_node = new TreeNode(root1-&gt;val + root2-&gt;val); queue&lt;TreeNode*&gt; q, q1, q2; q.push(merged_node); q1.push(root1); q2.push(root2); while(!q1.empty() &amp;&amp; !q2.empty()) &#123; auto node = q.front(), node1 = q1.front(), node2 = q2.front(); q.pop(), q1.pop(), q2.pop(); auto left1 = node1-&gt;left, left2 = node2-&gt;left; auto right1 = node1-&gt;right, right2 = node2-&gt;right; if(left1 != nullptr || left2 != nullptr) &#123; if(left1 != nullptr &amp;&amp; left2 != nullptr) &#123; auto left = new TreeNode(left1-&gt;val + left2-&gt;val); node-&gt;left = left; q.push(left); q1.push(left1); q2.push(left2); &#125; else if(left1 != nullptr) &#123; node-&gt;left = left1; &#125; else if(left2 != nullptr) &#123; node-&gt;left = left2; &#125; &#125; if(right1 != nullptr || right2 != nullptr) &#123; if(right1 != nullptr &amp;&amp; right2 != nullptr) &#123; auto right = new TreeNode(right1-&gt;val + right2-&gt;val); node-&gt;right = right; q.push(right); q1.push(right1); q2.push(right2); &#125; else if(right1 != nullptr) &#123; node-&gt;right = right1; &#125; else if(right2 != nullptr) &#123; node-&gt;right = right2; &#125; &#125; &#125; return merged_node; &#125;&#125;; ç”¨ bfs å†™çœŸçš„éº»çƒ¦äº†å¾ˆå¤šï¼Œè€Œä¸”å°±ä»£ç çš„æ‰§è¡Œæ•ˆçŽ‡å’Œæ¶ˆè€—ç©ºé—´è€Œè¨€ï¼Œä¹Ÿä¸å¤ªä¼˜ç§€ã€‚å¾ˆä¹…æ²¡æœ‰å†™è·Ÿæ ‘ç›¸å…³çš„ä»£ç äº†ï¼Œåè€Œä¸å¤ªä¼šäº†ã€‚ 116. Populating Next Right Pointers in Each NodeAnalysisåˆæ˜¯è·Ÿæ ‘ç›¸å…³çš„é¢˜ç›®ï¼Œå› ä¸ºæ²¡æœ‰å¤ä¹ æ ‘çš„ç›¸å…³çŸ¥è¯†ç‚¹ï¼Œæ„Ÿè§‰ç»ƒä¹ çš„æ•ˆæžœä¸æ˜¯å¾ˆå¥½ã€‚æ‰¯è¿œäº†ï¼Œå›žåˆ°è¿™é“é¢˜ã€‚è¯»å®Œé¢˜ç›®ï¼Œè¿™ä¸ªé¢˜ä¸€çœ‹å°±æƒ³åˆ°ç”¨å±‚åºéåŽ†ï¼ˆbfsï¼‰ï¼Œä½†æ˜¯éœ€è¦è§£å†³çš„é—®é¢˜æ˜¯å¦‚ä½•åˆ¤æ–­é‚£äº›ç»“ç‚¹æ˜¯åœ¨åŒä¸€å±‚ã€‚åº”è¯¥å¯ä»¥ä»Žç»“ç‚¹ä¸ªæ•°ä¸‹æ‰‹ï¼Œå› ä¸ºé¢˜ç›®å·²ç»é™å®šäº†æ˜¯å®Œç¾ŽäºŒå‰æ ‘ã€‚ Codelevel order123456789101112131415161718192021/* level order */class Solution &#123;public: Node* connect(Node* root) &#123; if(root == nullptr) return nullptr; queue&lt;Node*&gt; q; int cnt = 1; q.push(root); while(!q.empty()) &#123; int size = q.size(); for(int i = 0; i &lt; size; i++) &#123; Node* node = q.front(); q.pop(); if(i &lt; size - 1) node-&gt;next = q.front(); if(node-&gt;left != nullptr) q.push(node-&gt;left); if(node-&gt;right != nullptr) q.push(node-&gt;right); &#125; &#125; return root; &#125;&#125;; å¥½å§ï¼ŒçœŸæ˜¯ç”Ÿç–äº†ï¼Œå¹¶ä¸ç”¨åˆ¤æ–­æ˜¯ä¸æ˜¯åœ¨ä¸€å±‚ï¼Œå› ä¸ºå±‚åºéåŽ†å°±æ˜¯ä¸€å±‚ä¸€å±‚éåŽ†çš„ï¼Œçœ‹æ¥æ˜¯å®Œå…¨å¿˜è®°æ ‘çš„å±‚åºéåŽ†äº†ðŸ˜‚ã€‚ä¸è¿‡ï¼Œè™½ç„¶å¯ä»¥ç”¨å±‚åºéåŽ†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œä½†æ˜¯é¢˜ç›®è¦æ±‚ä½¿ç”¨å¸¸æ•°ä¸ªå­˜å‚¨ç©ºé—´ï¼Œä¹Ÿå°±æ˜¯ç©ºé—´å¤æ‚åº¦å¾—æ˜¯$O(1)$ï¼Œé‚£åªèƒ½æ¢ä¸€ç§æ–¹æ³•æ¥åšäº†ã€‚ next pointerä»”ç»†æƒ³ä¸€æƒ³ï¼Œé¢˜ç›®è¦åšçš„äº‹æƒ…å®žé™…ä¸Šå°±æ˜¯å°†æ ‘çš„æ¯ä¸€å±‚ç»“ç‚¹ä¸²èµ·æ¥å½¢æˆä¸€ä¸ªé“¾è¡¨ï¼Œè¿™æ ·è¦åšçš„äº‹æƒ…å°±æ˜¯æ‰¾åˆ°æŒ‡å®šç»“ç‚¹çš„åœ°å€å¹¶äº¤ç»™å¯¹åº”çš„ nextã€‚å½“ä½äºŽç¬¬ N å±‚æ—¶ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„æ‰¾åˆ°ç¬¬ N + 1 å±‚çš„ç»“ç‚¹ï¼Œå› ä¸ºçˆ¶èŠ‚ç‚¹å¯ä»¥å¾ˆå®¹æ˜“æ‰¾åˆ°å­ç»“ç‚¹ã€‚è¿™æ—¶ï¼Œå°±å­˜åœ¨ 2 ç§æƒ…å†µï¼š å­ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ç›¸åŒï¼Œè¿™æ ·å·¦å­ç»“ç‚¹çš„ next å°±æœ‰ï¼šleftchild-&gt;next = parent-&gt;rightã€‚ å­ç»“ç‚¹çš„çˆ¶èŠ‚ç‚¹ä¸åŒï¼Œä¹Ÿå°±æ˜¯å³å­ç»“ç‚¹ä¸Žå¦ä¸€é¢—çˆ¶èŠ‚ç‚¹çš„å·¦å­ç»“ç‚¹ç›¸è¿žï¼Œä¹Ÿå°±æœ‰ï¼šrightchild-&gt;next = parent-&gt;next-&gt;leftã€‚ æœ‰äº†è¿™ä¸ªæ€è·¯åŽè¿˜éœ€è¦è€ƒè™‘ä¸€ä¸‹æ ¹èŠ‚ç‚¹è·Ÿæ¯ä¸€å±‚çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ã€‚æ ¹èŠ‚ç‚¹ç›´æŽ¥ä¿®æ”¹ next å°±å¯ä»¥äº†ï¼Œä½†æ˜¯å¦‚ä½•çŸ¥é“æ˜¯æœ€åŽä¸€ä¸ªç»“ç‚¹å‘¢ï¼Ÿå®žé™…ä¸Šåœ¨ç¬¬ N å±‚æ—¶ï¼Œè¿™ä¸€å±‚çš„é“¾è¡¨å·²ç»åœ¨ç¬¬ N - 1 å±‚æž„é€ å¥½äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œç›´æŽ¥éåŽ†å³å¯ï¼Œåˆ°æœ«å°¾è‡ªç„¶å°±æ˜¯ NULL äº†ã€‚å¦å¤–ï¼Œå°†æ ¹ç»“ç‚¹å½“ä½œç¬¬ 0 å±‚ï¼Œå¯èƒ½ä¼šå¥½ç†è§£ä¸€äº›ã€‚123456789101112131415161718/* use next pointer */class Solution &#123;public: Node* connect(Node* root) &#123; if(root == nullptr) return nullptr; Node* leftmost = root; while(leftmost-&gt;left != nullptr) &#123; Node* head = leftmost; while(head != nullptr) &#123; head-&gt;left-&gt;next = head-&gt;right; if(head-&gt;next != nullptr) head-&gt;right-&gt;next = head-&gt;next-&gt;left; head = head-&gt;next; &#125; leftmost = leftmost-&gt;left; &#125; return root; &#125;&#125;; Summaryçœ‹ç€ä»Šå¤©çš„ä¸»é¢˜è¿˜æ˜¯æœç´¢ä»¥ä¸ºè¿˜æ˜¯ç®€å•çš„çº¯æœç´¢é—®é¢˜å‘¢ï¼Œæ²¡æƒ³åˆ°ç›´æŽ¥è·Ÿæ ‘è”ç³»åˆ°ä¸€èµ·äº†...å—¯ï¼Œæ˜Žå¤©ä¸ä¼šç›´æŽ¥å°±ä¸Šå›¾äº†å§ï¼Ÿè¿™ä¸¤é“é¢˜ä¹Ÿæ˜¯å¾ˆåŸºç¡€å¸¸è§„çš„ä¸Žæ ‘ç›¸å…³çš„é¢˜ç›®ï¼Œæ²¡åšå‡ºæ¥ï¼ŒçœŸè¯¥åçœä¸€ä¸‹äº†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day7]]></title>
    <url>%2F2022%2F03%2F29%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day7%2F</url>
    <content type="text"><![CDATA[æ»‘åŠ¨çª—å£è¿˜æ²¡ç»ƒå¤Ÿå•Šï¼Œå°±åˆ° DFS äº†...14 å¤©æ˜¾ç„¶ä¸å¤Ÿç”¨ã€‚åºŸè¯å°‘è¯´ï¼Œä¸€é“ç®€å•é¢˜ï¼Œä¸€é“ä¸­ç­‰é¢˜ã€‚ 733. Flood FillAnalysisè¿™ä¸ªé¢˜æ˜¯ä¸ªå¾ˆæ˜Žæ˜¾çš„æœç´¢é¢˜ï¼Œæ€è€ƒäº†ä¸€ä¸‹ dfs çš„åšæ³•ï¼Œæ²¡æƒ³å‡ºæ¥...ç„¶åŽå°±ä»Ž bfs çš„è§’åº¦æ¥åšï¼Œåšå‡ºæ¥äº†ï¼Œå°±æ˜¯ä»£ç å†™çš„æ¯”è¾ƒä¹±... Codebfs123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: bool isvisited[55][55] = &#123;false&#125;; int X[4] = &#123;-1, 1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; struct Node &#123; int x, y; &#125; node; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int m, int n, int value) &#123; if(x &lt; 0 || x &gt;= m || y &lt; 0 || y &gt;= n) return false; if(isvisited[x][y]) return false; if(image[x][y] != value) return false; return true; &#125; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int m = image.size(), n = image[0].size(), value = image[sr][sc]; node.x = sr, node.y = sc; queue&lt;Node&gt; q; q.push(node); isvisited[node.x][node.y] = true; while(!q.empty()) &#123; Node tmp = q.front(); q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int x = tmp.x + X[i]; int y = tmp.y + Y[i]; if(isvalid(image, x, y, m, n, value)) &#123; node.x = x; node.y = y; isvisited[x][y] = true; image[x][y] = newColor; q.push(node); &#125; &#125; &#125; image[sr][sc] = newColor; return image; &#125;&#125;; å¥½å§ï¼Œæ¥ç®€åŒ–ä¸€ä¸‹ä»£ç ï¼š123456789101112131415161718192021222324class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; if(newColor == image[sr][sc]) return image; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int m = image.size(), n = image[0].size(), value = image[sr][sc]; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); image[sr][sc] = newColor; while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &gt;= 0 &amp;&amp; newX &lt; m &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; n &amp;&amp; image[newX][newY] == value) &#123; q.emplace(newX, newY); image[newX][newY] = newColor; &#125; &#125; &#125; return image; &#125;&#125;; éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸Šé¢çš„è¿™æ®µ bfs ä»£ç å¹¶æ²¡æœ‰å¯¹ç‚¹æ˜¯å¦å…¥é˜Ÿè¿›è¡Œåˆ¤æ–­ï¼Œæ‰€ä»¥å½“ newColor ä¸Ž image[sr][sc] ç›¸ç­‰çš„æ—¶å€™ï¼Œä¼šé™·å…¥æ­»å¾ªçŽ¯ã€‚ä½†æ˜¯æŒ‰ç…§è¿™ä¸ªé¢˜ç›®çš„æ¡ä»¶ï¼Œå¦‚æžœäºŒè€…ç›¸ç­‰äº†ï¼Œå°±å¯ä»¥ç›´æŽ¥è¿”å›žäº†ã€‚ä¸ºä»€ä¹ˆèƒ½ç›´æŽ¥è¿”å›žï¼Ÿå› ä¸ºå½“æºç‚¹ä¸Šä¸‹å·¦å³å››ä¸ªç›¸é‚»ç‚¹çš„å€¼ä¸Žæºç‚¹å€¼ç›¸ç­‰æ—¶ï¼Œé‚£ä¹ˆä¹Ÿä¸€å®šä¸Ž newColor ç›¸ç­‰äº†ã€‚ dfsä¸ºä»€ä¹ˆæ€»è§‰å¾— dfs çš„é€’å½’å¾ˆæ€ªå‘¢ï¼Ÿ123456789101112131415161718192021class Solution &#123;public: int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; image, int x, int y, int color, int newColor) &#123; if(image[x][y] == color) &#123; image[x][y] = newColor; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &gt;= 0 &amp;&amp; newX &lt; image.size() &amp;&amp; newY &gt;= 0 &amp;&amp; newY &lt; image[0].size()) &#123; dfs(image, newX, newY, color, newColor); &#125; &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; floodFill(vector&lt;vector&lt;int&gt;&gt;&amp; image, int sr, int sc, int newColor) &#123; int curColor = image[sr][sc]; if(curColor != newColor) dfs(image, sr, sc, curColor, newColor); return image; &#125;&#125;; 695. å²›å±¿çš„æœ€å¤§é¢ç§¯Analysisè¿™ä¸ªé¢˜å®žè´¨ä¸Šå°±æ˜¯åœ¨æ‰¾ç”±ç›¸é‚»çš„ 1 ç»„æˆçš„æœ€å¤§å—...æ¢å¥è¯è®²ï¼Œè¿™ä¸ªé¢˜å…¶å®žä¹Ÿå°±æ˜¯åœ¨æ‰¾å›¾çš„æžå¤§è¿žé€šå­å›¾ï¼Œå¹¶è¿”å›žæœ€å¤§ç»“ç‚¹æ•°ã€‚ Codebfsæ„Ÿè§‰å¯¹ bfs çš„ç†Ÿæ‚‰ç¨‹åº¦è¦æ·±ä¸€ç‚¹ï¼Œdfs æ€»æ˜¯æ‘¸ä¸æ¸…æ¥šé€’å½’è¾¹ç•Œï¼Œä¸çŸ¥é“æŠŠé€’å½’è¾¹ç•Œå†™åœ¨å“ªé‡Œï¼Œbfs ä¸ä¸€ä¼šå°±å†™å‡ºæ¥äº†ã€‚1234567891011121314151617181920212223242526272829303132333435363738/* bfs */class Solution &#123;public: bool inq[55][55] = &#123;false&#125;; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; int bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int sr, int sc, int m, int n) &#123; int count = 0; queue&lt;pair&lt;int, int&gt;&gt; q; q.emplace(sr, sc); while(!q.empty()) &#123; int x = q.front().first, y = q.front().second; q.pop(); inq[x][y] = true; count++; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; if(newX &lt; m &amp;&amp; newX &gt;= 0 &amp;&amp; newY &lt; n &amp;&amp; newY &gt;= 0 &amp;&amp; grid[newX][newY] &amp;&amp; !inq[newX][newY]) &#123; inq[newX][newY] = true; q.emplace(newX, newY); &#125; &#125; &#125; return count; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(), ans = 0; for(int x = 0; x &lt; m; x++) &#123; for(int y = 0; y &lt; n; y++) &#123; if(grid[x][y] &amp;&amp; !inq[x][y]) &#123; int tmp = bfs(grid, x, y, m, n); ans = tmp &gt; ans ? tmp : ans; &#125; &#125; &#125; return ans; &#125;&#125;; bfs å†…çš„ if çš„æ¡ä»¶ï¼Œä¸€å®šè¦å…ˆåˆ¤æ–­æ˜¯å¦è¶Šç•Œï¼Œä¸ç„¶ä¼š rumtime errorï¼ˆä¹Ÿå°±æ˜¯è¶Šç•Œï¼‰ï¼Œè¿™å…¶å®žæ˜¯ä¸ªä¸ç®— bug çš„ bugðŸ˜‚ï¼Œä¸è¿‡è¿˜æ˜¯è®©æˆ‘ç¢ç£¨äº†å¿« 20 åˆ†é’Ÿã€‚ dfsè¿˜æ˜¯å†™ä¸ªåˆ¤æ–­ç‚¹æ˜¯å¦ç¬¦åˆæ¡ä»¶çš„å‡½æ•°å§ï¼Œè¿™æ ·çœ‹ç€æ¡ç†ä¼šæ¸…æ™°ä¸€ç‚¹ã€‚12345678910111213141516171819202122232425262728293031323334/* dfs */class Solution &#123;public: bool inq[55][55] = &#123;false&#125;; int X[4] = &#123;1, -1, 0, 0&#125;; int Y[4] = &#123;0, 0, 1, -1&#125;; bool isvalid(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if(x &lt; 0 || x &gt;= grid.size() || y &lt; 0 || y &gt;= grid[0].size()) return false; if(inq[x][y] || grid[x][y] == 0) return false; return true; &#125; int dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y) &#123; if(!isvalid(grid, x, y)) return 0; inq[x][y] = true; int count = 1; for(int i = 0; i &lt; 4; i++) &#123; int newX = x + X[i], newY = y + Y[i]; count += dfs(grid, newX, newY); &#125; return count; &#125; int maxAreaOfIsland(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(), ans = 0; for(int x = 0; x &lt; m; x++) &#123; for(int y = 0; y &lt; n; y++) &#123; if(grid[x][y] &amp;&amp; !inq[x][y]) &#123; int tmp = dfs(grid, x, y); ans = tmp &gt; ans ? tmp : ans; &#125; &#125; &#125; return ans; &#125;&#125;; ç”¨ä¸å¥½ dfs çš„åŽŸå› ï¼Œåº”è¯¥æ˜¯å¯¹é€’å½’è¾¹ç•Œçš„ç†è§£å¾ˆè¿·ã€‚ Summaryä»Šå¤©çš„ä¸¤é“é¢˜åº”è¯¥ç®—æ˜¯å¾ˆå¸¸è§„çš„ dfsã€bfs å…¥é—¨é¢˜åž‹äº†ï¼Œæ„Ÿè§‰è¿™éƒ¨åˆ†å†…å®¹å·²ç»è·Ÿå›¾æ²¾ä¸Šè¾¹äº†ã€‚å°½ç®¡ä»£ç ä¸€èˆ¬éƒ½æ¯”è¾ƒé•¿ï¼Œä½†æ˜¯æ„Ÿè§‰è¿˜æ˜¯æ»‘åŠ¨çª—å£ã€DP ä¹‹ç±»çš„é¢˜ç›®æ›´éš¾ç†è§£ä¸€ç‚¹ï¼Œè¿™äº›åè€Œæ¯”è¾ƒæ˜“äºŽç†è§£ï¼Œä¹Ÿå¯èƒ½æ˜¯è¿˜æ²¡ç¢°åˆ°éš¾é¢˜å§ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>DFS&amp;BFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨-day6]]></title>
    <url>%2F2022%2F03%2F28%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day6%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©æ˜¯æ»‘åŠ¨çª—å£äº†ï¼Œç»ˆäºŽä¸æ˜¯åŒæŒ‡é’ˆäº†ï¼Œæ„Ÿè§‰åŒæŒ‡é’ˆçš„é¢˜è¿˜æ²¡åšå¤ŸðŸ˜‚ã€‚ä¸¤é“ä¸­ç­‰é¢˜ã€‚ 3. Longest Substring Without Repeating CharactersAnalysiså¯»æ‰¾æ— é‡å¤å­—ç¬¦çš„æœ€é•¿å­ä¸²ï¼Œè¿™ä¸ªé—®é¢˜å¥½åƒå¯ä»¥ç”¨ KMP æ¥è§£å†³ï¼Œä½†æ˜¯æˆ‘æ—©å°±å¿˜è®°äº† KMP æ€Žä¹ˆç”¨äº†ã€‚ç„¶è€Œï¼Œé—æ†¾çš„æ˜¯æ»‘åŠ¨çª—å£çš„é¢˜æˆ‘ä¹Ÿæ²¡åšè¿‡ï¼Œæ‰€ä»¥å°±åªèƒ½æš´åŠ›è§£å†³äº†ã€‚æ²¡æƒ³åˆ°ï¼Œç«Ÿç„¶è¿˜å¯ä»¥è¿‡ã€‚ Codemethod 1æ¯”è¾ƒå°´å°¬çš„æ˜¯ï¼Œä¸€å¼€å§‹è€æ˜¯æƒ³ç”¨æ»‘åŠ¨çª—å£æ¥åšï¼Œç»“æžœæäº¤äº† 3 æ¬¡æ²¡è¿‡ï¼Œç›´æŽ¥åˆ äº†é‡æ–°å†™æš´åŠ›è§£æ³•ï¼Œä¸€æ¬¡å°±è¿‡äº†ã€‚1234567891011121314151617/* method 1: violent solutions */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int len = s.length(), i, j, ret = 0; for(i = 0; i &lt; len; i++) &#123; string tmp; tmp += s[i]; for(j = i + 1; j &lt; len; j++) &#123; if(tmp.find(s[j]) == string::npos) tmp += s[j]; else break; &#125; if(tmp.length() &gt; ret) ret = tmp.length(); &#125; return ret; &#125;&#125;; method 2å­¦ä¹ ä¸€ä¸‹æ»‘åŠ¨çª—å£çš„è§£æ³•ã€‚1234567891011121314151617181920/* method 2: use a set simulate hashtable to judge whether the char has appeared or not. */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; unordered_set&lt;char&gt; ht; int n = s.length(); int rk = -1, ans = 0; for(int i = 0; i &lt; n; i++) &#123; if(i != 0) &#123; ht.erase(s[i - 1]); &#125; while(rk + 1 &lt; n &amp;&amp; ht.find(s[rk + 1]) == ht.end()) &#123; ht.insert(s[rk + 1]); rk++; &#125; ans = max(ans, rk - i + 1); &#125; return ans; &#125;&#125;; æ»‘åŠ¨çª—å£å¥½åƒå¿…é¡»è¦æœ‰ä¸€ä¸ª hash è¡¨æ¥åˆ¤æ–­æ˜¯å¦å‡ºçŽ°é‡å¤çš„å­—ç¬¦ï¼Ÿä¸çŸ¥é“æ˜¯ä¸æ˜¯åŽŸæ¥ç ”ç©¶è¿‡ KMP çš„ç¼˜æ•…ï¼Œæ„Ÿè§‰æŒºå®¹æ˜“ç†è§£çš„ï¼Œå°±æ˜¯è‡ªå·±å†™ä¸å‡ºæ¥ðŸ˜‚ã€‚ method 3å¥½å§ï¼Œå¹¶ä¸æ˜¯ä¸€å®šéœ€è¦ hash è¡¨æ¥åˆ¤æ–­æ˜¯å¦å‡ºçŽ°é‡å¤çš„å­—ç¬¦ï¼Œæ„Ÿè§‰ä¸‹é¢è¿™æ®µä»£ç æ‰æ˜¯åŽŸæ±åŽŸå‘³çš„æ»‘åŠ¨çª—å£...1234567891011121314151617181920212223/* method 3: silding window */class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; int len = s.length(); int start, end, index, ans, l; start = end = ans = l = 0; while(end &lt; len) &#123; char tmp = s[end]; for(index = start; index &lt; end; index++) &#123; if(tmp == s[index]) &#123; start = index + 1; l = end - start; break; &#125; &#125; end++; l++; ans = max(ans, l); &#125; return ans; &#125;&#125;; ä»”ç»†åˆ†æžä¸€ä¸‹ï¼Œå¥½åƒè·Ÿä¸Šé¢çš„æš´åŠ›è§£æ³•æ˜¯ä¸€æ ·çš„ï¼Ÿå®žé™…ä¸Šåº”è¯¥æ˜¯ä¸ä¸€æ ·çš„ï¼Œå› ä¸ºä¸Šé¢å†™çš„æš´åŠ›è§£æ³•é‡Œé¢æœ‰å¾ˆå¤šæ‹·è´å­—ç¬¦ã€åˆ¤æ–­å­—ç¬¦æ˜¯å¦é‡å¤çš„æ“ä½œï¼Œä½†è¿™é‡Œå¹¶æ²¡æœ‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¿™æ®µä»£ç åœ¨åˆ¤æ–­å­—ç¬¦æ˜¯å¦é‡å¤çš„è¿‡ç¨‹ä¸­ï¼Œå…¶å®žå°±å·²ç»å®Œæˆäº†å¯¹å­—ç¬¦çš„æ‹·è´ï¼Ÿ 567. Permutation in StringAnalysisè™½ç„¶ç†è§£äº†é¢˜æ„ï¼Œä½†æ˜¯å¥½åƒæ²¡æœ‰æ€è·¯ðŸ™ƒï¼Œé™·åœ¨å¦‚ä½•æ±‚å­—ç¬¦ä¸²å…¨æŽ’çš„æ³¥æ·–ä¸­äº†ã€‚ Codemethod 1è¦ç”¨æ»‘åŠ¨çª—å£æ¥è§£é¢˜ï¼Œæœ‰ä¸€ä¸ªä¿¡æ¯å¿…é¡»è¦å¾—åˆ°ï¼Œé‚£å°±æ˜¯ï¼šå½“ä¸¤ä¸ªå­—ç¬¦ä¸²çš„æ¯ä¸ªå­—ç¬¦çš„ä¸ªæ•°éƒ½ç›¸ç­‰æ—¶ï¼Œä¸€ä¸ªå­—ç¬¦ä¸²æ‰æ˜¯å¦ä¸€ä¸ªå­—ç¬¦ä¸²çš„æŽ’åˆ—ã€‚è¿™æ ·ï¼Œé—®é¢˜å°±è½¬åŒ–æˆäº†åˆ¤æ–­ s2 æ˜¯å¦æœ‰å­ä¸²ä¸Ž s1 çš„å­—ç¬¦ä¸ªæ•°ç›¸ç­‰ï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ä¸¤ä¸ªæ•°ç»„æ¥ç»Ÿè®¡å­—ç¬¦ä¸ªæ•°äº†ã€‚PSï¼šæ²¡æƒ³åˆ° vector å¯ä»¥ç›´æŽ¥è¿›è¡Œæ¯”è¾ƒ...1234567891011121314151617181920/* method 1: sliding window */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt1(26), cnt2(26); for(int i = 0; i &lt; n; i++) &#123; cnt1[s1[i] - 'a']++; cnt2[s2[i] - 'a']++; &#125; if(cnt1 == cnt2) return true; for(int i = n; i &lt; m; i++) &#123; ++cnt2[s2[i] - 'a']; --cnt2[s2[i - n] - 'a']; if(cnt1 == cnt2) return true; &#125; return false; &#125;&#125;; method 2å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜ä¹Ÿå¯ä»¥åªç”¨ä¸€ä¸ª vectorï¼Œä½†æ˜¯éœ€è¦ä¸€ä¸ªå˜é‡ diff æ¥ä¿å­˜å½“å‰å­ä¸²æ˜¯å¦ä¸Ž s1 å­˜åœ¨å­—ç¬¦ä¸ªæ•°ä¸ç›¸ç­‰çš„å­—ç¬¦ä¸ªæ•°ã€‚ä¸è¿‡ï¼Œä¸€æ—¶åŠä¼šï¼Œå¥½åƒè¿˜æ˜¯çœ‹ä¸æ˜Žç™½ã€‚123456789101112131415161718192021222324252627282930/* method 2: just use one vector */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; n; i++) &#123; --cnt[s1[i] - 'a']; ++cnt[s2[i] - 'a']; &#125; int diff = 0; for(int c: cnt) &#123; if(c != 0) diff++; &#125; if(diff == 0) return true; for(int i = n; i &lt; m; i++) &#123; int x = s2[i] - 'a', y = s2[i - n] - 'a'; if(x == y) continue; if(cnt[x] == 0) diff++; cnt[x]++; if(cnt[x] == 0) diff--; if(cnt[y] == 0) diff++; cnt[y]--; if(cnt[y] == 0) diff--; if(diff == 0) return true; &#125; return false; &#125;&#125;; method 3æ²¡æƒ³åˆ°è¿™é¢˜è¿˜èƒ½ç”¨åŒæŒ‡é’ˆåšï¼Œå¥½å§ï¼Œæ›´åŠ æœ‰ç‚¹çœ‹ä¸æ˜Žç™½äº†ã€‚1234567891011121314151617181920212223/* method 3: use tow pointers */class Solution &#123;public: bool checkInclusion(string s1, string s2) &#123; int n = s1.length(), m = s2.length(); if(n &gt; m) return false; vector&lt;int&gt; cnt(26); for(int i = 0; i &lt; n; i++) &#123; cnt[s1[i] - 'a']--; &#125; int left = 0; for(int right = 0; right &lt; m; right++) &#123; int x = s2[right] - 'a'; cnt[x]++; while(cnt[x] &gt; 0) &#123; cnt[s2[left] - 'a']--; left++; &#125; if(right - left + 1 == n) return true; &#125; return false; &#125;&#125;; Summaryä»Šå¤©çš„ä¸¤é“é¢˜ç¨å¾®å¤æ‚äº†ä¸€ç‚¹ï¼Œä¸æ˜¯é‚£ä¹ˆå¥½ç†è§£ï¼Œéœ€è¦å¤šåšå‡ æ¬¡ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day5]]></title>
    <url>%2F2022%2F03%2F27%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day5%2F</url>
    <content type="text"><![CDATA[è¿˜æ˜¯ two pointers å•Šã€‚ç»§ç»­ï¼Œç»§ç»­ã€‚ 876. Middle of the Linked ListAnalysisæ‰¾é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ï¼Œæ¯”è¾ƒå¸¸è§„çš„ä¸€é“é¢˜ã€‚ Codemethod 1å•æŒ‡é’ˆéœ€è¦éåŽ†ä¸¤æ¬¡é“¾è¡¨ï¼Œç•¥éº»çƒ¦ã€‚123456789101112131415class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *tmp = head; int cnt = 0; while(tmp) &#123; cnt++; tmp = tmp-&gt;next; &#125; tmp = head; for(int i = 0; i &lt; cnt / 2; i++) tmp = tmp-&gt;next; return tmp; &#125;&#125;; method 2åŒæŒ‡é’ˆåªç”¨éåŽ†ä¸€æ¬¡é“¾è¡¨ï¼Œä½†è¦æ³¨æ„åˆ¤ç©ºçš„æ¡ä»¶ã€‚123456789101112class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; ListNode *slow = head, *fast = head; while(fast != nullptr &amp;&amp; fast-&gt;next != nullptr) &#123; slow = slow-&gt;next; fast = fast-&gt;next-&gt;next; &#125; return slow; &#125;&#125;; method 3æ²¡æƒ³åˆ°å®˜æ–¹æä¾›äº†ä¸€ç§æ•°ç»„çš„é¢˜è§£ï¼Œä¸è¿‡ä¸Žå…¶è¯´æ˜¯æ•°ç»„ï¼Œä¸å¦‚è¯´æ˜¯é˜Ÿåˆ—ã€‚1234567891011class Solution &#123;public: ListNode* middleNode(ListNode* head) &#123; if(head == nullptr) return nullptr; vector&lt;ListNode*&gt; arr = &#123;head&#125;; while(arr.back()-&gt;next != nullptr) &#123; arr.push_back(arr.back()-&gt;next); &#125; return arr[arr.size() / 2]; &#125;&#125;; 19. Remove Nth Node From End of ListAnalysisåˆ é™¤é“¾è¡¨çš„çš„å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œè¿™ä¹Ÿæ˜¯ä¸ªå¾ˆå¸¸è§„çš„é¢˜ç›®ã€‚ Codemethod 1å‡è®¾æ€»ç»“ç‚¹æ•°æ˜¯ Nï¼Œåªç”¨ä¸€ä¸ªæŒ‡é’ˆæ—¶ï¼Œåˆ é™¤å€’æ•°ç¬¬ n ä¸ªç»“ç‚¹ï¼Œå°±æ˜¯åˆ é™¤æ­£æ•°ç¬¬ N - n ä¸ªç»“ç‚¹ï¼Œæ‰€ä»¥è¦è®¡ç®—ä¸€ä¸‹é“¾è¡¨çš„é•¿åº¦ï¼Œå¦å¤–è¿˜éœ€è¦è€ƒè™‘ä¸€ä¸‹åˆ é™¤çš„æ˜¯ä¸æ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹äº†ã€‚12345678910111213141516171819202122232425class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode* tmp = head; int cnt = 0; while(tmp != nullptr) &#123; cnt++; tmp = tmp-&gt;next; &#125; cnt -= n; tmp = head; ListNode* t; if(cnt == 0) &#123; t = head-&gt;next; head = t-&gt;next; &#125; else &#123; for(int i = 0; i &lt; cnt - 1; i++) tmp = tmp-&gt;next; t = tmp-&gt;next; tmp-&gt;next = t-&gt;next; &#125; delete(t); return head; &#125;&#125;; method 2ç”¨åŒæŒ‡é’ˆçš„è§£æ³•ï¼Œä¸Žå•æŒ‡é’ˆç±»ä¼¼ã€‚ä½†æ˜¯å¦‚æžœåœ¨ä¸€å¼€å§‹åŠ ä¸€ä¸ªå¤´ç»“ç‚¹è¯ï¼Œåˆ é™¤ç»“ç‚¹æ—¶ï¼Œå°±ä¸ç”¨å¤ªè€ƒè™‘æ˜¯å¦æ˜¯ç¬¬ä¸€ä¸ªç»“ç‚¹äº†ã€‚è¿™ç§åœ¨è¡¨å¤´åŠ çš„ç»“ç‚¹å«åšå“‘ç»“ç‚¹ã€‚1234567891011121314151617181920class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode *dummy = new ListNode(0, head); ListNode *first = head; ListNode *second = dummy; for(int i = 0; i &lt; n; i++) first = first-&gt;next; while(first != nullptr) &#123; first = first-&gt;next; second = second-&gt;next; &#125; first = second-&gt;next; second-&gt;next = first-&gt;next; delete(first); first = dummy-&gt;next; delete(dummy); return first; &#125;&#125;; method 3ç”¨æ ˆä¹Ÿå¯ä»¥åšã€‚1234567891011121314151617181920212223class Solution &#123;public: ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; ListNode *dummy = new ListNode(0, head); stack&lt;ListNode*&gt; st; ListNode *tmp = dummy; while(tmp != nullptr) &#123; st.push(tmp); tmp = tmp-&gt;next; &#125; for(int i = 0; i &lt; n; i++) &#123; st.pop(); &#125; ListNode *pre = st.top(); tmp = pre-&gt;next; pre-&gt;next = tmp-&gt;next; delete(tmp); pre = dummy-&gt;next; delete(dummy); return pre; &#125;&#125;; method 4çœ‹è¯„è®ºï¼Œå‘çŽ°ç«Ÿç„¶è¿˜èƒ½ç”¨é€’å½’åšðŸ˜‚ï¼Œé€’å½’è¾¹ç•Œæ˜¯éåŽ†åˆ°é“¾è¡¨è¡¨å°¾ï¼Œåˆ¤å®šæ¡ä»¶æ˜¯è®¿é—®çš„ç»“ç‚¹æ•°ç­‰äºŽè¦åˆ é™¤çš„ç»“ç‚¹ä½ç½®ã€‚ä¸å¾—ä¸è¯´ï¼Œç”¨é€’å½’æ¥è§£å†³è¿™ä¸ªé—®é¢˜å¾ˆå·§ã€‚1234567891011class Solution &#123;public: int cur = 0; ListNode* removeNthFromEnd(ListNode* head, int n) &#123; if(head == nullptr) return nullptr; head-&gt;next = removeNthFromEnd(head-&gt;next, n); cur++; if(n == cur) return head-&gt;next; return head; &#125;&#125;; Summaryä»Šå¤©æ˜¯ä¸¤ä¸ªå¾ˆå¸¸è§„çš„é¢˜ç›®ï¼Œä¸ç®—éš¾é¢˜ï¼Œè‡ªå·±æƒ³ä¹Ÿæ¯”è¾ƒå®¹æ˜“è§£å†³ï¼Œå°±æ˜¯å¯èƒ½æƒ³ä¸åˆ°å¤šç§æ–¹æ³•æ¥è§£å†³è¿™äº›é—®é¢˜ã€‚è¿˜æœ‰ä¸€ä¸ªå¾ˆå¥‡æ€ªçš„åœ°æ–¹ï¼ŒæŒ‰ç†è¯´ï¼Œå³ä¾¿åŠ äº†å“‘ç»“ç‚¹ï¼Œåœ¨ä¸æ”¹å˜ head çš„æƒ…å†µä¸‹ï¼Œç›´æŽ¥è¿”å›ž head åº”è¯¥æ˜¯ä¸ä¼šé”™è¯¯çš„ã€‚ä½†æ˜¯ï¼Œaddress sanitizer ä¼šæŠ¥é”™ï¼Œæ˜¯æœ‰æ½œåœ¨çš„å†…å­˜é”™è¯¯å—ï¼ŸðŸ¤”]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day4]]></title>
    <url>%2F2022%2F03%2F26%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day4%2F</url>
    <content type="text"><![CDATA[ä¸ºä»€ä¹ˆç¬¬å››å¤©çš„ä¸»é¢˜è¿˜æ˜¯ two pointersï¼Œæœ‰ç‚¹è…»äº†ã€‚è…»äº†ä¹Ÿè¿˜æ˜¯è¦è‚ðŸ˜ 344. Reverse StringAnalysisè¿™ä¸ªé¢˜å¯å¤ªå¸¸è§äº†ã€‚ Codemethod 11234567891011/* method 1: use a array to copy */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; vector&lt;char&gt; ret; for(int i = s.size() - 1; i &gt;= 0; i--) &#123; ret.push_back(s[i]); &#125; s = ret; &#125;&#125;; method 212345678910111213141516171819202122/* method 2: just exchange the elements */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int size = s.size(); for(int i = 0; i &lt; size / 2; i++) &#123; char tmp = s[size - i - 1]; s[size - i - 1] = s[i]; s[i] = tmp; &#125; &#125;&#125;;/* also can write like this */class Solution &#123;public: void reverseString(vector&lt;char&gt;&amp; s) &#123; int left = 0, right = s.size() - 1; while(left &lt; right) &#123; swap(s[left++], s[right--]); &#125; &#125;&#125;; 557. Reverse Words in a String IIIAnalysisè¿™ä¸ªé¢˜ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œè¦å°†æ¯ä¸ªå•è¯åè½¬ï¼Œä½†ä¸èƒ½æ”¹å˜å•è¯çš„ç»å¯¹ä½ç½®ã€‚åè½¬å•è¯çš„ä»»åŠ¡å°±äº¤ç»™ä¸Šä¸ªé¢˜å¾—åˆ°çš„ reverse å‡½æ•°äº†ï¼Œå‰©ä¸‹è¦è§£å†³çš„é—®é¢˜å°±æ˜¯å¦‚ä½•æ‰¾åˆ°å•è¯äº†ã€‚ä¸è¿‡ï¼Œä¸Žå…¶è¯´æ˜¯æ‰¾å•è¯ï¼Œä¸å¦‚è¯´æ˜¯æ‰¾ç©ºæ ¼ï¼Œåªè¦æ‰¾åˆ°ç¬¬ä¸€ä¸ªä¸æ˜¯ç©ºæ ¼çš„å­—ç¬¦ï¼Œç„¶åŽåœ¨æ‰¾åˆ°ä¸‹ä¸€ä¸ªç©ºæ ¼å­—ç¬¦ï¼Œé‚£ä¹ˆè¿™ä¸­é—´çš„å†…å®¹å°±æ˜¯å•è¯äº†ã€‚ Codereverse å‡½æ•°å°±ä¸å†™äº†ï¼Œç›´æŽ¥åƒçŽ°æˆçš„ã€‚1234567891011121314151617class Solution &#123;public: string reverseWords(string s) &#123; int len = s.length(); for(int i = 0; i &lt; len; i++) &#123; if(s[i] != ' ') &#123; int j; for(j = i + 1; j &lt; len; j++) &#123; if(s[j] == ' ') break; &#125; reverse(s.begin() + i, s.begin() + j); i = j; &#125; &#125; return s; &#125;&#125;; Summaryä»Šå¤©ç»™çš„æ˜¯ä¸¤é“ç®€å•é¢˜ï¼Œéƒ½æ¯”è¾ƒç®€å•ã€‚ç¬¬äºŒä¸ªé¢˜ç›®ç¨å¾®éš¾ä¸€ç‚¹ç‚¹ï¼Œè€Œä¸”ç¬¬ä¸€ä¸ªé¢˜å¾—åˆ°çš„ä¸œè¥¿å¯ä»¥ç›´æŽ¥åœ¨ç¬¬äºŒä¸ªé¢˜ç›®é‡Œé¢ç”¨åˆ°ï¼Œè¿™ç§å®‰æŽ’å¾ˆä¸é”™ã€‚å¦‚æžœç›´æŽ¥åšç¬¬äºŒä¸ªé¢˜ï¼Œè¯´ä¸å®šä¼šæƒ³åˆ°å…¶ä»–åœ°æ–¹åŽ»ã€‚PSï¼šç¬¬äºŒä¸ªé¢˜ï¼Œç”¨æ ˆä¹Ÿèƒ½åšã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_2022_æ˜¥_ä¹™çº§çœŸé¢˜è¯•æ°´]]></title>
    <url>%2F2022%2F03%2F25%2FPAT-2022-%E6%98%A5-%E4%B9%99%E7%BA%A7%E7%9C%9F%E9%A2%98%E8%AF%95%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[ä¹°äº†å¥— 2022 æ˜¥å­£çš„ PAT ä¹™çº§çœŸé¢˜åšç€çŽ©ã€‚ æœ¬æ¥æŠ±ç€åšç€çŽ©çš„æƒ³æ³•ï¼Œç»“æžœè¢«æ•™è‚²äº†ã€‚æ»¡åˆ† 100 åˆ†ï¼Œç»“æžœåªæ‹¿äº† 72 åˆ†ï¼Œå°´å°¬ã€‚ä¹™çº§é¢˜åº“æ˜¯ä¸Šä¸ªæ˜ŸæœŸåšå®Œäº†ï¼Ÿåæ­£æ˜¯è¿‡åŽ»æœ‰ä¸€æ®µæ—¶é—´äº†ï¼Œæœ€è¿‘éƒ½åœ¨ Leetcode ä¸Šæ‰“ç äº†ï¼ŒPAT çŽ©çš„å°‘ï¼Œå¥½åƒæœ‰ç‚¹æ‰‹ç”Ÿäº†ï¼Ÿè¯è¯´å›žæ¥ï¼Œè¿™è¿˜æ˜¯ç¬¬ä¸€æ¬¡åš PAT çš„è€ƒè¯•é¢˜ï¼Œä¸ç†Ÿæ‚‰ä¹Ÿæ˜¯æ­£å¸¸å§ï¼Œç»™è‡ªå·±ä¸€ç‚¹å®‰æ…°ã€‚åºŸè¯å°‘è¯´ï¼Œç›´æŽ¥çœ‹é¢˜ç›®å§ã€‚ 7-1 æš´åŠ›ç ´è§£æ—…è¡Œç®±ä¸Šçš„å¯†ç é”é€šå¸¸éƒ½åªæœ‰ 3 ä½æ•°å­—ï¼Œå¦‚æžœå¿˜äº†å¯†ç ï¼Œåªè¦æœ‰è¶³å¤Ÿçš„è€å¿ƒï¼Œå“ªæ€•ç”¨é€ä¸€æžšä¸¾çš„åŠžæ³•ï¼Œä¹Ÿå¯ä»¥æš´åŠ›ç ´è§£ã€‚å¦‚æžœè¿˜èƒ½éšçº¦è®°å¾—æ•°å­—çš„èŒƒå›´ï¼Œåˆ™å¯ä»¥å¤§å¤§é™ä½Žç ´è§£çš„å·¥ä½œé‡ã€‚ æœ¬é¢˜å°±è¯·ä½ æ ¹æ®ç”¨æˆ·è®°å¿†ä¸­çš„æ•°å­—èŒƒå›´ï¼Œåˆ—å‡ºæ‰€æœ‰å¯èƒ½çš„å¯†ç ã€‚ è¾“å…¥æ ¼å¼è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° nï¼ˆâ‰¤8ï¼‰ï¼ŒéšåŽä¸€è¡Œåˆ—å‡º n ä¸ª 0 - 9 èŒƒå›´å†…çš„æ•°å­—ï¼Œæ˜¯ç”¨æˆ·è®°å¿†ä¸­å¯èƒ½å±žäºŽå¯†ç çš„æ•°å­—ã€‚é¢˜ç›®ä¿è¯ n ä¸ªæ•°å­—æ²¡æœ‰é‡å¤ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼æŒ‰ç…§å¯†ç ç»„æˆçš„ 3 ä½æ•°ä»Žå°åˆ°å¤§çš„é¡ºåºï¼Œè¾“å‡ºè¿™ n ä¸ªæ•°å­—èƒ½ç»„æˆçš„æ‰€æœ‰å¯èƒ½çš„ 3 ä½æ•°å¯†ç ã€‚è¦æ±‚æ¯è¡Œè¾“å‡º 10 ä¸ªï¼ŒåŒè¡Œæ•°å­—ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚æ³¨æ„ï¼šå¦‚æžœæœ‰å‰å¯¼é›¶ï¼Œä¹Ÿä¸å¯å¿½ç•¥ã€‚ è¾“å…¥æ ·ä¾‹1235 2 8 è¾“å‡ºæ ·ä¾‹123222 225 228 252 255 258 282 285 288 522525 528 552 555 558 582 585 588 822 825828 852 855 858 882 885 888 Analysisè¿™ä¸ªé¢˜è¿·æƒ‘æ€§æŒºå¼ºçš„ï¼Œç¬¬ä¸€çœ¼çœ‹è¿‡åŽ»ï¼Œä»¥ä¸ºæ˜¯æ±‚ 3 ä¸ªæ•°å­—å…¨æŽ’åˆ—çš„é¢˜ç›®ã€‚å®žé™…ä¸Šä¹Ÿç¡®å®žæ˜¯è¿™æ ·çš„é¢˜ç›®ï¼Œä½†æ˜¯æ²¡æœ‰é‚£ä¹ˆç®€å•ã€‚å› ä¸ºæ•°å­—ä¸ªæ•°æ˜¯ä¸é™å®šçš„ï¼Œå¯èƒ½ä¼šç»™å°‘äºŽ 3 ä¸ªçš„æ•°å­—ï¼Œä¹Ÿå¯èƒ½ä¼šç»™å¤§äºŽ 3 ä¸ªçš„æ•°å­—ã€‚æ‰€ä»¥ï¼Œå¤§ä½“ä¸Šå°±æœ‰ 2 ç§æƒ…å†µï¼š n &gt;= 3ã€‚ n &lt; 3ã€‚ åœ¨è€ƒè¯•æ—¶é—´å†™è¿™ä¸ªé—®é¢˜çš„æ—¶å€™ï¼Œä¸€ç›´åœ¨çº ç»“æ€Žä¹ˆè¾“å‡ºï¼Œæ€Žä¹ˆèƒ½æžšä¸¾å‡ºæ‰€æœ‰çš„å¯èƒ½ã€‚ä¸€ä¼šè§‰å¾—ç›´æŽ¥è¾“å‡ºæ•°å­—æ–¹ä¾¿ï¼Œä¸€ä¼šåˆè§‰å¾—ç›´æŽ¥ç®—å‡ºæ¥ç”¨é›†åˆè‡ªåŠ¨æŽ’åºæ›´ç®€å•ã€‚ç»“æžœæœ€åŽè¿˜æ˜¯é€‰æ‹©äº†é›†åˆï¼Œå› ä¸ºé›†åˆæ—¢å¯ä»¥é¿å…é‡å¤é€‰å–ï¼Œåˆå¯ä»¥æŽ’åºã€‚é‚£ä¹ˆï¼ŒæŽ¥ä¸‹æ¥è¦è€ƒè™‘çš„é—®é¢˜å°±æ˜¯æŠŠæ‰€æœ‰å¯èƒ½çš„æ•°å­—ç®—å‡ºæ¥äº†ã€‚å› ä¸ºåªéœ€è¦ç»„æˆ 3 ä½æ•°ï¼Œæ‰€ä»¥æŒ‰ç…§ä¹‹å‰çš„åˆ†æžå°±å¯ä»¥çŸ¥é“ï¼š n &gt;= 3ï¼Œæ­¤æ—¶åªç”¨åˆ†åˆ«é€‰æ‹©æ•°å­—ä½œä¸ºç™¾ä½ã€åä½å’Œä¸ªä½å°±è¡Œäº†ï¼Œåè€Œæ¯”è¾ƒå®¹æ˜“å¤„ç†ã€‚ n = 2ï¼Œå› ä¸ºé™å®šäº†æœ€åŽå¾—åˆ°çš„ 3 ä½æ•°ä¸­å¿…é¡»è¦æœ‰ 2 ä¸ªæ•°å­—ï¼Œä»ŽæŽ’åˆ—çš„è§’åº¦æ¥è®²ï¼Œå°±æ˜¯å¾€ 2 ä¸ªæ•°å­—ç»„æˆçš„é˜Ÿåˆ—ä¸­æ’ç©ºï¼Œä½†æ˜¯è¿™ä¸¤ä¸ªæ•°å­—ä¹Ÿæ˜¯å¯ä»¥äº¤æ¢ä½ç½®çš„ï¼Œæ‰€ä»¥å°±æ˜¯ 2 * 3 = 6ï¼Œä¸€å…± 6 ç§å¯èƒ½çš„ç»„åˆæ–¹å¼ã€‚ n = 1ï¼Œä¸Ž n = 2 æ—¶åŒç†ï¼Œä½†æ­¤æ—¶åªç”¨å°†å”¯ä¸€çš„æ•°å­—åˆ†åˆ«å½“ä½œç™¾ä½ã€åä½å’Œä¸ªä½ï¼Œè®¡ç®—ä¸€æ¬¡å°±è¡Œäº†ã€‚ n = 0ï¼Œè¿™ä¸ªæƒ…å†µï¼Œåšé¢˜çš„æ—¶å€™å¿˜äº†...å®žé™…ä¸Šå°± 000-999 è¿™ 1000 ä¸ªæ•°ã€‚ ä»¥ä¸Šå°±æ˜¯åšé¢˜æ—¶çš„åˆ†æžäº†ï¼Œæµªè´¹äº†æŒºå¤šæ—¶é—´çš„ã€‚ Codeè¿™æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼ŒçœŸä¹±å•Šã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;set&lt;int&gt; password;const int maxn = 10 + 5;int arr[maxn] = &#123;0&#125;, n;int main() &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; int tmp; if(n == 1) &#123; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = arr[0] * 100 + i * 10 + j; password.insert(tmp); &#125; &#125; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = i * 100 + arr[0] * 10 + j; password.insert(tmp); &#125; &#125; for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; tmp = i * 100 + j * 10 + arr[0]; password.insert(tmp); &#125; &#125; &#125; else if(n == 2) &#123; for(int i = 0; i &lt; 10; i++) &#123; tmp = i * 100 + arr[0] * 10 + arr[1]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[0] * 100 + i * 10 + arr[1]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[0] * 100 + arr[1] * 10 + i; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = i * 100 + arr[1] * 10 + arr[0]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[1] * 100 + i * 10 + arr[0]; password.insert(tmp); &#125; for(int i = 0; i &lt; 10; i++) &#123; tmp = arr[1] * 100 + arr[0] * 10 + i; password.insert(tmp); &#125; &#125; else &#123; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; n; j++) &#123; for(int k = 0; k &lt; n; k++) &#123; tmp = arr[i] * 100 + arr[j] * 10 + arr[k]; password.insert(tmp); &#125; &#125; &#125; &#125;// cout &lt;&lt; password.size() &lt;&lt; endl; set&lt;int&gt;::iterator it = password.begin(); int cnt = 0; for(; it != password.end(); it++) &#123; printf("%03d", *it); cnt++; if(cnt == password.size()) cout &lt;&lt; endl; else if(cnt % 10) cout &lt;&lt; ' '; else cout &lt;&lt; endl; &#125; return 0;&#125; ä¸Šé¢çš„ä»£ç ï¼Œæäº¤ä¸ŠåŽ»ä¹‹åŽï¼Œåªæ‹¿äº† 12 åˆ†ï¼Œè¿˜æœ‰ 2 ä¸ªæµ‹è¯•ç‚¹æ²¡è¿‡ã€‚çŽ°åœ¨æƒ³æƒ³ï¼Œå¯èƒ½æœ‰ä¸ªæµ‹è¯•ç‚¹æ˜¯ n = 0 çš„æƒ…å†µå§ï¼Œé‚£å¦å¤–ä¸€ä¸ªæµ‹è¯•ç‚¹å‘¢ï¼Ÿ 7-2 å­¦éœ¸æ‰€è°“â€œå­¦éœ¸â€ï¼Œå°±æ˜¯æ¯ä¸ªå­¦æœŸé€‰è¯¾å­¦æ—¶æœ€é•¿çš„äººã€‚æœ¬é¢˜å°±ç»™ä½ æ‰€æœ‰è¯¾ç¨‹çš„å­¦æ—¶å’Œé€‰è¯¾åå•ï¼Œè¯·ä½ æ‰¾å‡ºé‚£ä¸ªå­¦éœ¸ã€‚å¦‚æžœæœ‰æ€»å­¦æ—¶å¹¶åˆ—æœ€å¤šçš„æƒ…å†µï¼Œåˆ™é€‰é‚£ä¸ªé€‰è¯¾é—¨æ•°æœ€å¤šçš„ã€‚å¦‚æžœè¿˜æœ‰å¹¶åˆ—ï¼Œå°±æŒ‰å­¦å·å‡åºè¾“å‡ºä»–ä»¬å§~ è¾“å…¥æ ¼å¼è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°ï¼šNï¼ˆâ‰¤5000ï¼‰ä¸ºè¯¾ç¨‹æ€»æ•°ã€‚éšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€é—¨è¯¾çš„é€‰è¯¾ä¿¡æ¯ï¼Œæ ¼å¼å¦‚ä¸‹1å­¦æ—¶ äººæ•° é€‰è¯¾äºº1 é€‰è¯¾äºº2 â€¦â€¦ å…¶ä¸­ å­¦æ—¶ æ˜¯è¯¥è¯¾ç¨‹çš„å­¦æ—¶ï¼Œä¸€ä¸ªä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•°ï¼›äººæ•° æ˜¯è¯¥è¯¾ç¨‹çš„é€‰è¯¾äººæ•°ï¼Œä¸ºä¸è¶…è¿‡ 200 çš„éžè´Ÿæ•´æ•°ï¼›é€‰è¯¾äººi æ˜¯ç¬¬ i ä¸ªé€‰è¯¾å­¦ç”Ÿçš„ç¼–å·ï¼Œæ˜¯ä¸€ä¸ª 5 ä½æ•°å­—ã€‚é¢˜ç›®ä¿è¯ä¸åŒå­¦ç”Ÿå¯¹åº”çš„ç¼–å·ä¸åŒï¼Œä¸”åŒä¸€é—¨è¯¾ç¨‹çš„é€‰è¯¾åå•ä¸­æ²¡æœ‰é‡å¤çš„å­¦ç”Ÿã€‚ è¾“å‡ºæ ¼å¼é¦–å…ˆåœ¨ä¸€è¡Œä¸­è¾“å‡ºå­¦éœ¸ï¼ˆä»¬ï¼‰çš„é€‰è¯¾æ€»å­¦æ—¶å’Œé—¨æ•°ï¼ŒéšåŽåœ¨ä¸‹ä¸€è¡Œä¸­æŒ‰ç…§ç¼–å·å‡åºè¾“å‡ºæ‰€æœ‰æ»¡è¶³é¢˜é¢æè¿°çš„å­¦éœ¸ã€‚ç¼–å·é—´ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚é¢˜ç›®ä¿è¯è‡³å°‘å­˜åœ¨ä¸€ä½å­¦éœ¸ã€‚ è¾“å…¥æ ·ä¾‹123456532 5 10001 00003 91032 02387 1099364 2 36775 9103216 3 10993 02387 3677516 4 02387 56772 10993 0000332 3 10993 02387 88024 è¾“å‡ºæ ·ä¾‹1296 402387 10993 Analysisç¬¬äºŒä¸ªé¢˜ç›®æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œä½†æ˜¯ä¹Ÿæœ‰å‘ã€‚è€Œä¸”ï¼Œç»™çš„ä¿¡æ¯å¾ˆå¤šï¼Œéœ€è¦ä»”ç»†è¯»é¢˜æ‰èƒ½ç¡®å®šé‚£äº›ä¿¡æ¯æ˜¯ç”¨æ¥å¾—åˆ°ç»“æžœçš„ã€‚ä¸€å¼€å§‹æœ¬æ¥æ˜¯æƒ³ç”¨ map æ¥åšçš„ï¼ŒåŽé¢çœ‹åˆ°å­¦ç”Ÿç¼–å·åæ­£æ˜¯ä¸ª 5 ä½æ•°ï¼Œæˆ‘ç›´æŽ¥æ•£åˆ—å¾—äº†ã€‚è¿™ä¸ªæ€è·¯ä¹Ÿæ²¡é”™ï¼Œä½†æ˜¯å½“æ—¶åšçš„æ—¶å€™æ²¡æœ‰è€ƒè™‘åˆ°è¾“å‡ºçš„é™åˆ¶ï¼Œé¢˜ç›®å·²ç»è¯´äº†æœ‰å¹¶åˆ—çš„æƒ…å†µäº†ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹æœ€åŽçš„ç»“æžœè¿›è¡ŒæŽ’åºã€‚ä½†æ˜¯ï¼Œåšé¢˜çš„æ—¶å€™ï¼Œæœ‰ç‚¹æ–¹ï¼Œå®Œå…¨æ²¡æœ‰æƒ³åˆ°è¿™é‡Œæ¥ã€‚å…¶å®žå°±æ˜¯å¤ªæ–¹äº†ï¼Œæžå¾—é¢˜ç›®æ²¡æœ‰è¯»æ¸…æ¥šï¼Œå°±å¼€å§‹å†™äº†ã€‚ Codeè¿™æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œå› ä¸ºæ²¡æœ‰è€ƒè™‘åˆ°å¹¶åˆ—çš„æƒ…å†µï¼Œæ‰€ä»¥ä¹Ÿåªæ‹¿äº† 14 åˆ†...123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int studytimes[maxn] = &#123;0&#125;, amount[maxn] = &#123;0&#125;;int main() &#123; int n, time, peos, id; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; time &gt;&gt; peos; while(peos--) &#123; cin &gt;&gt; id; studytimes[id] += time; amount[id]++; &#125; &#125; int max_time = studytimes[0], max_amount = amount[0]; for(int i = 1; i &lt; maxn; i++) &#123; if(max_time &lt; studytimes[i]) max_time = studytimes[i]; if(max_amount &lt; amount[i]) max_amount = amount[i]; &#125; cout &lt;&lt; max_time &lt;&lt; ' ' &lt;&lt; max_amount &lt;&lt; endl; bool flag = true; for(int i = 1; i &lt; maxn; i++) &#123; if(max_time == studytimes[i] &amp;&amp; max_amount == amount[i]) &#123; if(flag) &#123; printf("%05d", i); flag = false; &#125; else printf(" %05d", i); &#125; &#125; return 0;&#125; çŽ°åœ¨å†çœ‹ï¼ŒçœŸæ˜¯ä¸åº”è¯¥ã€‚ 7-3 æŽ’è¯¾æŽ’è¯¾æ˜¯ä¸ªä¸–ç•Œéš¾é¢˜ã€‚ å‡è®¾æ¯ä¸ªå­¦æœŸæœ‰ N ä¸ªæ•™å­¦ç­çš„è¯¾éœ€è¦æŽ’ï¼Œæ¯å‘¨æœ‰ M ä¸ªæ—¶é—´æ®µå¯ä»¥ä¸Šè¯¾ï¼Œå…¨æ ¡å…±æœ‰ K é—´æ•™å®¤ï¼Œä¸åŒæŽ’è¯¾ç»„åˆæ–¹æ¡ˆçš„ä¸ªæ•°å¯èƒ½ä¼šè¶…è¿‡æ•´ä¸ªå®‡å®™çš„è´¨å­æ•°ã€‚æ›´ä¸ºå¤æ‚çš„æ˜¯ï¼Œæ¯ä¸ªå­¦æœŸæŽ’è¯¾å‰ï¼Œå­¦æ ¡è¿˜ä¼šæ”¶é›†æ¯ä¸ªæ•™å­¦ç­ä»»è¯¾è€å¸ˆä¸èƒ½ä¸Šè¯¾çš„æ—¶é—´æ®µï¼Œè¿˜è¦ä¿è¯æŽ’è¯¾ä¸ä¸Žè€å¸ˆçš„æ—¶é—´å®‰æŽ’èµ·å†²çªã€‚ å½“ç„¶ï¼Œæœ¬é¢˜ä¸æ˜¯è¦æ±‚ä½ å®žçŽ°ä¸€ä¸ªæŽ’è¯¾ç®—æ³•ï¼Œè€Œæ˜¯è¦æ±‚ä½ å®žçŽ°ä¸€ä¸ªæŽ’è¯¾æ–¹æ¡ˆæ£€æŸ¥ç®—æ³•ã€‚å³ç»™å®šæ¯ä¸ªæ•™å­¦ç­ä¸Šè¯¾çš„æ—¶é—´å’Œåœ°ç‚¹ï¼Œä½ éœ€è¦æ£€æŸ¥è¿™ä¸ªæ—¶é—´æ®µå’Œåœ°ç‚¹æ˜¯å¦åªæœ‰è¿™ä¸€ä¸ªç­ä¸Šè¯¾ï¼Œå¹¶ä¸”è¿™ä¸ªä¸Šè¯¾æ—¶é—´ä¸ä¼šæ­£å¥½æ˜¯ä»»è¯¾è€å¸ˆä¸èƒ½ä¸Šè¯¾çš„æ—¶é—´ã€‚ è¾“å…¥æ ¼å¼è¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸‰ä¸ªæ­£æ•´æ•°ï¼š$Nï¼ˆâ‰¤10^4ï¼‰$ä¸ºæ•™å­¦ç­æ€»æ•°ï¼›$Mï¼ˆâ‰¤40ï¼‰$ä¸ºä¸€å‘¨å†…ä¸Šè¯¾æ—¶é—´æ®µçš„ä¸ªæ•°ï¼›$Kï¼ˆâ‰¤10^3ï¼‰$ä¸ºæ•™å®¤æ€»æ•°ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ä»¥ä¸‹æˆ‘ä»¬å°±å°†æ•™å­¦ç­ã€æ—¶é—´æ®µã€æ•™å®¤åˆ†åˆ«ä»Ž 1 å¼€å§‹é¡ºåºç¼–å·ã€‚ éšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªæ•™å­¦ç­çš„ä»»è¯¾æ•™å¸ˆæ—¶é—´é™åˆ¶å’ŒæŽ’è¯¾çš„ä¿¡æ¯ã€‚æ ¼å¼å¦‚ä¸‹ï¼š1L T[1] ... T[L] Time Room å…¶ä¸­Læ˜¯ä»»è¯¾æ•™å¸ˆçš„æ—¶é—´é™åˆ¶æ•°é‡ï¼ˆ&lt; Mï¼‰ï¼ŒåŽé¢ç»™å‡ºLä¸ªè¯¥è€å¸ˆä¸èƒ½ä¸Šè¯¾çš„æ—¶é—´æ®µç¼–å·ï¼›Timeæ˜¯è¯¥æ•™å­¦ç­å®‰æŽ’çš„ä¸Šè¯¾æ—¶é—´æ®µç¼–å·ï¼ŒRoom æ˜¯ä¸Šè¯¾æ•™å®¤ç¼–å·ã€‚æˆ‘ä»¬å‡è®¾æ¯ä¸ªæ•™å­¦ç­çš„ä»»è¯¾è€å¸ˆéƒ½ä¸ä¸€æ ·ã€‚ è¾“å‡ºæ ¼å¼å¦‚æžœç»™å®šçš„è¯¾è¡¨å®‰æŽ’æ˜¯å®Œå…¨æ— å†²çªçš„ï¼Œåˆ™åœ¨ä¸€è¡Œå†…è¾“å‡ºï¼šPerfect Arrangement for N classes!å…¶ä¸­Næ˜¯æ•™å­¦ç­æ•°é‡ã€‚ å¦‚æžœè¯¾è¡¨æœ‰å†²çªï¼Œåˆ™éœ€è¦è¾“å‡ºå†²çªåŽŸå› ã€‚æˆ‘ä»¬é¦–å…ˆå‡è®¾æ•™å­¦ç­æ˜¯æŒ‰ç…§ç¼–å·é€’å¢žåºè¿›è¡ŒæŽ’è¯¾çš„ï¼Œæ•™å­¦èµ„æºå…ˆåˆ°å…ˆå¾—ã€‚å¦‚æžœåŽé¢å®‰æŽ’çš„æ•™å­¦ç­ A è·Ÿå‰é¢çš„æ•™å­¦ç­ B æŽ’åœ¨äº†åŒä¸€ä¸ªæ—¶é—´å’Œåœ°ç‚¹ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡ºERROR: Conflict between A and B.ï¼Œæ­¤æ—¶æ•™å­¦ç­ A æš‚ä¸å®‰æŽ’ã€‚å¦‚æžœæ•™å­¦ç­ A çš„ä¸Šè¯¾æ—¶é—´è·Ÿä»»è¯¾æ•™å¸ˆæœ‰å†²çªï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡ºERROR: Conflict with instructor for A.ã€‚å½“ä¸¤ç§å†²çªéƒ½å‘ç”Ÿæ—¶ï¼Œåˆ†ä¸¤è¡Œè¾“å‡ºï¼Œå…ˆè¾“å‡ºæ•™å­¦ç­å†²çªçš„ä¿¡æ¯ã€‚ è¾“å…¥æ ·ä¾‹ 11234565 20 102 1 5 10 70 10 35 2 4 6 8 10 3 33 10 3 18 15 11 20 19 10 è¾“å‡ºæ ·ä¾‹ 11Perfect Arrangement for 5 classes! è¾“å…¥æ ·ä¾‹ 21234565 20 102 1 5 10 70 10 75 2 4 6 8 10 6 33 10 3 18 6 32 20 10 10 7 è¾“å‡ºæ ·ä¾‹ 21234ERROR: Conflict between 2 and 1.ERROR: Conflict with instructor for 3.ERROR: Conflict between 5 and 1.ERROR: Conflict with instructor for 5. Analysisè¿™ä¸ªé¢˜è·Ÿç¬¬äºŒé“é¢˜æ˜¯ä¸€ä¸ªç±»åž‹çš„é¢˜ç›®ï¼Œéƒ½æ˜¯ä¿¡æ¯ç»™çš„å¾ˆå¤šï¼Œéœ€è¦æ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œè¿ç”¨ä¸åŒçš„ä¿¡æ¯ã€‚å”¯ä¸€çš„å‘ç‚¹ï¼Œå°±æ˜¯è¦è¯»æ¸…æ¥šé¢˜ç›®ï¼Œä½†é—æ†¾çš„æ˜¯ï¼Œè¿™ä¸Žæˆ‘æ— å…³... Codeè¿™æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œæäº¤åŽæ˜¯ 15 åˆ†...1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;const int maxn = 10000 + 5;struct Class &#123; int timelimit[45]; int time, room;&#125; cla[maxn];int main() &#123; int n, m, k, l, time_t, room_t; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); scanf("%d", &amp;l); for(int j = 0; j &lt; l; j++) &#123; scanf("%d", &amp;cla[1].timelimit[j]); &#125; scanf("%d %d", &amp;cla[1].time, &amp;cla[1].room); bool flag1 = true; for(int i = 2; i &lt;= n; i++) &#123; scanf("%d", &amp;l); for(int j = 0; j &lt; l; j++) &#123; scanf("%d", &amp;cla[i].timelimit[j]); &#125; scanf("%d %d", &amp;cla[i].time, &amp;cla[i].room); for(int j = 1; j &lt; i; j++) &#123; if(cla[i].time == cla[j].time &amp;&amp; cla[i].room == cla[j].room) &#123; printf("ERROR: Conflict between %d and %d.\n", i, j); flag1 = false; break; &#125; &#125; for(int j = 0; j &lt; l; j++) &#123; if(cla[i].time == cla[i].timelimit[j]) &#123; printf("ERROR: Conflict with instructor for %d.\n", i); cla[i].time = -1; flag1 = false; break; &#125; &#125; &#125; if(flag1) printf("Perfect Arrangement for %d classes!\n", n); return 0;&#125; 7-4 ç®€æ˜“æµ‹è°Žæµ‹è°Žé€šå¸¸ä½¿ç”¨ä¸€å¥—å‡†å¤‡å¥½çš„é—®é¢˜æé—®è¢«æµ‹è¯•è€…ï¼Œé€šè¿‡åˆ†æžè¢«æµ‹è¯•è€…çš„ååº”å¾—åˆ°ç»“æžœã€‚æ¯”è¾ƒé«˜çº§çš„æµ‹è°ŽæŠ€æœ¯ä¼šä½¿ç”¨æµ‹è°Žä»ªï¼Œç›‘è§†è¢«æµ‹è¯•è€…çš„ç”Ÿç†æ´»åŠ¨çŠ¶å†µã€‚æˆ‘ä»¬è¿™é‡Œçš„ç®€æ˜“æµ‹è°Žåˆ™æ˜¯é€šè¿‡å¯¹é—®é¢˜ç­”æ¡ˆçš„ç‰¹å¾åˆ†æžæ¥åšå‡ºåˆ¤æ–­ã€‚ é¦–å…ˆæˆ‘ä»¬è¦æ±‚è¢«æµ‹è¯•è€…åšå®Œ N é“å•é€‰é¢˜ï¼Œæ¯é“é¢˜æœ‰ 8 ä¸ªé€‰é¡¹ï¼Œç”±å°å†™è‹±æ–‡å­—æ¯a-hæ¥è¡¨ç¤ºã€‚è¿™æ ·å°±å¾—åˆ°ä¸€ä¸ªé•¿åº¦ä¸º N çš„ã€ç”±a-hå°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„å­—ç¬¦ä¸²ã€‚å¯¹æ¯ä¸ªå­—ç¬¦ä¸²æ‰“åˆ†ï¼Œå¾—åˆ†è¶…è¿‡æŸä¸ªç»™å®šé˜ˆå€¼ T çš„å°±åˆ¤æ–­ä¸ºâ€œç–‘ä¼¼è¯´è°Žè€…â€ã€‚æ‰“åˆ†åŽŸåˆ™å¦‚ä¸‹ï¼š ä»¥få¼€å¤´çš„ï¼Œå¾—åˆ† âˆ’2ï¼› ä»¥aç»“å°¾çš„ï¼Œå¾—åˆ† âˆ’1ï¼› å¯¹äºŽæ¯ä¸€æ®µé•¿åº¦å¤§äºŽ 5 çš„è¿žç»­é€‰æ‹©åŒä¸€å­—æ¯çš„æœ€é•¿å­ä¸²ï¼Œå¾—åˆ† +3ï¼› aåŽé¢ç´§è·Ÿeæˆ–hçš„ï¼Œå¾—åˆ† âˆ’4ï¼› å¯¹äºŽæ¯ä¸€æ®µé•¿åº¦å¤§äºŽ 3 çš„è¿žç»­é€‰æ‹©ç›¸é‚»é€’å¢žå­—æ¯çš„æœ€é•¿å­ä¸²ï¼ˆä¾‹å¦‚abcdæˆ–defghï¼‰ï¼Œå¾—åˆ† +5ã€‚æœ¬é¢˜å°±è¯·ä½ å†™ç¨‹åºå®Œæˆå¯¹è¢«æµ‹è¯•è€…çš„åˆ¤æ–­ã€‚ è¾“å…¥æ ¼å¼è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º 3 ä¸ªæ­£æ•´æ•°ï¼šNï¼ˆ6â‰¤Nâ‰¤100ï¼‰ä¸ºæµ‹è°Žé—®å·çš„é¢˜ç›®æ•°ï¼›T ï¼ˆâ‰¤100ï¼‰ä¸ºåˆ¤æ–­è¯´è°Žçš„å¾—åˆ†é˜ˆå€¼ï¼›Kï¼ˆâ‰¤100ï¼‰ä¸ºè¢«æµ‹è¯•è€…äººæ•°ã€‚ éšåŽ K è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªè¢«æµ‹è¯•è€…çš„ç­”æ¡ˆå­—ç¬¦ä¸²ã€‚ è¾“å‡ºæ ¼å¼å¯¹æ¯ä¸ªè¢«æµ‹è¯•è€…çš„ç­”æ¡ˆï¼Œåœ¨ä¸€è¡Œä¸­è¾“å‡ºå…¶å¾—åˆ†ã€‚å¦‚æžœåˆ†æ•°è¶…è¿‡é˜ˆå€¼ï¼Œåˆ™åœ¨å…¶åˆ†æ•°åŽè¾“å‡º!!!ã€‚ è¾“å…¥æ ·ä¾‹123456712 1 6fghaebcdedddahhhhhhgbaaacdeffffffffffffffghecaaafeeeeeeeegcbaaaaaabbbbbb è¾“å‡ºæ ·ä¾‹123456-1-28!!!-316!!! Analysisè¿™ä¸ªé¢˜æ„Ÿè§‰æ˜¯è¿™å¥—å·å­æœ€å¸¸è§„çš„ä¸€é“é¢˜äº†ï¼Œå› ä¸ºå¾ˆæ˜Žæ˜¾å°±æ˜¯å­—ç¬¦ä¸²å¤„ç†çš„é¢˜ç›®ã€‚ä½†è¿™ä¸ªé¢˜ç›®çš„å‘ç‚¹åœ¨äºŽï¼Œè¦åˆ†å¼€è®¨è®ºçš„æƒ…å†µå¤ªå¤šäº†ï¼Œæ¯”è¾ƒè´¹æ—¶é—´ã€‚ç‰¹åˆ«æ˜¯è¿žç»­é•¿åº¦å¤§äºŽ 5 çš„æƒ…å†µå’Œè¿žç»­ç›¸é‚»é€’å¢žå­—æ¯çš„æƒ…å†µï¼Œéœ€è¦ä»”ç»†æ¢³ç†ä¸€ä¸‹ä¸‹æ ‡çš„å¯¹åº”å…³ç³»ï¼Œå®žé™…ä¸Šï¼Œå¹¶ä¸æ˜¯ä¸€ä¸ªéš¾é¢˜ã€‚ Codeè¿™æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œæäº¤åŽæ˜¯ 18 åˆ†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;const int maxn = 100 + 5;char str[maxn];int main() &#123; int n, T, t, k; scanf("%d %d %d", &amp;n, &amp;T, &amp;k); while(k--) &#123; scanf("%s", str); t = 0; if(str[0] == 'f') t -= 2; if(str[n - 1] == 'a') t -= 1; for(int i = 0; i &lt; n; i++) &#123; if(str[i] == 'a') &#123; if(str[i + 1] == 'e' || str[i + 1] == 'h') &#123; t -= 4; i = i + 1; &#125; &#125; if(str[i] == str[i + 1]) &#123; int j; for(j = i + 2; j &lt; n; j++) &#123; if(str[i] != str[j]) break; &#125; if(j - i &gt; 5) &#123; t += 3; i = j; i--; &#125; &#125; if(str[i + 1] == str[i] + 1) &#123; int j; for(j = i; j &lt; n; j++) &#123; if(str[j + 1] != str[j] + 1) break; &#125; if(j - i &gt;= 3) &#123; t += 5; i = j; i--; &#125; &#125; &#125; printf("%d", t); if(t &gt; T) printf("!!!"); printf("\n"); &#125; return 0;&#125; 7-5 å‰Kå¤§æ•°æœ¬é¢˜ç›®æ ‡éžå¸¸ç®€å•ï¼šç»™å®š N ä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå‰ K ä¸ªæœ€å¤§çš„æ•°ï¼Œå¹¶æŒ‰é€’å‡åºè¾“å‡ºã€‚ è¾“å…¥æ ¼å¼è¾“å…¥ç¬¬ä¸€è¡Œç»™å‡º 2 ä¸ªæ­£æ•´æ•°$N (â‰¤10^6) $å’Œ $K (â‰¤5)$ã€‚éšåŽä¸€è¡Œç»™å‡º N ä¸ªæ•´æ•°é”®å€¼ï¼ŒèŒƒå›´åœ¨åŒºé—´$[âˆ’2^{30} ,2^{30}]$å†…ï¼Œä»¥ç©ºæ ¼åˆ†éš”ã€‚ è¾“å‡ºæ ¼å¼æŒ‰é€’å‡åºåœ¨ä¸€è¡Œä¸­è¾“å‡ºå‰ K ä¸ªæœ€å¤§çš„æ•°ã€‚ æ³¨æ„ï¼šä¸€è¡Œä¸­è¾“å‡ºçš„æ•°å­—é—´é¡»ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ è¾“å…¥æ ·ä¾‹ 11210 440 25 60 -15 30 -21 80 -1 -5 27 è¾“å‡ºæ ·ä¾‹ 1180 60 40 30 è¾“å…¥æ ·ä¾‹ 2124 523 -17 99 1 è¾“å‡ºæ ·ä¾‹ 2199 23 1 -17 Analysisè¿™ä¸ªé¢˜çš„å½¢å¼å€’æ˜¯å¾ˆç®€å•ï¼Œä¸è¿‡æƒ³æ‹¿æ»¡åˆ†ä¹Ÿä¸æ˜¯é‚£ä¹ˆå®¹æ˜“ã€‚å› ä¸ºé¢˜ç›®æ²¡è¯´ä¸ä¼šå‡ºçŽ°é‡å¤å…ƒç´ ï¼Œæ‰€ä»¥ï¼Œå¾ˆæ˜Žæ˜¾çš„ä¸€ä¸ªå‘ç‚¹å°±æ˜¯é‡å¤å…ƒç´ ã€‚ä¸€å¼€å§‹æƒ³åˆ°çš„åšæ³•æ˜¯å…ˆæŽ’åºï¼Œç„¶åŽç”¨ hashmap æŠŠè¾“å‡ºè¿‡çš„å…ƒç´ æ ‡è®°äº†ï¼Œç»“æžœæäº¤ä¹‹åŽç›´æŽ¥å°± Time Limited Exceeded è·Ÿ Memory Limited Exceeded äº†ã€‚ç„¶åŽå°±ç›´æŽ¥è·³è¿‡åšå‰é¢çš„é¢˜åŽ»äº†ï¼Œå½“æ—¶è¿™é“é¢˜æ˜¯ç¬¬ä¸‰ä¸ªåšçš„ã€‚ Codeè¿™æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œæäº¤ä¹‹åŽæ˜¯ 13 åˆ†ã€‚1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;bool cmp(int a, int b) &#123; return a &gt; b;&#125;unordered_map&lt;int, int&gt; ht;const int maxn = 1000000 + 5;int numbers[maxn] = &#123;0&#125;;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; numbers[i]; &#125; sort(numbers, numbers + n, cmp); bool flag = true; int index = 0; while(k) &#123; if(ht[numbers[index]] == 0) &#123; if(flag) &#123; cout &lt;&lt; numbers[index]; flag = false; &#125; else cout &lt;&lt; ' ' &lt;&lt; numbers[index]; ht[numbers[index]] = 1; k--; &#125; index++; if(index &gt;= n) break; &#125; return 0;&#125; å…¶å®žï¼Œæ„Ÿè§‰ä¸Šé¢çš„ä»£ç æ­£å¸¸åº”è¯¥ä¸ä¼šè¶…æ—¶ï¼Œåº”è¯¥æ˜¯é‚£ä¸ªæµ‹è¯•æ ·ä¾‹æ­»å¾ªçŽ¯äº†ã€‚è‡³äºŽå†…å­˜è¶…é™ï¼Œåªèƒ½ä¸ç”¨ hashmapï¼Œå†æƒ³æƒ³å…¶ä»–çš„åšæ³•äº†ã€‚ Summaryä¹™çº§é¢˜åº“çš„æœ€åŽ 10 é“é¢˜å¥½åƒæ˜¯ 2019 å¹´çš„çœŸé¢˜ï¼Œå…·ä½“æ˜¯å•¥æ—¶å€™çš„å°±ä¸çŸ¥é“äº†ã€‚ä½†æ˜¯ï¼Œä¸ªäººæ„Ÿè§‰æ¯”è¿™æ¬¡è€ƒè¯•çš„è¦å®¹æ˜“ä¸€äº›ã€‚ç‰¹åˆ«æ˜¯ 1101ã€1102ã€1103ã€1106ã€1107ã€1108ï¼ŒåŸºæœ¬è·Ÿé€åˆ†é¢˜ä¸€æ ·ï¼Œä½†è¿™å¼ å·å­çš„å‰ 3 é“é¢˜ï¼Œä¸æ˜¯é‚£ä¹ˆæ˜Žæ˜¾çš„é€åˆ†é¢˜ï¼ŒåŸ‹äº†ä¸€ç‚¹ç‚¹å‘ã€‚è¿™å¥—å·å­çš„ç¬¬ 4 é¢˜è·Ÿç¬¬ 5 é¢˜å°±ç¨å¾®å¸¸è§„ä¸€ç‚¹äº†ã€‚ä¸è¿‡ï¼Œè¯è¯´å›žæ¥ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯è¿™å‡ å¤©æ²¡çŽ© PATï¼Œæ‰€ä»¥æ‰‹çœŸçš„ç”Ÿäº†çš„ç¼˜æ•…ï¼Œåˆšä¸€æ‹¿åˆ°é¢˜ç›®ï¼Œç«Ÿç„¶æœ‰ç‚¹æ— ä»Žä¸‹æ‰‹çš„æ„Ÿè§‰ã€‚æ€»è€Œè¨€ä¹‹ï¼Œå…ˆæŠŠè¿™å‡ é“é¢˜ç›®çš„ AC ä»£ç å†™å‡ºæ¥å§ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day3]]></title>
    <url>%2F2022%2F03%2F25%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day3%2F</url>
    <content type="text"><![CDATA[ç¬¬ä¸‰å¤©çš„ä¸»é¢˜è¿˜æ˜¯ two pointersï¼Œä¸€é“ç®€å•é¢˜ï¼Œä¸€é“ä¸­ç­‰é¢˜ã€‚ 283. Move ZeroesAnalysisæ‹¿åˆ°è¿™ç§é¢˜ä¹‹åŽï¼Œè„‘å­é‡Œé¢ååº”çš„ç¬¬ä¸€è§£æ³•ï¼Œå°±æ˜¯ç›´æŽ¥ç”¨ vector æ‹·è´...ðŸ˜‚è¯•äº†ä¸‹ï¼Œç¡®å®žæ˜¯å¯ä»¥è§£å‡ºæ¥çš„ã€‚ä¸è¿‡æ—¢ç„¶å‡ºçŽ°åœ¨è¿™é‡Œè¿˜æ˜¯ç”¨åŒæŒ‡é’ˆçš„æ–¹æ³•åšä¸€ä¸‹ã€‚ Codemethod 11234567891011class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; ret(nums.size()); int index = 0; for(int i = 0; i &lt; nums.size(); i++) &#123; if(nums[i]) ret[index++] = nums[i]; &#125; nums = ret; &#125;&#125;; method 2123456789101112131415161718class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int first = 0, second = 1, size = nums.size(); while(first &lt; size) &#123; if(nums[first] == 0) &#123; while(second &lt; size &amp;&amp; nums[second] == 0) second++; if(second &lt; size) &#123; swap(nums[first], nums[second]); first++, second++; &#125; else break; &#125; else &#123; first++; if(second &lt;= first) second++; &#125; &#125; &#125;&#125;; method 3æŒ‰ç…§ä¸Šé¢ä»£ç çš„æ€è·¯ï¼Œä»Žå·¦è¾¹æŒ‡é’ˆæ¥è€ƒè™‘é—®é¢˜ï¼Œä¼šæ¯”è¾ƒéº»çƒ¦ï¼Œå®žé™…ä¸Šï¼Œå¯ä»¥ç›´æŽ¥ä»Žå³è¾¹æŒ‡é’ˆçš„è§’åº¦æ¥è€ƒè™‘é—®é¢˜ã€‚æ­¤æ—¶ï¼Œå·¦è¾¹æŒ‡é’ˆå°±æ˜¯éžé›¶æ•°çš„å°¾éƒ¨ï¼Œå³è¾¹æŒ‡é’ˆå°±æ˜¯å¾…å¤„ç†æ•°å­—åºåˆ—çš„å¤´éƒ¨ï¼Œè¿™æ ·å³è¾¹æŒ‡é’ˆæ¯é‡åˆ°ä¸€ä¸ªéžé›¶æ•°ï¼Œå°±ç›´æŽ¥ç§»åˆ°å·¦è¾¹ã€‚12345678910111213class Solution &#123;public: void moveZeroes(vector&lt;int&gt;&amp; nums) &#123; int left = 0, right = 0, size = nums.size(); while(right &lt; size) &#123; if(nums[right]) &#123; swap(nums[left], nums[right]); left++; &#125; right++; &#125; &#125;&#125;; 167. Two Sum II - Input Array Is SortedAnalysisè¿™ä¸ªé¢˜æ˜¯ 1. Two Sum çš„åŠ å¼ºç‰ˆï¼Œä¹‹å‰çš„è§£æ³•åœ¨è¿™é‡Œå¯ä»¥ç”¨ã€‚æ‰€ä»¥ï¼Œé¦–å…ˆæƒ³åˆ°çš„å°±æ˜¯æš´åŠ›æ±‚è§£è·Ÿå“ˆå¸Œï¼Œä½†è¿™ä¸¤ç§æ–¹æ³•éƒ½æ²¡æœ‰ä½¿ç”¨é¢˜ç›®ç»™çš„æ¡ä»¶ï¼šæ•°ç»„æœ‰åºã€‚ Codemethod 11234567891011121314151617/* method 1: violent solution, will cause time limit exceeded. */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; ret; int size = numbers.size(); for(int i = 0; i &lt; numbers.size(); i++) &#123; for(int j = i + 1; j &lt; numbers.size(); j++) &#123; if(numbers[j] + numbers[i] == target) &#123; ret.push_back(i + 1); ret.push_back(j + 1); &#125; &#125; &#125; return ret; &#125;&#125;; æš´åŠ›è§£æ³•ï¼Œæžœç„¶ä¸å‡ºæ‰€æ–™çš„ä¼šè¶…æ—¶å•Šã€‚ method 2123456789101112131415161718/* method 2: use hash map */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; vector&lt;int&gt; ret(2); map&lt;int, int&gt; hash; int size = numbers.size(); hash[numbers[0]] = 0; for(int i = 1; i &lt; size; i++) &#123; if(hash.find(target - numbers[i]) != hash.end()) &#123; ret[0] = hash[target - numbers[i]] + 1; ret[1] = i + 1; &#125; hash[numbers[i]] = i; &#125; return ret; &#125;&#125;; å“ˆå¸Œè™½ç„¶ä¸è¶…æ—¶ï¼Œä½†æ˜¯é¢å¤–çš„æ¶ˆè€—äº†å†…å­˜ç©ºé—´ã€‚ method 3è€ƒè™‘åˆ°æ•°ç»„æœ‰åºï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨å‰ä¸¤å¤©å­¦ä¹ çš„äºŒåˆ†æŸ¥æ‰¾ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $O(nlogn)$ äº†ã€‚1234567891011121314151617/* method 3: use binary search */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; for(int i = 0; i &lt; numbers.size(); i++) &#123; int left = i + 1, right = numbers.size() - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(numbers[mid] == target - numbers[i]) &#123; return &#123;i + 1, mid + 1&#125;; &#125; else if(numbers[mid] &gt; target - numbers[i]) right = mid - 1; else left = mid + 1; &#125; &#125; return &#123;-1, -1&#125;; &#125;&#125;; method 4ç”±äºŽè¿™ä¸ªé¢˜å‡ºçŽ°åœ¨åŒæŒ‡é’ˆé‡Œé¢ï¼Œæ‰€ä»¥è‚¯å®šå¯ä»¥ä½¿ç”¨åŒæŒ‡é’ˆçš„è§£æ³•ã€‚å¦‚ä½•ä½¿ç”¨åŒæŒ‡é’ˆå‘¢ï¼Ÿéœ€è¦è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆåˆ†åˆ«ä»Žæ•°ç»„çš„å·¦å³ä¸¤è¾¹è¿›è¡ŒéåŽ†ï¼Œæ¯æ¬¡å°†æŒ‡é’ˆæ‰€æŒ‡çš„å€¼ä¹‹å’Œä¸Žç›®æ ‡å€¼è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æžœå¤§äºŽç›®æ ‡å€¼ï¼Œé‚£ä¹ˆå·¦ç§»å³æŒ‡é’ˆï¼›å¦‚æžœå°äºŽï¼Œé‚£ä¹ˆå³ç§»å·¦æŒ‡é’ˆã€‚å¯èƒ½ä¼šæœ‰äººè§‰å¾—æ¼è§£ï¼Œå®žé™…ä¸Šå¹¶ä¸ä¼šã€‚ä»Žåè¯æ³•çš„è§’åº¦å¾ˆå®¹æ˜“æƒ³æ˜Žç™½ï¼Œå¦‚æžœå³æŒ‡é’ˆå›ºå®šï¼Œå·¦æŒ‡é’ˆå·¦è¾¹å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„è§£ï¼Œæˆ–è€…å·¦æŒ‡é’ˆå›ºå®šï¼Œå³æŒ‡é’ˆå³è¾¹å­˜åœ¨æ»¡è¶³æ¡ä»¶çš„è§£ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°ç»„ä¸€å®šä¸æ˜¯æœ‰åºçš„ã€‚1234567891011121314/* method 4: use two pointers */class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123; int left = 0, right = numbers.size() - 1; while(left &lt; right) &#123; int sum = numbers[left] + numbers[right]; if(sum &lt; target) left++; else if(sum &gt; target) right++; else return &#123;left + 1, right + 1&#125;; &#125; return &#123;-1, -1&#125;; &#125;&#125;; SummaryåŒæŒ‡é’ˆç”¨æ¥è§£å†³ä¸€äº›é—®é¢˜çœŸæ˜¯æœ‰å¥‡æ•ˆå•Šã€‚å¤§ä½“ä¸Šæ¥è®²ï¼Œè¦ä¹ˆæ˜¯ä»Žä¸­é—´å‘ä¸¤è¾¹éåŽ†ï¼Œè¦ä¹ˆæ˜¯ä¸¤è¾¹å‘ä¸­é—´éåŽ†ã€‚é‡åˆ°è¿™ç§ç±»åž‹çš„é¢˜ç›®çš„æ—¶å€™ï¼Œä¸å¦¨ä»Žè¿™ä¸¤ä¸ªè§’åº¦æ€è€ƒä¸€ä¸‹ï¼Œè¯´ä¸å®šé—®é¢˜å°±èƒ½å¾—åˆ°è§£å†³ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day2]]></title>
    <url>%2F2022%2F03%2F24%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day2%2F</url>
    <content type="text"><![CDATA[ç¬¬äºŒå¤©çš„ä¸»é¢˜æ˜¯ two pointersï¼Œä¸€é“ç®€å•é¢˜ï¼Œä¸€é“å›°éš¾é¢˜ã€‚ 977. Squares of a Sorted ArrayAnalysisè¿™ä¸ªé¢˜ç¬¬ä¸€çœ¼çœ‹åˆ°åŽï¼Œè„‘å­é‡Œé¢æµ®çŽ°å‡ºæ¥çš„è§£æ³•ï¼Œå°±æ˜¯ç›´æŽ¥ç®—ï¼Œç„¶åŽæŽ’åºã€‚å°è¯•äº†ä¸€ä¸‹ï¼Œä¹Ÿæ˜¯å¯ä»¥è¿™æ ·åšçš„ã€‚ä¸è¿‡ï¼Œæ—¢ç„¶å‡ºçŽ°åœ¨åŒæŒ‡é’ˆè¿™é‡Œï¼Œåº”è¯¥å¯ä»¥ç”¨åŒæŒ‡é’ˆæ¥åšã€‚ç”¨åŒæŒ‡é’ˆå¤„ç†æœ‰ 2 ç§æ€è·¯ï¼š ä»Žä¸­é—´å‘ä¸¤è¾¹éåŽ†ï¼Œè¿™æ ·éœ€è¦å…ˆæ‰¾åˆ°ä¸­é—´å€¼ï¼Œå¯ä»¥è®¤ä¸ºä¸­é—´å€¼æ˜¯å¹³æ–¹åŽæ•°ç»„çš„æœ€å°å€¼ï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯æ•°ç»„ä¸­æ­£è´Ÿæ•°çš„åˆ†ç•Œç‚¹ï¼ˆé¢˜ç›®å·²ç»é™å®šæ˜¯éžé™åºæ•°ç»„ï¼Œæ‰€ä»¥æ­£è´Ÿæ•°æ˜¯åˆ†åˆ«åˆ†å¸ƒåœ¨ä¸¤è¾¹çš„ï¼‰ã€‚ ä»Žä¸¤è¾¹å‘ä¸­é—´éåŽ†ï¼Œè¿™æ ·æ¯æ¬¡é€‰å‡ºæ¥çš„å€¼å®žé™…ä¸Šæ˜¯æ•°ç»„å‰©ä½™æ•°å­—ä¸­çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥éœ€è¦é€†åºä¸€ä¸‹ã€‚ Codemethod 11234567891011class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; &#125; sort(nums.begin(), nums.end()); return nums; &#125;&#125;; method 2è¿™é‡Œé€‰æ‹©å¹³æ–¹åŽæœ€å°å€¼ä¸ºä¸­é—´å€¼ã€‚1234567891011121314151617181920212223242526272829303132class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(), min_index = 0, min = nums[0] * nums[0]; for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; if(nums[i] &lt; min) &#123; min = nums[i]; min_index = i; &#125; &#125; int left = min_index - 1, right = min_index + 1; vector&lt;int&gt; ret; ret.push_back(min); while(left &gt;= 0 &amp;&amp; right &lt;= size - 1) &#123; if(nums[left] &gt;= nums[right]) &#123; ret.push_back(nums[right]); right++; &#125; else &#123; ret.push_back(nums[left]); left--; &#125; &#125; while(left &gt;= 0) &#123; ret.push_back(nums[left--]); &#125; while(right &lt;= size - 1) &#123; ret.push_back(nums[right++]); &#125; return ret; &#125;&#125;; method 312345678910111213141516class Solution &#123;public: vector&lt;int&gt; sortedSquares(vector&lt;int&gt;&amp; nums) &#123; int size = nums.size(); for(int i = 0; i &lt; size; i++) &#123; nums[i] = nums[i] * nums[i]; &#125; vector&lt;int&gt; ret(size); int index = size - 1; for(int i = 0, j = size - 1; i &lt;= j;) &#123; if(nums[i] &gt; nums[j]) ret[index--] = nums[i++]; else ret[index--] = nums[j--]; &#125; return ret; &#125;&#125;; 189. Rotate ArrayAnalysisè¿™ä¸ªé¢˜å¾ˆç»å…¸ï¼Œåšæ³•å¾ˆå¤šï¼Œæ˜¯åšè¿‡å¾ˆå¤šæ¬¡çš„é¢˜ç›®äº†ã€‚ç”¨ reverse å‡½æ•°æ˜¯æœ€ç®€å•ç›´è§‚ã€è€Œä¸”æ¶ˆè€—ä½Žçš„åšæ³•äº†ï¼Œå¦‚æžœç”¨ç›´æŽ¥äº¤æ¢æ•°å­—çš„æ–¹æ³•ï¼Œéœ€è¦è®¡ç®—å‡ºéåŽ†çš„æ¬¡æ•°ï¼Œä½†æ˜¯å®žé™…ä¸Šå¯ä»¥å•ç‹¬è®¾ç½®ä¸€ä¸ª countï¼Œç”¨æ¥è®°å½•äº¤æ¢çš„æ¬¡æ•°ï¼Œä¸€æ—¦ç­‰äºŽ n è¯´æ˜Žéƒ½äº¤æ¢è¿‡äº†ï¼Œå°±å¯ä»¥é€€å‡ºå¾ªçŽ¯äº†ï¼Œè¿™æ ·ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ Codemethod 11234567891011121314151617181920212223/* method 1: use queue, but cost many memory */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; vector&lt;int&gt; ret; queue&lt;int&gt; q; k %= size; for(int i = 0; i &lt; size; i++) &#123; q.push(nums[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; tmp = q.front(); q.pop(); q.push(tmp); &#125; while(!q.epmty()) &#123; ret.push_back(q.front()); q.pop(); &#125; nums = ret; &#125;&#125;; method 212345678910111213141516/* method 2: use vector, also cost many memory */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; vector&lt;int&gt; ret; k %= size; for(int i = size - k; i &lt; size; i++) &#123; ret.push_back(nums[i]); &#125; for(int i = 0; i &lt; size - k; i++) &#123; ret.push_back(nums[i]); &#125; nums = ret; &#125;&#125;; method 31234567891011/* method 3: use reverse function */class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; k %= size; reverse(nums.begin(), nums.end()); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); &#125;&#125;; method 412345678910111213141516171819202122232425262728293031class Solution &#123;public: void rotate(vector&lt;int&gt;&amp; nums, int k) &#123; int size = nums.size(), tmp; k %= size; /* version 1 */ int count = gcd(size, k); for(int start = 0; start &lt; count; start++) &#123; int cur = start; int prev = nums[start]; do&#123; int next = (cur + k) % size; swap(nums[next], prev); cur = next; &#125; while(start != cur); &#125; /* version 2 int count = 0; for(int start = 0; count &lt; n; start++) &#123; int cur = start; int prev = nums[start]; do&#123; int next = (cur + k) % size; swap(nums[next], prev); cur = next; count++; &#125; while(start != cur); &#125; */ &#125;&#125;; Summaryæœ‰æ—¶å€™ç”¨åŒæŒ‡é’ˆæ¥è§£å†³ä¸€äº›é—®é¢˜æ—¶ï¼Œå¯èƒ½ä¼šæœ‰å¥‡æ•ˆï¼Œæ•´ä½“è€Œè¨€ï¼Œæ€è·¯ä¸ç®—éš¾ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Two pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode_14 å¤©ç®—æ³•å…¥é—¨_day1]]></title>
    <url>%2F2022%2F03%2F23%2FLeetcode-14-%E5%A4%A9%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8-day1%2F</url>
    <content type="text"><![CDATA[æ¥è¯•è¯• Leetcode 14 å¤©ç®—æ³•å…¥é—¨çš„éš¾åº¦ã€‚ç¬¬ä¸€å¤©çš„ä¸»é¢˜æ˜¯äºŒåˆ†æŸ¥æ‰¾ï¼Œç»™äº† 3 é“ç®€å•é¢˜ã€‚ 704. Binary SearchAnalysisæ³¨æ„é€€å‡ºå¾ªçŽ¯çš„æ¡ä»¶æ˜¯left &lt;= rightã€‚ Code12345678910111213141516171819class Solution &#123;public: int search(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; /* You can also write this way to avoid overflows. mid = (right - left) / 2 + left; */ mid = (left + right) / 2; if(nums[mid] &gt; target) &#123; right = mid - 1; &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; &#125; else if(nums[mid] == target) return mid; &#125; return -1; &#125;&#125;; 278. First Bad VersionAnalysisè¿™ä¸ªé¢˜ä¸€å¼€å§‹æƒ³åˆ°çš„æ˜¯ç›´æŽ¥å¾ªçŽ¯ï¼Œç»“æžœä¸å‡ºæ‰€æ–™çš„è¶…æ—¶äº†ï¼Œç„¶åŽåˆæ”¹æˆäº†äºŒåˆ†ã€‚è¯è¯´ï¼Œå¥½åƒæ²¡æœ‰çœ‹æ¸…æ¥šé¢˜ç›®çš„æ¡ä»¶ï¼šYou should minimize the number of calls to the API.ã€‚ä¹‹æ‰€ä»¥è¦è¿”å›ž leftï¼Œæ˜¯å› ä¸º left ä¸€å®šæ˜¯ bad versionã€‚ä½†æ˜¯ï¼Œmid åœ¨æ¯æ¬¡å¾ªçŽ¯åŽï¼Œå°±ä¸ä¸€å®šæ˜¯ bad version äº†ã€‚ Code123456789101112131415161718// The API isBadVersion is defined for you.// bool isBadVersion(int version);class Solution &#123;public: int firstBadVersion(int n) &#123; int left = 1, right = n, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(isBadVersion(mid)) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; &#125;&#125;; 35. Search Insert PositionAnalysisä¸€å¼€å§‹è¢«è¿™ä¸ªé¢˜ç»•è¿›åŽ»äº†ï¼Œä»¥ä¸ºè¦æŠŠæ‰¾åˆ°æ²¡æ‰¾åˆ°çš„æƒ…å†µå•ç‹¬çš„æ‹¿å‡ºæ¥è®¨è®ºã€‚å®žé™…ä¸Šï¼ŒæŒ‰ç…§äºŒåˆ†æŸ¥æ‰¾çš„æ€è·¯ï¼Œmid æœ€åŽåªæœ‰ä¸¤ç§ç»“æžœï¼š æ‰¾åˆ°äº† target çš„ä½ç½®ã€‚ æ‰¾åˆ°äº†æœ€åŽä¸€ä¸ªå°äºŽ target çš„å€¼çš„ä½ç½®ã€‚ æ‰€ä»¥æ ¹æ®ä¸åŒæƒ…å†µè¿”å›ž target çš„ä½ç½®æˆ– target è¦æ’å…¥çš„ä½ç½®å°±å¯ä»¥äº†ã€‚ å®žé™…ä¸Šï¼Œè¿™ä¸ªåŽŸç†åº”è¯¥æ˜¯ lower_bound() å‡½æ•°çš„å®žçŽ°åŽŸç†ï¼Œåªä¸è¿‡ï¼Œlower_bound() å‡½æ•°è¿”å›žçš„ä½ç½®ä¿¡æ¯åº”è¯¥æ˜¯æŸ¥æ‰¾ä¸åˆ°åŽçš„ leftï¼ˆå¦‚æžœæ²¡æŸ¥æ‰¾åˆ°ï¼Œæœ€ç»ˆ right ä¸€å®šä¼šå°äºŽ leftï¼Œå› ä¸ºåªæœ‰è¿™æ ·æ‰èƒ½é€€å‡ºå¾ªçŽ¯ï¼‰ï¼Œè€Œè¿™ä¸ªå€¼å…¶å®žä¹Ÿå°±æ˜¯æ’å…¥çš„ä½ç½®ã€‚å…¶å®žä¹Ÿå°±æ˜¯è¯´ï¼Œæ‰¾åˆ°äº†ï¼Œå°±è¿”å›ž midï¼Œæ²¡æ‰¾åˆ°ï¼Œå°±è¿”å›ž leftã€‚ Codeversion 11234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(nums[mid] == target) break; else if(nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if(target &lt;= nums[mid]) return mid; else return mid + 1; &#125;&#125;; version 2123456class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; return lower_bound(nums.begin(), nums.end(), target) - nums.begin(); &#125;&#125;; version 31234567891011121314class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1, mid; while(left &lt;= right) &#123; mid = (right - left) / 2 + left; if(nums[mid] == target) break; else if(nums[mid] &gt; target) right = mid - 1; else left = mid + 1; &#125; if(target == nums[mid]) return mid; else return left; &#125;&#125;; Summaryä¸€æ¬¡æ€§è¿žç»­ 3 åšé“åŒçŸ¥è¯†ç‚¹çš„é¢˜ç›®ï¼Œå¯¹å·©å›ºè¿™ä¸ªçŸ¥è¯†ç‚¹å€’æ˜¯å¾ˆæœ‰å¸®åŠ©ã€‚äºŒåˆ†æŸ¥æ‰¾è¿”å›žçš„ä¸‹æ ‡ç¡®å®žæ˜¯ä¸€ä¸ªå®¹æ˜“è®©äººè¿·æƒ‘çš„ç‚¹ï¼Œå¯èƒ½ä¼šæœ‰äººå–œæ¬¢æŠŠå¾ªçŽ¯çš„æ¡ä»¶å†™æˆleft &lt; rightï¼Œè¿™æ ·å†™åº”è¯¥ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œä¸è¿‡è¿”å›žå€¼å¯èƒ½éœ€è¦ç›¸åº”çš„åšå‡ºè°ƒæ•´ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Leetcode</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_stack&queueå®¹å™¨çš„åŸºæœ¬ç”¨æ³•]]></title>
    <url>%2F2022%2F03%2F18%2FC-stack-queue%E5%AE%B9%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[æœ¬æ–‡åªä»‹ç» stack å’Œ queue çš„ä¸€äº›å¸¸è§ç”¨æ³•ï¼Œä¸ç€é‡è®¨è®ºå¦‚ä½•å®žçŽ°çš„é—®é¢˜ã€‚ introä¸Žå…¶ä»– STL å®¹å™¨ä¸€æ ·ï¼Œä½¿ç”¨ stack ä¸Ž queueï¼Œéœ€è¦åˆ†åˆ«å¼•å…¥å¤´æ–‡ä»¶ stack å’Œ queueã€‚ stackæ ˆï¼ˆstackï¼‰æ˜¯ä¸€ç§åŽè¿›å…ˆå‡ºï¼ˆFILOï¼‰çš„æ•°æ®ç»“æž„ã€‚å°±å¥½æ¯”æ”¾ç›˜å­ä¸€æ ·ï¼Œåœ¨ä¸å°†å æ”¾å¥½çš„ç›˜å­å…¨éƒ¨ä¸¾èµ·çš„æƒ…å†µä¸‹ï¼Œåªèƒ½å…ˆä¾æ¬¡æ‹¿æœ€ä¸Šé¢çš„ç›˜å­ä½¿ç”¨ï¼ˆè¿™ä¸ªæ¯”æ–¹å¯èƒ½ä¸å¤ªæ°å½“ï¼‰ã€‚æ ˆçš„å£°æ˜Žæ¯”è¾ƒç®€å•ï¼Œç›´æŽ¥ï¼š1stack&lt;int&gt; st; å…¶ä¸­ï¼Œintå¯ä»¥æ¢æˆå…¶ä»–æ•°æ®ç±»åž‹ã€ç»“æž„ä½“æˆ–å®¹å™¨ã€‚æŽ¥ä¸‹æ¥ï¼Œåœ¨çœ‹ä¸€ä¸‹ä¸Žæ ˆç›¸å…³çš„å‡½æ•°ã€‚ emptyempty ç”¨æ¥åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºï¼Œç©ºå°±è¿”å›žtrueï¼Œå¦åˆ™å°±è¿”å›žfalseï¼Œå¦‚ï¼š1234567891011121314#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;char&gt; st; if(st.empty()) cout &lt;&lt; "emtpy"; else cout &lt;&lt; "no"; return 0;&#125;/*out:empty*/ poppop ç”¨æ¥å¼¹å‡ºæ ˆé¡¶å…ƒç´ ï¼Œå¦‚ï¼š1st.pop(); pushpush ç”¨æ¥å°†å…ƒç´ åŽ‹å…¥æ ˆå†…ï¼Œå¦‚ï¼š1st.push(); sizesize ç”¨æ¥è¿”å›žæ ˆå†…å…ƒç´ çš„ä¸ªæ•°ï¼Œå¦‚ï¼š12345678910111213141516#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); cout &lt;&lt; st.size(); return 0;&#125;/*out:3*/ toptop ç”¨æ¥è¿”å›žæ ˆé¡¶å…ƒç´ ï¼Œå¦‚ï¼š12345678910111213141516#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;int main() &#123; stack&lt;int&gt; st; st.push(1); st.push(2); st.push(3); int a = st.top(); cout &lt;&lt; a; return 0;&#125;/*out:3 æ³¨æ„ä½¿ç”¨å‰å…ˆåˆ¤æ–­æ ˆä¸ç©ºï¼Œä¸ç„¶ä¼šäº§ç”ŸæœªçŸ¥é”™è¯¯ã€‚ queueè¿™é‡Œä»‹ç»çš„é˜Ÿåˆ—ï¼ˆqueueï¼‰åªæ˜¯ä¸€ç§å…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰çš„æ•°æ®ç»“æž„ã€‚å°±è·Ÿç”Ÿæ´»ä¸­çš„æŽ’é˜Ÿæ˜¯ä¸€å›žäº‹ï¼Œå‰æŽ’çš„äººå…ˆé€šè¿‡ã€‚é˜Ÿåˆ—çš„å£°æ˜Žä¸Žæ ˆä¸€æ ·ï¼Œå¦‚ï¼š1queue&lt;int&gt; q; å…¶ä¸­ï¼Œintå¯ä»¥æ¢æˆå…¶ä»–æ•°æ®ç±»åž‹ã€ç»“æž„ä½“æˆ–å®¹å™¨ã€‚æŽ¥ä¸‹æ¥ï¼Œåœ¨çœ‹ä¸€ä¸‹ä¸Žé˜Ÿåˆ—ç›¸å…³çš„å‡½æ•°ã€‚ emptyempty ç”¨æ¥åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œç©ºå°±è¿”å›žtrueï¼Œå¦åˆ™å°±è¿”å›žfalseï¼Œç”¨æ³•ä¸Žæ ˆä¸€è‡´ã€‚ pushpush ç”¨æ¥å°†å…ƒç´ åŽ‹å…¥é˜Ÿå†…ï¼Œå¦‚ï¼š12queue&lt;int&gt; q;q.push(1); front/backfront å’Œ back åˆ†åˆ«ç”¨æ¥è¿”å›žé˜Ÿé¦–ä¸Žé˜Ÿå°¾å…ƒç´ ï¼Œå¦‚ï¼š1234queue&lt;int&gt; q;q.push(1);int a = q.front();int b = q.back(); poppop ç”¨æ¥å¼¹å‡ºé˜Ÿé¦–å…ƒç´ ï¼Œå¦‚ï¼š123queue&lt;int&gt; q;q.push(1);q.pop(); sizesize ç”¨æ¥è¿”å›žé˜Ÿåˆ—å†…å…ƒç´ çš„ä¸ªæ•°ï¼Œç”¨æ³•ä¸Žæ ˆä¸€è‡´ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>Stack</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_string å®¹å™¨çš„å¸¸è§ç”¨æ³•]]></title>
    <url>%2F2022%2F03%2F14%2FC-string-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[C++ æä¾›äº†ä¸¤ç§ç±»åž‹çš„å­—ç¬¦ä¸²è¡¨ç¤ºå½¢å¼ï¼šC è¯­è¨€ç±»åž‹å’Œå¼•å…¥çš„ string ç±»ã€‚åœ¨æŸäº›åœºæ™¯ä¸‹ï¼Œä½¿ç”¨æ–°çš„ string ç±»æ¥å¤„ç†å­—ç¬¦ä¸²ååˆ†æ–¹ä¾¿ï¼Œè¿™é‡Œä»‹ç»ä¸€ä¸‹å…¶å¸¸è§çš„ç”¨æ³•ã€‚ å®šä¹‰å¦‚æžœè¦ä½¿ç”¨ stringï¼Œéœ€è¦æ·»åŠ  string å¤´æ–‡ä»¶ã€‚ä½†åœ¨ C++ 11 ä¸­ï¼Œiostream è¿™ä¸ªå¤´æ–‡ä»¶å†…å¥½åƒå·²ç»åŒ…å«äº† string ï¼Œå…·ä½“å¦‚ä½•ï¼Œè¿™é‡Œä¸åšè®¨è®ºã€‚å®šä¹‰ string çš„æ–¹å¼è·ŸåŸºæœ¬æ•°æ®ç±»åž‹ç›¸åŒï¼Œåªéœ€è¦åœ¨ string åŽé¢è·Ÿä¸Šå˜é‡åå³å¯ï¼š1string str; å¦‚æžœè¦åˆå§‹åŒ–ï¼Œå°±éœ€è¦ç›´æŽ¥å¯¹ string ç±»åž‹çš„å˜é‡èµ‹å€¼ï¼š1string str = "abcd"; æœ‰æ—¶å€™éœ€è¦ä¸€ä¸ªå«æœ‰ n ä¸ªç›¸åŒå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œæ­¤æ—¶å¯ä»¥åˆ©ç”¨ string çš„æž„é€ å‡½æ•°å®Œæˆï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str = string(4, 'a'); cout &lt;&lt; str &lt;&lt; endl; return 0;&#125;/*out:aaaa*/ è¿˜å¯ä»¥ç”¨æž„é€ å‡½æ•°å®Œæˆæˆªå–å­—ç¬¦ä¸²çš„æ“ä½œï¼š123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcd"; string s = string(str, 1, 3); cout &lt;&lt; s &lt;&lt; endl; return 0;&#125;/*out:bcd*/ è®¿é—®C++ æä¾›äº†ä¸¤ç§å¤šç§è®¿é—® string ç±»çš„æ–¹å¼ã€‚ é€šè¿‡ä¸‹æ ‡è®¿é—®C++ å¯ä»¥é€šè¿‡ä¸‹æ ‡ç›´æŽ¥è®¿é—®åˆ° string ç±»åž‹å˜é‡çš„æ¯ä¸€ä¸ªå­—ç¬¦å˜é‡ï¼Œå¦‚ï¼š123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str[i] &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ è®¿é—®å•ä¸ªå­—ç¬¦è¿˜å¯ä»¥é€šè¿‡ at å‡½æ•°æ¥å®Œæˆï¼š123456789101112#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; str.at(i) &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ å¦‚æžœè¦è¾“å…¥æˆ–è¾“å‡ºæ•´ä¸ªå­—ç¬¦ä¸²ï¼Œå°±å¾—ç”¨ cin å’Œ coutï¼š12345678#include &lt;iostream&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; cout &lt;&lt; str;&#125; ç¡¬è¦ç”¨ scanf å’Œ printf ä¹Ÿæ˜¯å¯ä»¥çš„ï¼Œå¦‚ï¼š12345678#include &lt;iostream&gt;using namespace std;int main() &#123; string str; scanf("%s", str.c_str()); printf("%s", str.c_str());&#125; é€šè¿‡è¿­ä»£å™¨è®¿é—®string ç±»ä¸Žå…¶ä»– STL å®¹å™¨ä¸€æ ·ï¼Œä¹Ÿæ˜¯æ”¯æŒç”¨è¿­ä»£å™¨è®¿é—®çš„ï¼Œå¦‚ï¼š12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "abcde"; string::iterator it = str.begin(); for(; it != str.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; ' '; &#125;&#125;/* out:a b c d e */ è¿™ä¸ªç”¨æ³•æœ‰ç‚¹ç±»ä¼¼æŒ‡é’ˆï¼Œå¦å¤–ï¼Œit + 2å’Œstr[2]è¡¨ç¤ºçš„æ˜¯åŒä¸€ä¸ªå­—ç¬¦ã€‚ æ“ä½œç¬¦operator +=è¿™æ˜¯ string çš„åŠ æ³•ï¼Œç±»ä¼¼ C è¯­è¨€ä¸­çš„ strcatï¼Œjava é‡Œé¢ä¹Ÿæœ‰ç±»ä¼¼çš„ç”¨æ³•ï¼Œå¦‚ï¼š123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcde"; string str2 = "efghi"; string str3 = str1 + str2; str1 = str1 + str2; cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str3 &lt;&lt; endl;; &#125;/* out:abcdeefghiabcdeefghi*/ æ³¨æ„ï¼šstring ç±»å¯æ²¡æœ‰ +ã€/ã€Ã—ï¼Œä¸è¦æƒ¯æ€§æ€è€ƒäº†ã€‚ compare operatorä¸¤ä¸ª string ç±»åž‹çš„å˜é‡å¯ä»¥ç›´æŽ¥ç”¨ &lt;ã€&gt;ã€==ã€&lt;=ã€&gt;=ã€!= ç›´æŽ¥è¿›è¡Œæ¯”è¾ƒï¼Œè§„åˆ™æ˜¯æŒ‰å­—å…¸åºé€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼Œè¿™ä¸ªåŠŸèƒ½ç±»ä¼¼ C è¯­è¨€ä¸­çš„ strcmpï¼Œå¦‚ï¼š123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aa", str2 = "aaa", str3 = "abc", str4 = "xyz"; if(str1 &lt; str2) printf("1\n"); if(str1 != str3) printf("2\n"); if(str4 &gt;= str3) printf("3\n"); &#125;/* out:123*/ å¸¸ç”¨å‡½æ•°ç›¸è¾ƒäºŽ C è¯­è¨€ï¼Œstring ç±»å°è£…äº†å¾ˆå¤šå¸¸ç”¨çš„å­—ç¬¦ä¸²æ“ä½œå‡½æ•°ï¼Œå¯ä»¥ç›´æŽ¥æ‹¿æ¥ç”¨ï¼Œå¾ˆæ–¹ä¾¿ã€‚ length/sizelength å’Œ size è¿”å›ž string çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¦‚ï¼š12345678910#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaa", str2 = "11aaa"; cout &lt;&lt; str1.size() &lt;&lt; ' ' &lt;&lt; str2.length();&#125;/* out:3 5*/ insertinsert çš„ç”¨æ³•æœ‰å¾ˆå¤šï¼Œè¿™é‡Œåªåˆ—ä¸¾å¸¸è§çš„å‡ ä¸ªç”¨æ³•ã€‚ å­—ç¬¦ä¸²ä¸­æ’å…¥å­—ç¬¦ä¸²åŸºæœ¬å†™æ³•ï¼šstr1.insert(pos, str2)ï¼Œåœ¨ str1 çš„ pos è¿™ä¸ªä½ç½®ï¼Œæ’å…¥å­—ç¬¦ä¸² str2ï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz", str2 = "11aaa"; str1.insert(2, str2); cout &lt;&lt; str1;&#125;/* out:aa11aaaz*/ è¿˜å¯ä»¥ä½¿ç”¨è¿­ä»£å™¨æ¥å®Œæˆï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz", str2 = "11aaa"; str1.insert(str1.begin() + 2, str2.begin(), str2.end()); cout &lt;&lt; str1;&#125;/* out:aa11aaaz*/ å­—ç¬¦ä¸²ä¸­æ’å…¥å¤šä¸ªå­—ç¬¦åŸºæœ¬å†™æ³•ï¼šstr1.insert(pos, count, ch)ï¼Œåœ¨ str1 çš„ pos è¿™ä¸ªä½ç½®ï¼Œæ’å…¥ count ä¸ªå­—ç¬¦ chï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "aaz"; str1.insert(2, 1, 'c'); cout &lt;&lt; str1;&#125;/* out:aacz*/ åŒæ ·ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨è¿­ä»£å™¨æ¥å®Œæˆã€‚å‚è€ƒé“¾æŽ¥ï¼šC++ stringç±»insertç”¨æ³•æ€»ç»“ eraseerase å¯ä»¥ç”¨æ¥åˆ é™¤å•ä¸ªå­—ç¬¦æˆ–ä¸€ä¸ªåŒºé—´å†…çš„æ‰€æœ‰å­—ç¬¦ã€‚ åˆ é™¤å•ä¸ªå­—ç¬¦åŸºæœ¬å†™æ³•ï¼šstr1.erase(it)ï¼Œit ä¸ºè¦åˆ é™¤çš„å­—ç¬¦çš„è¿­ä»£å™¨ï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcde"; str1.erase(str1.begin() + 2); cout &lt;&lt; str1;&#125;/* out:abde*/ åˆ é™¤ä¸€ä¸ªåŒºé—´å†…çš„å­—ç¬¦åˆ é™¤ä¸€ä¸ªåŒºé—´å†…çš„å­—ç¬¦æœ‰ä¸¤ç§æ–¹æ³•ï¼Œstr1.erase(first, last)å’Œstr1.erase(pos, length)ï¼Œä¹Ÿå°±æ˜¯åŒºé—´çš„å†™æ³•ã€‚ç¬¬ä¸€ç§å†™æ³• first ä¸Ž last å¿…é¡»è¦æ˜¯è¿­ä»£å™¨ï¼Œåˆ é™¤çš„åŒºé—´æ˜¯[first, last)ï¼Œå·¦é—­å³å¼€ï¼›ç¬¬äºŒç§å†™æ³•ä¸­ pos ä¸ºéœ€è¦å¼€å§‹åˆ é™¤çš„èµ·å§‹ä½ç½®ï¼Œlength ä¸ºåˆ é™¤çš„å­—ç¬¦ä¸ªæ•°ï¼Œå¦‚ï¼š123456789101112131415#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg", str2; str2 = str1; str1.erase(str1.begin() + 2, str1.end() - 1); cout &lt;&lt; str1 &lt;&lt; endl; str2.erase(2, 4); cout &lt;&lt; str2;&#125;/* out:abgabg*/ å‚è€ƒé“¾æŽ¥ï¼šc++ stringçš„eraseåˆ é™¤æ–¹æ³• clearclear ç”¨æ¥æ¸…ç©º string ä¸­çš„æ•°æ®ï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg"; str1.clear(); cout &lt;&lt; str1.length();&#125;/* out:0*/ substrsubstr ç”¨æ¥è¿”å›žå­ä¸²ï¼ŒåŸºæœ¬å†™æ³•ï¼šstr.substr(pos, len)ï¼Œå³è¿”å›žä»Ž pos å¼€å§‹ï¼Œé•¿åº¦ä¸º len å­ä¸²ï¼Œå¦‚ï¼š1234567891011#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcdefg", str2; str2 = str1.substr(3, 3); cout &lt;&lt; str2;&#125;/* out:def*/ ä¹Ÿå¯ä»¥ç›´æŽ¥å†™str.substr(pos)ï¼Œä¼šç›´æŽ¥è¿”å›žä»Ž pos å¼€å§‹ï¼Œç›´åˆ°å­—ç¬¦ä¸²ç»“å°¾çš„å­ä¸²ã€‚ findfind ç”¨æ¥æŸ¥æ‰¾å­ä¸²ï¼Œè¿™ä¸ªå­ä¸²ä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªå­—ç¬¦ï¼ŒåŸºæœ¬å†™æ³•ï¼šstr.find(str2)æˆ–str.find(str2, pos)ï¼Œå¦‚æžœä¸åŠ å‚æ•° posï¼Œé‚£ä¹ˆ find ä¼šè¿”å›ž str2 åœ¨ str ä¸­ç¬¬ä¸€æ¬¡å‡ºçŽ°çš„ä½ç½®ï¼Œå¦åˆ™å°±è¿”å›ž string::nposï¼ˆæ˜¯ä¸€ä¸ªå¸¸æ•°ï¼Œæœ¬èº«çš„å€¼æ˜¯ -1ï¼Œä½†ç”±äºŽå®ƒæ˜¯ unsigned_int ç±»åž‹ï¼Œæ‰€ä»¥ä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯ 4294967295ï¼‰ã€‚è€ŒåŠ äº† pos åŽï¼Œå°±ä¼šä»Ž str çš„ç¬¬ pos ä¸ªä½ç½®å¼€å§‹åŒ¹é… str2ï¼Œè¿”å›žå€¼ä¸Žä¸åŠ  pos ä¸€è‡´ã€‚å¦‚ï¼š123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "hello world"; string str1 = "llo", str2 = "you"; cout &lt;&lt; str.find('e') &lt;&lt; endl; if(str.find(str1) != string::npos) cout &lt;&lt; str.find(str1) &lt;&lt; endl; if(str.find(str1, 2) != string::npos) cout &lt;&lt; str.find(str1, 2) &lt;&lt; endl; if(str.find(str2) != string::npos) cout &lt;&lt; str.find(str2) &lt;&lt; endl; else cout &lt;&lt; "no pos" &lt;&lt; endl;&#125;/* out:122no pos*/ å‚è€ƒé“¾æŽ¥ï¼šC++ stringä¸­çš„find()å‡½æ•° replacereplace ç”¨æ¥æ›¿æ¢å­ä¸²ï¼ŒåŸºæœ¬ç”¨æ³•ï¼šstr.replace(pos, len, str2)æˆ–str.replace(it1, it2, str2)ã€‚ç¬¬ä¸€ç§å†™æ³•æ˜¯æŠŠ str ä»Žç¬¬ pos ä¸ªä½ç½®å¼€å§‹ã€é•¿åº¦ä¸º len çš„å­ä¸²æ›¿æ¢ä¸º str2ï¼›ç¬¬äºŒç§å†™æ³•æ˜¯æŠŠ str çš„è¿­ä»£å™¨ [it1, it2) èŒƒå›´çš„å­ä¸²æ›¿æ¢ä¸º str3ï¼Œå¦‚ï¼š1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; string str = "Maybe you will turn around."; string str2 = "will not"; string str3 = "surely"; cout &lt;&lt; str.replace(10, 4, str2) &lt;&lt; endl; cout &lt;&lt; str.replace(str.begin(), str.begin() + 5, str3) &lt;&lt; endl;&#125;/* out:Maybe you will not turn around.surely you will not turn around.*/ to_stringto_string ç”¨æ¥å°†æ•°å€¼è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ï¼ŒåŸºæœ¬ç”¨æ³•ï¼šstring num = to_string(1234213)ï¼Œå¦‚ï¼š12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; string str = to_string(1234567); cout &lt;&lt; str &lt;&lt; endl; str = to_string(1.223563333); cout &lt;&lt; str &lt;&lt; endl; str = to_string(-121); cout &lt;&lt; str &lt;&lt; endl;&#125;/* out:12345671.223563-121*/ è¿™ä¸ªå‡½æ•°ï¼Œå¤„ç†æŸäº›é—®é¢˜æ—¶ï¼Œå¯èƒ½æœ‰å¥‡æ•ˆã€‚å‚è€ƒé“¾æŽ¥ï¼šc++ to_String() appendappend å‡½æ•°ç”¨æ¥å‘å­—ç¬¦ä¸²æœ«å°¾æ·»åŠ å­—ç¬¦æˆ–å¦ä¸€ä¸ªå­—ç¬¦ä¸²ï¼ŒåŸºæœ¬ç”¨æ³•ï¼šstr.append(5, &#39;+&#39;)æˆ–str1.append(str2)ï¼Œå¦‚ï¼š12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; string str1 = "abcd", str2 = "efgh"; cout &lt;&lt; str1.append(5, '+') &lt;&lt; endl; cout &lt;&lt; str1.append(str2) &lt;&lt; endl; return 0;&#125;/* out:abcd+++++abcd+++++efgh*/ å‚è€ƒé“¾æŽ¥ï¼šC++ä¸­string appendå‡½æ•°çš„ä½¿ç”¨ä¸Žå­—ç¬¦ä¸²æ‹¼æŽ¥ pop_back/push_backä¸¥æ ¼æ¥è®²ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°åº”è¯¥æ˜¯ä»ŽåŸºç±»ç»§æ‰¿è¿‡æ¥çš„ï¼ˆç›²çŒœä¸€ä¸‹ string çš„åŸºç±»ä¼°è®¡æ˜¯ vector ðŸ˜‚ï¼‰ï¼Œç”¨æ³•ä¸Šä¸Ž vector ä¸­çš„ push_back å’Œ pop_back æ— å·®åˆ«ï¼š12345string str = "aaa"// åœ¨ str æœ«å°¾æ·»åŠ ä¸€ä¸ªå­—ç¬¦ bstr.push_back('b');// åœ¨ str æœ«å°¾åˆ é™¤ä¸€ä¸ªå­—ç¬¦str.pop_back();]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C/C++</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ä¸¤ä»¶å°äº‹]]></title>
    <url>%2F2021%2F12%2F07%2F%E4%B8%A4%E4%BB%B6%E5%B0%8F%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[ä»Šå¤©å‘ç”Ÿäº†ä¸¤ä»¶å°äº‹ï¼Œéƒ½ä¸Žæ°´ç›¸å…³ã€‚ ä¸¤ä»¶å°äº‹éƒ½å¾ˆå¹³å¸¸ï¼Œéƒ½æ˜¯æ™®é€šäººä¼šç¢°åˆ°ï¼Œå¯èƒ½ä¹Ÿä¼šåšçš„äº‹æƒ…ã€‚ ä¹‹æ‰€ä»¥æƒ³è¦å†™ä¸‹æ¥ï¼Œä¸»è¦æ˜¯ä¸ºäº†è®©è‡ªå·±åçœï¼Œä¸ºä»€ä¹ˆä¼šåšå‡ºè¿™æ ·çš„äº‹æƒ…ï¼Œä¸ºä»€ä¹ˆä¼šå¾—åˆ°è¿™æ ·çš„ç»“æžœã€‚ ä¸è¿‡ï¼Œå€’ä¹Ÿä¸æ˜¯æƒ³å®Œå®Œå…¨å…¨çš„è‡ªæˆ‘æ‰¹åˆ¤ã€‚ ä¸¤ä»¶äº‹æƒ…çš„å…³è”æ€§å¾ˆå¤§ï¼Œäº‹æƒ…çš„ç»è¿‡æ˜¯è¿™æ ·çš„ï¼š ä¸‹åˆï¼Œæˆ‘æ‹¿äº†ä¸€ä¸ªæ°´æ¡¶å‡†å¤‡åŽ»ç¤¾åŒºçš„ç›´é¥®ç”¨æ°´ç«™æŽ¥ç‚¹çº¯å‡€æ°´ï¼Œé¡ºè·¯åœ¨åŽ»æ°´ç«™å‰æ–¹ 150 ç±³å¤„çš„è‡ªæ¥æ°´å…¬å¸äº¤æ°´è´¹ï¼ˆä¸»è¦æ˜¯ä¸ºäº†è¯¢é—®æœ€è¿‘æ°´è¡¨è®°å½•æ˜¯å¦æ­£ç¡®ï¼‰ã€‚ç­‰åˆ°æˆ‘æ¥åˆ°æ°´ç«™åŽï¼Œç©ºæ— ä¸€äººï¼Œç´¢æ€§å°±ç›´æŽ¥ç”¨æ¡¶æŽ¥æ°´ï¼Œæƒ³ç€ä¸å¦‚é¡ºè·¯åŽ»è‡ªæ¥æ°´å…¬å¸äº¤ä¸‹æ°´è´¹å§ï¼ˆæ­¤æ—¶çš„æˆ‘ï¼Œä¸æ¯«æ²¡æœ‰è€ƒè™‘åˆ°åœ¨æˆ‘ç¦»å¼€çš„æ—¶å€™ï¼Œå¯èƒ½ä¼šæœ‰äººæ¥æŽ¥æ°´ï¼‰ã€‚ç„¶åŽï¼Œæˆ‘å°±ç•™ä¸‹äº†æˆ‘çš„æ¡¶ï¼ˆæŽ¥æ°´å™¨çš„å¼€å…³ä¼šè‡ªåŠ¨å…³é—­ï¼‰ã€‚ æ¥åˆ°è‡ªæ¥æ°´å…¬å¸åŽï¼ŒæŠ¥äº†ä½ç½®ä¸Žä½æˆ·ä¿¡æ¯ï¼Œå·¥ä½œäººå‘˜æé†’æœ‰ 2 å¹´çš„åžƒåœ¾å¤„ç†è´¹æ²¡æœ‰äº¤ï¼Œä½†æˆ‘è®°å¾—å¾ˆæ¸…æ¥šï¼ŒåŽ»å¹´çš„åžƒåœ¾å¤„ç†è´¹æ˜¯æˆ‘äº²è‡ªæ¥äº¤çš„ã€‚å£å¤´è¯´æ˜Žå¹¶ä¸èƒ½è®©å·¥ä½œäººå‘˜ç›¸ä¿¡ï¼ŒäºŽæ˜¯ï¼Œæˆ‘å°±å°†åŽ»å¹´çš„å‘ç¥¨æ‹¿ç»™äº†å·¥ä½œäººå‘˜ã€‚æžœç„¶ï¼Œè§åˆ°å‘ç¥¨ï¼Œå·¥ä½œäººå‘˜å°±ä¿¡æœäº†ã€‚ä¹‹åŽï¼Œåˆè¯¢é—®äº†æœ‰å…³æ°´è¡¨è®°å½•çš„äº‹æƒ…ï¼Œä½†ä¸æ¯«æ²¡æœ‰æ‰“æ¶ˆæˆ‘çš„ç–‘æƒ‘ã€‚å› ä¸ºåŽé¢åˆæœ‰äººä¹Ÿç­‰ç€äº¤æ°´è´¹ï¼Œæˆ‘ç´¢æ€§æ‰“æ¶ˆäº†ç»§ç»­è¯¢é—®ä¸‹åŽ»çš„å¿µå¤´ã€‚ å›žåˆ°æ°´ç«™åŽï¼Œä¸€çœ‹æŽ¥æ°´å™¨ï¼Œæ°´æ¡¶æ²¡äº†ï¼ŒçŽ¯è§†å‘¨å›´ä¸€åœˆï¼Œç»“æžœè·Ÿæ¥çš„æ—¶å€™ä¸€æ ·ï¼Œä¸€ä¸ªäººä¹Ÿæ²¡æœ‰ã€‚ äº‹æƒ…çš„å¤§æ¦‚å°±æ˜¯è¿™æ ·ï¼Œå…¶å®žå¯ä»¥ç²¾ç‚¼ä¸€ä¸‹ï¼š åœ¨æœ‰å‘ç¥¨çš„æƒ…å†µä¸‹ï¼Œè®©å·¥ä½œäººå‘˜ä¿®æ”¹äº†ä¿¡æ¯ï¼Œé¿å…äº†ä¸éœ€è¦çš„æŸå¤± ä¸§å¤±äº†å¯¹çŽ¯å¢ƒçš„è­¦æƒ•ï¼Œå°†â€œæœ‰ä»·å€¼â€çš„ç‰©å“æš´éœ²åœ¨æ— äººçš„çŽ¯å¢ƒä¸­ï¼Œé€ æˆäº†æŸå¤± æ€»ç»“ä¸€ä¸‹ï¼Œå¯ä»¥çœ‹å‡ºè¿™ä¸¤ä»¶äº‹æƒ…éƒ½æ˜¯å› æ°´è€Œèµ·çš„ï¼Œä½†æ˜¯ç»“æžœå´æ­£å¥½ç›¸åã€‚å½’æ ¹ç»“åº•ï¼Œå®ƒä»¬æ‰€åæ˜ å‡ºæ¥çš„æ˜¯æˆ‘åœ¨å¤„ç†äº‹æƒ…ä¸Šçš„å­˜åœ¨çš„é—®é¢˜ã€‚é‚£ä¹ˆï¼Œè¿™äº›é—®é¢˜åˆæ˜¯ä»€ä¹ˆå‘¢ï¼Ÿæ˜¯ç²—å¿ƒçš„é—®é¢˜å—ï¼Ÿæˆ‘è§‰å¾—åº”è¯¥ä¸å•å•æ˜¯ç²—å¿ƒçš„é—®é¢˜ï¼Œå•ä»Žç¬¬ä¸€ä»¶äº‹æƒ…æ¥è®²ï¼Œæˆ‘å¹¶æ²¡æœ‰çŠ¯ä¸‹ç²—å¿ƒçš„é”™è¯¯ï¼›è€Œä»Žç¬¬äºŒä»¶äº‹æƒ…çš„è§’åº¦æ¥çœ‹ï¼Œæˆ‘çš„é”™è¯¯æ˜¯å¤ªå¤©çœŸäº†ã€‚å½“æ—¶ï¼Œæˆ‘åªæƒ³äº†ä¸¤ç‚¹å°±åšå‡ºäº†å†³å®šï¼š çŽ°åœ¨æ²¡äººæ¥æŽ¥æ°´ï¼Œå‘¨å›´åˆæ²¡æœ‰å¤šå°‘äººï¼Œå…ˆåŽ»äº¤äº†æ°´è´¹åœ¨å›žæ¥å§ å¦‚æžœæœ‰äººæ¥æŽ¥æ°´ï¼Œçœ‹åˆ°æˆ‘çš„æ¡¶åœ¨ä¸Šé¢ï¼Œåº”è¯¥ä¼šæŠŠæˆ‘çš„æ¡¶æ‹¿ä¸‹æ¥å§ çŽ°åœ¨ï¼Œåœ¨å›žå¤´çœ‹æˆ‘çš„æƒ³æ³•ï¼Œç¡®å®žæ˜¯å¤©çœŸï¼Œä½ å°±è¿™ä¹ˆæ”¾å¿ƒåˆ«äººä¸ä¼šé¡ºæ‰‹ç‰µç¾Šç›´æŽ¥æŠŠä½ é‚£åˆšæŽ¥å¥½æ°´çš„æ¡¶ç›´æŽ¥æ‹¿èµ°å—ï¼Ÿç‰¹åˆ«æ˜¯åœ¨å‘¨å›´è¿˜æ²¡æœ‰ä»»ä½•ç›‘æŽ§è®¾å¤‡çš„æƒ…å†µä¸‹ï¼Œä¹Ÿæ²¡æœ‰è·Ÿå…¶ä»–äººæ‰“æ‹›å‘¼ã€‚ å›ºç„¶æ‹¿èµ°æˆ‘çš„æ¡¶çš„äººæ˜¯ä¸é“å¾·çš„ï¼Œä»–åº”è¯¥æŠŠæˆ‘çš„æ¡¶æ‹¿ä¸‹æ¥ç„¶åŽæ”¾åˆ°æ—è¾¹ï¼ˆå°½ç®¡æ¡¶å·²ç»æŽ¥å¥½äº†æ°´ï¼‰ï¼Œä½†æˆ‘åˆå¼ºçƒˆè§‰å¾—æ˜¯æˆ‘åœ¨è¿™ä»¶äº‹æƒ…ä¸Šçš„å¤„ç†æ˜¯é”™è¯¯çš„ã€‚å¦‚æžœæˆ‘æŽ¥äº†æ°´å…ˆé€å›žå®¶åŽ»ï¼Œç„¶åŽå†åŽ»äº¤æ°´è´¹ä¸è¡Œå—ï¼Ÿæ—¶é—´ä¸Šä¹Ÿæ˜¯æ¥çš„åŠçš„ï¼Œä¸ºä»€ä¹ˆä¼šæ€¥äºŽè¿™ä¸€æ—¶å‘¢ï¼Ÿä¸ç®¡ä½•æ—¶ä½•åœ°ï¼Œè¿˜æ˜¯è¦å¯¹å‘¨å›´çŽ¯å¢ƒä¿æŒè¾ƒé«˜çš„è­¦æƒ•æ€§æ‰è¡Œï¼Œå› ä¸ºä½ å¹¶ä¸çŸ¥é“éº»çƒ¦ä¼šä½•æ—¶æ‰¾ä¸Šèº«ã€‚æ›´ä¸èƒ½å®¹å¿è‡ªå·±çš„æ˜¯ï¼Œä¸œè¥¿é—å¤±äº†ï¼Œè¿žå¯»æ‰¾çš„çº¿ç´¢éƒ½æ²¡æœ‰ã€‚å°±å¥½æ¯”ï¼Œåœ¨é»‘æš—çš„çŽ¯å¢ƒä¸­ä¸Žäººææ–—ï¼Œä½ æ˜¯ä¼¸æ‰‹ä¸è§äº”æŒ‡ï¼Œè€Œä½ çš„æ•Œäººæ˜¯å¸¦ç€å¤œè§†ä»ªçš„ã€‚è¿™æ ·ä¸‹åŽ»ï¼Œå¤±è´¥çš„ä¸€æ–¹åªä¼šæ˜¯è‡ªå·±ã€‚ å°½ç®¡è¿™æ˜¯å°äº‹ï¼Œä½†æ˜¯ä»Žä¸­æŠ˜çŽ°å‡ºçš„è‡ªèº«æ‰€å­˜åœ¨çš„é—®é¢˜ä¸å®¹å°è§†ã€‚ 2021-12-8 ä»Šå¤©åˆç«™åœ¨é‚£ä½é¡ºæ‰‹ç‰µç¾Šçš„äººçš„è§’åº¦æƒ³äº†ä¸€ä¸‹ï¼Œå½“ä»–çœ‹åˆ°æœ‰ä¸€ä¸ªâ€œæ— äººè®¤é¢†â€ï¼ˆä»–è®¤ä¸ºæ˜¯è¿™æ ·ï¼‰çš„æ¡¶æ”¾åœ¨ä»–é¢å‰æ—¶ï¼Œä»–ç›´æŽ¥å°±æ‹¿èµ°äº†çš„è¿™ä¸ªè¡Œä¸ºï¼Œæ˜¯ä¸æ˜¯å°±å¥½æ¯”åœ¨å¤§é©¬è·¯ä¸Šæ¡äº†é’±ä¸€æ ·å‘¢ï¼Ÿå¦‚æžœæ˜¯æˆ‘æ¡äº†é’±ï¼Œé‚£æˆ‘ä¸€æ ·ä¹Ÿä¼šæ£è¿›è‡ªå·±çš„è…°åŒ…ï¼Œå½“ç„¶ï¼Œå¤±ä¸»è¦æ˜¯å°±åœ¨æ—è¾¹å°±å¦è°ˆäº†ï¼Œå› ä¸ºæˆ‘æ€•è¿™æ ·å¯èƒ½ä¼šè¢«æ‰“ã€‚ä½†å°±è¿™ä»¶äº‹è€Œè¨€ï¼Œè‡³å°‘æˆ‘ä½œä¸ºæ¡¶çš„ä¸»äººï¼Œå¹¶æ²¡æœ‰åœ¨çŽ°åœºç•™ä¸‹â€œæš‚æ—¶å­˜æ”¾ï¼Œè¯·å‹¿æ‹¿èµ°â€ä¹‹ç±»çš„ä¿¡æ¯ï¼Œä¹Ÿæ²¡æœ‰åœ¨ä»–æ‹¿èµ°ä¹‹æ—¶å‡ºæ¥é˜»æ­¢ä»–ã€‚å¦‚æžœä¸€å‘³çš„å°†å¸Œæœ›å¯„æ‰˜åœ¨åˆ«äººèº«ä¸Šï¼Œå¸Œæœ›åˆ«äººæ˜¯ä¸€ä¸ªé«˜ç´ è´¨çš„äººï¼Œæ˜¯ä¸€ä¸ªä¸ä¼šéšä¾¿æ‹¿ä¸æ˜¯è‡ªå·±ä¸œè¥¿çš„äººï¼Œè¿™ä¸ªæƒ³æ³•åœ¨ç›®å‰çš„ç¤¾ä¼šçŽ¯å¢ƒä¸‹ï¼Œæžœç„¶è¿˜æ˜¯ä¸çŽ°å®žçš„ï¼Œé‚£è¿™å°±åˆå›žåˆ°äº†è¿˜æ˜¯æˆ‘è‡ªå·±å¤ªå¤©çœŸçš„é—®é¢˜ä¸Šäº†ã€‚ ä¹‹æ‰€ä»¥åˆå†™è¿™äº›çš„ç›®çš„ï¼Œå…¶å®žæ˜¯æˆ‘ä¸å¤ªæƒ³åŽ»è¿‡åˆ†æŒ‡è´£æ‹¿æˆ‘æ¡¶çš„äººï¼Œå› ä¸ºæˆ‘è§‰å¾—å¯¹æ™®é€šçš„è€ç™¾å§“è€Œè¨€ï¼Œè¿™å…¶å®žæ˜¯â€œäººä¹‹å¸¸æƒ…â€ï¼Œä½†ä¸»è¦çš„é—®é¢˜è¿˜æ˜¯åœ¨æˆ‘ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ çš„ä¸€äº›æ¦‚å¿µ]]></title>
    <url>%2F2021%2F11%2F17%2FC%2B%2B-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[æ­¤æ–‡ç”¨äºŽè®°å½•å­¦ä¹  C++ è¿‡ç¨‹ä¸­é‡åˆ°çš„ä¸€äº›çŸ¥è¯†ç‚¹ã€‚ å‘½åç©ºé—´å‘½åç©ºé—´é‡Œé¢åŒ…å«äº†é€»è¾‘ç»“æž„ä¸Šç›¸äº’å…³è”çš„ä¸€ç»„ç±»ã€å‡½æ•°ã€æ¨¡æ¿ç­‰ã€‚å‘½åç©ºé—´åƒæ˜¯ä¸€ä¸ªå®¹å™¨ï¼ŒæŠŠæŸäº›åœ¨é€»è¾‘ç»“æž„ä¸Šç›¸å…³çš„â€œå¯¹è±¡â€æ”¾åœ¨ä¸€èµ·å¹¶ä¸Žå¤–ç•ŒåŒºåˆ†ã€‚ç‰¹åˆ«çš„ï¼Œå‘½åç©ºé—´é‡Œé¢çš„å˜é‡åæˆ–ç±»åå¯ä»¥å’Œå‘½åç©ºé—´å¤–çš„å˜é‡åå’Œç±»åé‡åã€‚ ä¿®é¥°ç¬¦signedã€unsignedã€shortã€long æ˜¯ C++ ä¸­çš„ä¿®é¥°ç¬¦ï¼Œå½“ short å’Œ long ç”¨æ¥ä¿®é¥° int æ—¶ï¼Œint å¯çœç•¥ä¸å†™ï¼Œè¡¨ç¤ºçŸ­æ•´åž‹æ•°æ®æˆ–é•¿æ•´åž‹æ•°æ®ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œæ²¡æœ‰ short å’Œ long è¿™ç§æ•°æ®ç±»åž‹ï¼‰ã€‚ å†…å­˜åˆ†é…C++ ç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œè®¡ç®—æœºå†…å­˜è¢«åˆ†ä¸ºç¨‹åºä»£ç åŒºã€å…¨å±€æ•°æ®åŒºã€å †åŒºã€æ ˆåŒºå››ä¸ªéƒ¨åˆ†ã€‚ é™æ€å­˜å‚¨åŒºåˆ†é…é™æ€åˆ†é…æ–¹å¼ä¸‹çš„å†…å­˜åœ¨ç¨‹åºç¼–è¯‘çš„æ—¶å€™å°±å·²ç»åˆ†é…å¥½äº†ä¸”å­˜åœ¨äºŽç¨‹åºçš„æ•´ä¸ªè¿è¡Œè¿‡ç¨‹ã€‚ä¾‹å¦‚ static å˜é‡ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸéšç¨‹åºçš„ç»“æŸè€Œç»“æŸï¼Œè€Œé£žåƒä¸€èˆ¬å˜é‡éšå‡½æ•°æˆ–ä½œç”¨åŸŸçš„ç»“æŸè€Œç»“æŸã€‚ å½“ç„¶ï¼Œé™¤äº† static å˜é‡ï¼Œè¿˜æœ‰ä¸€ç§å…¨å±€å¯¹è±¡ static objectï¼Œä¹Ÿå¯ä»¥å­˜æ”¾åœ¨é™æ€å­˜å‚¨åŒºã€‚ æ ˆå†…å­˜åˆ†é…æ ˆå†…å­˜åˆ†é…æ–¹å¼ä¸‹çš„å†…å­˜æ˜¯å­˜åœ¨äºŽæŸä½œç”¨åŸŸçš„ä¸€å—ç©ºé—´ã€‚ä¾‹å¦‚è°ƒç”¨æŸä¸ªå‡½æ•°æ—¶ï¼Œå‡½æ•°å†…å±€éƒ¨å˜é‡çš„å­˜å‚¨å•å…ƒå¯ä»¥åœ¨æ ˆä¸Šåˆ›å»ºï¼Œå‡½æ•°æ‰§è¡Œç»“æŸæ—¶ï¼Œè¿™äº›å†…å­˜å•å…ƒä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚ å †å†…å­˜åˆ†é…å †å†…å­˜åˆ†é…ï¼Œä¹Ÿç§°åŠ¨æ€å†…å­˜åˆ†é…ï¼Œé€šå¸¸ä½¿ç”¨ new å’Œ delete å…³é”®å­—è¿›è¡Œç®¡ç†ã€‚å †å†…å­˜ç©ºé—´å¯ç”±ç”¨äºŽæ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾ï¼Œæ‰€ä»¥å…¶ç”Ÿå­˜å‘¨æœŸç”±ç”¨æˆ·æŒ‡å®šï¼Œè¾ƒä¸ºçµæ´»ã€‚ä½†é¢‘ç¹çš„åˆ†é…ã€é‡Šæ”¾å¤§å°ä¸åŒçš„å †ç©ºé—´ä¼šäº§ç”Ÿå†…å­˜ç¢Žç‰‡ã€‚ å‡½æ•°é‡è½½å‡½æ•°é‡è½½æŒ‡å®šä¹‰ä¸€ä¸ªå‡½æ•°å‚æ•°ç±»åž‹æˆ–å‚æ•°ä¸ªæ•°ä¸åŒçš„é‡åå‡½æ•°ã€‚å½“ç¨‹åºæ‰§è¡Œæ—¶ï¼Œç¼–è¯‘å™¨å°†è°ƒç”¨å‚æ•°ç±»åž‹ä¸Žå‡½æ•°å½¢å‚ç±»åž‹ä¸€è‡´çš„å‡½æ•°ã€‚ é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡çš„ç‰¹ç‚¹è¿™éƒ¨åˆ†å†…å®¹éƒ½æ˜¯æ¦‚å¿µæ€§å†…å®¹ï¼Œåº”è¯¥ç®—æ˜¯æ‰€æœ‰é¢å‘å¯¹è±¡çš„ç¨‹åºè¯­è¨€çš„åŸºæœ¬ç‰¹æ€§ã€‚ æŠ½è±¡æŠ½è±¡æ˜¯æŒ‡å¯¹å…·ä½“é—®é¢˜æˆ–å¯¹è±¡è¿›è¡Œæ¦‚æ‹¬ï¼ŒæŠ½å‡ºå…¶å…¬å…±æ€§è´¨å¹¶åŠ ä»¥æè¿°çš„è¿‡ç¨‹ã€‚ä¸€èˆ¬æƒ…å†µæŠ½è±¡åˆ†ä¸ºæ•°æ®æŠ½è±¡å’Œè¡Œä¸ºæŠ½è±¡ï¼Œå…¶ä¸­æ•°æ®æŠ½è±¡æ˜¯æŒ‡ä¸€ä¸ªå¯¹è±¡åŒºåˆ«äºŽå¦ä¸€ä¸ªå¯¹è±¡çš„ç‰¹å¾ï¼Œè¡Œä¸ºæŠ½è±¡æ˜¯æŒ‡æŸç±»å¯¹è±¡çš„å…±åŒç‰¹å¾ã€‚ å°è£…å°è£…æ˜¯æŒ‡å°†æŠ½è±¡å¾—åˆ°çš„æ•°æ®å’Œè¡Œä¸ºç›¸ç»“åˆï¼Œéšè—å¯¹è±¡å±žæ€§å’Œå®žçŽ°ç»†èŠ‚ä¸”ä»…å¯¹å¤–æä¾›å…¬å…±è®¿é—®æ–¹å¼çš„è¿‡ç¨‹ã€‚ ç»§æ‰¿ç»§æ‰¿æ˜¯æŒ‡é€šè¿‡ä»£ç å¤ç”¨åœ¨ä¿æŒåŽŸæœ‰ç±»ç‰¹æ€§çš„åŸºç¡€ä¸Šå¯¹å­ç±»è¿›è¡Œå…·ä½“è¯´æ˜Žçš„è¿‡ç¨‹ï¼Œé€šä¿—æ¥è¯´ç»§æ‰¿å°±æ˜¯ç²¾ç®€é‡å¤ä»£ç çš„æ‰‹æ®µã€‚ å¤šæ€å¤šæ€æ˜¯æŒ‡ä¸€æ®µç¨‹åºèƒ½å¤Ÿå¤„ç†å¤šç§ç±»åž‹å¯¹è±¡çš„èƒ½åŠ›ï¼Œå‡½æ•°é‡è½½å°±æ˜¯å®žçŽ°å¤šæ€çš„ä¸€ç§æ‰‹æ®µã€‚åœ¨ C++ ä¸­ï¼Œå¤šæ€å¯åˆ†ä¸ºå¼ºåˆ¶å¤šæ€ã€é‡è½½å¤šæ€ã€ç±»åž‹å‚æ•°åŒ–å¤šæ€å’ŒåŒ…å«å¤šæ€ã€‚ ç±»ç±»ä¸€èˆ¬æ˜¯ç”±ç±»åã€æ•°æ®æˆå‘˜ã€å‡½æ•°æˆå‘˜ä¸‰éƒ¨åˆ†ç»„æˆã€‚å®šä¹‰ç±»çš„åŸºæœ¬å½¢å¼ä¸ºï¼š12345678class name &#123; public: å¤–éƒ¨æŽ¥å£ protected: ä¿æŠ¤æ€§æˆå‘˜ private: ç§æœ‰æˆå‘˜&#125; å…¶ä¸­ publicã€protectedã€private è¡¨ç¤ºè®¿é—®æŽ§åˆ¶å±žæ€§ï¼Œç”¨äºŽæŽ§åˆ¶ç±»æˆå‘˜çš„è®¿é—®æƒé™ã€‚ç‰¹åˆ«çš„ï¼Œæ²¡æœ‰åˆ†é…æŽ§åˆ¶å±žæ€§çš„é»˜è®¤ä¸º private ç§æœ‰æˆå‘˜ã€‚public æˆå‘˜å¯ä»¥åœ¨ç±»å¤–ç›´æŽ¥è®¿é—®ï¼›protected æˆå‘˜å¯ä»¥åœ¨å­ç±»ä¸­è®¿é—®ï¼›private æˆå‘˜åªèƒ½è¢«æœ¬ç±»çš„æˆå‘˜å‡½æ•°è®¿é—®ã€‚ ç±»çš„æˆå‘˜å‡½æ•°æˆå‘˜å‡½æ•°æè¿°äº†ç±»çš„è¡Œä¸ºã€‚æˆå‘˜å‡½æ•°åœ¨ç±»ä¸­åªç”¨è¯´æ˜Žå…¶å‡½æ•°çš„è¿”å›žç±»åž‹ã€åå­—å’Œå‚æ•°è¡¨ï¼Œè€Œå‡½æ•°çš„å…·ä½“å®žçŽ°åœ¨ç±»å¤–è¯´æ˜Žï¼Œå…¶åŸºæœ¬å½¢å¼ä¸ºï¼š1234567class name &#123; å‡½æ•°çš„è¿”å›žç±»åž‹ å‡½æ•°å(å‚æ•°åˆ—è¡¨)&#125;;è¿”å›žå€¼ç±»åž‹ ç±»å::å‡½æ•°å(å‚æ•°åˆ—è¡¨) &#123; å‡½æ•°ä½“&#125; å¯¹è±¡åœ¨ C++ ä¸­ï¼Œå¯¹è±¡æ˜¯æŸç±»äº‹ç‰©çš„å®žä¾‹ï¼Œå…¶å£°æ˜Žå½¢å¼ä¸ºï¼š1ç±»å å¯¹è±¡å; å¼•ç”¨å¼•ç”¨ä¸ŽæŒ‡é’ˆä¸»è¦æœ‰ä¸‰ä¸ªåŒºåˆ«ï¼š å¯ä»¥é€šè¿‡*p = 0æˆ–è€…*p = NULLæ¥æè¿°ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œä½†ä¸å­˜åœ¨ç©ºå¼•ç”¨ã€‚ æŒ‡é’ˆå¯åœ¨ä»»ä½•æ—¶é—´è¿›è¡Œåˆå§‹åŒ–æ“ä½œï¼Œè€Œå¼•ç”¨åªèƒ½å®šä¹‰æ—¶è¿›è¡Œåˆå§‹åŒ–æ“ä½œã€‚ æŒ‡é’ˆå˜é‡æŒ‡å‘å†…å­˜çš„ä¸€ä¸ªå­˜å‚¨å•å…ƒï¼Œè€Œå¼•ç”¨åªä¸è¿‡æ˜¯åŽŸå˜é‡çš„ä¸€ä¸ªåˆ«åè€Œå·²ã€‚ å†…å­˜æ³„æ¼å†…å­˜æ³„æ¼çš„å¯èƒ½åœºæ™¯å¾ˆå¤šï¼Œä½†é€šä¿—æ¥è®²ï¼Œå†…å­˜æ³„æ¼åº”è¯¥å«â€œå†…å­˜é—²ç½®â€æ›´åˆé€‚ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå†…å­˜æ³„æ¼å…¶å®žæŒ‡çš„å°±æ˜¯ç¨‹åºåœ¨ç»“æŸä¹‹å‰ï¼Œç”³è¯·çš„å†…å­˜åœ¨ç”¨å®Œä¹‹åŽï¼Œæ²¡æœ‰è¢«é‡Šæ”¾æŽ‰ï¼Œé‚£ä¹ˆç¨‹åºå†æ¬¡éœ€è¦å†…å­˜çš„æ—¶å€™ï¼Œå°±æ— æ³•å†ä½¿ç”¨è¿™å—å†…å­˜äº†ï¼Œåªèƒ½å†æ¢ä¸€æ•´å—äº†ã€‚å½“ç„¶äº†ï¼Œè¿™åªæ˜¯é€šä¿—çš„ç†è§£æ–¹å¼ï¼Œå¹¶ä¸æ˜¯é‚£ä¹ˆä¸¥è°¨ã€‚ è¯­è¨€ç±»åž‹C++ æ˜¯ä¸€ç§é™æ€æ•°æ®ç±»åž‹è¯­è¨€ï¼Œå®ƒçš„ç±»åž‹æ£€æŸ¥å‘ç”Ÿåœ¨ç¼–è¯‘æ—¶ã€‚å› æ­¤ï¼Œç¼–è¯‘å™¨å¿…é¡»çŸ¥é“ç¨‹åºä¸­æ¯ä¸€ä¸ªå˜é‡å¯¹åº”çš„æ•°æ®ç±»åž‹ã€‚ä¸Žä¹‹ç›¸åçš„ï¼ŒPython çš„ç±»åž‹æ£€æŸ¥æ˜¯åœ¨ç¨‹åºè¿è¡Œæ—¶è¿›è¡Œçš„ã€‚ å†…ç½®ç±»åž‹C++ çš„åŸºæœ¬å†…ç½®ç±»åž‹åŒ…æ‹¬ä¸¤éƒ¨åˆ†ï¼šç®—æ•°ç±»åž‹å’Œç©ºç±»åž‹ã€‚ç®—æ•°ç±»åž‹åŒ…å«äº†å­—ç¬¦ã€æ•´æ•°åž‹ã€å¸ƒå°”å€¼å’Œæµ®ç‚¹æ•°ï¼Œç©ºç±»åž‹ä¸å¯¹åº”å…·ä½“çš„å€¼ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½®æ»‘åˆæŽ¢]]></title>
    <url>%2F2021%2F11%2F13%2F%E8%BD%AE%E6%BB%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[é¬¼ä½¿ç¥žå·®çš„ä¹°äº†ä¸€åŒç›´æŽ’è½®æ»‘éž‹å­ï¼ðŸ˜‘ è¯ºï¼å°±æ˜¯ä¸‹é¢è¿™ä¸ªä¸œè¥¿ï¼š äº‹æƒ…èµ·å› æ˜¯è¿™æ ·çš„ï¼šä¸´è¿‘åŒåä¸€äº†ï¼Œæƒ³ç€æ˜¯ä¸æ˜¯ä¹°ç‚¹ä»€ä¹ˆä¸œè¥¿ï¼Œå¤©å¤©åœ¨å®¶é—²ç€ï¼Œå¶å°”å‡ºé—¨å‘çŽ°èµ°è·¯æŒºè¿œçš„ï¼Œæœ€è¿‘ä¹Ÿæ²¡æœ‰éª‘è½¦äº†ï¼Œæ˜¯ä¸æ˜¯æ•´ä¸ªä»£æ­¥å·¥å…·ï¼Ÿä»¥æ¥å¯ä»¥æé«˜ä¸‹â€œæ•ˆçŽ‡â€ï¼ŒäºŒæ¥é¡ºä¾¿é”»ç‚¼èº«ä½“ã€‚ ç»“æžœå°±è¿™æ ·é¬¼ä½¿ç¥žå·®çš„æƒ³åˆ°äº†è½®æ»‘è·Ÿæ»‘æ¿ï¼Œæ»‘æ¿å…¶å®žæ˜¯åŽ»å¹´å°±å¼€å§‹æƒ³å°è¯•çŽ©çŽ©çš„ä¸œè¥¿äº†ï¼Œè¿™æ¬¡è¿˜æ˜¯å¿ä½äº†ã€‚è€ƒè™‘åˆ°äºŒè€…éƒ½æ˜¯éœ€è¦èº«ä½“å¹³è¡¡æ€§çš„ä½“è‚²æ´»åŠ¨ï¼Œç´¢æ€§å°±ä¹°è½®æ»‘éž‹å­äº†ã€‚ä¸»è¦è¿˜æ˜¯æ»‘æ¿å™ªéŸ³æœ‰ç‚¹å¤§ï¼Œè¿™çŽ©æ„å¥½åƒä¸æ€Žä¹ˆåµï¼Ÿ å…·ä½“æ„Ÿå—å¦‚ä½•ï¼Œè¦ç­‰çŽ©ä¸€çŽ©ä¹‹åŽæ‰èƒ½åˆ†æžã€‚ ä¸è¿‡ï¼Œæ‹¿è¿™ä¸œè¥¿å½“ä»£æ­¥å·¥å…·çš„æˆ‘ï¼Œæ˜¯ä¸æ˜¯åˆè½ä¼äº†ï¼Ÿäººå®¶çš„ä»£æ­¥å·¥å…·å¯æ˜¯å››ä¸ªè½®å­çš„è½¦å•Šï¼è¯¶ï¼Ÿçªç„¶å‘çŽ°ï¼Œè¿™çŽ©æ„å¥½åƒå•è„šå››è½®ï¼ŒåŒè„šå…«è½®ï¼Œå¾—ï¼Œå½“æˆ‘æ²¡è¯´ã€‚ ä¸ç®¡å¦‚ä½•ï¼Œè½®æ»‘æœ¬è´¨æ˜¯ä¸€ç§ä½“è‚²æ´»åŠ¨ã€‚å½“ç„¶äº†ï¼Œè‡³å°‘ç›®å‰è€Œè¨€ï¼Œç¡®å®žå¯ä»¥æ»¡è¶³æˆ‘çš„éœ€æ±‚ï¼š ä»£æ­¥ é”»ç‚¼ å¥½å§ï¼ŒçŽ°åœ¨æ˜¯ 2021 å¹´ 11 æœˆ 13 æ—¥ï¼Œä»Šå¤©æ˜¯ç¬¬ä¸€å¤©è§åˆ°è¿™ä½å…„å¼Ÿï¼Œå¸Œæœ›å®ƒå¥½å¥½å¾…æˆ‘ï¼Œå°‘è®©ç»™æˆ‘æ‘”å‡ è·¤ã€‚\ æ—¥æœŸï¼š2021-11-14ä¸‹åˆè¶ç€é˜³å…‰æ˜Žåªšçš„æ—¶å€™ï¼ŒæŠ˜è…¾äº† 2 ä¸ªå°æ—¶ï¼Œæ‘”äº†å¥½å‡ æ¬¡ã€‚ç‰¹åˆ«æœ‰ä¸€æ¬¡æ˜¯å®Œå…¨å¤±åŽ»å¹³è¡¡ï¼Œå±è‚¡ï¼ˆå‡†ç¡®è¯´æ˜¯å°¾æ¤Žéª¨ï¼‰å¤§é¢ç§¯ç€åœ°ï¼Œå½“ä¸‹è§‰å¾—å±è‚¡å¼€èŠ±äº†ï¼Œé‚£å«ä¸€ä¸ªç–¼ï¼Œå…‰æ˜¯é‡æ–°å†ç«™èµ·æ¥å°±èŠ±äº†å‡ åˆ†é’Ÿã€‚ ç»ƒä¹ æ—¶é—´æ˜¯ 2 å°æ—¶æ²¡é”™ï¼Œä½†æ˜¯è‡ªæˆ‘æ„Ÿè§‰æ”¶æ•ˆç”šå¾®ã€‚ä»”ç»†ç¢ç£¨äº†ä¸€ä¸‹ï¼Œæ²¡æƒ³å‡ºä¸ªæ‰€ä»¥ç„¶ï¼Œç»“æžœåˆåŽ»æ‰¾äº†ç‚¹è§†é¢‘çœ‹ï¼Œå‘çŽ°å¥½åƒæ˜¯è‡ªå·±å¤ªç€æ€¥äº†ã€‚å¤§æ¦‚æ„æ€å°±æ˜¯ç›®å‰è¿žèµ°éƒ½æ²¡å­¦ä¼šå°±æƒ³è·‘äº†ï¼Œæ²¡åŠžæ³•ï¼Œæ™šä¸Šåˆç»ƒä¹ äº†å‡ ç™¾æ¬¡åŽŸåœ°è¸æ­¥ï¼Œè¹²ä¸‹ç«™èµ·ï¼ŒåŽæ¥åˆå°è¯•äº†ä¸€ä¸‹æ»‘è¡Œï¼Œå¥½åƒæ‰¾åˆ°äº†ç‚¹æ„Ÿè§‰ï¼Ÿä½†é—æ†¾çš„æ˜¯ï¼Œä¸ä¼šæ‹å¼¯ :(ã€‚ æ—¥æœŸï¼š2021-11-15å‚æ™šç»ƒä¹ äº†å¤§æ¦‚ä¸€ä¸ªå¤šå°æ—¶ï¼Œåªæ˜¯ç»ƒä¹ è¿‘è·ç¦»çš„æŽ¨æ­¥æ»‘è¡Œå’Œå¹³è¡¡å‰æ»‘ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼ŒåŸºæœ¬ä¸Šæ„Ÿè§‰å¤§æ¦‚æœ‰äº†å§ã€‚ç„¶åŽåˆå°è¯•äº†ä¸‹åˆ¹è½¦è·Ÿè½¬å¼¯ï¼Œæ„Ÿè§‰åˆ¹è½¦ä¼šå®¹æ˜“ä¸€ç‚¹ï¼Œä½†æ˜¯è½¬å¼¯ä¸€ç‚¹æ„Ÿè§‰éƒ½æ²¡æŠ“ä½ï¼Œå¯èƒ½è¿˜éœ€è¦åœ¨å¤šæ‘”å‡ æ¬¡æ‰èƒ½æœ‰æ„Ÿè§‰å§ã€‚æ˜¯çš„ï¼Œæˆ‘çŽ°åœ¨æœ‰ç‚¹åŽæ‚”æ²¡ä¹°æŠ¤å…·äº†ï¼Œè¿™æ ·æˆ‘æ´»åŠ¨çš„æ—¶å€™ä¹Ÿæ”¾å¾—å¼€ä¸€ç‚¹ï¼Œä¸è‡³äºŽçŽ°åœ¨æœ‰ç‚¹ç•æ‰‹ç•è„šçš„ï¼ˆæ¯•ç«Ÿæ˜¨å¤©çš„å±è‚¡è¿˜åŽ†åŽ†åœ¨ç›®ï¼Œä¸è¿‡å·²ç»å¥½å¤šäº†ï¼‰ã€‚ ç»ƒä¹ çš„æ—¶å€™çªç„¶æƒ³èµ·æ¥å°æ—¶å€™å­¦éª‘è‡ªè¡Œè½¦çš„æ—¶å€™äº†ï¼Œé•¿è¾ˆåœ¨åŽé¢æ‰¶ç€åº§æ¤…ï¼Œæˆ‘åœ¨å‰é¢éª‘ï¼Œä»–ä»¬çªç„¶æ¾å¼€æ‰‹ï¼Œéª—æˆ‘è¿˜æ²¡æœ‰ï¼Œç„¶åŽæˆ‘æŽ¥ç€éª‘ï¼Œéª‘ç€éª‘ç€å°±ä¼šäº†ã€‚å…¶å®žï¼Œè½®æ»‘åº”è¯¥ä¹Ÿæ˜¯ä¸€æ ·ï¼Œå…³é”®å°±æ˜¯è¦æ‰¾åˆ°èº«ä½“çš„æ‰€é€‚åº”çš„å¹³è¡¡æ„Ÿã€‚å¦‚ä½•åŽ»æ‰¾å‘¢ï¼Ÿåªæœ‰å¤§èƒ†å°è¯•ï¼Œå¤šæ‘”å‡ æ¬¡ï¼Œåº”è¯¥å°±èƒ½æ‰¾åˆ°äº†ã€‚é—æ†¾çš„æ˜¯ï¼Œæˆ‘å¹¶æ²¡æœ‰æŠ¤å…·æ¥æ”¯æ’‘æˆ‘åšè¿™æ ·çš„äº‹æƒ…ï¼Œä½†ä¸ç®¡å¦‚ä½•è¿˜æ˜¯è¦ç»§ç»­ç»ƒä¹ ä¸‹åŽ»ã€‚ æ—¥æœŸï¼š2021-11-16å“ˆï¼Œä»Šå¤©æ„Ÿè§‰è¿˜è¡Œï¼Œç»ƒä¹ æ—¶é—´åœ¨ä¸€ä¸ªåŠå°æ—¶å·¦å³ï¼Œæ‘”äº†å››æ¬¡ï¼Œä¸è¿‡å¥½åœ¨æ²¡æœ‰å—å¤§ä¼¤ï¼Œå°±æ˜¯å³æ‰‹æ‰‹æŽŒä¸å°å¿ƒæŒ‚äº†ä¸ªå½©ï¼Œä¸€ä¸ªå°ä¼¤å£ï¼Œå†æ¬¡è¯´æ˜Žäº†æŠ¤å…·å¯¹åˆå­¦è€…çš„é‡è¦æ€§ã€‚ä¸è¿‡ï¼Œæˆ‘å¥½åƒæœ‰ä¸€ä¸ªå¯ä»¥ä¿æŠ¤æ‰‹æŽŒçš„â€œæŠ¤å…·â€ï¼Œæ˜Žå¤©å¯ä»¥è¯•ä¸€è¯•ã€‚ è¯è¯´ï¼Œä»Šå¤©å·®ç‚¹åˆ·äº†ä¸ªå˜´å•ƒæ³¥ï¼Œå¥½åœ¨æ‰‹æ”¯æ’‘ä½äº†ã€‚è¿˜æœ‰ä¸€æ¬¡ï¼Œå·®ç‚¹æ ½åˆ°äººå®¶é¸¡ç¬¼é‡Œé¢äº† XDã€‚æ€»ä¹‹ï¼Œæ²¡å—å¤§ä¼¤å°±å¥½ã€‚ ä»Šå¤©ä¸»è¦çš„ç»ƒä¹ å†…å®¹æ˜¯æŽ¨æ­¥æ»‘è¡Œå’Œå¹³è¡¡å‰æ»‘ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼Œå°±æ˜¯åŠ¨ä½œå§¿åŠ¿è¿˜æ˜¯æœ‰äº›ä¸åˆ°ä½ã€‚ æ—¥æœŸï¼š2021-11-17å³è…¿è†ç›–å¢žåŠ ä¸€å¤„æ“¦ä¼¤ï¼Œè¿˜å¥½åªæ˜¯è½»å¾®ã€‚è¯è¯´ï¼Œä»Šå¤©ç»•ç€å®¶æ»‘äº†ä¸€åœˆï¼Œä¸å¾—ä¸åæ§½ä¸‹å†œæ‘çš„æ°´æ³¥è·¯ï¼Œæœ‰äº›è·¯æ®µæ¨ªæ¡çº¹å¤ªå¤šäº†ï¼Œè„šåœ¨ä¸Šæ»‘è¿‡æ—¶ï¼Œé¢ çš„æˆ‘è„šéƒ½éº»äº†ï¼Œç«™éƒ½ç«™ä¸ç¨³äº†ï¼Œç‰¹åˆ«å®¹æ˜“æ‘”ï¼ˆä¸è¿‡ï¼Œåè¿‡æ¥æƒ³å¥½åƒä¹Ÿèƒ½é”»ç‚¼ä¸€ä¸‹å¹³è¡¡æ„Ÿï¼ŸðŸ¤”ï¼‰ã€‚æ²¡æœ‰æ¨ªæ¡çº¹çš„è·¯æ®µï¼Œé‚£æ»‘çš„å°±å¾ˆèˆ’æœäº†ï¼Œè„šä¸Šæ²¡æœ‰é¢ ç°¸æ„Ÿï¼Œå¾ˆç¨³å½“ï¼Œç´¯äº†å°±å¹³è¡¡å‰æ»‘æºœä¸€ä¸‹ï¼Œç„¶åŽå†æ»‘ï¼Œå½“ç„¶æ»‘çš„æ—¶é—´å¤ªé•¿äº†ï¼Œä¹Ÿè¿˜æ˜¯è¦ä¼‘æ¯ä¸‹çš„ã€‚ å‰å‡ å¤©ç»ƒä¹ è½¬å¼¯ä¸€ç‚¹æ„Ÿè§‰æ²¡æœ‰ï¼Œä»Šå¤©å°è¯•äº†ä¸‹ï¼Œå¥½åƒæœ‰ç‚¹æ„Ÿè§‰ï¼Œå°±è·Ÿäººèµ°è·¯è½¬å¼¯ä¸€æ ·ï¼Œä¸ç”¨éžå¾—ä¸åŠ¨ï¼Œå¯ä»¥è¿ˆå°æ­¥æ»‘è¿‡å¼¯ã€‚ è¿˜æœ‰ä¸€ç‚¹æ—¶è§‰å¾—è‡ªå·±ä½“åŠ›ä¸å¤ªå¤Ÿï¼Œæ»‘ä¸äº†å¤ªè¿œå°±è§‰å¾—è…°é…¸ï¼Œè¿™æ˜¯ä»€ä¹ˆâ€œæ¯›ç—…â€ï¼Ÿè¿˜æ˜¯æˆ‘çš„å§¿åŠ¿æœ‰äº›ä¸åˆ°ä½ï¼Œä½¿å¾—æˆ‘çš„è…°è‚Œè´Ÿè·è¿‡å¤§ï¼Œæ‰€ä»¥å¾ˆå¿«å°±è§‰å¾—ç´¯äº†ï¼Ÿ æ—¥æœŸï¼š2021-11-18ä»Šå¤©æ»‘çš„å¾ˆç´¯ï¼Œä½†æ˜¯æ„Ÿè§‰å¾ˆå¥½ï¼ŒçŽ°åœ¨å¤§æ¦‚èƒ½æŒç»­æ»‘è¡Œæ¯”è¾ƒä¹…äº†ï¼Œå¯¹äºŽä¹‹å‰çš„é—®é¢˜ï¼Œä»Šå¤©å¯ä»¥ç¨å¾®å›žç­”ä¸€ä¸‹äº†ï¼š æ»‘ä¸äº†å¤ªè¿œå°±è§‰å¾—ç´¯ï¼Œæ˜¯ä¸æ˜¯å§¿åŠ¿ä¸å¯¹ï¼Ÿå‡†ç¡®æ¥è®²ï¼Œä¸æ˜¯å§¿åŠ¿ä¸å¯¹ï¼Œè€Œæ˜¯å§¿åŠ¿ç»´æŒçš„å¤ªä¹…äº†ã€‚æ»‘è¡Œçš„æ—¶å€™ï¼Œä¸ºäº†ä¿æŒèº«ä½“çš„å¹³è¡¡æ„Ÿï¼Œä¸€èˆ¬ä¼šç•¥å¾®å±ˆè†ï¼Œèº«ä½“å‰å€¾ã€‚å¾ˆæ˜¾ç„¶ï¼Œå³ä¾¿æ²¡æœ‰ç©¿è½®æ»‘éž‹ï¼Œå°±åœ¨å¹³åœ°ä¸Šç»´æŒè¿™ä¸ªå§¿åŠ¿ä¹Ÿå¾ˆç´¯ï¼Œæ›´ä½•å†µæ˜¯ç©¿äº†è½®æ»‘éž‹ã€‚æ‰€ä»¥ï¼Œåº”è¯¥åœ¨æ»‘è¡Œçš„æ—¶å€™åº”è¯¥è¦ç›´ç«‹èµ·æ¥ï¼Œå½“ç„¶äº†ï¼Œç›´ç«‹å¿…é¡»è¦å»ºç«‹åœ¨ç»´æŒäº†å¹³è¡¡çš„åŸºç¡€ä¸Šï¼Œä¸ç„¶å°±æ‘”è·¤äº†ã€‚è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯ï¼Œèº«ä½“å°½å¯èƒ½çš„è¦æ”¾æ¾ï¼Œä¸è¦å¤ªåƒµç¡¬äº†ï¼Œè‚Œè‚‰å¤ªç´§å¼ äº†ï¼Œä¹Ÿä¼šå®¹æ˜“äº§ç”Ÿç–²åŠ³ã€‚ å¦‚ä½•è½¬å¼¯ï¼Ÿè½¬å¼¯å…¶å®žå¯ä»¥è¾¹æ»‘è¾¹è½¬ï¼ˆåªè¦æ­¥å­è¿ˆå°ç‚¹ï¼‰ï¼Œä¹Ÿå¯ä»¥æ»‘ç€è½¬ã€‚æ»‘ç€è½¬å…¶å®žå°±æ˜¯ A å­—è½¬å¼¯ï¼Œè¿™ä¸ªåŠ¨ä½œçš„é‡ç‚¹åœ¨äºŽè¦ä½¿ç”¨éž‹å­çš„å†…åˆƒï¼Œè‡³äºŽè…¿ç»·ç´§å…¶å®žåªæ˜¯è¾…åŠ©çš„ä½œç”¨ã€‚å¾€é‚£è¾¹è½¬ï¼Œå°±ç”¨é‚£åªè„šçš„éŸ§ã€‚ è¯è¯´ï¼Œä»Šå¤©å°è¯•äº†ä¸‹å†²å¡ï¼Œæžœç„¶ï¼Œä¸¤æ¬¡éƒ½æ‘”äº†ã€‚è¿˜æœ‰ä¸€æ¬¡ï¼Œæ»‘äº†å¤ªä¹…ï¼Œå¾ˆç´¯ï¼Œè„šçªç„¶ä¸€ä¸‹æ²¡åŠ²äº†ï¼Œç›´æŽ¥æ ½è‰ä¸›é‡Œäº†ï¼Œ2333ã€‚å¯¹äº†ï¼Œä»Šå¤©æœ‰å¥½å‡ æ¬¡å·®ç‚¹è¦æ‘”è·¤ï¼Œç»“æžœéƒ½å¥‡æ€ªçš„ç¨³ä½äº†ï¼Œå¾ˆè¯§å¼‚ï¼Œåº”è¯¥æ˜¯èº«ä½“å¯¹è¿™ç§å¤±åŽ»å¹³è¡¡çš„æ„Ÿè§‰é€‚åº”äº†ä¸€äº›å§ã€‚ ä»Šå¤©åŸºæœ¬æ²¡åœè¿‡ï¼Œä¸€ç›´åœ¨æ»‘ï¼Œæ»‘äº†å¤§æ¦‚ 3 ä¸ªå°æ—¶ï¼Œæœ€åŽä¸€ä¸ªå°æ—¶åŽ»è¡—ä¸ŠçŽ©äº†ä¸€ä¸‹ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼Œä¹Ÿä¸æ˜¯å¾ˆéš¾ã€‚æœ€åŽï¼Œè„±ä¸‹éž‹å­çš„é‚£ä¸€åˆ»æ˜¯çœŸçš„æ„Ÿè§‰å…¨èº«æœ‰ç‚¹é…¸äº†ï¼Œå‡ºæ±—çš„æ„Ÿè§‰è¿˜æ˜¯å¥½å•Šã€‚ æ—¥æœŸï¼š2021-11-19å°è¯•äº†ä¸€ä¸‹â€œé•¿é€”â€æ»‘è¡Œï¼Œä¸€åŽ»ä¸€æ¥ï¼Œä¸€èµ·æ˜¯ 10 å…¬é‡Œï¼ŒèŠ±äº†å¤§æ¦‚ 1 ä¸ªå°æ—¶ï¼Œçœ‹æ¥çŽ°åœ¨è‡ªå·±çš„æ»‘è¡Œé€Ÿåº¦å¤§æ¦‚ä¹Ÿå°± 8 - 10 km/h äº†å§ï¼Œè¿™ä¸ªé€Ÿåº¦å…·ä½“æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿå°±è·Ÿæ…¢æ…¢éª‘è‡ªè¡Œè½¦ä¸€æ ·ã€‚ æ•´ä¸ªæ»‘è¡Œè¿‡ç¨‹æ˜¯åœ¨å›½é“å…¬è·¯ä¸Šè¿›è¡Œçš„ï¼Œè™½ç„¶æ˜¯åœ¨åœ¨å…¬è·¯è¾¹ä¸Šæ»‘è¡Œï¼Œä½†ä¹Ÿè¦æ³¨æ„åŽæ–¹çš„è½¦è¾†ï¼Œæ³¨æ„ä¸è¦åå‘æ»‘è¡Œï¼Œè¦éµå®ˆåŸºæœ¬çš„äº¤é€šè§„åˆ™ï¼Œè¦æˆ´å¥½æŠ¤å…·ã€‚å…¬è·¯æ»‘è¡Œçš„æ—¶å€™ï¼Œè¦å°å¿ƒè·¯ä¸Šçš„å°çŸ³å¤´ï¼Œå½“é€Ÿåº¦è¿‡å¿«çš„æ—¶å€™ï¼Œè½®å­ä¸€æ—¦ç¢°åˆ°è¿™äº›çŸ³å¤´å°±ä¼šçªç„¶åƒå‰å†²ä¸€ä¸‹ï¼Œå®¹æ˜“æ‘”è·¤ï¼Œæ‰€ä»¥è¦å°å¿ƒã€æ…¢é€Ÿã€‚æ¯å½“è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘å°±åŽæ‚”ä¸ºä»€ä¹ˆæ²¡æœ‰ä¹°æŠ¤å…·ã€‚è¯´å®žåœ¨çš„ï¼Œå¦‚æžœæ˜¯é«˜é€Ÿå…¬è·¯çš„è¯ï¼ŒåŸºæœ¬ä¸ä¼šæœ‰è¿™ç§é—®é¢˜ï¼Œç›¸æ¯”å›½é“è€Œè¨€ï¼Œé«˜é€Ÿå…¬è·¯äº§ç”Ÿçš„æ‘©æ“¦åŠ›ä¹Ÿä¼šå°å¾ˆå¤šï¼Œä¹Ÿä¼šæ›´åŠ çœåŠ›ã€‚ä½†é—æ†¾çš„æ˜¯ï¼Œé‚£æ˜¯é«˜é€Ÿå…¬è·¯ï¼Œä¸æ˜¯é«˜é€Ÿâ€œæ»‘é“â€ï¼Œè¿™è·¯æ˜¯ç»™è½¦è·‘çš„ã€‚ ä»Žæ‹¿åˆ°è½®æ»‘éž‹åˆ°ä»Šå¤©ä¸ºæ­¢ï¼Œå·®ä¸å¤šä¸€å‘¨äº†å§ï¼ŒåŸºæœ¬çš„æ»‘è¡Œä¸Žä¸œè¥¿å¥½åƒæŽŒæ¡äº†ï¼Œä½†è¿˜ä¸æ˜¯å¾ˆç‰¢å›ºã€‚è¿™ä¸¤å¤©åœ¨è¡—ä¸Šæ»‘è¡Œçš„åŠ¨ä½œå…¶å®žå·²ç»ä¸æ˜¯åˆšå¼€å§‹å­¦çš„æŽ¨æ­¥æ»‘è¡Œäº†ï¼Œä¹‹å‰ä¸€ç›´è§‰å¾—è‡ªå·±æ€»æ˜¯å–œæ¬¢ç”¨å†…åˆƒï¼ŒçŽ°åœ¨å‘çŽ°ï¼Œåœ¨è¡—ä¸Šæ»‘è¡Œçš„æ—¶å€™ï¼Œè„šå…¶å®žæ˜¯æœ‰ä¸€ä¸ªä¸Šå‰è¹¬çš„åŠ¨ä½œçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸¤è„šäº¤æ›¿æ»‘è¡Œçš„æ—¶å€™ï¼Œå…¶å®žæ˜¯åœ¨äº¤æ›¿å‘å‰è¹¬ï¼Œè¿™æ—¶ä¹Ÿå°±å¿…ç„¶ä¼šæœ‰ä¸€åªè„šåœ¨å‰æ–¹ï¼Œä¸€åªè„šåœ¨åŽæ–¹ï¼Œå¾ˆæ˜¾ç„¶ï¼Œåœ¨åŽé¢çš„é‚£åªè„šè¹¬åœ°çš„æ—¶å€™ï¼Œå°±ä¼šç”¨åˆ°å†…åˆƒã€‚ æ€»ä½“è€Œè¨€ï¼Œæ»‘è¡Œæ—¶é—´ä¸é•¿ï¼Œä½†æˆ‘æ€»è§‰å¾—è½®æ»‘è¿™ä¸ªä¸œè¥¿ç†è®ºå  40%ï¼Œå®žé™…å  60%ï¼Œæ›´å¤šè¿˜æ˜¯è¦é èº«ä½“åŽ»æ„Ÿå—ï¼Œè¦é èº«ä½“åŽ»ç†Ÿæ‚‰è¸©åœ¨è½®å­ä¸Šçš„å¹³è¡¡æ„Ÿï¼Œæ„Ÿè§‰è‡ªå·±å…¶å®žç®—æ˜¯æ»‘ç€æ»‘ç€å°±ä¼šäº†ï¼Œä¹Ÿæ²¡æœ‰è¿‡åˆ†çš„åŽ»è¿½æ±‚åŠ¨ä½œå§¿åŠ¿ï¼Œæ›´å¤šçš„è¿˜æ˜¯é èº«ä½“æ„Ÿå—å¹³è¡¡ã€‚ä¸è¿‡ï¼Œåœ¨æ»‘è¡Œè¿‡ç¨‹ä¸­ï¼Œå§¿åŠ¿ä¹Ÿè¿˜æ˜¯è¦å°½é‡ä¿æŒæ­£ç¡®çš„ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥æ»‘çš„æ›´å¿«ã€æ›´çœåŠ›ã€‚å¦å¤–è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯ï¼ŒæŠ¤å…·æ˜¯éœ€è¦çš„ï¼Œæˆ‘å‘è§‰æˆ‘æ²¡æˆ´æŠ¤å…·å°±æ•¢åŽ»è¡—ä¸Šæµªï¼Œå®žåœ¨æ˜¯å¤ªèŽ½äº†ï¼ŒçœŸçš„æ˜¯â€œè‰ºé«˜äººèƒ†å¤§â€ã€‚å› ä¸ºæ²¡æœ‰æŠ¤å…·ï¼Œä¹Ÿæœ‰ç‚¹æ€•åšå‡ åå…¬é‡Œçš„é•¿é€”æ»‘è¡Œï¼Œæ¯•ç«Ÿè¿˜æ˜¯å®‰å…¨ä¸ºé‡ã€‚ æ—¥æœŸï¼š2021-11-24ä¸€åŽ»ä¸€æ¥ï¼Œä¸€å…± 30 å…¬é‡Œï¼Œç»™æˆ‘ç´¯æ­»äº†ï¼Œæ€»å…±è€—æ—¶ 4 ä¸ªå°æ—¶ï¼Œï¼Œå·®ä¸å¤šæ˜¯ 7 - 8 km/h çš„é€Ÿåº¦ï¼Œæ„Ÿè§‰è‡ªå·±è…¿éƒ½è¦æ»‘æ–­äº†ï¼Œç‰¹åˆ«æ˜¯æœ€åŽ 5 å…¬é‡Œï¼Œå¿ƒé‡Œæ€»æ˜¯åœ¨å˜€å’•ï¼šæˆ‘çš„å¤©ï¼Œæ€Žä¹ˆè¿˜æœ‰è¿™ä¹ˆè¿œå•Šï¼Œå•¥æ—¶å€™èƒ½åˆ°å•Šã€‚è¿™æ®µçŸ­é€”æ—…ç¨‹çš„å¥½æ¶ˆæ¯æ˜¯å…¨ç¨‹åªæ‘”äº†ä¸€æ¬¡ï¼Œåæ¶ˆæ¯æ˜¯åˆæ˜¯å±è‚¡æ‘”äº†ï¼Œä¸è¿‡å¥½åœ¨æ˜¯å·¦ä¾§å¤§è…¿å…ˆç€åœ°ï¼Œå½“æ—¶æ˜¯æŒºéš¾å—çš„ï¼ŒåŽæ¥å°±å¥½å¾ˆå¤šäº†ï¼Œå› ä¸ºæ²¡æœ‰æŠŠéž‹å­èƒŒåœ¨èº«ä¸Šï¼Œæ‰€ä»¥ä¸­é€”ä¹Ÿä¸èƒ½æ¢éž‹ï¼Œæ»‘å¤ªä¹…ä¹‹åŽï¼Œè„šç€å®žæ˜¯éš¾å—å•Šã€‚å¦å¤–ï¼Œæ˜¯åœ¨æœ€åŽåªå‰©ä¸‹äº”åˆ†ä¹‹ä¸€è·¯ç¨‹çš„æ—¶å€™æ‘”çš„ï¼Œå¹²ï¼Œä¸»è¦æ˜¯é‚£æ—¶å€™çœ‹ä¸è§å•Šâ€¦ çªç„¶å‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼Œé•¿æ—¶é—´ç©¿ç€éž‹å­æ»‘è¡Œï¼Œè„šè¸ä¼šå¾ˆç´¯ã€‚å°½ç®¡ç›¸æ¯”è·‘æ­¥è€Œè¨€ï¼Œè½®æ»‘å¯¹è†ç›–çš„è´Ÿè·è¦å°å¾ˆå¤šï¼Œä½†æ˜¯æ„Ÿè§‰å¯¹è„šè¸çš„è´Ÿè·è¦å¤§å¾ˆå¤šã€‚ä¹‹æ‰€ä»¥ä¼šè¿™æ ·ï¼Œæ˜¯å› ä¸ºåœ¨æ»‘è¡Œçš„è¿‡ç¨‹ä¸­æ—¶åˆ»è¦æ³¨æ„åˆƒçš„æŽ§åˆ¶ã€‚å½“ç„¶äº†ï¼Œå¯èƒ½ä¹Ÿæ˜¯æˆ‘ä¸ç†Ÿç»ƒçš„åŽŸå› ï¼Œæ»‘è¡Œæ—¶æ€»æ˜¯è¹©è„šã€‚ä¹Ÿæœ‰å¯èƒ½ä¸Žéž‹å­æœ‰å…³ï¼Œéž‹å­æ²¡æœ‰ç©¿å¥½ï¼Œä¸å¤Ÿç´§æ—¶ï¼Œä¸ºäº†æŽ§åˆ¶åˆƒï¼Œä¼šå€ŸåŠ©éž‹å¸®ä½¿åŠ›ï¼Œè¿™æ ·å°±ä½¿å¾—è„šè¸çš„è´Ÿè·å¾ˆå¤§ã€‚ ä»Šå¤©è¿˜çŠ¯äº†ä¸€ä¸ªå¤§å¿Œï¼Œåˆ°è¾¾ç›®çš„åœ°çš„æ—¶å€™æ˜¯äº”ç‚¹ï¼Œåœ¨ç›®çš„åœ°æºœè¾¾å’Œä¼‘æ¯è€—åŽ»äº†åŠå°æ—¶ï¼Œç­‰åˆ°å‡†å¤‡è¿”å›žæ—¶ï¼Œå·²ç»äº”ç‚¹åŠäº†ï¼Œå¤©éƒ½è¦é»‘äº†ï¼ˆæ·±ç§‹ï¼Œå¤©é»‘å¾—æ—©ï¼‰ï¼Œç»“æžœæ»‘åˆ°äº†äº”åˆ†ä¹‹äºŒçš„è·¯ç¨‹æ—¶ï¼Œå¤©å·²ç»æ˜¯çœ‹ä¸è§äº†ï¼Œè·¯è¾¹ä¸Šåˆæ²¡æœ‰è·¯ç¯ï¼Œç»“æžœä¸€è·¯æ‘¸é»‘å›žæ¥ã€‚æ³¨æ„å•Šï¼Œåœ¨æ²¡æœ‰æŠ¤å…·çš„æƒ…å†µä¸‹ï¼Œæ‘¸é»‘å›žæ¥ï¼Œç®€ç›´å°±æ˜¯çžŽå­åœ¨æ»‘ï¼Œè¿™æ˜¯ä¸€ä»¶éžå¸¸å±é™©çš„äº‹æƒ…ï¼Œä»¥åŽä¸èƒ½åœ¨è¿™æ ·æžäº†ã€‚ å¯¹äº†ï¼Œè¿˜äº†è§£åˆ°ä¸€ä¸ªä¿¡æ¯ã€‚æŒ‰ç…§æ³•å¾‹æ¥è®²ï¼Œæ˜¯ä¸å…è®¸åœ¨è·¯ä¸ŠçŽ©è½®æ»‘æˆ–è€…æ»‘æ¿çš„ï¼Œä¸€æ—¦å‡ºäº‹ï¼Œè‡ªå·±å°±æ˜¯å…¨è´£ã€‚è™½ç„¶è·¯ä¸Šæ²¡æœ‰äº¤è­¦ä¸“é—¨æŠ“ï¼Œä½†æ˜¯è¿˜æ˜¯è¦æ³¨æ„å•Šã€‚ä¸è¿‡ï¼Œ8 - 10 km/h çš„é€Ÿåº¦åŸºæœ¬ä¸Šæ˜¯ä¸å¯èƒ½å‡ºäº‹çš„ï¼Œå³ä¾¿å‡ºäº‹æœ€å¤šçš®è‚‰ä¼¤ï¼Œä½†æ˜¯æœ‰æ—¶å€™æ“¦åˆ°äººå®¶è½¦æ¼†é‚£å°±äº‹å¤§äº†ï¼Œæ‰€ä»¥è¿˜æ˜¯è¦æ³¨æ„è¿™ç‚¹ã€‚å”¯ä¸€çš„è§£å†³åŠžæ³•å°±æ˜¯ç»ƒå¥½åˆ¹è½¦ï¼Œåœ¨æœ‰éœ€è¦çš„æ—¶å€™æ¥ä¸ªæ€¥åˆ¹è½¦ã€‚ è¿™æ˜¯å½“æ—¶æ»‘åˆ°æ¡¥ä¸Šæ‹çš„ç…§ç‰‡ï¼Œè¿™å°±æ˜¯æ·±ç§‹ä¸‹åˆ 4 ç‚¹çš„å¤ªé˜³ï¼Œè¯´æ˜¯ 12 ç‚¹æˆ‘éƒ½ä¿¡â€¦ ä»Žç›®çš„åœ°è¿”ç¨‹çš„æ—¶å€™ï¼Œç”¨æ‰‹æœºç›´æŽ¥æœ€å¤§éŸ³é‡æ”¾æœ´æ ‘çš„ã€Šåœ¨å¸Œæœ›çš„ç”°é‡Žä¸Šã€‹ï¼Œå½“çœŸæ˜¯è§‰å¾—è‡ªå·±è¿˜æ˜¯â€œæ´»ç€â€çš„å•Šã€‚ åŽæ¥å¤©ä¸€é»‘ï¼Œæžœæ–­ç›´æŽ¥æ¢åˆ°æ‘‡æ»šäº†ï¼Œä¹Œæ¼†å˜›é»‘çš„ï¼Œä¸å£®ä¸‹èƒ†ä¸è¡Œï¼Œ23333ã€‚ä¸€è·¯ä¸Šï¼Œä¼´éšç€æ±½è½¦çš„é¸£ç¬›å£°ï¼Œä»Ž simple man åˆ° donâ€™t stop å†åˆ° highway to hellï¼ˆè¿™ä¸ªæžœæ–­åˆ‡äº†ï¼‰ï¼Œç­‰åˆ°å¿«åˆ°å®¶ï¼Œçœ‹åˆ°è·¯ç¯æ—¶å€™å·²ç»æ˜¯ everybody hurts äº†ï¼Œå“ˆï¼Œçªç„¶æ„Ÿè§‰ä¸–ç•Œéƒ½äº®äº†ï¼Œä¸è¿‡ï¼Œå¿«åˆ°å®¶çš„æ—¶å€™ï¼Œæ˜¯è§‰å¾—æœ€ç´¯çš„æ—¶å€™ï¼Œå¤ªç´¯äº†ï¼Œè„šéƒ½æŠ¬ä¸èµ·æ¥äº†ã€‚åˆ°å®¶æ—¶ï¼Œå·²ç»ä¼¸æ‰‹ä¸è§äº”æŒ‡äº†ï¼ŒåŽŸæ¥å¾ˆå¿«å°±èƒ½çˆ¬å®Œçš„äº”å±‚æ¥¼ï¼Œç¡¬æ˜¯ä¸€æ­¥ä¸€ä¸ªå°é˜¶è¸©ç¨³äº†æ‰æŠ¬è„šã€‚ æ€»ä¹‹ï¼Œä»¥åŽæ˜¯å†ä¹Ÿä¸èƒ½è·ŸçžŽå­ä¸€æ ·äº†ï¼Œä¸€å®šè¦è®¡ç®—å¥½æ—¶é—´ï¼Œä¸ç„¶ç­‰åˆ°çœŸæœ‰äº‹ï¼Œå°±æ™šäº†ï¼ˆåˆ«åœ¨åƒä¸ªæ†¨æ†¨ä¸€æ ·äº†ï¼Œä¸€ç›´èŽ½ï¼‰ã€‚ æ—¥æœŸï¼š2021-11-27ä¸€ä¸‹å­æ»‘å‡ åå…¬é‡Œçš„åŽæžœå°±æ˜¯å¾—ä¼‘æ¯å‡ å¤©æ‰èƒ½ç¼“è¿‡æ¥ï¼Œè„šè¸è¿˜æ˜¯æœ‰ç‚¹é…¸ç–¼çš„æ„Ÿè§‰å•Šã€‚ ä»Šå¤©å¤§æ¦‚åˆæ»‘äº†å‡ å…¬é‡Œå§ï¼ŒçŽ°åœ¨å›žå¤´ç®—ç®—æ»‘è¡Œæ€»è·¯ç¨‹å¤§æ¦‚æœ‰ 50 - 60 å…¬é‡Œäº†ï¼Œè¿™ä¹Ÿç®—æ˜¯æœ‰ä¸€ç‚¹æ»‘è¡Œç»éªŒäº†å§ï¼Ÿç„¶åŽåˆå°è¯•äº†ä¸€ä¸‹è‘«èŠ¦æ­¥è·Ÿå¼“æ­¥è½¬å¼¯ï¼Œè‘«èŠ¦æ­¥è¿˜æŒºå®¹æ˜“çš„ï¼Œä½†è¿˜éœ€è¦å¤šç»ƒä¹ ï¼ŒçŽ°åœ¨æ­¥å­è¿˜ä¸èƒ½è¿ˆçš„å¾ˆå¤§ï¼Œæ…¢æ…¢ç»ƒï¼Œæ­¥å­åº”è¯¥å°±å¯ä»¥è¿ˆå¤§ä¸€ç‚¹äº†ã€‚è‡³äºŽå¼“æ­¥è½¬å¼¯ï¼ŒçŽ°åœ¨è¿˜æ²¡æœ‰æ‰¾åˆ°æ„Ÿè§‰ï¼Œè¿˜å¾—çœ‹è§†é¢‘å­¦ä¹ ä¸‹ã€‚ å­¦ä¹ æ–°åŠ¨ä½œå¯åˆæœ‰çš„æŠ˜è…¾äº†ï¼Œå¥½æ¶ˆæ¯æ˜¯æ‰¾åˆ°äº†ä¸€ä¸ªä¸é”™çš„åœºåœ°ï¼Œåæ¶ˆæ¯æ˜¯åˆå¾—æ‘”è·¤å•¦ï¼Œå¸Œæœ›å¯ä»¥å°½å¿«æŽŒæ¡ä¸¤ä¸ªåŠ¨ä½œå§ã€‚ æ—¥æœŸï¼š2021-12-24è·ç¦»ä¸Šæ¬¡æ»‘è¡Œåˆ°ä»Šå¤©ï¼Œä¸­é€”çŸ­é€”æ»‘è¡Œè¿‡ 2 æ¬¡ï¼Œå¯èƒ½æ˜¯ä¸Šæ¬¡æ»‘è¡Œä¹‹åŽä¼‘æ¯äº†æ¯”è¾ƒé•¿çš„æ—¶é—´ç¼˜æ•…ï¼Œå†æ¬¡æ»‘è¡Œçš„æ—¶å€™ï¼Œå·¦è„šè„šè¸æ²¡æœ‰äº†ä¹‹å‰é…¸ç–¼çš„æ„Ÿè§‰ï¼Œä¹Ÿæ˜Žæ˜¾æ„Ÿè§‰è‡ªå·±çš„è„šå¯¹åˆƒçš„æ“æŽ§å¥½åƒæ›´åŠ çµæ´»äº†ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯è‡ªå·±å¤ªä¹…æ²¡æœ‰æ»‘äº†çš„ç¼˜æ•…ã€‚ è¿™ä¸¤æ¬¡æ»‘è¡Œéƒ½æ˜¯çŸ­é€”çš„ï¼Œæ²¡æœ‰åŽ»å¤ªè¿œçš„åœ°æ–¹ï¼Œå†åŠ ä¸Šå¤©æ°”å˜å†·ã€æ™´å¤©è¾ƒå°‘çš„ç¼˜æ•…ï¼Œ2 æ¬¡æ»‘è¡Œçš„æ—¶é—´é—´éš”ä¹Ÿæ¯”è¾ƒå¤§ï¼Œä¸è¿‡éƒ½æ˜¯å¾ˆè½»æ¾çš„åœ¨æ»‘ã€‚ ç¬¬ä¸€æ¬¡ä¸»è¦å°è¯•äº†ä¸€ä¸‹è‡ªå·±èƒ½æ»‘è¡Œçš„æœ€å¿«é€Ÿåº¦ï¼Œæµ‹è¯•äº†ä¸€ä¸‹å¤§æ¦‚æ˜¯ 12 km/h è¿™æ ·çš„é€Ÿåº¦ï¼Œä¸è¿‡ï¼Œåªæµ‹è¯•äº†ä¸€æ¬¡ï¼Œä¸¤ä¸ªæ¥å›žï¼Œç²¾å‡†åº¦å°±ä¸æ˜¯é‚£ä¹ˆé«˜äº†ã€‚åœ¨ä¿æŒè¿™ä¸ªé€Ÿåº¦çš„è¿‡ç¨‹ä¸­ï¼Œå…¶å®žæ„Ÿè§‰äººæŒºç´¯çš„ï¼Œå› ä¸ºè¦ä¿æŒé€Ÿåº¦ï¼Œæ‰€ä»¥å¿…é¡»è¦å°½å¯èƒ½çš„åŠè¹²æ»‘è¡Œï¼Œæ‰‹ä¹Ÿè¦èƒŒåœ¨èƒŒåŽï¼Œä»Žè€Œé™ä½Žé£Žé˜»ï¼Œè¿™æ ·çš„åŽæžœå°±æ˜¯å¾ˆå®¹æ˜“å°±æ„Ÿè§‰åˆ°ç´¯äº†ï¼Œè€Œä¸”ï¼Œæ»‘ä¸äº†å¤ªè¿œå°±å¼€å§‹å–˜æ°”äº†ï¼Œåº”è¯¥è¿˜æ˜¯æˆ‘è‡ªèº«ä½“åŠ›å¤ªå¼±çš„ç¼˜æ•…ï¼Œå½“ç„¶ä¹Ÿæœ‰å§¿åŠ¿ä¸æ ‡å‡†çš„åŽŸå› åœ¨å†…ã€‚ä¹Ÿè®¸ï¼Œä½“åŠ›æ–¹é¢å¯ä»¥é€šè¿‡è·‘æ­¥æ¥é”»ç‚¼ä¸€ä¸‹ã€‚ ç¬¬äºŒæ¬¡æœ¬æ¥æƒ³çš„æ˜¯éšä¾¿æµªä¸€ä¸‹ï¼Œå…å¾—å—ä¼¤ï¼Œæ¯•ç«Ÿå†¬å¤©å—ä¼¤äº†ä¸å¥½æ¢å¤ã€‚æ²¡æˆæƒ³ï¼Œä»Žç©¿ä¸Šéž‹å­å¼€å§‹ï¼Œä¸€ç›´åœ¨å°è¯•è·³è·ƒã€‚å°è¯•ä¸€ç•ªåŽï¼Œè½»è½»çš„è·³è·ƒå¥½åƒå·²ç»ä¸åœ¨è¯ä¸‹äº†ï¼Œè¿™å¯¹è·¨è¶Šä¸€ä¸‹å°éšœç¢ç‰©å€’æ˜¯å¾ˆæœ‰å¸®åŠ©ï¼›å¤§å¹…åº¦çš„è·³è·ƒä¹Ÿèƒ½è·³èµ·æ¥ï¼Œä½†æ˜¯è½åœ°çš„ä¸€çž¬é—´ä¼šæ˜Žæ˜¾æœ‰ä¸€ç§ç«™ä¸ç¨³çš„æ„Ÿè§‰ï¼Œå¯èƒ½æ˜¯é€Ÿåº¦å¤ªå¿«å¯¼è‡´çš„ã€‚ä¹Ÿè®¸ï¼Œè·³è·ƒè½åœ°è¿‡ç¨‹ä¸­æ”¹å˜ä¸€ä¸‹ä¸Žåœ°é¢æŽ¥è§¦çš„åˆƒï¼Œå¯èƒ½ä¼šä½¿è½åœ°æ›´åŠ å¹³ç¨³ã€‚åŽæ¥ï¼Œåˆå°è¯•äº†ä¸€ä¸‹å†²å¡ï¼Œæ²¡é”™ï¼Œå°±æ˜¯åŽŸæ¥æ‘”äº† 3 æ¬¡å±è‚¡çš„é‚£ä¸ªå¡ï¼Œä¸€å…±å°è¯•äº† 2 æ¬¡ã€‚ä¸€å¼€å§‹æ˜¯ä»Žå¡çš„ä¸­é—´å¼€å§‹å†²ä¸‹æ¥çš„ï¼Œæ„Ÿè§‰è‡ªå·±å¾ˆå¹³ç¨³çš„å°±ä¸‹æ¥äº†ï¼Œä¹Ÿæ²¡å‡é€Ÿï¼Œå¹¶ä¸”å†²å¡å¸¦æ¥çš„é€Ÿåº¦æ¯”è¾ƒå¿«ï¼Œè€Œä¸”ä¸ç”¨è‡ªå·±è´¹åŠ²ï¼Œå°±å¾ˆèˆ’æœã€‚ä¹‹åŽå†å°è¯•çš„æ—¶å€™ï¼Œå°±ç›´æŽ¥ä»Žå¡é¡¶ä¸Šå†²ä¸‹æ¥äº†ã€‚å…¶å®žåœ¨å†²å¡ä¹‹å‰å¿ƒé‡Œæ˜¯å‡†å¤‡å‡é€Ÿä¸‹å¡çš„ï¼Œç»“æžœçœŸåˆ°äº†é‚£æ—¶å€™ï¼Œæ ¹æœ¬å°±ä¸èƒ½å‡é€Ÿï¼Œä¸€æ˜¯å› ä¸ºé€Ÿåº¦çš„ç¼˜æ•…ï¼Œè´¸ç„¶å‡é€Ÿå¾ˆå¯èƒ½ä¼šä¸€å¤´æ ½å‡ºåŽ»ï¼›äºŒæ˜¯æˆ‘æ²¡æœ‰åœ¨é‚£ç§æƒ…å†µä¸‹ç¨³å®šåˆ¹è½¦çš„ç»éªŒã€‚å¹¸è¿çš„æ˜¯ï¼Œå½“æ—¶çš„æˆ‘æ„Ÿè§‰è¿™ä¸ªé€Ÿåº¦æ˜¯æˆ‘å¯ä»¥æŽ§åˆ¶çš„ï¼Œæˆ‘æ„Ÿè§‰æˆ‘çš„è„šï¼Œä¸ï¼Œæˆ‘çš„éž‹å­ï¼Œæ˜¯å¯ä»¥å¾ˆå¥½çš„æŠ“ä½åœ°é¢çš„ã€‚ç»“æžœï¼Œæ¯«æ— å‡é€Ÿçš„ç›´æŽ¥å°±ä»Žå¡ä¸Šå†²äº†ä¸‹æ¥ï¼Œé‚£æ„Ÿè§‰æ˜¯çœŸçš„å¾ˆèˆ’ç•…ï¼Œå°±å¥½åƒå¿ƒæåˆ°å—“å­çœ¼ï¼Œç„¶åŽåˆå›žåŽ»äº†ä¸€æ ·ï¼Œæˆ‘è§‰ç€ï¼Œå–œçˆ±æžé™è¿åŠ¨çš„äººåœ¨æˆåŠŸæŒ‘æˆ˜ä¸€é¡¹æžé™è¿åŠ¨çš„æ—¶å€™åº”è¯¥ä¹Ÿæ˜¯è¿™æ ·çš„æ„Ÿè§‰å§ï¼Œè¿™æ ·æ‰èƒ½ç®—æ˜¯ç¡®ç¡®å®žå®žçš„æ˜¯åœ¨æ´»ç€ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Sport</category>
      </categories>
      <tags>
        <tag>Skating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS è¯¾ç¨‹ä¸‹çš„æ±‡ç¼–ç¬”è®°]]></title>
    <url>%2F2021%2F11%2F11%2FHIT-OS-%E8%AF%BE%E7%A8%8B%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æ­¤æ–‡ç”¨æ¥è®°å½•åœ¨è¿›è¡Œ HIT_OS è¯¾ç¨‹æ—¶ï¼Œé‡åˆ°çš„ä¸€äº›è·Ÿæ±‡ç¼–è¯­è¨€ç›¸å…³çš„é—®é¢˜ï¼ˆçº¯æ±‡ç¼–å°ç™½è§’åº¦ï¼‰ã€‚ æ³¨æ„ï¼šä»¥ä¸‹å†…å®¹éƒ½æ˜¯ x86 æœºå™¨ä¸‹çš„æ±‡ç¼–çŸ¥è¯†ã€‚ entryentryæ˜¯æ±‡ç¼–è¯­è¨€ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œå‘Šè¯‰ cpu è¿™æ®µæ±‡ç¼–ç¨‹åºçš„å…¥å£æ˜¯ä»€ä¹ˆï¼Œä¸€èˆ¬è€Œè¨€ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯æ±‡ç¼–ç¨‹åºå…¥å£ã€‚ movmovæ˜¯æ•°æ®ä¼ é€æŒ‡ä»¤ï¼Œä¹Ÿæ˜¯æœ€åŸºæœ¬çš„æ±‡ç¼–ç¼–ç¨‹æŒ‡ä»¤ï¼Œç”¨äºŽå°†ä¸€ä¸ªæ•°æ®ä»Žæºåœ°å€ä¼ é€åˆ°ç›®æ ‡åœ°å€ï¼ˆå¯„å­˜å™¨ä¹‹é—´çš„æ•°æ®ä¼ é€æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€æ ·ï¼‰ï¼Œå…¶ç‰¹ç‚¹æ˜¯ä¸ç ´åæºåœ°å€å•å…ƒçš„å†…å®¹ï¼ˆå±žäºŽå¤åˆ¶æ€§è´¨ï¼Œä¸å±žäºŽæ¬å®¶æ€§è´¨ï¼‰ï¼ŒåŸºæœ¬ç”¨æ³•ï¼š123! mov dst,src mov EAX,#050aH ;å°†åå…­è¿›åˆ¶æ•° 050a ä¼ é€åˆ°é€šç”¨å¯„å­˜å™¨ EAX ä¸­ mov DI,BX ;å¯„å­˜å™¨ä¹‹é—´ä¼ æ•° æ³¨æ„ mov çš„ä¸¤ä¸ªæ“ä½œæ•°ä¸èƒ½åŒæ—¶ä¸ºæ®µå¯„å­˜å™¨ï¼Œå…¶ä»–æ³¨æ„äº‹é¡¹ç­‰å†…å®¹å‚è€ƒç™¾åº¦ç™¾ç§‘ï¼šMOVã€‚ xorè¿™ä¸ªæ²¡å•¥è¯´çš„ï¼Œå¼‚æˆ–æ“ä½œï¼ŒC è¯­è¨€ä¸­å‡ºçŽ°è¿‡çš„ä¸œè¥¿ã€‚ä¸è¿‡åœ¨æ±‡ç¼–è¿™é‡Œå¥½åƒç”¨çš„å¾ˆå¤šï¼Ÿ ax ah alax æ˜¯ cpu å†…éƒ¨ä¸€ä¸ªå¯„å­˜å™¨åŠ©è®°ç¬¦ï¼Œé€šå¸¸ç§°ä¹‹ä¸ºç´¯åŠ å™¨ã€‚ä»¥è¿™é—¨è¯¾ä¸Šçš„ 16 ä½ cpu ä¸ºä¾‹ï¼Œahï¼ˆa highï¼‰ å°±æ˜¯ ax çš„é«˜å…«ä½ï¼Œalï¼ˆa lowï¼‰ å°±æ˜¯ ax çš„ä½Žå…«ä½ã€‚é€šä¿—æ¥è®²ï¼Œè‹¥ ax=1234hï¼Œé‚£ä¹ˆ ah=12hï¼Œal=34hã€‚å¯¹åº”çš„ï¼Œå…¶ä»–å¯„å­˜å™¨ä¸€æ ·ä¹Ÿæœ‰ä¸Žå…¶å¯¹åº”çš„ h å’Œ lã€‚ intint åº”è¯¥æ˜¯æ±‡ç¼–ä¸­ä¸“é—¨ç”¨æ¥è°ƒç”¨ä¸­æ–­çš„ä¸€ä¸ªæŒ‡ä»¤ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯å„ç§å„æ ·çš„â€œä¸­æ–­ç â€ï¼Œä¸åŒçš„â€œä¸­æ–­ç â€å®žçŽ°çš„åŠŸèƒ½ä¸ä¸€æ ·ã€‚ åŸºåœ°å€ä¸Žæ®µåœ°å€å¯¹ä¸€ä¸ªç¨‹åºè€Œè¨€ï¼ŒåŸºåœ°å€å°±æ˜¯è¿™ä¸ªç¨‹åºè¢«æœºå™¨æ‰§è¡Œæ—¶æœºå™¨æ‰€éœ€è¦çš„â€œä¸œè¥¿â€ï¼ˆå¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯ä»¥ä»£ç æ®µç­‰?ï¼‰çš„åœ°å€ï¼ŒåŸºåœ°å€å°±æ˜¯è¿™ä¸ªè¿™ä¸ªç¨‹åºçš„â€œæ®µâ€çš„èµ·å§‹åœ°å€ï¼Œè€Œæœºå™¨è¦æ‹¿åˆ°è¿™äº›â€œä¸œè¥¿â€å°±éœ€è¦æ®µåœ°å€ã€‚æ¢å¥è¯è¯´ï¼ŒåŸºåœ°å€å…¶å®žè·Ÿæ®µåœ°å€æ˜¯ç±»ä¼¼çš„ä¸œè¥¿ã€‚å…·ä½“çš„ç†è§£å‚è€ƒç™¾ç§‘è¿™ä¸ªå›žç­”ï¼šä»€ä¹ˆæ˜¯åŸºåœ°å€å’Œæ®µåœ°å€ï¼Ÿä¸»è¦ç”¨é€”æ˜¯ï¼Ÿ æ±‡ç¼–ä¸­çš„ ## åœ¨æ±‡ç¼–ä¸­è¡¨ç¤ºç«‹å³å¯»å€ï¼Œä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š1mov A,#21H è¯¥æŒ‡ä»¤çš„æ„æ€æ˜¯å°†å€¼ 21H é€ç»™å¯„å­˜å™¨ A ä¸­æš‚å­˜ï¼Œå¦‚æžœæŠŠ#åŽ»æŽ‰ï¼Œé‚£ä¹ˆæ„æ€å°±æ˜¯å°†åœ°å€ 21H é‡Œé¢çš„å†…å®¹é€ç»™å¯„å­˜å™¨ A äº†ã€‚ æ±‡ç¼–ä¸­çš„ .å‚è€ƒé“¾æŽ¥ï¼šARMä¸­çš„æ±‡ç¼–æŒ‡ä»¤ã€‚ å§‘ä¸”è®¤ä¸º.byteã€.textè¿™ç±»æŒ‡ä»¤æ˜¯ GNU çš„ä¼ªæ±‡ç¼–æŒ‡ä»¤ã€‚å¦å¤–ï¼Œä¸Šè¿°æ–‡ç« ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–æŒ‡ä»¤çš„ä»‹ç»ï¼Œä¹Ÿå¯ä»¥ç®—ä½œå‚è€ƒèµ„æ–™ã€‚ x86 ä¸‹çš„å¯„å­˜å™¨å‚è€ƒæ–‡ç« é‡Œé¢å†™çš„å·²ç»å¾ˆæ¸…æ¥šäº†ï¼Œä½†æˆ‘ä»¬ç›®å‰éœ€è¦äº†è§£çš„ä¸œè¥¿æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æœ‰å¤šå°‘ä¸ªå¯„å­˜å™¨ï¼Œåå­—å«ä»€ä¹ˆã€‚8086çš„ç¼–ç¨‹æ¨¡åž‹åŒ…æ‹¬ 8ã€16 å’Œ 32 ä½çš„å¯„å­˜å™¨,æŒ‰ç…§ä½åˆ†ç±»ï¼š 8 ä½çš„å¯„å­˜å™¨åŒ…æ‹¬ AHï¼ŒALï¼ŒBHï¼ŒBLï¼ŒCHï¼ŒCLï¼ŒDH å’Œ DLã€‚ 16 ä½å¯„å­˜å™¨åŒ…æ‹¬ AXï¼ŒBXï¼ŒCXï¼ŒDXï¼ŒSPï¼ŒBPï¼ŒDIï¼ŒSIï¼ŒIPï¼ŒFLAGSï¼ŒCSï¼ŒDSï¼ŒESï¼ŒSSï¼ŒFSï¼Œå’Œ GSã€‚ æ‰©å±•çš„ 32 ä½çš„æŒ‡ä»¤åŒ…æ‹¬ EAXï¼ŒEBXï¼ŒECXï¼ŒEDXï¼ŒESPï¼ŒEBPï¼ŒEDIï¼ŒESIï¼ŒEIP å’Œ EFLAGSã€‚ æ‰€æœ‰çš„ 32 ä½å¯„å­˜å™¨å’Œ 16 ä½å¯„å­˜å™¨ä¸­çš„ FS æˆ–è€… GS éƒ½ä»…ä»…èƒ½å¤Ÿåœ¨ 80386 ä»¥ä¸Šä½¿ç”¨ã€‚ å‚è€ƒæ–‡ç« ï¼šIntel 80X86å¯„å­˜å™¨åˆ†ç±»ä»‹ç» CFCF æ˜¯æ±‡ç¼–ä¸­çš„è¿›ä½æ ‡å¿—ä½ï¼Œä¸»è¦ç”¨æ¥åæ˜ è¿ç®—æ˜¯å¦äº§ç”Ÿè¿›ä½æˆ–é”™ä½ã€‚å¦‚æžœè¿ç®—ç»“æžœçš„æœ€é«˜ä½äº§ç”Ÿäº†ä¸€ä¸ªè¿›ä½æˆ–é”™ä½ï¼Œå…¶å€¼å°±ä¸º 1ã€‚ä¸Žä¹‹å¯¹åº”çš„æ˜¯ä¸¤ä¸ªè·³è½¬æŒ‡ä»¤ï¼š jc å’Œ jncï¼Œå‰è€…å½“ CF=1 æ—¶ï¼Œè·³è½¬ï¼ŒåŽè€…åä¹‹ã€‚ jncè¿™æ¡è¯­å¥çš„åŠŸèƒ½æœ‰ç‚¹ç±»ä¼¼ C è¯­è¨€ä¸­çš„ gotoï¼Œä½†å®ƒä¸Ž goto ä¸åŒçš„åœ°æ–¹åœ¨äºŽï¼Œå®ƒéœ€è¦æœ‰ä¸€ä¸ªè¿›ä½ã€‚æ¢å¥è¯è¯´ï¼Œjnc xxxè¿™æ¡è¯­å¥ä¹‹å‰ä¼šæœ‰è¿ç®—ï¼Œè¿ç®—çš„ç»“æžœä¼šå½±å“ CF çš„å€¼ã€‚å½“ CF=0 æ—¶ï¼Œå®ƒå°±ä¼šäº§ç”Ÿä¸Ž goto ä¸€æ ·çš„åŠŸèƒ½ï¼Œåä¹‹ï¼Œå°±è·³è¿‡è¿™æ¡è¯­å¥ï¼Œå°±æ˜¯ continue çš„åŠŸèƒ½äº†ã€‚ ldslds æŒ‡ä»Žå­˜å‚¨å™¨å–å‡º 32 ä½åœ°å€çš„æŒ‡ä»¤ï¼Œæ ¼å¼æœ‰ï¼šlds oprd1, oprd2ï¼Œå…¶ä¸­ï¼Œoprd1 ä¸ºä»»æ„ä¸€ä¸ª 16 ä½çš„å­˜å‚¨å™¨ï¼Œoprd2 ä¸º 32 ä½çš„å­˜å‚¨å™¨ã€‚ []æ±‡ç¼–ä¸­çš„ [] è¡¨ç¤ºä¸€ç§é—´æŽ¥çš„å–æ“ä½œæ•°çš„æ–¹å¼ï¼Œæœ‰ç‚¹ç±»ä¼¼äºŽ C è¯­è¨€ä¸­çš„æŒ‡é’ˆæ¦‚å¿µï¼Œå…·ä½“å‚è€ƒä¸‹é¢è¿™ä¸ªå›žç­”ï¼šæ±‡ç¼–è¯­è¨€åŠ ä¸­æ‹¬å·è¡¨ç¤ºä»€ä¹ˆï¼Ÿ rep movsbrep movsb å…¶å®žæ˜¯ä¸¤ä¸ªæŒ‡ä»¤ï¼Œä½†æ˜¯ä¸€èˆ¬æ˜¯è”åˆèµ·æ¥ç”¨çš„ï¼ŒåŒæ—¶åœ¨è¿™æ¡æŒ‡ä»¤ä¹‹å‰å¿…ç„¶è¦å¯¹ cx è¿™ä¸ªå¯„å­˜å™¨çš„å€¼è¿›è¡Œè®¾ç½®ï¼Œå› ä¸º cx çš„å€¼ä»£è¡¨äº†é‡å¤å¤šå°‘æ¬¡ã€‚å…·ä½“çš„ç»†èŠ‚å¯ä»¥å‚è€ƒè¿™ç¯‡æ–‡ç« ï¼šæ±‡ç¼–ä¸­ rep movsb å­—ã€å­—èŠ‚ã€ä½å­—ï¼ˆwordï¼‰è¿™ä¸ªæ¦‚å¿µåº”è¯¥å°±æ˜¯é’ˆå¯¹ cpu è€Œè¨€çš„ï¼Œä¸ä¸¥è°¨çš„è®²ï¼Œå­—å¯èƒ½å°±æ˜¯ cpu ä¸€æ¬¡æ€§èƒ½å¤„ç†çš„æŒ‡ä»¤é•¿åº¦ï¼›è€Œå­—èŠ‚ï¼ˆbyteï¼‰æ˜¯ä¸€ä¸ªå­˜å‚¨æ¦‚å¿µï¼Œä½ï¼ˆbitï¼‰ä¹Ÿç®—æ˜¯ä¸€ä¸ªå­˜å‚¨æ¦‚å¿µã€‚æ¯”å¦‚ï¼Œå¯¹ 16 ä½ cpu è€Œè¨€ 1 ä¸ªå­—é•¿å°±æ˜¯ 2 ä¸ªå­—èŠ‚ï¼Œ16 ä½ã€‚æ‰€ä»¥ï¼Œä¸åŒåž‹å·çš„ cpu ï¼Œå…¶å­—çš„å¤§å°æ˜¯ä¸ä¸€æ ·çš„ï¼Œå½“ç„¶äº†ï¼Œè¿™æ ·è¯´å¯èƒ½ä¸å¤ªä¸¥è°¨ã€‚ callè¿™ä¸ªæŒ‡ä»¤ç±»ä¼¼ C è¯­è¨€ä¸­çš„ gotoï¼Œä½†æ˜¯è¿™ä¸ªæŒ‡ä»¤æ‰§è¡Œå®Œå­ç¨‹åºåŽè¦å›žæ¥ï¼Œè¿™æ˜¯äºŒè€…çš„åŒºåˆ«ã€‚è¯¦ç»†å‚è€ƒè¿™ä¸ªå›žç­”ï¼šæ±‡ç¼–è¯­è¨€ä¸­çš„ call æ˜¯ä»€ä¹ˆæ„æ€]]></content>
      <categories>
        <category>Programming</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS_Basic]]></title>
    <url>%2F2021%2F11%2F10%2FHIT-OS-Basic%2F</url>
    <content type="text"><![CDATA[æ­¤ç³»åˆ—åšæ–‡ç”¨æ¥è®°å½• MOOC ä¸Šè‡ªå­¦å“ˆå·¥å¤§æ“ä½œç³»ç»Ÿè¯¾ç¨‹ï¼ˆç”±æŽæ²»å†›è€å¸ˆæŽˆè¯¾ï¼‰æ—¶çš„ç¬”è®°ã€‚ L1è¿™ä¸€èŠ‚è¯¾ä¸»è¦æ˜¯è€å¸ˆè¯´æ˜Žå­¦ä¹ è¯¾ç¨‹çš„ç›®çš„å’Œæœ¬è¯¾ç¨‹çš„è¦æ±‚ã€‚å¦å¤–ï¼Œå°±æ˜¯åœ¨å®žéªŒæ¥¼ç†Ÿæ‚‰ä¸‹å®žéªŒçŽ¯å¢ƒã€‚ L2è¿™ä¸€è®²è€å¸ˆä¸»è¦æ˜¯åœ¨è¯´æ˜Žç”µè„‘æŽ¥é€šç”µæºåŽåœ¨åšäº›ä»€ä¹ˆäº‹æƒ…ã€‚ å…³äºŽç»„æˆè®¡ç®—æœºçš„äº”å¤§éƒ¨ä»¶ï¼ˆè¿™åˆæ˜¯è€ç”Ÿå¸¸è°ˆäº†ï¼‰ï¼šè¾“å…¥è®¾å¤‡ã€è¾“å‡ºè®¾å¤‡ã€å­˜å‚¨å™¨ã€è¿ç®—å™¨ã€æŽ§åˆ¶å™¨ã€‚è®¡ç®—æœºçš„å·¥ä½œæ–¹å¼ï¼šå–æŒ‡æ‰§è¡Œï¼Œâ€œæŒ‡â€å®žé™…ä¸ŠæŒ‡çš„æ˜¯æŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä½äºŽå†…å­˜ä¸­çš„å‘½ä»¤ã€‚è¿™ä¸ªæ¦‚å¿µåº”è¯¥è´¯ç©¿äº†æ•´ä¸ªæ“ä½œç³»ç»Ÿçš„è®¾è®¡ã€‚ ç†Ÿæ‚‰ä¸€ä¸‹å®žéªŒæ¥¼çš„åŸºæœ¬æ“ä½œï¼š12345678910111213141516171819202122232425262728293031323334353637383940# è§£åŽ‹æ–‡ä»¶$ cd oslab$ tar -zxvf hit-oslab-linux-20110823.tar.gz -C /home/shiyanlou/# ç¼–è¯‘å†…æ ¸$ cd linux-0.11$ make all # all å¯çœç•¥ï¼Œæœ‰æ—¶éœ€è¦å…ˆ make clean # è¿è¡Œå†…æ ¸$ cd ~/oslab # éœ€è¦å† run è¿™ä¸ªè„šæœ¬æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ä¸‹$ ./run # æ‰§è¡Œè¿™æ¡å‘½ä»¤åŽä¼šå‡ºçŽ° Bochs çš„çª—å£# æ±‡ç¼–è°ƒè¯•$ cd ~/oslab # åŒæ ·éœ€è¦åœ¨è¿™ä¸ªç›®å½•ä¸‹$ ./dbg-asm # å¯ä»¥ä½¿ç”¨ help æ¥æŸ¥çœ‹è°ƒè¯•ç³»ç»Ÿçš„å‘½ä»¤# C è¯­è¨€è°ƒè¯•ï¼Œéœ€è¦ä½¿ç”¨ä¸¤ä¸ªçª—å£ã€‚# ç¬¬ä¸€ä¸ªçª—å£$ cd \~/oslab$ ./dbg-c# ç¬¬äºŒä¸ªçª—å£$ cd \~/oslab$ ./rungdb# æ–‡ä»¶äº¤æ¢$ cd ~/oslab$ sudo ./mount-hdc # å…ˆæŒ‚è½½$ cd hdc$ ls -l# æ­¤æ—¶çœ‹åˆ°çš„æ–‡ä»¶å°±æ˜¯ hdc-0.11.img è¿™ä¸ªé•œåƒæ–‡ä»¶å†…çš„æ–‡ä»¶$ cd ~/oslab$ sudo umount hdc # è¯»å†™å®Œæ¯•åŽè¦å¸è½½# 1. æ³¨æ„ä¸è¦åœ¨è¯»å†™å†…æ ¸æ–‡ä»¶æ—¶è¿è¡Œå†…æ ¸ï¼Œä¹Ÿä¸è¦åœ¨è¿è¡Œå†…æ ¸æ—¶è¯»å†™å†…æ ¸å†…çš„æ–‡ä»¶# 2. å…³é—­ Bochs ä¹‹å‰ï¼Œè¦å…ˆæ‰§è¡Œä¸€ä¸‹ `sync` ä¿å­˜ä¸€ä¸‹ L3è¿™ä¸€è®²è€å¸ˆä¸»è¦è®²äº†æ“ä½œç³»ç»Ÿå¯åŠ¨æ—¶åšçš„ä¸¤ä»¶äº‹ï¼š è¯»å…¥ç³»ç»Ÿ å®Œæˆåˆå§‹åŒ– å…·ä½“å¦‚ä½•è¿›è¡Œéœ€è¦å€ŸåŠ©ä»£ç åˆ†æžã€‚ Experiment 1å®žéªŒé¡¹ç›® 1 çš„ä¸»é¢˜æ˜¯æŽ§åˆ¶ç³»ç»Ÿçš„å¯åŠ¨ï¼Œä¸»è¦åŒ…å«çš„å†…å®¹ï¼š é˜…è¯»ã€ŠLinux å†…æ ¸å®Œå…¨æ³¨é‡Šã€‹çš„ç¬¬ 6 ç« ï¼Œå¯¹è®¡ç®—æœºå’Œ Linux 0.11 çš„å¼•å¯¼è¿‡ç¨‹è¿›è¡Œåˆæ­¥çš„äº†è§£ï¼› æŒ‰ç…§ä¸‹é¢çš„è¦æ±‚æ”¹å†™ 0.11 çš„å¼•å¯¼ç¨‹åº bootsect.s æœ‰å…´è¶£åŒå­¦å¯ä»¥åšåšè¿›å…¥ä¿æŠ¤æ¨¡å¼å‰çš„è®¾ç½®ç¨‹åº setup.sã€‚ æ”¹å†™ bootsect.s ä¸»è¦å®Œæˆå¦‚ä¸‹åŠŸèƒ½ï¼šbootsect.s èƒ½åœ¨å±å¹•ä¸Šæ‰“å°ä¸€æ®µæç¤ºä¿¡æ¯â€œXXX is bootingâ€¦â€ï¼Œå…¶ä¸­ XXX æ˜¯ä½ ç»™è‡ªå·±çš„æ“ä½œç³»ç»Ÿèµ·çš„åå­—ï¼Œä¾‹å¦‚ LZJosã€Sunix ç­‰ï¼ˆå¯ä»¥ä¸Šè®ºå›ä¸Šç§€ç§€è°çš„ OS åå­—æœ€å¸…ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤ºä¸€ä¸ªç‰¹è‰² logoï¼Œä»¥è¡¨ç¤ºè‡ªå·±æ“ä½œç³»ç»Ÿçš„ä¸Žä¼—ä¸åŒã€‚ï¼‰ æ”¹å†™ setup.s ä¸»è¦å®Œæˆå¦‚ä¸‹åŠŸèƒ½ï¼š bootsect.s èƒ½å®Œæˆ setup.s çš„è½½å…¥ï¼Œå¹¶è·³è½¬åˆ° setup.s å¼€å§‹åœ°å€æ‰§è¡Œã€‚è€Œ setup.s å‘å±å¹•è¾“å‡ºä¸€è¡Œâ€Now we are in SETUPâ€ã€‚ setup.s èƒ½èŽ·å–è‡³å°‘ä¸€ä¸ªåŸºæœ¬çš„ç¡¬ä»¶å‚æ•°ï¼ˆå¦‚å†…å­˜å‚æ•°ã€æ˜¾å¡å‚æ•°ã€ç¡¬ç›˜å‚æ•°ç­‰ï¼‰ï¼Œå°†å…¶å­˜æ”¾åœ¨å†…å­˜çš„ç‰¹å®šåœ°å€ï¼Œå¹¶è¾“å‡ºåˆ°å±å¹•ä¸Šã€‚ setup.s ä¸å†åŠ è½½ Linux å†…æ ¸ï¼Œä¿æŒä¸Šè¿°ä¿¡æ¯æ˜¾ç¤ºåœ¨å±å¹•ä¸Šå³å¯ã€‚ æ”¹å†™ bootsect.sè¿™ä¸ªä»»åŠ¡æ¯”è¾ƒå®¹æ˜“ï¼Œå› ä¸ºè€å¸ˆä¸Šè¯¾çš„æ—¶å€™å¤§è‡´ä¸Šè®²è¿‡äº†ï¼Œæ‰€ä»¥åªéœ€è¦æŒ‰ç…§è€å¸ˆç»™çš„æç¤ºæ¥å®Œæˆå°±è¡Œäº†ã€‚å…ˆæŠŠå®žéªŒçŽ¯å¢ƒæŒ‰ç…§ä¸Šä¸ªå®žéªŒçš„æ­¥éª¤å¼„å¥½ï¼Œè§£åŽ‹æ–‡ä»¶ã€‚ å…ˆæ‰¾åˆ° bootsect.s123$ cd linux-0.11/boot/$ ls$ vim bootsect.s è¿›å…¥ bootsect.s çš„ç¼–è¾‘é¡µé¢åŽèƒ½çœ‹åˆ° Linus 91å¹´å†™ä¸‹çš„è¯´æ˜Žï¼Œå……æ»¡äº†å¹´ä»£æ„Ÿã€‚æ˜ å…¥çœ¼ä¸­çš„å…¨æ˜¯æ±‡ç¼–ä»£ç ï¼Œå¯¹äºŽä¸æ‡‚æ±‡ç¼–çš„äººæ¥è¯´æœ‰ç‚¹éš¾å—ã€‚ä¸è¿‡æ²¡å…³ç³»ï¼Œæ‰¾åˆ°æŒ‡å®šä½ç½®ç„¶åŽä¿®æ”¹å°±è¡Œã€‚ é¦–å…ˆï¼Œè¦ä¿®æ”¹çš„æ–‡æœ¬çš„ä½ç½®æ˜¯åœ¨ bootsect.s æ–‡ä»¶å†…çš„ 244 - 247 è¡Œå¤„ï¼ˆç›´æŽ¥æ‰¾å°±è¡Œäº†ï¼‰ï¼š1234msg1: .byte 13,10 .ascii &quot;Loading system ...&quot; .byte 13,10,13,10 æ”¹ä¸ºè‡ªå·±å–œæ¬¢çš„å³å¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ”¹ä¸ºï¼šcolor_os is booting ...ã€‚æŽ¥ç€æˆ‘ä»¬è¿˜éœ€è¦åœ¨ä¿®æ”¹ä¸€ä¸‹è¦æ˜¾ç¤ºçš„å­—ç¬¦ä¸ªæ•°ï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•æ‰¾åˆ°ä»£ç ä½ç½®å‘¢ï¼Ÿå¯æƒ³è€ŒçŸ¥ï¼Œè¿™æ®µå­—ç¬¦ä¸²æ˜¯è¦åœ¨å¼€æœºçš„æ—¶å€™æ˜¾ç¤ºçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¼€æœºåŽçš„å…‰æ ‡å¹²çš„ç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯æ˜¾ç¤ºè¿™ä¸²å­—ç¬¦ï¼Œé‚£åªè¦æ‰¾åˆ°è¯»å…¥å…‰æ ‡çš„ä½ç½®å°±è¡Œäº†ï¼ˆå…¶å®žä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨ vim çš„æœç´¢åŠŸèƒ½æ‰¾åˆ°ä¸Ž msg1 ç›¸å…³çš„åœ°æ–¹å°±å¯ä»¥äº†ï¼‰ã€‚ æŽ¥ä¸‹æ¥è¦ä¿®æ”¹çš„ä½ç½®æ˜¯åœ¨ 98 è¡Œå¤„ï¼š1mov cx,#24 ä¸Šé¢çš„è¿™ä¸ª24å®žé™…ä¸Šå°±æ˜¯ä¹‹å‰Loading system ...åŠ ä¸Š 3 ä¸ªæ¢è¡Œç¬¦ã€3 ä¸ªå›žè½¦ç¬¦çš„å’Œã€‚è¿™é‡Œï¼Œæ•°ä¸€ä¸‹ä¿®æ”¹åŽçš„å­—ç¬¦ä¸ªæ•°ï¼Œåº”è¯¥æ”¹ä¸º 29ã€‚ è¿™æ ·å°±å·®ä¸å¤šäº†ï¼Œæ¥å°è¯•ç¼–è¯‘è¿è¡Œä¸€ä¸‹:12$ cd linux-0.11$ make all æ²¡æœ‰é”™è¯¯æç¤ºå°±å¯ä»¥å°è¯•è¿è¡Œäº†ã€‚12$ cd ~/oslab$ ./run è§‚å¯Ÿç»“æžœå¯ä»¥å‘çŽ°å·²ç»æ”¹æˆæƒ³è¦çš„ç»“æžœäº†ã€‚ Reviewè¿™é‡Œæˆ‘ä»¬æŒ‰ç…§è€å¸ˆç»™çš„æç¤ºåœ¨å®Œæˆä¸€ä¸‹è¿™ä¸ªå®žéªŒã€‚æ ¹æ®è€å¸ˆçš„æç¤ºï¼Œå¯ä»¥å†™å‡º bootsect.s æœ€ç»ˆçš„æºç ï¼š1234567891011121314151617181920212223242526272829entry _start_start:! read cursor pos mov ah,#0x03 ! ah need to be set as 03, so the bios interruption can check it xor bh,bh int 0x10! print the message we set mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ! es need to be set mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 è¿™é‡Œå†æ¥ç®€å•è§£é‡Šä¸€ä¸‹è¿™æ®µæ±‡ç¼–ä»£ç ï¼ˆæ¯•ç«Ÿæ²¡å­¦è¿‡æ±‡ç¼–ï¼Œå°±å½“å­¦æ±‡ç¼–äº†ï¼‰ï¼Œentryæ˜¯æ±‡ç¼–ä»£ç ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œç”¨æ¥æŒ‡ç¤ºæ±‡ç¼–ç¨‹åºçš„å…¥å£ï¼Œæ˜¾ç„¶ï¼Œåœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œå®ƒå‘Šè¯‰ cpu ç¨‹åºçš„å…¥å£æ˜¯ _startã€‚!åŽé¢çš„å†…å®¹å°±æ˜¯æ³¨é‡Šï¼Œmovã€xorè¿™æ ·çš„â€œæ ‡è¯†ç¬¦â€åœ¨æ±‡ç¼–é‡Œé¢å«åšæ“ä½œç ï¼ŒåŽé¢ç´§è·Ÿçš„å°±æ˜¯æ“ä½œæ•°ï¼ŒäºŒè€…ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œæ“ä½œæ•°ä¹‹é—´ç”¨,éš”å¼€ã€‚ bios 0x10 ä¸­æ–­æ ¹æ® ah çš„ä¸åŒçš„å€¼æ¥å‘æŒ¥ä¸åŒçš„åŠŸèƒ½ï¼ˆå…¶ä»– bios ä¸­æ–­å¯èƒ½ä¹Ÿæœ‰ï¼‰ã€‚ä¸åŒåŠŸèƒ½éœ€è¦çš„è¾“å…¥ä¸Žè¿”å›žéƒ½æ˜¯ä¸æƒ³åŒçš„ï¼Œè¿™éƒ¨åˆ†çš„å†…å®¹çš„ç–‘é—®å¯ä»¥æŸ¥è¯¢è€å¸ˆç»™çš„æ‰‹å†Œä¸Šçš„æ³¨é‡Šï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥æŸ¥ bios ä¸­æ–­çš„æ‰‹å†Œã€‚ ä¹‹æ‰€ä»¥è¦æ”¹åŠ¨å¯„å­˜å™¨ es çš„å€¼ï¼Œæ˜¯å› ä¸º 0x10 ä¸­æ–­è§„å®šäº† es:bp æ˜¯å­—ç¬¦ä¸²çš„é¦–åœ°å€ï¼ˆä¹Ÿå°±æ˜¯èµ·å§‹ä½ç½®ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰ bp çš„å€¼æ˜¯æ— æ³•è®©æœºå™¨æ˜¾ç¤ºå­—ç¬¦ä¸²çš„ã€‚ info_loopæ˜¯åˆ©ç”¨ jmp æŒ‡ä»¤è®¾ç½®çš„ä¸€ä¸ªå¾ªçŽ¯ï¼Œè¿™æ¡æŒ‡ä»¤ä¼šè®©æœºå™¨ä¸€ç›´æ‰§è¡Œè¿™ä¸ªå¾ªçŽ¯ã€‚å¦‚æžœæ²¡æœ‰è¿™æ¡æŒ‡ä»¤ï¼Œæœºå™¨å°±ä¼šåŽ»å¯»æ‰¾ä¸‹ä¸€ä¸ªèƒ½å¯åŠ¨çš„è®¾å¤‡ã€‚ .orgä¹Ÿæ˜¯æ±‡ç¼–ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œå®ƒå‘Šè¯‰ cpu ä¸‹é¢çš„è¯­å¥ä»Žåœ°å€ 510 å¤„å¼€å§‹æ‰§è¡Œï¼Œç›¸æ¯”åŽŸæœ¬çš„å†…æ ¸ä»£ç ï¼Œè¿™é‡Œèˆå¼ƒæŽ‰äº†root_devï¼Œæ‰€ä»¥éœ€è¦å°†åœ°å€è®¾ç½®ä¸º 510ï¼Œè¿™æ ·å½“æˆ‘ä»¬å°†ç£ç›˜å¼•å¯¼æ‰‡åŒºï¼ˆå…± 512 å­—èŠ‚ï¼‰çš„æœ€åŽä¸¤ä¸ªå­—èŠ‚è®¾ç½®ä¸º 0xAA55 æ—¶ï¼Œæœºå™¨è¯»å–åˆ°è¿™é‡Œå°±ä¼šçŸ¥é“è¿™ä¸ªæ‰‡åŒºæ˜¯å¼•å¯¼æ‰‡åŒºäº†ï¼ˆæ˜¯å¦‚ä½•è¯»çš„ï¼Œè¿™é‡Œå°±ä¸è§£é‡Šäº†ï¼‰ã€‚æœ€åŽçš„ boot_flagå°±æ˜¯å¯åŠ¨æ ‡å¿—çš„å­—é¢æ„æ€äº†ï¼Œå¯æƒ³è€ŒçŸ¥ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯ 0xAA55ã€‚å¯ä»¥çŒœæµ‹ä¸€ä¸‹ï¼Œè¿™å‡ è¡Œä»£ç åº”è¯¥æ˜¯åŽç»­å·¥ä½œåšçš„å‡†å¤‡ã€‚ æžå®šæºç åŽï¼Œå°±å¯ä»¥å¼€å§‹ç¼–è¯‘å†…æ ¸è¿è¡Œæ£€æŸ¥ä¸€ä¸‹è¿è¡Œç»“æžœäº†ã€‚ä»¥ Linux ä¸ºä¾‹ï¼Œè¿›å…¥linux-0.11/bootç›®å½•ä¸‹è¦ç¼–è¯‘å’Œé“¾æŽ¥ bootsect.s å°±è¦æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼š12as86 -0 -a -o bootsect.o bootsect.sld86 -0 -s -o bootsect bootsect.o åˆ«æ€¥ç€åŽ»è¿è¡Œå†…æ ¸ï¼Œå…ˆç”¨ls -lå‘½ä»¤æ£€æŸ¥ä¸‹ç¼–è¯‘å¥½çš„æ–‡ä»¶çš„å¤§å°ã€‚å¯ä»¥å‘çŽ°ï¼Œbootsect çš„æ–‡ä»¶å¤§å°æ˜¯ 544 å­—èŠ‚ï¼Œä½†æ˜¯å¼•å¯¼ç¨‹åºå¿…é¡»è¦æ­£å¥½å ç”¨ä¸€ä¸ªç£ç›˜æ‰‡åŒºï¼Œå³ 512 å­—èŠ‚ã€‚é€ æˆå¤šäº† 32 ä¸ªå­—èŠ‚çš„åŽŸå› æ˜¯ ld86 äº§ç”Ÿçš„æ˜¯ Minix å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ï¼Œè¿™æ ·çš„å¯æ‰§è¡Œæ–‡ä»¶é™¤äº†æ–‡æœ¬æ®µã€æ•°æ®æ®µç­‰éƒ¨åˆ†ä»¥å¤–ï¼Œè¿˜åŒ…æ‹¬ä¸€ä¸ª Minix å¯æ‰§è¡Œæ–‡ä»¶å¤´éƒ¨ï¼Œè€Œè¿™ä¸ªæ–‡ä»¶çš„å¤´éƒ¨æ­£å¥½å¤šäº† 32 ä¸ªå­—èŠ‚ã€‚ åœ¨ linux ä¸‹éœ€è¦å°†æ–‡ä»¶å¤§å°æ”¹ä¸º 512 å­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯åˆ æŽ‰å¤´éƒ¨ï¼Œæ‰€ä»¥éœ€è¦å€ŸåŠ©å‘½ä»¤ï¼š12dd bs=1 if=bootsect of=Image skip=32cp ./Image ../Image ä¹‹åŽåœ¨ oslab ç›®å½•ä¸‹ï¼Œè¿è¡Œ run è„šæœ¬ï¼š1$ ./run å°±å¯ä»¥å¾—åˆ°è¿™æ ·çš„ç»“æžœï¼š æ”¹å†™ setup.så…ˆåˆ†æžä¸€ä¸‹è¦æ±‚ï¼š åˆ©ç”¨ setup.s å‘å±å¹•è¾“å‡ºä¸€è¡Œâ€œNow we are in SETUPâ€ åˆ©ç”¨ setup.s èŽ·å–åŸºæœ¬ç¡¬ä»¶å‚æ•°ï¼Œè¿™ä¸ªå†…æ ¸æœ¬èº«å°±å·²ç»è¯»äº†å†…å­˜æ•° setup.s ä¸å†åŠ è½½ linux å†…æ ¸ï¼Œä¿æŒä¸Šè¿°ä¿¡æ¯æ˜¾ç¤ºåœ¨å±å¹•ä¸Šå³å¯ï¼Œè¿™é‡Œå¯èƒ½ä¼šç”¨åˆ°ä¸­æ–­ å…ˆçœ‹ç¬¬ä¸€æ¡è¦æ±‚ï¼Œè¿™ä¸ªè·Ÿå‰ä¸€ä¸ªä»»åŠ¡å®Œæˆå¾—äº‹æƒ…æ˜¯ç±»ä¼¼çš„ï¼Œéœ€è¦æ‰¾åˆ°å…‰æ ‡ä½ç½®ï¼Œç„¶åŽæ‰“å°å³å¯ã€‚ å°è¯•äº†ä¸€ä¸‹ï¼Œå°† bootsect.s å†…ä¸Žå…‰æ ‡å’Œæ‰“å°æ–‡å­—ç›¸å…³çš„ä»£ç æŠ„åˆ°äº† setup.s è¿™ä¸ªæ–‡ä»¶å¯¹åº”è¯»å…‰æ ‡çš„ä½ç½®ï¼Œç»“æžœå¹¶ä¸é¡¶ç”¨ã€‚çªç„¶æƒ³åˆ°ï¼Œæ˜¯ä¸æ˜¯æ‰“å°å®Œä¸€è¡Œå­—ç¬¦åŽå†å°†å…‰æ ‡ä½ç½®ç§»åŠ¨åˆ°è¡Œé¦–å‘¢ï¼ŸäºŽæ˜¯åˆåœ¨æŠ„è¿‡æ¥çš„ä»£ç ä¸‹é¢è¡¥ä¸Šäº†è¯»å…‰æ ‡ä½ç½®çš„ä»£ç ï¼Œç»“æžœè¿˜æ˜¯ä¸è¡Œï¼Œæžœç„¶ï¼Œä¸æ‡‚æ±‡ç¼–ï¼Œå•çº¯çš„é  Ctrl + C/Vï¼Œè¿˜æ˜¯ä¸è¡Œï¼Œç´¢æ€§çœ‹ä¸‹è€å¸ˆç»™çš„æç¤ºã€‚ çœ‹äº†è€å¸ˆçš„æç¤ºï¼Œæ‰å‘çŽ°è€å¸ˆè®²çš„â€œæ”¹å†™â€è·Ÿæˆ‘ç†è§£çš„â€œæ”¹å†™â€å«ä¹‰ä¸æ˜¯ä¸€æ ·çš„ã€‚è€å¸ˆæ˜¯ç›´æŽ¥ä»Žæ–°å†™ä¸€ä¸ªèƒ½å®Œæˆä»»åŠ¡çš„ bootsect.s å’Œ setup.s æ–‡ä»¶ï¼Œè€Œæˆ‘æ˜¯ç›´æŽ¥æ”¹çŽ°æˆæ–‡ä»¶ï¼Œæ°´å¹³è¿‡ä½Žï¼Œè¿‡ä½Žï¼Œ2333ã€‚ä¸è¿‡å›žè¿‡å¤´æ¥æƒ³ä¸€ä¸‹ï¼Œå¦‚æžœåªæ˜¯å•çº¯å®Œæˆå®žéªŒï¼Œé‚£ä¹ˆç¡®å®žä¸éœ€è¦è¯»å–é‚£ä¹ˆå¤šç³»ç»Ÿä¿¡æ¯ï¼Œä¹Ÿä¸éœ€è¦ç³»ç»Ÿå®Œå…¨å¯åŠ¨ï¼Œåªè¦æ˜¾ç¤ºäº†éœ€è¦çš„ä¸œè¥¿å³å¯ã€‚æ—¢è¦æ˜¾ç¤ºæ–‡æœ¬ï¼Œåˆè¦å†…æ ¸å®Œå¥½çš„å¯åŠ¨ï¼Œåè€Œéœ€è¦çš„çŸ¥è¯†é‡æ›´å¤šï¼Œè¿™å¯¹åˆå­¦è€…è€Œè¨€åè€Œæ˜¯ä¸åˆ©çš„ã€‚å¥½å§ï¼Œç†ç›´æ°”å£®çš„å®‰æ…°äº†è‡ªå·±ï¼Œä¸‹é¢åœ¨æŒ‰ç…§è€å¸ˆç»™çš„æ€è·¯æ¥åšä¸€ä¸‹ã€‚ æ ¹æ®è€å¸ˆç»™å‡ºçš„æ€è·¯ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„å®Œæˆè¿™ä¸ªå®žéªŒçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå…·ä½“è¯·çœ‹ä¸Šæ–‡ Reviewã€‚ ä¸‹é¢æˆ‘ä»¬é¦–å…ˆè®© setup.s å®Œæˆç¬¬ä¸€ä¸ªå­ä»»åŠ¡ï¼šå‘å±å¹•è¾“å‡ºâ€œNow we are in SETUPâ€ã€‚è¿™ä¸ªä»»åŠ¡ä¸Ž bootsect.s å¹²çš„äº‹æƒ…å¾ˆç±»ä¼¼ï¼Œäº‹å®žä¸Šï¼Œæˆ‘ä»¬è¿˜çœŸçš„å°±åªéœ€è¦å°†å‰é¢ä¸‹å¥½çš„ bootsect.s æŠ„è¿‡æ¥å†ä¿®æ”¹ä¸€ä¸‹å°±å¥½äº†ï¼Œæ”¹å¥½åŽï¼š123456789101112131415161718192021entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg2: .byte 13,10 .ascii &quot;Now we are in SETUP&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 å› ä¸º es çš„å€¼åœ¨ bootsect.s å·²ç»æ”¹è¿‡äº†ï¼Œæ‰€ä»¥è¿™é‡Œè¦æ”¹å›žæ¥ï¼Œç›´æŽ¥å€ŸåŠ© cs è¿™ä¸ªæ®µå¯„å­˜å™¨ã€‚è‡³äºŽä¸ºä»€ä¹ˆèƒ½å€ŸåŠ© cs æ®µå¯„å­˜å™¨è¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ï¼Œæ˜¯å› ä¸º cs æ˜¯ä¿å­˜å¾®å¤„ç†å™¨æ‰§è¡Œä»£ç çš„å†…å­˜æ®µï¼Œcsï¼ˆä»£ç æ®µå¯„å­˜å™¨ï¼‰æŒæœ‰æ®µçš„èµ·å§‹ä½ç½®ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ 0x07c0ã€‚è¿™é‡Œï¼Œä¹Ÿä¸å¾—ä¸è¯´ï¼Œæ€ªä¸å¾— cpu é‡Œé¢è¦æžè¿™ä¹ˆå¤šå¯„å­˜å™¨çš„ï¼Œå…¶å®žéƒ½æ˜¯ç”¨çš„ç€çš„ï¼Œå°±æ˜¯ç€å®žéš¾è®°ðŸ˜“ã€‚è¿˜æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œå°±æ˜¯ bootsect.s å·²ç»ç”¨è¿‡ msg1 è¿™ä¸ªæ ‡è¯†ç¬¦äº†ï¼Œè¿™é‡Œéœ€è¦ç”¨ msg2 äº†ã€‚ åœ¨ç¼–è¯‘ setup.s ä¹‹å‰ï¼Œè¿˜éœ€è¦åšä¸€ä»¶äº‹æƒ…ï¼Œé‚£å°±æ˜¯è®© bootsect.s è¯»å…¥ setup.sã€‚é‚£ä¹ˆå¦‚ä½•è¯»å…¥ setup.s å‘¢ï¼Ÿå…¶å®žå°±æ˜¯ä½¿ç”¨ 0x13 ä¸­æ–­ï¼Œå¯ä»¥å‘çŽ°åˆ°ç›®å‰ä½ç½®æˆ‘ä»¬éƒ½æ˜¯é€šè¿‡ bios ä¸­æ–­åœ¨è¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æžœã€‚çŽ°åœ¨çœ‹æ¥ï¼Œbios ä¸­æ–­å°±åƒæ˜¯å¯ä¾›ä½¿ç”¨çš„ä¸€ä¸ªå·¥å…·ä¸€æ ·ï¼ˆäº‹å®žä¸Šï¼Œå®ƒæœ¬èº«å°±æ˜¯å¦‚æ­¤ï¼‰ã€‚ é‚£ä¹ˆè·Ÿç€è€å¸ˆçš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¿®æ”¹åŽçš„ bootsect.s çš„æºç ï¼š12345678910111213141516171819202122232425262728293031323334SETUPLEN=2SETUPSEG=0x07e0entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup mov dx,#0x0000 mov ax,#0x0000 int 0x13 jmp load_setupok_load_setup: jmpi 0,SETUPSEGmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 å†æ¥ç®€å•è§£é‡Šä¸€ä¸‹è¿™æ®µä»£ç ï¼Œ0x13 ä¸­æ–­å¯¹ ahã€alã€bhã€blã€ch å’Œ cl çš„å€¼æœ‰è¦æ±‚ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨å®ƒä¹‹å‰ï¼Œè¦å…ˆå¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„å€¼ã€‚åœ¨ linux-0.11 çš„ bootsect.s æ–‡ä»¶ä¸­ï¼ŒSETUPLEN çš„å€¼ä¸º 4ï¼Œä»£è¡¨äº† 4 ä¸ªæ‰‡åŒºï¼Œè¿™é‡Œæˆ‘ä»¬åªè¯» 2 ä¸ªï¼Œæ‰€ä»¥ SETUPLEN çš„å€¼åœ¨å¼€å¤´è®¾ç½®ä¸º 2ã€‚jmp load_setupæ˜¯åœ¨æœ«å°¾è®¾ç½®çš„å¾ªçŽ¯ï¼Œå¦‚æžœè½½å…¥å¤±è´¥å°±ä¼šä»Žå¤´å¼€å§‹ã€‚ è½½å…¥æˆåŠŸåŽï¼Œä¼šè·³è½¬æ‰§è¡Œ setup.sã€‚æ­¤æ—¶ï¼Œéœ€è¦å…ˆæžæ¸…æ¥š setup.s åœ¨å“ªé‡Œï¼Œé€šè¿‡å‰é¢è°ƒç”¨ 0x13 ä¸­æ–­å¯çŸ¥æˆ‘ä»¬å°† setup.s æ”¾åœ¨äº† 0x07c0 çš„åŽ 2 ä¸ªæ‰‡åŒºã€‚è€Œ bootsect.s æœ¬èº«å  1 ä¸ªæ‰‡åŒºï¼Œæ‰€ä»¥ SETUPSEG éœ€è¦è®¾ç½®ä¸º 0x07e0ï¼Œå°±æ˜¯ 0x07c0 åŠ äº† 512 å­—èŠ‚ï¼ˆ1 ä¸ªæ‰‡åŒºï¼‰åŽçš„åœ°å€ï¼Œè¿™æ ·å°±å®Œæˆäº†ä»Ž bootsect.s åˆ° setup.s çš„è·³è½¬ã€‚ æºç å®ŒæˆåŽå°±å¯ä»¥ç¼–è¯‘è¿è¡Œæ£€æŸ¥ç»“æžœäº†ã€‚ä½†çŽ°åœ¨æœ‰ 2 ä¸ªæ–‡ä»¶éœ€è¦ç¼–è¯‘ã€é“¾æŽ¥ã€‚å¦‚æžœéƒ½æ‰‹åŠ¨ç¼–è¯‘ï¼Œå°±å¤ªæ…¢äº†ï¼Œæ‰€ä»¥å€ŸåŠ© Makefile æ˜¯æœ€ä½³æ–¹å¼ã€‚ è¿›å…¥linux-0.11ç›®å½•åŽï¼Œä½¿ç”¨ä¸‹é¢å‘½ä»¤ï¼š1make BootImage æ­¤æ—¶ä¼šçœ‹åˆ°ä¸‹é¢çš„é”™è¯¯ï¼š12Unable to open &apos;system&apos;make: *** [BootImage] Error 1 æœ‰ Errorï¼è¿™æ˜¯å› ä¸º make æ ¹æ® Makefile çš„æŒ‡å¼•æ‰§è¡Œäº†tools/build.cï¼Œbuild.c æ˜¯ä¸ºç”Ÿæˆæ•´ä¸ªå†…æ ¸çš„é•œåƒæ–‡ä»¶è€Œè®¾è®¡çš„ï¼Œè€Œæˆ‘ä»¬å´åªéœ€è¦ç¼–è¯‘ bootsect.s å’Œ setup.s ã€‚å®ƒåœ¨å‘æˆ‘ä»¬è¦ â€œç³»ç»Ÿâ€ çš„æ ¸å¿ƒä»£ç ã€‚ä¸ºå®Œæˆå®žéªŒï¼Œéœ€è¦ç»™å®ƒæ‰“ä¸ªå°è¡¥ä¸ã€‚ build.c çš„å·¥ä½œåŽŸç†ä»Žå‘½ä»¤è¡Œå‚æ•°å¾—åˆ° bootsectã€setup å’Œ system å†…æ ¸çš„æ–‡ä»¶åï¼Œå°†ä¸‰è€…åšç®€å•çš„æ•´ç†åŽä¸€èµ·å†™å…¥ Imageã€‚å…¶ä¸­ system æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ˆargv[3]ï¼Ÿï¼‰ã€‚å½“make allæˆ–è€…makeallçš„æ—¶å€™ï¼Œè¿™ä¸ªå‚æ•°ä¼ è¿‡æ¥çš„æ˜¯æ­£ç¡®çš„æ–‡ä»¶åï¼Œbuild.c ä¼šæ‰“å¼€å®ƒï¼Œå°†å†…å®¹å†™å…¥ Imageã€‚è€Œmake BootImageæ—¶ï¼Œä¼ è¿‡æ¥çš„æ˜¯å­—ç¬¦ä¸² noneã€‚æ‰€ä»¥ï¼Œæ”¹é€  build.c çš„æ€è·¯å°±æ˜¯å½“ argv[3] æ˜¯ none çš„æ—¶å€™ï¼Œåªå†™ bootsect å’Œ setupï¼Œå¿½ç•¥æ‰€æœ‰ä¸Ž system æœ‰å…³çš„å·¥ä½œï¼Œæˆ–è€…åœ¨è¯¥å†™ system çš„ä½ç½®éƒ½å†™ä¸Š â€œ0â€ã€‚ è¦è¾¾åˆ°ä¸Šè¿°æ•ˆæžœï¼Œæˆ‘ä»¬åªéœ€è¦å°† build.c ä¸­ç¬¬ 178 - 190 è¡Œæ³¨é‡ŠæŽ‰å³å¯ã€‚ ç„¶åŽå†è¿›å…¥åˆ°~/oslab/linux-0.11ç›®å½•ä¸‹ï¼Œæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼š12make BootImage../run å°±å¯ä»¥å¾—åˆ°ä¸‹é¢çš„ç»“æžœï¼š å¯ä»¥å‘çŽ°è¿™ä¸ªç»“æžœè·Ÿä¹‹å‰ bootsect.s äº§ç”Ÿçš„ç»“æžœæ˜¯ç±»ä¼¼çš„ï¼ŒåŽŸå› å°±æ˜¯å› ä¸ºè¿™é‡Œçš„ setup.s å®Œå…¨å°±æ˜¯å¤åˆ¶çš„ bootsect.sã€‚ çŽ°åœ¨ï¼Œå†æ¥è§£å†³æœ€åŽä¸€ä¸ªä»»åŠ¡ï¼šåˆ©ç”¨ setup.s èŽ·å–ç¡¬ä»¶å‚æ•°ï¼Œä¿å­˜å¹¶è¾“å‡ºåˆ°å±å¹•ä¸Šï¼Œä¸”ä¸å†åŠ è½½å†…æ ¸ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>HIT_OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux é›¶æ•£çŸ¥è¯†]]></title>
    <url>%2F2021%2F10%2F19%2FLinux-%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[è®°å½•ä¸€äº›å®¹æ˜“å¿˜è®°ä¸”ä¸Ž Linux ç›¸å…³çš„ä¸€äº›å®žç”¨çŸ¥è¯†ï¼Œæ–¹ä¾¿è‡ªå·±æŸ¥è¯¢ã€‚ zsh çš„ä¸€äº›å¿«æ·é”® æŒ‰é”® ä½œç”¨ Ctrl + d é”®ç›˜è¾“å…¥ç»“æŸæˆ–é€€å‡ºç»ˆç«¯ Ctrl + s æš‚åœå½“å‰ç¨‹åºï¼Œæš‚åœåŽæŒ‰ä¸‹ä»»æ„é”®æ¢å¤è¿è¡Œ Ctrl + z å°†å½“å‰ç¨‹åºæ”¾åˆ°åŽå°è¿è¡Œï¼Œæ¢å¤åˆ°å‰å°ä¸ºå‘½ä»¤fg Ctrl + a å°†å…‰æ ‡ç§»è‡³è¾“å…¥è¡Œå¤´ï¼Œç›¸å½“äºŽHomeé”® Ctrl + e å°†å…‰æ ‡ç§»è‡³è¾“å…¥è¡Œæœ«ï¼Œç›¸å½“äºŽEndé”® Ctrl + k åˆ é™¤ä»Žå…‰æ ‡æ‰€åœ¨ä½ç½®åˆ°è¡Œæœ« Alt + Backspace å‘å‰åˆ é™¤ä¸€ä¸ªå•è¯ Shift + PgUp å°†ç»ˆç«¯æ˜¾ç¤ºå‘ä¸Šæ»šåŠ¨ Shift + PgDn å°†ç»ˆç«¯æ˜¾ç¤ºå‘ä¸‹æ»šåŠ¨ Shell å¸¸ç”¨çš„é€šé…ç¬¦ å­—ç¬¦ å«ä¹‰ * åŒ¹é… 0 æˆ–å¤šä¸ªå­—ç¬¦ ? åŒ¹é…ä»»æ„ä¸€ä¸ªå­—ç¬¦ [list] åŒ¹é… list ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ [^list] åŒ¹é…é™¤ list ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ä»¥å¤–çš„å­—ç¬¦ [c1-c2] åŒ¹é… c1 - c2 ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ï¼Œå¦‚ï¼š[0-9][a-z] {string1, string2, â€¦} åŒ¹é… string1 æˆ– string2 ï¼ˆæˆ–æ›´å¤šï¼‰å…¶ä¸€å­—ç¬¦ä¸² {c1..c2} åŒ¹é… c1 - c2 ä¸­å…¨éƒ¨å­—ç¬¦ï¼Œå¦‚ï¼š{1..10} ç³»ç»Ÿæ—¥å¿—æ–‡ä»¶ æ—¥å¿—åç§° è®°å½•ä¿¡æ¯ alternatives.log ç³»ç»Ÿçš„ä¸€äº›æ›´æ–°æ›¿ä»£ä¿¡æ¯ apport.log åº”ç”¨ç¨‹åºå´©æºƒä¿¡æ¯ apt/history.log ä½¿ç”¨ apt-get å®‰è£…å¸è½½è½¯ä»¶çš„ä¿¡æ¯è®°å½• apt/term.log ä½¿ç”¨ apt-get æ—¶çš„å…·ä½“æ“ä½œï¼Œå¦‚ package çš„ä¸‹è½½ã€æ‰“å¼€ç­‰ auth.log ç™»å½•è®¤è¯çš„ä¿¡æ¯è®°å½• boot.log ç³»ç»Ÿå¯åŠ¨æ—¶çš„ç¨‹åºæœåŠ¡çš„æ—¥å¿—ä¿¡æ¯ btmp é”™è¯¯çš„ä¿¡æ¯è®°å½• Consolekit/history æŽ§åˆ¶å°çš„ä¿¡æ¯è®°å½• dis-upgrade dis-upgrade è¿™ç§æ›´æ–°æ–¹å¼çš„ä¿¡æ¯è®°å½• dmesg å¯åŠ¨æ—¶ï¼Œæ˜¾ç¤ºå±å¹•ä¸Šå†…æ ¸ç¼“å†²ä¿¡æ¯ï¼Œä¸Žç¡¬ä»¶æœ‰å…³çš„ä¿¡æ¯ dpkg.log dpkg å‘½ä»¤ç®¡ç†åŒ…çš„æ—¥å¿— faillog ç”¨æˆ·ç™»å½•å¤±è´¥è¯¦ç»†ä¿¡æ¯è®°å½• fontconfig.log ä¸Žå­—ä½“é…ç½®æœ‰å…³çš„ä¿¡æ¯è®°å½• kern.log å†…æ ¸äº§ç”Ÿçš„ä¿¡æ¯è®°å½•ï¼Œåœ¨è‡ªå·±ä¿®æ”¹å†…æ ¸æ—¶æœ‰å¾ˆå¤§å¸®åŠ© lastlog ç”¨æˆ·çš„æœ€è¿‘ä¿¡æ¯è®°å½• wtmp ç™»å½•ä¿¡æ¯çš„è®°å½•ï¼Œwtmp å¯ä»¥æ‰¾å‡ºè°æ­£åœ¨è¿›å…¥ç³»ç»Ÿï¼Œè°ä½¿ç”¨å‘½ä»¤æ˜¾ç¤ºè¿™ä¸ªæ–‡ä»¶æˆ–ä¿¡æ¯ç­‰ syslog ç³»ç»Ÿä¿¡æ¯è®°å½•]]></content>
  </entry>
  <entry>
    <title><![CDATA[æ–™ç†éšè®°]]></title>
    <url>%2F2021%2F09%2F07%2F%E6%96%99%E7%90%86%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æƒ³ä¸åˆ°è‡ªå·±æŽ¥è¿‘ä¸€å¹´æ²¡æœ‰æ›´åšåŽï¼Œå†æ¬¡æ›´åšçš„ç¬¬ä¸€ç¯‡æ–‡ç« ä¼šæ˜¯è¿™ä¸ªä¸»é¢˜ã€‚ä¸è¿‡åæ­£ä¹Ÿæ²¡æœ‰äººçœ‹ï¼Œæƒå½“æ˜¯è‡ªå·±è®°å½•ç”¨çš„ä¹Ÿå¯ã€‚ ç›®å‰æŽŒæ¡çš„æ–™ç†æ²¡æœ‰é‚£ä¹ˆå¤šï¼Œå¯¹çƒ¹é¥ªçš„ç ”ç©¶ä¹Ÿä¸å¤ªæ·±ï¼Œç´¢æ€§å°±ä¸åˆ†çš„å¤ªæ¸…æ¥šäº†ï¼Œç›´æŽ¥è®°å½•ä¸‹éœ€è¦çš„å¤§æ¦‚ä¿¡æ¯å³å¯ã€‚ é…¸è¾£åœŸè±†ä¸è¿™é“èœä¼°è®¡æ˜¯å¾ˆå¤šäººå­¦ä¼šçš„ç¬¬ä¸€é“èœäº†ï¼Œä¸è¿‡æˆ‘å¥½åƒå·²ç»å¿˜è®°äº†ç¬¬ä¸€ä¸ªä¼šåšçš„èœäº†ã€‚ é…¸è¾£åœŸè±†ä¸è¦æƒ³ç‚’å¥½ï¼ŒåœŸè±†ä¸ä¸€å®šè¦åˆ‡æˆâ€œä¸â€ã€‚å½“ç„¶äº†ï¼Œä¹Ÿä¸æ˜¯è¯´ä¸€å®šè¦è·Ÿç±³ç²‰ä¸€æ ·ç»†ï¼Œç²—ç»†é€‚ä¸­ï¼Œåƒç«æŸ´æ¢—é‚£ä¸ªå¤§å°å³å¯ï¼Œç•¥å¤§ä¹Ÿè¡Œï¼Œæ‰€ä»¥è¦ç†Ÿç»ƒçš„ä½¿ç”¨èœåˆ€ï¼Œåˆ‡è®°å°å¿ƒä¸è¦åˆ‡åˆ°æ‰‹æŒ‡äº†ã€‚åˆ‡å¥½åŽçš„åœŸè±†ä¸ï¼Œä¸è¦ç›´æŽ¥æš´éœ²åœ¨ç©ºæ°”ä¸­ï¼Œå¦åˆ™åœŸè±†ä¸çš„é¢œè‰²ä¼šå˜ç°ï¼Œæ‰€ä»¥è¦æ”¾ç½®åœ¨æœ‰æ°´çš„ç¢—ä¸­æ³¡ç€ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œæœ‰äº›åœ°æ–¹è¿™é“èœæ˜¯ä¸æ”¾é’æ¤’çš„ã€‚è€Œä¸ºäº†æœ‰è¾£å‘³ï¼Œä¸€å¼€å§‹èµ·é”…å°‘çƒ§å¥½æ²¹åŽï¼Œè’œå’Œå¹²è¾£æ¤’çˆ†é¦™åŽï¼Œå°±ç›´æŽ¥ä¸‹åœŸè±†ä¸äº†ã€‚å¦å¤–ï¼Œä¸ºäº†ç»´æŒåœŸè±†ä¸çš„ç™½è‰²ï¼ˆæˆ–è€…ç±³é»„è‰²ï¼‰ï¼Œå¤šç”¨ç™½é†‹è°ƒå‘³ï¼Œè€Œä¸æ˜¯é™ˆé†‹ã€‚ ï¼ˆä¾ç¨€è®°å¾—ï¼Œæ¯äº²ç‚’åœŸè±†ä¸æ—¶ï¼Œè¾£å‘³æ˜¯åŠ äº†è±†ç“£é…±æ¥çš„ï¼Œå¹¶æ²¡æœ‰æ”¾å¹²è¾£æ¤’ï¼Œè¿™å¯èƒ½æ˜¯æˆ‘å®¶çš„åƒæ³•ã€‚ï¼‰ æ¸…ç‚’è¥¿å…°èŠ±è¿™é“èœåœ¨çœŸæ­£å¼€å§‹ç‚’ä¹‹å‰å‡†å¤‡å·¥ä½œæ¯”è¾ƒå¤šã€‚å…ˆæ˜¯è¥¿å…°èŠ±çš„å¤„ç†ï¼Œç”¨åˆ€åŽ»é™¤è€æ ¹ï¼Œå¹¶å°†å¤§æœµè¥¿å…°èŠ±æ”¹æˆå°æœµï¼Œæ´—å‡€ã€‚ç„¶åŽï¼Œå¾€é”…å†…åŠ æ°´ï¼Œæ°´é¢ç¨ä¸ºå¯ä»¥å®½ä¸€ç‚¹ï¼Œå¾…é”…ä¸­æ°´çƒ§å¼€åŽï¼Œå°†è¥¿å…°èŠ±å€’å…¥é”…ä¸­ã€‚æ³¨æ„ç„¯æ°´æ—¶é—´ä¸è¦è¿‡ä¹…ï¼Œå¦åˆ™ä¸€æ¥ä¼šä½¿è¥¿å…°èŠ±çš„å£æ„Ÿå˜è€ã€å˜è½¯ï¼ŒäºŒæ¥ä¼šä½¿è¥¿å…°èŠ±ä¸­çš„è¥å…»ç‰©è´¨æµå¤±ã€‚ æŽ¥ç€ï¼Œèµ·é”…çƒ§æ²¹ï¼Œä¸‹è’œçˆ†é¦™ï¼Œå†å€’å…¥è¥¿å…°èŠ±ç¿»ç‚’ï¼ŒåŠ å…¥ç›ã€é¸¡ç²¾ã€ç™½é†‹ç­‰è°ƒå‘³æ–™ã€‚ç”±äºŽä¹‹å‰è¿›è¡Œäº†ç„¯æ°´è¿™ä¸ªæ­¥éª¤ï¼Œæ‰€ä»¥è¿™æ—¶ï¼Œä¸è¦ç‚’å¤ªä¹…ï¼Œé—»åˆ°é¦™å‘³ï¼Œå·®ä¸å¤šå°±å¯ä»¥å‡ºé”…äº†ã€‚ å½“ç„¶äº†ï¼Œè¯´æ˜¯æ¸…ç‚’ï¼Œå¹¶ä¸æ˜¯å®Œå…¨ä¸åŠ å…¶ä»–é…èœäº†ã€‚ä¸ºäº†èœè‰²ï¼Œå¯ä»¥åŠ å…¥é€‚é‡çš„æœ¨è€³å’Œçº¢æ¤’ä¸æ¥ç‚¹ç¼€ï¼ˆäºŒè€…å¯ä»¥ä¸Žè¥¿å…°èŠ±ä¸€åŒç„¯æ°´ï¼‰ï¼Œä¸ºäº†å¢žé²œï¼Œä¹Ÿå¯ä»¥åœ¨å‡ºé”…å‰åŠ å…¥å°‘è®¸èšæ²¹ï¼Œç¿»ç‚’å‡åŒ€åŽå†å‡ºé”…ã€‚ æ¸…ç‚’ä¸Šæµ·é’è¿™é“èœçš„åšæ³•è·Ÿæ¸…ç‚’è¥¿å…°èŠ±ç±»ä¼¼ï¼ˆæ¸…ç‚’é’èœåŸºæœ¬éƒ½æ˜¯è¿™æ ·ï¼‰ï¼Œå¯ä»¥æå‰ç„¯æ°´ä¹Ÿå¯ä»¥ä¸æå‰ç„¯æ°´ã€‚ä¸Šæµ·é’çš„èœæ ¹å°½é‡åŽ»é™¤çš„å½»åº•ä¸€ç‚¹ï¼Œè¿™æ ·åƒèµ·æ¥ä¼šæ„Ÿè§‰å«©ä¸€äº›ã€‚ä¸ºäº†é¿å…æ²¹çƒ§çƒ­åŽï¼Œç›´æŽ¥ä¸‹è’œçˆ†é¦™è¿‡åº¦å¯¼è‡´çš„è’œå˜é»‘ã€å˜ç³Šï¼Œå¯ä»¥å…ˆæ”¾å…¥ä¸Šæµ·é’ï¼Œç¨å¾®ç¿»ç‚’ä¸€ä¼šåŽï¼Œå†ä¸‹è’œï¼Œç­‰åˆ°æœ‰è’œé¦™äº†åŽï¼Œå†å‡ºé”…ã€‚ çº¢çƒ§é¸¡ç¿…å…ˆå°†é¸¡ç¿…æ”¹èŠ±åˆ€ï¼Œç„¶åŽå†·æ°´ä¸‹é”…ç„¯æ°´ï¼Œå¯ä»¥åŠ å…¥å°‘è®¸å§œç‰‡ä¸Žç›ï¼Œå¾…é¸¡ç¿…å·®ä¸å¤šç†Ÿäº†åŽï¼Œæžå‡ºå¤‡ç”¨ã€‚ç„¶åŽå€’å‡ºé”…å†…çš„æ°´ï¼Œå°†é”…å†…çš„è‚‰æ²«æ¸…æ´—å¹²å‡€åŽï¼Œå€’å…¥é€‚é‡çš„æ²¹ã€‚å¾…æ²¹çƒ§çƒ­åŽï¼Œä¸‹å…¥è’œã€å§œçˆ†é¦™ï¼Œæ­¤æ—¶å¯ä»¥å°ç«æ…¢çƒ§ï¼Œç…¸å‡ºé¦™å‘³åŽï¼Œå¼€å§‹åŠ å…¥é…±æ²¹ã€é†‹ã€ç›ç­‰å…¶ä»–è°ƒæ–™ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨è±†ç“£é…±æ¥ä½¿èœè‰²å˜çº¢ã€‚ å¾…å›½å†…æ±¤æ±å¼€å§‹æ”¶æ±åŽï¼ŒåŠ å…¥ä¹‹å‰å¤‡å¥½çš„é¸¡ç¿…ï¼Œå°ç«æ…¢ç‚–ã€‚å‡ºé”…å‰ï¼Œå¯ä»¥å†åŠ å…¥å°‘è®¸é’æ¤’ç‚¹ç¼€èœè‰²ã€‚ ç™½ç¼åŸºå›´è™¾è¿™é“èœåˆ†ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯å¯¹è™¾çš„å¤„ç†ï¼Œå¦ä¸€ä¸ªæ˜¯å¦‚ä½•è°ƒç†è˜¸æ±ã€‚ è™¾çš„å¤„ç†åŒæ ·åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼Œç¬¬ä¸€ä¸ªæ˜¯æ´»è™¾çš„æ¸…æ´—ï¼ŒåŽ»æŽ‰è™¾å¤´ã€è™¾è„‘ã€è™¾çº¿ç­‰ã€‚ç¬¬äºŒä¸ªå°±æ˜¯å°†è™¾ç…®ç†Ÿï¼Œå…ˆçƒ§å¼€æ°´ï¼Œç„¶åŽå†å°†è™¾ä¸‹é”…ã€‚ä¹‹æ‰€ä»¥è¦çƒ§å¼€æ°´å†ä¸‹é”…ï¼Œæ˜¯ä¸ºäº†å‡å°‘ç…®è™¾çš„æ—¶é—´ï¼Œä»¥å…è™¾è‚‰å£æ„Ÿå˜è€ï¼›åŒæ—¶ï¼Œå¼€æ°´ä¸­å¯ä»¥åŠ å…¥é€‚é‡çš„ç›ã€ç”Ÿå§œã€æ–™é…’ç”¨æ¥åŽ»é™¤è™¾çš„è…¥å‘³ã€‚å¤§æ¦‚ç…® 5 - 10 åˆ†é’Ÿå·¦å³ï¼Œè™¾èº«å˜çº¢åŽå°±å¯ä»¥æžå‡ºäº†ã€‚ è˜¸æ±çš„å¤„ç†ä¸ä½œç»†è¯´ï¼Œè™½è¯´è¿™é“èœæ˜¯é“ç²¤èœï¼Œä½†æˆ‘ä»¬æ˜¯å®¶å¸¸åšæ³•ï¼Œæ‰€ä»¥æŒ‰ç…§è‡ªå·±çš„å£å‘³æ¥è°ƒå³å¯ï¼Œå»ºè®®å°‘è®¸é…±æ²¹ã€é™ˆé†‹ã€è’œè“‰ã€ç³–ã€ç›å³å¯ï¼Œç³–ã€ç›ä¹Ÿå¯å•ç‹¬åªåŠ ä¸€ç§ã€‚è‹¥æ˜¯å–œæ¬¢åƒå…¶ä»–çš„è°ƒå‘³æ–™ï¼ˆèŠ¥æœ«ï¼Ÿï¼‰ï¼Œä¹Ÿå¯ä»¥è‡ªå·±åŠ ã€‚ åœŸè±†ç‚–é¸¡å—è¿™é“èœä¸­çš„â€œé¸¡å—â€ä¸€å®šè¦é€‰è‚‰å¤šçš„éƒ¨ä½ï¼ŒæŽ¨èé¸¡å¤§è…¿èƒ¯å­ï¼Œæ”¹æˆå°åˆ€ï¼ŒåŠ ç›è…Œåˆ¶ä¸€å®šæ—¶é—´ï¼Œä¹Ÿå¯ä»¥åŠ å…¥å®šé‡çš„ç”Ÿç²‰ï¼Œä½¿è‚‰è´¨æ›´åŠ é²œå«©ï¼Œé¿å…é¸¡è‚‰å£æ„Ÿè¾ƒâ€œé¢â€ã€‚ å€’å…¥é€‚é‡çš„æ²¹ï¼Œå…ˆå°†é¸¡å—ç‚¸ç†Ÿï¼Œç„¶åŽå†åŠ å…¥è€æŠ½ä¸Šè‰²ï¼Œç»§è€ŒåŠ å…¥è’œã€å§œã€é…±æ²¹ã€è±†ç“£é…±ã€èŠ±æ¤’ç­‰å…¶ä»–è°ƒæ–™ï¼Œç­‰åˆ°èœè‰²ã€èœé¦™éƒ½å‡ºæ¥åŽï¼ŒåŠ å…¥é€‚é‡çš„æ¸…æ°´ï¼Œç›–ä¸Šé”…ç›–ã€‚ç¨å¾®ç…®ä¸€ä¼šåŽï¼Œå€’å…¥åœŸè±†ï¼Œå…ˆå¤§ç«ç…®ã€‚è§‚å¯ŸåœŸè±†æˆè‰²ï¼Œå·®ä¸å¤šç†Ÿäº†åŽï¼Œæ”¹å°ç«ç…®ï¼Œæ­¤æ—¶æ±¤æ±å¼€å§‹æ”¶æ±ï¼Œå¯ä»¥å†åŠ å…¥åˆ‡å¥½çš„é’è¾£æ¤’ï¼Œç”¨ä»¥è°ƒé…èœè‰²ã€‚å°†é’è¾£æ¤’ç¿»ç‚’å‡ºå‘³åŽï¼Œå³å¯å‡ºé”…ã€‚ é’æ¤’è‚‰ä¸å…ˆå°†çŒªè‚‰æ´—å‡€ï¼Œç„¶åŽåˆ‡æˆä¸ã€‚çŒªè‚‰è¦æƒ³åˆ‡çš„ä¸å¤Ÿç»†ï¼Œå¤§è‡´æ³¨æ„ 2 ä¸ªç‚¹ï¼š æ¨ªåˆ‡ç‰›ç¾Šç«–åˆ‡çŒªï¼Œè¦é¡ºç€çŒªè‚‰çš„çº¹ç†åˆ‡ï¼Œå³åˆ€å’Œè‚‰çš„çº¹ç†å‘ˆæ°´å¹³çº¿ è¦æƒ³åˆ‡ä¸ï¼Œå…ˆè¦åˆ‡ç‰‡ï¼Œç‰‡æ‰“çš„çˆ†ï¼Œä¸å°±å¤Ÿä¸ï¼ˆè¿™è·Ÿåˆ‡åœŸè±†ä¸æ˜¯ä¸€æ ·çš„ï¼‰ åˆ‡å¥½çš„çŒªè‚‰åŠ å…¥é£Ÿç›ã€ç”Ÿç²‰ï¼ˆä¹Ÿå¯åŠ å…¥å…¶ä»–çš„è°ƒæ–™ï¼Œåªè¦å¥½åƒçš†å¯ï¼‰è…Œåˆ¶ 10 - 20 åˆ†é’Ÿå·¦å³ï¼ŒæœŸé—´å¯ä»¥å‡†å¤‡å¥½è’œã€å§œã€å¹²è¾£æ¤’ã€é’æ¤’ä¸ç­‰ã€‚ç„¶åŽçƒ§æ²¹ï¼Œæ²¹æ¸©å¤§æ¦‚åˆ°å…«æˆï¼Œè‚‰ä¸å³å¯ä¸‹é”…ï¼Œä¸ƒå…«æˆç†ŸåŽï¼ŒåŠ å…¥è’œã€å§œã€å¹²è¾£æ¤’ã€‚ç‚’å‡ºé¦™å‘³åŽï¼Œå†åŠ å…¥è±†ç“£é…±ã€é…±æ²¹ã€ç›ç­‰è°ƒæ–™ï¼Œè®©èœè‰²æ›´äº®ï¼Œå‘³é“æ›´é²œã€‚æ­¤æ—¶ï¼Œå¯ä»¥åŠ å…¥å°‘è®¸æ¸…æ°´ï¼Œä»¥å…ç«å¤§ç³Šé”…ã€‚æœ€åŽåŠ å…¥é’æ¤’ä¸ï¼Œå¿«é€Ÿç‚’å‡ºå‘³åŽï¼Œå³å¯å‡ºé”…ã€‚ ç³–æ‹Œè¥¿çº¢æŸ¿æŒ‘å‡ ä¸ªæˆç†Ÿçš„è¥¿çº¢æŸ¿ï¼Œæ´—å‡€ã€‚å¦‚æžœä¸å–œæ¬¢åƒçš®ï¼Œå¯ä»¥å…ˆåœ¨è¥¿çº¢æŸ¿è¡¨é¢æ”¹ä¸€ä¸ªå¤§çš„åå­—èŠ±åˆ€ï¼Œç„¶åŽç”¨å¼€æ°´æ³¡ä¸ª 3 - 5 åˆ†é’Ÿå·¦å³ï¼Œç„¶åŽå°±å¯ä»¥è½»æ˜“çš„æ’•æŽ‰è¡¨çš®äº†ã€‚ç„¶åŽåœ¨å°†å¤„ç†å¥½çš„è¥¿çº¢æŸ¿æ”¹æˆä¸€é¡µä¸€é¡µçš„å½¢çŠ¶ï¼Œæ‘†æ”¾åœ¨ç›˜ä¸­åŽï¼Œæ’’ä¸Šç™½ç³–å³å¯ã€‚å¦‚æžœä¸æ˜¯é‚£ä¹ˆå–œæ¬¢åƒé…¸çš„ï¼Œå¯ä»¥å…ˆå°†æ”¹å¥½çš„åˆ€çš„è¥¿çº¢æŸ¿ç”¨å°‘é‡ç›è…Œåˆ¶å‡ åˆ†é’Ÿï¼Œç„¶åŽå†æ‘†ç›˜æ’’ä¸Šç™½ç³–ã€‚ å°è‘±æ‹Œè±†è…æŒ‘ä¸€å—å®Œå¥½çš„å«©è±†è…å—ï¼Œåˆ‡æˆä¸€ä¸ªä¸ªå°æ­£æ–¹ä½“å½¢çŠ¶ï¼Œå¾…é”…é‡Œæ°´çƒ§å¼€åŽï¼Œå†å°†è±†è…ä¸‹å…¥è¿‡é”…ä¸­ç„¯æ°´ï¼Œé”…ä¸­å¯ä»¥åŠ å…¥é€‚é‡çš„ç›ï¼Œå¯èƒ½ä¼šä½¿è±†è…çš„å£æ„Ÿæ›´åŠ ç´§è‡´ã€‚ç†ŸåŽï¼Œç››å…¥ç›˜å­ä¸­ã€‚æ­¤æ—¶ï¼Œå¯ä»¥å‘ç›˜å­ä¸­åŠ å…¥è°ƒå‘³æ–™ï¼Œé”…é‡Œå¼€å§‹çƒ§æ²¹ã€‚è¿™é“èœæœ‰äººè°æ˜¯ä¸œåŒ—èœï¼Œæœ‰äººè¯´æ˜¯é²èœï¼Œä¸ªäººè§‰å¾—åƒæ˜¯é²èœã€‚è€Œåœ¨é²èœä¸­ï¼Œè¿™é“èœè²Œä¼¼å‘³ä¸æ˜¯å¾ˆé‡ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¸åŠ é…±æ²¹ï¼Œå¤§æ¦‚åªæ”¾ç›ã€é¸¡ç²¾ã€ç™½é†‹ã€é¦™æ²¹ã€‚è°ƒå‘³æ–™åŠ æ²¹åŽï¼Œæ’’ä¸Šè‘±èŠ±ï¼Œå°†é”…é‡Œçƒ§å¥½çš„æ²¹æ·‹åˆ°è‘±èŠ±ä¸Šï¼Œåœ¨æ»´ä¸Šå‡ æ»´é¦™æ²¹ï¼Œå¾ˆé¦™ã€‚ é…¸è¾£å¤§ç™½èœé€‰å–æ–°é²œç™½èœï¼Œèœå¶å¤ªå¤§çš„è¯å¯ä»¥ç”¨åˆ€æ”¹å°ä¸€ç‚¹ï¼Œæ´—å‡€ï¼Œæ”¾ç½®ä¸€æ—å¤‡ç”¨ã€‚å‡†å¤‡ä¸€å®šé‡çš„è’œæœ«ï¼Œè¿™é“èœçš„è¾£å‘³å¯ä»¥ç”¨å¹²è¾£æ¤’æ¥è°ƒï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å°ç±³æ¤’ã€‚å…ˆä¸‹è¾£æ¤’è·Ÿè’œæœ«ç‚é”…ï¼Œç„¶åŽä¸‹ç™½èœç¿»ç‚’ï¼ŒæœŸé—´å¯ä»¥åŠ å…¥ä¸€ç‚¹æ¸…æ°´ã€‚å¾…ç™½èœå·®ä¸å¤šç†Ÿäº†åŽï¼Œå¿«é€ŸåŠ å…¥é¸¡ç²¾ã€ç›ã€é†‹ç­‰è°ƒå‘³æ–™ï¼Œç¿»ç‚’å‡åŒ€åŽï¼Œå³å¯å‡ºé”…ã€‚ è‚‰æ²«èŒ„å­è‚‰æ²«èŒ„å­çš„è‚‰æ²«å¯ä»¥ç”¨çº¯ç˜¦è‚‰ï¼Œä¹Ÿå¯ä»¥ç”¨äº”èŠ±è‚‰çš„è‚‰æ²«ï¼Œä¸€èˆ¬è‚‰åº—ä¼šç›´æŽ¥å–è‚‰æ²«ï¼Œä¹Ÿå¯ä»¥ä¹°è‚‰å›žæ¥åŽè‡ªå·±å‰ï¼Œå¤šå‡ºæ¥çš„è‚‰æ²«ä¹Ÿå¯ä»¥ç”¨æ¥åŒ…é¥ºå­ã€‚èŒ„å­å¯ä»¥é€‰ç”¨ç´«çš®èŒ„å­ï¼Œä¸€èˆ¬ä¸åŽ»çš®ï¼Œä¹Ÿå¯ä»¥é€‰ç”¨é’çš®èŒ„å­ï¼Œä¸€èˆ¬è¦åŽ»çš®ã€‚å…ˆå°†èŒ„å­ä¸‹é”…ç‚’è½¯ç‚’ï¼Œç››å‡ºå¤‡ç”¨ã€‚ç„¶åŽå°†è‚‰æ²«ç‚’æ•£ï¼ŒæœŸé—´å¯ä»¥æ”¾å…¥è’œæœ«ã€ç”ŸæŠ½ç­‰è°ƒæ–™ï¼Œå¾…è‚‰æ²«ç‚’å¥½åŽå†åŠ å…¥èŒ„å­ï¼Œå†åŠ å…¥ç›ã€é†‹ç­‰è°ƒå‘³æ–™ï¼Œç¿»ç‚’å‡åŒ€å³å¯å‡ºé”…ã€‚ æ‰‹æ’•åŒ…èœè¿™é“èœè·Ÿç‚’é…¸è¾£å¤§ç™½èœç´¯æ­»ï¼Œå¦‚æžœä¸æƒ³åƒè¾£ï¼Œå¯ä»¥ä¸æ”¾è¾£æ¤’ï¼ŒåŠ å…¥è’œæœ«å³å¯ã€‚åœ¨å¿«è¦å‡ºé”…çš„æ—¶å€™ï¼Œå¯ä»¥åŠ å…¥é€‚é‡ç™½ç³–ï¼Œä½¿åŒ…èœåƒèµ·æ¥æ›´åŠ é²œã€‚ è¾£å­é¸¡ä¸é¸¡ä¸çš„é€‰ææœ‰ä¸¤ç§ï¼š é¸¡è„¯è‚‰ é¸¡å¤§è…¿è‚‰ å»ºè®®é€‰æ‹©é¸¡å¤§è…¿è‚‰æ¥åšã€‚å¦‚æžœé€‰ç”¨é¸¡å¤§è…¿è‚‰æ¥åšï¼Œé‚£ä¹ˆå°±éœ€è¦å¯¹é¸¡å¤§è…¿åŽ»éª¨ï¼Œç„¶åŽå†å°†è‚‰åˆ‡ä¸ï¼Œæ³¨æ„è‚‰ä¸è¦åˆ‡å°ä¸€ç‚¹ï¼ˆä¸è¦åƒä¸‹å›¾ä¸­è¿™ä¹ˆå¤§ï¼‰ã€‚åˆ‡å¥½åŽï¼Œç”¨ç”Ÿç²‰ã€é¸¡è›‹æ¸…ã€ç›è…Œåˆ¶ä¸€å°ä¼šã€‚åœ¨æ­¤æœŸé—´ï¼Œå¯ä»¥å‡†å¤‡å§œã€è’œã€èŠ±æ¤’ã€å¹²è¾£æ¤’ã€é’æ¤’ç­‰ã€‚èµ·é”…çƒ§å¥½æ²¹åŽï¼Œä¸‹å…¥é¸¡ä¸ï¼Œæ³¨æ„ä¸è¦è®©é¸¡ä¸ç²˜è¿žå†ä¸€èµ·ã€‚ç„¶åŽåŠ å…¥è’œã€å§œã€èŠ±æ¤’ã€å¹²è¾£æ¤’ï¼Œç‚’å‡ºå‘³ï¼ŒæŽ¥ç€ï¼ŒåŠ ä¸€å°å‹ºè±†ç“£é…±ç‚’å‡ºçº¢æ²¹ï¼ŒåŠ ä¸€ç‚¹æ¸…æ°´ç”¨ä½œæ±¤æ±ï¼Œå†åŠ å…¥é€‚é‡ç”ŸæŠ½ã€‚æœ€åŽä¸‹å…¥åˆ‡æˆå—çŠ¶çš„é’æ¤’ï¼Œå°†é’æ¤’ç‚’å‡ºå‘³å³å¯å‡ºé”…ã€‚ ç´«èœè›‹èŠ±æ±¤å…ˆå°†ç´«èœæ´—å‡€ï¼Œç„¶åŽæ”¾ç½®ä¸€æ—å¤‡ç”¨ã€‚åˆ‡å¥½è’œæœ«ï¼Œèµ·é”…çƒ§æ²¹ï¼Œå…ˆä¸‹è’œæœ«ç‚é”…ï¼Œç„¶åŽåŠ å…¥æ¸…æ°´ï¼Œæ­¤æ—¶å¯ä»¥åŠ å…¥ä¸€å®šé‡çš„è°ƒå‘³æ–™ã€‚å†å°†é¸¡è›‹æ‰“å…¥ç¢—ä¸­ï¼Œæ…æ‹Œå‡åŒ€ã€‚ç­‰é”…é‡Œçš„æ°´å·®ä¸å¤šçƒ§å¼€åŽï¼ŒåŠ å…¥ç´«èœï¼Œæ…æ‹Œæ•£å¼€ï¼Œç„¶åŽå†å€’å…¥è›‹æ¶²ï¼Œæ³¨æ„ä¸ºäº†é¿å…è›‹å‡ç»“æˆå—ï¼Œè¦å°†è›‹æ¶²è¿‚å›žå€’å…¥é”…ä¸­ï¼Œå¹¶ç”¨é”…é“²ä¸æ–­æ…æ‹Œã€‚å¤§æ¦‚é”…è¿‡ 1 - 2 åˆ†é’Ÿï¼Œè›‹ç†Ÿäº†ï¼ŒåŠ å…¥é€‚é‡è°ƒå‘³æ–™åŽå³å¯å‡ºé”…ã€‚ è¿™é“èœå¯ä»¥æ”¾é€‚é‡çš„è™¾çš®ï¼Œä¼šä½¿å¾—æ±¤å‘³æ›´åŠ é²œç¾Žï¼Œå½“ç„¶ä¸å–œæ¬¢åƒè™¾çš®çš„ä¹Ÿå¯ä»¥ä¸æ”¾ã€‚ å›žé”…è‚‰æŒ‘ä¸€å—ä¸Šå¥½çš„äº”èŠ±è‚‰ï¼Œæœ€å¥½è‚¥ç˜¦ç›¸é—´ã€‚ä¹°è‚‰çš„æ—¶å€™è®°å¾—è®©å¸ˆå‚…åŽ»æŽ‰çŒªçš®ä¸Šçš„æ¯›ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œäº”èŠ±è‚‰æ˜¯ä¸ç”¨åŽ»çš®çš„ï¼Œä½†çŒªæ¯›è¿˜æ˜¯è¦åŽ»é™¤å¹²å‡€ã€‚å°†äº”èŠ±è‚‰æ´—å‡€åŽï¼Œæ”¾å…¥é”…ä¸­ç„¯æ°´ï¼Œå†·æ°´ä¸‹é”…ï¼Œå¯ä»¥åŠ å…¥å§œç‰‡ã€è‘±ã€æ–™é…’ã€ç›ç­‰æ¥åŽ»è…¥ï¼Œå¹¶ä½¿è‚‰çš„å£æ„Ÿç´§å®žï¼ŒæœŸé—´è¦æžå‡ºé”…ä¸­æ°´ä¸Šçš„æµ®æ²«ã€‚ç”¨ä¸€æ ¹ç­·å­ï¼Œèƒ½æ’åˆ°äº”èŠ±è‚‰ä¸­æ—¶ï¼Œå°±å¯ä»¥æžå‡ºé”…äº†ã€‚å¿«é€Ÿç”¨å†·æ°´å†²ä¸€è¾¹ï¼Œè¶å¤–å†·å†…çƒ­ï¼Œå°†äº”èŠ±è‚‰åˆ‡æˆè–„ç‰‡ï¼Œä¸å–œæ¬¢åƒå¤ªå¤šè‚¥è‚‰è¯ï¼Œä¸€å®šè¦å°½é‡çš„åˆ‡è–„ç‚¹ã€‚åˆ‡å¥½åŽï¼Œæ”¾åœ¨ç›˜å­ä¸­å¤‡ç”¨ã€‚å‡†å¤‡å¥½è’œè‹—ã€é’æ¤’ã€å§œã€è’œæœ«ï¼Œèµ·é”…çƒ§æ²¹ï¼Œä¸‹å…¥è’œæœ«ã€å§œç…¸é¦™ï¼Œå†ä¸‹å…¥è‚‰ç‰‡ç…¸ç‚’è‡³è‚‰ç‰‡é¢œè‰²å˜é€æ˜Žï¼Œè¾¹ç¼˜ç•¥å¾®å·èµ·ã€‚ç„¶åŽå†åŠ å…¥è±†ç“£é…±ï¼Œç‚’å‡ºçº¢æ²¹ï¼Œå†åŠ å…¥å°‘è®¸é…±æ²¹è°ƒè‰²ï¼Œä¸Žè‚‰ç‰‡ä¸€èµ·ç¿»ç‚’å‡åŒ€ã€‚æœ€åŽå†ä¸‹å…¥è’œè‹—ã€é’æ¤’ï¼Œå¿«é€Ÿç¿»ç‚’ï¼ŒåŠ å…¥ç›ã€é†‹ç­‰è°ƒå‘³æ–™å³å¯å‡ºé”…ã€‚ å–œæ¬¢åƒè¾£ã€éº»çš„è¯ï¼Œå¯ä»¥å¹²è¾£æ¤’ã€èŠ±æ¤’ä¸Žè’œæœ«ã€å§œä¸€åŒä¸‹é”…ç…¸é¦™ï¼Œç„¶åŽå†ç‚’è‚‰ã€‚ èåœçƒ§é¸¡å—è¿™åˆæ˜¯ä¸€é“å®¶å¸¸èœï¼Œåšæ³•å…¶å®žä¸ŽåœŸè±†é’é¸¡å—å·®ä¸å¤šï¼Œä½†è¦æ³¨æ„èåœè¦æ¯”åœŸè±†æ˜“ç†Ÿï¼Œæ‰€ä»¥ç„–çš„æ—¶é—´ä¸èƒ½å¤ªé•¿ï¼Œä¸ç„¶èåœçƒ‚äº†å°±ä¸å¥½åƒäº†ã€‚å¦å¤–ï¼Œä¹‹æ‰€ä»¥è¦ç”¨èåœå½“é…èœï¼Œå…¶å®žæ˜¯å› ä¸ºå†¬å¤©åˆ°äº†ï¼Œå¤šåƒèåœï¼Œå¯ä»¥è¡¥å……èº«ä½“çš„æ°´åˆ†ï¼Œè¡¥æ°”é€šè‚ºã€‚PSï¼šä¸‹é¢çš„å›¾ç‰‡ç”¨çš„æ±¤ç¢—è£…çš„ï¼Œçœ‹åƒç€å®žä¸å¥½ï¼Œè¿˜æ˜¯ç”¨ç›˜å­å¥½ã€‚ é»„ç“œç‚’è›‹è¿™ä¹Ÿæ˜¯ä¸€é“å¾ˆå¸¸è§çš„å®¶å¸¸èœï¼Œå¤‡æ–™è¿‡ç¨‹å°±ä¸ç»†è¯´äº†ã€‚å…ˆå°†æ…æ‹Œå‡åŒ€çš„è›‹æ¶²å€’å…¥å·²çƒ§åˆ°ä¸ƒã€å…«æˆçƒ­çš„æ²¹é”…ä¸­ï¼Œä½¿è›‹æˆå—å˜ç†Ÿï¼ˆè¿™ä¸ªè¡¨è¾¾æœ‰ç‚¹æ€ªï¼ŒçŸ¥é“æ˜¯ä»€ä¹ˆæ„æ€å°±è¡Œï¼‰ï¼Œç„¶åŽåœ¨å€’å…¥é»„ç“œï¼Œå¤§ç«ç¿»ç‚’ï¼Œæ³¨æ„é”…ä¸­éœ€è¦æœ‰ç‚¹æ°´åˆ†ï¼Œå¯ä»¥é€‚å½“åŠ ç‚¹æ°´ï¼Œè¾¹ç‚’è¾¹åŠ å…¥è°ƒæ–™ï¼Œä¸ä¸€ä¼šä¾¿å¯å‡ºé”…äº†ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œè¿™é“èœé‡Œé¢è¿˜å¯ä»¥åŠ å…¥é»‘æœ¨è€³æ¥ç‚¹ç¼€èœè‰²ï¼Œå¥½åƒä¹Ÿå¯ä»¥ç•¥å¾®å‡å°‘ä¸€ç‚¹é¸¡è›‹çš„è…¥å‘³ï¼ŸåŒæ—¶ï¼Œè¿˜å¯ä»¥åŠ å…¥ä¸€ç‚¹èšæ²¹ï¼Œä½¿èœçš„å‘³é“æ›´åŠ é²œç¾Žï¼Œæˆ–è€…å•çº¯åŠ ç‚¹ç³–ä¹Ÿå¯ä»¥ï¼Œå¦‚æžœä¸å–œæ¬¢åŠ å¤ªå¤šè°ƒå‘³å“ï¼Œä¹Ÿå¯ä»¥ä¸åŠ ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Cooking</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_03]]></title>
    <url>%2F2020%2F09%2F28%2FNand2Tetris-Part1-03%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨çš„ä¸»é¢˜æ˜¯ Memoryï¼Œå…ˆæŠŠåšå¥½çš„ ALU æ”¾ä¸€è¾¹ï¼Œæˆ‘ä»¬æ¥ç ”ç©¶ä¸€ä¸‹å’Œå†…å­˜ï¼ˆRAMï¼‰æœ‰å…³çš„é—®é¢˜ã€‚ Unit 3.1 Sequential Logicæœ¬å°èŠ‚ä¸»è¦åœ¨å¼•å‡ºæ–°çš„æ¦‚å¿µï¼šé¡ºåºé€»è¾‘ï¼ˆSequential Logicï¼‰ã€æ—¶é—´ç­‰ï¼Œå¦å¤–ä¹ŸæŒ‡å‡ºäº†é¡ºåºé€»è¾‘ä¸Žå‰ä¸¤å‘¨æ‰€å­¦çš„ç»„åˆé€»è¾‘ï¼ˆCombinational Logicï¼‰çš„ä¸åŒã€‚æ¢å¥è¯æ¥è®²ï¼Œè¿™å‘¨è€ƒè™‘çš„é—®é¢˜ä¼šæ›´åŠ è´´è¿‘çŽ°å®žç”Ÿæ´»ä¸€ç‚¹ã€‚ Unit 3.2 Filp Flopsæœ¬å°èŠ‚ä»‹ç»äº†æœ¬å‘¨å†…å®¹æ‰€ä½¿ç”¨çš„æœ€åŸºæœ¬å•å…ƒï¼šData Flip Flopsï¼ˆDFFï¼‰ï¼Œå¹¶è¯´æ˜Žäº†å®ƒçš„åŠŸèƒ½ï¼›æŽ¥ç€ç»§ç»­è®²è§£äº†å†…å­˜çš„åŸºæœ¬å•å…ƒ 1-Bit Registersï¼Œç€é‡åœ¨è¯´æ˜Žå®ƒçš„è¿è¡Œè¿‡ç¨‹ã€‚ Unit 3.3 Memory Unitsæœ¬å°èŠ‚ä»‹ç»äº†å†…å­˜å•å…ƒï¼ˆMemory unitsï¼‰çš„ä¸€äº›ç‰¹ç‚¹ï¼Œå¹¶é€šè¿‡è½¯ä»¶æ¨¡æ‹Ÿäº† RAM8 çš„è¿è¡Œè¿‡ç¨‹ã€‚éœ€è¦æ³¨æ„å†…å­˜æ˜¯ä¸€ä¸ªå…·æœ‰æ—¶é—´å±žæ€§çš„ç¡¬ä»¶å•å…ƒï¼Œè¿™ä¸ªè¯¾ç¨‹æåˆ°çš„å†…å­˜å•å…ƒæ˜¯é€šè¿‡ä¸Šé¢æåˆ°çš„ DFF æ¥â€œå±•çŽ°â€æ—¶é—´åŠŸèƒ½çš„ï¼ˆå®žé™…ä¸æ¸…æ¥šï¼Œä½†æ˜¯ DFF ç¡®å®žæ˜¯æœ‰è¿™ä¸ªåŠŸèƒ½çš„ï¼‰ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨æŸä¸ªæ—¶åˆ»ï¼Œå†…å­˜å•å…ƒä¸Šçš„å¯„å­˜å™¨çš„ç”µä¿¡å·æ”¹å˜åŽï¼Œå†…å­˜å•å…ƒçš„è¾“å‡ºä¾ç„¶ä¸å˜ï¼Œä¸‹ä¸€ä¸ªæ—¶åˆ»åŽï¼Œå†…å­˜å•å…ƒçš„è¾“å‡ºæ‰ä¼šæ”¹å˜ã€‚ åŒæ—¶ï¼Œè€å¸ˆè¿˜æåˆ°äº†å¯„å­˜å™¨çš„åœ°å€å’Œå¯„å­˜å™¨æ•°é‡çš„å…³ç³»ï¼Œä¹Ÿå°±æ˜¯ 2 çš„å¯¹æ•°å…³ç³»ã€‚æ¯”å¦‚ï¼ŒRAM8 å†…éƒ¨æœ‰ 8 ä¸ª Registerï¼Œé‚£ä¹ˆå°±å¯ä»¥ç”¨ 3 ä¸ª bit æ¥è¡¨ç¤ºè¿™ 8 ä¸ª Register çš„åºå·ï¼Œä¹Ÿå³ï¼š000ã€001ã€010ã€011ã€100ã€110ã€101 å’Œ 111ï¼Œè¿™ä¸ªæ•°å­—å…¶å®žä¹Ÿå°±æ˜¯å†…å­˜çš„åœ°å€ï¼Œè¿™åº”è¯¥å°±æ˜¯å†…å­˜åœ°å€æ¦‚å¿µçš„ç”±æ¥äº†ã€‚ Unit 3.4 Countersæœ¬å°èŠ‚ä»‹ç»äº†è®¡æ•°å™¨ï¼ˆCountersï¼‰çš„ä¸€äº›åŠŸèƒ½å’Œæœºåˆ¶ï¼ŒåŒ…å« 3 ä¸ªæ–¹é¢ï¼š èƒ½å°†å€¼é‡ç½®ä¸º 0ã€‚ èƒ½å°†å€¼éšç€æ—¶é—´é€’å¢žï¼Œä¸”æ¯ 1s å¢žåŠ  1ã€‚ èƒ½è¾“å‡ºä¸Šä¸€ä¸ªæ—¶åˆ»è®¾ç½®çš„å€¼ã€‚ Unit 3.5 Project 3 Overviewæœ¬å‘¨ä½œä¸šéœ€è¦å®žçŽ° 7 ä¸ªä¸Žå†…å­˜ç›¸å…³çš„èŠ¯ç‰‡å’Œ 1 ä¸ªè®¡æ•°å™¨ï¼Œé’ˆå¯¹å„ä¸ªèŠ¯ç‰‡çš„å®žçŽ°ï¼Œè€å¸ˆç»™å‡ºäº†è‹¥å¹²æç¤ºï¼Œè€Œæˆ‘ä»¬å°†ä¼šä»¥ DFF ä¸º primitive chip æ¥æž„å»ºå¦å¤– 8 ä¸ªèŠ¯ç‰‡ã€‚ Bitè¿™ä¸ªè€å¸ˆå·²ç»è®²è¿‡äº†ï¼Œç›´æŽ¥ç”¨ 1 ä¸ª Mux å’Œ 1 ä¸ª DFF å°±å¯ä»¥å®žçŽ°ï¼Œä½†æ˜¯è¿˜é¢å¤–éœ€è¦ä¸€ä¸ª Mux æ¥å¸®åŠ©è¾“å‡ºï¼ˆä¸ç”¨ Muxï¼Œç”¨å…¶ä»–çš„ä¹Ÿå¯ä»¥ï¼‰ã€‚123456789CHIP Bit &#123; IN in, load; OUT out; PARTS: Mux(a=t2, b=in, sel=load, out=t1); DFF(in=t1, out=t2); Mux(a=t2, b=true, sel=false, out=out);&#125; RegisteræŒ‰ç…§æç¤ºï¼Œç›´æŽ¥ç”¨ 16 ä¸ª Bit å åŠ åœ¨ä¸€èµ·å°±å¯ä»¥äº†ã€‚ä½†æ˜¯è¦æ³¨æ„ä¸€ä¸‹æ—¶é—´çš„æ¦‚å¿µï¼Œä¹Ÿå³è¿™ 16 ä¸ª Bit æ˜¯éƒ½å¤„äºŽå·¥ä½œçŠ¶æ€çš„ï¼Œå°½ç®¡æœ‰äº› Bit çš„å€¼å¯èƒ½å¹¶æ²¡æœ‰æ”¹å˜ã€‚12345678910111213141516171819202122CHIP Register &#123; IN in[16], load; OUT out[16]; PARTS: Bit(in=in[0], load=load, out=out[0]); Bit(in=in[1], load=load, out=out[1]); Bit(in=in[2], load=load, out=out[2]); Bit(in=in[3], load=load, out=out[3]); Bit(in=in[4], load=load, out=out[4]); Bit(in=in[5], load=load, out=out[5]); Bit(in=in[6], load=load, out=out[6]); Bit(in=in[7], load=load, out=out[7]); Bit(in=in[8], load=load, out=out[8]); Bit(in=in[9], load=load, out=out[9]); Bit(in=in[10], load=load, out=out[10]); Bit(in=in[11], load=load, out=out[11]); Bit(in=in[12], load=load, out=out[12]); Bit(in=in[13], load=load, out=out[13]); Bit(in=in[14], load=load, out=out[14]); Bit(in=in[15], load=load, out=out[15]);&#125; RAM8æ ¹æ®è®²è§£ï¼ŒRAM8 å†…éƒ¨åŒ…å«äº† 8 ä¸ª Registerï¼Œæ¯ä¸ª Register éƒ½å¯ä»¥å­˜å‚¨æ•°å­—ï¼Œæ ¹æ®ç‰¹å®šçš„åœ°å€ï¼ˆaddressï¼‰è¿›è¡ŒæŽ§åˆ¶ï¼ˆåŒ…æ‹¬å†™å…¥å€¼ã€æ¸…é™¤å€¼ï¼‰ã€‚è®¾è®¡è¿™ä¸ªèŠ¯ç‰‡çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•æ ¹æ®åœ°å€æ¥æ“ä½œ Registerï¼Œè¿™ä¸Žç¬¬äºŒå•å…ƒè®¾è®¡ ALU æ˜¯ä¸€æ ·çš„éš¾ç‚¹ã€‚ç¬¬äºŒå•å…ƒï¼Œè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹å¼æ˜¯ç”¨ Mux æ¥é€‰æ‹©ä¸åŒçš„å¯„å­˜å™¨è¿›è¡Œè¾“å‡ºã€‚è€Œè¿™é‡Œï¼Œæ¶‰åŠåˆ°é€‰å€å’Œè¾“å…¥ï¼Œéœ€è¦ä½¿ç”¨ DMux æ¥è¿›è¡Œé€‰å€å’Œè¾“å…¥ï¼Œé€šè¿‡ Register åŽï¼Œå†ç”¨ Mux è¿›è¡Œè¾“å‡ºã€‚å› ä¸º RAM8 å†…éƒ¨åŒ…å«äº† 8 ä¸ª Registerï¼Œæ‰€ä»¥é€‰ç”¨ DMux8Way æ¥å¤„ç†é€‰å€å’Œè¾“å…¥ï¼Œå†ç”¨ Mux8Way16 æ¥è¾“å‡ºæŒ‡å®šåœ°å€çš„ Register çš„å€¼ã€‚123456789101112131415161718CHIP RAM8 &#123; IN in[16], load, address[3]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address, a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); Register(in=in, load=load0, out=u0); Register(in=in, load=load1, out=u1); Register(in=in, load=load2, out=u2); Register(in=in, load=load3, out=u3); Register(in=in, load=load4, out=u4); Register(in=in, load=load5, out=u5); Register(in=in, load=load6, out=u6); Register(in=in, load=load7, out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address, out=out);&#125; RAM64æœ‰äº†å‰é¢çš„æ€è·¯åŽï¼ŒRAM64 å®žé™…ä¸Šå°±æ˜¯ 8 ä¸ª RAM8 å †å åœ¨ä¸€èµ·ã€‚ä¸è¿‡æ­¤æ—¶çš„åœ°å€éœ€è¦ç”¨ 6 ä½äºŒè¿›åˆ¶æ•°æ¥è¡¨ç¤ºï¼Œå…¶ä¸­å‰ 3 ä½ç”¨æ¥è¡¨ç¤ºæ˜¯é‚£ä¸€å— RAM8ï¼ŒåŽ 3 ä½ç”¨æ¥è¡¨ç¤ºæ˜¯è¿™å— RAM8 ä¸Šçš„å“ªä¸€ä¸ª Registerï¼ˆå®žé™…ä¸Šä¹Ÿå°±æ˜¯æ€»çº¿å®½åº¦ä»Ž 3 å‡çº§åˆ°äº† 6ï¼‰ã€‚123456789101112131415161718CHIP RAM64 &#123; IN in[16], load, address[6]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM8(in=in, load=load0, address=address[3..5], out=u0); RAM8(in=in, load=load1, address=address[3..5], out=u1); RAM8(in=in, load=load2, address=address[3..5], out=u2); RAM8(in=in, load=load3, address=address[3..5], out=u3); RAM8(in=in, load=load4, address=address[3..5], out=u4); RAM8(in=in, load=load5, address=address[3..5], out=u5); RAM8(in=in, load=load6, address=address[3..5], out=u6); RAM8(in=in, load=load7, address=address[3..5], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM512åŒç†ï¼ŒRAM512 å®žé™…ä¸Šå°±æ˜¯ 8 ä¸ª RAM64 å †å åœ¨ä¸€èµ·ã€‚å¯¹åº”çš„ï¼ŒçŽ°åœ¨éœ€è¦ 9 ä½äºŒè¿›åˆ¶æ•°æ¥è¡¨ç¤ºåœ°å€äº†ï¼Œä¹Ÿå°±æ˜¯æ€»çº¿å®½åº¦æ‰©å±•åˆ°äº† 9ã€‚123456789101112131415161718CHIP RAM512 &#123; IN in[16], load, address[9]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM64(in=in, load=load0, address=address[3..8], out=u0); RAM64(in=in, load=load1, address=address[3..8], out=u1); RAM64(in=in, load=load2, address=address[3..8], out=u2); RAM64(in=in, load=load3, address=address[3..8], out=u3); RAM64(in=in, load=load4, address=address[3..8], out=u4); RAM64(in=in, load=load5, address=address[3..8], out=u5); RAM64(in=in, load=load6, address=address[3..8], out=u6); RAM64(in=in, load=load7, address=address[3..8], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM4KåŒç†ï¼ŒRAM4k å®žé™…ä¸Šå°±æ˜¯ 8 ä¸ª RAM512 å †å åœ¨ä¸€èµ·ã€‚å¯¹åº”çš„ï¼ŒçŽ°åœ¨éœ€è¦ 12 ä½äºŒè¿›åˆ¶æ•°æ¥è¡¨ç¤ºåœ°å€äº†ï¼Œä¹Ÿå°±æ˜¯æ€»çº¿å®½åº¦æ‰©å±•åˆ°äº† 12ã€‚123456789101112131415161718CHIP RAM4K &#123; IN in[16], load, address[12]; OUT out[16]; PARTS: DMux8Way(in=load, sel=address[0..2], a=load0, b=load1, c=load2, d=load3, e=load4, f=load5, g=load6, h=load7); RAM512(in=in, load=load0, address=address[3..11], out=u0); RAM512(in=in, load=load1, address=address[3..11], out=u1); RAM512(in=in, load=load2, address=address[3..11], out=u2); RAM512(in=in, load=load3, address=address[3..11], out=u3); RAM512(in=in, load=load4, address=address[3..11], out=u4); RAM512(in=in, load=load5, address=address[3..11], out=u5); RAM512(in=in, load=load6, address=address[3..11], out=u6); RAM512(in=in, load=load7, address=address[3..11], out=u7); Mux8Way16(a=u0, b=u1, c=u2, d=u3, e=u4, f=u5, g=u6, h=u7, sel=address[0..2], out=out);&#125; RAM16KåŒç†ï¼ŒRAM16k å®žé™…ä¸Šå°±æ˜¯ 4 ä¸ª RAM4K å †å åœ¨ä¸€èµ·ã€‚å¯¹åº”çš„ï¼ŒçŽ°åœ¨éœ€è¦ 14 ä½äºŒè¿›åˆ¶æ•°æ¥è¡¨ç¤ºåœ°å€äº†ï¼Œä¹Ÿå°±æ˜¯æ€»çº¿å®½åº¦æ‰©å±•åˆ°äº† 14ã€‚1234567891011121314CHIP RAM16K &#123; IN in[16], load, address[14]; OUT out[16]; PARTS: DMux4Way(in=load, sel=address[0..1], a=load0, b=load1, c=load2, d=load3); RAM4K(in=in, load=load0, address=address[2..13], out=u0); RAM4K(in=in, load=load1, address=address[2..13], out=u1); RAM4K(in=in, load=load2, address=address[2..13], out=u2); RAM4K(in=in, load=load3, address=address[2..13], out=u3); Mux4Way16(a=u0, b=u1, c=u2, d=u3, sel=address[0..1], out=out);&#125; PCProgram Counterï¼Œç®€ç§° PCï¼Œç›´è¯‘å°±æ˜¯ç¨‹åºè®¡æ•°å™¨ã€‚è¿™ä¸ªå°èŠ¯ç‰‡çœŸçš„æƒ³äº†å¾ˆä¹…éƒ½æ²¡æœ‰ä»€ä¹ˆæ€è·¯...å‡†ç¡®æ¥è®²ï¼Œä¸æ˜¯æ²¡æœ‰æž„é€ çš„æ€è·¯ï¼Œè€Œæ˜¯ä¸çŸ¥é“æ€Žä¹ˆç”¨ HDL è¯­è¨€æ¥æè¿°ã€‚æ²¡åŠžæ³•ï¼Œåªå¥½é˜…è¯»ä¸€ä¸‹åˆ«äººå†™çš„ä»£ç äº†ï¼Œç»“æžœå‘çŽ°ï¼Œå¤§å®¶å¥½åƒåœ¨è¿™é‡Œéƒ½æœ‰ç‚¹é—®é¢˜ï¼Œhha~ðŸ¤£ã€‚å›žè¿‡å¤´æ¥ï¼Œä¸€å¼€å§‹ä¸çŸ¥é“æ€Žä¹ˆå†™ï¼Œåªèƒ½ç¿»è€å¸ˆç»™çš„èµ„æ–™ï¼Œçœ‹çœ‹èƒ½ä¸èƒ½æ‰¾åˆ°ç‚¹æ€è·¯ã€‚æ²¡æƒ³åˆ°è¿˜æ•´çš„æ‰¾åˆ°äº†ï¼Œå°±æ˜¯ä¹¦ä¸Šç¬¬å†™çš„ï¼š Counter A w-bit counter consists of two main elements: a regular w-bit register, andcombinational logic. The combinational logic is designed to (a) compute the counting function, and (b) put the counter in the right operating mode, as mandated by the values of its three control bits. Tip: Most of this logic was already built in chapter 2. ä»”ç»†çœ‹æœ€åŽä¸€è¡Œï¼šTip: Most of this logic was already built in chapter 2.ï¼ŒåŽŸæ¥ç¬¬äºŒç« å°±åšè¿‡äº†ã€‚å†ä»”ç»†ä¸€æƒ³ï¼Œåœ¨åš ALU çš„æ—¶å€™é¢å¯¹çš„ä¹Ÿæ˜¯ç±»ä¼¼çš„é—®é¢˜ï¼Œé‚£æ—¶æ˜¯é€šè¿‡ Mux æ¥æŒ‘é€‰å‡ºæ¥åˆé€‚çš„å€¼è¿›è¡Œè¾“å‡ºçš„ï¼Œé‚£ä¹ˆç”¨åˆ°è¿™é‡Œåº”è¯¥ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ å¯æ˜¯åˆè¯¥å¦‚ä½•å®žçŽ°å¾ªçŽ¯è®¡æ•°çš„åŠŸèƒ½å‘¢ï¼Ÿå›žæƒ³ä¸€ä¸‹å¾ªçŽ¯çš„è¿‡ç¨‹ï¼Œå³ä¸Šä¸€æ¬¡çš„ç»“æžœä½œä¸ºè¿™ä¸€æ¬¡çš„åˆå§‹å€¼ã€‚é‚£ä¹ˆåœ¨ HDL é‡Œé¢æ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥è¿™æ ·å†™å‘¢ï¼Ÿç­”æ¡ˆæ˜¯å¯ä»¥çš„ï¼ˆæ€»è§‰å¾—è¿™æ ·å†™æœ‰è¯­æ³•é”™è¯¯ðŸ˜‚ï¼‰ã€‚é‚£ä¹ˆæ­£å¸¸è¾“å‡ºçš„å€¼ä¸Žå¾ªçŽ¯é€’å¢žçš„å€¼åˆè¯¥å¦‚ä½•ä¿å­˜å‘¢ï¼Ÿéš¾é“ä¿å­˜åœ¨ä¸€ä¸ª Register é‡Œé¢ï¼Ÿç„¶åŽåˆå¼€å§‹æ²¡æœ‰æ€è·¯äº†ï¼Œç›´åˆ°åˆçœ‹åˆ°äº†åˆ«äººæ–‡ç« é‡Œé¢çš„ï¼š Multiple OutputsSometimes you need more than one sub-bus connected to the output of a chip-part. Simply add more than one out= connection to the chip-part definition.CHIP Foo { IN in[16]; OUT out[8]; PARTS: Not16 (in=in, out[0..7]=low8, out[8..15]=high8); Something8 (a=low8, b=high8, out=out); }This also works if you want to use an output of a chip in further computations.CHIP Foo { IN a, b, c; OUT out1, out2; PARTS: Something (a=a, b=b, out=x, out=out1); Whatever (a=x, b=c, out=out2); } åŽŸæ¥å•ç‹¬çš„æŸä¸ªèŠ¯ç‰‡æ˜¯å¯ä»¥æœ‰ä¸¤ä¸ªè¾“å‡ºçš„ï¼ˆoutï¼‰çš„...æœ€ç»ˆï¼Œè´¹äº†ä¸€ç•ªåŠŸå¤«åŽå¾—åˆ°çš„é€šè¿‡ä»£ç ï¼š1234567891011CHIP PC &#123; IN in[16],load,inc,reset; OUT out[16]; PARTS: Inc16(in=prevalue, out=u1); Mux16(a=prevalue, b=u1, sel=inc, out=u2); Mux16(a=u2, b=in, sel=load, out=u3); Mux16(a=u3, b=false, sel=reset, out=u4); Register(in=u4, load=true, out=out, out=prevalue);&#125; Unit 3.6 Perspectiveè¿™å‘¨çš„é—®é¢˜ï¼š è¿™å‘¨ç”¨ DFF æž„å»ºäº†å…¶ä»–çš„èŠ¯ç‰‡ï¼ŒæŠŠ DFF å½“ä½œäº†æ‹¥æœ‰æŸç§åŠŸèƒ½çš„é»‘ç›’å­ï¼Œé‚£ä¹ˆå®ƒå®žé™…ä¸Šæ˜¯æ€Žä¹ˆæž„æˆçš„å‘¢ï¼Ÿ å¤§èƒ¡å­è€å¸ˆè§£é‡Šè¯´è¿™ä¸æ˜¯æˆ‘ä»¬è¿™é—¨è¯¾è¦æ•™çš„å†…å®¹ï¼ˆç¬‘æ­»ðŸ˜‚ï¼‰ï¼Œå› ä¸ºé€šè¿‡æž„é€ å…¶ä»–çš„èŠ¯ç‰‡å°±å¯ä»¥å­¦ä¹ åˆ°ç»„åˆé€»è¾‘ç”µè·¯ä¸Žæ—¶åºé€»è¾‘ç”µè·¯çš„å·®åˆ«ï¼Œæ‰€ä»¥è¦æŠŠé‡ç‚¹æ”¾åœ¨æž„é€ å…¶ä»–çš„èŠ¯ç‰‡ä¸Šã€‚ä¸è¿‡ï¼Œå¤§èƒ¡å­è€å¸ˆè¿˜æ˜¯å›žç­”äº†è¿™ä¸ªé—®é¢˜ï¼Œç”¨ä¸¤ä¸ª NAND æž„é€ äº†ä¸€ä¸ª DFFã€‚å¦å¤–ï¼ŒNAND ä¹Ÿä¸æ˜¯å”¯ä¸€ç”¨æ¥æž„å»ºå†…å­˜ç³»ç»Ÿçš„åŸºç¡€ç†è®ºã€‚ ç”µè„‘åªä½¿ç”¨ RAM ä½œä¸ºå†…å­˜è®¾å¤‡å—ï¼Ÿ æ˜¾ç„¶ä¸æ˜¯ï¼Œè¿˜æœ‰ ROMã€Flash Memory å’Œ Cache Memoryã€‚ROM å…¨ç§° Read Only Memoryï¼Œæ˜¯ä¸€ç§æ–­ç”µåŽä¹Ÿä¸ä¼šæŸå¤±ä¿¡æ¯çš„å­˜å‚¨è®¾å¤‡ï¼ˆæ¯”å¦‚ç¡¬ç›˜ï¼‰ï¼›è€Œ Flash Memory åˆ™æ˜¯ä»‹äºŽ RAM å’Œ ROM ä¹‹é—´çš„å­˜å‚¨è®¾å¤‡ï¼Œå®ƒçš„é€Ÿåº¦å¿«äºŽ ROMï¼Œæ…¢äºŽ RAMï¼Œä½†å®ƒçš„å®¹é‡å¤§äºŽ RAMï¼Œå°äºŽ ROMï¼Œç®—æ˜¯å­˜å‚¨é€Ÿåº¦å’Œç©ºé—´çš„æŠ˜ä¸­äº§ç‰©ï¼ˆæ¯”å¦‚ Mac çš„é—ªå­˜ï¼Œæ‰‹æœºçš„é—ªå­˜ï¼‰ï¼›æœ€åŽæ˜¯ Cache Memoryï¼Œè¿™ä¸ªä¸œè¥¿å°±æ˜¯ CPU çš„ç¼“å­˜ã€‚ è¿™å‘¨çš„éš¾ç‚¹è·Ÿä¸Šå‘¨ç±»ä¼¼ï¼Œç”¨â€œç”µå­è¯­è¨€â€æ¥æž„é€ å¾ªçŽ¯ã€æ¡ä»¶ç­‰å¤æ‚é€»è¾‘æ˜¯çœŸçš„éš¾ã€‚ç¬¬ä¸€ä¸ªæƒ³åˆ°è¿™äº›æƒ³æ³•çš„äººï¼ŒçœŸçš„æ˜¯ç¥žæ¥ä¹‹ç¬”ï¼Œåˆ›é€ æ€§å¤ªå¼ºäº†ï¼Œä¼°è®¡è¿™äº›å‘æ˜Žå®¶å½“æ—¶ä¹Ÿæ²¡æœ‰æƒ³åˆ°æ›¾ç»çš„é€»è¾‘ç”µè·¯èƒ½æ¼”å˜æˆçŽ°åœ¨çš„ç”µè„‘å§ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‰’è°±è®°å½• - Homesteaders]]></title>
    <url>%2F2020%2F09%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-Homesteaders%2F</url>
    <content type="text"><![CDATA[ã€ŠHomesteadersã€‹æ˜¯ç”± Joanie Madden ç”¨å“¨ç¬›æ¼”å¥çš„ä¸€é¦–å‡¯å°”ç‰¹é£Žæ ¼çš„æ›²å­ï¼Œæ˜¯ä¸€é¦–ååˆ†çº¯å‡€çš„è½»éŸ³ä¹ã€‚ Homesteaders - Joanie MaddenYour browser does not support the audio tag. æ™šä¸Šå¼¹ç´çš„æ—¶å€™ï¼Œè„‘æµ·é‡Œçªç„¶å“èµ·äº†è¿™é¦–æ›²å­çš„æ—‹å¾‹ï¼Œä¼´éšç€è„‘æµ·å†…çš„æ—‹å¾‹ï¼Œçœ¼å‰çš„æ™¯è‰²å¥½åƒåˆå›žåˆ°äº†é«˜ä¸­æ—¶ä»£ã€‚æƒ³åˆ°é‚£æ—¶çš„è‡ªå·±ï¼Œé¬¼ä½¿ç¥žå·®çš„æ‰¾äº†ä¸€æœ¬è¨€æƒ…å°è¯´è¯»ï¼ˆå¯èƒ½æ˜¯è€ä¸ä½æž¯ç‡¥çš„å­¦ä¹ ç”Ÿæ´»å§ï¼Œä¸ºä»€ä¹ˆä¸è¯»ç§‘å¹»å°è¯´å‘¢ï¼Ÿï¼Ÿï¼Ÿï¼‰ã€‚ä¸€è¾¹è¯»ï¼Œä¸€è¾¹å¬ç€è¿™é¦–æ›²å­ã€‚æœ€åŽï¼Œå°è¯´è¯»å®Œäº†ï¼Œè¿™é¦–æ›²å­ä¹Ÿå¬äº†ä¸€éåˆä¸€éã€‚å°è¯´çš„æƒ…èŠ‚çŽ°å·²éš¾ä»¥å›žæƒ³èµ·æ¥äº†ï¼Œä½†é‚£æ—¶çš„è‡ªå·±æµéœ²å‡ºçš„äº›è®¸æ„Ÿæƒ…å´éšç€è¿™é¦–æ›²å­çš„æ—‹å¾‹ä¸€éåˆä¸€éçš„åˆ»è¿›äº†è‡ªå·±çš„è„‘æµ·ã€‚ å…¶å®žï¼Œé«˜ä¸­æ—¶ä»£ç»“æŸåŽï¼Œè„‘æµ·å°±å·²ç»å¤šæ¬¡å“èµ·äº†è¿™æ®µç†Ÿæ‚‰æ—‹å¾‹ï¼Œå¯è‡ªå·±è®©å®ƒåœç•™åœ¨è„‘ä¸­çš„æ—¶é—´ä¸ä¼šè¶…è¿‡ 10 ç§’ï¼Œç´¢æ€§è¿™æ¬¡è®©å®ƒåœç•™çš„ä¹…ä¸€ç‚¹ã€‚ç„¶åŽï¼Œç”¨å‰ä»–è¯•ç€å¼¹äº†ä¸€ä¸‹ï¼Œè¿˜æŒºåƒçš„ã€‚éšåŽæ‰¾åˆ°åŽŸæ›²ï¼Œå¬äº†å‡ éï¼Œä¸ä¸€ä¼šä¸»æ—‹å¾‹å°±æ‰’å‡ºæ¥äº†ï¼Œè®°å½•ä¸‹æ¥ï¼Œå…å¾—è‡ªå·±å¿˜äº†ã€‚ è¿™æ ·çš„è¯ï¼Œå†è¿‡å‡ å¹´åŽçš„è‡ªå·±å¶å°”çœ‹åˆ°è¿™äº›ä¸œè¥¿çš„æ—¶å€™ï¼Œä¹Ÿè®¸å¿ƒä¸­è¿˜èƒ½ç•™æœ‰ä¸€ä¸æ„ŸåŠ¨å§ï¼ è‡ªæ‰’è°±ï¼š[5]1231[5] [6]123155(1)76 54345112316532123[6]123211[6] [5][5][6]12123211[6] [5][5][6]11(1)767(1)6 5452431236335321232(1)767(1)6 54524312363321[6] [7][]ï¼šé™å…«åº¦ ()ï¼šå‡å…«åº¦]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_02]]></title>
    <url>%2F2020%2F09%2F21%2FNand2Tetris-Part1-02%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨çš„ä¸»é¢˜æ˜¯ Boolean Arithmetic and the ALU Roadmapï¼Œæ—¨åœ¨ä»‹ç»å¦‚ä½•æž„å»ºåŠ æ³•å™¨ï¼ˆadderï¼‰å’Œç®—æœ¯é€»è¾‘å•å…ƒï¼ˆArithmetic Logic Unitï¼ŒALUï¼‰ï¼Œå­¦ä¹ è·¯çº¿ä¾ç„¶è¿˜æ˜¯ä»Žç®€å•åˆ°å¤æ‚ã€‚ Unit 2.1 Binary Numbersæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜ŽäºŒè¿›åˆ¶ä¸Žåè¿›åˆ¶çš„ä¸€äº›è”ç³»ï¼Œç²—ç•¥ä»‹ç»äº†ä¸€ä¸‹è¿›åˆ¶è½¬æ¢çš„è¿‡ç¨‹ï¼Œä½†æ²¡æœ‰è¯´æ˜Žå…·ä½“çš„æ–¹æ³•ã€‚å­¦è¿‡ä¸€é—¨ç¼–ç¨‹è¯­è¨€è¯¾çš„åŒå­¦ï¼Œè‚¯å®šå¯¹è¿™äº›éƒ½å·²ç»å¾ˆç†Ÿæ‚‰ï¼›æ²¡å­¦è¿‡çš„ï¼Œè€å¸ˆè®²çš„ä¹Ÿå¾ˆæ¸…æ™°ã€‚ Unit 2.2 Binary Additionæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»äºŒè¿›åˆ¶åŠ æ³•è§„åˆ™ï¼Œæœ¬è´¨ä¸Šä¸Žåè¿›åˆ¶æ˜¯ä¸€æ ·çš„ã€‚ä½†ç”±äºŽäºŒè¿›åˆ¶ç®—æœ¯å­˜åœ¨ä½æ•°ï¼ˆbitsï¼‰çš„é™åˆ¶ï¼Œæ‰€ä»¥ä¼šäº§ç”Ÿæº¢å‡ºï¼ˆoverflowï¼‰çš„é—®é¢˜ï¼Œè€å¸ˆæš‚æ—¶æ²¡æœ‰è®²å…·ä½“çš„è§£å†³åŠžæ³•ï¼Œåªè¯´æ˜Žäº†ï¼Œåœ¨è®¡ç®—æœºå†…æ˜¯ä¼šç›´æŽ¥å¿½ç•¥æŽ‰çš„ï¼Œä½†æ˜¯ä½¿ç”¨è€…å¿…é¡»çŸ¥é“æº¢å‡ºäº†ã€‚æŽ¥ç€ï¼Œåˆç”±æ˜“åˆ°éš¾çš„ä»‹ç»äº†ä¸‰ç§åŠ æ³•å™¨ï¼Œå¹¶å¤§è‡´è¯´æ˜Žäº†ä¸€ä¸‹æž„é€ çš„æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯æœ¬å‘¨çš„ä½œä¸šä¹‹ä¸€ã€‚ Unit 2.3 Negative Numberså‰é¢ä»‹ç»çš„è§„åˆ™éƒ½æ˜¯ä¸Žæ­£æ•°ç›¸å…³çš„ï¼Œè€Œæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»åœ¨è®¡ç®—æœºä¸­å¦‚ä½•è¡¨ç¤ºè´Ÿæ•°ï¼Œè€å¸ˆä¸»è¦ä»‹ç»äº†ä¸¤ç§è¡¨ç¤ºæ–¹æ³•ï¼š ç”¨æœ€å‰é¢çš„ 1 ä½ï¼ˆ1 bitï¼‰ä»£è¡¨ç¬¦å·ï¼Œä¸º 0ï¼Œåˆ™ä¸ºæ­£æ•°ï¼Œä¸º 1ï¼Œåˆ™ä¸ºè´Ÿæ•°ï¼ŒäºŒè€…ç»å¯¹å€¼ç›¸ç­‰ã€‚è¿™æ ·è¡¨ç¤ºä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯ä¼šäº§ç”Ÿæ­£ 0 å’Œ è´Ÿ 0ï¼Œè¿™æ ·åœ¨åšåŠ ã€å‡æ³•æ—¶ä¼šäº§ç”Ÿé—®é¢˜ï¼Œæ‰€ä»¥èˆå¼ƒäº†è¿™ç§æ–¹æ³• ç”¨ $2^N + (-x) = 2^N - x$ æ¥è¡¨ç¤ºè´Ÿæ•°ï¼Œå…¶ä¸­ -x å°±æ˜¯è¦è¡¨ç¤ºçš„è´Ÿæ•°ï¼Œè¿™æ ·è¡¨ç¤ºåŽå°±æ²¡æœ‰è´Ÿ 0 äº†ï¼Œä¸”åœ¨åšåŠ ã€å‡æ³•æ—¶ä¹Ÿæ˜¯å®Œå…¨æ­£ç¡®çš„ã€‚ è¯´ç‚¹é¢˜å¤–è¯ï¼Œä¸Šé¢çš„å‡ å°èŠ‚å†…å®¹å¯¹åº”äº†ç»„æˆåŽŸç†ä¸­æœ‰å…³æ•°çš„è¡¨ç¤ºéƒ¨åˆ†ï¼Œæåˆ°çš„ä¸€äº›æ–¹æ³•ï¼Œå…¶å®žå°±æ˜¯åŽŸç ã€è¡¥ç ï¼ˆradix complementï¼‰å’Œåç çš„æ¦‚å¿µï¼Œå¯èƒ½æ˜¯è€å¸ˆä¸ºäº†ç…§é¡¾éžè®¡ç®—æœºä¸“ä¸šçš„å­¦ç”Ÿï¼Œä¸€ç‚¹æ²¡æè¿™äº›ä¸œè¥¿ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å›½å¤–è®²è¯¾çš„é£Žæ ¼å¯¼è‡´äº†è€å¸ˆä¸ä¼šç¡¬è®²è¿™äº›æ¦‚å¿µæ€§çš„ä¸œè¥¿å§ã€‚ Unit 2.4 Arithmetic Logic Unitæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»åŽé¢è¦æž„å»ºçš„è®¡ç®—æœº Hack çš„ ALU æ˜¯å¦‚ä½•æž„å»ºçš„ã€‚é¦–å…ˆæ˜¯å¯¹æ­¤ ALU çš„åŸºæœ¬ä»‹ç»ï¼ŒåŒ…æ‹¬å…¶è¾“å…¥ã€è¾“å‡ºã€æŽ§åˆ¶ä½ï¼ˆcontrol bitsï¼‰ï¼Œæ³¨æ„å…¶æŽ§åˆ¶ä½æœ‰ä¸¤ç±»ï¼Œæœ‰ 6 ä¸ªç®—æ˜¯åŠŸèƒ½æŽ§åˆ¶ä½ï¼Œå‰©ä¸‹ä¸¤ä¸ªæ˜¯è¾“å‡ºæŽ§åˆ¶ä½ï¼Œä¸”å¹¶æ²¡æœ‰è¯´æ˜Žè¾“å‡ºæŽ§åˆ¶ä½å­˜åœ¨çš„æ„ä¹‰ã€‚æŽ¥ç€ï¼Œè¯´æ˜Žäº†å¦‚ä½•ä½¿ç”¨ç¡¬ä»¶æ¨¡æ‹Ÿå™¨æ¥ä½¿ç”¨æ¨¡æ‹Ÿ ALU çš„ä¸€äº›åŠŸèƒ½ï¼Œåœ¨è¿™ä¸€å—ï¼Œå¦‚æžœå¯¹ ALU çš„è¿ç®—è¿‡ç¨‹ä¸æ¸…æ¥šå¯ä»¥ä½¿ç”¨å†…ç½®çš„ï¼ˆbuilt-inï¼‰ALU æ¥ç†Ÿæ‚‰ä¸€ä¸‹è¿‡ç¨‹ã€‚æœ€åŽï¼Œä¸¾ä¾‹éªŒè¯äº† ALU èƒ½é€ä¸€å®žçŽ°æ‰€è¦æ±‚åŠŸèƒ½çš„å¯é æ€§ï¼Œä½†è€å¸ˆæ²¡æœ‰ä»‹ç»å…·ä½“çš„åŽŸç†ï¼Œæƒ³äº†è§£å°±å¾—è‡ªå·±çœ‹èµ„æ–™äº†ã€‚è¿˜å‰©ä¸‹çš„æœ€åŽä¸€ç‚¹æ˜¯åœ¨è¯´æ˜Ž Hack ALU çš„ä¼˜ç‚¹ï¼Œé€šä¿—æ¥è®²å…¶å®žå°±æ˜¯ä¸€ç‚¹ï¼šæ˜“äºŽå­¦ä¹ ã€‚ Unit 2.5 Project 2 Overviewæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»è¿™å‘¨çš„ä½œä¸šï¼Œå¹¶ç»™å‡ºäº†ä¸€äº›æç¤ºä¿¡æ¯ã€‚å°½ç®¡åœ¨ç¬¬ä¸€å‘¨å·²ç»å®žçŽ°äº†å¾ˆå¤š chipsï¼Œä½†æ˜¯è€å¸ˆå»ºè®®ä¸è¦ä½¿ç”¨è‡ªå·±å®žçŽ°çš„ chipsï¼Œç›´æŽ¥ä½¿ç”¨è½¯ä»¶è‡ªå¸¦ï¼ˆbuilt-inï¼‰çš„ chipsï¼ŒåŽŸå› æ˜¯ä¸ºäº†é¿å…è½¯ä»¶å¯èƒ½ä¼šäº§ç”Ÿçš„å¡é¡¿ç­‰æƒ…å†µã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥å¼€å§‹å®Œæˆè¿™å‘¨çš„ä½œä¸šã€‚ HalfAdderæŒ‰ç…§è€å¸ˆç»™çš„æç¤ºï¼Œç›´æŽ¥ç”¨ Xor å’Œ And æ¥å®žçŽ°å°±å®Œäº‹äº†ã€‚123456789CHIP HalfAdder &#123; IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry);&#125; FullAdder12345678910CHIP FullAdder &#123; IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, sum=s1, carry=v1); HalfAdder(a=s1, b=c, sum=sum, carry=v2); Or(a=v1, b=v2, out=carry);&#125; Add1612345678910111213141516171819202122CHIP Add16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: HalfAdder(a=a[0], b=b[0], sum=out[0], carry=c1); FullAdder(a=a[1], b=b[1], c=c1, sum=out[1], carry=c2); FullAdder(a=a[2], b=b[2], c=c2, sum=out[2], carry=c3); FullAdder(a=a[3], b=b[3], c=c3, sum=out[3], carry=c4); FullAdder(a=a[4], b=b[4], c=c4, sum=out[4], carry=c5); FullAdder(a=a[5], b=b[5], c=c5, sum=out[5], carry=c6); FullAdder(a=a[6], b=b[6], c=c6, sum=out[6], carry=c7); FullAdder(a=a[7], b=b[7], c=c7, sum=out[7], carry=c8); FullAdder(a=a[8], b=b[8], c=c8, sum=out[8], carry=c9); FullAdder(a=a[9], b=b[9], c=c9, sum=out[9], carry=c10); FullAdder(a=a[10], b=b[10], c=c10, sum=out[10], carry=c11); FullAdder(a=a[11], b=b[11], c=c11, sum=out[11], carry=c12); FullAdder(a=a[12], b=b[12], c=c12, sum=out[12], carry=c13); FullAdder(a=a[13], b=b[13], c=c13, sum=out[13], carry=c14); FullAdder(a=a[14], b=b[14], c=c14, sum=out[14], carry=c15); FullAdder(a=a[15], b=b[15], c=c15, sum=out[15], carry=c16);&#125; Inc161234567CHIP Inc16 &#123; IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, out=out);&#125; ALU_nostatæŒ‰ç…§è€å¸ˆæ‰€ç»™èµ„æ–™ä¸Šçš„æç¤ºï¼Œæˆ‘ä»¬å…ˆä¸åŽ»è€ƒè™‘ ng å’Œ zr è¿™ä¸¤ä¸ªè¾“å‡ºæŽ§åˆ¶ä½ï¼Œç›´æŽ¥è€ƒè™‘è¾“å‡ºå³å¯ã€‚é‚£æˆ‘ä»¬å…ˆå¾—æž„é€ å‡ºèƒ½æ ¹æ® zx å’Œ nx è¿™ä¸¤ä¸ªæŽ§åˆ¶ä½æ¥é€‰æ‹©æ€§è¾“å‡ºçš„é€»è¾‘ç”µè·¯ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªé€»è¾‘ç”µè·¯æ€»çº¿å®½åº¦æ˜¯ 16 ä½çš„ã€‚ç»“æžœç¡¬æƒ³äº†å¥½ä¸€ä¼šå„¿ï¼Œæ²¡æƒ³å‡ºæ¥ã€‚åŽæ¥æ„è¯†åˆ°ï¼Œè¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šå…¶å®žå°±æ˜¯åœ¨æ€è€ƒå¦‚ä½•åœ¨æ²¡æœ‰æ¡ä»¶ç¼–ç¨‹è¯­å¥çš„æƒ…å†µä¸‹æž„é€ å‡ºæ¡ä»¶é€»è¾‘ã€‚èƒ¡ä¹±çš„å†™äº†äº›ä»£ç ï¼Œå‘çŽ°è¯­æ³•éƒ½ä¸é€šï¼Œä½†è„‘å­é‡Œå§‹ç»ˆæƒ³çš„éƒ½æ˜¯ï¼šåœ¨çŽ°æœ‰çš„å¯ä½¿ç”¨çš„é€»è¾‘ç”µè·¯é‡Œï¼Œå¥½åƒæ²¡æœ‰å¯ä»¥ç”¨äºŽæ¡ä»¶é€‰æ‹©çš„å•Šï¼Ÿè¿‡äº†ä¸¤å¤©ï¼Œåˆå›žæ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œçªç„¶å‘çŽ°ï¼ŒMux è¿™ç§ä¸œè¥¿ä¸æ˜¯æ ¹æ® sel bit æ¥é€‰æ‹©æ€§è¾“å‡ºçš„å—ï¼Ÿçªç„¶æƒ³åˆ°è‡ªå·±ä¹‹å‰çš„æƒ³æ³•ï¼šè¿™ä¸œè¥¿åº”è¯¥æ˜¯é€šä¿¡ä¸“ä¸šåŒå­¦ç ”ç©¶çš„ä¸œè¥¿å§...å¥½å§ï¼Œè‡ªå·±ä¸€å¼€å§‹å°±æŠŠæ­£ç¡®çš„æ€è€ƒæ–¹å‘ç»™æŠ›åˆ°ä¹éœ„äº‘å¤–åŽ»äº†ï¼ŒçœŸæ˜¯æ¬èµ·çŸ³å¤´ç ¸è‡ªå·±çš„è„šï¼Œæƒ³çš„æˆ‘çœŸæ˜¯è¾›è‹¦...æ‰¯è¿œäº†ï¼Œæœ‰äº†ä¸Šé¢çš„æ€è·¯åŽï¼Œè¿™ä¸ªé—®é¢˜å…¶å®žå°±å¾ˆå®¹æ˜“äº†ï¼Œç›´æŽ¥çœ‹ä¸‹é¢ä»£ç ï¼š1234567891011121314151617181920212223242526272829303132CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=out);&#125; ALUå®Œæˆä¸Šé¢çš„ä»»åŠ¡åŽï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„é—®é¢˜å°±æ˜¯å¦‚ä½•å¾—åˆ° zr å’Œ ng çš„æ­£ç¡®ç»“æžœã€‚æŒ‰ç…§å‰é¢çš„è¯¾ç¨‹å†…å®¹ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“è´Ÿæ•°çš„æœ€é«˜ä½ bit æ˜¯ 1ï¼Œæ‰€ä»¥ ng å°±å¾ˆå®¹æ˜“å¾—åˆ°äº†ã€‚ä½†æ˜¯ zr å°±ä¸æ˜¯é‚£ä¹ˆæ˜“å¾—äº†ï¼ŒåŽŸå› åœ¨äºŽ 0 çš„äºŒè¿›åˆ¶æœ€é«˜ä½ä¸Žæ™®é€šæ­£æ•°çš„äºŒè¿›åˆ¶æœ€é«˜ä½ä¸€æ ·ï¼Œéƒ½æ˜¯ 0 ï¼Œæ‰€ä»¥æ— æ³•è½»æ˜“çš„åŒºåˆ†ã€‚è¿™é‡Œå¥½åƒåˆå›žåˆ°äº†æˆ‘ä»¬åœ¨ä¹‹å‰ç¢°åˆ°çš„é—®é¢˜ï¼šå¦‚ä½•åœ¨æ²¡æœ‰åˆ¤æ–­ç¼–ç¨‹è¯­å¥çš„æƒ…å†µä¸‹æž„é€ å‡ºåˆ¤æ–­é€»è¾‘å‘¢ï¼Ÿæ³¨æ„åˆ° 0 å…ˆå–åå†è‡ªå¢žåŠ  1 åŽï¼Œå¾—åˆ°çš„äºŒè¿›åˆ¶åºåˆ—æœ€é«˜ä½ä¸ŽåŽŸåºåˆ—æœ€é«˜ä½ä¸€è‡´ï¼ˆæº¢å‡ºçš„ bit èˆå¼ƒï¼‰ï¼Œè€Œå…¶ä»–çš„æ•°ç”±æ­¤è¿‡ç¨‹å¾—åˆ°çš„ä¸¤ä¸ªåºåˆ—çš„æœ€é«˜ä½å¿…ç„¶ä¸€ä¸ªæ˜¯ 1ï¼Œå¦ä¸€ä¸ªæ˜¯ 0ã€‚å¦‚æ­¤ä¸€æ¥ï¼Œé—®é¢˜å°±è§£å†³äº†ã€‚å½“ç„¶äº†ï¼Œè¦æƒ³å¾—åˆ° zrï¼Œæœ€å¿«çš„åŠžæ³•å…¶å®žå°±æ˜¯è®©æœ€åŽçš„ç»“æžœåºåˆ—æŒ‰ä½å–æˆ–ï¼ˆOrï¼‰è¿ç®—ï¼Œé‡‡ç”¨ä¹‹å‰æž„é€ çš„ Or8Way è¿™ä¸ªé€»è¾‘ç”µè·¯ï¼Œè¯•äº†ä¸‹ï¼Œå¥½åƒæ€»æ˜¯è¯­æ³•æœ‰é—®é¢˜...12345678910111213141516171819202122232425262728293031323334353637383940CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no zr ng Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=z5); Not16(in=z5, out=z6); Inc16(in=z6, out=z7); Or16(a=z5, b=z7, out[15]=z8); Not(in=z8, out=zr); And16(a=z5, b=true, out[15]=ng); Mux16(a=z3, b=z4, sel=no, out=out);&#125; Unit 2.6 Perspectivesè¿™å‘¨çš„é—®é¢˜ä¸»è¦æœ‰ 4 ä¸ªï¼š ç›®å‰æ‰€æž„å»ºçš„å¤§çº¦ 20 ç§é€»è¾‘ç”µè·¯ï¼Œæ˜¯å¦éƒ½æ˜¯æ ‡å‡†çš„ï¼Ÿ é—®è¿™ä¸ªé—®é¢˜çš„äººå£ä¸­çš„æ ‡å‡†åº”è¯¥æ˜¯ç›¸å¯¹äºŽå·¥ä¸šç•Œè€Œè¨€çš„ï¼Œè€å¸ˆçš„å›žç­”å¾ˆç›´æŽ¥ï¼Œé™¤äº†ç”¨äºŽå­¦ä¹ çš„ ALUï¼Œå…¶ä»–éƒ½æ˜¯æ ‡å‡†çš„ã€‚å…¶å®žä»”ç»†ä¸€æƒ³ï¼Œå¤ªåº•å±‚çš„ä¸œè¥¿ï¼Œåè€Œæ²¡æœ‰å¤šç§æž„å»ºæ–¹æ³•ï¼Œå¤§å®¶ç”¨çš„å…¶å®žéƒ½æ˜¯é‚£ä¸€å¥—ã€‚ ç›®å‰å®žçŽ°çš„ ALU ä¸ºä½•ä¸èƒ½æä¾›ä¹˜æ³•æˆ–é™¤æ³•ï¼Ÿ å› ä¸ºè¯¾ç¨‹ä¸­å®žçŽ°çš„ ALU è¿‡äºŽç®€å•ï¼Œåªæ˜¯ä¸ºäº†å­¦ä¹ ä½¿ç”¨ã€‚ä½†ä½ ä¾ç„¶å¯ä»¥è‡ªå·±åŽ»å®žçŽ°ä¹˜æ³•æˆ–é™¤æ³•ï¼Œè¿™å–å†³äºŽå¼€å‘è€…æ˜¯å¦éœ€è¦ç»™å®ƒæ·»åŠ è¿™ä¸ªåŠŸèƒ½ã€‚ è¯¾ç¨‹ä¸­çš„ ALU æ˜¯å¦é«˜æ•ˆï¼Ÿ è¯¾ç¨‹ä¸­è®¾è®¡çš„å¤§å¤šæ•°é€»è¾‘ç”µè·¯éƒ½æ˜¯é«˜æ•ˆçš„ï¼Œä½†æœ‰ä¸€ç§ä»ç„¶å¯ä»¥æ”¹è¿›çš„æ›´é«˜æ•ˆï¼Œé‚£å°±æ˜¯â€”â€”Adderã€‚ç›®å‰å®ƒâ€œä½Žæ•ˆâ€çš„åŽŸå› åœ¨äºŽï¼Œå…¶å†…éƒ¨å®žçŽ°æ˜¯ç”±å¤šä¸ªå…¨åŠ å™¨â€œä¸²â€èµ·æ¥çš„ï¼Œæ‰€ä»¥äºŒè¿›åˆ¶æ¯”ç‰¹æµçš„æµåŠ¨å­˜åœ¨ä¸€å®šçš„å»¶è¿Ÿã€‚ ä¸ºä½•å»ºè®®å­¦ç”Ÿä½¿ç”¨ built-in chipsï¼Ÿ ç¬¬ä¸€ï¼Œä½¿ç”¨ built-in chips ä¼šæ›´åŠ é«˜æ•ˆï¼›ç¬¬äºŒæ˜¯å› ä¸ºå¯ä»¥é¿å…ä¸€äº›æœªçŸ¥çš„é”™è¯¯ï¼Œè€Œè¿™äº›é”™è¯¯å¯èƒ½æ˜¯ç”±æ¨¡æ‹Ÿå™¨çš„ bug å¯¼è‡´çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™å¹¶ä¸æ˜¯ä½ çš„ä»£ç æœ‰é—®é¢˜ï¼›ç¬¬ä¸‰ï¼Œæ¨¡æ‹Ÿå™¨å¹¶ä¸é«˜æ•ˆï¼Œä½¿ç”¨è‡ªå·±æž„å»ºçš„ chips å¯èƒ½ä¼šè¿›ä¸€æ­¥é™ä½Žæ•ˆçŽ‡ã€‚ è¿™å‘¨å†…å®¹çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•æž„å»º ALUï¼Œå¯è§åœ¨æ²¡æœ‰é«˜çº§è¯­è¨€çš„å¸®åŠ©ä¸‹ï¼Œå¦‚æžœæƒ³è¦åœ¨åº•å±‚å®žçŽ°ä¸€äº›å¤æ‚é€»è¾‘ï¼Œè¿˜æ˜¯æŒºè´¹è„‘å­çš„ã€‚å¦å¤–ï¼Œè¿˜æœ‰ä¸€å—çŸ¥è¯†è€å¸ˆæ²¡æœ‰å¼ºè°ƒï¼Œå°±æ˜¯æ ¹æ®é€»è¾‘è¿ç®—æ¥æž„é€ å®žé™…è¿ç®—ï¼Œä¹Ÿå°±æ˜¯ ALU è¿™æ ·è®¾è®¡çš„èƒŒåŽåŽŸç†ï¼Œè¿™éƒ¨åˆ†å†…å®¹å¯èƒ½åˆè·Ÿç”µå­¦æœ‰ç‚¹å…³ç³»å§...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_01]]></title>
    <url>%2F2020%2F09%2F20%2FNand2Tetris-Part1-01%2F</url>
    <content type="text"><![CDATA[Nand2Tetris æ˜¯ç”±å¸Œä¼¯æ¥å¤§å­¦çš„ä¸¤ä½æ•™æŽˆ Noam Nisan å’Œ Shimon Schocken åœ¨ Coursera ä¸Šå¼€è®¾çš„åœ¨çº¿è¯¾ç¨‹ï¼ˆç½‘ç»œè¯¾ç¨‹ï¼‰ã€‚è¯¾ç¨‹å…¨ç§°å«åšï¼šä¾æ®åŸºæœ¬åŽŸç†æž„å»ºçŽ°ä»£è®¡ç®—æœºï¼šä»Žä¸Žéžé—¨åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼ˆåŸºäºŽé¡¹ç›®çš„è¯¾ç¨‹ï¼‰ï¼Œå…¶ä¸»è¦å†…å®¹ä¸Žè®¡ç®—æœºç»„æˆåŽŸç†ã€æ“ä½œç³»ç»Ÿç­‰ç§‘ç›®çš„å…³è”æ€§è¾ƒå¤§ï¼Œä½†è¯¾ç¨‹çš„å—ä¼—ç¾¤ä½“ä¹Ÿä¸æ­¢å±€é™äºŽä¸“ä¸šäººå£«ï¼Œä¸”è¯¾ç¨‹çš„å®žè·µæ€§å¾ˆå¼ºï¼Œå¯¹æ·±å…¥ç†è§£ç†è®ºçŸ¥è¯†å¾ˆæœ‰å¸®åŠ©ã€‚ Introductionç¬¬ä¸€å‘¨åŒ…å«ä¸¤ä¸ªç« èŠ‚ï¼ˆä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸€å‘¨ä¸€ä¸ªï¼‰ï¼šIntroduction å’Œ Boolean Functions and Gate Logicã€‚é¡¾åæ€ä¹‰ï¼ŒIntroduction æ˜¯å¯¹æœ¬è¯¾ç¨‹çš„è¯´æ˜Žï¼ŒBoolean Functions and Gate Logic æ‰æ˜¯ç¬¬ä¸€å‘¨çš„çœŸæ­£çš„å­¦ä¹ å†…å®¹ã€‚é€šè¿‡ Introduction å¯ä»¥çŸ¥é“å¤§ä½“çš„å­¦ä¹ è·¯çº¿æ˜¯ä»ŽåŸºæœ¬çš„é€»è¾‘é—¨å•å…ƒå¼€å§‹ï¼Œè‡ªä¸‹è€Œä¸Šçš„å­¦ä¹ å¦‚ä½•æž„å»ºè®¡ç®—æœºï¼Œç»§è€Œæž„å»ºå‡ºèƒ½åœ¨è¿™å°è®¡ç®—æœºä¸Šè¿è¡Œçš„ç¨‹åºï¼Œä¹Ÿå³ï¼šNand -&gt; Hack -&gt; Tetrisã€‚å¦å¤–ï¼Œå¯¹äºŽè´­ä¹°äº†è¯¾ç¨‹çš„åŒå­¦è€Œè¨€ï¼Œè¿™ç« èŠ‚ä¼šæœ‰ä¸€ä¸ªç¼–ç¨‹ä½œä¸šï¼Œç”¨æ¥ç»ƒä¹ å¦‚ä½•åœ¨ Coursera ä¸Šæäº¤ä½œä¸šã€‚ä½†å¦‚æžœä½ æ˜¯æ—å¬ç”Ÿï¼ˆauditorï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥å¿½ç•¥æŽ‰ã€‚ Boolean Functions and Gate Logicè¿™éƒ¨åˆ†å†…å®¹å±žäºŽè®¡ç®—æœºç³»ç»Ÿç»“æž„åº•å±‚ä¸­çš„åº•å±‚ï¼Œè¯¾ç¨‹ä»Žä¸€ä¸ªå°å°é—¨é€»è¾‘ç”µè·¯å¼€å§‹è®²èµ·ï¼ˆå½“ç„¶ä¸ä¼šè®²ä¸Žç‰©ç†ç›¸å…³çš„å†…å®¹ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆè®©å¤§å®¶ä¸è¦è¿‡åˆ†åœ¨æ„çš„åœ°æ–¹ï¼‰ï¼Œé€æ­¥ä»‹ç»å„ç§ä¸åŒçš„é€»è¾‘ç”µè·¯ï¼Œå¹¶è‡ªè¡Œæž„é€ å…·æœ‰ä¸€å®šå¤æ‚æ€§çš„å¤åˆé€»è¾‘é—¨ç”µè·¯ã€‚ Unit 1.1 Boolean Logicæœ¬å°èŠ‚ä¸»è¦ä»‹ç»äº†ä¸‰ç§åŸºæœ¬çš„é€»è¾‘é—¨ï¼ˆLogic gateï¼‰ï¼šä¸Žï¼ˆAndï¼‰ã€æˆ–ï¼ˆOrï¼‰å’Œéžï¼ˆNotï¼‰ï¼Œå¹¶ä¸¾ä¾‹è¯´æ˜Žäº†ä¸Žä¹‹å¯¹åº”çš„åŸºæœ¬è¿ç®—æ–¹æ³•å’Œè§„å¾‹ã€‚ ä¸‰ç§é€»è¾‘é—¨çš„çœŸå€¼è¡¨ï¼ˆTruth tableï¼‰å¦‚ä¸‹ï¼šAndï¼š$$\begin{array}{cc|c}x &amp; y &amp; And \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Orï¼š$$\begin{array}{cc|c}x &amp; y &amp; Or \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Notï¼š$$\begin{array}{c|c}x &amp; Not \\\hline0 &amp; 0 \\1 &amp; 0 \\\end{array}$$ è¿ç®—è§„å¾‹ï¼š äº¤æ¢å¾‹ï¼ˆCommutative Lawï¼‰ x and y = y and x x or y = y or x ç»“åˆå¾‹ï¼ˆAssociative Lawï¼‰ x and (y and z) = (x and y) and z x or (y or z) = (x or y) or z åˆ†é…å¾‹ï¼ˆDistributive Lawï¼‰ x and (y or z) = (x and y) or (x and z) x or (y and z) = (x or y) and (x or z) å¾·æ‘©æ ¹å¾‹ï¼ˆDe Morgan Lawï¼‰ not (x and y) = (not x) or (not y) not (x or y) = (not x) and (not y) ä»¥ä¸ŠåŸºæœ¬å†…å®¹è¯´ä¸å®šå°±ä¼šç”¨åˆ°ï¼Œè®°å½•ä¸‹ã€‚ Unit 1.2 Boolean Functions Synthesisæœ¬å°èŠ‚ä¸»è¦è®²äº†ä¸‰ç‚¹ï¼š å¦‚ä½•æ ¹æ®çœŸå€¼è¡¨æ¥åå‘æž„é€ å¸ƒå°”å‡½æ•° ä»‹ç»äº†ä¸€ä¸ªç»“è®ºï¼šä»»æ„å¸ƒå°”å‡½æ•°éƒ½èƒ½è¢«ä¸Žæˆ–éžä¸‰ç§è¿ç®—è¡¨ç¤ºï¼ˆAny Boolean function can be represented using an expression containing AND, OR and NOT operations.ï¼‰ æŽ¥ä¸‹æ¥ä¼šç”¨ä¸Žéžé—¨ï¼ˆNandï¼‰æ¥æž„å»ºå…¶ä»–é€»è¾‘é—¨ Unit 1.3 Logic gatesæœ¬å°èŠ‚ç€é‡åœ¨è¯´æ˜Žä¸€ä¸ªé—®é¢˜ï¼Œå³ï¼šè¿™é—¨è¯¾ç¨‹ä¸ä¼šä»Žç‰©ç†å±‚é¢æ·±ç©¶è¿™ç§é€»è¾‘é—¨æ˜¯æ€Žæ ·å®žçŽ°çš„ï¼Œä½†æ˜¯ä¼šæŽ¢è®¨å¦‚ä½•åˆ©ç”¨åŸºç¡€é€»è¾‘é—¨æ¥æž„å»ºå¤åˆé€»è¾‘é—¨ã€‚å¦å¤–ï¼Œè¿˜ä»‹ç»äº†åœ¨è¿™ä¸ªè¯¾ç¨‹ä¸­ä¼šè§åˆ°çš„ä¸€äº›æè¿°ç”¨è¯­ã€‚PSï¼šGod bless their souls. æ„Ÿè§‰åƒæ˜¯åœ¨å˜²è®½å‘¢ï¼ˆç¬‘ï¼‰ã€‚ Unit 1.4 Hardware Description Languageæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜Žç¡¬ä»¶æè¿°è¯­è¨€ï¼ˆåŽé¢ä¼šç®€ç§° HDLï¼‰çš„è¯­æ³•è§„åˆ™ï¼Œä¸å¤šï¼Œå»ºè®®ç›´æŽ¥è‡ªå·±çœ‹è€å¸ˆæä¾›çš„æ‰‹å†Œï¼Œå¹¶è¯•ç€å†™ä¸‹ä»£ç ï¼Œæœ‰äº†ä¸€å®šçš„æ„Ÿæ€§è®¤è¯†åŽï¼Œå†æ¥å¬ï¼Œå¯èƒ½ä¼šæ”¶èŽ·å¤šä¸€ç‚¹ã€‚ Unit 1.5 Hardware Simulationæœ¬å°èŠ‚ä¸»è¦åœ¨è®²å¦‚ä½•ä½¿ç”¨è¯¾ç¨‹æä¾›çš„ç¡¬ä»¶æ¨¡æ‹Ÿå™¨å’Œä¸€äº›æ³¨æ„äº‹é¡¹ã€‚ Unit 1.6 Multi Bit Busesæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜Žå¤šä½ï¼ˆbitï¼‰é€»è¾‘é—¨åœ¨æœ¬è¯¾ç¨‹æ‰€ç”¨çš„ HDL ä¸­çš„ç”¨æ³•ï¼Œå¹¶é¡ºä¾¿å¤§è‡´çš„è¯´æ˜Žäº†ä¸€ä¸‹æ€»çº¿çš„å«ä¹‰ï¼Œå¯¹åŽé¢æž„é€ ä½é€»è¾‘å•å…ƒæœ‰ä¸€å®šå¸®åŠ©ï¼Œç‰¹åˆ«æ˜¯æœ‰ HDL ä»£ç çš„åœ°æ–¹ï¼Œå¯¹åŽé¢çš„ä½œä¸šå¾ˆæœ‰å¸®åŠ©ã€‚ Unit 1.7 Project 1 Overviewæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»ç¬¬ä¸€å‘¨çš„ä½œä¸šä»¥åŠè¿™å‘¨ä½œä¸šå¯¹äºŽåŽç»­è¯¾ç¨‹çš„æ„ä¹‰ã€‚ä¸å¾—ä¸è¯´ï¼Œå›½å†…è€å¸ˆä»Žæ¥ä¸ä¼šè·Ÿä½ è®²ä½œä¸šçš„æ„ä¹‰ï¼Œæœ€å¤šç»™ä½ è®²è®²é”™é¢˜ã€‚ æ‰¯è¿œäº†ï¼Œæ¯å‘¨ä½œä¸šåŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼šä»£ç æºæ–‡ä»¶ï¼ˆ.hdlï¼‰ã€æµ‹è¯•è„šæœ¬ï¼ˆ.tstï¼‰å’Œæ¯”å¯¹æ–‡ä»¶ï¼ˆ.cmpï¼‰ï¼ˆå…¶å®žå°±æ˜¯ç¨‹åºæ­£ç¡®çš„è¿è¡Œç»“æžœï¼‰ï¼Œæ¯ä¸€ä¸ªå°ä½œä¸šï¼ˆå°±æ˜¯ä½ è¦å®žçŽ°çš„æ¯ä¸€ä¸ªå°èŠ¯ç‰‡ï¼‰éƒ½åŒ…å«è¿™ä¸‰ä¸ªæ–‡ä»¶ã€‚å¥½æ¶ˆæ¯æ˜¯æµ‹è¯•è„šæœ¬è·Ÿæ­£ç¡®ç­”æ¡ˆè€å¸ˆéƒ½å‡†å¤‡å¥½äº†ï¼Œåæ¶ˆæ¯æ˜¯ä»£ç å¾—è‡ªå·±å†™ï¼ˆå…¶å®žä¹Ÿä¸ç®—åæ¶ˆæ¯ï¼Œæœ¬å°±æ˜¯åˆ†å†…ä¹‹äº‹ï¼Œç¬‘ï¼‰ï¼Œä¸‹é¢æˆ‘ä»¬æ¥å®Œæˆè¿™å‘¨çš„ä½œä¸šã€‚ PSï¼šæœ‰ä¸€ç‚¹è¦æ³¨æ„ï¼Œä¸‹é¢è¿™äº›é€»è¾‘é—¨å®žçŽ°çš„æ–¹å¼ä¸å”¯ä¸€ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆä¸€å†å¼ºè°ƒçš„ä¸œè¥¿ã€‚ NotNand æ˜¯æˆ‘ä»¬åœ¨è¿™ä¸ªè¯¾ç¨‹ä¸­å¯ä»¥ç›´æŽ¥ä½¿ç”¨çš„åŸºæœ¬é€»è¾‘é—¨ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨ï¼ŒNot æ˜¯æˆ‘ä»¬è¦å®Œæˆçš„ç¬¬ä¸€ä¸ªèŠ¯ç‰‡ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ä½¿ç”¨ä¸€ä¸ªäºŒå…ƒçš„ä¸Žéžé—¨æ¥å®žçŽ°ä¸€ä¸ªä¸€å…ƒçš„éžé—¨ï¼ˆThe implementation of a unary Not gate from a binary Nand gate is simple.ï¼‰ã€‚ ä¸€å…ƒéžé—¨åªæœ‰ä¸¤ç§æƒ…å†µï¼ŒäºŒå…ƒä¸Žéžé—¨æœ‰å››ç§æƒ…å†µï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æŽ¥ç”¨ä¸Žéžé—¨çš„å…¶ä¸­ä¸¤ç§æƒ…å†µæ¥è¡¨ç¤ºéžé—¨å³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567CHIP Not &#123; IN in; OUT out; PARTS: Nand(a=in, b=true, out=out);&#125; Andä¸€å¼€å§‹æ€è€ƒå¦‚ä½•å®žçŽ° And æ—¶ï¼Œæœ‰ç‚¹æ— ä»Žä¸‹æ‰‹çš„æ„Ÿè§‰åŽæ¥ï¼Œæƒ³äº†ä¸€ä¼šï¼Œæƒ³åˆ°äº†ä¸¤ç§æ–¹æ³•ï¼š ä½¿ç”¨ 2 ä¸ª Nand ä½¿ç”¨ 1 ä¸ª Nandï¼Œåœ¨ä½¿ç”¨ 1 ä¸ª Not 12345678910111213CHIP And &#123; IN a, b; OUT out; PARTS: /* method 1: use 2 Nand Nand(a=a, b=b, out=c); Nand(a=c, b=true, out=out); */ /* method 2: use Nand and Not */ Nand(a=a, b=b, out=c); Not(in=c, out=out);&#125; Orå®žçŽ° And ä¹‹åŽï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šé¢å®žçŽ°å¥½äº†çš„é€»è¾‘é—¨æ¥å¸®åŠ©å®žçŽ° Orã€‚ 12345678910CHIP Or &#123; IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=nota, b=notb, out=e); Not(in=e, out=out);&#125; Xorå¼‚æˆ–è¿ç®—æœ‰ç‚¹ç‰¹æ®Šï¼ŒåŒæ ·è¿˜æ˜¯ç”¨å·²ç»å®žçŽ°è¿‡çš„é€»è¾‘é—¨æ¥å®žçŽ°ã€‚123456789CHIP Xor &#123; IN a, b; OUT out; PARTS: Or(a=a, b=b, out=c); Nand(a=a, b=b, out=d); And(a=c, b=d, out=out);&#125; MuxMux å…¨ç§° Multiplexorï¼Œå³å¤šè·¯å¤ç”¨å™¨ï¼ˆå¤§æ¦‚æ˜¯è¿™ä¸ªæ„æ€å§ï¼‰ï¼Œè¿™ä¸ªä¸œè¥¿åº”è¯¥æ˜¯é€šä¿¡ä¸“ä¸šåŒå­¦ç ”ç©¶çš„ä¸œè¥¿ï¼Œæœ‰ä¸‰ä¸ªè¾“å…¥ï¼šaï¼Œb å’Œ selã€‚è§„åˆ™å°±æ˜¯æ ¹æ® sel çš„å€¼æ¥ç¡®å®šè¾“å‡º a è¿˜æ˜¯ bï¼Œsel æœ‰ç‚¹åƒæ˜¯æ ¡éªŒç ä¹‹ç±»çš„ä¸œè¥¿å§ã€‚ ç²—ç•¥åˆ†æžä¸€ä¸‹ï¼ŒMux æœ‰å…«ç§æƒ…å†µï¼Œæˆ‘ä»¬å…ˆè§‚å¯Ÿä¸€ä¸‹å®ƒçš„çœŸå€¼è¡¨ã€‚$$\begin{array}{ccc|c}a &amp; b &amp; sel &amp; Mux \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 \\\end{array}$$Mux çš„ç»“æžœä¸­æœ‰ 4 ä¸ªå€¼ä¸ºçœŸï¼Œä»”ç»†å›žæƒ³ä¸€ä¸‹è€å¸ˆåœ¨ 1.2 è®²çš„æœ‰å…³åå‘æž„é€ å¸ƒå°”å‡½æ•°çš„çŸ¥è¯†ï¼Œé¦–å…ˆå…ˆåˆ—å‡ºæ‰€æœ‰çœŸå€¼çš„è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯ä¸Šè¡¨ä¸­çš„ç¬¬ 3ã€4ã€6ã€8 è¡Œï¼Œå¯å¾—ï¼š ç¬¬ 3 è¡Œï¼ša and (not b) and (not sel) ç¬¬ 4 è¡Œï¼ša and b and (not sel) ç¬¬ 6 è¡Œï¼šnot a and b and sel ç¬¬ 8 è¡Œï¼ša and b and sel ç»§è€Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° Mux çš„å¸ƒå°”å‡½æ•°å¼å­ï¼š(a and (not b) and (not sel)) or (a and b and (not sel)) or ((not a) and b and sel) or (a and b and sel)ã€‚æ±—ï¼ŒçœŸé•¿ï¼Œä¸è¿‡å…ˆä¸ç®¡ï¼Œæˆ‘ä»¬ç›´æŽ¥æŒ‰ç…§è¿™ä¸ªå‡½æ•°æ¥å†™ä»£ç ï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹ä»£ç ï¼š12345678910111213141516171819202122232425CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=b, out=notb); Not(in=sel, out=notsel); Not(in=a, out=nota); And(a=a, b=notb, out=u1); And(a=u1, b=notsel, out=u2); And(a=a, b=b, out=v1); And(a=v1, b=notsel, out=v2); And(a=nota, b=b, out=w1); And(a=w1, b=sel, out=w2); And(a=a, b=b, out=x1); And(a=x1, b=sel, out=x2); Or(a=u2, b=v2, out=y1); Or(a=y1, b=w2, out=y2); Or(a=y2, b=x2, out=out);&#125; æµ‹è¯•åŽç»“æžœæ˜¯æ­£ç¡®çš„ï¼Œä¸è¿‡è¿™æ˜¾ç„¶ä¸å¤Ÿè€å¸ˆè¯´çš„ elegantï¼ˆç¬‘ï¼‰ï¼Œæˆ‘ä»¬æ¥æŠŠå¸ƒå°”å‡½æ•°å¼æ ¹æ®è¿ç®—è§„åˆ™åŒ–ç®€ä¸€ä¸‹ï¼Œå¯å¾—ï¼š(a and (not sel)) or (b and sel)ï¼Œä»Žè€Œå¯å¾—ï¼š12345678910CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=sel, out=notsel); And(a=a, b=notsel, out=u); And(a=b, b=sel, out=v); Or(a=u, b=v, out=out);&#125; æµ‹è¯•åŽç»“æžœä¾ç„¶æ­£ç¡®ï¼Œè¯´æ˜ŽåŒ–ç®€æ˜¯æ­£ç¡®çš„ã€‚ ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ä¸Šé¢çš„æ–¹æ³•æ¥æž„é€ å¸ƒå°”å‡½æ•°ï¼Ÿå› ä¸ºæ­¤æ—¶æˆ‘ä»¬èƒ½ç”¨çš„é€»è¾‘é—¨å·²ç»ä¸ä»…ä»…åªæœ‰ Nandï¼Œè¿˜æœ‰å…ˆå‰å·²ç»æž„é€ å¥½äº†çš„ Andã€Notã€Orã€Xorï¼Œè¿™äº›éƒ½å¯ä»¥ç›´æŽ¥æ‹¿æ¥ç”¨äº†ï¼Œé‚£è¿˜è´¹è„‘å­æ­»æƒ³å¹²å˜›å‘¢ã€‚å½“ç„¶äº†ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆå¼ºè°ƒè¿‡çš„æ€æƒ³ã€‚ å¦å¤–ï¼Œé€šè¿‡ä¸Šé¢çš„è®¡ç®—è¿‡ç¨‹å’Œè€å¸ˆçš„è®²è§£ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°åå‘æž„é€ å¸ƒå°”å‡½æ•°æ—¶çš„å‡ ä¸ªè¦ç‚¹ï¼š é€‰å–ç»“æžœåºåˆ—ä¸­çœŸå€¼æˆ–å‡å€¼è¾ƒå°‘çš„ä¸€æ–¹ï¼Œä¸Šé¢çš„ Mux ä¸­çœŸå‡å€¼éƒ½æ˜¯ 4 ä¸ªï¼Œä»»å–å³å¯ ç”¨æ¯ä¸€ä¸ªå€¼å†™å‡ºçš„å¼å­å¿…é¡»ä¿è¯å…¶ä¸­çš„æ¯ä¸€å­é¡¹çš†ä¸ºçœŸæˆ–å‡ï¼Œæ¯”å¦‚ä»¥ä¸Šé¢ç¬¬ 3 è¡Œä¸ºä¾‹ï¼Œaã€not b å’Œ not sel çš„å€¼éƒ½æ˜¯ 1 å•ä¸ªå¼å­çš„æ¯ä¸€å­é¡¹è¦è¿›è¡Œ and è¿ç®—ï¼Œè€Œæ¯ä¸ªå¼å­ä¹‹é—´åˆ™ç”¨ or è¿ç®— PSï¼šæœ‰å…³é€»è¾‘å¼å­åŒ–ç®€çš„é—®é¢˜ï¼Œåº”è¯¥å±žäºŽç¦»æ•£æ•°å­¦çš„çŸ¥è¯†ã€‚ DMuxDMuxï¼ŒDemultiplexorï¼Œå³è§£å¤ç”¨å™¨ï¼Œä¸Ž Mux æ˜¯ä¸€å¯¹ï¼ŒäºŒè€…çš„åŠŸèƒ½ä¹Ÿæ­£å¥½ç›¸åï¼Œä½† DMux çš„ç‰¹æ®Šæ€§åœ¨äºŽå®ƒæœ‰ä¸¤ä¸ªè¾“å‡ºã€‚æˆ‘ä»¬è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯æ¥æž„å»ºï¼Œå…ˆçœ‹ä¸€ä¸‹ DMux çš„çœŸå€¼è¡¨$$\begin{array}{c|cc}sel &amp; a &amp; b \\\hline0 &amp; in &amp; 0 \\1 &amp; 0 &amp; in \\\end{array}$$è¿™æ˜¯è€å¸ˆæä¾›çš„èµ„æ–™ä¸Šçš„çœŸå€¼è¡¨ï¼Œå¥½åƒä¸æ˜¯å¾ˆæ˜“äºŽåˆ†æžé—®é¢˜ï¼Œé‚£æˆ‘ä»¬æŠŠè¯¦ç»†çš„çœŸå€¼è¡¨æ•´ç†å‡ºæ¥ï¼š$$\begin{array}{cc|cc}sel &amp; in &amp; a &amp; b \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 \\\end{array}$$è¿™æ ·ï¼Œæˆ‘ä»¬åœ¨åˆ†æžè¿™ä¸ªé—®é¢˜æ—¶ï¼Œå°±å¯ä»¥å•ç‹¬è€ƒè™‘å¦‚ä½•åˆ©ç”¨ sel å’Œ in åˆ†åˆ«å¾—åˆ° aã€b è¿™ä¸¤åˆ—å€¼ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011CHIP DMux &#123; IN in, sel; OUT a, b; PARTS: Not(in=in, out=notin); Or(a=sel, b=notin, out=v1); Not(in=v1, out=a); And(a=sel, b=in, out=b);&#125; Not16å¤šä½é€»è¾‘é—¨æ˜¯è€å¸ˆåœ¨ 1.6 è®²è¿‡çš„å†…å®¹ï¼Œæž„é€ çš„åŸºæœ¬æ€æƒ³å°±æ˜¯æ¯ä¸€ä½éƒ½ç”¨ä¸€ä¸ªé€»è¾‘é—¨æ¥è®¡ç®—ï¼Œç»„åˆåœ¨ä¸€èµ·å°±å¯ä»¥äº†ã€‚12345678910111213141516171819202122CHIP Not16 &#123; IN in[16]; OUT out[16]; PARTS: Not(in=in[0], out=out[0]); Not(in=in[1], out=out[1]); Not(in=in[2], out=out[2]); Not(in=in[3], out=out[3]); Not(in=in[4], out=out[4]); Not(in=in[5], out=out[5]); Not(in=in[6], out=out[6]); Not(in=in[7], out=out[7]); Not(in=in[8], out=out[8]); Not(in=in[9], out=out[9]); Not(in=in[10], out=out[10]); Not(in=in[11], out=out[11]); Not(in=in[12], out=out[12]); Not(in=in[13], out=out[13]); Not(in=in[14], out=out[14]); Not(in=in[15], out=out[15]);&#125; And1612345678910111213141516171819202122CHIP And16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]);&#125; Or1612345678910111213141516171819202122CHIP Or16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: Or(a=a[0], b=b[0], out=out[0]); Or(a=a[1], b=b[1], out=out[1]); Or(a=a[2], b=b[2], out=out[2]); Or(a=a[3], b=b[3], out=out[3]); Or(a=a[4], b=b[4], out=out[4]); Or(a=a[5], b=b[5], out=out[5]); Or(a=a[6], b=b[6], out=out[6]); Or(a=a[7], b=b[7], out=out[7]); Or(a=a[8], b=b[8], out=out[8]); Or(a=a[9], b=b[9], out=out[9]); Or(a=a[10], b=b[10], out=out[10]); Or(a=a[11], b=b[11], out=out[11]); Or(a=a[12], b=b[12], out=out[12]); Or(a=a[13], b=b[13], out=out[13]); Or(a=a[14], b=b[14], out=out[14]); Or(a=a[15], b=b[15], out=out[15]);&#125; Mux1612345678910111213141516171819202122CHIP Mux16 &#123; IN a[16], b[16], sel; OUT out[16]; PARTS: Mux(a=a[0], b=b[0], sel=sel, out=out[0]); Mux(a=a[1], b=b[1], sel=sel, out=out[1]); Mux(a=a[2], b=b[2], sel=sel, out=out[2]); Mux(a=a[3], b=b[3], sel=sel, out=out[3]); Mux(a=a[4], b=b[4], sel=sel, out=out[4]); Mux(a=a[5], b=b[5], sel=sel, out=out[5]); Mux(a=a[6], b=b[6], sel=sel, out=out[6]); Mux(a=a[7], b=b[7], sel=sel, out=out[7]); Mux(a=a[8], b=b[8], sel=sel, out=out[8]); Mux(a=a[9], b=b[9], sel=sel, out=out[9]); Mux(a=a[10], b=b[10], sel=sel, out=out[10]); Mux(a=a[11], b=b[11], sel=sel, out=out[11]); Mux(a=a[12], b=b[12], sel=sel, out=out[12]); Mux(a=a[13], b=b[13], sel=sel, out=out[13]); Mux(a=a[14], b=b[14], sel=sel, out=out[14]); Mux(a=a[15], b=b[15], sel=sel, out=out[15]);&#125; Or8Way12345678910111213CHIP Or8Way &#123; IN in[8]; OUT out; PARTS: Or(a=in[0], b=in[1], out=v1); Or(a=v1, b=in[2], out=v2); Or(a=v2, b=in[3], out=v3); Or(a=v3, b=in[4], out=v4); Or(a=v4, b=in[5], out=v5); Or(a=v5, b=in[6], out=v6); Or(a=v6, b=in[7], out=out);&#125; Mux4Way164 è·¯ Mux16 ä½¿ç”¨ä¸‰ä¸ª Mux16 å³å¯å®Œæˆï¼Œå¯èƒ½ä¼šæœ‰äººé—®ä¸ºä»€ä¹ˆè¦å…ˆè®© a å’Œ c å…ˆé€šè¿‡ä¸€æ¬¡ Mux16ã€‚å› ä¸º sel bits æ˜¯ä»Žå³å¾€å·¦è¯»çš„ï¼Œè‹¥ a å’Œ b å…ˆé€šè¿‡ä¸€æ¬¡ Mux16ï¼Œå½“ sel[1]=0 æ—¶ï¼Œå°±æ— æ³•å¾—åˆ°æ­£ç¡®çš„è¾“å‡ºç»“æžœäº†ï¼ˆsel[0]=0ï¼Œå°±è¾“å‡º aï¼Œsel[0]=1ï¼Œå°±è¾“å‡º bï¼Œä½†ç¬¬ä¸€æ¬¡é€šè¿‡ Mux16 åŽå·²ç»è¿‡æ»¤æŽ‰ a æˆ– b äº†ï¼‰ã€‚123456789CHIP Mux4Way16 &#123; IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=c, sel=sel[1], out=v1); Mux16(a=b, b=d, sel=sel[1], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; Mux8Way16åœ¨ Mux4Way16 çš„åŸºç¡€ä¸Šæž„é€ å°±è¡Œäº†ï¼Œæ³¨æ„ä¸€ä¸‹è¿™é‡Œçš„è¯­æ³•ã€‚1234567891011CHIP Mux8Way16 &#123; IN a[16], b[16], c[16], d[16], e[16], f[16], g[16], h[16], sel[3]; OUT out[16]; PARTS: Mux4Way16(a=a, b=c, c=e, d=g, sel=sel[1..2], out=v1); Mux4Way16(a=b, b=d, c=f, d=h, sel=sel[1..2], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; DMux4Wayå…ˆç”¨ sel[1] æ¥åŒºåˆ† aã€b å’Œ cã€d ä¸¤ç»„ï¼Œå†ç”¨ sel[0] åœ¨ç»„å†…åˆ†åˆ«åŒºåˆ† aã€b å’Œ cã€dã€‚123456789CHIP DMux4Way &#123; IN in, sel[2]; OUT a, b, c, d; PARTS: DMux(in=in, sel=sel[1], a=u1, b=u2); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d);&#125; DMux8Wayåœ¨ DMux4Way çš„åŸºç¡€ä¸Šæž„å»ºå°±è¡Œï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚1234567891011CHIP DMux8Way &#123; IN in, sel[3]; OUT a, b, c, d, e, f, g, h; PARTS: DMux4Way(in=in, sel=sel[1..2], a=u1, b=u2, c=u3, d=u4); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d); DMux(in=u3, sel=sel[0], a=e, b=f); DMux(in=u4, sel=sel[0], a=g, b=h);&#125; Unit 1.8 Perspectivesæœ¬å°èŠ‚ä¸»è¦è€å¸ˆä»¬å›žç­”å­¦ç”Ÿåœ¨è®ºå›åŒºæå‡ºçš„ä¸€äº›å…¸åž‹é—®é¢˜ï¼Œè¿™æ¬¡ä¸»è¦å›žç­”äº† 3 ä¸ªé—®é¢˜ï¼š èƒ½å¦ä¸ç”¨ Nand è€Œæ˜¯ç”¨å…¶ä»–çš„åŸºæœ¬é€»è¾‘é—¨æ¥æž„å»ºä¸€ä¸ªè®¡ç®—æœºï¼Ÿ ç­”æ¡ˆæ˜¯ yesï¼Œè¿™é‡Œæˆ‘ä»¬ä¸æ·±ç©¶å…·ä½“åŽŸå› ã€‚ Nand gate çš„å…·ä½“å·¥ä½œåŽŸç† è€å¸ˆç”¨ç”µè·¯å›¾è®²äº†ä¸€ä¸‹ï¼Œå½“ç„¶ï¼Œè¿™æ˜¯ç”µæ°”å·¥ç¨‹å¸ˆè¯¥å¹²çš„æ´»ï¼Œå°±ä¸å…·ä½“è®¨è®ºäº† å·¥ä¸šåå¢ƒä¸‹ä½¿ç”¨çš„ HDL è¯­è¨€ä¸Žè¯¾ç¨‹ä½¿ç”¨çš„ HDL è¯­è¨€æœ‰ä½•å·®åˆ« å·¥ä¸šçŽ¯å¢ƒç”¨çš„è‚¯å®šåŠŸèƒ½æ›´åŠ å¼ºå¤§ï¼Œæ•ˆçŽ‡æ›´é«˜ï¼Œå­¦ä¹ çš„æ—¶é—´è¾ƒé•¿ï¼›è€Œæœ¬è¯¾ç¨‹çš„ HDL è¯­è¨€åªæ˜¯ä¸ºäº†æ»¡è¶³æ•™å­¦ä½¿ç”¨ï¼Œæ‰€ä»¥åŠŸèƒ½æ€§ä¼šå¼±å¾ˆå¤šï¼Œä½†æ˜“äºŽå­¦ä¹ ï¼Œä¸”è¶³å¤Ÿæ»¡è¶³æœ¬è¯¾ç¨‹çš„æ‰€æœ‰éœ€è¦ æœ¬å‘¨å†…å®¹è¿‡äºŽåº•å±‚ï¼Œä¼°è®¡ä¸å°‘äººè§‰å¾—æ— èŠï¼Œä¸è¿‡è¿˜å¥½ä¸æ˜¯å¤ªéš¾ã€‚å½“ç„¶ï¼Œå¯èƒ½ä¼šæœ‰ç¬¬ä¸€æ¬¡ä½¿ç”¨è¿™æ ·çš„ HDL è¯­è¨€å’Œç¡¬ä»¶æ¨¡æ‹Ÿå™¨è€Œä¸ç†Ÿæ‚‰çš„é—®é¢˜ï¼Œä¸è¿‡è€å¸ˆæä¾›çš„æ‰‹å†Œå’Œè§†é¢‘çš„è®²è§£å¸®åŠ©è¿˜æ˜¯å¾ˆå¤§çš„ã€‚ä¸ªäººæ„Ÿè§‰è€å¸ˆç»™çš„æ‰‹å†Œå¦‚æžœèƒ½æ›´è¯¦ç»†ä¸€ç‚¹ï¼Œç”¨ä¾‹å†å¤šä¸€ç‚¹å°±æ›´å¥½äº†ï¼ˆä¸»è¦è¿˜æ˜¯è‡ªå·±å¤ªæ‡’ï¼Œç¬‘ï¼‰ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax è¯­æ³•å¿«é€ŸæŒ‡å—]]></title>
    <url>%2F2020%2F09%2F17%2FMathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MathJax æ˜¯ä¸€ä¸ª JavaScript åº“ï¼Œå¯ä»¥è®©ä½ ç›´æŽ¥ç”¨ Latex è¯­æ³•æ¥ä¹¦å†™æ•°å­¦å…¬å¼ï¼Œååˆ†æ–¹ä¾¿ã€‚æƒ³æ·±å…¥äº†è§£ MathJaxï¼Œç‚¹å‡»é“¾æŽ¥ï¼šMathJaxï¼Œæœ¬æ–‡æ—¨åœ¨æ•´ç†ä¸€äº›å¹³æ—¶å†™æ–‡æ¡£æ—¶å¸¸ç”¨çš„ä¸€äº›è¯­æ³•ï¼Œä¾¿äºŽå¤æŸ¥ã€‚ ä¹¦å†™ä½ç½®å¹³æ—¶å†™æ–‡æ¡£æ—¶ï¼Œå…¬å¼çš„æ”¾ç½®ä½ç½®æœ‰ä¸¤ä¸ªåœ°æ–¹ï¼šæ–‡å­—ä¸­é—´å’Œå•ç‹¬æˆå—ï¼Œè¿™å°±è·Ÿå•è¡Œä»£ç ä¸Žä»£ç å—ä¸€æ ·ã€‚ æ”¾åœ¨æ–‡å­—ä¸­é—´çš„å…¬å¼è¦ç”¨ä¸€å¯¹ç¾Žå…ƒç¬¦å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ å•ç‹¬æˆå—çš„å…¬å¼è¦ç”¨ä¸¤å¯¹ç¾Žå…ƒç¬¦å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ï¼Œæ˜¾ç¤ºä¸ºï¼š$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ å¸Œè…Šå­—æ¯ æ˜¾ç¤º è¯­æ³• æ˜¾ç¤º è¯­æ³• $\gamma$ \gamma $\delta$ \delta $\epsilon$ \epsilon $\zeta$ \zeta $\eta$ \eta $\theta$ \theta $\iota$ \iota $\kappa$ \kappa $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\pi$ \pi $\rho$ \rho $\sigma$ \sigma $\tau$ \tau $\upsilon$ \upsilon $\phi$ \phi $\chi$ \chi $\psi$ \psi $\omega$ \omega å¦‚æžœè¦å¤§å†™å¸Œè…Šå­—æ¯ï¼Œå°†è¯­æ³•çš„é¦–å­—æ¯å¤§å†™å³å¯ï¼Œå¦‚ï¼š\Sigmaï¼Œæ˜¾ç¤ºä¸ºï¼š$\Sigma$ï¼›å¦‚æžœè¦æ–œä½“å¸Œè…Šå­—æ¯ï¼Œåœ¨è¯­æ³•å‰åŠ ä¸Švarå³å¯ï¼Œå¦‚ï¼š\varsigmaï¼Œæ˜¾ç¤ºä¸ºï¼š$\varSigma$ ä¸Šä¸‹æ ‡ä¸Šæ ‡ä½¿ç”¨^ï¼Œä¸‹æ ‡ä½¿ç”¨_ï¼ŒäºŒè€…åŽé¢å†æŽ¥å­—ç¬¦ï¼Œå¦‚æžœå­—ç¬¦æ•°å¤§äºŽä¸€ä¸ªéœ€è¦ä½¿ç”¨ä¸€å¯¹èŠ±æ‹¬å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$\sum_{i=0}^N$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^N$ çŸ¢é‡$\vec a$æ˜¾ç¤ºä¸ºï¼š$\vec a$ï¼›å¦‚æžœæƒ³æ”¹å˜å­—æ¯ä¸Šæ–¹çš„ç¬¦å·ï¼Œå¯ä»¥è¿™æ ·å†™$$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \overrightarrow{xy} \quad $$ï¼Œæ˜¾ç¤ºä¸ºï¼š$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \ \ \ \overrightarrow{xy} \quad $ æ‹¬å·å°æ‹¬å·ï¼š$()$ï¼Œæ˜¾ç¤ºä¸ºï¼š$()$ä¸­æ‹¬å·ï¼š$[]$ï¼Œæ˜¾ç¤ºä¸ºï¼š$[]$å°–æ‹¬å·ï¼š$&lt;&gt; \langle\rangle$ï¼Œæ˜¾ç¤ºä¸ºï¼š$&lt;&gt; \langle\rangle$\leftå’Œ\rightå¯ä»¥ä½¿ç¬¦å·å¤§å°ä¸Žä¸´è¿‘çš„å…¬å¼ç›¸é€‚åº”ï¼Œå¦‚ï¼š$(\frac{x}{y})$ï¼Œæ˜¾ç¤ºä¸ºï¼š$(\frac{x}{y})$ï¼›è€Œ$\left(\frac{x}{y})\right$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\left(\frac{x}{y}\right)$ æ±‚å’Œã€æžé™å’Œç§¯åˆ† æ±‚å’Œä½¿ç”¨\sumï¼Œå¦‚ï¼š$\sum_{i=0}^n{a_i}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^n{a_i}$ æžé™ä½¿ç”¨\limï¼Œå¦‚:$\lim_{n \to 0}e^n $ï¼Œæ˜¾ç¤ºä¸ºï¼š$\lim_{n \to 0}e^n $ ç§¯åˆ†ä½¿ç”¨\intï¼Œå¦‚ï¼š$\int_0^1 2x dx$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\int_0^1 2x dx$ åˆ†å¼ä¸Žæ ¹å¼ åˆ†å¼ä½¿ç”¨\fracï¼Œç”¨æ³•ä¸ºï¼š$\frac{å¼1}{å¼2}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\frac{å¼1}{å¼2}$ æ ¹å¼ä½¿ç”¨\sqrtï¼Œå¦‚ï¼š$\sqrt{x}{y}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sqrt{x}{y}$ ç‰¹æ®Šå‡½æ•°å¦‚ï¼š$\sin x \quad \ln x \quad \max(A, B, C)$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sin x \quad \ln x \quad \max(A, B, C)$ å–æ•´å‡½æ•°å‘ä¸Šå–æ•´ï¼š$\lceil x \rceil$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\lceil x \rceil$å‘ä¸‹å–æ•´ï¼š$\lfloor x \rfloor$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\lfloor x \rfloor$ ç‰¹æ®Šç¬¦å· æ˜¾ç¤º è¯­æ³• æ˜¾ç¤º è¯­æ³• $\infty$ \infty $\cup$ \cup $\cap$ \cap $\subset$ \subset $\subseteq$ \subseteq $\supset$ \supset $\in$ \in $\notin$ \notin $\varnothing$ \varnothing $\forall$ \forall $\exists$ \exists $\lnot$ \lnot $\nabla$ \nabla $\partial$ \partial $\geqslant$ \geqslant $\leqslant$ \leqslant ç‰¹æ®Šç¬¦å·è¿˜æœ‰å¾ˆå¤šè¿™é‡Œä¸ä¸€ä¸€åˆ—ä¸¾äº†ã€‚ ç©ºæ ¼LaTex è¯­æ³•æœ¬èº«ä¼šå¿½ç•¥ç©ºæ ¼çš„å­˜åœ¨éœ€è¦ç”¨\æ¥è½¬è¯‘ï¼Œå¦‚ï¼š$a b\ a\ b$ï¼Œæ˜¾ç¤ºä¸ºï¼š$a b\ a\ b$ï¼›ä¸€æ¬¡æ€§ç”Ÿæˆ 4 ä¸ªç©ºæ ¼ï¼Œéœ€è¦ä½¿ç”¨\quadï¼Œå¦‚ï¼š$a \quad b$ï¼Œæ˜¾ç¤ºä¸ºï¼š$a \quad b$ çŸ©é˜µåŸºæœ¬è¯­æ³• èµ·å§‹æ ‡è®°ï¼š\begin{matrix}ï¼Œ ç»“æŸæ ‡è®°ï¼š\end{matrix} æ¯ä¸€è¡Œæœ«å°¾æ ‡è®°ï¼š\\ è¡Œé—´å…ƒç´ ä¹‹é—´ç”¨&amp;åˆ†å‰² å¦‚ï¼š12345$$\begin&#123;matrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;matrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}$$ çŸ©é˜µè¾¹æ¡†ç”¨ä»¥ä¸‹å…³é”®è¯æ›¿æ¢æŽ‰èµ·å§‹ã€ç»“æŸæ ‡è®°ä¸­çš„matrixï¼Œå¦‚ï¼š pmatrixï¼šå°æ‹¬å·è¾¹æ¡† bmatrixï¼šä¸­æ‹¬å·è¾¹æ¡† Bmatrixï¼šå¤§æ‹¬å·è¾¹æ¡† vmatrixï¼šå•ç«–çº¿è¾¹æ¡† Vmatrixï¼šåŒç«–çº¿è¾¹æ¡† å¦‚ï¼š1234567891011121314151617181920212223242526272829$$\begin&#123;pmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;pmatrix&#125;$$$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$$$\begin&#123;Bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Bmatrix&#125;$$$$\begin&#123;vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;vmatrix&#125;$$$$\begin&#123;Vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Vatrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{pmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{pmatrix}$$ $$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}$$ $$\begin{Bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Bmatrix}$$ $$\begin{vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{vmatrix}$$ $$\begin{Vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Vmatrix}$$ çœç•¥å· çœç•¥å·ï¼š\dotsï¼Œå¦‚ï¼š$1 \dots 5$ï¼Œæ˜¾ç¤ºä¸ºï¼š$1 \dots 5$ æ¨ªçœç•¥å·ï¼š\cdots ç«–çœç•¥å·ï¼š\vdots æ–œçœç•¥å·ï¼š\ddots å¦‚ï¼š123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;m1&#125; &amp; a_&#123;m2&#125; &amp; \cdots &amp; a_&#123;mn&#125; \\\end&#123;bmatrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\\end{bmatrix}$$ è¡Œä¸­çŸ©é˜µå¦‚ï¼š$\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$( \begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix} )$ é˜µåˆ—ä½¿ç”¨arrayå…³é”®å­—ï¼ŒåŸºæœ¬è¯­æ³•ï¼š1234$$\begin&#123;array&#125;&#123;æ ¼å¼ä¸²&#125;......\end&#123;array&#125;$$ å…¶ä¸­ï¼Œâ€œæ ¼å¼ä¸²â€ç”±å››ç§å­—ç¬¦æž„æˆï¼Œåˆ†åˆ«ä¸ºï¼š lï¼Œå·¦å¯¹é½ cï¼Œå±…ä¸­ rï¼Œå³å¯¹é½ |ï¼Œå»ºç«‹ç«–ç›´çº¿ ä½¿ç”¨\hlineå¯æ’å…¥æ°´å¹³çº¿ã€‚ å¦‚ï¼š123456$$\begin&#123;array&#125;&#123;c|lll&#125;- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end&#123;array&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{array}{c|lll}- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end{array}$$ æ–¹ç¨‹ç»„ä½¿ç”¨caseså…³é”®å­—ï¼ŒåŸºæœ¬è¯­æ³•ï¼š1234$$\begin&#123;cases&#125;&#123;æ ¼å¼ä¸²&#125;......\end&#123;cases&#125;$$ å¦‚ï¼š123456$$\begin&#123;cases&#125;a_1x + b_1y + c_1z = d_1\\a_2x + b_2y + c_2z = d_2\\a_3x + b_3y + c_3z = d_3\\\end&#123;cases&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{cases}a_1x + b_1y + c_1z = d_1 \\a_2x + b_2y + c_2z = d_2 \\a_3x + b_3y + c_3z = d_3 \\\end{cases}$$æ‰€ä»¥ï¼Œåˆ†æ®µå‡½æ•°å¯ä»¥å†™æˆï¼š123456$$f(x) = \begin&#123;cases&#125;0 &amp; xä¸ºæ— ç†æ•° \\x &amp; xä¸ºæœ‰ç†æ•° \\\end&#123;cases&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$f(x) =\begin{cases}0 &amp; xä¸ºæ— ç†æ•° \\x &amp; xä¸ºæœ‰ç†æ•° \\\end{cases}$$ å­—ä½“è½¬æ¢è¦å¯¹å…¬å¼çš„æŸä¸€éƒ¨åˆ†å­—ç¬¦è¿›è¡Œå­—ä½“è½¬æ¢ï¼Œä½¿ç”¨\[å­—ä½“æ ¼å¼] xxxå³å¯ï¼Œé»˜è®¤ä¸ºæ„å¤§åˆ©ä½“ï¼Œå­—ä½“æ ¼å¼ä»…åˆ—ä¸¾ä»¥ä¸‹å‡ ç§ï¼š å­—ä½“ è¯­æ³• å­—ä½“ è¯­æ³• ç½—é©¬ä½“ \rm æ„å¤§åˆ©ä½“ \it é»‘ä½“ \bf èŠ±ä½“ \cal å€¾æ–œä½“ \sl ç­‰çº¿ä½“ \sf æ•°å­¦æ–œä½“ \mit æ‰“å­—æœºå­—ä½“ \tt å°ä½“å¤§å†™å­—æ¯ \sc å¦‚ï¼š1234567$$a\ b\ c \\\rm &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\\bf &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\$$ æ˜¾ç¤ºä¸ºï¼š$$a\ b\ c \\\rm {a\ b\ c} \\\it {a\ b\ c} \\\bf {a\ b\ c} \\\it {a\ b\ c} \\$$å¦å¤–ï¼Œä¸€èˆ¬ä¼šç”¨textå…³é”®å­æ¥ä¹¦å†™æ–‡æœ¬ï¼Œå¦‚ï¼š$\text{æ— ç©·å¤§}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\text{æ— ç©·å¤§}$ã€‚ å‚è€ƒæ–‡ç« ï¼šMathJax è¯­æ³•å‚è€ƒåŸºæœ¬æ•°å­¦å…¬å¼è¯­æ³•(of MathJax)Markdown æ•°å­¦å…¬å¼è¯­æ³•]]></content>
      <categories>
        <category>Tools</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown è¯­æ³•å¿«é€ŸæŒ‡å—]]></title>
    <url>%2F2020%2F09%2F16%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[æœ‰å…³ Markdown çš„æ¦‚å¿µæ€§é—®é¢˜ï¼Œè¯·ç‚¹å‡»é“¾æŽ¥è‡ªè¡ŒæŸ¥çœ‹ã€‚æœ¬æ–‡æ—¨åœ¨æ•´ç†ä¸€äº›å¹³æ—¶å†™æ–‡æ¡£æ—¶å¸¸ç”¨çš„ä¸€äº›è¯­æ³•ï¼Œè¿™æ ·æ—¢æ–¹ä¾¿ä»–äººæŸ¥çœ‹ï¼Œä¹Ÿä»¥å…è‡ªå·±å¿˜è®°ã€‚ æ ‡é¢˜Markdown æ”¯æŒä¸¤ç§å½¢å¼çš„æ ‡é¢˜ï¼ŒSetext å’Œ atxï¼Œå¸¸ç”¨çš„æ˜¯ atx è¯­æ³•çš„æ ‡é¢˜ï¼Œæœ¬æ–‡ä»¥æ­¤ä¸ºä¸»ã€‚Atx æ ·å¼çš„æ ‡é¢˜æ¯è¡Œå¼€å¤´ä½¿ç”¨ 1-6 ä¸ªäº•å·ï¼Œäº•å·çš„ä¸ªæ•°å¯¹åº” 1-6 çº§æ ‡é¢˜ï¼ˆæœ€å¤šä¹Ÿå°± 6 çº§ï¼‰ï¼Œä¾‹å¦‚ï¼š12345# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜#### å››çº§æ ‡é¢˜ æ•ˆæžœå¦‚ä¸‹ï¼š å—å¼•ç”¨å—å¼•ç”¨çš„æ–¹å¼å¾ˆç®€å•ï¼Œä¾‹å¦‚ï¼š1&gt; xxxx æ•ˆæžœå¦‚ä¸‹ï¼š xxxx å¼•ç”¨å†…è¿˜å¯ä»¥åŒ…å« Markdown çš„å…¶ä»–å…ƒç´ ï¼Œå¦‚åˆ—è¡¨å’Œä»£ç å—ç­‰ï¼Œè¿™é‡Œä¸è¯¦ç»†ä»‹ç»äº†ã€‚ åˆ—è¡¨Markdown æ”¯æŒæœ‰åºåˆ—è¡¨å’Œæ— åºåˆ—è¡¨ã€‚ æ— åºåˆ—è¡¨æ— åºåˆ—è¡¨ä½¿ç”¨æ˜Ÿå·ã€åŠ å·å’Œè¿žå­—ç¬¦ï¼Œä½¿ç”¨ä»»ä¸€ç¬¦å·éƒ½å¯ä»¥å®žçŽ°ä¸€æ ·çš„æ•ˆæžœï¼Œä¾‹å¦‚ï¼š1234567891011* peach* apple* banana+ peach+ apple+ banana- peach- apple- banana æ•ˆæžœå¦‚ä¸‹ï¼š peach apple banana peach apple banana peach apple banana æœ‰åºåˆ—è¡¨æœ‰åºåˆ—è¡¨ä½¿ç”¨æ•°å­—åŠ ç‚¹å®Œæˆï¼ˆç‚¹åŽä¸Žå­—ç¬¦ä¹‹é—´æœ‰ç©ºæ ¼ï¼‰ï¼Œä¾‹å¦‚ï¼š1231. peach2. apple3. banana æ•ˆæžœå¦‚ä¸‹ï¼š peach apple banana åˆ—è¡¨ä¹‹é—´è¿˜å¯ä»¥è¿›è¡ŒåµŒå¥—ä½¿ç”¨ï¼Œå½¢æˆä¸€çº§è¡¨å¤´å’ŒäºŒçº§è¡¨å¤´è¿™æ ·çš„ä¸œè¥¿ï¼Œå¦‚ï¼š12345- xxx - xxx1. 111 2. 222 æ•ˆæžœå¦‚ä¸‹ï¼š xxx xxx 111 222 ä»£ç å—å¸¸è§ç”¨æ³•ä¸»è¦æœ‰å•è¡Œä»£ç å—å’Œå¤šè¡Œä»£ç å—ã€‚ å•è¡Œä»£ç å—å•è¡Œä»£ç å—ä½¿ç”¨ä¸€å¯¹é‡éŸ³ç¬¦``æ¥ä¹¦å†™ï¼Œç›´æŽ¥å°†ä»£ç æ”¾åˆ°é‡éŸ³ç¬¦ä¸­é—´å³å¯ï¼Œå¦‚ï¼š1`xxx` xxxxxxxxx å¤šè¡Œä»£ç å—å¤šè¡Œä»£ç å—ä½¿ç”¨ä¸‰å¯¹é‡éŸ³ç¬¦æ¥ä¹¦å†™ï¼ŒåŒæ ·å°†ä»£ç å—æ”¾åˆ°ä¸­é—´å³å¯ï¼Œå¦‚ï¼š12345(```)xxxbbbxxx(```)æ³¨æ„å®žé™…æ˜¯æ²¡æœ‰æ‹¬å·çš„ æ•ˆæžœå¦‚ä¸‹ï¼š1xxxbbbxxx æ°´å¹³çº¿å¦‚æžœä¸€è¡Œä¸­åªæœ‰ä¸‰ä¸ªä»¥ä¸Šçš„è¿žå­—ç¬¦ã€æ˜Ÿå·æˆ–ä¸‹åˆ’çº¿ï¼Œåˆ™ä¼šåœ¨è¯¥ä½ç½®ç”Ÿæˆä¸€ä¸ª&lt;hr&gt;æ ‡ç­¾ï¼Œè¿™æ¡çº¿å¯ä»¥å«æ°´å¹³çº¿ï¼Œä¹Ÿå¯ä»¥å«åˆ†å‰²çº¿ï¼Œæ•ˆæžœå¦‚ä¸‹ï¼š ä¸åŒçš„ Markdown ç¼–è¾‘å™¨æ¸²æŸ“å‡ºæ¥çš„æ•ˆæžœå¯èƒ½ä¸ä¸€æ ·ã€‚ è¡¨æ ¼Markdown å†…è¡¨æ ¼çš„ç”¨æ³•æœ‰ç‚¹éº»çƒ¦ï¼Œéœ€è¦ä½¿ç”¨å†’å·ã€ç«–çº¿å’Œè¿žå­—ç¬¦æ¥å®Œæˆï¼Œå¦‚ï¼š1234è¡¨å¤´ | è¡¨å¤´ | è¡¨å¤´-- | :--: | --:1 | 2 | 34 | 5 | 6 æ•ˆæžœå¦‚ä¸‹ï¼š è¡¨å¤´ è¡¨å¤´ è¡¨å¤´ 1 2 3 4 5 6 å¤§è‡´è¯´æ˜Žä¸€ä¸‹ï¼šç¬¬äºŒè¡Œæ˜¯æ ¼å¼æŽ§åˆ¶è¡Œï¼Œ-æœ‰ä¸€ä¸ªå°±å¯ä»¥äº†ï¼Œæœ‰æ—¶ä¸ºäº†å¯¹é½ä¼šå¤šåŠ å‡ ä¸ªï¼›é™¤äº†ç¬¬äºŒè¡Œå¤–çš„å…¶ä»–è¡Œä¸­çš„æ–‡å­—æ˜¯é»˜è®¤å±…å·¦çš„ï¼Œä¸¤è¾¹éƒ½åŠ :ï¼Œå°±å¯ä»¥å±…ä¸­ï¼Œå³è¾¹åŠ :å°±å¯ä»¥å±…å³ã€‚ è¡¨æ ¼ä¸­çš„æ–‡å­—ä¹Ÿèƒ½ä½¿ç”¨ Markdown ä¸­æ–‡å­—ç›¸å…³çš„è¯­æ³•ï¼›å¦‚æžœæƒ³è¦æ”¹å˜è¡¨æ ¼ä¸­æ–‡å­—çš„é¢œè‰²ï¼Œå¯ä»¥å€ŸåŠ©fontæ ‡ç­¾æ¥å®Œæˆã€‚ æ–‡å­—ä¸Žæ–‡å­—ç›¸å…³çš„è¯­æ³•ï¼Œå¦‚ï¼š1234**åŠ ç²—***æ–œä½“****æ–œä½“åŠ ç²—***~~åˆ é™¤~~ æ•ˆæžœå¦‚ä¸‹ï¼šåŠ ç²—æ–œä½“æ–œä½“åŠ ç²—åˆ é™¤ å›¾ç‰‡å¼•ç”¨åŸºæœ¬è¯­æ³•ï¼Œå¦‚ï¼š123![å›¾ç‰‡åç§°](å›¾ç‰‡åœ°å€ &quot;å›¾ç‰‡ä¸‹æ ‡é¢˜&quot;)å¦‚ï¼š![zzz](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600276810120&amp;di=ffb59bf5363570267ac8201139b33c94&amp;imgtype=0&amp;src=http%3A%2F%2Fa2.att.hudong.com%2F86%2F10%2F01300000184180121920108394217.jpg &quot;xxx&quot;) æ•ˆæžœå¦‚ä¸‹ï¼š é“¾æŽ¥åŸºæœ¬è¯­æ³•ï¼Œå¦‚ï¼š123[é“¾æŽ¥åç§°](é“¾æŽ¥åœ°å€)å¦‚ï¼š[Baidu](https://www.baidu.com) æ•ˆæžœå¦‚ä¸‹ï¼šBaidu å‚è€ƒæ–‡ç« ï¼šMarkdown ä¸­æ–‡æ–‡æ¡£MarkdownåŸºæœ¬è¯­æ³•]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_Summary]]></title>
    <url>%2F2020%2F09%2F16%2FZJU-DS-Summary%2F</url>
    <content type="text"><![CDATA[è¯¾å ‚ç¬”è®°å…¨éƒ¨å†™å®Œäº†ï¼Œæ€»ç»“ä¸€ä¸‹ã€‚ è¯¾å ‚è¯„ä»·è™½ç„¶è¿™æ˜¯é—¨åœ¨çº¿è¯¾ç¨‹ï¼Œä½†æ˜¯è¯¾å ‚çš„è´¨é‡å…¶å®žå¾ˆé«˜ï¼Œä¸»è¦å½’åŠŸäºŽä¸¤ä½è€å¸ˆæ·±å…¥æµ…å‡ºçš„è®²è§£ï¼Œä»¥åŠåœ¨åˆé€‚çš„æ—¶é—´æ’å…¥çš„è¯¾é—´ä¹ é¢˜ã€‚ç§è®¤ä¸ºå§¥å§¥è·Ÿä½•å¤´å·²ç»å°½é‡è®²çš„ç®€å•ä¸€ç‚¹äº†ï¼Œä½†æ˜¯ç”±äºŽè¿™é—¨è¯¾ç¨‹çš„ç‰¹æ®Šæ€§ï¼ˆæŠ½è±¡çš„ä¸œè¥¿å¤ªå¤šï¼‰ï¼Œå¯èƒ½è¿˜æ˜¯æœ‰äººå¬çš„äº‘é‡Œé›¾é‡Œï¼Œå»ºè®®å¤šå¬å‡ éã€‚ä½•å¤´è®²è¯¾æ¯”è¾ƒç›´æŽ¥ï¼Œå„ç§ç»†èŠ‚æ€§é—®é¢˜éƒ½ä¼šç»™ä½ è®²æ¸…æ¥šï¼Œå§¥å§¥è®²è¯¾å¶å°”ä¼šâ€œè°ƒçš®â€ä¸€ä¸‹ï¼ˆå¿ƒæ€çœŸæ˜¯å¹´è½»å•Š...ï¼‰ï¼Œæ›´æƒ³å¼•å‘ä½ è‡ªå·±çš„æ€è€ƒï¼›ä»–ä»¬çš„å…±åŒç‚¹å°±æ˜¯è¯¾ä¸Šè®²çš„è¯éƒ½ååˆ†çš„ç²¾ç»ƒï¼Œæ²¡ä»€ä¹ˆåºŸè¯ï¼Œæœ‰äº›åœ°æ–¹è¿˜å¾—éƒ½å¬å‡ éæ‰èƒ½æ‡‚ã€‚ å¦å¤–ï¼Œè¯¾é—´ç©¿æ’çš„ä¹ é¢˜å’Œè§†é¢‘åŽçš„è®¨è®ºå¯ä»¥å¼•å‘å­¦ç”Ÿçš„æ€è€ƒï¼Œå¯¹ç†è§£è¯¾ä¸Šçš„ä¸œè¥¿æœ‰ä¸€å®šçš„å¸®åŠ©ï¼Œè¿™ä¹Ÿæ˜¯å€¼å¾—ç§°èµžçš„åœ°æ–¹ï¼›ä¸“é—¨è®¾ç½®çš„â€œå°ç™½ä¸“åœºâ€ä¹Ÿæ˜¯ååˆ†è´´å¿ƒï¼Œå€¼å¾—å¥½è¯„ã€‚ è¯¾ç¨‹ç»ƒä¹ è¯¾ç¨‹ç»ƒä¹ ä¸»è¦æœ‰ä¸‰ç§ï¼šè¯¾é—´ä¹ é¢˜ã€è¯¾åŽä¹ é¢˜å’Œ PTA ä¸Šçš„ç¼–ç¨‹é¢˜ã€‚è¯¾é—´ä¹ é¢˜å¸®åŠ©ç†è§£è¯¾å ‚ä¸Šæ‰€è®²çš„å†…å®¹ï¼›è¯¾åŽä¹ é¢˜å¸®åŠ©å·©å›ºè¯¾å ‚ä¸Šæ‰€è®²çš„å†…å®¹ï¼›PTA ä¸Šçš„ä½œä¸šé¢˜ç®—æ˜¯å®žæ‰“å®žçš„â€œåº”ç”¨é¢˜â€ï¼ŒæŠŠè¯¾ä¸Šå­¦çš„ç†è®ºä¸€æ­¥æ­¥å®žçŽ°ï¼Œæ—¢èƒ½åŠ æ·±å¯¹ç†è®ºçš„ç†è§£ï¼Œåˆèƒ½å¢žå¼ºç¼–ç èƒ½åŠ›ï¼Œååˆ†ä¸é”™ã€‚ æœ‰ç‚¹ç¾Žä¸­ä¸è¶³çš„åœ°æ–¹å°±æ˜¯è¯¾åŽä¹ é¢˜å¤ªå°‘äº†ï¼Œè¿™ç±»ç¬”è¯•é¢˜ç›®å¦‚æžœèƒ½å¢žå¤šï¼Œå¯¹è¦è€ƒè¯•çš„å­¦ç”Ÿè€Œè¨€å¾ˆæœ‰å¸®åŠ©ã€‚ä¸è¿‡ï¼Œè€å¸ˆä»¬ç¼–çš„æ•™æä¸Šä¹Ÿæœ‰ä¸å°‘ä¹ é¢˜ï¼Œè¿™å¯èƒ½æ˜¯è¯¾åŽä¹ é¢˜æ¯”è¾ƒå°‘çš„åŽŸå› ã€‚ å…³äºŽ PTA ä¸Šçš„ç¼–ç¨‹é¢˜ï¼Œå»ºè®®å…¨éƒ¨åšå®Œï¼ˆè™½ç„¶è€å¸ˆè¯´äº†é‚£äº›å¿…åšï¼Œé‚£äº›é€‰åšï¼‰ï¼Œä¸€å®šè¦è‡ªå·±å…ˆåšï¼Œä¸èƒ½ä¸€æ¬¡ AC ä¸è¦ç´§ï¼Œå®žåœ¨ AC ä¸äº†ï¼Œå†çœ‹è€å¸ˆçš„è®²è§£ï¼ˆéš¾ä¸€ç‚¹çš„åŸºæœ¬éƒ½è®²äº†ï¼‰ã€‚æœ‰äº›é¢˜ç›®çš„è§£é¢˜æ€è·¯å…¶å®žæœ‰å¾ˆå¤šï¼Œå…‰æ˜¯ç›´æŽ¥ç™¾åº¦å°±æœ‰å¾ˆå¤šèµ„æ–™å¯æŸ¥ã€‚å¦å¤–ï¼Œé¢˜ç›®æ€»ä½“éš¾åº¦å¤§æ¦‚å°±æ˜¯ PAT ç”²çº§çš„éš¾åº¦äº†ï¼Œä½œä¸šé¢˜é‡Œé¢æœ‰äº›å°±æ˜¯å½“å¹´çš„ç”²çº§çœŸé¢˜ï¼Œæ‰€ä»¥ä¸€å®šè¦å¥½å¥½åšã€‚ è€ƒè¯•è€ƒè¯•çš„å½¢å¼æ¯”è¾ƒç®€å•ï¼Œä¹Ÿå¾ˆæ–¹ä¾¿ï¼Œæ¯å‘¨ä½œä¸šéƒ½æ˜¯ç¼–ç¨‹é¢˜ï¼Œè€ƒè¯•æœ‰åˆ¤æ–­ã€é€‰æ‹©ã€å¡«ç©ºã€ç¼–ç é¢˜ï¼Œæ²¡æœ‰åšè¿‡é’ˆå¯¹æ€§ç»ƒä¹ çš„åŒå­¦å¯èƒ½ä¼šå¾ˆä¸ä¹ æƒ¯ï¼Œæœ€å¥½è€ƒè¯•å‰åšç‚¹é’ˆå¯¹æ€§çš„ç»ƒä¹ ã€‚å¦å¤–ï¼Œå¦‚æžœè€ƒè¯•ç»“æŸåŽï¼Œèƒ½æä¾›é”™é¢˜çš„ç­”æ¡ˆå°±å®Œç¾Žäº†ã€‚ ä¸ªäººä½“ä¼šæ•°æ®ç»“æž„ä¸Žç®—æ³•è¿™é—¨è¯¾æ˜¯çœŸçš„å¾ˆæŠ½è±¡ï¼ŒåŸºæœ¬å…¨éƒ¨éƒ½æ˜¯ç†è®ºåŒ–çš„ä¸œè¥¿ï¼Œå­¦çš„åŸºæœ¬å°±æ˜¯å‡ åå¹´å‰çš„è®¡ç®—æœºç§‘å­¦å®¶è®ºæ–‡ä¸Šå†™çš„ä¸œè¥¿ï¼Œå¾—è€ä½æ€§å­ï¼Œä»”ç»†é’»ç ”ã€‚è¿™é—¨è¯¾å°±å¥½æ¯”ä¿®ç‚¼æ­¦ä¾ ç»æŠ€å‰ä¿®ç‚¼çš„â€œå†…åŠŸå¿ƒæ³•â€ä¸€èˆ¬ï¼Œæ˜¯æ ¹åŸºï¼Œç†è®ºåŸºç¡€æ‰Žå®žäº†ï¼Œå®žè·µèƒ½åŠ›æ‰èƒ½ç¨³æ­¥æé«˜ã€‚ä¸è¿‡ï¼Œä¸¤ä½è€å¸ˆè®²çš„å¾ˆæ£’ï¼Œç€å®žæ–¹ä¾¿äº†ä¸å°‘ã€‚ åœ¨æŠŠå›¾å­¦å®Œçš„æ—¶å€™ï¼Œæ„Ÿè§‰å°±åƒæ˜¯æœ‰äº†â€œå± é¾™å®åˆ€â€å´ä¸çŸ¥é“æ€Žä¹ˆç”¨ä¸€æ ·ã€‚ä¸è¿‡å®žé™…çš„ç”Ÿäº§åå¢ƒä¸­ï¼Œæ ¹æœ¬æ²¡æœºä¼šè®©ä½ åŽ»â€œå± é¾™â€... ä¸€èˆ¬è€Œè¨€ï¼Œè®¡ç®—æœºå­¦ç§‘çš„ç§‘ç›®è¦æƒ³å­¦åˆ°ä¸œè¥¿ï¼Œåˆ‡å¿Œä¸èƒ½ç©ºè°ˆç†è®ºï¼Œä¸€å®šå¾—åŠ¨æ‰‹ï¼ŒåŠ¨æ‰‹åŽ»å†™ï¼ŒåŠ¨è„‘å­åŽ»æƒ³é—®é¢˜ã€‚å°±è¿™é—¨è¯¾è€Œè¨€ï¼ŒPTA ä¸Šçš„ç¼–ç¨‹é¢˜éƒ½æ˜¯ååˆ†ä¸é”™çš„ä¹ é¢˜ï¼Œä¸€å®šå¾—åŠ¨è„‘å­åŽ»å†™ã€‚å°±ç®—ä¸èƒ½è§£å†³ï¼Œåªè¦åŠ¨è„‘å­æ€è€ƒäº†é—®é¢˜ï¼ŒåŸºæœ¬éƒ½ä¼šæœ‰æ”¶èŽ·ã€‚ è‡ªå·±ç®—æ˜¯æŠŠè¿™é—¨è¯¾åå¤å­¦äº†å¥½å‡ éæ‰ç®—æ˜¯èƒ½ç†è§£ä¸€äº›ä¸œè¥¿äº†ï¼Œå¯èƒ½æ˜¯è‡ªå·±è„‘å­å¤ªæ‹™äº†å§... ä¸ç®¡æ€Žä¹ˆè¯´ï¼ŒæŠŠæ‰€æœ‰çš„ç¬”è®°æ•´ç†å®Œä¹Ÿç®—æ˜¯å®Œæˆäº†ä¸€ä»¶äº‹ï¼Œç»§ç»­åŠªåŠ›å§ï¼Œéªšå¹´~ðŸ˜‰]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_12-KMP]]></title>
    <url>%2F2020%2F09%2F15%2FZJU-DS-12-KMP%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨ä¸»è¦è®²è§£å‡ é“é¢˜ç›®ï¼Œç„¶åŽå†ä»‹ç»ä¸€ä¸‹ KMP ç®—æ³•ã€‚ ä¸²åœ¨äº†è§£KMPç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯ä¸²ã€‚ä¸²ï¼ˆStringï¼‰å…¶å®žä¹Ÿæ˜¯çº¿æ€§è¡¨çš„ä¸€ç§åº”ç”¨ï¼ŒæŒ‡çš„æ˜¯çº¿æ€§å­˜å‚¨çš„ä¸€ç»„æ•°æ®ï¼ˆå¸¸è§æ˜¯å­—ç¬¦ï¼Œæ­£æ‰€è°“â€œå­—ç¬¦ä¸²â€ï¼‰ï¼Œå½“ç„¶ï¼Œä¸²ä¸ä»…ä»…åŒ…å«å­—ç¬¦ï¼Œå®ƒæ˜¯é€šç”¨çš„æ•°æ®ç»“æž„ã€‚åŒæ—¶ï¼Œä¸Žä¸²ç›¸å…³çš„æ“ä½œé›†æœ‰å¾ˆå¤šï¼Œå¦‚ï¼šæ±‚ä¸²çš„é•¿åº¦ã€æ¯”è¾ƒä¸¤ä¸²æ˜¯å¦ç›¸ç­‰ã€ä¸¤ä¸²ç›¸æŽ¥ã€æ±‚å­ä¸²ã€æ’å…¥å­ä¸²ã€åŒ¹é…å­ä¸²ï¼ˆKMP å°±æ˜¯å¹²è¿™äº‹çš„ï¼‰ã€åˆ é™¤å­ä¸²ç­‰ã€‚ KMPåŒ¹é…å­ä¸²ä»€ä¹ˆæ˜¯â€œåŒ¹é…å­ä¸²â€å‘¢ï¼Ÿçœ‹åå­—ï¼Œå…¶å®žæœ‰ä¸¤ä¸ªç€é‡ç‚¹ï¼Œä¸€ä¸ªæ˜¯åŒ¹é…ï¼Œä¸€ä¸ªæ˜¯å­ä¸²ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œç»™å®šä¸€æ®µæ–‡æœ¬ï¼Œä»Žä¸­æ‰¾å‡ºæŸä¸ªæŒ‡å®šçš„å…³é”®å­—ï¼Œä¾‹å¦‚ç»™å®šæ–‡æœ¬ï¼šThis is not a bug, itâ€™s destiny. ï¼Œéœ€è¦ä»Žä¸­æ‰¾å‡º bug è¿™ä¸ªå…³é”®å­—ï¼ˆå½“ç„¶è¿™å¹¶ä¸æ˜¯ä»¶å¤æ‚çš„äº‹æƒ…ï¼‰ï¼Œè¿™å®žé™…ä¸Šå°±æ˜¯â€œåŒ¹é…å­ä¸²â€ã€‚ é‚£ä¹ˆæˆ‘ä»¬é‡æ–°è§„èŒƒä¸€ä¸‹ï¼Œå°±æ˜¯ï¼šç»™å®šä¸€ä¸ªæ–‡æœ¬ï¼šstring = xxxxxxxï¼Œåœ¨ç»™å®šä¸€ä¸ªæ¨¡å¼ï¼špattern = xxxxï¼Œæ±‚ pattern åœ¨ string ä¸­å‡ºçŽ°çš„ä½ç½®ã€‚ åˆ†æžä¾æ®åŒ¹é…å­ä¸²çš„æ€è·¯ï¼Œå¦‚æžœè¦æ‰¾patternåœ¨stringä¸­å‡ºçŽ°çš„ä½ç½®ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼ŒæŽ¥ç€å¯¹stringè¿›è¡ŒéåŽ†ï¼ŒåŒæ—¶ä¸Žpatterné€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœå‡ºçŽ°ä¸ç›¸ç­‰çš„ï¼Œåˆ™stringçš„æŒ‡é’ˆå›žé€€åˆ°åˆè¯•æ¯”è¾ƒä½ç½®çš„åŽä¸€ä¸ªä½ç½®ï¼ˆè‹¥ä»Ž i å¼€å§‹æ¯”è¾ƒï¼Œåˆ™å›žé€€åˆ° i+1 å¼€å§‹æ¯”è¾ƒï¼‰ï¼Œpatternçš„æŒ‡é’ˆåˆ™å›žé€€åˆ°ç¬¬ä¸€ä½ï¼Œé‡å¤æ‰§è¡Œå³å¯ï¼Œè¿™å®žé™…ä¸Šæ˜¯ä¸€ç§æš´åŠ›è§£æ³•ã€‚ä½¿ç”¨æš´åŠ›è§£æ³•æ—¶ï¼Œä¸²ä¸­è‚¯å®šä¼šæœ‰ç›¸åŒçš„åºåˆ—å­˜åœ¨ï¼Œæ‰€ä»¥æŒ‡é’ˆå›žæº¯åŽå†æ¬¡éåŽ†æ¯”è¾ƒæ—¶ï¼Œå°±ä¼šè¿›è¡Œé‡å¤çš„æ¯”è¾ƒæ“ä½œäº†ï¼Œè¿™æ ·å°±åšäº†å¾ˆå¤šæ— ç”¨çš„æ“ä½œï¼Œè€Œ KMP ç®—æ³•å°±æ˜¯ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜çš„ã€‚ åŒ¹é…å‡½æ•°KMP ç®—æ³•åœ¨ç›´æŽ¥è¿›è¡ŒåŒ¹é…å‰ä¼šå¯¹æ¨¡å¼ä¸²ï¼ˆpatternï¼‰è¿›è¡Œåˆ†æžï¼Œå€ŸåŠ©ä¸€ä¸ªè¾…åŠ©æ•°ç»„match[]ï¼Œè¿™ä¸ªæ•°ç»„å†…ä¿å­˜ç€æ¨¡å¼ä¸²æŒ‰ç…§ä¸‹é¢çš„ $ match $ å‡½æ•°è®¡ç®—çš„â€œå€¼â€ï¼Œæ ¹æ®è¿™äº›â€œå€¼â€ï¼Œå†æž„é€ åˆé€‚çš„åˆ¤æ–­è§„åˆ™æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼›match[]æ•°ç»„çš„ä¸‹æ ‡å°±æ˜¯æ¨¡å¼ä¸²æ¯ä¸€ä¸ªå­—ç¬¦çš„ä¸‹æ ‡ã€‚å…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸ª $ match $ å‡½æ•°: $$match(j) = \begin{cases}&amp;\text{æ»¡è¶³}p_0 \cdots p_i = p_{j-i} \cdots p_j \text{çš„æœ€å¤§}i(\lt j) \\&amp;-1\ \ \ \text{å¦‚æžœè¿™æ ·çš„} i \text{ä¸å­˜åœ¨}\end{cases}$$ å‡è®¾patternä¸ºabcabcacabè¿™ä¸ªåºåˆ—ï¼Œä¸‹é¢æ¥è®¡ç®—ä¸€ä¸‹å…¶ç”± $ match $ å‡½æ•°å¾—æ¥çš„æ•°ç»„ã€‚1â†’2â†’3â†’4â†’é‡å¤å…ˆä»Žaå¼€å§‹ï¼Œaä¸ºé¦–å­—ç¬¦ï¼Œæ ¹æ® $ match $ å‡½æ•°çš„è§„åˆ™ï¼Œmatch(0) = -1ç»§è€Œåˆ°bï¼Œbéœ€è¦å’Œå‰é¢çš„aè¿›è¡Œæ¯”è¾ƒï¼Œå‘çŽ°ä¸åŒ¹é…ï¼Œmatch(1) = -1å†çœ‹cï¼Œæ­¤æ—¶å¯¹äºŽmatchå‡½æ•°è€Œè¨€ï¼Œiå¯ä»¥å–ä¸¤ä¸ªå€¼ï¼Œåˆ†åˆ«æ˜¯0å’Œ1ï¼ˆæ­¤æ—¶j=2ï¼‰ï¼Œå–0æ—¶ï¼Œcç›´æŽ¥å’Œaæ¯”è¾ƒï¼Œä¸åŒ¹é…ï¼Œå–1æ—¶ï¼Œé‚£å°±æ˜¯abå’Œbcè¿›è¡Œæ¯”è¾ƒï¼Œè¿˜æ˜¯ä¸åŒ¹é…ï¼Œæ‰€ä»¥match(2) = -1å†çœ‹ä¸‹ä¸€ä¸ªaï¼Œæ­¤æ—¶iå¯ä»¥å–ä¸‰ä¸ªå€¼ï¼ˆ0ã€1ã€2ï¼Œæ³¨æ„matchå‡½æ•°çš„æ¡ä»¶æ˜¯ä¸å¤§äºŽjçš„æœ€å¤§iï¼‰ï¼Œå–0ï¼Œaå’Œaæ¯”è¾ƒï¼ŒåŒ¹é…æˆåŠŸï¼Œmatch(3) = 0ï¼Œå–1ï¼Œabå’Œcaä¸åŒ¹é…ï¼Œå–2ï¼Œabcå’Œbcaä¹Ÿä¸åŒ¹é…ï¼ˆè‹¥æ­¤æ—¶åŒ¹é…ï¼Œmatch(3)çš„å€¼éœ€è¦æ›´æ–°ï¼‰ï¼Œæ‰€ä»¥match(3) = 0æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œé‡å¤ç›´è‡³ç»“æŸã€‚é‡å¤è®¡ç®—åŽï¼Œå¯ä»¥å¾—åˆ°ä¸‹è¡¨ï¼š pattern a b c a b c a c a b j 0 1 2 3 4 5 6 7 8 9 match -1 -1 -1 0 1 2 3 -1 0 1 matchå‡½æ•°æœ‰å¤šç§å’Œä¸åŒçš„ç§°å‘¼ï¼Œæœ‰äº›ä¹¦ä¹Ÿå«nextã€‚å¦å¤–ï¼Œéœ€è¦æ˜Žç¡®çš„æ˜¯ï¼Œè¿™ä¸ªç‰¹å®šå‡½æ•°çš„é’ˆå¯¹å¯¹è±¡æ˜¯patternï¼Œä¹Ÿå³æ˜¯ç»™å®šçš„æ¨¡å¼ä¸²ï¼Œè€Œä¸æ˜¯åŽŸä¸²ã€‚å¦å¤–ï¼Œpatternæ¯”è¾ƒçŸ­ï¼Œstringæ¯”è¾ƒé•¿ï¼ŒKMPç®—æ³•åªç”¨åˆ†æžä¸€ä¸ªçŸ­çš„å­ä¸²è€Œä¸ç”¨åˆ†æžä¸€ä¸ªé•¿ä¸²ï¼Œè¿™å…¶å®žå·²ç»æå‡äº†æ•ˆçŽ‡ã€‚ ç®—æ³•å®žçŽ°ä½¿ç”¨ $ match $ å‡½æ•°èŽ·å¾—match[]æ•°ç»„åŽï¼Œå¦‚ä½•åŽ»ä½¿ç”¨match[]æ•°ç»„åˆæˆä¸ºæ–°é—®é¢˜ã€‚é¦–å…ˆæˆ‘ä»¬å·²ç»çŸ¥é“äº†ï¼Œæ ¹æ®match[]æ•°ç»„å¯ä»¥é¿å…åŽ»æ¯”è¾ƒé‡å¤çš„åºåˆ—ï¼Œå½“ä¸åŒ¹é…æ—¶ï¼ŒæŒ‡å‘patternçš„æŒ‡é’ˆpä¼šåŽ»æ‰¾p-1è¿™ä¸ªæŒ‡é’ˆæ‰€æŒ‡ä½ç½®çš„match[]å€¼ï¼Œè€Œè¿™ä¸ªmatch[]å€¼åŠ 1å°±æ˜¯æŒ‡é’ˆpé‡æ–°å¼€å§‹è¿›è¡ŒåŒ¹é…çš„ä½ç½®ï¼Œå³å¦‚ä¸‹å›¾æ‰€ç¤ºï¼šå°±æ˜¯è¿™æ ·åŽ»ä½¿ç”¨matchæ•°ç»„çš„ï¼Œæ˜Žç¡®è¿™ä¸ªé—®é¢˜åŽï¼ŒåŸºæœ¬å¯ä»¥å†™å‡º KMP ç®—æ³•çš„ä»£ç äº†ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š1234567891011121314151617Position KMP(char *string, char *pattern) &#123; int n = strlen(string); /* O(n) */ int m = strlen(pattern); /* O(m) */ int s, p, *match; if(n &lt; m) return NotFound; match = (int*)malloc(m*sizeof(int)); BuildMatch(pattern, match); /* T(B) */ s = p = 0; while(s&lt;n &amp;&amp; p&lt;m) &#123; /* O(n) */ if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p-1] + 1; else s++; &#125; return (p==m)?(s-m):NotFound;&#125; ä»Žä¸Šé¢çš„ä»£ç å¯ä»¥åˆ†æžå‡ºå…¶æ—¶é—´å¤æ‚åº¦åŸºæœ¬ä¸º$T = O(n+m) + T(B)$ï¼ŒBuildMatchå‡½æ•°çš„æ—¶é—´å¤æ‚åº¦å–å†³äºŽå…¶è‡ªèº«çš„å®žçŽ°æ–¹å¼ï¼Œåˆ«å¿˜è®°äº†ï¼ŒKMPæ˜¯ä»¥å®ƒä¸ºå‰æçš„ã€‚ æœ‰äº†å‰é¢å¯¹ $ match $ å‡½æ•°çš„åˆ†æžï¼ŒBuildMatchå‡½æ•°çš„æž„é€ å°±æ¯”è¾ƒç®€å•äº†ï¼Œä½†è‹¥åªæ˜¯ç®€å•ç”¨çº¿æ€§çš„æ–¹æ³•åŽ»æž„é€ matchæ•°ç»„çš„è¯ï¼Œä¼šä½¿å¾—æ—¶é—´å¤æ‚åº¦ä¸º$O(m^3)$ï¼Œè¿™å°±å¾ˆä¸å‹å¥½äº†ï¼Œé‚£æ€Žä¹ˆåŠžå‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯åˆ©ç”¨match[]æ•°ç»„å†…çš„å€¼ï¼Œå¦‚æžœæ˜¯è®¡ç®—ç¬¬iä¸ªä½ç½®çš„matchå€¼ï¼Œé‚£ä¹ˆå¿…å®šå¾—åŽ»æ‰¾i-1çš„matchå€¼åŠ 1æ‰€æŒ‡ä½ç½®çš„å­—ç¬¦æ˜¯å¦ä¸Žiæ‰€æŒ‡ä½ç½®çš„å­—ç¬¦ç›¸åŒï¼Œå¦‚æžœç›¸åŒï¼Œçš†å¤§æ¬¢å–œï¼Œmatch[i] == match[i-1] + 1äº†ï¼Œå¦‚æžœä¸ç›¸ç­‰å‘¢ï¼Ÿ å°±å¾—åŽ»æ‰¾i-1çš„matchå€¼çš„matchå€¼åŠ 1æ‰€æŒ‡ä½ç½®çš„å­—ç¬¦æ˜¯å¦ä¸Žiæ‰€æŒ‡ä½ç½®çš„å­—ç¬¦ç›¸åŒäº†ï¼ˆå¥½ç»•...ðŸ˜“ï¼‰ï¼Œä¹Ÿå³match[match[i-1]]ï¼Œè‹¥ç›¸åŒï¼Œmatch[i] == match[match[i-1]] + 1ï¼Œå¦‚æžœè¿˜ä¸ç›¸ç­‰ï¼Œç»§ç»­æ‰¾å§...ï¼ˆè¿˜å¥½æ˜¯ç”µè„‘å¹²æ´»ðŸ˜“ï¼‰ã€‚å¯å‚è€ƒä¸‹å›¾ï¼šåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š1234567891011121314void BuildMatch(char *pattern, int *match) &#123; int i, j; int m = strlen(pattern); /* O(m) */ match[0] = -1; for(j=1; j&lt;m; j++) &#123; /* O(m) */ i = match[i-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) &#123; match[j] = i+1; &#125; else match[j] = -1; &#125;&#125; ç®€å•åˆ†æžä¸€ä¸‹ä¸Šè¿°ä»£ç çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¯å¾— $T_m(N) = O(m)$ï¼Œç»¼åˆèµ·æ¥ KMP ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $T(N) = O(n+m)$ï¼Œä»Žæš´åŠ›è§£æ³•çš„ $O(nÂ·m)$ ä¼˜åŒ–æˆ $O(n+m)$ï¼Œç¡®å®žåŽ‰å®³ï¼ Homeworkä¸²çš„æ¨¡å¼åŒ¹é…è¿™é“é¢˜ç›®æ˜¯ç”¨æ¥æµ‹è¯•å„å¼å„æ ·çš„ä¸²çš„æ¨¡å¼åŒ¹é…ç®—æ³•çš„ï¼ŒæŒ‰ç…§å§¥å§¥ç»™å‡ºçš„ä»£ç ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define NotFound -1typedef int Position;void Build_Match(char *pattern, int *match) &#123; Position i, j; int m = strlen(pattern); match[0] = -1; for(j=1; j&lt;m; j++) &#123; i = match[j-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) match[j] = i+1; else match[j] = -1; &#125;&#125;Position KMP(char *string, char *pattern) &#123; int n = strlen(string); int m = strlen(pattern); Position s, p, *match; if(n &lt; m) return NotFound; match = (Position*)malloc(m*sizeof(Position)); Build_Match(pattern, match); s = p =0; while(s&lt;n &amp;&amp; p&lt;m) &#123; if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p - 1]+1; else s++; &#125; return (p == m) ? (s - m) : NotFound;&#125;int main(int argc, char const *argv[]) &#123; char string[] = "This is a simple example."; char pattern[] = "simple"; Position p = KMP(string, pattern); if(p == NotFound) printf("Not Found.\n"); else printf("%s\n", string+p); return 0;&#125;/*samples:in:abcabcabcabcacabxy3abcabcacabcabcabcdabcabcabcabcacabxyzout:abcabcacabxyNot FoundNot Found */]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_11-æ•£åˆ—æŸ¥æ‰¾]]></title>
    <url>%2F2020%2F09%2F06%2FZJU-DS-11-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨å°†ä»‹ç»æ•£åˆ—æŸ¥æ‰¾ å¼•å­å…ˆæ¥å›žé¡¾ä¸€ä¸‹å…¶ä»–çš„æŸ¥æ‰¾æ–¹æ³•ï¼š åç§° æ—¶é—´å¤æ‚åº¦ é¡ºåºæŸ¥æ‰¾ $O(N)$ äºŒåˆ†æŸ¥æ‰¾ï¼ˆé™æ€æŸ¥æ‰¾ï¼‰ $O(log_2N)$ äºŒå‰æœç´¢æ ‘ $O(h), h$ä¸ºæ ‘é«˜ å¹³è¡¡äºŒå‰æ ‘ $O(log_2N)$ ä¸Šè¡¨ä¸­çš„æŸ¥æ‰¾æ–¹æ³•éƒ½æ˜¯å»ºç«‹åœ¨å®¹æ˜“æ¯”è¾ƒå…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œå¦‚æžœå…³é”®å­—ä¸å®¹æ˜“æ¯”è¾ƒå‘¢ï¼Ÿ æ•£åˆ—æŸ¥æ‰¾æ•£åˆ—æŸ¥æ‰¾æ‰€è¦è§£å†³çš„é—®é¢˜å°±æ˜¯ï¼š è®¡ç®—ä½ç½®ï¼šæž„é€ æ•£åˆ—å‡½æ•°ç¡®å®šå…³é”®è¯å­˜å‚¨ä½ç½®è§£å†³å†²çªï¼šåº”ç”¨æŸç§ç­–ç•¥è§£å†³å¤šä¸ªå…³é”®è¯ä½ç½®ç›¸åŒçš„é—®é¢˜ æŒ‰ç…§æ•£åˆ—æŸ¥æ‰¾çš„åšæ³•ï¼Œæ¯æ¬¡æŸ¥æ‰¾åªè¿›è¡Œè®¡ç®—å°±å¤Ÿäº†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ï¼Œä¹Ÿå°±æ˜¯è¯´æŸ¥æ‰¾æ—¶é—´ä¸Žé—®é¢˜è§„æ¨¡æ— å…³ï¼ æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šç¬¦å·é›†ï¼ˆSymbol Tableï¼‰æ•°æ®å¯¹è±¡é›†ï¼šç¬¦å·è¡¨æ˜¯â€œåå­—ï¼ˆNameï¼‰- å±žæ€§ï¼ˆAttributeï¼‰â€å¯¹çš„é›†åˆæ“ä½œé›†ï¼šTable âˆˆ Symbol Table, Name âˆˆ NameType, Attr âˆˆ AttributeType SymbolTable InitializeTable(int TableSize)ï¼Œåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºTableSizeçš„ç¬¦å·è¡¨ Boolean IsIn(SymbolTable Table, NameType Name)ï¼ŒæŸ¥æ‰¾ç‰¹å®šçš„åå­—Nameæ˜¯å¦åœ¨ç¬¦å·è¡¨Tableä¸­ AttributeType Find(SymbolTable Table, NameType Name)ï¼ŒèŽ·å–Tableä¸­æŒ‡å®šåå­—Nameå¯¹åº”çš„å±žæ€§ SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)ï¼Œå°†Tableä¸­æŒ‡å®šåå­—Nameçš„å±žæ€§ä¿®æ”¹ä¸ºAttr SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)ï¼Œå‘Tableä¸­æ’å…¥ä¸€ä¸ªæ–°åå­—NameåŠå…¶å±žæ€§Attr SymbolTable Delete(SymbolTable Table, NameType Name)ï¼Œä»ŽTableä¸­åˆ é™¤ä¸€ä¸ªåå­—NameåŠå…¶å±žæ€§ åŸºæœ¬æ€æƒ³æ•£åˆ—ï¼ˆHashingï¼‰çš„åŸºæœ¬æ€æƒ³å¦‚ä¸‹ï¼š ä»¥å…³é”®å­—$key$ä¸ºè‡ªå˜é‡ï¼Œé€šè¿‡æ•£åˆ—å‡½æ•°$h$ï¼Œè®¡ç®—å‡ºå¯¹åº”çš„å‡½æ•°å€¼$h(k)$ï¼Œä½œä¸ºæ•°æ®å¯¹è±¡çš„å­˜å‚¨åœ°å€ã€‚ å¯èƒ½ä¸åŒå…³é”®å­—ä¼šæ˜ å°„åˆ°åŒä¸€æ•£åˆ—åœ°å€ä¸Šï¼Œè¿™ç§æƒ…å†µç§°ä¸ºå†²çªï¼ˆCollisionï¼‰ï¼Œè¿™éœ€è¦æŸç§å†²çªè§£å†³ç­–ç•¥ã€‚ è¿™é‡Œå¼•å…¥è£…å¡«å› å­(Loading Factor)çš„æ¦‚å¿µï¼Œå³ï¼šæ•£åˆ—è¡¨å†…å…ƒç´ ä¸ªæ•°ï¼ˆ$n$ï¼‰ä¸Žæ•£åˆ—è¡¨ç©ºé—´ï¼ˆ$m$ï¼‰çš„æ¯”å€¼ï¼Œå³$\alpha = n / m$ã€‚ æ•£åˆ—å‡½æ•°æŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œåœ¨æž„é€ æ•£åˆ—å‡½æ•°æ—¶éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼š è®¡ç®—ç®€å•ï¼Œä»¥ä¾¿æé«˜åœ°å€è½¬æ¢é€Ÿåº¦ å…³é”®è¯å¯¹åº”çš„åœ°å€ç©ºé—´åˆ†å¸ƒå‡åŒ€ï¼Œä»¥å°½é‡å‡å°‘å†²çª æ ¹æ®æ•°æ®å…ƒç´ çš„ä¸åŒï¼Œå¯ä»¥åˆ†ä¸ºä»¥æ•°å­—å…³é”®è¯å’Œå­—ç¬¦å…³é”®è¯æž„é€ çš„æ•£åˆ—å‡½æ•°ã€‚ æ•°å­—å…³é”®è¯ä»¥æ•°å­—ä¸ºå…³é”®è¯çš„æ•£åˆ—å‡½æ•°æž„é€ æ–¹æ³•åˆæœ‰å¤šç§ï¼Œä¾æ¬¡å¦‚ä¸‹ï¼š åç§° æ•£åˆ—å‡½æ•° ç›´æŽ¥å®šå€æ³• $h(key) = a \times key + b, a, b$ä¸ºå¸¸æ•° é™¤ç•™ä½™æ•°æ³• $h(key) = key mod p, p$å–ç´ æ•° æ•°å­—åˆ†æžæ³• $h(key) = atoi(key + 7)$ æŠ˜å æ³• å…³é”®è¯åˆ†å‰²æˆä½æ•°ç›¸åŒçš„å‡ ä¸ªéƒ¨åˆ†å åŠ  å¹³æ–¹å–ä¸­æ³• å…³é”®å­—å¹³æ–¹åŽå–å…¶ä¸­å‡ ä½ å­—ç¬¦å…³é”®è¯ä»¥å­—ç¬¦ä¸ºå…³é”®è¯çš„æ•£åˆ—å‡½æ•°æž„é€ ä¹Ÿæœ‰å¤šç§ï¼Œä¾æ¬¡å¦‚ä¸‹ï¼šASCIIç åŠ å’Œæ³•å‰3ä¸ªå­—ç¬¦ç§»ä½æ³•ç§»ä½æ³•æ•£åˆ—å‡½æ•°ï¼š$h(key) = (\sum key[i])\ mod\ TableSize$ï¼Œæ­¤æ³•äº§ç”Ÿçš„å†²çªè¾ƒä¸ºä¸¥é‡æ•£åˆ—å‡½æ•°ï¼š$h(key) = (key[0] \times 27^2 + key[1] \times 27 + key[2])\ mod\ TableSize$ï¼Œè¿™é‡Œçœ‹ä½œ 27 è¿›åˆ¶æ•°ï¼Œä¾ç„¶å­˜åœ¨å†²çªï¼Œæ•£åˆ—å‡½æ•°ï¼š$h(key) = (\sum_{i=0}^{i-1} key[n-i-1] \times 32^i)\ mod\ TableSize$ï¼Œçœ‹ä½œ 32 è¿›åˆ¶æ•°æ¶‰åŠå…³é”®è¯ï¼Œæ‰€æœ‰nä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”åˆ†å¸ƒæ¯”è¾ƒå‡åŒ€ 1234567Index Hash(const char *Key, int TableSize) &#123; unsigned int h = 0; while(*Key != â€˜\0â€™) &#123; h = (h &lt;&lt; 5) + *Key++; // h &lt;&lt; 5 &lt;==&gt; h*32 &#125; return h%TableSize;&#125; å†²çªå¤„ç†æ–¹æ³•å¯¹äºŽæ•£åˆ—æŸ¥æ‰¾è€Œè¨€ï¼Œäº§ç”Ÿå†²çªå¿…å®šä¼šå½±å“æ•ˆçŽ‡ï¼Œé‚£ä¹ˆå¦‚ä½•å¤„ç†å†²çªå‘¢ï¼Ÿ å¼€æ”¾å®šå€æ³•å¼€æ”¾å®šå€æ³•çš„æ€è·¯æ¯”è¾ƒç®€å•ï¼Œè¯´ç™½äº†ï¼Œå°±æ˜¯è¿™ä¸ªä¸è¡Œæ¢å¦å¤–ä¸€ä¸ªï¼Œä¸€æ—¦äº§ç”Ÿäº†å†²çªï¼ˆè¯¥åœ°å€å·²æœ‰å…¶å®ƒå…ƒç´ ï¼‰ï¼Œå°±æŒ‰ç…§æŸç§è§„åˆ™å¯»æ‰¾å¦ä¸€ä¸ªç©ºçš„åœ°å€ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå¯»æ‰¾ä¸‹ä¸€ç©ºåœ°å€çš„è¿‡ç¨‹ï¼Œç§°ä¸ºæŽ¢æµ‹ï¼Œè€Œå®ƒä¹Ÿæœ‰å¤šç§ä¸åŒçš„æŽ¢æµ‹æ–¹æ³•ã€‚ çº¿æ€§æŽ¢æµ‹é¡¾åæ€ä¹‰ï¼Œçº¿æ€§æŽ¢æµ‹æ³•å°±æ˜¯çº¿æ€§çš„æŽ¢æµ‹æ³•ï¼ˆè¯´äº†æ²¡è¯´ç³»åˆ—ï¼ŸðŸ˜ï¼‰ï¼Œä¹Ÿå³ä»¥å¢žé‡åºåˆ—${1, 2, \ldots}ï¼ˆTableSize - 1ï¼‰$å¾ªçŽ¯è¯•æŽ¢ä¸‹ä¸€ä¸ªåœ°å€ï¼Œä¹Ÿå°±æ˜¯æ£€æµ‹åˆ°å†²çªäº†ï¼Œä¸‹æ ‡åŠ ä¸€è¯•è¯•ä¸‹ä¸€ä¸ªåœ°å€ï¼Œæ³¨æ„å¾ªçŽ¯åˆ°æœ«å°¾åŽè‹¥è¿˜æ²¡æœ‰ç©ºä½ç½®ï¼Œåˆ™ç»§ç»­ä»Žå¤´éƒ¨å¼€å§‹å¾ªçŽ¯ï¼Œæ­¤æ³•å®¹æ˜“äº§ç”Ÿâ€œèšé›†â€çŽ°è±¡ã€‚ å¹³æ–¹æŽ¢æµ‹å¹³æ–¹æŽ¢æµ‹ä¹Ÿå«äºŒæ¬¡æŽ¢æµ‹ï¼Œä»¥å¢žé‡åºåˆ—${1^2, -1^2, 2^2, -2^2, \ldots, q*2, -q^2}, q \le \lfloor TableSize \rfloor$ï¼Œå¾ªçŽ¯è¯•æŽ¢ä¸‹ä¸€ä¸ªå­˜å‚¨åœ°å€ï¼Œæ­¤æ³•ä¸Žçº¿æ€§æŽ¢æµ‹å”¯ä¸€çš„åŒºåˆ«åªæ˜¯å¢žé‡åºåˆ—ä¸åŒè€Œå·²ã€‚ä½†å¹³æ–¹æŽ¢æµ‹å­˜åœ¨ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œå°±æ˜¯â€œæŠ–åŠ¨â€çŽ°è±¡ï¼Œæ˜Žæ˜Žæœ‰ç©ºä½ç½®ï¼Œä½†æ˜¯å°±æ˜¯æ— æ³•æŽ¢æµ‹åˆ°æ•£åˆ—è¡¨çš„ç©ºä½ç½®ï¼Œä¸è¿‡å¥½åœ¨å¯ä»¥å€ŸåŠ©ä¸‹é¢è¿™ä¸ªå®šç†ï¼ˆæ„Ÿè°¢æ•°å­¦å®¶ðŸ™‡â€ï¼‰ã€‚ å®šç†ï¼šå¦‚æžœæ•£åˆ—è¡¨é•¿åº¦TableSizeæ˜¯æŸä¸ª$4k+3$ï¼ˆ$k$æ˜¯æ­£æ•´æ•°ï¼‰å½¢å¼çš„ç´ æ•°æ—¶ï¼Œå¹³æ–¹æŽ¢æµ‹å°±å¯ä»¥æŽ¢æŸ¥åˆ°æ•´ä¸ªæ•£åˆ—è¡¨ç©ºé—´ã€‚ åŒæ•£åˆ—é¡¾åæ€ä¹‰ï¼ŒåŒæ•£åˆ—ï¼Œå°±æ˜¯äº§ç”Ÿå†²çªäº†ï¼Œå†è¿›è¡Œä¸€æ¬¡æ•£åˆ—ï¼Œä¸¤æ¬¡æ•£åˆ—çš„æ•£åˆ—å‡½æ•°ä¸åŒï¼Œè€Œæ˜¯ç¬¬ä¸€æ¬¡æ•£åˆ—çš„ç»“æžœå°†ä½œä¸ºç¬¬äºŒæ¬¡æ•£åˆ—çš„keyï¼Œä¹Ÿå³$d_i$ä¸º$i \times h_2(key)$ï¼Œå…¶æŽ¢æµ‹åºåˆ—ä¸º$h_2(key),\ 2h_2(key),\ 3h_2(key), \ldots$ï¼Œå¾ˆæ˜Žæ˜¾ï¼Œå¯¹ä»»æ„çš„keyï¼Œ$h_2(key) \neq 0$ï¼Œä¸ºä¿è¯æ‰€æœ‰çš„æ•£åˆ—å­˜å‚¨å•å…ƒéƒ½å¯ä»¥è¢«æŽ¢æµ‹åˆ°ï¼Œ$h_2$é€‰ä¸º$h_2(key) = p - (key\ mod\ p)$ï¼Œ$p,\ TableSize$éƒ½æ˜¯ç´ æ•°ã€‚ å†æ•£åˆ—å½“æ•£åˆ—è¡¨å…ƒç´ å¤ªå¤šï¼ˆå³è£…å¡«å› å­$\alpha$å¤ªå¤§ï¼‰æ—¶ï¼ŒæŸ¥æ‰¾æ•ˆçŽ‡ä¼šä¸‹é™ï¼Œå®žé™…æœ€å¤§è£…å¡«å› å­ä¸€èˆ¬å–$0.5 \le \alpha \le 0.85 $ï¼Œå¯¹åº”çš„è§£å†³åŠžæ³•å°±æ˜¯åŠ å€æ‰©å¤§æ•£åˆ—è¡¨ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±å«åšâ€œå†æ•£åˆ—ï¼ˆRehashingï¼‰â€ï¼Œæ³¨æ„ï¼Œå†æ•£åˆ—æ—¶ï¼ŒåŽŸå…ˆçš„æ•£åˆ—åºåˆ—ä¸æ˜¯ç®€å•çš„å¤åˆ¶ï¼Œè€Œæ˜¯è¦é‡æ–°è®¡ç®—ã€‚ åˆ†ç¦»é“¾æŽ¥æ³•åˆ†ç¦»é“¾æŽ¥æ³•æœ€ç»ˆäº§ç”Ÿçš„ç»“æž„æœ‰ç‚¹ç±»ä¼¼å›¾çš„é‚»æŽ¥è¡¨ï¼Œå…¶åŸºæœ¬æ€æƒ³å°±æ˜¯å°†ç›¸åº”ä½ç½®ä¸Šå†²çªçš„æ‰€æœ‰å…³é”®è¯å­˜å‚¨åœ¨åŒä¸€ä¸ªå•é“¾è¡¨ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ç§ç»“æž„éœ€è¦ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”æ•°ç»„å†…æ¯ä¸ªå…ƒç´ é™¤äº†è¡¨ç¤ºå…³é”®å­—è¿˜å¾—æœ‰ä¸€ä¸ªæŒ‡é’ˆåŸŸï¼Œç”¨æ¥å°†é“¾è¡¨ä¸²èµ·æ¥ã€‚ æ€§èƒ½åˆ†æžå¯¹äºŽæŸ¥æ‰¾è€Œè¨€ï¼Œè¡¡é‡å…¶æ•ˆçŽ‡çš„æŒ‡æ ‡ï¼Œä¾ç„¶æ˜¯å¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼ˆASLï¼Œåˆ†æŸ¥æ‰¾æˆåŠŸå’Œä¸æˆåŠŸä¸¤ç§ï¼‰ï¼Œå¹³å‡æŸ¥æ‰¾é•¿åº¦çš„è®¡ç®—æ–¹æ³•è¦è§†å…·ä½“çš„æ•£åˆ—æ–¹æ³•è€Œå®šã€‚å¦å¤–ï¼Œå½±å“äº§ç”Ÿå†²çªå¤šå°‘æœ‰ä»¥ä¸‹ä¸‰ä¸ªå› ç´ ï¼š æ•£åˆ—å‡½æ•°æ˜¯å¦å†›è¿ å¤„ç†å†²çªçš„æ–¹æ³• æ•£åˆ—è¡¨çš„è£…å¡«å› å­$\alpha$ ä¸‹é¢ç›´æŽ¥ç»™å‡ºå…¶æœŸæœ›æŽ¢æµ‹æ¬¡æ•° pï¼Œä¸åšæ·±å…¥çš„æ•°å­¦æŽ¢è®¨ã€‚ çº¿æ€§æŽ¢æµ‹æ³•ï¼š$p =\begin{cases} \frac{1} {2} [1+\frac{1} {(1-\alpha)^2}],&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\\frac{1}{2}[1+\frac{1}{(1-\alpha)}],&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$å¹³æ–¹æŽ¢æµ‹æ³•ï¼š$p =\begin{cases} \frac{1} {(1-\alpha)},&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\\frac{-1} {\alpha} ln(1-\alpha),&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$åˆ†ç¦»é“¾æŽ¥æ³•ï¼š$p =\begin{cases} \alpha + e^{-\alpha},&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\1+ \frac{\alpha} {2},&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$ æ ¹æ®ä¸Šé¢çš„å…¬å¼æˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸‹é¢å‡ ç‚¹ç»“è®ºï¼š å½“è£…å¡«å› å­$\alpha &lt; 0.5$æ—¶ï¼Œå„ç§æŽ¢æµ‹æ³•çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°éƒ½ä¸å¤§éšç€$\alpha$çš„å¢žå¤§ï¼Œçº¿æ€§æŽ¢æµ‹æ³•çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°å¢žåŠ è¾ƒå¿«ï¼Œä¸æˆåŠŸæŸ¥æ‰¾å’Œæ’å…¥æ“ä½œçš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°æ¯”æˆåŠŸæŸ¥æ‰¾çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°è¦å¤§åˆç†çš„æœ€å¤§è£…å¡«å› å­$\alpha$åº”è¯¥ä¸è¶…è¿‡0.85 æ€»ç»“æ•£åˆ—æŸ¥æ‰¾çš„ä¼˜ç‚¹å¾ˆæ˜Žæ˜¾ï¼Œé€‰æ‹©åˆé€‚çš„æ•£åˆ—å‡½æ•°ï¼Œæ•£åˆ—æŸ¥æ‰¾æ•ˆçŽ‡çš„æœŸæœ›æ˜¯å¸¸æ•°$O(1)$ï¼Œå®ƒå‡ ä¹Žä¸Žå…³é”®å­—çš„ç©ºé—´çš„å¤§å°$n$æ— å…³ï¼Œä¹Ÿé€‚åˆäºŽå…³é”®å­—ç›´æŽ¥æ¯”è¾ƒè®¡ç®—é‡è¿‡å¤§çš„é—®é¢˜ï¼›ä½†å®ƒæ˜¯ä»¥è¾ƒå°çš„$\alpha$ä¸ºå‰æï¼Œæ˜¯ä¸€ä¸ªä»¥ç©ºé—´æ¢æ—¶é—´çš„æŸ¥æ‰¾æ–¹æ³•ï¼›å¦å¤–ï¼Œå®ƒå¯¹å…³é”®å­—çš„å­˜å‚¨æ˜¯éšæœºçš„ï¼Œä¸ä¾¿äºŽé¡ºåºæŸ¥æ‰¾å…³é”®å­—ï¼Œä¹Ÿä¸é€‚åˆäºŽèŒƒå›´æŸ¥æ‰¾ï¼Œæˆ–æœ€å¤§ã€æœ€å°å€¼æŸ¥æ‰¾ã€‚ å¼€æ”¾å®šå€æ³•çš„å­˜å‚¨æ•ˆçŽ‡å¾ˆé«˜ï¼Œä½†æ˜¯å­˜åœ¨â€œèšé›†â€çŽ°è±¡ï¼›åˆ†ç¦»é“¾æŽ¥æ³•æ˜¯é¡ºåºå­˜å‚¨å’Œé“¾å¼å­˜å‚¨çš„ç»“åˆï¼Œé“¾è¡¨éƒ¨åˆ†çš„å­˜å‚¨æ•ˆçŽ‡å’ŒæŸ¥æ‰¾æ•ˆçŽ‡éƒ½æ¯”è¾ƒä½Žï¼Œå…³é”®å­—çš„åˆ é™¤ä¸éœ€è¦â€œæ‡’æƒ°åˆ é™¤ï¼ˆä¸æ–­é“¾ï¼Œåªæ ‡è®°ä¸ºç©ºï¼‰â€ï¼Œä»Žè€Œæ²¡æœ‰å­˜å‚¨â€œåžƒåœ¾â€ï¼Œä½†å¤ªå°çš„$\alpha$å¯èƒ½å¯¼è‡´ç©ºé—´æµªè´¹ï¼Œå¤§çš„$\alpha$åˆå°†ä»˜å‡ºæ›´å¤šçš„æ—¶é—´ä»£ä»·ï¼Œä¸”ä¸å‡åŒ€çš„é“¾è¡¨é•¿åº¦ä¼šå¯¼è‡´æ—¶é—´æ•ˆçŽ‡çš„ä¸¥é‡ä¸‹é™ã€‚ Homework11-1 ç”µè¯èŠå¤©ç‹‚äººè¿™ä¸ªé¢˜å§¥å§¥å·²ç»è®²è¿‡äº†ï¼Œç›´æŽ¥ç”¨å§¥å§¥çš„ä»£ç æœ‰ç‚¹éº»çƒ¦ï¼Œå€ŸåŠ© C++ çš„ MAP å’Œæ•£åˆ—çš„æ€æƒ³ï¼Œå¯ä»¥å¾ˆè½»æ¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2000000 + 5;map&lt;string, int&gt; phonenum2num;map&lt;int, string&gt; num2phonenum;int times[maxn] = &#123; 0 &#125;, n, index = 1;int main() &#123; cin &gt;&gt; n; string num; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; num; int tmp = phonenum2num.find(num)-&gt;second; if (!tmp) &#123; phonenum2num[num] = index; num2phonenum[index] = num; times[index] = 1; index++; &#125; else &#123; times[tmp]++; &#125; &#125; int max = times[1], maxindex = 1, count = 1; string madman = num2phonenum.find(1)-&gt;second; for (int i = 2; i &lt; index; i++) &#123; if (times[i] &gt; max) &#123; max = times[i]; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; else if (times[i] == max) &#123; if (num2phonenum.find(i)-&gt;second &lt; num2phonenum.find(maxindex)-&gt;second) &#123; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; count++; &#125; &#125; if (count == 1) cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max; else cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max &lt;&lt; ' ' &lt;&lt; count; return 0;&#125;/*samples:in:413005711862 1358862583213505711862 1308862583213588625832 1808792583215005713862 13588625832out:13588625832 3*/ 11-2 Hashingæœ¬é¢˜è€ƒå¯Ÿæ•£åˆ—æŸ¥æ‰¾çš„å†²çªå¤„ç†æ–¹æ³•ï¼Œé¢˜ç›®å¾ˆç›´ç™½çš„å‘Šè¯‰äº†å¤„ç†å†²çªçš„æ–¹æ³•æ˜¯å¹³æ–¹æŽ¢æµ‹æ³•ï¼Œä½†é¢˜ç›®è¦æ±‚çš„å¹³æ–¹æŽ¢æµ‹åªä¼šç”¨æ­£æ•´æ•°æŽ¢æµ‹ã€‚è¿™æ–¹é¢çš„çŸ¥è¯†ï¼Œè¯¾ä¸Šä½•è€å¸ˆå·²ç»è®²çš„å¾ˆæ¸…æ¥šäº†ï¼Œä¸è¿‡è¿™ä¸ªé¢˜çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•å¤„ç†æ— æ³•è¿›è¡Œæ•£åˆ—çš„æ•°ã€‚ ç”±äºŽé¢˜ç›®å‘Šè¯‰äº†åªä¼šç”¨æ­£æ•´æ•°æŽ¢æµ‹ï¼Œå…¶å®žç®—æ˜¯å˜ç›¸çš„å‘Šè¯‰ä½ äº†ï¼Œåªè¦ç»è¿‡æ•£åˆ—å‡½æ•°å¾—åˆ°çš„ä¸‹æ ‡å€¼å¤§äºŽæ•£åˆ—è¡¨é•¿åº¦ï¼Œå°±è®¤ä¸ºæ— æ³•å­˜æ”¾äº†ï¼Œä¹Ÿå°±æ˜¯è¯´å¹¶ä¸ä¼šå¾ªçŽ¯è¯•æŽ¢ï¼Œæ˜Žç™½è¿™ç‚¹åŽå°±å¥½åŠžäº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 20000 + 10;bool hashTable[maxn] = &#123; 0 &#125;;bool isprime(int n) &#123; if (n &lt;= 1) return false; else &#123; int tmp = (int)sqrt(n); for (int i = 2; i &lt;= tmp; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125;int nextprime(int m) &#123; while (!isprime(m)) m++; return m;&#125;int hashfunc(int num, int hashkey) &#123; return num % hashkey;&#125;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; m = nextprime(m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; int index = hashfunc(tmp, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; &#125; else &#123; int step; for (step = 1; step &lt; m; step++) &#123; index = hashfunc(tmp + step * step, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; break; &#125; &#125; if (step &gt;= m) &#123; if (i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; '-'; &#125; &#125; &#125; return 0;&#125;/*samples:in:4 410 6 4 15out:0 1 4 -in:5 510 6 4 15 25out:0 1 4 - -in:5 55 10 6 4 15 out:0 1 2 4 -in:1 11out:1*/ 11-3 QQ è´¦æˆ·çš„ç”³è¯·ä¸Žç™»é™†è¿™é¢˜ç”¨ MAP ç®€ç›´å¤ªå®¹æ˜“äº†ï¼Œè¦æ˜¯å…¨éƒ¨è‡ªå·±å†™ï¼Œä»£ç é‡ç•¥å¤§ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; qqnum;int main() &#123; int n; char ope; cin &gt;&gt; n; string tmp_num, tmp_pass; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ope &gt;&gt; tmp_num &gt;&gt; tmp_pass; map&lt;string, string&gt;::iterator it; it = qqnum.find(tmp_num); switch (ope) &#123; case 'L': &#123; if (it == qqnum.end()) &#123; cout &lt;&lt; "ERROR: Not Exist" &lt;&lt; endl; &#125; else &#123; if (it-&gt;second == tmp_pass) &#123; cout &lt;&lt; "Login: OK" &lt;&lt; endl; &#125; else cout &lt;&lt; "ERROR: Wrong PW" &lt;&lt; endl; &#125; break; &#125; case 'N': &#123; if (it != qqnum.end()) &#123; cout &lt;&lt; "ERROR: Exist" &lt;&lt; endl; &#125; else &#123; qqnum[tmp_num] = tmp_pass; cout &lt;&lt; "New: OK" &lt;&lt; endl; &#125; break; &#125; default: break; &#125; &#125; return 0;&#125;/*samples:in:5L 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comL 1234567890 myQQ@qqL 1234567890 myQQ@qq.comout:ERROR: Not ExistNew: OKERROR: ExistERROR: Wrong PWLogin: OK*/ 11-4 Hashing - Hard Versionè¿™ä¸ªé¢˜çš„æ„æ€å¾ˆç›´è§‚ï¼Œå°±æ˜¯ç»™å®šä¸€ä¸ªç”¨çº¿æ€§æŽ¢æµ‹æ³•æž„å»ºçš„æ•£åˆ—è¡¨ï¼Œç„¶åŽè¦æ ¹æ®è¿™ä¸ªå¾—åˆ°æ•°å­—åºåˆ—çš„è¾“å…¥é¡ºåºã€‚ è¿™ä¸ªé¢˜çœ‹èµ·æ¥å¾ˆå®¹æ˜“ï¼Œå…¶å®žæœ‰ç‚¹éš¾æƒ³ã€‚å› ä¸ºå°±æ ·ä¾‹è€Œè¨€ï¼Œ33 å’Œ 1 éƒ½æœ‰å¯èƒ½æ˜¯ç¬¬ä¸€ä¸ªè¾“å…¥çš„ï¼Œè¯¥æ€Žä¹ˆç¡®å®šæ•°å­—çš„è¾“å…¥é¡ºåºå…¶å®žå°±æ˜¯éš¾ç‚¹ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œåšä¸€é“é¢˜æ—¶ï¼Œæƒ³åˆ°çš„éƒ½æ˜¯è·Ÿè¿™ä¸ªé¢˜ç›¸å…³çš„çŸ¥è¯†ã€‚ä½†æ˜¯è¿™ä¸ªé¢˜ï¼Œç¡®å®šè¾“å…¥é¡ºåºå…¶å®žéœ€è¦ç”¨åˆ°æ‹“æ‰‘æŽ’åºçš„çŸ¥è¯†ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000 + 3;vector&lt;int&gt; AdjL[maxn];int n, hashTable[maxn], elements = 0;bool isvis[maxn] = &#123;false&#125;;map&lt;int, int&gt; value2index;map&lt;int, int&gt; index2value;void toposort() &#123; int indegree[maxn] = &#123;0&#125;; for(int v = 0; v &lt; n; v++) &#123; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]++; &#125; &#125; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) &#123; if(indegree[i] == 0 &amp;&amp; hashTable[i] &gt;= 0) &#123; q.push(hashTable[i]); &#125; &#125; int count = 0; while(!q.empty()) &#123; int tmp = q.top(); q.pop(); cout &lt;&lt; tmp; if(count &lt; elements - 1) &#123; cout &lt;&lt; ' '; count++; &#125; int v = value2index[tmp]; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]--; if(indegree[AdjL[v][w]] == 0) q.push(hashTable[AdjL[v][w]]); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; hashTable[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(hashTable[i] &lt; 0) continue; value2index[hashTable[i]] = i; index2value[i] = hashTable[i]; elements++; int tmp = hashTable[i]; int index = tmp % n; if(hashTable[index] == hashTable[i] &amp;&amp; index == i) continue; else &#123; bool flag = true; queue&lt;int&gt; q; for(; index &lt; n || flag; index++) &#123; if(flag &amp;&amp; index &gt;= n) &#123; index %= n; flag = false; &#125; if(hashTable[index] == tmp) break; q.push(index); &#125; while(!q.empty()) &#123; int front = q.front(); q.pop(); AdjL[front].push_back(index); &#125; &#125; &#125; toposort(); return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_10-æŽ’åºï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F09%2F05%2FZJU-DS-10-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨ç»§ç»­ä»‹ç»æŽ’åºç®—æ³•ã€‚ å¿«é€ŸæŽ’åºå¿«é€ŸæŽ’åºä¸Žå½’å¹¶æŽ’åºçš„ç­–ç•¥æœ‰äº›ç±»ä¼¼ï¼ŒåŸºæœ¬æ€æƒ³ä¹Ÿæ˜¯åˆ†æ²»æ³•ï¼Œé¦–å…ˆä»Žå¾…æŽ’åºåˆ—ä¸­æ‰¾ä¸€ä¸ªä¸»å…ƒï¼Œæ ¹æ®è¿™ä¸ªä¸»å…ƒå°†å¾…æŽ’åºåˆ—çš„æ‰€æœ‰å…ƒç´ åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ¯”å®ƒå°ï¼Œå¦ä¸€éƒ¨åˆ†æ¯”å®ƒå¤§ï¼Œç„¶åŽå¯¹ä¸¤ä¸ªå­éƒ¨åˆ†åœ¨è¿›è¡Œåˆ’åˆ†å’ŒæŽ’åºï¼Œä¾æ¬¡é‡å¤æ“ä½œï¼Œæœ€åŽå†å°†è¿™äº›åˆå¹¶ä¸ºä¸€ä¸ªåºåˆ—ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678void Quick_Sort(ElementType A[], int N) &#123; if(N &lt; 2) return; pivot = ä»ŽA[]ä¸­é€‰ä¸€ä¸ªä¸»å…ƒ; å°†S = &#123;A[] / pivot&#125; åˆ†æˆ2ä¸ªç‹¬ç«‹å­é›†; A1 = &#123;a âˆˆ S | A &lt;= pivot&#125;; A2 = &#123;a âˆˆ S | A &gt;= pivot&#125;; A[] = Quick_Sort(A1, N1)âˆª(pivot)âˆªQuick_Sort(A2, N2);&#125; æŒ‰ç…§ä¸Šè¿°çš„ä¼ªç æè¿°ï¼Œå¿«æŽ’éœ€è¦è§£å†³çš„é—®é¢˜æœ‰ä¸¤ä¸ªï¼š 1. å¦‚ä½•åŽ»é€‰ä¸»å…ƒ2. å¦‚ä½•è¿›è¡Œå­é›†åˆ’åˆ† å¾ˆæ˜Žæ˜¾ï¼ŒæŒ‰ç…§æ€è·¯ï¼Œèƒ½æŠŠç¬¬ä¸€ä¸ªé—®é¢˜è§£å†³äº†ï¼Œç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿå°±è¿Žåˆƒè€Œè§£äº†ã€‚ é€‰ä¸»å…ƒé‚£ä¹ˆä¸»å…ƒåº”è¯¥æ€Žä¹ˆåŽ»é€‰æ‹©å‘¢ï¼Ÿæ¯”è¾ƒç»å…¸çš„æ–¹æ³•å°±æ˜¯å–å¤´ã€ä¸­ã€å°¾ä¸‰ä¸ªæ•°ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥äº”ä¸ªæ•°ï¼‰çš„ä¸­ä½æ•°ï¼ˆä»¥åºåˆ—{8, 12, 3}ä¸ºä¾‹ï¼Œå®ƒçš„ä¸­ä½æ•°æ˜¯8ï¼‰ï¼Œé€‰ä¸»å…ƒæ—¶ï¼Œå¯ä»¥é¡ºä¾¿å°†å¾…é€‰çš„ä¸‰ä½æ•°è¿›è¡ŒæŽ’åºï¼Œè¿™æ ·å½“é€‰å‡ºä¸»å…ƒåŽï¼Œä¹Ÿå¯ä»¥å¾…æŽ’åºåˆ—æ•°æ®çš„æ€»ä¸ªæ•°å‡å°‘ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112ElementType Median3(ElementType A[], int Left, int Right)&#123; int Center = (Left + Right)/2; if(A[Left] &lt; A[Center]) Swap(&amp;A[Left], &amp;A[Center]); if(A[Left] &lt; A[Right]) Swap(&amp;A[Left], &amp;A[Right]); if(A[Center] &lt; A[Right]) Swap(&amp;A[Center], &amp;A[Right]); /*after finish swap, A[Left] &lt;= A[Center] &lt;= A[Right]*/ /*put the pivot to A[Right-1], then only consider the sequence from A[Left+1] to A[Right-2]*/ Swap(&amp;A[Center], &amp;A[Right-1]); return A[Right-1];&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œå› ä¸ºæœ€åŽå°†pivotæ”¾åˆ°äº†Right-1ä½ç½®ï¼Œæ‰€ä»¥ï¼Œå¦å¤–ä¸¤ä¸ªå…ƒç´ çš„ä½ç½®å°±å¯ä»¥ä¸ç”¨åœ¨è€ƒè™‘äº†ï¼Œåªè€ƒè™‘åŒºé—´$[Left+1, Right-1]$å†…çš„å…ƒç´ å³å¯ã€‚ å­é›†åˆ’åˆ†å­é›†åˆ’åˆ†æ—¶ï¼Œéœ€è¦ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªé¦–ï¼Œä¸€ä¸ªå°¾ï¼Œå½“å°¾æŒ‡é’ˆå°äºŽé¦–æŒ‡é’ˆï¼ˆä¸¤è€…å·²äº¤å‰ï¼‰æ—¶ï¼Œè¯´æ˜Žå­é›†çš„åˆ’åˆ†å·²å®Œæˆã€‚åœ¨è¿›è¡Œè¿™ä¸ªæ“ä½œæ—¶ï¼Œä¼šå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯é‡åˆ°ç›¸ç­‰çš„å…ƒç´ æ€Žä¹ˆåŠžï¼Ÿä»¥æœ€åçš„æƒ…å†µï¼ˆåºåˆ—å…ƒç´ å…¨éƒ¨ç›¸ç­‰ï¼‰ä¸ºä¾‹ï¼Œå¦‚æžœé‡‡å–ç›´æŽ¥äº¤æ¢å…ƒç´ çš„æ–¹æ³•ï¼Œé‚£ä¹ˆé¦–ã€å°¾æŒ‡é’ˆçš„æ¯ä¸€æ¬¡å˜åŒ–ï¼Œéƒ½éœ€è¦äº¤æ¢ä¸€æ¬¡å…ƒç´ ï¼Œç»“æŸåŽï¼Œä¸»å…ƒpivotä¼šè¢«æ”¾åœ¨ä¸­é—´çš„ä½ç½®ï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡å¾ªçŽ¯çš„æ—¶å€™å°±ä¼šå°†å‰©ä¸‹çš„åºåˆ—åœ¨ç­‰åˆ†æˆä¸¤ä¸ªåºåˆ—ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±æ˜¯$O(NlogN)$äº†ï¼›é‚£å¦‚æžœè·³è¿‡ç›¸ç­‰çš„å…ƒç´ å‘¢ï¼Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œä¼šæœ‰ä¸€ç«¯çš„æŒ‡é’ˆåœæ»žä¸å‰ï¼Œé‚£ä¹ˆæ¯æ¬¡å°±åªæœ‰ä¸€ä¸ªæŒ‡é’ˆåœ¨ç§»åŠ¨ï¼Œè¿™æ ·æ¯æ¬¡å¾—åˆ°çš„å­åºåˆ—å°±$N, N-1, N-2, \dots, 1$äº†ï¼Œé‚£æ ·æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯$O(N^2)$ï¼Œæ‰€ä»¥è¿˜æ˜¯é‡‡å–äº¤æ¢å…ƒç´ çš„æ–¹æ³•ã€‚å¦å¤–ï¼Œå¦‚æžœæ•°æ®è§„æ¨¡è¾ƒå°çš„è¯ï¼Œï¼Œç‰¹åˆ«æ˜¯æ•°æ®æ€»æ•°è¿ž100éƒ½ä¸åˆ°çš„æ—¶å€™ï¼Œå¯¹äºŽä¾ç„¶ä½¿ç”¨é€’å½’çš„å¿«é€ŸæŽ’åºè€Œè¨€ï¼Œå°±ä¸æ˜¯é‚£ä¹ˆåˆ’ç®—äº†ï¼Œæ‰€ä»¥éœ€è¦åšä¸ªåˆ¤æ–­ï¼Œåœ¨æ•°æ®è§„æ¨¡è¾ƒå°çš„æ—¶å€™ï¼Œé‡‡å–å…¶ä»–çš„æŽ’åºæ–¹å¼ã€‚ ç®—æ³•å®žçŽ°é€‰å¥½ä¸»å…ƒï¼Œæ˜Žç¡®å­é›†çš„åˆ’åˆ†æ–¹æ³•ï¼Œå°±å¯ä»¥æ¥æž„é€ ç®—æ³•äº†ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void QuickSort(ElementType A[], int Left, int Right)&#123; if(Cutoff &lt;= Right-Left)&#123; Pivot = Median3(A, Left, Right); i = Left; j = Right - 1; for(; ; ) &#123; while(A[++i] &lt; pivot); while(A[--j] &gt; pivot); if(i &lt; j) Swap(&amp;A[i], &amp;A[j]); else break; &#125; Swap(&amp;A[i], &amp;A[Right-1]); QuickSort(A, Left, i-1); QuickSort(A, i+1, Right); &#125;else Insertion_Sort(A+Left, Right-Left+1);&#125; ä¸Šè¿°ä»£ç çš„æ€è·¯æ¯”è¾ƒç›´è§‚ï¼Œå…ˆé€‰å¥½ä¸»å…ƒï¼Œåœ¨è¿›è¡Œå­é›†åˆ’åˆ†ï¼Œç„¶åŽå°†ä¸»å…ƒæ”¾åˆ°é è¿‘ä¸­é—´çš„ä½ç½®ï¼Œæ­¤æ—¶ä¸»å…ƒçš„ä½ç½®ä¸Žæœ€ç»ˆç»“æžœåºåˆ—çš„ä½ç½®æ˜¯ä¸€è‡´çš„ï¼Œè¿™ç‚¹ä¸Žå†’æ³¡æŽ’åºä¸€æ ·ï¼Œæ¯æ¬¡éƒ½ä¼šæœ‰ä¸€ä¸ªå…ƒç´ è¢«æŽ’åˆ°æœ€ç»ˆä½ç½®ã€‚å½“å¾…æŽ’å…ƒç´ å°äºŽé˜ˆå€¼Cutoffæ—¶ï¼Œç›´æŽ¥ä½¿ç”¨æ’å…¥æŽ’åºè§£å†³å‰©ä¸‹çš„å…ƒç´ åºåˆ—ã€‚ è¡¨æŽ’åºè¡¨æŽ’åºé€‚ç”¨äºŽå¾…æŽ’å…ƒç´ ä¸æ˜¯ç®€å•çš„æ•´æ•°ï¼Œè€Œæ˜¯å¤æ‚ã€åºžå¤§çš„å…ƒç´ çš„æ—¶å€™ï¼Œå› ä¸ºè¿™äº›å¤æ‚ã€åºžå¤§çš„å…ƒç´ çš„äº¤æ¢å’Œç§»åŠ¨ä¼šååˆ†è´¹æ—¶ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¡¨æŽ’åºåœ¨æŽ’åºè¿‡ç¨‹ä¸­ä¸éœ€è¦ç§»åŠ¨å…ƒç´ ï¼Œåªéœ€è¦ç§»åŠ¨æŒ‡é’ˆå³å¯ï¼Œè¿™ç§ä¸ç§»åŠ¨å…ƒç´ ï¼Œåªç§»åŠ¨æŒ‡é’ˆçš„æŽ’åºæ–¹æ³•ç§°ä¸ºé—´æŽ¥æŽ’åºã€‚å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ä½œä¸ºâ€œè¡¨â€ï¼ˆtableï¼‰ï¼Œè¡¨æŽ’åºç®—æ³•çš„æ“ä½œå¯¹è±¡å°±æ˜¯è¿™ä¸ªâ€œè¡¨â€äº†ã€‚ ç‰©ç†æŽ’åºå‡è‹¥ä»ç„¶éœ€è¦ç§»åŠ¨å®žé™…çš„å…ƒç´ æ¥å®ŒæˆæŽ’åºï¼Œé‚£ä¹ˆå¯ä»¥æ ¹æ®ä¸‹é¢è¿™ä¸ªç»“è®ºåœ¨çº¿æ€§çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸ªæ“ä½œã€‚ å®šç†ï¼šNä¸ªæ•°å­—çš„æŽ’åˆ—ç”±è‹¥å¹²ä¸ªç‹¬ç«‹çš„çŽ¯ç»„æˆã€‚ è¿™é‡Œçš„â€œçŽ¯â€ï¼Œå…¶å®žæ˜¯ä¸€ä¸ªæ¯”è¾ƒæŠ½è±¡çš„æ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯ç»è¿‡è¡¨æŽ’åºåŽç­‰åˆ°çš„tableå†…ï¼Œæœ‰äº›å…ƒç´ çš„é¡ºåºä¼šå½¢æˆä¸€ä¸ªåºåˆ—ï¼Œè€Œè¿™ä¸ªåºåˆ—å°±ç§°ä½œâ€œçŽ¯â€ã€‚ä¸‹é¢æ¥çœ‹ä¸ªä¾‹å­ï¼Œè¡¨æŽ’åºå‰ï¼š A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 è¡¨æŽ’åºåŽï¼š A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 ä¸Šè¡¨ä¸­ï¼Œç”±{3, 5, 1, 0}è¿™ä¸ªä¸‹æ ‡åºåˆ—å¯å¾—å¯¹åº”çš„æœ‰åºåºåˆ—ä¸º{a, b, d, f}ï¼Œè¿™ä¸ªåºåˆ—æ˜¯æœ‰åºçš„ï¼Œå…¶å¯¹åº”å…³ç³»å¦‚ä¸‹è¡¨ï¼š A [0] [1] [3] [5] table 3 5 1 0 ç”±ä¸Šè¡¨ä¸­æž„æˆçš„å…³ç³»ï¼Œå°±æ˜¯â€œçŽ¯â€ï¼Œå¯ä»¥æ ¹æ®â€œçŽ¯â€å¾—åˆ°æœ‰åºçš„åºåˆ—ã€‚ç´§æŽ¥ç€ï¼Œæ ¹æ®è¿™äº›æœ‰åºçš„åºåˆ—ï¼Œå€ŸåŠ©ä¸€ä¸ªä¸´æ—¶ç©ºé—´ï¼ŒéåŽ†ä¸€æ¬¡è¿™ä¸ªæœ‰åºåºåˆ—ï¼Œå°±å¯ä»¥å®Œæˆç‰©ç†åºåˆ—çš„æŽ’åºã€‚å¾ˆæ˜Žæ˜¾å¯ä»¥å¾—åˆ°ï¼Œå½“table[i] == iæ—¶ï¼ŒçŽ¯å°±ç»“æŸäº†ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æžå½“åˆå§‹åºåˆ—ä¸ºæœ‰åºæ—¶ï¼Œæ˜¯æœ€å¥½çš„æƒ…å†µï¼›å½“æœ‰$\lfloor N/2 \rfloor$ä¸ªçŽ¯æ—¶ï¼Œæ¯ä¸ªçŽ¯åŒ…å«2ä¸ªå…ƒç´ ï¼Œäº¤æ¢ä¸¤ä¸ªå…ƒç´ éœ€è¦ä¸‰æ­¥æ“ä½œï¼Œå°±éœ€è¦$\lfloor 3N/2 \rfloor$æ¬¡å…ƒç´ ç§»åŠ¨ï¼Œè€Œè¡¨æŽ’åºé’ˆå¯¹çš„å°±æ˜¯å…ƒç´ ç§»åŠ¨æ—¶é—´è¾ƒé•¿çš„å­˜å‚¨ç»“æž„ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T = O(m\ N)$ï¼Œ$m$ä¸ºæ¯ä¸ªå…ƒç´ çš„å¤åˆ¶æ—¶é—´ã€‚ åŸºæ•°æŽ’åºåŸºæ•°æŽ’åºä¸Žå…¶ä»–æŽ’åºç®—æ³•æœ‰ä¸€ä¸ªå¾ˆå¤§çš„å·®åˆ«ï¼Œé‚£å°±æ˜¯ä¸ä»…åªæ˜¯æ¯”å¤§å°äº†ï¼Œå› ä¸ºå•çº¯é æ¯”è¾ƒå¤§å°çš„æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æœ€ä½Žåªèƒ½æ˜¯$T(NlogN)$è¿™ä¸ªçº§åˆ«ï¼Œæ‰€ä»¥å¾—åœ¨æ·»ç‚¹â€œæ–™â€æ¥ç»§ç»­æå‡é€Ÿåº¦ï¼Œä¸‹é¢å…ˆæ¥çœ‹çœ‹æ¡¶æŽ’åºã€‚ æ¡¶æŽ’åºå¯¹äºŽæ¡¶æŽ’åºè€Œè¨€ï¼Œå‡è®¾å¾…æŽ’åºåˆ—æœ‰$N$ä¸ªå…ƒç´ ï¼Œå…ˆç”³è¯·$N$ä¸ªæ¡¶ï¼ˆæœ‰åºï¼Œæ¡¶å†…ä¿å­˜æŒ‡é’ˆï¼‰ï¼Œç„¶åŽå°†æ¯ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œæ’åˆ°è¿™ä¸ªæœ‰åºçš„æ¡¶æŽ’åˆ—ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥äº†ï¼Œå¤§è‡´ä»£ç å¦‚ä¸‹ï¼š1234567891011void Bucket_Sort(ElementType A[], int N) &#123; count[]åˆå§‹åŒ–; while(è¯»å…¥ä¸€ä¸ªæ•°æ®) &#123; å°†è¯¥æ•°æ®æ’å…¥count[æ¡¶å†…ä¿å­˜çš„æŒ‡é’ˆ++]; &#125; for(i=0; i&lt;M; i++) &#123; if(count[i])&#123; è¾“å‡ºcount[i]æ•´ä¸ªé“¾è¡¨; &#125; &#125;&#125; æŒ‰ç…§ä¸Šè¿°çš„ä¼ªç ï¼Œæœ‰$N$ä¸ªæ•°æ®éœ€è¦è¯»å…¥ï¼Œ$M$ä¸ªæ•°æ®éœ€è¦è¾“å‡ºï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T(N, M) = O(M + N)$ã€‚ä½†æ˜¯å½“$M &gt;&gt; N$çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨æ¡¶æŽ’åºå°±ä¸æ˜¯é‚£ä¹ˆåˆ’ç®—äº†ï¼Œè¿™å°±éœ€è¦ä½¿ç”¨åŸºæ•°æŽ’åºäº†ã€‚ æ¡¶æŽ’åºåŸºæœ¬æ€æƒ³äº†è§£äº†æ¡¶æŽ’åºä¹‹åŽï¼ŒåŸºæ•°æŽ’åºå°±å¥½ç†è§£äº†ï¼ŒåŸºæ•°æŽ’åºå»ºæ¡¶è§„åˆ™æ˜¯æŒ‰ç…§ç»™å®šæ•°æ®çš„è¿›åˆ¶æ•°å»ºæ¡¶ï¼Œä¾‹å¦‚{78, 123, 44, 678}ï¼Œ è¿™ä¸ªåºåˆ—çš„æ•°éƒ½æ˜¯åè¿›åˆ¶çš„ï¼Œæ‰€ä»¥åŸºæ•°ï¼ˆæ¡¶çš„å¤§å°ï¼‰ä¸º 10ã€‚ åŸºæ•°æŽ’åºç®—æ³•çš„ä¸»ä½“æ€æƒ³é‡‡ç”¨çš„æ˜¯æ¬¡ä½ä¼˜å…ˆï¼ˆLeast Significant Digitï¼‰çš„æ€æƒ³ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨ä¸»ä½ä¼˜å…ˆ(Most Significant Digit)ï¼‰ï¼Œç®€å•æ¥è®²ï¼Œç¬¬ä¸€æ¬¡æŽ’åºä»¥ä¸ªä½æ•°å¤§å°ä¸ºåŸºå‡†æ¥æŽ’åºï¼Œç¬¬äºŒæ¬¡æŽ’åºä»¥åä½æ•°å¤§å°ä¸ºåŸºå‡†æ¥æŽ’åºï¼Œä½†éœ€è¦å°†ç¬¬ä¸€æ¬¡æŽ’åºä¸­çš„é«˜ä½æ•°æ‹¿å‡ºæ¥ï¼Œé‡å¤è‡³æœ€é«˜ä½æŽ’å®ŒåŽç»“æŸã€‚æ¯èººæŽ’åºè¿‡ç¨‹ä¸­ï¼Œéœ€è¦è®¿é—®$N$ä¸ªç»“ç‚¹ï¼Œä¹Ÿéœ€è¦è®¿é—®$B$ä¸ªæ¡¶ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T=O(P(N+B))$ã€‚ å¤šå…³é”®å­—æŽ’åºæ‰‘å…‹ç‰Œçš„èŠ±è‰²å°±æ˜¯ä¸€ç§â€œå¤šå…³é”®å­—æŽ’åºâ€ï¼Œä¸åŒèŠ±è‰²åŒèŠ±é¡ºä¹Ÿæœ‰å¤§å°ä¹‹åˆ†ã€‚ ä»¥ä¸ºæ‰‘å…‹ç‰ŒæŽ’åºä¸ºä¾‹ï¼Œæ‰‘å…‹ç‰Œæœ‰ä¸¤ç§å±žæ€§ï¼Œåˆ†åˆ«æ˜¯èŠ±è‰²å’Œå¤§å°ï¼Œä¸€å‰¯æ•´é½çš„æ‰‘å…‹ç‰Œï¼ŒèŠ±è‰²å’Œå¤§å°å¿…å®šéƒ½æ˜¯æ•´é½çš„ï¼Œæ ¹æ®åŸºæ•°æŽ’åºçš„æ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆæŒ‰ç…§å¤§å°æ¥åšåŸºæ•°æŽ’åºï¼Œè¿™éœ€è¦13ä¸ªæ¡¶æ¥å®Œæˆï¼ŒæŽ’å¥½åºåŽï¼Œå„ä¸ªæ¡¶ä¸­çš„ç‰Œçš„å¤§å°éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œæ­¤æ—¶æˆ‘ä»¬åœ¨ä»¥èŠ±è‰²ä¸ºåŸºæ•°å»ºæ¡¶ï¼Œä¾æ¬¡å–å‡ºèŠ±è‰²æŒ‰é¡ºåºå–å‡ºèŠ±è‰²ç›¸åŒçš„ç‰Œæ”¾åˆ°ä¸åŒèŠ±è‰²çš„æ¡¶å†…å³å¯ï¼Œå·²ç»ä¸éœ€è¦æ ¹æ®å¤§å°æŽ’åºäº†ã€‚ æŽ’åºç®—æ³•çš„æ¯”è¾ƒ æŽ’åºæ–¹æ³• å¹³å‡æ—¶é—´å¤æ‚åº¦ æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ é¢å¤–ç©ºé—´å¤æ‚åº¦ ç¨³å®šæ€§ ç®€å•é€‰æ‹©æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ä¸ç¨³å®š å†’æ³¡æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ç¨³å®š ç›´æŽ¥æ’å…¥æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ç¨³å®š å¸Œå°”æŽ’åº $O(N^d)$ $O(N^2)$ $O(1)$ ä¸ç¨³å®š å †æŽ’åº $O(NlogN)$ $O(NlogN)$ $O(1)$ ä¸ç¨³å®š å¿«é€ŸæŽ’åº $O(NlogN)$ $O(N^2)$ $O(logN)$ ä¸ç¨³å®š å½’å¹¶æŽ’åº $O(NlogN)$ $O(NlogN)$ $O(N)$ ç¨³å®š åŸºæ•°æŽ’åº $O(P(N+B))$ $O(P(N+B))$ $O(N+B)$ ç¨³å®š å°½ç®¡ä¸Šè¡¨ä¸­ç»™å‡ºäº†å„æŽ’åºç®—æ³•çš„å…·ä½“çš„æ—¶é—´å¤æ‚åº¦ï¼Œä½†æ˜¯å®žé™…åº”ç”¨æ—¶è¿˜æ˜¯éœ€è¦æ ¹æ®å®žé™…æƒ…å†µæ¥é€‰æ‹©åˆé€‚çš„æŽ’åºç®—æ³•ã€‚å¦å¤–ï¼Œä»Žè¡¨ä¸­çœ‹åˆ°å †æŽ’åºçš„æ€§èƒ½æ¯”è¾ƒå¥½ï¼Œä½†æ˜¯å®žé™…æ•ˆæžœä¸å¤ªç†æƒ³ã€‚é™¤äº†è¿™äº›åŸºç¡€æŽ’åºç®—æ³•å¤–ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æŽ’åºç®—æ³•ï¼Œé‚£äº›ä¹Ÿå€¼å¾—è¿›ä¸€æ­¥å­¦ä¹ ã€‚ Homework10-4 ç»Ÿè®¡å·¥é¾„è¿™ä¸ªé¢˜ç›®å¾ˆç®€å•ï¼Œå€ŸåŠ©ä¸€ä¸‹å§¥å§¥è¯¾ä¸Šè®²çš„æ¡¶æŽ’åºçš„æ€æƒ³å³å¯ï¼ŒC++ è¯­æ³•çš„ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;int main() &#123; int n; std::cin &gt;&gt; n; int staff[55] = &#123; 0 &#125;, tmp; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; tmp; staff[tmp]++; &#125; for (int i = 0; i &lt; 52; i++) &#123; if (staff[i]) std::cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; staff[i] &lt;&lt; std::endl; &#125; return 0;&#125;/*samples:in:810 2 0 5 7 2 5 2out:0:12:35:27:110:1in:1010 2 0 0 0 5 7 2 5 2out:0:32:35:27:110:1*/ 10-5 PAT Judgeè¿™é“é¢˜ç›®çš„å‡ºé¢˜èƒŒæ™¯åº”è¯¥å°±æ˜¯ PAT çš„æŽ’åç³»ç»Ÿäº†ï¼Œä½†å…¶å®žæ˜¯ç”²çº§é¢˜åº“çš„ä¸€é“æŽ’åºé¢˜ï¼Œéœ€è¦æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚æ¥è¿›è¡ŒæŽ’åºï¼Œç›´æŽ¥ä½¿ç”¨ C++ çš„åº“å‡½æ•°ä¼šæ–¹ä¾¿è®¸å¤šã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10000 + 5;struct user&#123; int id, scores[6], sum, perfect; bool flag;&#125; us[maxn];int n, k, m, p[6] = &#123;0&#125;;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void init() &#123; for(int i = 1; i &lt;= n; i++) &#123; us[i].id = i; us[i].sum = us[i].perfect = 0; us[i].flag = false; memset(us[i].scores, -1, sizeof(us[i].scores)); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", p + i); &#125; int id, proid, scoob; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;proid, &amp;scoob); if(scoob != -1) us[id].flag = true; if(scoob == -1 &amp;&amp; us[id].scores[proid] == -1) us[id].scores[proid] = 0; if(scoob == p[proid] &amp;&amp; us[id].scores[proid] &lt; p[proid]) us[id].perfect++; if(scoob &gt; us[id].scores[proid]) us[id].scores[proid] = scoob; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] &gt; 0) us[i].sum += us[i].scores[j]; &#125; &#125; sort(us + 1, us + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; us[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) rank = i; printf("%d %05d %d", rank, us[i].id, us[i].sum); for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] == -1) printf(" -"); else printf(" %d", us[i].scores[j]); &#125; putchar('\n'); &#125; return 0;&#125; /*samples:in:7 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0out:1 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 -in:3 4 920 25 25 3000001 3 3000002 3 3000003 3 3000001 3 3000002 3 2000003 3 2000001 3 3000002 3 1000003 3 30out:1 00001 30 - - 30 -1 00002 30 - - 30 -1 00003 30 - - 30 -in:2 2 620 2000001 1 -100002 1 -100001 1 -100002 1 -100001 1 -100002 1 0out:(blank)*/ 10-6 Sort with Swap(0, i)è¿™ä¸ªé¢˜ä¸å¤ªå¥½æƒ³ï¼Œä½†æ˜¯ä¸Žè¡¨æŽ’åºéžå¸¸ç±»ä¼¼ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int pos[maxn], n, ans = 0;int main() &#123; cin &gt;&gt; n; int remains = n - 1, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; pos[tmp] = i; if(tmp == i &amp;&amp; tmp != 0) remains--; &#125; int k = 1; while(remains &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; remains--; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;/*samples:in:103 5 7 2 6 4 9 0 8 1outÂ£Âº9in:54 0 2 1 3out:3in:30 2 1out:2in:54 3 2 1 0out:4*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_09_æŽ’åºï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F09%2F02%2FZJU-DS-09-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨å°†ä¼šä»‹ç»å‡ ç§å¸¸è§çš„æŽ’åºç®—æ³•ã€‚ ç®€å•æŽ’åºç®€å•æŽ’åºæ˜¯å‡ ä¸ªç®€å•çš„æŽ’åºç®—æ³•çš„ç»Ÿç§°ï¼Œä¸‹é¢æ¥ä¸€ä¸€ä»‹ç»ã€‚ å†’æ³¡æŽ’åºå†’æ³¡æŽ’åºçš„æ€æƒ³æ¯”è¾ƒç›´è§‚ï¼Œæ¯æ¬¡å¾ªçŽ¯æ—¶ï¼Œä¼šå°†æ•°ç»„ï¼ˆæˆ–é“¾è¡¨ï¼‰å†…ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼ŒæŒ‰ç…§è§„å®šçš„é€’å¢žï¼ˆæˆ–é€’å‡ï¼‰é¡ºåºå‘åŽç§»åŠ¨ï¼Œä¸€ç›´åˆ°é‡å¤åˆ°æœ«å°¾ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); &#125; &#125; &#125;&#125; ä»£ç æ¡†æž¶ååˆ†ç®€å•ï¼Œä½†æ˜¯è¿™æ ·ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å¾…æŽ’åºåˆ—åœ¨å·²ç»æœ‰åºçš„æƒ…å†µä¸‹ï¼Œä¾ç„¶ä¼šè¿›è¡Œä¸¤æ¬¡å¾ªçŽ¯ï¼Œå°½ç®¡ä¸ä¼šäº¤æ¢ç›¸é‚»å…ƒç´ çš„å€¼ï¼Œä½†æ˜¯è¿˜æ˜¯ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¼šç™½ç™½æµªè´¹æ—¶é—´ã€‚ä»”ç»†æƒ³ä¸€ä¸‹ï¼Œå¦‚æžœè¾“å…¥åºåˆ—æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆå…ƒç´ çš„å€¼ä¸€æ¬¡ä¹Ÿä¸ä¼šäº¤æ¢ï¼Œæ ¹æ®è¿™ä¸ªç‰¹ç‚¹ï¼Œå¯ä»¥å¯¹ä¸Šè¿°çš„ä»£ç è¿›è¡Œä¸€ç‚¹å°ä¼˜åŒ–ï¼Œæ·»åŠ ä¸€ä¸ªæ ‡å¿—ä½ï¼Œä¸€æ¬¡æœ‰åºåŽå°±å¯ä»¥ç›´æŽ¥è·³å‡ºå¾ªçŽ¯äº†ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; flag = 0; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); flag = 1; &#125; &#125; if(!flag) break; &#125;&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç çš„æ€è·¯ï¼Œå¯ä»¥è¾ƒä¸ºæ¸…æ™°çš„åˆ†æžå‡ºå†’æ³¡æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š æœ€å¥½çš„æƒ…å†µï¼Œåºåˆ—ä¸ºé¡ºåºåºåˆ—ï¼Œ$T = O(N)$ æœ€åçš„æƒ…å†µï¼Œåºåˆ—ä¸ºé€†åºåºåˆ—ï¼Œ$T = O(N^2)$ å¦å¤–ï¼Œå¯¹äºŽå†’æ³¡æŽ’åºè€Œè¨€ï¼Œæ¯ä¸€æ¬¡å†’æ³¡ç»“æŸï¼ˆå†…å±‚å¾ªçŽ¯ç»“æŸä¸€è½®ï¼‰åŽéƒ½ä¼šæœ‰ä¸€ä¸ªå…ƒç´ è¢«æ”¾åˆ°è¿™ä¸ªåºåˆ—æœ‰åºåŽçš„æœ€ç»ˆä½ç½®ä¸Šï¼Œè€Œä¸”ï¼Œå†’æ³¡æŽ’åºä¹Ÿä¸ä¼šäº¤æ¢ç›¸åŒå…ƒç´ çš„ä½ç½®ï¼ˆä½¿ç”¨$&gt;$è€Œä¸æ˜¯$\geq$ï¼‰ï¼Œæ‰€ä»¥å†’æ³¡æŽ’åºæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œå†è€…ï¼Œå†’æ³¡æŽ’åºè¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œå³æŽ’åºçš„æ–¹å‘æ˜¯ä¸€å®šçš„ï¼Œåªä¼šæŒ‰ç…§ä¸€ä¸ªæ–¹å‘éåŽ†å­˜å‚¨æ•°æ®çš„æ•°æ®ç»“æž„ï¼Œè¿™æ˜¯å…¶ä»–æŽ’åºç®—æ³•æ— æ³•è¾¾åˆ°çš„ã€‚ æ’å…¥æŽ’åºæ’å…¥æŽ’åºæœ‰ä¸ªå¾ˆå½¢è±¡çš„ä¾‹å­ï¼Œå°±æ˜¯æ‰“æ‰‘å…‹ç‰Œæ—¶â€œç†ç‰Œâ€çš„è¿‡ç¨‹ï¼Œä¸è¿‡å¯èƒ½æœ‰ç‚¹å·®åˆ«ã€‚åŒºåˆ«åœ¨äºŽï¼Œç†æ‰‘å…‹ç‰Œæ—¶ï¼Œæ‰‹ä¸Šæ˜¯æ²¡æœ‰ç‰Œçš„ï¼Œè€Œéœ€è¦ç†çš„ç‰Œåœ¨ç‰Œå †é‡Œé¢ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸¤ä¸ªç©ºé—´å¯ä»¥æ”¾ç‰Œï¼Œä½†æ’å…¥æŽ’åºå®žé™…ä¸Šåªä½¿ç”¨äº†ä¸€ä¸ªå†…å­˜ç©ºé—´ï¼Œè¿™æ ·çš„è¯ï¼Œæ¯ä¸€æ¬¡æ’å…¥æ—¶å°±éœ€è¦å…ˆæ‰¾åˆ°æ’å…¥çš„ä½ç½®äº†ã€‚æŒ‰ç…§â€œç†ç‰Œâ€çš„è¿‡ç¨‹æ¥æè¿°å°±æ˜¯ï¼šå…ˆæ‘¸ä¸€å¼ ç‰Œï¼Œä»ŽåŽå¾€å‰æ‰¾åˆ°åˆé€‚çš„æ’å…¥ä½ç½®ï¼Œå°†æ¯”è¿™å¼ ç‰Œå¤§çš„ç‰Œå‘åŽç§»ï¼ˆè…¾å‡ºä½ç½®ï¼‰ï¼Œå†å°†æ–°ç‰Œæ’å…¥åˆ°è¿™ä¸ªä½ç½®ä¸‹å³å¯ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Insertion_Sort(ElementType A[], int N) &#123; for(P=1; P&lt;N; p++) &#123; temp = A[P]; for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;temp; i--) &#123; A[i] = A[i-1]; &#125; A[i] = temp; &#125;&#125; æ’å…¥æŽ’åºå’Œå†’æ³¡æŽ’åºçš„æ—¶é—´å¤æ‚åº¦ç±»ä¼¼ï¼š æœ€å¥½çš„æƒ…å†µï¼Œåºåˆ—ä¸ºé¡ºåºåºåˆ—ï¼Œ$T = O(N)$ æœ€åçš„æƒ…å†µï¼Œåºåˆ—ä¸ºé€†åºåºåˆ—ï¼Œ$T = O(N^2)$ åŒæ—¶ï¼Œæ’å…¥æŽ’åºä¹Ÿæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ã€‚ æ—¶é—´å¤æ‚åº¦ä¸‹ç•Œ å¯¹äºŽä¸‹æ ‡$i &lt; j$ï¼Œå¦‚æžœ$A[i] &gt; A[j]$ï¼Œåˆ™ç§°$(i, j)$æ˜¯ä¸€å¯¹é€†åºå¯¹ï¼ˆInversionï¼‰å¦‚åºåˆ—${2, 3, 1}$ä¸­ï¼Œ$(2, 1)$å’Œ$(3, 1)$åˆ†åˆ«æ˜¯ä¸€å¯¹é€†åºå¯¹ï¼Œé€†åºå¯¹çš„ä¸ªæ•°ç§°ä¸ºé€†åºæ•°ï¼Œè¿™ä¸Žçº¿æ€§ä»£æ•°ä¸­çš„æ¦‚å¿µæ˜¯ä¸€è‡´çš„ã€‚ åœ¨å†’æ³¡æŽ’åºå’Œæ’å…¥æŽ’åºä¸­ï¼Œæ¯æ¬¡äº¤æ¢ä½ç½®çš„ä¸¤ä¸ªç›¸é‚»å…ƒç´ æ­£å¥½æ¶ˆåŽ» 1 ä¸ªé€†åºå¯¹ï¼Œé‚£ä¹ˆå®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ï¼š$T(N, I) = O(N+I)$ï¼Œå…¶ä¸­$I$æ˜¯é€†åºå¯¹çš„å¯¹æ•°ã€‚å¾ˆæ˜Žæ˜¾ï¼Œå¦‚æžœåºåˆ—åŸºæœ¬æœ‰åºï¼Œåˆ™$I$å€¼å¯å¿½ç•¥ä¸è®¡ï¼Œæ—¶é—´å¤æ‚åº¦ä»…ä¸º$T(N)$ï¼Œæ­¤æ—¶ç®—æ³•æ—¢ç®€å•ï¼Œåˆé«˜æ•ˆã€‚ å®šç†ï¼šå¯¹äºŽä»»æ„Nä¸ªä¸åŒå…ƒç´ ç»„æˆçš„åºåˆ—å¹³å‡å…·æœ‰$N(N-1)/4$ä¸ªé€†åºå¯¹ã€‚ ç”±ä¸Šé¢çš„å®šç†ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼šä»»ä½•ä»…ä»¥äº¤æ¢ç›¸é‚»ä¸¤å…ƒç´ æ¥æŽ’åºçš„ç®—æ³•ï¼Œå…¶å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$\Omega(N^2)$ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æžœæƒ³è¦æé«˜ç®—æ³•çš„æ•ˆçŽ‡ï¼Œå°±å¾—åœ¨æ¯æ¬¡äº¤æ¢å…ƒç´ æ—¶ï¼Œä¸æ­¢æ¶ˆåŽ» 1 ä¸ªé€†åºå¯¹ï¼Œè¿™å°±è¦æ±‚æ¯æ¬¡äº¤æ¢çš„ä¸¤ä¸ªå…ƒç´ è¦åœ¨åºåˆ—ä¸­ç›¸éš”çš„æ¯”è¾ƒè¿œã€‚ å¸Œå°”æŽ’åºå¸Œå°”æŽ’åºçš„ä¸»è¦ç›®çš„å°±æ˜¯æ¯æ¬¡äº¤æ¢å…ƒç´ æ—¶ï¼Œé€šè¿‡æ¶ˆåŽ»å¤šä¸ªé€†åºå¯¹æ¥è¾¾åˆ°æå‡ç®—æ³•æ•ˆçŽ‡ã€‚å…¶ä¸»è¦æ€æƒ³ï¼šå…ˆå®šä¹‰å¢žé‡åºåˆ—$D_M &gt; D_{M-1} &gt; \dots &gt; D_1 = 1$ï¼Œç„¶åŽå¯¹æ¯ä¸ª$D_k$è¿›è¡Œâ€œ$D_k$-é—´éš”â€æŽ’åºï¼ˆ$k=M, M-1, \dots,1$ï¼‰ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒåŽé¢è¿›è¡Œçš„â€œé—´éš”â€æŽ’åºä¸ä¼šå½±å“å‰é¢â€œé—´éš”â€æŽ’åºçš„æœ‰åºæ€§ï¼Œä¹Ÿå³â€œ$D_k$-é—´éš”â€æœ‰åºçš„åºåˆ—ï¼Œåœ¨æ‰§è¡Œâ€œ$D_{k-1}$-é—´éš”â€æŽ’åºåŽï¼Œä»ç„¶æ˜¯â€œ$D_k$-é—´éš”â€æœ‰åºçš„ã€‚åŽŸå§‹å¸Œå°”æŽ’åºï¼Œå¢žé‡ä¾æ¬¡å‡åŠï¼Œ$D_M = \lfloor N/2 \rfloor, D_k = \lfloor D{k+1}/2 \rfloor$ï¼Œæ­¤æ—¶æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¸º$T = \Theta(N^2)$ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š1234567891011void Shell_Sort(ElementType A[], int N) &#123; for(D=N/2; D&gt;0; D/=2) &#123; for(P=D; P&lt;N; P++) &#123; temp = A[P]; for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;temp; i-=D) &#123; A[i] = A[i-D]; &#125; A[i] = temp; &#125; &#125;&#125; åœ¨æœ€åçš„æƒ…å†µï¼ˆæ¯æ¬¡è¿›è¡Œé—´éš”æŽ’åºçš„åºåˆ—éƒ½æ˜¯æœ‰åºçš„ï¼‰ä¸‹ï¼Œå¸Œå°”æŽ’åºä¼šé€€åŒ–æˆæ’å…¥æŽ’åºï¼ŒåŽŸå› åœ¨äºŽå¢žé‡å…ƒç´ ä¸äº’è´¨ï¼Œåˆ™å°å¢žé‡å¯èƒ½æ ¹æœ¬ä¸èµ·ä½œç”¨ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¼•å…¥äº†æ›´å¤šçš„å¢žé‡åºåˆ—ï¼š Hibbardå¢žé‡åºåˆ—ï¼Œ$D_k = 2^k - 1$ï¼Œè¿™æ ·ä¿è¯äº†ç›¸é‚»å¢žé‡å…ƒç´ äº’è´¨ï¼Œæœ€åæƒ…å†µä¸‹$T = \Omega(N^{3/2})$ï¼ŒçŒœæƒ³$T_{avg} = O(N^{5/4})$ Sedgewickå¢žé‡åºåˆ—ï¼Œ${1, 5, 19, 41, 109, \dots}$ï¼Œä¹Ÿå³å¢žé‡åºåˆ—çš„æ¯ä¸€ä¸ªå…ƒç´ æ˜¯ç”±$9 \times 4^i + 1$æˆ–$4^i - 3 \times 2^i + 1$è®¡ç®—å¾—åˆ°ï¼ŒçŒœæƒ³$T_{avg} = O(N^{7/6}), T_{worst} = O(N^{4/3})$ ç”±äºŽå¸Œå°”æŽ’åºæ¯æ¬¡å¯¹å¢žé‡åºåˆ—è¿›è¡ŒæŽ’åºï¼Œç›¸é‚»çš„ç›¸ç­‰å…ƒç´ å±žäºŽä¸åŒå¢žé‡åºåˆ—ï¼Œåˆ™å¸Œå°”æŽ’åºå¯èƒ½ä¼šæ”¹å˜ç›¸ç­‰ä¸”ç›¸é‚»å…ƒç´ çš„ç›¸å¯¹ä½ç½®ï¼Œå±žäºŽä¸ç¨³å®šçš„æŽ’åºã€‚ é€‰æ‹©æŽ’åºé€‰æ‹©æŽ’åºæ˜¯ä¸€ç§ç®€å•ç›´è§‚çš„æŽ’åºç®—æ³•ï¼ŒåŸºæœ¬å·¥ä½œåŽŸç†æ˜¯æ¯ä¸€æ¬¡ä»Žå¾…æŽ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰å‡ºæœ€å°ï¼ˆå¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ï¼Œå­˜æ”¾åœ¨åºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œç„¶åŽï¼Œå†ä»Žå‰©ä½™æœªæŽ’åºå…ƒç´ ä¸­ç»§ç»­å¯»æ‰¾æœ€å°ï¼ˆå¤§ï¼‰å…ƒç´ ï¼Œç„¶åŽæ”¾åˆ°å·²æŽ’åºåºåˆ—çš„æœ«å°¾ï¼Œé‡å¤æ­¤è¿‡ç¨‹ç›´åˆ°å…¨éƒ¨å¾…æŽ’åºçš„æ•°æ®å…ƒç´ æŽ’å®Œã€‚ ç®€å•é€‰æ‹©æŽ’åºç®€å•é€‰æ‹©æŽ’åºçš„æ€è·¯å¾ˆç®€å•ï¼Œä¸Žé€‰æ‹©æŽ’åºçš„åŸºæœ¬æ€æƒ³ä¸€è‡´ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678void Selection_Sort(ElementType A[], int N) &#123; for(i=0; i&lt;N; i++) &#123; //find the minimum from A[i] to A[n-1], and return to Position MinPosition = ScanForMin(A, i, N-1); //replace the minimum element to the last position of the ordered part Swap(A[i], A[MinPosition]); &#125;&#125; ç®€å•é€‰æ‹©æŽ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸»è¦æœ‰ä¸¤ä¸ªå½±å“æ¡ä»¶ï¼Œç¬¬ä¸€ä¸ªæ˜¯æŸ¥æ‰¾æœ€å°å€¼ï¼Œç¬¬äºŒä¸ªæ˜¯äº¤æ¢ï¼Œæ‰€ä»¥å®ƒçš„æ—¶é—´å¤æ‚åº¦æ— è®ºæ€Žæ ·éƒ½æ˜¯$T=\Theta(N^2)$ã€‚ å †æŽ’åºåˆ†æžäº†ç®€å•é€‰æ‹©æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åŽï¼Œå‘çŽ°ç®€å•é€‰æ‹©æŽ’åºçš„æ—¶é—´éƒ½è€—è´¹åœ¨äº†æŸ¥æ‰¾æœ€å°å€¼ä¸Šï¼Œå¦‚æžœèƒ½æŠŠè¿™ä¸€æ“ä½œå˜å¿«ï¼Œé‚£ä¹ˆç®€å•é€‰æ‹©æŽ’åºçš„æ•ˆçŽ‡å°±èƒ½æé«˜ã€‚æ ¹æ®é€‰æ‹©æŽ’åºçš„ç‰¹ç‚¹ï¼Œæ¯æ¬¡æŸ¥æ‰¾çš„å€¼å¿…é¡»æ˜¯æœ€å°ï¼ˆå¤§ï¼‰å€¼ï¼Œè¿™ä¸Žå°ï¼ˆå¤§ï¼‰æ ¹å †çš„æ€§è´¨æ˜¯ä¸€è‡´çš„ï¼Œé‚£ä¹ˆä½¿ç”¨å †æ¥è¿›è¡Œå…ƒç´ çš„æŸ¥æ‰¾ï¼Œæ¯æ¬¡å¼¹å‡ºæœ€å°ï¼ˆå¤§ï¼‰å€¼ï¼Œå°±å¯ä»¥æå‡æŽ’åºæ•ˆçŽ‡ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Heap_Sort(ElementType A[], int N) &#123; BuildHeap(A); for(i=0; i&lt;N; i++) &#123; tempA[i] = DeleteMin[A]; &#125; for(i=0; i&lt;N; i++) &#123; A[i] = tempA[i]; &#125;&#125; ä¸Šè¿°ä»£ç çš„è¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼Œæ¯æ¬¡æ‰¾å‡ºæœ€å°ï¼ˆå¤§ï¼‰å…ƒç´ åŽï¼Œä¿å­˜åœ¨ä¸€ä¸ªä¸´æ—¶æ•°ç»„å†…ï¼Œç„¶åŽåœ¨å°†ä¸´æ—¶æ•°ç»„å†…çš„æŽ’åºç»“æžœå¤åˆ¶åˆ°åŽŸå§‹æ•°ç»„ä¸­ã€‚è¿™æ ·å³éœ€è¦é¢å¤–çš„ç©ºé—´ï¼ˆ$O(N)$ï¼‰åŽ»å­˜å‚¨è¿™éƒ¨åˆ†æ•°æ®ï¼Œåˆè¦é¢å¤–çš„æ—¶é—´åŽ»å¤åˆ¶å…ƒç´ ã€‚é‚£ä¹ˆå¦‚ä½•åŽ»é¿å…è¿™éƒ¨åˆ†å¼€é”€å‘¢ï¼Ÿè¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š 123456789void Heap_Sort(ElementType A[], int N) &#123; for(i=N/2; i&gt;=0; i--) &#123; PercDown(A, i, N); //Build heap &#125; for(i=N-1; i&gt;0; i--) &#123; Swap(&amp;A[0], &amp;A[i]); //delete max PercDown(A, 0, i); &#125;&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œå»ºç«‹ä¸€ä¸ªå¤§æ ¹å †ï¼ŒæŽ’åºå¼€å§‹åŽï¼Œäº¤æ¢å¤§æ ¹å †æœ€å¤§å…ƒç´ ä¸Žæœ€æœ«å°¾å…ƒç´ çš„å€¼ï¼Œå®ŒæˆåŽï¼Œå°†è¿™ä¸ªæœ€å¤§å€¼å‰”é™¤å‡ºå †ï¼Œç´§æŽ¥ç€å†è°ƒæ•´ä¸ºå¤§æ ¹å †ï¼Œé‡å¤æ‰§è¡Œä¸Šè¿°æ“ä½œã€‚ å®šç†ï¼šå †æŽ’åºå¤„ç†Nä¸ªä¸åŒå…ƒç´ çš„éšæœºæŽ’åˆ—çš„å¹³å‡æ¯”è¾ƒæ¬¡æ•°æ˜¯$2NlogN - O(N log logN)$ è™½ç„¶å †æŽ’åºç»™å‡ºæœ€ä½³å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼Œä½†å®žé™…æ•ˆæžœä¸å¦‚ç”¨Sedgewickå¢žé‡åºåˆ—çš„å¸Œå°”æŽ’åºã€‚ å½’å¹¶æŽ’åºå½’å¹¶æŽ’åºçš„æ ¸å¿ƒå°±æ˜¯æœ‰åºå­åˆ—çš„å½’å¹¶ï¼Œé¦–å…ˆï¼Œç”³è¯·ç©ºé—´ï¼Œä¿å­˜åˆå¹¶åŽçš„æœ‰åºåºåˆ—ï¼Œè®¾å®šä¸¤ä¸ªæŒ‡é’ˆï¼Œæœ€åˆä½ç½®åˆ†åˆ«ä¸ºä¸¤ä¸ªæœ‰åºåºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œæ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ï¼Œé€‰æ‹©ç›¸å¯¹å°çš„å…ƒç´ æ”¾åˆ°ç”³è¯·çš„ç©ºé—´å†…ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä½ç½®ï¼Œé‡å¤ç›´è‡³æŸä¸€ä¸ªå­åºåˆ—è¶…å‡ºåºåˆ—å°¾ï¼ŒæŽ¥ç€å°†å¦ä¸€åºåˆ—å‰©ä¸‹çš„æ‰€æœ‰å…ƒç´ ç›´æŽ¥å¤åˆ¶åˆ°ç”³è¯·ç©ºé—´çš„å°¾éƒ¨ã€‚åˆå¹¶ä¸¤ä¸ªæœ‰åºå­åˆ—çš„åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516void Merge(ElementType A[], ElementType TempA[], int L, int R, int RightEnd) &#123; LeftEnd = R-1; //Suppose two subsequences are side-by-side Tmp = L; //initial position NumElements = RightEnd - L + 1; while(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd) &#123; if(A[L] &lt;= A[R]) TempA[Tmp++] = A[L++]; else TempA[Tmp++] = A[R++]; &#125; // copy the rest straightly while(L &lt;= LeftEnd) TempA[Tmp++] = A[L++]; while(R &lt;= RightEnd) TempA[Tmp++] = A[R++]; //copy the result to A[] from right to left for(i=0; i&lt;NumElements; i++, RightEnd--) &#123; A[RightEnd] = TempA[RightEnd] &#125;&#125; å½’å¹¶ç®—æ³•åœ¨å®žçŽ°çš„æ—¶å€™æœ‰ä¸¤ç§ä¸åŒçš„ç­–ç•¥ï¼Œä¸‹é¢å…ˆä»‹ç»é€’å½’ã€‚ é€’å½’å½’å¹¶æŽ’åºçš„é€’å½’ç®—æ³•çš„æ€æƒ³æ˜¯åŸºäºŽåˆ†æ²»æ³•çš„ï¼Œå…ˆå°†åˆ†å¼€çš„å­åºåˆ—æŽ’å¥½ï¼Œåœ¨åˆå¹¶æˆä¸€ä¸ªå¤§çš„åºåˆ—ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void MSort(ElementType A[], ElementType TempA[], int L, int RightEnd) &#123; int Center; if(L &lt; RightEnd) &#123; Center = (L + RightEnd)/2; MSort(A, TempA, L, Center); MSort(A, TempA, Center+1, RightEnd); Merge(A, TempA, L, Center+1, RightEnd); &#125;&#125; åŸºäºŽåˆ†æ²»æ³•çš„å½’å¹¶æŽ’åºé€’å½’ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$T(NlogN)$ï¼ŒæŽ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼š$$\begin{align} T(N)&amp; = 2 T(N/2)) + cN \\&amp; = 2\ (2T(N/2^2) + c N/2) + cN \\&amp; = \dots = 2^k * O(1) + ckN \\&amp; = O(NlogN)\end{align}$$å¯å¾—$T(N) = O(NlogN)$ï¼Œè¿™ä¸ªæ—¶é—´å¤æ‚åº¦æ˜¯å¾ˆâ€œå¼ºâ€çš„ðŸ˜†ï¼Œä¹Ÿå³æ˜¯è¯´åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼ˆæ— è®ºå¥½åï¼‰éƒ½æ˜¯$NlogN$ï¼Œå¦å¤–ï¼Œå½’å¹¶æŽ’åºæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ã€‚ä¸ºäº†ä½¿å®ƒä¸Žä¸Šè¿°å…¶ä»–æŽ’åºç®—æ³•çš„å‡½æ•°æŽ¥å£ç»Ÿä¸€ï¼Œå†æ•´ç†ä¸‹ä»£ç ï¼š12345678void Merge_Sort_Recursion(ElementType A[], int N) &#123; ElementType *TempA; TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; MSort(A, TempA, 0, N-1); free(TempA); &#125; else Error("Insufficient Space.");&#125; æ³¨æ„åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä¸´æ—¶ä¼ é€’ä½¿ç”¨çš„æ•°ç»„æ˜¯å£°æ˜Žåœ¨Merge_Sortå‡½æ•°ä¸­çš„ï¼Œè¿™æ ·åšçš„å¥½å¤„å°±æ˜¯é¿å…äº†åœ¨MSortä¸­é‡å¤å£°æ˜Žå’Œé‡å¤é‡Šæ”¾å†…å­˜æ“ä½œã€‚ éžé€’å½’å½’å¹¶æŽ’åºçš„éžé€’å½’ç®—æ³•åŸºæœ¬æ€æƒ³ä¾ç„¶æ˜¯åˆ†æ²»æ³•çš„æ€æƒ³ï¼Œæ¯æ¬¡å¾ªçŽ¯å…ˆå½’å¹¶ç›¸é‚»çš„ä¸¤ä¸ªå­åˆ—ï¼Œå­åˆ—é•¿åº¦é€æ¸å¢žåŠ ï¼Œç›´è‡³æœ€åŽå·¦å³ä¸¤ä¸ªå­åˆ—ä¹‹å’Œå¤§äºŽåºåˆ—æ€»é•¿åº¦ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930void Merge_Sort_Non_Recursion(ElementType A[], int N) &#123; int length; ElementType *TempA; length = 1; //initialize the length of subsequence TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; while(length &lt; N) &#123; Merge_pass(A, TempA, N, length); //left length *= 2; Merge_pass(TempA, A, N, length); //right length *= 2; &#125; &#125; else printf("Insufficient Space.\n");&#125;/*Merge adjacent ordered subsequence in pairs accroding to the current length of subsequence*/void Merge_pass(ElementType A[], ElementType TempA[], int N, int length) &#123; int i, j; for(i=0; i&lt;=N-2*length; i+=length) &#123; Merge(A, TempA, i, i+length, i+2*length-1); &#125; if(i+length &lt; N) &#123; //Merge the last two subsequence Merge(A, TempA, i, i+length, N-1); &#125; else &#123; //only one subsequence last for(j=i; j&lt;N; j++) TempA[j] = A[j]; &#125;&#125; æ³¨æ„ä¸Šè¿°ä»£ç ä¸­çš„ç»†èŠ‚ï¼ŒMerge_passæ˜¯ä¸€ä¸ªæŒ‰ç…§åºåˆ—é•¿åº¦è¿›è¡Œä¸€æ¬¡å½’å¹¶çš„å‡½æ•°ï¼Œå½“åºåˆ—é•¿åº¦å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå°†å†æ¬¡è°ƒç”¨æ­¤å‡½æ•°ï¼Œå¦å¤–ï¼Œåœ¨æ­¤å‡½æ•°å†…ï¼Œforå¾ªçŽ¯å†…å½’å¹¶çš„åºåˆ—æ˜¯å‰N/length - 1å¯¹ï¼Œè€Œä¸æ˜¯N/lengthå¯¹ï¼Œå¦‚æžœNæ˜¯å¥‡æ•°ï¼Œæœ€åŽä¸€ä¸ªå­åˆ—å°±è¢«å•ç‹¬å‡ºæ¥äº†ï¼Œå®ƒä¸Žå…¶ä»–å­åˆ—çš„é•¿åº¦ä¸ç­‰ï¼Œæ‰€ä»¥é’ˆå¯¹æœ€åŽä¸€ä¸ªå­åˆ—çš„å¤„ç†ï¼Œè¦ä¸Žå‰é¢åŒºåˆ†å¼€æ¥ã€‚å†è€…ï¼Œä¸Šè¿°ä»£ç ä¸­lengthå¢žé•¿çš„å€æ•°æ˜¯2ï¼Œç†è®ºä¸Šå³æ˜¯äºŒè·¯å½’å¹¶ã€‚ å°ç»“å½’å¹¶æŽ’åºç®—æ³•çš„ä¼˜ç‚¹å¾ˆæ˜Žæ˜¾ï¼Œé‚£å°±æ˜¯åœ¨ä»»ä½•æƒ…å†µï¼ˆæ— è®ºå¥½åï¼‰ä¸‹ï¼Œå…¶æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯$T(NlogN)$ï¼ŒåŒæ—¶ï¼Œå®ƒè¿˜æ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œä½†æ˜¯å®ƒæœ‰ä¸€ä¸ªå¾ˆæ˜Žæ˜¾çš„ç¼ºç‚¹ï¼Œå°±æ˜¯éœ€è¦å ç”¨$O(N)$å¤§å°çš„ç©ºé—´ï¼Œå¹¶ä¸”åœ¨å†…å­˜å†…è¦é¢‘ç¹çš„è¿›è¡Œå€’æ¢æ“ä½œï¼Œæ‰€ä»¥ï¼Œä¸€èˆ¬å†…éƒ¨æŽ’åºä¸­ä¸ä¼šä½¿ç”¨å½’å¹¶æŽ’åºï¼Œå¤–éƒ¨æŽ’åºä¼šä½¿ç”¨å½’å¹¶æŽ’åºã€‚ Homework09-1 æŽ’åºè¿™ä¸ªé¢˜ä¸“é—¨ç”¨æ¥æ£€æµ‹è‡ªå·±å®žçŽ°çš„æŽ’åºç®—æ³•ï¼Œæœ€å¥½æŠŠè€å¸ˆè®²äº†çš„éƒ½å®žçŽ°ä¸€ä¸‹ã€‚ å†’æ³¡æŽ’åº123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void bubble_sort(int *array, int n) &#123; for(int i = n - 1; i &gt; 0; i--) &#123; bool flag = true; for(int j = 0; j &lt; i; j++) &#123; if(array[j] &gt; array[j + 1])&#123; swap(&amp;array[j], &amp;array[j + 1]); flag = false; &#125; &#125; if(flag) break; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; bubble_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; æ’å…¥æŽ’åº123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å¸Œå°”æŽ’åº123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å †æŽ’åº12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; for(int i = n - 1; i &gt; 0; i--) &#123; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; heap_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å½’å¹¶æŽ’åºéžé€’å½’123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; merge_pass(tmparr, array, n, length); length *= 2; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; é€’å½’12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void msort(int *array, int *tmparr, int left, int rightend) &#123; int center; if(left &lt; rightend) &#123; center = (left + rightend) / 2; msort(array, tmparr, left, center); msort(array, tmparr, center + 1, rightend); merge(array, tmparr, left, center + 1, rightend); &#125;&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; msort(array, tmparr, 0, n - 1); free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 09-2 Insert or Mergeè¿™ä¸ªé¢˜å½¢å¼ç®€å•ï¼Œä½†æ˜¯è¦æƒ³å¾—æ»¡åˆ†ï¼Œå¿…é¡»å¾—å¯¹æ’å…¥æŽ’åºè·Ÿå½’å¹¶æŽ’åºéƒ½å¾ˆäº†è§£æ‰è¡Œã€‚ é¢˜ç›®è¦æ±‚è¾“å‡ºä¸¤æ ·ä¸œè¥¿ï¼š åˆ¤æ–­å±žäºŽé‚£ä¸€ç§æŽ’åº ç„¶åŽè¾“å‡ºå†è¿›è¡Œä¸‹ä¸€æ¬¡è¿™ç§æŽ’åºåŽæ‰€å¾—çš„åºåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; if(issame(tmparr)) &#123; merge_pass(tmparr, array, n, length); printarray(array, n); break; &#125; merge_pass(tmparr, array, n, length); length *= 2; if(issame(array)) &#123; merge_pass(array, tmparr, n, length); printarray(tmparr, n); break; &#125; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Merge Sort\n"); merge_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6out:Merge Sort1 2 3 8 4 5 7 9 0 6*/ 09-3 Insertion or Heap Sortè¿™ä¸ªé¢˜ä¸Žä¸Šé¢˜ç±»åž‹ä¸€è‡´ï¼Œåªä¸è¿‡æŠŠå½’å¹¶æŽ’åºæ¢æˆäº†å †æŽ’åºã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; int i; for(i = n - 1; i &gt; 0; i--) &#123; if(issame(array)) break; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); printarray(array, n);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Heap Sort\n"); heap_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9out:Heap Sort5 4 3 1 0 2 6 7 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_08-å›¾ï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F08%2F31%2FZJU-DS-08-%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[è¿™å‘¨è¯¾ç¨‹ä¸»è¦ä»‹ç»äº†å›¾çš„å¦å¤–ä¸¤ä¸ªåº”ç”¨ï¼šæœ€å°ç”Ÿæˆæ ‘å’Œæ‹“æ‰‘æŽ’åºï¼Œé¡ºå¸¦è®²äº†ä¸€ä¸‹å…³é”®è·¯å¾„ æœ€å°ç”Ÿæˆæ ‘ä»€ä¹ˆæ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spaning Treeï¼‰ï¼Ÿå®ƒé¦–å…ˆæ˜¯ä¸€æ£µæ ‘ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰å›žè·¯ï¼Œä¸” V ä¸ªé¡¶ç‚¹çš„æœ€å°ç”Ÿæˆæ ‘ä¸€å®šæœ‰ V-1 æ¡è¾¹ï¼ˆè¿™å°±æ˜¯æ ‘çš„æ€§å€¼ï¼‰ã€‚æ—¢ç„¶æ˜¯ç”Ÿæˆæ ‘ï¼Œæ‰€ä»¥è¿™æ£µæ ‘åŒ…å«äº†å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ï¼Œæ ‘ä¸­çš„ V-1 æ¡è¾¹ä¸€å®šä¹Ÿéƒ½åœ¨å›¾å†…ï¼›é‚£æœ€å°æ˜¯ä»€ä¹ˆï¼Ÿæœ€å°çš„å«ä¹‰æ˜¯æŒ‡è¾¹çš„æƒé‡å’Œæœ€å°ã€‚è¿™é‡Œè¦æ³¨æ„ï¼Œå¦‚æžœå›¾æ˜¯è¿žé€šçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾ä¸€å®šå­˜åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸”ä¸ä¸€å®šå”¯ä¸€ã€‚ ä¸‹é¢ä»‹ç»çš„ä¸¤ç§ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•æœ¬è´¨æ€æƒ³éƒ½æ˜¯åŸºäºŽâ€œè´ªå¿ƒâ€ï¼Œè¿™ä¸Žå‰é¢çš„ Dijkstra ç®—æ³•æ˜¯ä¸€è‡´çš„ã€‚æ‰€è°“â€œè´ªå¿ƒâ€ï¼Œå³æ˜¯æŒ‡æ¯ä¸€æ­¥éƒ½è¦â€œæœ€å¥½â€çš„ï¼Œåœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œæƒé‡æœ€å°çš„è¾¹ä¹Ÿå°±æ˜¯â€œæœ€å¥½â€çš„äº†ã€‚ Prim ç®—æ³•Prim ç®—æ³•çš„å¤§è‡´è¿‡ç¨‹ä»Žä¸€ä¸ªé¡¶ç‚¹å¼€å§‹ï¼Œæ…¢æ…¢çš„ç”Ÿé•¿æˆä¸€æ£µæ ‘ï¼Œå…ˆçœ‹ä¸‹å®ƒçš„ä¼ªç æè¿°ï¼š12345678910111213141516171819void Prim() &#123; MST = &#123;S&#125;; while(1) &#123; V = æœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…; if(V ä¸å­˜åœ¨) break; å°† V æ”¶å½•è¿› MST; dist[V] = 0; for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(dist[W] != 0) &#123; if( è¾¹æƒ(V,W) &lt; dist[W]) &#123; dist[W] = 0; parent[W] = V; &#125; &#125; &#125; &#125; if(MST ä¸­æ”¶å½•çš„é¡¶ç‚¹ä¸åˆ° |ï¼¶| ä¸ª) Error("ç”Ÿæˆæ ‘ä¸å­˜åœ¨");&#125; Prim ç®—æ³•ä¸Ž Dijkstra ç®—æ³•ååˆ†ç±»ä¼¼ï¼Œå°±æ˜¯å¾ªçŽ¯å†…çš„åˆ¤æ–­æ¡ä»¶ä¸ä¸€æ ·ï¼Œå…¶ä»–åŸºæœ¬ä¸€è‡´ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ Prim ç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ã€‚dist æ•°ç»„ç”¨æ¥ç­›é€‰è¾¹æƒæœ€å°çš„é¡¶ç‚¹ï¼›parent æ•°ç»„æ¥ä¿å­˜æ ‘ï¼Œä¸” parent æ•°ç»„éœ€è¦åˆå§‹åŒ–ä¸º -1ï¼Œè¿™é‡Œä¸Žå¹¶æŸ¥é›†çš„æ€è·¯æ˜¯ç±»ä¼¼çš„ã€‚ ä»¥$v_1$ä¸ºæºç‚¹ï¼Œdist æ•°ç»„åˆå§‹åŒ–ï¼š index 1 2 3 4 5 6 7 dist 0 âˆž âˆž âˆž âˆž âˆž âˆž parent -1 -1 -1 -1 -1 -1 -1 ç›´æŽ¥å°† dist[1] åˆå§‹åŒ–ä¸º 0ï¼Œç„¶åŽ$v_1$ä½œä¸ºæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…ï¼Œå°†å…¶æ”¶å½•è¿› MSTï¼Œå†è®¿é—®å…¶æ¯ä¸ªé‚»æŽ¥ç‚¹ï¼Œæ­¤æ—¶å¯ä»¥å°† dist æ•°ç»„çš„å€¼æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 2 4 1 âˆž âˆž âˆž parent -1 1 1 1 -1 -1 -1 æŽ¥ç€ï¼Œæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…å°±æ˜¯$v_4$ï¼Œæ”¶å½•è¿› MSTï¼Œæ­¤æ—¶ dist å’Œ parent æ•°ç»„æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 2 2 0 7 7 4 parent -1 1 4 1 4 4 4 å¯ä»¥çœ‹åˆ°ï¼Œå› ä¸º$(v_4, v_3) &lt; (v_1, v_3)$ï¼Œæ‰€ä»¥ dist[3] ä¸Ž parent[3] çš„å€¼å°†ä¼šå¾—åˆ°æ›´æ–°ã€‚ å†æ¥ï¼Œæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…å°±æ˜¯$v_2$ï¼Œæ”¶å½•è¿› MSTï¼Œæ­¤æ—¶ dist å’Œ parent æ•°ç»„æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 0 2 0 7 8 4 parent -1 1 4 1 4 4 4 ä¾æ¬¡ç±»æŽ¨ï¼Œæ”¶å½•$v_3$ï¼Œæœ‰ï¼š index 1 2 3 4 5 6 7 dist 0 0 0 0 7 5 4 parent -1 1 4 1 4 3 4 æ”¶å½•$v_7$ï¼Œæœ‰ï¼š index 1 2 3 4 5 6 7 dist 0 0 0 0 6 1 0 parent -1 1 4 1 7 7 4 æœ€åŽå†åˆ†åˆ«é€‰å–$v_6$å’Œ$v_5$åŽï¼ŒMST ä¸­æ”¶å½•çš„é¡¶ç‚¹è¾¾åˆ° |V| ä¸ªåŽå°±å¾—åˆ°äº†æœ€å°ç”Ÿæˆæ ‘ã€‚é€šè¿‡ä¸Šé¢ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒPrim ä¸­çš„ dist æ•°ç»„çš„ç”¨é€”ä¸Ž Djikstra ç®—æ³•ä¸­ dist æ•°ç»„çš„ç”¨é€”æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåªæ˜¯ä¸¤è€…çš„åˆ¤æ–­æ¡ä»¶ä¸ä¸€æ ·è€Œå·²ã€‚å¦å¤–ï¼ŒPrim ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿå°±æ˜¯$O(|V|^3)$ã€‚ Kruskal ç®—æ³•Kruskal ç®—æ³•çš„å¤§è‡´è¿‡ç¨‹æ˜¯åœ¨â€œé€‰è¾¹â€ï¼Œä¹Ÿå°±æ˜¯å°†æ£®æž—åˆå¹¶æˆæ ‘ï¼Œå…¶ä¼ªç æè¿°ä¸ºï¼š123456789101112131415void Kruskal(Graph G) &#123; MST = &#123;&#125;; while(MST ä¸­æ‰¾ä¸åˆ° |V|-1 æ¡è¾¹ &amp;&amp; E ä¸­è¿˜æœ‰è¾¹) &#123; ä»Ž E ä¸­å–ä¸€æ¡æƒé‡æœ€å°çš„è¾¹ E(v, w); //ä½¿ç”¨æœ€å°å †å®žçŽ° å°†å–å‡ºçš„æœ€å°è¾¹ E(v, w)ä»Ž E ä¸­åˆ é™¤; if(E(v, w) ä¸åœ¨ MST ä¸­æž„æˆå›žè·¯) &#123; //ä½¿ç”¨å¹¶æŸ¥é›†å®žçŽ° å°† E(v, w)åŠ å…¥ MST; &#125; else &#123; å½»åº•æ— è§† E(v, w); &#125; &#125; if(MST ä¸­æ‰¾ä¸åˆ° |V|-1 æ¡è¾¹) &#123; Error("ç”Ÿæˆæ ‘ä¸å­˜åœ¨"); &#125;&#125; ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ Kruskal ç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ã€‚ ä¾æ¬¡åŠ å…¥è¾¹$(v_1, v_4)$ã€$(v_6, v_7)$ã€$(v_1, v_2)$ã€$(v_3, v_4)$ã€$(v_4, v_7)$ã€$(v_5, v_7)$å³å¯ï¼Œæ•´ä¸ªè¿‡ç¨‹è®²èµ·æ¥æ¯” Prim ç®—æ³•ç®€å•äº†ä¸å°‘ï¼Œä½†æ˜¯å®žçŽ°èµ·æ¥å°±ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œæ—¢è¦ç”¨åˆ°æœ€å°å †ï¼Œåˆè¦ç”¨åˆ°å¹¶æŸ¥é›†ï¼Œä½†å…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿç¨å¾®ä¼˜ç§€ä¸€ç‚¹ï¼ˆç›¸æ¯” Primï¼‰ï¼Œä¸ºï¼š$O(|E|Log|E|)$ã€‚å¦å¤–ï¼Œç¬”è¯•é¢˜ä¸­ï¼ŒKruskal ç®—æ³•è§£é¢˜é€Ÿåº¦æ˜¯ç¬¬ä¸€åï¼Œè°ç”¨è°çŸ¥é“ã€‚ æ‹“æ‰‘æŽ’åºæ‹“æ‰‘æŽ’åºä¸åŒäºŽæ™®é€šæŽ’åºï¼Œæ™®é€šæŽ’åºå°±æ˜¯æŒ‰ç…§æŸä¸€è§„åˆ™å¯¹å…·æœ‰åŒç±»æ€§è´¨çš„å…ƒç´ è¿›è¡Œå‡åºæˆ–é™åºæŽ’åºï¼›è€Œæ‹“æ‰‘æŽ’åºæ˜¯é’ˆå¯¹æœ‰å‘æ— çŽ¯å›¾ï¼ˆDirected Acyclic Graphï¼ŒDAGï¼‰G è¿›è¡Œçš„ï¼Œæ˜¯å°†å›¾ G ä¸­æ‰€æœ‰é¡¶ç‚¹æŽ’æˆä¸€ä¸ªçº¿æ€§åºåˆ—ï¼Œä½¿å¾—å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹ u å’Œ vï¼Œè‹¥è¾¹ $&lt;u, v&gt;$æ˜¯å›¾ G çš„è¾¹ï¼ˆä¹Ÿå³å­˜åœ¨ä¸€æ¡ u åˆ° v çš„æœ‰å‘è·¯å¾„ï¼‰ï¼Œåˆ™ u åœ¨çº¿æ€§åºåˆ—ä¸­ä¸€å®šå‡ºçŽ°åœ¨ v ä¹‹å‰ï¼Œè¿™æ ·çš„åºåˆ—å«åšæ‹“æ‰‘åºåˆ—ï¼Œè€Œè¿™ä¸ªå¾—åˆ°è¿™ä¸ªåºåˆ—çš„è¿‡ç¨‹å°±å«åšæ‹“æ‰‘æŽ’åºã€‚ è€Œå§¥å§¥è®²çš„ AOV ç½‘ï¼Œå…·ä½“å®šä»¥è¯·ç‚¹å‡»é“¾æŽ¥å‚è€ƒä¸‹ç™¾åº¦ç™¾ç§‘ã€‚å¦å¤–ï¼Œå¯¹äºŽä¸€ä¸ª AOV ç½‘è€Œè¨€ï¼Œå¦‚æžœæœ‰åˆç†çš„æ‹“æ‰‘åºï¼Œåˆ™å…¶å¿…å®šæ˜¯æœ‰å‘æ— çŽ¯å›¾ã€‚æ¢å¥è¯è¯´ï¼Œä¹Ÿå°±æ˜¯è¯´æ‹“æ‰‘æŽ’åºå¯ä»¥ç”¨æ¥æ£€æµ‹å›¾å†…æ˜¯å¦æœ‰çŽ¯ï¼Œè¿™ä¹Ÿæ˜¯ç¬”è¯•é¢˜ä¸­å¸¸ç”¨çš„çŸ¥è¯†ç‚¹ã€‚ æ‹“æ‰‘æŽ’åºçš„ä¼ªç ç®—æ³•å¦‚ä¸‹ï¼š12345678910111213141516171819void TopSort() &#123; for(å›¾ä¸­æ¯ä¸ªé¡¶ç‚¹ V) &#123; if(Indegree[V] == 0) &#123; Enqueue(V, Q); &#125; &#125; while(!IsEmpty(Q)) &#123; V = Dequeue(Q); è¾“å‡ºVï¼Œæˆ–è€…è®°å½• V çš„è¾“å‡ºåºå·; cnt++; for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(--Indegree[W] == 0) &#123; Enqueue(W, Q); &#125; &#125; &#125; if(cnt != |V|) &#123; Error("å›¾ä¸­æœ‰å›žè·¯"); &#125;&#125; å…³é”®è·¯å¾„å…³é”®è·¯å¾„é—®é¢˜æ˜¯é’ˆå¯¹ AOEï¼ˆActivity On Edgeï¼‰ç½‘ç»œè€Œè¨€çš„ï¼Œå±žäºŽæ‹“æ‰‘æŽ’åºçš„åº”ç”¨ï¼Œä¸€èˆ¬ç”¨äºŽå®‰æŽ’é¡¹ç›®çš„å·¥åºé—®é¢˜ï¼Œå›¾ä¸­çš„è¾¹ä»£è¡¨å·¥åºï¼Œå·¥åºä¸Žå·¥åºä¹‹é—´æœ‰å…ˆåŽå…³ç³»ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºè¾¹ä»£è¡¨æ´»åŠ¨ï¼Œé¡¶ç‚¹è¡¨ç¤ºè¿™ä¸ªæ´»åŠ¨çš„ç»“æŸï¼ŒæŒ‰ç…§å§¥å§¥ PPT ä¸­çš„ä»‹ç»æ¥ç†è§£å³å¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æŽ¥ç€è·Ÿç€å§¥å§¥çš„ PPT ä¸€èµ·æ‰‹åŠ¨è®¡ç®—å…³é”®è·¯å¾„ï¼Œå¯ä»¥å¾—åˆ°ä¸‹å›¾çš„ç»“æžœã€‚ åœ¨ä¸Šé¢çš„é—®é¢˜ä¸­ï¼Œæ³¨æ„å¯¹é‚£æ¡â€œè™šè¾¹â€çš„ç†è§£ï¼Œä¹‹æ‰€ä»¥ä¼šæœ‰è¿™æ¡è™šè¾¹ï¼Œå…¶å®žæ˜¯å› ä¸ºè¦æƒ³åˆ°è¾¾é¡¶ç‚¹ 7ï¼Œå¿…é¡»è¦å…ˆåˆ°è¾¾é¡¶ç‚¹ 4 å’Œ 5ã€‚å¯èƒ½æœ‰äººä¼šé—®ä¸ºä»€ä¹ˆæ˜¯ä»Ž 5 æŒ‡å‘ 4ï¼Œå¾ˆç®€å•ï¼Œå› ä¸º 4 åŽåˆ°è¾¾ï¼Œ5 ä¼šå…ˆåˆ°è¾¾ï¼Œå¦‚æžœ 5 åŽåˆ°è¾¾ï¼Œ4 å…ˆåˆ°è¾¾ï¼Œé‚£å°±æ˜¯ 4 æŒ‡å‘ 5 äº†ã€‚ å¦å¤–éœ€è¦æ³¨æ„çš„å°±æ˜¯æœºåŠ¨æ—¶é—´çš„è®¡ç®—ï¼Œè¿˜æ˜¯è¦å…ˆç†è§£æœºåŠ¨æ—¶é—´çš„æ¦‚å¿µã€‚æœºåŠ¨æ—¶é—´è¿™ä¸ªä¸œè¥¿ï¼Œå®žé™…ä¸Šå°±æ˜¯å¯ä»¥å·æ‡’çš„æ—¶é—´ï¼ŒåŽå®Œæˆçš„äººä¸èƒ½å·æ‡’ï¼Œä½†å…ˆå®Œæˆçš„äººå°±å¯ä»¥å·æ‡’äº†ã€‚ä»¥é¡¶ç‚¹ 5 ä¸ºä¾‹ï¼Œå®ƒçš„æœºåŠ¨æ—¶é—´å°±æ˜¯ï¼š$D_{&lt;5, 7&gt;} = Latest[7] - Earliest[i] - C_{&lt;5, 7&gt;} = 14 - 7 - 4 = 3$ã€‚ä¼šç®—è¿™äº›ä¸œè¥¿åŽï¼Œå°±å¯ä»¥æ‰¾å‡ºå…³é”®è·¯å¾„äº†ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯å¯¹ä¸€ä¸ª AOE ç½‘è€Œè¨€ï¼Œå…³é”®è·¯å¾„ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œè¿™ä¸ªä»Žä¸Šå›¾å°±å¯ä»¥çœ‹å‡ºã€‚ Homework08-7 å…¬è·¯æ‘æ‘é€šå¾ˆç›´è§‚çš„æœ€å°ç”Ÿæˆæ ‘é—®é¢˜ï¼Œä¸€é Prim ç®—æ³•å°±æžå®šäº†ï¼Œå¦‚æžœä¸è¿žé€šå°±è¾“å‡º -1ï¼Œåä¹‹å°±è¾“å‡ºæœ€å°ç”Ÿæˆæ ‘çš„è¾¹æƒä¹‹å’Œï¼Œä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt; #define maxn 1005const int inf = 0x3fffffff;int nv, ne, G[maxn][maxn], dist[maxn];bool visited[maxn] = &#123; false &#125;;void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; for (int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void prim() &#123; for (int i = 0; i &lt; maxn; i++) dist[i] = inf; dist[1] = 0; int times = 0, totalweight = 0; while(1) &#123; int mindis = inf, v = -1; for (int i = 1; i &lt;= nv; i++) &#123; if (!visited[i] &amp;&amp; dist[i] &lt; mindis) &#123; mindis = dist[i]; v = i; &#125; &#125; if (v == -1) break; times++; visited[v] = true; totalweight += dist[v]; for (int w = 1; w &lt;= nv; w++) &#123; if (G[v][w] != inf &amp;&amp; !visited[w] &amp;&amp; G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; if (times == nv) printf("%d", totalweight); else printf("-1");&#125;int main() &#123; scanf("%d %d", &amp;nv, &amp;ne); init(); int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; scanf("%d %d %d", &amp;v1, &amp;v2, &amp;weight); G[v1][v2] = G[v2][v1] = weight; &#125; prim(); return 0;&#125;/*samples:in:6 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3out:12*/ 08-8 How Long Does It Takeè¿™é“é¢˜è™½ç„¶æ˜¯è‹±æ–‡çš„ï¼Œä½†æ˜¯é¢˜æ„å¾ˆç›´è§‚ï¼Œå°±æ˜¯ç›´æŽ¥æ±‚å…³é”®è·¯å¾„çš„æœ€æ—©å®Œæˆæ—¶é—´ï¼Œä½†å®žé™…ä¸Šå¹¶æ²¡æœ‰è¦æ±‚ä¹Ÿè¦è¾“å‡ºå…³é”®è·¯å¾„ï¼Œå‡å°‘äº†ç‚¹éº»çƒ¦å§ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯å°±æ˜¯åˆ©ç”¨å…ˆæ‹“æ‰‘æŽ’åºï¼Œå¾—åˆ°ä¸€ä¸ªæ‹“æ‰‘åºåˆ—ï¼Œç„¶åŽé€šè¿‡è¿™ä¸ªæ‹“æ‰‘åºåˆ—æ¥å…³é”®è·¯å¾„çš„æœ€æ—©å®Œæˆæ—¶é—´ã€‚æˆ‘ä»¬ä½¿ç”¨ STL æ¥å·ä¸‹æ‡’ï¼Œå°† Vector å½“ä½œé‚»æŽ¥è¡¨æ¥å­˜å‚¨å›¾ï¼Œåˆ©ç”¨ Vector å†…çš„æˆå‘˜å‡½æ•° emplace_backï¼ˆC++11 çš„æ–°ç‰¹æ€§ï¼‰æ¥è¾“å…¥é¡¶ç‚¹å’Œå¯¹åº”çš„è¾¹æƒè¦æ–¹ä¾¿ä¸€äº›ï¼Œä½†è¦è¿™æ ·ç”¨å¾—å…ˆå†™å¥½ node çš„æž„é€ å‡½æ•°ã€‚åœ¨è¿›è¡Œæ‹“æ‰‘æŽ’åºæ—¶ï¼Œå¯ä»¥é¡ºä¾¿å°†æœ€æ—©å®Œæˆæ—¶é—´ä¹Ÿä¸€å¹¶è®¡ç®—å‡ºæ¥ã€‚ä¸ºäº†é¿å…å›¾å¯èƒ½ä¸æ˜¯è¿žé€šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶æ˜¯æ— è§£çš„ï¼Œéœ€è¦è®¾ç½®ä¸€ä¸ªè®¡æ•°å™¨æ¥è®°å½•æ‰€å¾—åˆ°çš„æ‹“æ‰‘åºåˆ—çš„é¡¶ç‚¹ä¸ªæ•°ï¼Œå¦‚æžœä¸Žå›¾çš„é¡¶ç‚¹æ€»æ•°ä¸ç›¸ç­‰ï¼Œé‚£ä¹Ÿå°±æ˜¯è¯´å›¾æ˜¯ä¸è¿žé€šçš„ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node&#123; int w, weight; node(int w, int weight) &#123; this-&gt;w = w; this-&gt;weight = weight; &#125;&#125;;vector&lt;node&gt; G[maxn];int nv, ne, indegree[maxn] = &#123; 0 &#125;, cost[maxn];void topsort() &#123; queue&lt;int&gt; q; for (int v = 0; v &lt; nv; v++) &#123; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]++; &#125; &#125; for (int i = 0; i &lt; maxn; i++) cost[i] = -1; int count = 0; for (int i = 0; i &lt; nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); cost[i] = 0; &#125; &#125; while (!q.empty()) &#123; int v = q.front(); q.pop(); count++; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]--; if (cost[G[v][w].w] &lt; cost[v] + G[v][w].weight) &#123; cost[G[v][w].w] = cost[v] + G[v][w].weight; &#125; if (indegree[G[v][w].w] == 0) &#123; q.push(G[v][w].w); &#125; &#125; &#125; if (count != nv) cout &lt;&lt; "Impossible"; else &#123; int max = cost[0]; for (int i = 1; i &lt; nv; i++) &#123; if (max &lt; cost[i]) max = cost[i]; &#125; cout &lt;&lt; max; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight; G[v1].emplace_back(v2, weight); &#125; topsort(); return 0;&#125;/*samples:in:9 120 1 60 2 40 3 51 4 12 4 13 5 25 4 04 6 94 7 75 7 46 8 27 8 4out:18in:4 50 1 10 2 22 1 31 3 43 2 5out:Impossiblein:7 60 3 23 4 21 2 32 4 24 5 34 6 2out:8*/ 08-9 å…³é”®æ´»åŠ¨è¿™é“é¢˜æ²¡å•¥è¯´çš„ï¼Œå°±æ˜¯å…³é”®è·¯å¾„çš„é—®é¢˜ã€‚ç›¸æ¯”ä¸Šé“é¢˜ï¼Œè¿™é“é¢˜è¦éº»çƒ¦ä¸€äº›ï¼Œå› ä¸ºè¿™ä¸ªé¢˜ä¸ä»…è¦è¾“å‡ºæœ€æ—©å®Œæˆæ—¶é—´ï¼Œè¿˜å¾—è¾“å‡ºå…³é”®è·¯å¾„ï¼Œå¤šäºäº† STL çœäº†å¾ˆå¤šéº»çƒ¦ã€‚æ±‚æœ€æ—©å®Œæˆæ—¶é—´çš„æ€è·¯ä¸Žä¸Šé¢é‚£é¢˜æ˜¯ä¸€æ ·çš„ï¼Œç›´æŽ¥ä¸€ä¸ªæ‹“æ‰‘æŽ’åºå°±å®Œäº‹äº†ã€‚éš¾ç‚¹åœ¨äºŽå¦‚ä½•æ‰¾å…³é”®è·¯å¾„ï¼Œä¸èƒ½ç®€å•çš„ç›´æŽ¥æ‹¿æ‹“æ‰‘åºåˆ—æ¥åå‘è¾“å‡ºï¼Œé‚£æ€Žä¹ˆåŠžå‘¢ï¼Ÿä»”ç»†å›žå¿†ä¸€ä¸‹è¯¾ä¸Šçš„ä¾‹å­ï¼Œå¯ä»¥å‘çŽ°å…³é”®è·¯å¾„çš„å…³é”®æ´»åŠ¨æ²¡æœ‰ç©ºä½™æ—¶é—´ï¼Œå‡å¦‚ e æ˜¯æ´»åŠ¨çš„æœ€æ—©å®Œæˆæ—¶é—´ï¼Œl æ˜¯æ´»åŠ¨çš„æœ€æ™šå¼€å§‹æ—¶é—´ï¼Œé‚£ä¹ˆå…³é”®æ´»åŠ¨çš„ e ä¸Ž l æ˜¯ç›¸ç­‰ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå°†æ‹“æ‰‘åºåˆ—ä¸­çš„æ‰€æœ‰çš„å…³é”®æ´»åŠ¨çš„ e å’Œ l æ±‚å‡ºï¼Œå¹¶è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœç›¸ç­‰ï¼Œå°±æ˜¯å…³é”®æ´»åŠ¨äº†ï¼Œå½“ç„¶äº†ï¼Œå‰ææ˜¯æ‹“æ‰‘åºåˆ—æ˜¯å­˜åœ¨çš„ã€‚ä½†æ˜¯åˆ«å¿˜è®°äº†ï¼Œé¢˜ç›®è¦æ±‚ä»Žå°åˆ°å¤§è¾“å‡ºå…³é”®æ´»åŠ¨ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹æ‰¾å‡ºçš„åºåˆ—è¿›è¡ŒæŽ’åºï¼Œç„¶åŽå†è¾“å‡ºã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node &#123; int v, w; node(int v, int w) &#123; this-&gt;v = v; this-&gt;w = w; &#125;&#125;;bool cmp(int a, int b) &#123; return b - a;&#125;vector&lt;node&gt; G[maxn];stack&lt;int&gt; topo;int nv, ne, ve[maxn] = &#123; 0 &#125;, vl[maxn], indegree[maxn] = &#123; 0 &#125;;bool topoorder() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= nv; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; indegree[G[i][j].v]++; &#125; &#125; for (int i = 1; i &lt;= nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); ve[i] = 0; &#125; &#125; while (!q.empty()) &#123; int u = q.front(); topo.push(u); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; indegree[G[u][i].v]--; if (ve[G[u][i].v] &lt; ve[u] + G[u][i].w) &#123; ve[G[u][i].v] = ve[u] + G[u][i].w; &#125; if (indegree[G[u][i].v] == 0) q.push(G[u][i].v); &#125; &#125; if (topo.size() != nv) return false; else return true;&#125;void criticalpath() &#123; int max = ve[1], maxid = 1; for (int i = 2; i &lt;= nv; i++) &#123; if (ve[i] &gt; max) &#123; max = ve[i]; maxid = i; &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; for (int i = 0; i &lt; maxn; i++) vl[i] = max; while (!topo.empty()) &#123; int u = topo.top(); topo.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v; if (vl[v] - G[u][i].w &lt; vl[u]) &#123; vl[u] = vl[v] - G[u][i].w; &#125; &#125; &#125; vector&lt;int&gt; keyact[maxn]; for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v, w = G[u][i].w; int e = ve[u], l = vl[v] - w; if (e == l) keyact[u].push_back(v); &#125; &#125; for (int i = 1; i &lt;= nv; i++) sort(keyact[i].begin(), keyact[i].end(), cmp); for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; keyact[u].size(); i++) &#123; cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; keyact[u][i] &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int u, v, w; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].emplace_back(v, w); &#125; if (!topoorder()) cout &lt;&lt; 0; else criticalpath(); return 0;&#125;/*samples:in:7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2out:171-&gt;22-&gt;44-&gt;66-&gt;7in:4 41 2 21 3 22 4 23 4 2out:41-&gt;31-&gt;22-&gt;43-&gt;4in:3 31 2 12 3 13 1 1out:0in:3 31 2 11 3 12 3 1out:21-&gt;22-&gt;3*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prologueï¼ˆãƒ—ãƒ­ãƒ­ãƒ¼ã‚° - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼ï¼‰- ç¿»å¼¹]]></title>
    <url>%2F2020%2F08%2F29%2FPrologue%EF%BC%88%E3%83%97%E3%83%AD%E3%83%AD%E3%83%BC%E3%82%B0%20-%20%E6%8A%BC%E5%B0%BE%E3%82%B3%E3%83%BC%E3%82%BF%E3%83%AD%E3%83%BC%EF%BC%89-%20%E7%BF%BB%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Prologueï¼ˆãƒ—ãƒ­ãƒ­ãƒ¼ã‚° - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼ï¼‰æ˜¯æŠ¼å°¾äºŽ 2003 å¹´å‘è¡Œçš„ä¸“è¾‘ã€ŠDramaticã€‹ä¸­çš„ä¸€é¦–è¾ƒä¸ºç®€å•çš„æŒ‡å¼¹æ›²å­ã€‚ è°±å­ä¸€å…±å°±ä¸¤é¡µï¼Œä¸é•¿ï¼Œä½†æ˜¯ç¼–çš„çœŸå¥½ï¼Œæƒ³è¦å®Œæ•´çš„å¼¹ä¸‹æ¥è¿˜å¾—è´¹ä¸€ç•ªåŠŸå¤«ã€‚å…ˆçœ‹ä¸‹åŽŸç‰ˆè°±å­ç¬¬ 1 é¢ï¼ˆæ‰«æä»¶ï¼Œç”»è´¨ç•¥å·®è§è°…ï¼‰ï¼š è°±å­äº”çº¿è°±çš„å·¦ä¸Šè§’å†™ç€ Tuning = Standardï¼Œè¯´æ˜Žè¿™æ˜¯é¦–æ ‡å‡†è°ƒå¼¦çš„æ›²å­ï¼›äº”çº¿è°±çš„å¼€å¤´æœ‰ä¸€ä¸ªé«˜éŸ³è°±å·å’Œä¸€ä¸ªâ€œ#â€å·è¡¨ç¤ºè¿™é¦–æ›²å­æ˜¯ G å¤§è°ƒçš„ï¼›è¾¹ä¸Šçš„$\frac{6}{8}$ï¼Œè¡¨ç¤ºè¿™é¦–æ›²å­çš„èŠ‚æ‹æ˜¯å…«å…­æ‹ï¼›è°±å·ä¸Šè¿˜æœ‰ä¸€ä¸ªå¸¦æ–¹æ¡†çš„ç¼©å†™çš„è‹±æ–‡å•è¯ Introï¼Œè¡¨ç¤ºå‰ä¸¤å°èŠ‚æ˜¯è¿™é¦–æ›²å­çš„å¼•å­ï¼ˆå°±åƒæŸäº›å°è¯´å¼€å¤´çš„å¼•å­ä¸€æ ·ï¼‰ï¼›ç´§æŽ¥ç€è¾¹ä¸Šçš„ G è¡¨ç¤ºè¿™ä¿©å°èŠ‚çš„å’Œå¼¦èµ°å‘æ˜¯ Gï¼›è¿˜æœ‰åŽé¢å¸¦æ–¹æ¡†çš„è‹±æ–‡åˆ†åˆ«ä»£è¡¨è¿™é¦–æ›²å­çš„ A æ®µã€B æ®µã€C æ®µç­‰ã€‚ å»ºè®®åªçœ‹å…­çº¿è°±çš„ä¹Ÿä¸è¦å¿½ç•¥ä¸Šé¢çš„å†…å®¹ã€‚ A æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬äºŒå°èŠ‚äº”çº¿è°±ä¸Šçš„æ•°å­—ä»£è¡¨äº†å·¦æ‰‹çš„æŒ‡æ³•ï¼Œä½†å®žé™…ä¸Šä½ å¯ä»¥æŒ‰ç…§è‡ªå·±ç†Ÿç»ƒçš„æ–¹å¼æ¥æ¼”å¥ï¼›å¦å¤–ï¼ŒS æ ‡è®°ä»£è¡¨ä»Ž 2 å¼¦ 3 å“ç”¨æ»‘éŸ³æ¼”å¥æ³•æ»‘åˆ° 10 å“ï¼Œä¸ºäº†è¾¾åˆ°è·ŸåŽŸæ›²çš„æ•ˆæžœï¼Œæ»‘åˆ° 10 å“åŽï¼Œéœ€è¦åœ¨å¼¹ä¸€æ¬¡ 2 å¼¦ 10 å“ç¬¬å››å°èŠ‚å³æ‰‹ä¸­æŒ‡ä¸Žæ— åæŒ‡éœ€è¦åŒæ—¶å¼¹å“ 1ã€2å¼¦ï¼Œç”¨æ»‘éŸ³å¬èµ·æ¥ä¼šæ›´æ£’ç¬¬äº”å°èŠ‚å·¦æ‰‹ä¸­æŒ‡ä¸Žå°æŒ‡éœ€è¦é¦–å…ˆåŒæ—¶æŒ‰ä½ 6 å¼¦ 8 å“å’Œ 3 å¼¦ 9 å“ç¬¬å…­å°èŠ‚å·¦æ‰‹é£ŸæŒ‡éœ€è¦æ¨ªæŒ‰ï¼Œä½†é£ŸæŒ‡æ¨ªæŒ‰çš„éŸ³å¯ä»¥â€œå¼±å¤„ç†â€ æŽ¥ä¸‹æ¥å°±åˆ° B æ®µäº†ï¼Œä¸ªäººæ„Ÿè§‰ B æ®µç®€å•ä¸€äº›ï¼ŒåŽé¢å‡ ä¸ªå°èŠ‚åœ¨è°±å­çš„ç¬¬äºŒé¢ï¼š B æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬ä¸ƒå°èŠ‚ 1 å¼¦çš„å¤„ç†æ–¹å¼å¯ä»¥ä¸Ž A æ®µç¬¬äºŒå°èŠ‚ç±»ä¼¼ç¬¬å…«å°èŠ‚é£ŸæŒ‡å°æ¨ªæŒ‰ 1-4 å¼¦ 5 å“ æŽ¥ç€æ˜¯ C æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬äºŒå°èŠ‚éœ€è¦å·¦æ‰‹æœ‰ä¸€å®šçš„â€œåŠ›é‡â€æ‰èƒ½æŒ‰å¥½æ•´ä¸ª C æ®µæœ‰å¤šå¤„éœ€è¦ç”¨ç¶éŸ³æŠ€å·§ï¼Œæ‰èƒ½æ›´å¥½çš„è¡¨è¾¾æ›²å­æƒ…æ„Ÿçš„å˜åŒ–C æ®µå±žäºŽç»“å°¾æ®µï¼ŒåŒ…æ‹¬ä¸¤ä¸ªç»“å°¾éƒ¨åˆ†ï¼Œè°±å­ä¸Šæœ‰æ ‡è®° 1 å’Œ 2ï¼Œæ³¨æ„åŒºåˆ† åŽŸæ›²ï¼š æ¸£ç¿»ï¼ˆè¿˜åœ¨é…é…¿ä¹‹ä¸­ï¼‰ï¼š]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>FingerStyle</tag>
        <tag>Guitar</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_07-å›¾ï¼ˆä¸­ï¼‰]]></title>
    <url>%2F2020%2F08%2F28%2FZJU-DS-07-%E5%9B%BE%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨è¯¾ç¨‹ä¸»è¦åŒ…æ‹¬å›¾è®ºä¸­æœ€çŸ­è·¯å¾„çš„é—®é¢˜å’Œæœ‰å…³æ ‘çš„ä¹ é¢˜è¯¾ï¼Œä¹ é¢˜è¯¾ç¬”è®°æ·»åŠ åˆ°å‰é¢å¯¹åº”é¢˜ç›®çš„æ‰€åœ¨çš„æ–‡ç« ä¸­äº†ã€‚ æœ€çŸ­è·¯å¾„é—®é¢˜çš„æŠ½è±¡ä¸€èˆ¬è€Œè¨€ï¼Œæœ€çŸ­è·¯å¾„é—®é¢˜éƒ½å¯æŠ½è±¡ä¸ºï¼šåœ¨ç½‘ç»œä¸­ï¼Œæ±‚ä¸¤ä¸ªä¸åŒé¡¶ç‚¹ä¹‹é—´çš„æ‰€æœ‰è·¯å¾„ä¸­ï¼Œè¾¹çš„æƒå€¼ä¹‹å’Œæœ€å°çš„é‚£ä¸€æ¡è·¯å¾„ï¼Œä»Žè€Œï¼Œæœ‰ï¼š è¿™æ¡è·¯å¾„å°±æ˜¯ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰ ç¬¬ä¸€ä¸ªé¡¶ç‚¹ä¸ºæºç‚¹ï¼ˆSourceï¼‰ æœ€åŽä¸€ä¸ªé¡¶ç‚¹ä¸ºç»ˆç‚¹ï¼ˆDestinationï¼‰ æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œæœ€çŸ­è·¯å¾„é—®é¢˜åˆå¯ä»¥åˆ†åˆ«ä¸¤ç±»ï¼š å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼šä»ŽæŸå›ºå®šæºç‚¹å‡ºå‘ï¼Œæ±‚å…¶åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œæ ¹æ®å›¾çš„ç±»åž‹ä¸åŒåˆå¯ä»¥åˆ†ä¸ºï¼š ï¼ˆæœ‰å‘ï¼‰æ— æƒå›¾ ï¼ˆæœ‰å‘ï¼‰æœ‰æƒå›¾ å¤šæºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼šæ±‚ä»»æ„ä¸¤é¡¶ç‚¹é—´çš„æœ€çŸ­è·¯å¾„ æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•è€ƒè™‘è¿™ç±»é—®é¢˜æ—¶ï¼Œæœ‰ä¸€ä¸ªåŽŸåˆ™ï¼Œå³ï¼šæŒ‰ç…§é€’å¢žï¼ˆéžé€’å‡ï¼‰çš„é¡ºåºæ‰¾å‡ºå„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯ã€‚ä»¥ä¸‹å›¾ä¸­çš„â€œå›¾â€ä¸ºä¾‹ï¼š æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜æœ¬è´¨ä¸Šå°±æ˜¯ BFSï¼Œå‡è®¾æºç‚¹ä¸º$v_3$ï¼ŒæŒ‰ç…§ BFS çš„æ€è·¯ï¼Œé€šè¿‡$v_3$å¯ä»¥ç›´æŽ¥è®¿é—®$v_1$å’Œ$v_2$ï¼Œè¿™ç®—æ˜¯ä¸Ž$v_3$çš„è·ç¦»ä¸º 1 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹ï¼Œä¾æ¬¡ç±»æŽ¨ï¼Œä¸Ž$V_3$è·ç¦»ä¸º 2 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹å°±æ˜¯$v_2$å’Œ$v_4$ï¼Œä¸Ž$v_3$è·ç¦»ä¸º 3 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹å°±æ˜¯$v_5$å’Œ$v_7$ã€‚ æŽ¥ç€åœ¨æŒ‰ç…§ BFS ç®—æ³•å†™å‡ºå…¶ä¼ªç ç®—æ³•ï¼š12345678910111213void Unweighted(Vertex S) &#123; Enqueue(S, Q); while(!IsEmpty(Q)) &#123; V = Dequeue(Q); for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(dist[W] == -1) &#123; dist[W] = dist[V] + 1; path[W] = V; Enqueue(W, Q); &#125; &#125; &#125;&#125; ä¸Ž BFS ç®—æ³•ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œç”¨ dist æ•°ç»„æ¥ä¿å­˜æºç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„è·ç¦»ï¼Œç”¨ path æ•°ç»„ä¿å­˜äº†æºç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„è·¯å¾„ã€‚è¿™é‡Œå¤šè¯´ä¸€å¥ï¼Œè‹¥æƒ³çŸ¥é“è·¯å¾„çš„è·ç¦»æ˜¯å¤šå°‘ç›´æŽ¥è®¿é—® dist æ•°ç»„å³å¯ï¼›è‹¥è¦çŸ¥é“è·¯å¾„æ˜¯ä»€ä¹ˆï¼Œé€’å½’è¾“å‡º path æ•°ç»„å³å¯ï¼ˆéžé€’å½’è¾“å‡ºçš„é¡ºåºæ˜¯é€†è¿‡æ¥çš„ï¼‰ã€‚ æœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„æœ‰æƒå›¾çš„æœ€çŸ­è·¯å¾„ä¸Žæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„æœ€æ˜¾è‘—çš„åŒºåˆ«å°±æ˜¯ï¼Œæœ‰æƒå›¾çš„æœ€çŸ­è·¯å¾„ä¸ä¸€å®šæ˜¯è¿›è¿‡é¡¶ç‚¹æœ€å°‘çš„è·¯å¾„ï¼Œè€Œæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„åˆ™ä¸€å®šæ˜¯ç»è¿‡é¡¶ç‚¹æœ€å°‘çš„è·¯å¾„ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œ$v_1 -&gt; v_4 -&gt; v_6$ä¸Ž$v_1 -&gt; v_4 -&gt; v_7 -&gt; v_6$ç›¸æ¯”ï¼Œç¬¬äºŒæ¡è·¯å¾„è¦æ›´çŸ­ä¸€ç‚¹ã€‚åŒæ ·ï¼Œå½“å›¾å†…å­˜åœ¨è´Ÿæƒå€¼çš„è¾¹æ—¶ï¼Œå°±å¯èƒ½äº§ç”Ÿè´Ÿå€¼åœˆï¼ˆNegative-cost cycleï¼‰ï¼Œå¦‚ä¸‹å›¾ï¼šæ­¤æ—¶å•æºæœ€çŸ­è·¯å¾„çš„ç®—æ³•æ˜¯æ— æ³•å¾—åˆ°æ­£ç¡®ç»“æžœçš„ï¼Œè¿™é‡Œä¸æ·±å…¥è®¨è®ºè¿™ç±»é—®é¢˜ã€‚ å›žè¿‡å¤´æ¥ï¼Œæœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ä¸Žæ— æƒå›¾çš„å•æºæœ€çŸ­è·¯ç®—æ³•æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯äºŒè€…çš†æ˜¯æŒ‰ç…§é€’å¢žçš„é¡ºåºæ‰¾å‡ºåˆ°å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè€Œæœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ä¹Ÿå«Dijkstraç®—æ³•ã€‚ Dijkstra ç®—æ³•Dijkstra ç®—æ³•æ˜¯å…¸åž‹çš„è´ªå¿ƒç®—æ³•ï¼Œç›´æŽ¥æè¿°å…¶è¿‡ç¨‹æœ‰ç‚¹éº»çƒ¦ï¼Œå…ˆçœ‹ä¸‹é¢çš„ä¼ªç ç®—æ³•æè¿°ï¼š123456789101112131415void Dijkstra(Vertex S) &#123; while(1) &#123; v = æœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…; if(è¿™æ ·çš„ v ä¸å­˜åœ¨) break; collected[v] = true; for(v çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ w)&#123; if(collected[w] == false) &#123; if(dist[v] + &lt;v, w&gt;çš„æƒå€¼ &lt; dist[w]) &#123; dist[w] = dist[v] + &lt;v, w&gt;çš„æƒå€¼; path[w] = v; &#125; &#125; &#125; &#125;&#125; éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ä¸èƒ½è§£å†³æœ‰è´Ÿè¾¹çš„æƒ…å†µ æ€»æ˜¯æŒ‰ç…§é¡¶ç‚¹åºå·é€’å¢žï¼ˆéžé€’å‡ï¼‰çš„é¡ºåºæ¥å¼€å§‹ç®—æ³• æ¯æ¬¡æ”¶å½•ä¸€ä¸ªé¡¶ç‚¹ w åŽè¦æ›´æ–°ä»Ž v åˆ° w çš„æœ€çŸ­è·¯å¾„çš„æƒå€¼å’Œ æ¯æ¬¡æ”¶å½•ä¸€ä¸ªé¡¶ç‚¹ w åŽå¯èƒ½ä¼šå½±å“ v åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œæ‰€ä»¥è¦å¯¹ v çš„é‚»æŽ¥ç‚¹è¿›è¡Œè®¿é—® å¦‚ä½•ä»Žæœªæ”¶å½•é¡¶ç‚¹ä¸­æ‰¾å‡º dist æœ€å°è€…æ˜¯å½±å“æ­¤ç®—æ³•æ—¶é—´å¤æ‚åº¦çš„å…³é”®ï¼Œæ ¹æ®æ–¹æ³•çš„ä¸åŒï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š ç›´æŽ¥æ‰«ææ‰€æœ‰æœªæ”¶å½•é¡¶ç‚¹ï¼Œæ¯æ¬¡åœ¨æ‰¾å‡ºæ‰€æœ‰é¡¶ç‚¹ä¸­ dist æœ€å°çš„é¡¶ç‚¹ï¼Œç„¶åŽå†è®¿é—®å½“å‰è¿™ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æŽ¥ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(|V^2| + |E|)$ï¼Œè¿™ç§æ–¹æ³•é€‚åˆç¨ å¯†å›¾ å¦‚æžœæ˜¯å°† dist å­˜åœ¨æœ€å°å †ä¸­ï¼Œé‚£ä¹ˆæ‰¾å‡ºæ‰€æœ‰é¡¶ç‚¹ä¸­ dist æœ€å°çš„é¡¶ç‚¹æ‰€è€—è´¹çš„æ—¶é—´å°±æ˜¯$O(log|V|)$ï¼Œä½†æ˜¯æœ€åŽè¿˜å¾—å°†è¿™ä¸ªå€¼æ’å…¥åˆ°å †ä¸­ï¼Œä¸”å¯¹äºŽä¸€ä¸ªè¿žé€šçš„å›¾è€Œè¨€ï¼Œè¾¹æ•°è‚¯å®šå¤§äºŽç­‰äºŽé¡¶ç‚¹æ•°ï¼Œæ‰€ä»¥å…¶æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|)$ï¼Œè¿™ç§æ–¹æ³•é€‚åˆç¨€ç–å›¾ ä¸‹é¢å†ä»¥ä¸‹å›¾ä¸­çš„å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€éç®—æ³•ã€‚ é¦–å…ˆï¼Œdist å’Œ path æ•°ç»„éƒ½è¦å…ˆåˆå§‹åŒ–ï¼š index 1 2 3 4 5 6 7 dist âˆž âˆž âˆž âˆž âˆž âˆž âˆž path -1 -1 -1 -1 -1 -1 -1 æ³¨æ„ä¸Šé¢ä¸‹æ ‡æ˜¯ä»Ž 1 å¼€å§‹çš„ï¼Œä¸Žé¡¶ç‚¹ä¸‹æ ‡å¯¹åº”å…å¾—æžæ··ï¼Œå½“ç„¶ä»Ž 0 å¼€å§‹ä¹Ÿæ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†åŽé¢åˆ†æžé—®é¢˜æ—¶å¯èƒ½æžæ··æ·†ã€‚ æŽ¥ç€ä»Ž $v_1$ å¼€å§‹ï¼Œåœ¨è®¿é—®$v_1$çš„é‚»æŽ¥ç‚¹ä¹‹å‰ï¼Œéœ€è¦å…ˆå°† dist[1] çš„å€¼ä¿®æ”¹ä¸º 0ï¼Œå› ä¸ºå…¶è‡ªèº«åˆ°è‡ªèº«çš„è·ç¦»æ˜¯ 0ï¼Œç„¶åŽè®¿é—®$v_1$çš„é‚»æŽ¥ç‚¹ï¼Œå¹¶æ›´æ–°è¿™äº›é‚»æŽ¥ç‚¹å¯¹åº”çš„ dist å’Œ path æ•°ç»„çš„å€¼ï¼ˆ$v_1$çš„é‚»æŽ¥ç‚¹åªæœ‰$v_2$å’Œ$v_4$ï¼‰ï¼Œæ­¤æ—¶ dist ä¸Ž pathæ•°ç»„çš„å€¼ä¸ºï¼š index 1 2 3 4 5 6 7 dist 0 2 âˆž 1 âˆž âˆž âˆž path -1 1 -1 1 -1 -1 -1 æ­¤æ—¶åˆå›žåˆ°å¾ªçŽ¯ä½“çš„å¼€å¤´éƒ¨åˆ†ï¼Œæ‰¾å‡º dist ä¸­æœ€å°çš„ä¸”æœªè¢«è®¿é—®è¿‡çš„ï¼Œæ˜¾ç„¶æ˜¯$v_4$ï¼Œç„¶åŽåˆ©ç”¨$v_4$æ¥æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 å†ç»§ç»­ä¸‹ä¸€è½®å¾ªçŽ¯ï¼Œæ­¤æ—¶é€‰å‡ºçš„é¡¶ç‚¹å°±æ˜¯$v_2$ï¼Œåœ¨æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 ä¸Šé¢è¡¨æ ¼ä¸­çš„å€¼ä¸Žç¬¬äºŒæ¬¡å¾ªçŽ¯æ²¡æœ‰å˜åŒ–ï¼ŒåŽŸå› åœ¨äºŽé€šè¿‡$v_2$å¹¶ä¸èƒ½ä½¿$v_1$åˆ°è¾¾$v_4$å’Œ$v_5$çš„è·ç¦»å˜å°ï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸ç”¨æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ã€‚ å†ç»§ç»­ä¸‹ä¸€è½®å¾ªçŽ¯ï¼Œæ­¤æ—¶é€‰å‡ºçš„é¡¶ç‚¹å°±æ˜¯$v_3$ï¼ˆæ³¨æ„æ˜¯æŒ‰é€’å¢žé¡ºåºï¼Œæ‰€ä»¥ä¸æ˜¯$v_5$ï¼‰ï¼Œæ­¤æ—¶é€šè¿‡$v_3$å¯ä»¥ä½¿$v_1$åˆ°$v_6$çš„è·ç¦»å˜å°ï¼Œæ‰€ä»¥æ›´æ–°æ•°ç»„ä¸­çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 8 5 path -1 1 4 1 4 3 4 æŽ¥ç€é€‰å®š$v_5$ï¼ŒæŒ‰ç…§åŒæ ·çš„è¿‡ç¨‹ï¼Œæ•°ç»„å€¼ä¹Ÿä¸ç”¨æ›´æ–°ã€‚ åœ¨é€‰å®š$v_7$ï¼Œæ­¤æ—¶å¯ä»¥ä½¿$v_1$åˆ°$v_6$çš„è·ç¦»å˜å°ï¼Œæ›´æ–°æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 6 5 path -1 1 4 1 4 7 4 æœ€åŽä¸€ä¸ªé¡¶ç‚¹æ˜¯$v_6$ï¼Œä½†$v_6$æ²¡æœ‰é‚»æŽ¥ç‚¹ï¼ˆå°±ç®—æœ‰ï¼Œæ­¤æ—¶å…¶ä»–é¡¶ç‚¹ä¹Ÿéƒ½è¢«è®¿é—®è¿‡äº†ï¼‰ï¼Œæ‰€ä»¥å¾ªçŽ¯ä¼šç»“æŸã€‚ æ³¨æ„ä¸Šè¿°è¿‡ç¨‹ä¸Žå§¥å§¥è®²çš„ç•¥å¾®æœ‰ç‚¹ä¸ä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯å¼€å¤´åŠ å…¥$v_1$åŽï¼Œæ•°ç»„å€¼éƒ½æ˜¯å¾ªçŽ¯ä½“å†…æ›´æ–°çš„ï¼›è€Œå§¥å§¥è®²çš„æ˜¯åœ¨å¾ªçŽ¯å¼€å§‹ä¹‹å‰å°±å·²ç»å…¨éƒ¨æ›´æ–°å¥½äº†ã€‚å®žé™…ä¸Šï¼Œåœ¨å¾ªçŽ¯ä½“å†…æ›´æ–°è¿˜è¦æ›´åŠ æ–¹ä¾¿ä¸€ç‚¹ã€‚ æœ‰æƒå›¾çš„å¤šæºæœ€çŸ­è·¯å¾„è€ƒè™‘æœ‰æƒå›¾çš„å¤šæºæœ€çŸ­è·¯å¾„æ—¶ï¼Œæ¯«æ— ç–‘é—®ä¼šæƒ³åˆ°ç›´æŽ¥å°†å•æºæœ€çŸ­è·¯å¾„ç®—æ³•è°ƒç”¨$|V|$ï¼ˆå› ä¸ºé¡¶ç‚¹ä¸ªæ•°æ˜¯$|V|$ï¼‰ï¼Œæ­¤æ—¶ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$ T = O(|V^3| + |E| \times |V|)$ï¼Œæ˜¾ç„¶å¦‚æžœæ˜¯ç¨€ç–å›¾ï¼Œæ•ˆçŽ‡è¾ƒé«˜ã€‚ é‚£ç¢°åˆ°ç¨ å¯†å›¾æ€Žä¹ˆåŠžå‘¢ï¼Ÿç­”æ¡ˆæ˜¯ç”¨ Floyd ç®—æ³• Floyd ç®—æ³•Floyd ç®—æ³•ä¸Ž Dijkstra ç®—æ³•æœ‰ç‚¹ç±»ä¼¼ï¼Œä½†æ˜¯å…¶å€ŸåŠ©äº†æ•°å­¦å½’çº³æ³•ï¼Œç›¸æ¯” Dijkstra ç®—æ³•ï¼Œä»£ç è¦ç®€å•ä¸€ç‚¹ã€‚ æ³¨æ„ Floyd ç®—æ³•åªèƒ½ç”¨äºŽé‚»æŽ¥çŸ©é˜µï¼Œå®ƒæœ¬èº«ä¹Ÿæ˜¯é€šè¿‡é‚»æŽ¥çŸ©é˜µæ¥æ›´æ–°æœ€çŸ­è·¯å¾„çš„æƒå€¼ä¹‹å’Œçš„ï¼Œå½“$D^{k-1}$å·²ç»å®Œæˆï¼Œé€’æŽ¨åˆ°$D^k$æ—¶ï¼Œä¸»è¦ç†è§£ä¸¤ä¸ªç‚¹ï¼š è‹¥ k ä¸åœ¨æœ€çŸ­è·¯å¾„$i -&gt; \dots -&gt; j$ä¹‹é—´ï¼Œåˆ™$D^k = D^{k-1}$ è‹¥ k åœ¨æœ€çŸ­è·¯å¾„å¾„$i -&gt; \dots -&gt; j$ä¹‹é—´ï¼Œåˆ™è¯¥è·¯å¾„å¿…å®šç”±ä¸¤æ®µæœ€çŸ­è·¯å¾„ç»„æˆï¼š$D^k[i][j] = D^{k-1}[i][k] + D^{k-1}[k][j]$ å…¶ä¼ªç æè¿°ä¸ºï¼š12345678910111213141516171819void Floyd() &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; D[i][j] = G[i][j]; // initialization path[i][j] = -1; &#125; &#125; // notice these loop variables for(k = 0; k &lt; N; k++) &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(D[i][k] + D[k][j] &lt; D[i][j]) &#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125;&#125; Homework07-4 å“ˆåˆ©Â·æ³¢ç‰¹çš„è€ƒè¯•è¿™é“é¢˜ç›®æ˜¯å…¸åž‹çš„å¤šæºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œç›´æŽ¥ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨å›¾ï¼Œç„¶åŽè°ƒç”¨ Folyd ç®—æ³•å³å¯å¾—åˆ°æ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ã€‚ä½†è¦æ³¨æ„è¿™é“é¢˜ç›®çš„æœ€ä¼˜è§£æ˜¯é€‰æ‹©å‡ºåˆ°å…¶ä»–å„é¡¶ç‚¹çš„ç»¼åˆè·ç¦»æœ€çŸ­çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´å„ä¸ªé¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸­æœ€é•¿çš„é‚£æ¡æœ€çŸ­è·¯å¾„çš„æœ€å°å€¼è€…å°±æ˜¯æœ€ä¼˜è§£ï¼Œå¥½å§ï¼Œå¾ˆæ‹—å£ã€‚æ³¨æ„ï¼Œå¹¶ä¸èƒ½ä»¥æœ€çŸ­è·¯å¾„ä¹‹å’Œæœ€å°è€…ä¸ºæœ€ä¼˜è§£ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚è¿™é“é¢˜çš„ä»£ç å†™çš„æ¯”è¾ƒç®€å•ï¼Œæ€è·¯ä¸Žä¸Šè¿°ä¸€è‡´ï¼Œå¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;int n, m, G[maxn][maxn], dist[maxn][maxn];void floyd() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; dist[i][j] = G[i][j]; &#125; &#125; for(int k = 1; k &lt;= n; k++) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(dist[i][k] + dist[k][j] &lt; dist[i][j] &amp;&amp; i != j) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125;&#125;void findanimal() &#123; floyd(); int mindist = inf; int animal; for(int i = 1; i &lt;= n; i++) &#123; int maxdist = 0; for(int j = 1; j &lt;= n; j++) &#123; if(i != j &amp;&amp; dist[i][j] &gt; maxdist) maxdist = dist[i][j]; &#125; if(maxdist == inf) &#123; cout &lt;&lt; 0; return; &#125; if(mindist &gt; maxdist) &#123; mindist = maxdist; animal = i; &#125; &#125; cout &lt;&lt; animal &lt;&lt; ' ' &lt;&lt; mindist;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2]; G[v2][v1] = G[v1][v2]; &#125; findanimal(); return 0;&#125;/*samples:in:6 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80out:4 70*/ 07-5 Saving James Bond - Hard Versionè¿™é“é¢˜ç›®æ˜¯ä¸Šå‘¨é¢˜ç›®çš„åŠ å¼ºç‰ˆï¼Œé¢˜ç›®å¤§æ„ä¸Žå§¥å§¥åœ¨è¯¾ä¸Šå¼€å¤´è®²çš„ä¸€æ ·ï¼Œä¸ä»…è¦åˆ¤æ–­æ˜¯å¦å¯ä»¥åˆ°è¾¾å²¸è¾¹ï¼Œè¿˜è¦è¾“å‡ºå¯¹åº”çš„è·¯å¾„ã€‚ è§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯å°±æ˜¯åˆ©ç”¨ BFS ç®—æ³•æ¥æ‰¾æœ€çŸ­è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ã€‚å¯èƒ½æœ‰çš„åŒå­¦ä¼šè§‰å¾—é¡¶ç‚¹ä¹‹å‰çš„è·ç¦»ä¸å°±æ˜¯è¾¹çš„æƒå—ï¼Ÿå…¶å®žä¸ç„¶ï¼Œè¿™ä¸ªé¢˜ç›®çš„è¾¹æƒä¸æ˜¯ç›´æŽ¥ç»™å‡ºï¼Œéœ€è¦è®¡ç®—å¾—åˆ°ï¼›è€Œä¸”ï¼Œè¿™ä¸ªé¢˜ç›®çš„æœ€ä¼˜è§£ä¸æ˜¯è¦æ±‚æœ€çŸ­è·¯å¾„çš„æƒå€¼æœ€å°ï¼Œè€Œæ˜¯è¦æ±‚è·³çš„æ¬¡æ•°æœ€å°‘ï¼Œæ‰€ä»¥ï¼Œåªéœ€è¦ç”¨è®¡ç®—å‡ºè¾¹æƒç„¶åŽåˆ¤æ–­æ˜¯å¦å¯è¾¾å³å¯ã€‚ è¦æ±‚å¾—å…·ä½“ç»è¿‡äº†å‡ è·³åˆ°è¾¾å²¸è¾¹ï¼Œç¨å¾®æœ‰ç‚¹éº»çƒ¦ï¼Œä½†å¯ä»¥å€Ÿé‰´ä¸Šç¯‡æ–‡ç« å…­åº¦ç©ºé—´é‚£ä¸ªé¢˜ç›®çš„æ€è·¯ï¼Œåœ¨å¼€å§‹ BFS ä¹‹å‰å…ˆè®°å½•æ˜¯å“ªä¸ªé¡¶ç‚¹ï¼Œåœ¨æ¯æ¬¡å¾ªçŽ¯ç»“æŸä¹‹å‰ï¼Œå°†å½“å‰åŠ å…¥è·¯å¾„çš„ç»“ç‚¹ä¸Žè®°å½•çš„ç»“ç‚¹æ¯”å¯¹ï¼Œå¦‚æžœç›¸åŒï¼Œé‚£ä¹ˆè·³æ­¥æ•°åŠ  1ï¼Œå¹¶å°†æ­¤ç»“ç‚¹è®°å½•åŽç”¨ä½œä¸‹è½®å¾ªçŽ¯åˆ¤æ–­ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node &#123; int x, y;&#125; coords[maxn];int n, d, path[maxn];bool vis[maxn] = &#123;false&#125;;int firstjump(int v) &#123; int dis = d - sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) + 7.5; if(dis &gt; 0) return dis; else return 0;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125;bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool cmp(int a, int b) &#123; return firstjump(a) &gt; firstjump(b);&#125;void printpath(int inde) &#123; if(path[inde] == -1) &#123; cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl; return; &#125; printpath(path[inde]); cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl;&#125;void save007() &#123; if(d &gt;= 50 - 15 / 2) &#123; cout &lt;&lt; 1; return; &#125; else &#123; int order[maxn]; queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) &#123; order[i] = i; path[i] = -1; &#125; sort(order, order + n, cmp); int last, tail; for(int i = 0; i &lt; n; i++) &#123; if(firstjump(order[i])) &#123; q.push(order[i]); vis[order[i]] = true; last = order[i]; &#125; &#125; int step = 2; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(issafe(front)) &#123; cout &lt;&lt; step &lt;&lt; endl; printpath(front); return; &#125; for(int i = 0; i &lt; n; i++) &#123; if(!vis[i] &amp;&amp; jump(front, i)) &#123; q.push(i); path[i] = front; vis[i] = true; tail = i; &#125; &#125; if(last == front) &#123; step++; last = tail; &#125; &#125; if(q.empty()) cout &lt;&lt; 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; coords[i].x &gt;&gt; coords[i].y; &#125; save007(); return 0;&#125;/*samples:in:17 1510 -2110 21-40 1030 -5020 4035 100 -10-25 2240 -40-30 30-10 220 1125 2125 1010 1010 35-30 10out:40 1110 2110 35in:4 13-12 1212 12-12 -1212 -12out:0in:1 5030 30out:1*/ 07-6 æ—…æ¸¸è§„åˆ’è¿™é“é¢˜ç›®æ˜¯ä¸­æ–‡çš„ï¼Œè¯»èµ·æ¥æ²¡é‚£ä¹ˆè´¹åŠ²äº†ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“è®©äººçœ‹å‡ºæ˜¯å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚ é¢˜ç›®å·²ç»ç»™å®šäº†æºç‚¹å’Œç»ˆç‚¹ï¼Œæ‰€ä»¥ç”¨æºç‚¹ç›´æŽ¥å¥— Dijkstra ç®—æ³•å³å¯å¾—åˆ°å…¶åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ ä½†è¿™ä¸ªé¢˜ç›®çš„éš¾ç‚¹åœ¨äºŽè¦æ ¹æ®é¢˜ç›®ç»™å®šçš„é€‰è§£æ–¹å¼æ¥ç¡®å®šæœ€ä¼˜è§£ï¼Œå³ï¼š è·¯å¾„æœ€çŸ­ æœ€ä¾¿å®œ æ‰€ä»¥éœ€è¦ä¿®æ”¹ä¸€ä¸‹ Dijkstra ç®—æ³•ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* notes: this problem is similar to the Advanced Level 1030. */#include &lt;iostream&gt;using namespace std;const int inf = 0x3fffffff;const int maxn = 500 + 5;int n, m, src, dst, G[maxn][maxn], cost[maxn][maxn];int d[maxn], c[maxn];bool vis[maxn] = &#123;false&#125;;void dijkstra(int src) &#123; fill(d, d + maxn, inf); d[src] = 0; c[src] = 0; for(int i = 0; i &lt; n; i++) &#123; int v = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; d[j] &lt; min) &#123; v = j; min = d[j]; &#125; &#125; if(v == -1) return; vis[v] = true; for(int w = 0; w &lt; n; w++) &#123; if(!vis[w] &amp;&amp; G[v][w] != inf) &#123; if(d[v] + G[v][w] &lt; d[w]) &#123; d[w] = d[v] + G[v][w]; c[w] = c[v] + cost[v][w]; &#125; else if(d[v] + G[v][w] == d[w]) &#123; if(c[v] + cost[v][w] &lt; c[w]) c[w] = c[v] + cost[v][w]; &#125; &#125; &#125; &#125;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2] &gt;&gt; cost[v1][v2]; G[v2][v1] = G[v1][v2], cost[v2][v1] = cost[v1][v2]; &#125; dijkstra(src); cout &lt;&lt; d[dst] &lt;&lt; ' ' &lt;&lt; c[dst]; return 0;&#125;/*samples:in:4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20out:3 40*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_06-å›¾ï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F08%2F27%2FZJU-DS-06-%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯å›¾ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿå›¾åˆæœ‰é‚£äº›åŸºæœ¬çš„æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ ä»€ä¹ˆæ˜¯å›¾å›¾å¸¸ç”¨æ¥å»ºç«‹å¤šå¯¹å¤šçš„å…³ç³»ï¼Œå¦‚ç¤¾äº¤ç½‘ç»œç­‰ã€‚é‚£ä¹ˆç”¨ä»€ä¹ˆæ¦‚å¿µæ¥è¯´æ˜Žè¿™äº›å…³ç³»å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯â€œé¡¶ç‚¹â€è·Ÿâ€œè¾¹â€ã€‚å›¾çš„æž„æˆåªæœ‰ä¸¤ç§ï¼šé¡¶ç‚¹å’Œè¾¹ï¼ŒäºŒè€…å³æ˜¯ç”¨æ¥è¡¨ç¤ºå…³ç³»çš„æ¦‚å¿µã€‚ é¡¶ç‚¹ä¸€ä¸ªå›¾å†…è‚¯å®šä¸æ­¢ä¸€ä¸ªé¡¶ç‚¹ï¼ˆVertexï¼‰ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨ ï¼¶ æ¥è¡¨ç¤ºé¡¶ç‚¹é›†åˆ è¾¹åŒæ ·ï¼Œä¸€ä¸ªå›¾å†…è‚¯å®šä¸æ­¢ä¸€æ¡è¾¹ï¼ˆEdgeï¼‰ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨ E æ¥è¡¨ç¤ºè¾¹çš„é›†åˆã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾åˆ†ä¸ºæœ‰å‘å›¾ä¸Žæ— å‘å›¾ï¼Œæ‰€ä»¥è¾¹åœ¨è¿™ä¸¤ç§å›¾ä¸­åˆ†åˆ«ç§°ä½œæœ‰å‘è¾¹ï¼ˆå•è¡Œçº¿ï¼Œå¦‚$&lt;v_1, v_2&gt;$ï¼‰ä¸Žæ— å‘è¾¹ï¼ˆ$(v1, v2)$ï¼‰ã€‚ å¦å¤–ï¼Œåœ¨å›¾å†…æ˜¯ä¸è€ƒè™‘é‡è¾¹å’Œè‡ªå›žè·¯çš„ã€‚ åŸºæœ¬æœ¯è¯­ä¸Žå›¾ç›¸å…³çš„åŸºæœ¬æœ¯è¯­æœ‰å¾ˆå¤šï¼Œç¢°è§ä¸€ä¸ªè®°å½•ä¸€ä¸ªï¼š æ— å‘å›¾ï¼Œå›¾å†…æ‰€æœ‰çš„è¾¹éƒ½æ˜¯æ— å‘è¾¹ï¼Œå¯¹åº”çš„ï¼Œè‹¥å›¾å†…æ‰€æœ‰çš„è¾¹éƒ½æ˜¯æœ‰å‘è¾¹ï¼Œé‚£è¿™ä¸ªå›¾å°±æ˜¯æœ‰å‘å›¾ æ¯ä¸€æ¡è¾¹ä¸Šèµ‹äºˆæƒå€¼åŽï¼Œé‚£ä¹ˆç§°è¿™ä¸ªå›¾å«åšâ€œç½‘ç»œâ€ï¼Œè¿™ä¸ªæ¦‚å¿µä¸Žäº’è”ç½‘ç»œæ˜¯ä¸ä¸€æ ·çš„ å®Œå…¨å›¾ï¼Œå›¾å†…æ‰€æœ‰é¡¶ç‚¹ï¼Œä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½æœ‰è¾¹ è¿žé€šï¼Œå¦‚æžœä»Ž V åˆ° W å­˜åœ¨ä¸€æ¡ï¼ˆæ— å‘ï¼‰è·¯å¾„ï¼Œåˆ™ç§° V å’Œ W æ˜¯è¿žé€šçš„ è·¯å¾„ï¼ŒV åˆ° W çš„è·¯å¾„æ˜¯ä¸€ç³»åˆ—é¡¶ç‚¹${V, V_1, V_2, \dots, V_n, W}$çš„é›†åˆï¼Œå…¶ä¸­ä»»ä¸€å¯¹ç›¸é‚»é¡¶ç‚¹é—´éƒ½æœ‰å›¾ä¸­çš„è¾¹ã€‚è·¯å¾„çš„é•¿åº¦æ˜¯è·¯å¾„ç§çš„è¾¹æ•°ï¼ˆå¦‚æžœå¸¦æƒï¼Œåˆ™æ˜¯æ‰€æœ‰è¾¹çš„æƒé‡å’Œï¼‰ã€‚å¦‚æžœ V åˆ° W ä¹‹é—´çš„æ‰€æœ‰é¡¶ç‚¹éƒ½ä¸åŒï¼Œåˆ™ç§°ç®€å•è·¯å¾„ å›žè·¯ï¼Œèµ·ç‚¹ç­‰äºŽç»ˆç‚¹çš„è·¯å¾„ è¿žé€šå›¾ï¼Œå›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹å‡è¿žé€š è¿žé€šåˆ†é‡ï¼Œæ— å‘å›¾çš„æžå¤§è¿žé€šå­å›¾ï¼Œå…¶ä¸­â€œæžå¤§â€åŒ…å«ä¸‹é¢ä¸¤ä¸ªæ„æ€ï¼š æžå¤§é¡¶ç‚¹æ•°ï¼šå†åŠ ä¸€ä¸ªé¡¶ç‚¹å°±ä¸è¿žé€šäº† æžå¤§è¾¹æ•°ï¼šåŒ…å«å­å›¾ç§æ‰€æœ‰é¡¶ç‚¹ç›¸è¿žçš„æ‰€æœ‰è¾¹ æœ‰å‘å›¾ä¸­é¡¶ç‚¹ V å’Œ W ä¹‹é—´å­˜åœ¨åŒå‘è·¯å¾„ï¼Œåˆ™ç§° V å’Œ W æ˜¯å¼ºè¿žé€šçš„ å¼ºè¿žé€šå›¾ï¼Œæœ‰å‘å›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹å‡å¼ºè¿žé€š å¼ºè¿žé€šåˆ†é‡ï¼Œæœ‰å‘å›¾çš„æžå¤§å¼ºè¿žé€šå­å›¾ å¼±è¿žé€šå›¾ï¼Œå¦‚æžœä¸€ä¸ªéžå¼ºè¿žé€šå›¾ï¼Œå°†å…¶ä¸­æ‰€æœ‰çš„æœ‰å‘è¾¹æ”¹ä¸ºæ— å‘è¾¹ï¼Œå¾—åˆ°çš„å›¾ä¸ºè¿žé€šå›¾ï¼Œè¿™æ ·çš„å›¾ç§°ä¸ºå¼±è¿žé€šå›¾ å›¾çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šå›¾ï¼ˆGraphï¼‰æ•°æ®å¯¹è±¡é›†ï¼š$G(V, E)$ç”±ä¸€ä¸ªéžç©ºçš„æœ‰é™é¡¶ç‚¹é›†$V$å’Œä¸€ä¸ªæœ‰é™è¾¹é›†åˆ$E$ç»„æˆã€‚æ“ä½œé›†ï¼šæœ€å¤§å †$H âˆˆ MaxHeap$ï¼Œå…ƒç´ $item âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œæœ‰ï¼š Graph Create()ï¼Œå»ºç«‹å¹¶è¿”å›žç©ºå›¾ Graph InsertVertex(Graph G, Vertex v)ï¼Œå°† v æ’å…¥ G Graph InsertEdge(Graph G, Edge e)ï¼Œå°† e æ’å…¥ G void DFS(Graph G, Vertex v)ï¼Œä»Žé¡¶ç‚¹ v å‡ºå‘æ·±åº¦ä¼˜å…ˆéåŽ†å›¾ G void BFS(Graph G, Vertex v)ï¼Œä»Žé¡¶ç‚¹ v å‡ºå‘å®½åº¦ä¼˜å…ˆéåŽ†å›¾ G void ShortestPath(Graph G, Vertex v, int Dist[])ï¼Œè®¡ç®—å›¾ G ä¸­é¡¶ç‚¹ v åˆ°ä»»æ„å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·ç¦» void MST(Graph G)ï¼Œè®¡ç®—å›¾ G çš„æœ€å°ç”Ÿæˆæ ‘ å›¾çš„è¡¨ç¤ºå›¾çš„è¡¨ç¤ºæœ‰å¤šç§æ–¹æ³•ï¼ŒæŒ‰ç…§æ‰€è¦è§£å†³çš„é—®é¢˜çš„æ€§è´¨ï¼Œç”¨ç¬¦åˆé—®é¢˜æƒ…å†µçš„è¡¨ç¤ºæ–¹æ³•æ¥è¡¨ç¤ºå›¾ï¼Œåœ¨è§£å†³é—®é¢˜æ˜¯å¯ä»¥äº‹åŠåŠŸå€ï¼Œä¸‹é¢åªä»‹ç»ä¸¤ç§å¸¸è§çš„è¡¨ç¤ºæ–¹æ³•ã€‚ é‚»æŽ¥çŸ©é˜µé‚»æŽ¥çŸ©é˜µæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œç”¨æ•°ç»„ä¸‹æ ‡$0-N-1$ä»£è¡¨$N$ä¸ªé¡¶ç‚¹çš„ç¼–å·ï¼Œæ•°ç»„çš„å…ƒç´ çš„å€¼è¡¨ç¤ºä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ˜¯å¦æœ‰è¾¹ï¼ˆè‹¥æ˜¯ç½‘ç»œï¼Œé‚£ä¹ˆç›´æŽ¥å°†æ•°ç»„å…ƒç´ çš„å€¼ä¿®æ”¹ä¸ºå¯¹åº”çš„æƒå€¼å³å¯ï¼‰ï¼Œå³æœ‰ï¼š $G[i][j] =\begin{cases}1&amp; è‹¥&lt;v_i, v_j&gt;æ˜¯Gä¸­çš„è¾¹\\0&amp; å¦åˆ™\end{cases}$å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ— å‘å›¾çš„é‚»æŽ¥çŸ©é˜µä¸€å®šæ˜¯å¯¹ç§°çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ— å‘å›¾çš„é‚»æŽ¥çŸ©é˜µåªéœ€è¦å­˜å‚¨ä¸€åŠå³å¯ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦ç”¨åˆ°çŸ©é˜µçš„åŽ‹ç¼©å­˜å‚¨çŸ¥è¯†ã€‚ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µè¡¨ç¤ºå›¾çš„ä¼˜ç‚¹æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š ç›´è§‚ã€ç®€å•ã€ä¾¿äºŽç†è§£ æ–¹ä¾¿æ£€æŸ¥ä»»æ„ä¸€å¯¹é¡¶ç‚¹é—´æ˜¯å¦å­˜åœ¨è¾¹ æ–¹ä¾¿æ‰¾ä»»ä¸€é¡¶ç‚¹çš„æ‰€æœ‰â€œé‚»æŽ¥ç‚¹â€ï¼ˆæœ‰è¾¹ç›´æŽ¥ç›¸è¿žçš„é¡¶ç‚¹ï¼‰ æ–¹ä¾¿è®¡ç®—ä»»ä¸€é¡¶ç‚¹çš„â€œåº¦â€ï¼ˆè¿™é‡Œçš„åº¦çš„æ¦‚å¿µä¸Žæ ‘æ˜¯ç±»ä¼¼çš„ï¼Œä»Žè¯¥é¡¶ç‚¹å‘å‡ºçš„è¾¹æ•°ä¸ºâ€œå‡ºåº¦â€ï¼ŒæŒ‡å‘è¯¥ç‚¹çš„è¾¹æ•°ä¸ºâ€œå…¥åº¦â€ï¼‰ æ— å‘å›¾ï¼šå¯¹åº”è¡Œï¼ˆæˆ–åˆ—ï¼‰éž 0 å…ƒç´ çš„ä¸ªæ•° æœ‰å‘å›¾ï¼šå¯¹åº”è¡Œéž 0 å…ƒç´ çš„ä¸ªæ•°æ˜¯â€œå‡ºåº¦â€ï¼Œå¯¹åº”åˆ—éž 0 å…ƒç´ çš„ä¸ªæ•°æ˜¯â€œå…¥åº¦â€ é‚»æŽ¥çŸ©é˜µçš„ç¼ºç‚¹å¦‚ä¸‹ï¼š å­˜å‚¨ç¨€ç–å›¾ï¼ˆé¡¶ç‚¹å¤šè¾¹å¾ˆå°‘ï¼‰æ—¶æœ‰å¤§é‡æ— æ•ˆå…ƒç´ ï¼Œæžå¤§æµªè´¹ç©ºé—´ï¼Œä½†å­˜å‚¨ç¨ å¯†å›¾ï¼ˆç‰¹åˆ«æ˜¯å®Œå…¨å›¾ï¼‰å¾ˆåˆç®— ç»Ÿè®¡ç¨€ç–å›¾ä¸­çš„è¾¹æ•°æ•ˆçŽ‡å¾ˆä½Ž é‚»æŽ¥è¡¨ç”±äºŽé‚»æŽ¥çŸ©é˜µè¡¨ç¤ºç¨€ç–å›¾æµªè´¹ç©ºé—´ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜å¯¹åº”å‡ºçŽ°çš„å°±æ˜¯é‚»æŽ¥è¡¨ã€‚ åœ¨é‚»æŽ¥è¡¨ä¸­ï¼Œ$G[N]$ä¸ºæŒ‡é’ˆæ•°ç»„ï¼Œå¯¹åº”çŸ©é˜µæ¯ä¸€è¡Œä¸€ä¸ªé“¾è¡¨ï¼Œåªå­˜éž 0 å…ƒç´ ï¼Œæ³¨æ„é‚»æŽ¥è¡¨çš„è¡¨ç¤ºå¹¶ä¸å”¯ä¸€ã€‚ é‚»æŽ¥è¡¨çš„ç‰¹ç‚¹ï¼š æ–¹ä¾¿æ‰¾ä»»ä¸€é¡¶ç‚¹çš„æ‰€æœ‰â€œé‚»æŽ¥ç‚¹â€ èŠ‚çº¦ç¨€ç–å›¾çš„ç©ºé—´ï¼Œéœ€è¦ N ä¸ªå¤´æŒ‡é’ˆ å’Œ 2E ä¸ªç»“ç‚¹ï¼ˆæ¯ä¸ªç»“ç‚¹è‡³å°‘ 2 ä¸ªåŸŸï¼‰ æ–¹ä¾¿è®¡ç®—æ— å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„åº¦å’Œæœ‰å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„å‡ºåº¦ï¼Œä½†è®¡ç®—æœ‰å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„å…¥åº¦æ¯”è¾ƒéº»çƒ¦ï¼Œéœ€è¦æž„é€ â€œé€†é‚»æŽ¥è¡¨â€ï¼ˆå­˜å‚¨æŒ‡å‘è‡ªå·±çš„è¾¹ï¼‰æ‰èƒ½æ–¹ä¾¿çš„è®¡ç®—å…¥åº¦ ä¸ä¾¿äºŽæ£€æŸ¥ä»»æ„ä¸€å¯¹é¡¶ç‚¹æ˜¯å¦å­˜åœ¨è¾¹ å›¾çš„éåŽ†å›¾é‡Œé¢éåŽ†çš„æ¦‚å¿µä¸Žæ ‘æ˜¯ä¸€è‡´çš„ï¼Œå›¾çš„åŸºæœ¬éåŽ†æ–¹æ³•æœ‰ä¸¤ç§ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDepth First Searchï¼ŒDFSï¼‰å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreath First Searchï¼ŒBFSï¼‰ã€‚æ ¹æ®åº”ç”¨åœºæ™¯çš„ä¸åŒï¼Œä¸¤ç§éåŽ†ç®—æ³•åœ¨ä¸åŒåœºæ™¯ä¸‹è§£å†³é—®é¢˜çš„éš¾æ˜“ç¨‹åº¦ä¹Ÿä¸ä¸€æ ·ã€‚ DFSDFS ç®—æ˜¯æ ‘çš„å…ˆåºéåŽ†çš„æŽ¨å¹¿ï¼Œå…¶ä¼ªç ç®—æ³•ä¸ºï¼š123456void DFS(Vertex V) &#123; visited[V] = true; // æ­¤ç»“ç‚¹æ ‡è®°ä¸ºå·²è®¿é—® for( V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(!visited[W]) DFS(W); &#125;&#125; æ ¹æ®å›¾çš„å­˜å‚¨ç»“æž„çš„ä¸åŒï¼ŒDFS çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸åŒï¼š ä½¿ç”¨é‚»æŽ¥è¡¨å­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N + E)$ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N^2)$ BFSBFS ç®—æ˜¯æ ‘çš„å±‚åºéåŽ†çš„æŽ¨å¹¿ï¼Œå…¶ä¼ªç ç®—æ³•ä¸ºï¼š12345678910111213void BFS(Vertex V) &#123; visited[V] = true; Enqueu(V, Q); while(!Isempty(Q)) &#123; V = Dequeue(Q); for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(!visited[W]) &#123; visited[W] = true; Enqueue(W, Q); &#125; &#125; &#125;&#125; åŒæ ·ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼š ä½¿ç”¨é‚»æŽ¥è¡¨å­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N+E)$ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N^2)$ Homework06-1 åˆ—å‡ºè¿žé€šé›†é¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œåˆ†åˆ«ç”¨ DFS å’Œ BFSåˆ—å‡ºå…¶æ‰€æœ‰çš„è¿žé€šé›†ï¼ˆå…¶å®žå°±æ˜¯è¿žé€šåˆ†é‡ï¼Œå¿˜è®°æ˜¯å•¥äº†ï¼Œå¯ä»¥é‡æ–°çœ‹ä¸‹ä¸Šé¢çš„æ¦‚å¿µï¼‰å³å¯ã€‚ä¹‹å‰å§¥å§¥åœ¨è¯¾ä¸Šè®²è¿‡ï¼ŒæŒ‰ç…§ DFS çš„éåŽ†è¿‡ç¨‹ï¼Œä¸€ä¸ªæœ€å¤–å±‚çš„ DFS çš„è°ƒç”¨ï¼Œå°±ç›¸å½“äºŽè®¿é—®äº†è¿™ä¸ªå›¾çš„ä¸€ä¸ªè¿žé€šé›†ã€‚é‚£ä¹ˆä½¿ç”¨ DFS åœ¨è®¿é—®æ¯ä¸ªè¿žé€šé›†æ˜¯é¡ºä¾¿è¾“å‡ºå½“å‰æ‰€å¤„è¿žé€šé›†çš„æ‰€æœ‰å…ƒç´ å³å¯ï¼ŒåŒç†ï¼ŒBFS ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ ç”±äºŽå§¥å§¥è®²äº†å›¾çš„ä¸¤ç§å­˜å‚¨æ–¹æ³•ï¼Œç»§ç»­æŒ‰éƒ¨å°±ç­çš„æŒ‰ç…§å§¥å§¥ç»™å®šçš„ä»£ç æŽ¥ç€å¾€ä¸‹å†™ï¼š é‚»æŽ¥è¡¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* notes: The adjacency list is built by head pointer, so the traversal sequences is not same as sample output.Actually, the adjacency list is not unique, so the traversal sequences are also not unique.You can use the sort function to get the same result. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct AdjVNode* PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; WeightType Weight; PtrToAdjVNode Next;&#125;;typedef struct Vnode&#123; PtrToAdjVNode FirstEdge; DataType Data;&#125; AdjList[MaxVertexNum];typedef struct GNode* PtrToGNode;struct GNode&#123; int Nv; int Ne; AdjList G; &#125;;typedef PtrToGNode LGraph;LGraph CreateGraph(int VertexNum) &#123; Vertex V; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; Graph-&gt;G[V].FirstEdge = NULL; &#125; return Graph;&#125;void InsertEdge(LGraph Graph, Edge E) &#123; PtrToAdjVNode NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph() &#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125; void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; PtrToAdjVNode W; Visit(S); Visited[S] = true; for(W = Graph-&gt;G[S].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) DFS(Graph, W-&gt;AdjV, Visit, Visited); &#125;&#125;void BFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; Vertex V; Visit(S); Visited[S] = true; Queue[++rear] = S; while(front &lt; rear) &#123; V = Queue[++front]; PtrToAdjVNode W; for(W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) &#123; Visit(W-&gt;AdjV); Visited[W-&gt;AdjV] = true; Queue[++rear] = W-&gt;AdjV; &#125; &#125; &#125;&#125;void ListComponents(LGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; LGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/*samples:in:8 60 70 12 04 12 43 5out:&#123; 0 2 4 1 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 2 1 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ é‚»æŽ¥çŸ©é˜µ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode &#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct GNode* PtrToGNode;struct GNode &#123; int Nv; int Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];&#125;;typedef PtrToGNode MGraph;MGraph CreateGraph(int VertexNum) &#123; Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; Graph-&gt;G[V][W] = INFINITY; &#125; &#125; return Graph;&#125;void InsertEdge(MGraph Graph, Edge E) &#123; Graph-&gt;G[E-&gt;V1][E-&gt;V2] = 1; Graph-&gt;G[E-&gt;V2][E-&gt;V1] = 1;&#125;MGraph BuildGraph() &#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125;bool IsEdge(MGraph Graph, Vertex V, Vertex W) &#123; return Graph-&gt;G[V][W] &lt; INFINITY ? true : false;&#125;void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(MGraph Graph, Vertex V, void (*Visit)(Vertex), int Visited[]) &#123; Visit(V); Visited[V] = true; Vertex W; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) DFS(Graph, W, Visit, Visited); &#125;&#125;void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; // use a simple queue Vertex V, W; Visit(S); Visited[S] = true; Queue[++rear] = S; //enqueue while(front &lt; rear) &#123; V = Queue[++front]; //dequeue for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) &#123; Visit(W); Visited[W] = true; Queue[++rear] = W; &#125; &#125; &#125;&#125;void ListComponents(MGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; MGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/* simple method: use 2-dimensional array represent adjcent matrix#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10 + 5;const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void dfs(int node) &#123; visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[node][i] != inf) dfs(i); &#125;&#125;void bfs(int node) &#123; queue&lt;int&gt; q; cout &lt;&lt; node &lt;&lt; ' '; visited[node] = true; q.push(node); while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[front][i] != inf) &#123; cout &lt;&lt; i &lt;&lt; ' '; visited[i] = true; q.push(i); &#125; &#125; &#125;&#125;void listcomponents() &#123; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; dfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; bfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125;&#125;int main() &#123; init(); cin &gt;&gt; nv &gt;&gt; ne; for(int i = 0; i &lt; ne; i++) &#123; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; G[v1][v2] = G[v2][v1] = 1; &#125; listcomponents(); return 0;&#125;*//*some samples:in:8 60 70 12 04 12 43 5out:&#123; 0 1 4 2 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 1 2 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 06-2 Saving James Bond - Easy Versionè¿™é“é¢˜ç›®æ˜¯éš¾åº¦é™ä½ŽåŽçš„ç®€å•ç‰ˆï¼ŒæŒ‰ç…§å§¥å§¥ç»™å®šçš„æ€è·¯æ¥å†™å³å¯ï¼Œè¿™é‡Œä½¿ç”¨ C++ çš„éƒ¨åˆ†åŠŸèƒ½æ¥å†™å¯èƒ½ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼ˆç”¨çº¯ C ä¹Ÿå¯ä»¥èƒœä»»ï¼Œå¯èƒ½ä¼šç¨å¾®éº»çƒ¦ï¼‰ï¼Œå¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node&#123; double x, y;&#125; coords[maxn];int n;double d;bool visited[maxn] = &#123;false&#125;;bool firstjump(int v) &#123; return sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) - 7.5 &lt;= d;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125; bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool DFS(int v) &#123; visited[v] = true; bool flag = false; if(issafe(v)) return true; else &#123; for(int w = 0; w &lt; n; w++) &#123; if(!visited[w] &amp;&amp; jump(v, w)) &#123; flag = DFS(w); if(flag) break; &#125; &#125; &#125; return flag;&#125;void save007() &#123; bool flag = false; for(int v = 0; v &lt; n; v++) &#123; if(!visited[v] &amp;&amp; firstjump(v)) &#123; flag = DFS(v); if(flag) break; &#125; &#125; flag ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int v = 0; v &lt; n; v++) &#123; cin &gt;&gt; coords[v].x &gt;&gt; coords[v].y; &#125; save007(); return 0;&#125;/*sample:in:25 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12out:Yesin:4 13-12 1212 12-12 -1212 -12out:No*/ 06-3 å…­åº¦ç©ºé—´ç”±äºŽå…­åº¦ç©ºé—´ç†è®ºå§¥å§¥å·²ç»ä»‹ç»è¿‡äº†ï¼Œæ‰€ä»¥é¢˜ç›®æ„æ€ç†è§£èµ·æ¥æ¯”è¾ƒå®¹æ˜“ï¼ŒæŒ‰ç…§å§¥å§¥çš„è®²è§£ï¼Œåªéœ€è¦ç¨ç¨ä¿®æ”¹ BFS ç®—æ³•å°±å¯ä»¥äº†ï¼Œä½†æ³¨æ„æœ€åŽè¾¹ç•Œæ¡ä»¶çš„è®¾ç½®è¦å¥½å¥½ç†è§£ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define maxn 1005const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;int BFS(int v) &#123; memset(visited, false, sizeof(visited)); visited[v] = true; int Queue[maxn], front = -1, rear = -1; Queue[++rear] = v; int count = 1, level = 0, last = v, tail; while(front &lt; rear) &#123; int first = Queue[++front]; for(int w = 1; w &lt;= nv; w++) &#123; if(!visited[w] &amp;&amp; G[first][w] != inf) &#123; Queue[++rear] = w; visited[w] = true; tail = w; count++; &#125; &#125; if(first == last) &#123; level++; last = tail; &#125; if(level == 6) break; &#125; return count;&#125;void sds() &#123; for(int i = 1; i &lt;= nv; i++) &#123; int count = BFS(i); printf("%d: %.2lf%%\n", i, (double)count / nv * 100.0); &#125;&#125;int main() &#123; init(); scanf("%d %d", &amp;nv, &amp;ne); int v1, v2; for(int i = 0; i &lt; ne; i++) &#123; scanf("%d %d", &amp;v1, &amp;v2); G[v1][v2] = G[v2][v1] = 1; &#125; sds(); return 0;&#125;/*samples:in:10 91 22 33 44 55 66 77 88 99 10out:1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‰’è°±è®°å½• - ç§‹æŸ³]]></title>
    <url>%2F2020%2F08%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-%E7%A7%8B%E6%9F%B3%2F</url>
    <content type="text"><![CDATA[å‰æ®µæ—¶é—´ï¼Œæœ‹å‹çªç„¶ç»™æˆ‘å‘äº†ä»–æ¯”è¾ƒå–œæ¬¢çš„æ°‘è°£ â€”â€”ã€Šç§‹æŸ³ã€‹ã€‚æ­£å·§ä»–è‡ªå·±åœ¨å¹å£ç´ï¼Œæ‰€ä»¥æƒ³è¯•ç€æ‰’æ‰’è°±å­ï¼Œç»“æžœè°±å­æ‰’å®ŒåŽï¼Œè®©æˆ‘ç»™ä»–çœ‹çœ‹ã€‚æˆ‘è½¬å°”ä¸€æƒ³ï¼Œç›´æŽ¥è‡ªå·±æ‰’äº†æ¯”å¯¹ç®—äº†ã€‚ä¸è¿‡ï¼Œç½‘ä¸Šä¼°è®¡ä¹Ÿæœ‰å¯¹åº”çš„ç®€è°±ã€‚ åŽŸæ›²ï¼š è‡ªæ‰’è°±ï¼š123 212 1(6)(5)123 335 532123 212 1(6)(5)123 212 1(7)1345 532234 444 323345 321165 132 171()ï¼šé™å…«åº¦ æ‰’çš„æ¯”è¾ƒç®€é™‹ï¼Œæ—¥åŽåœ¨åšä¸€å¼ ç®€è°±å§ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_05-æ ‘ï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F05%2F03%2FZJU-DS-05-%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬è®²å°†ä¼šåœ¨äºŒå‰æ ‘ç»“æž„çš„åŸºç¡€ä¸Šåœ¨ä»‹ç»å¦å¤–ä¸‰ç§ç‰¹æ®Šçš„ç»“æž„ï¼šå †ã€å“ˆå¤«æ›¼æ ‘å’Œé›†åˆï¼Œå¿«æ¥å­¦ä¹ å§ï¼ Heapåœ¨äº†è§£å¯¹ä¹‹å‰å…ˆæ¥è€ƒè™‘ä¸€ä¸‹â€œä¼˜å…ˆé˜Ÿåˆ—â€çš„é—®é¢˜ã€‚ æ‰€è°“ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå³å–å‡ºå…ƒç´ çš„é¡ºåºæ˜¯ä¾ç…§å…ƒç´ çš„ä¼˜å…ˆæƒï¼ˆå…³é”®å­—ï¼‰å¤§å°ï¼Œè€Œä¸æ˜¯å…ƒç´ è¿›å…¥é˜Ÿåˆ—çš„å…ˆåŽé¡ºåºï¼Œå¯ä»¥ç”¨æ•°ç»„ã€é“¾è¡¨ã€æœ‰åºæ•°ç»„ã€æœ‰åºé“¾è¡¨ã€æ ‘ç­‰æ¥å®žçŽ°ã€‚ å¦‚æžœä½¿ç”¨å¹³è¡¡äºŒå‰æ ‘æ¥å®žçŽ°ï¼Œæ’å…¥ä¸éš¾å®žçŽ°ï¼Œä½†æ˜¯åˆ é™¤æ“ä½œä¼šå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯ï¼Œå¤šæ¬¡åˆ é™¤æ“ä½œåŽï¼Œæ ‘çš„ä¸¤è¾¹ä¼šå˜å¾—ä¸å‡è¡¡ï¼Œå¦‚æžœåœ¨æ¥æ—‹è½¬è°ƒæ•´å°±ä¼šé™ä½Žæ•ˆçŽ‡ï¼ŒäºŽæ˜¯è€ƒè™‘è®©æœ€å¤§å€¼æˆä¸ºæ ¹ç»“ç‚¹ï¼ˆå¤§æ ¹å †ï¼‰ï¼Œæ¯æ¬¡åˆ é™¤åªéœ€è¦åˆ é™¤æ ¹ç»“ç‚¹å³å¯ï¼Œè¿™æ ·å°±ä¸ä¼šå½±å“æ ‘çš„é«˜åº¦äº†ã€‚å †æœ‰ä¸¤ä¸ªç‰¹æ€§ï¼ˆæ»¡è¶³ç‰¹æ€§æ‰èƒ½ç§°å †ï¼Œå¦åˆ™ä¸è¡Œï¼‰ï¼š ç»“æž„æ€§ï¼šç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘ æœ‰åºæ€§ï¼šä»»ä¸€ç»“ç‚¹çš„å…³é”®å­—æ˜¯å…¶å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰ã€‚ æœ€å¤§å †ï¼ˆMaxHeapï¼‰ï¼Œä¹Ÿç§°å¤§æ ¹å †ï¼Œæ ¹ä¸ºæœ€å¤§å€¼ æœ€å°å †ï¼ˆMinHeapï¼‰ï¼Œä¹Ÿç§°å°æ ¹å †ï¼Œæ ¹ä¸ºæœ€å°å€¼ å †çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šæœ€å¤§å †ï¼ˆMaxHeapï¼‰æ•°æ®å¯¹è±¡é›†ï¼šå®Œå…¨äºŒå‰æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹å…ƒç´ å€¼ä¸å°äºŽå…¶å­ç»“ç‚¹çš„å…ƒç´ å€¼æ“ä½œé›†ï¼šæœ€å¤§å †$H âˆˆ MaxHeap$ï¼Œå…ƒç´ $item âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œæœ‰ï¼š MaxHeap Create(int MaxSize)ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å † Boolean IsFull(MaxHeap H)ï¼Œåˆ¤æ–­æœ€å¤§å †Hæ˜¯å¦å·²æ»¡ Insert(MaxHeap H, ElementType item)ï¼Œå°†å…ƒç´ itemæ’å…¥æœ€å¤§å †H Boolean IsEmpty(MaxHeap H)ï¼Œåˆ¤æ–­æœ€å¤§å †Hæ˜¯å¦ä¸ºç©º ElementType DeleteMax(MaxHeap H)ï¼Œè¿”å›žHä¸­æœ€å¤§å…ƒç´ ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰ å †çš„å®žçŽ°C è¯­è¨€ä¸‹çš„å †å®šä¹‰å¯ä»¥å¦‚ä¸‹ï¼š123456typedef struct HeapStruct *MaxHeap;struct HeapStruct&#123; ElementType *Data; int Size; int Capacity;&#125;; æœ€å¤§å †åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºå †ï¼‰12345678MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125; åˆ¤æ–­å †æ»¡123bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125; åˆ¤æ–­å †ç©º123bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125; æ’å…¥ç”±äºŽå †çš„å®žçŽ°æ˜¯åŸºäºŽå®Œå…¨äºŒå‰æ ‘çš„æ€æƒ³ï¼Œæ’å…¥å…ƒç´ çš„æ—¶å€™ç›´æŽ¥æ”¾åœ¨æœ€åŽå°±å¥½ã€‚ä½†æ˜¯è¦æ³¨æ„ä¸ºäº†ä¿è¯æ ‘çš„ç»“æž„ç¬¦åˆæœ€å¤§å †çš„ç‰¹æ€§ï¼Œæ‰€ä»¥éœ€è¦å°†å­ç»“ç‚¹ä¸Žçˆ¶ç»“ç‚¹æ¯”è¾ƒï¼Œå¦‚æžœå­ç»“ç‚¹æ¯”çˆ¶ç»“ç‚¹å¤§ï¼Œå°±å°†å­ç»“ç‚¹ä¸Žçˆ¶ç»“ç‚¹äº’æ¢ã€‚1234567891011121314bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125; åˆ é™¤å¯¹å¤§æ ¹å †è€Œè¨€ï¼Œåˆ é™¤å°±æ˜¯åˆ é™¤æœ€å¤§å€¼å…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯å †é¡¶ï¼‰ã€‚åˆ é™¤äº†å †é¡¶åŽï¼Œç›´æŽ¥å°†æœ€åŽä¸€ä¸ªå…ƒç´ æ”¾åˆ°å †é¡¶æ˜¾ç„¶æ— æ³•ä¿è¯å †çš„ç»“æž„æ€§ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹æ­¤æ—¶çš„å †åšè°ƒæ•´ã€‚123456789101112131415161718ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125; ç›´æŽ¥å»ºå †ä¸Šé¢æåˆ°çš„å»ºå †æ–¹æ³•å®žé™…ä¸Šæ˜¯å°†å…ƒç´ ä¸€ä¸ªä¸ªçš„æ’å…¥åˆ°å †ä¸­ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(NLogN)$ã€‚ å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ€è·¯æ¥å»ºå †ï¼š å°† N ä¸ªå…ƒç´ æŒ‰è¾“å…¥é¡ºåºå­˜å…¥ï¼Œå…ˆæ»¡è¶³å®Œå…¨äºŒå‰æ ‘çš„ç‰¹æ€§ è°ƒæ•´å„ç»“ç‚¹ä½ç½®ï¼Œä»¥æ»¡è¶³æœ€å¤§å †çš„æœ‰åºç‰¹æ€§ã€‚ å¶å­ç»“ç‚¹æ— é¡»è°ƒæ•´ï¼Œæ‰€ä»¥åªéœ€ä¾æ¬¡è°ƒæ•´æ‰€æœ‰éžå¶ç»“ç‚¹å³å¯ï¼Œè°ƒæ•´çš„æ€è·¯ä¸Žåˆ é™¤ç»“ç‚¹æ—¶è°ƒæ•´å †çš„ç»“æž„çš„æ€è·¯ä¸€è‡´ã€‚å¦å¤–ï¼Œä¸ºäº†ä½¿å¾—ä»£ç ç®€æ´ï¼Œå¯ä»¥å°†ç»“ç‚¹ä¸‹ç§»çš„æ“ä½œç‹¬ç«‹å°è£…å‡ºæ¥ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; å°½ç®¡ä»Žä»£ç ä¸Šçœ‹æ—¶é—´å¤æ‚åº¦å¥½åƒæ˜¯$O(N^2)$ï¼Œä½†å®žé™…æƒ…å†µçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(NLogN)$ã€‚ æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef int ElementType;typedef struct HNode *Heap;struct HNode&#123; ElementType *Data; int Size; int Capacity;&#125;;typedef Heap MaxHeap;#define MaxData 1000MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125;bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125;#define ERROR -1bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125;ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125;void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MaxHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n'); &#125;int main() &#123; MaxHeap H = Createheap(10); Insert(H, 10); Insert(H, 5); Insert(H, 20); Insert(H, 30); Insert(H, 15); Insert(H, 18); Printheap(H); return 0;&#125; æœ€å°å †æœ€å°å †çš„ç»“æž„ä¸Žæœ€å¤§å †çš„ç»“æž„åŒºåˆ«åªåœ¨äºŽæ ¹ç»“ç‚¹å€¼æ¯”å¶ç»“ç‚¹éƒ½å°ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ã€‚æ‰€ä»¥ï¼Œæœ€å°å †çš„æ’å…¥ã€åˆ é™¤å’Œç›´æŽ¥å»ºå †çš„ä»£ç ç•¥æœ‰å·®å¼‚ï¼Œä½†æ€è·¯éƒ½æ˜¯ä¸€è‡´çš„ã€‚ æ’å…¥å‰é¢ä»‹ç»æœ€å¤§å †çš„æ—¶å€™å·²ç»çŸ¥é“äº†ï¼Œæ¯å‘å †ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹å°±éœ€è¦è°ƒæ•´å †çš„ç»“æž„ï¼Œè°ƒæ•´è¿™ä¸ªæ“ä½œå¯ä»¥ç‹¬ç«‹å°è£…èµ·æ¥ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ ç®€æ´ã€‚æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125; åˆ é™¤æ³¨æ„æœ€å°å †ä¸­åˆ é™¤æ“ä½œçš„ Percdown å‡½æ•°ä¸Žæœ€å¤§å †æ˜¯æœ‰åŒºåˆ«çš„ï¼Œä¸»è¦åœ¨äºŽå½“å¶ç»“ç‚¹å°äºŽæ ¹èŠ‚ç‚¹æ—¶ï¼Œæ‰éœ€è¦å°†æ ¹ç»“ç‚¹ä¸‹ç§»ï¼ˆè€Œæ­¤æ—¶æœ€å¤§å †åˆšå¥½å°±æ˜¯åˆé€‚çš„ä½ç½®ï¼‰ã€‚12345678910111213141516171819202122void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125; ç›´æŽ¥å»ºå †ç›´æŽ¥å»ºå †çš„æ€è·¯ä¸€è‡´ï¼Œä¸åŒçš„åªæ˜¯æœ€å°å †çš„ Percdown å‡½æ•°ä¸Žæœ€å¤§å †ä¸åŒï¼Œä½†æ˜¯å¯ä»¥å‘çŽ° Buildheap è¿™ä¸ªå‡½æ•°æ²¡æœ‰å˜åŒ–ï¼Œè¿™å…¶å®žå°±æ˜¯å°† Percdown ç‹¬ç«‹å°è£…èµ·æ¥çš„å¥½å¤„ã€‚1234567891011121314151617void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap Createheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * MAXN); H-&gt;Size = 0; H-&gt;Capacity = Maxsize; return H;&#125; bool Isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Isempty(MinHeap H) &#123; return H-&gt;Size == 0;&#125;void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MinHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; MinHeap H = Createheap(5); Insert(H, 46); Insert(H, 23); Insert(H, 26); Insert(H, 24); Insert(H, 10); Printheap(H); Deletemin(H); Printheap(H); return 0;&#125; Huffman Treeç¼–ç é—®é¢˜æ˜¯è®¡ç®—æœºå­¦ç§‘å†…ååˆ†é‡è¦çš„é—®é¢˜ï¼Œè€Œå“ˆå¤«æ›¼æ ‘å°±æ˜¯ä¸ºäº†è§£å†³ç¼–ç çš„é—®é¢˜è€Œäº§ç”Ÿçš„ã€‚ä¸Žä¹‹ç±»ä¼¼çš„é—®é¢˜è¿˜æœ‰åˆ¤å®šæ ‘å’Œæœç´¢æ ‘å¦‚ä½•æž„é€ æœ€ä¼˜çš„é—®é¢˜ï¼Œè€Œæ‰€è°“æœ€ä¼˜ï¼Œå³æ˜¯æŸ¥æ‰¾æ ‘æ•ˆçŽ‡æœ€é«˜ã€‚ é¦–å…ˆï¼Œå“ˆå¤«æ›¼æ ‘æ˜¯ä¸€ç§å¾ˆç‰¹æ®Šçš„äºŒå‰æ ‘ï¼ˆæ²¡é”™ï¼Œå®ƒæ˜¯äºŒå‰æ ‘ï¼‰ï¼Œå®ƒæœ‰ N ä¸ªå¶å­ç»“ç‚¹ï¼Œè‹¥è¯¥æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰è¾¾åˆ°æœ€å°ï¼Œç§°è¿™æ ·çš„äºŒå‰æ ‘ä¸ºå“ˆå¤«æ›¼æ ‘ï¼ˆHuffman Treeï¼‰ï¼Œä¹Ÿå«æœ€ä¼˜äºŒå‰æ ‘ã€‚ é‚£ä¹ˆï¼Œä»€ä¹ˆæ˜¯å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼ŒWeighted Path Length of Treeï¼‰å‘¢ï¼Ÿ è®¾äºŒå‰æ ‘æœ‰ N ä¸ªå¶å­ç»“ç‚¹ï¼Œæ¯ä¸ªå¶å­ç»“ç‚¹å¸¦æœ‰æƒå€¼$w_k$ï¼Œä»Žæ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­ç»“ç‚¹çš„é•¿åº¦ä¸º$l_k$ï¼Œåˆ™æ¯ä¸ªå¶å­ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œï¼š$WPL = \sum_{k=1}^n w_k l_k$ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå“ˆå¤«æ›¼æ ‘å®žé™…ä¸Šå°±æ˜¯æŒ‡ WPL æœ€å°çš„æ ‘ã€‚ æž„é€ æž„é€ å“ˆå¤«æ›¼æ ‘çš„æ–¹æ³•ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œæ¯æ¬¡æŠŠæƒå€¼æœ€å°çš„ä¸¤æ£µäºŒå‰æ ‘åˆå¹¶å³å¯ã€‚ ç”±äºŽæ¯æ¬¡å»ºæ ‘éƒ½éœ€è¦é€‰å‡ºæƒå€¼æœ€å°çš„ç»“ç‚¹ï¼Œæ‰€ä»¥åœ¨ä»£ç å®žçŽ°è¿‡ç¨‹ä¸­ï¼Œå€ŸåŠ©æœ€å°å †æ¥æ‰¾å‡ºæƒå€¼æœ€å°çš„ç»“ç‚¹æ¯”è¾ƒæ–¹ä¾¿å¿«æ·ã€‚ è¿™é‡Œå·ä¸ªæ‡’ï¼Œç›´æŽ¥ç”¨ä½•å¤´ç»™å‡ºçš„ä»£ç ï¼š12345678910111213141516171819typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman(MinHeap H) &#123; int i; HuffmanTree T; BuildMinHeap(H); for(i = 1; i &lt; H-&gt;Size; i++) &#123; T = malloc(sizeof(struct TreeNode)); T-&gt;Left = Deletemin(H); T-&gt;Right = Deletemin(H); T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; Insert(H, T); &#125; T = DeleteMin(H); // insert new root node return T;&#125; ç‰¹ç‚¹ç”±äºŽå“ˆå¤«æ›¼æ ‘æž„é€ æ–¹æ³•çš„ç‰¹æ®Šæ€§ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š æ²¡æœ‰åº¦ä¸º 1 çš„ç»“ç‚¹ n ä¸ªå¶å­ç»“ç‚¹çš„å“ˆå¤«æ›¼æ ‘å…±æœ‰ $2n-1$ ä¸ªç»“ç‚¹ å“ˆå¤«æ›¼æ ‘çš„ä»»æ„éžå¶ç»“ç‚¹çš„å·¦å³å­æ ‘äº¤æ¢åŽä»æ˜¯å“ˆå¤«æ›¼æ ‘ å¯¹åŒä¸€ç»„æƒå€¼${w_1, w_2, w_3, \dots, w_n}$ï¼Œæ˜¯å­˜åœ¨ä¸åŒæž„çš„ä¸¤æ£µå“ˆå¤«æ›¼æ ‘ï¼Œä½†æ³¨æ„å…¶ WPL æ˜¯ä¸€å®šæ˜¯ä¸€æ ·ä¸”æœ€å°çš„ è®°å¥½è¿™äº›ç‰¹ç‚¹ï¼Œç®—æ³•ç¬”è¯•é¢˜å¯èƒ½ä¼šé‡è§ã€‚ ç¼–ç å¦‚å‰æ‰€è¨€ï¼Œå“ˆå¤«æ›¼æ ‘çš„å‡ºçŽ°æ˜¯ä¸ºäº†è§£å†³ç¼–ç é—®é¢˜ï¼Œé‚£ä¹ˆå…·ä½“è§£å†³äº†é‚£äº›é—®é¢˜å‘¢ï¼Ÿ å“ˆå¤«æ›¼æ ‘è§£å†³çš„ç¼–ç é—®é¢˜å°±æ˜¯é¿å…äº†åœ¨è¿›è¡Œä¸ç­‰é•¿ç¼–ç æ—¶çš„å¯èƒ½ä¼šäº§ç”Ÿçš„äºŒä¹‰æ€§ã€‚æ‰€è°“äºŒä¹‰æ€§å°±æ˜¯æŒ‡åŒä¸€ä¸²ç¼–ç ï¼Œè§£é‡Šç»“æžœä¼šæœ‰ä¸åŒã€‚æ ¹æ®å“ˆå¤«æ›¼æ ‘çš„ç»“æž„ï¼Œå¦‚æžœç”¨å­—ç¬¦ä»£è¡¨å¶ç»“ç‚¹ï¼Œå·¦å³åˆ†æ”¯åˆ†åˆ«ä»£è¡¨ 0 å’Œ 1ï¼Œç”¨æ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶ç»“ç‚¹çš„è·¯å¾„æ–¹å‘ä»£è¡¨æ¯ä¸ªå­—ç¬¦çš„ç¼–ç ï¼Œå¯ä»¥å¾ˆç¥žå™¨çš„å‘çŽ°ï¼Œå„ç§å­—ç¬¦ç¼–ç ç»„åˆéƒ½ä¸ä¼šäº§ç”ŸäºŒä¹‰æ€§ã€‚ æ­¤æ—¶ï¼Œå¯¹æ¯ä¸ªå­—ç¬¦æ‰€ç¼–çš„ç ä¹Ÿå«åšå‰ç¼€ç ï¼ˆå³ä»»ä½•å­—ç¬¦çš„ç¼–ç éƒ½ä¸æ˜¯å¦ä¸€å­—ç¬¦ç¼–ç çš„å‰ç¼€ï¼‰ã€‚å®žé™…ä¸Šè€Œè¨€ï¼Œå½“æ‰€æœ‰å­—ç¬¦éƒ½å¤„åœ¨å¶ç»“ç‚¹æ—¶ï¼Œå°±ä¸ä¼šäº§ç”Ÿéžå‰ç¼€ç ã€‚ æŒ‰ç…§å“ˆå¤«æ›¼æ ‘è¿›è¡Œçš„ç¼–ç ï¼Œè¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œé‚£å°±æ˜¯ä»£ä»·æœ€å°ï¼Œæ¯”èµ·ç­‰é•¿ç¼–ç è¦èŠ‚çœäº†å¤§é‡çš„ç©ºé—´ã€‚ è¿™å°±æ˜¯å“ˆå¤«æ›¼æ ‘æ‰€è§£å†³çš„ç¼–ç é—®é¢˜ã€‚ Setè¿™é‡Œé›†åˆçš„æ¦‚å¿µä¸Žæ•°å­¦ä¸Šé›†åˆçš„æ¦‚å¿µåŸºæœ¬ä¸€è‡´ï¼Œä½†å®žé™…ç»å¸¸ç”¨åˆ°çš„é›†åˆå«åšâ€œå¹¶æŸ¥é›†â€ï¼Œå…¶å®žå°±æ˜¯é›†åˆçš„å¹¶å’ŒæŸ¥ä¸¤ä¸ªæ“ä½œã€‚PSï¼šå­¦å®Œæ•´å¥—è¯¾ç¨‹ä¹‹åŽï¼Œå›žè¿‡å¤´ä¼šå‘çŽ°ï¼Œé›†åˆæ›´åƒæ˜¯åŽé¢è¦å­¦çš„â€œå›¾â€ï¼Œä½†å…¶ä¸­ä¸€äº›æ¦‚å¿µåˆä¸Žæ ‘è”ç³»å¯†åˆ‡ã€‚ åˆ©ç”¨é™æ€æ•°ç»„å­˜å‚¨é›†åˆè¾ƒä¸ºæ–¹ä¾¿ï¼Œå€Ÿç”¨ä¸€ä¸‹ä½•å¤´çš„ä»£ç ï¼š1234typedef struct &#123; ElementType Data; int Parent;&#125; SetType; æŸ¥æ‰¾æŸ¥æ‰¾æŸä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆï¼Œè¦å…ˆæ‰¾åˆ°è¿™ä¸ªç»“ç‚¹çš„ä½ç½®ï¼Œç„¶åŽåœ¨ä»Žä¸‹å¾€ä¸Šä¾æ¬¡æŸ¥æ‰¾æ ¹ç»“ç‚¹ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567int Find(SetType S[], ElementType X) &#123; int i; for(i = 0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++) if(i &gt;= MaxSize) return -1; // not find the element for(; S[i].Parent &gt;= 0; i = S[i].Parent); return i; // return the root static pointer&#125; å¹¶ä¸¤ä¸ªé›†åˆçš„å¹¶è¿ç®—éœ€è¦åœ¨æŸ¥æ‰¾æ“ä½œçš„åŸºç¡€ä¸Šå®žçŽ°ï¼Œå…ˆåˆ†åˆ«æ‰¾åˆ°ä¸¤ä¸ªé›†åˆçš„æ ¹ç»“ç‚¹ï¼Œå†å°†å…¶ä¸­ä¸€ä¸ªæ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹æŒ‡é’ˆè®¾ç½®æˆå¦ä¸€ä¸ªæ ¹ç»“ç‚¹çš„æ•°ç»„ä¸‹æ ‡ï¼Œå‡è®¾ä¸¤ä¸ªé›†åˆå†…åˆ†åˆ«æœ‰å…ƒç´  $X_1$ å’Œ $X_2$ï¼Œä»£ç å¦‚ä¸‹ï¼š123456void Union(SetType S[], ElementType X1, ElementType X2) &#123; int Root1, Root2; Root1 = Find(S, X1); Root2 = Find(S, X2); if(Root1 != Root2) S[Root2].Parent = Root1;&#125; æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå½“ä¸æ–­çš„å¹¶å…¥æ–°é›†åˆæ—¶ï¼Œå¯èƒ½ä¼šäº§ç”Ÿæ ‘ä¸æ–­å¢žé«˜çš„æƒ…å†µï¼Œè¿™æ ·ä¼šå¯¼è‡´æŸ¥æ‰¾çš„æ•ˆçŽ‡é™ä½Žï¼Œä¸€ç§å¯è¡Œçš„åŠžæ³•å°±æ˜¯å°†å°é›†åˆå¹¶å…¥å¤§é›†åˆã€‚ä½†è¿™æ ·åšçš„æ•ˆçŽ‡ä»ç„¶ä¸é«˜ï¼Œä¸è¿‡åŽé¢å§¥å§¥ä¼šäº¤ç»™æˆ‘ä»¬è·¯å¾„åŽ‹ç¼©å’ŒæŒ‰ç§©å½’å¹¶çš„æ–¹æ³•ã€‚ Homework05-7 å †ä¸­çš„è·¯å¾„é¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œåˆ©ç”¨é¢˜ç›®ç»™å®šçš„ä¸€ä¸²æ•°å­—å»ºç«‹æœ€å°å †ï¼Œç„¶åŽå¯¹ä»»æ„ç»™å®šçš„ä¸‹æ ‡ iï¼Œæ‰“å° H[i] åˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap initheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * (Maxsize + 1)); H-&gt;Capacity = Maxsize; H-&gt;Size = 0; return H;&#125;bool isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool insert(MinHeap H, int data) &#123; if(isfull(H)) return false; else &#123; int i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &gt; data &amp;&amp; i &gt; 1; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = data; &#125;&#125;void Printpath(MinHeap H, int index) &#123; for(; index &gt;= 1; index /= 2) &#123; printf("%d", H-&gt;Data[index]); if(index != 1) putchar(' '); &#125; putchar('\n');&#125; int main() &#123; int i, n, m, temp; scanf("%d %d", &amp;n, &amp;m); MinHeap H = initheap(n); for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); insert(H, temp); &#125; for(i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;temp); Printpath(H, temp); &#125; return 0;&#125;/*samples:in:5 346 23 26 24 105 4 3out:24 23 1046 23 1026 10*/ 05-8 File Transferè¿™é“é¢˜ä¸Žè€å¸ˆä¸Šè¯¾è®²çš„è¿žç½‘é—®é¢˜å¾ˆç±»ä¼¼ï¼Œä½†æ˜¯è¦çœ‹æ¸…æ¥šé¢˜ç›®ä¸­I C Såˆ†åˆ«ä»£è¡¨çš„å«ä¹‰ã€‚ Iä»£è¡¨è¾“å…¥è¿žæŽ¥ï¼Œå°±ç›¸å½“äºŽå°†ä¸¤ä¸ªå…ƒç´ å¹¶æˆä¸€ä¸ªé›†åˆï¼›Cä»£è¡¨æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ä¸ªé›†åˆï¼›Sä»£è¡¨åœæ­¢æµ‹è¯•ã€‚ æ ¹æ®é¢˜ç›®çš„æµ‹è¯•æ ·ä¾‹ï¼Œæˆ‘ä»¬å¾—çŽ°æž„é€ é›†åˆï¼Œç„¶åŽåœ¨åˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆå†…ã€‚å½“ç„¶äº†ï¼Œä¸€å¼€å§‹æ‰€æœ‰çš„å…ƒç´ éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„é›†åˆï¼Œåªæœ‰å½“â€œè¾“å…¥è¿žæŽ¥â€åŽä¸¤ä¸ªå…ƒç´ æ‰ç®—æ˜¯å¤„äºŽåŒä¸€ä¸ªé›†åˆã€‚ æ˜Žç™½ä»¥ä¸ŠåŽŸåˆ™åŽï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚æ¥è¿›è¡Œè¾“å‡ºå³å¯ã€‚ å¦å¤–ï¼Œå§¥å§¥å‡ºè¿™é“é¢˜çš„ç›®çš„å°±æ˜¯ä¸ºäº†ç»™å¤§å®¶ä»‹ç»è·¯å¾„åŽ‹ç¼©ä¸ŽæŒ‰ç§©å½’å¹¶ï¼Œä¸ç”¨è¿™ä¸¤ç§æ–¹æ³•ï¼Œæ˜¾ç„¶ä¸èƒ½ ACã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10005typedef int Set[MAXN];typedef int SetType;void init(Set S) &#123; int i; for(i = 0; i &lt; MAXN; i++) &#123; S[i] = -1; &#125;&#125;void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125;SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125;int main() &#123; Set set; init(set); int i, n, c1, c2; scanf("%d%*c", &amp;n); char act; while((act = getchar()) != 'S') &#123; scanf("%d %d%*c", &amp;c1, &amp;c2); int root1, root2; root1 = Find(set, c1); root2 = Find(set, c2); if(act == 'C') &#123; if(root1 == root2 &amp;&amp; (root1 &gt; 0 || root2 &gt; 0)) printf("yes\n"); else printf("no\n"); &#125; else if(act == 'I') &#123; Union(set, root1, root2); &#125; &#125; int cnt = 0; for(i = 1; i &lt;= n; i++) &#123; if(set[i] &lt; 0) cnt++; &#125; if(cnt == 1) printf("The network is connected.\n"); else printf("There are %d components.\n", cnt); return 0;&#125; æŒ‰ç§©å½’å¹¶å§¥å§¥è®²è§£çš„æŒ‰ç§©å½’å¹¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œå…³é”®å–å†³äºŽå¦‚ä½•ç†è§£â€œç§©â€ï¼Œå¯ä»¥å°†å…¶è®¤ä¸ºæ˜¯æ ‘é«˜ï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯æ ‘ç»“ç‚¹çš„ä¸ªæ•°ã€‚ä½†ä¸¤è€…æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯å°†å°è§„æ¨¡çš„æ ‘å¹¶åˆ°å¤§è§„æ¨¡çš„æ ‘ä¸Šã€‚123456789void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125; è·¯å¾„åŽ‹ç¼©è·¯å¾„åŽ‹ç¼©æ‰€è§£å†³çš„é—®é¢˜æ˜¯å°½å¯èƒ½çš„é™ä½Žæ ‘çš„é«˜åº¦ï¼Œè¿™æ ·å°±ä¼šä½¿å¾—å…¶æŸ¥æ‰¾æ•ˆçŽ‡æé«˜ã€‚ åœ¨ä¹‹å‰ä»‹ç»çš„æŸ¥æ‰¾æ“ä½œä¸­ï¼Œæ¯æ¬¡éœ€è¦å…ˆæ‰¾åˆ°å¶ç»“ç‚¹åœ¨åŽ»æ‰¾æ ¹ç»“ç‚¹ï¼Œæ‰¾åˆ°äº†ä¹‹åŽå¹¶ä¸å¯¹é›†åˆï¼ˆä¹Ÿå°±æ˜¯æŸ¥æ‰¾æ ‘ï¼‰çš„ç»“æž„åšå‡ºä¼˜åŒ–ã€‚ä½†è·¯å¾„åŽ‹ç¼©å€ŸåŠ©é€’å½’ï¼Œæ¯æ‰¾åˆ°ä¸€ä¸ªç»“ç‚¹ï¼Œå°±å°†å®ƒç›´æŽ¥æŒ‚åœ¨æ ¹ç»“ç‚¹çš„ä¸‹é¢ï¼Œè¿™æ ·å½“æ‰¾åˆ°ç›®æ ‡ç»“ç‚¹çš„æ ¹ç»“ç‚¹æ—¶ï¼Œè¿™æ£µæŸ¥æ‰¾æ ‘çš„é«˜åº¦å°±æ˜¯ 2 äº†ï¼Œæžå¤§çš„æé«˜äº†ä¸‹æ¬¡æŸ¥æ‰¾æ—¶çš„æ•ˆçŽ‡ã€‚1234SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125; 05-9 Huffman Codesé¢˜ç›®å¤§æ„å°±æ˜¯ç»™å®šå­—ç¬¦å‡ºçŽ°çš„é¢‘çŽ‡ï¼Œåˆ¤æ–­ç»™å®šçš„æµ‹è¯•æ ·ä¾‹æ˜¯å¦æ˜¯æœ€ä¼˜è§£ï¼Œä½†è¦æ³¨æ„æœ€ä¼˜è§£å¯èƒ½å¹¶ä¸æ˜¯ç”±å“ˆå¤«æ›¼æ ‘æž„æˆçš„ã€‚ å½“åˆåšè¿™ä¸ªé¢˜æ—¶ï¼Œæƒ³æ–¹è®¾æ³•çš„å·æ‡’ï¼Œéžå¸¸ä¸æƒ…æ„¿å»ºå“ˆå¤«æ›¼æ ‘ï¼Œç»“æžœæœ€åŽè¿˜çœŸæ‰¾åˆ°äº† AC çš„æ–¹æ³•ã€‚ è™½ç„¶ä¸å»ºå“ˆå¤«æ›¼æ ‘ï¼Œä½†æ˜¯ WPL è¿˜æ˜¯éœ€è¦è®¡ç®—å‡ºæ¥ç”¨æ¥åˆ¤å®šæ˜¯å¦æœ€ä¼˜çš„ã€‚é‚£ä¹ˆå¦‚ä½•è®¡ç®— WPL å‘¢ï¼Ÿå¯¹ï¼Œç»§ç»­å·æ‡’ï¼Œç›´æŽ¥ç”¨ C++ STL é‡Œé¢çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå…¶å®žå°±æ˜¯æœ€å°å †ï¼‰ï¼Œæ ¸å¿ƒæ€è·¯å°±æ˜¯å“ˆå¤«æ›¼æ ‘çš„ WPL ä¹Ÿç­‰äºŽé™¤äº†æ ¹ç»“ç‚¹ä»¥å¤–ï¼Œå…¨éƒ¨ç»“ç‚¹çš„æƒå€¼ä¹‹å’Œã€‚è¿™ç§è®¡ç®—æ–¹æ³•ä¸Žè€å¸ˆä¸Šè¯¾è®²çš„æ˜¯å®Œå…¨ä¸åŒäº†ï¼Œåˆ©ç”¨è¿™ç§æ€è·¯ï¼Œå¯ä»¥å¾ˆç®€å•çš„è®¡ç®—å‡ºä¸€æ£µå“ˆå¤«æ›¼æ ‘çš„ WPLï¼Œè€Œä¸”è¿˜ä¸ç”¨å»ºæ ‘ã€‚ æœ‰äº†æœ€ä¼˜è§£çš„ WPL åŽï¼Œåªéœ€è¦åœ¨è®¡ç®—å‡ºæ¯ä¸ªæ ·ä¾‹çš„ WPLï¼Œå¹¶æ¯”å¯¹æ˜¯å¦ä¸€è‡´å³å¯çŸ¥é“æ ·ä¾‹æ˜¯å¦æ­£ç¡®ã€‚ æ˜Žç™½ä»¥ä¸Šé—®é¢˜åŽï¼ŒåŸºæœ¬å·²ç»è§£å†³è¿™é“é¢˜ç›®äº†ã€‚ä¸è¿‡è¿˜æœ‰ä¸€ä¸ªåœ°æ–¹è¦æ³¨æ„ï¼Œå¯¹äºŽéžå‰ç¼€ç ä¸” WPL ç›¸åŒçš„æ ·ä¾‹ï¼Œå°±ä¸æ˜¯æ­£ç¡®ç»“æžœäº†ã€‚æ‰€ä»¥ï¼Œåœ¨è®¡ç®—æ ·ä¾‹çš„ WPL åŽï¼Œè¿˜éœ€è¦åˆ¤æ–­æ ·ä¾‹ä¸­æ˜¯å¦æœ‰éžå‰ç¼€ç çš„å­˜åœ¨ï¼Œå¦‚æžœæœ‰ï¼Œé‚£å°±ä¸æ˜¯æ­£ç¡®ç»“æžœï¼Œéœ€åˆ¤å®šä¸º Noã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int maxn = 65 + 5;int hashTable[128] = &#123;0&#125;;bool issubstr(string a, string b) &#123; int flag = true; for(int i = 0; i &lt; b.length(); i++) &#123; if(b[i] != a[i]) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; int n; cin &gt;&gt; n; char ch; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch; cin &gt;&gt; hashTable[ch]; q.push(hashTable[ch]); &#125; int wpl = 0; while(q.size() &gt; 1) &#123; int n1, n2, n; n1 = q.top(); q.pop(); n2 = q.top(); q.pop(); n = n1 + n2; q.push(n); wpl += n; &#125; int m; cin &gt;&gt; m; while(m--) &#123; string codes[maxn]; int wpl_tmp = 0; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch &gt;&gt; codes[i]; wpl_tmp += codes[i].length() * hashTable[ch]; &#125; bool prefix = false; for(int i = 0; i &lt; n; i++) &#123; string str_tmp = codes[i]; for(int j = 0; j &lt; n; j++) &#123; if(str_tmp != codes[j] &amp;&amp; issubstr(codes[j], str_tmp)) &#123; prefix = true; break; &#125; &#125; if(prefix) break; &#125; bool repetition = false; for(int i = 0; i &lt; n - 1; i++) &#123; string str_tmp = codes[i]; if(str_tmp == codes[i + 1]) &#123; repetition = true; break; &#125; &#125; if(wpl_tmp == wpl &amp;&amp; !prefix &amp;&amp; !repetition) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_05_01-æµ‹è¯•èµ›]]></title>
    <url>%2F2020%2F05%2F03%2FPAT-05-01-%E6%B5%8B%E8%AF%95%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[æœ¬æ¥è¿™åŽŸæ–‡ä¸­åº”è¯¥åœ¨æ˜¨å¤©å°±å‘å‡ºæ¥çš„ï¼ŒäºŽæ˜¯ä¹Žï¼Œå·äº†ä¸€ä¸‹æ‡’ï¼Œå°±åˆ°ä»Šå¤©äº†...åºŸè¯ä¸å¤šè¯´ç›´æŽ¥çœ‹é¢˜ï¼ 7-1 knuth æ´—ç‰Œæ³•Knuth æ´—ç‰Œæ³•æ˜¯ç”Ÿæˆ { 1, 2, â€¦, n } çš„ä¸€ä¸ªéšæœºé‡æŽ’åˆ—çš„ç®—æ³•ã€‚ä¸Žæ¯æ¬¡åå¤éšæœºç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œç›´åˆ°èŽ·å¾—ä¸€ä¸ªä¸é‡å¤çš„æ–°æ•°å­—çš„ç®—æ³•ä¸åŒï¼ŒKnuth æ´—ç‰Œæ³•ä»ŽåŽŸå§‹åºåˆ— { 1, 2, â€¦, n } å¼€å§‹ï¼Œé€æ¬¡æ´—ç‰Œã€‚æ´—ç‰Œçš„æ–¹æ³•æ˜¯ä»Žå·¦åˆ°å³ï¼Œæ¯è½®ä»Žæ²¡ç¡®å®šçš„æ•°å­—ä¸­éšæœºæŠ½å–ä¸€ä¸ªæ•°ï¼ŒæŠŠå®ƒæ”¾åˆ°ç¡®å®šçš„ä½ç½®ä¸Šã€‚ä¾‹å¦‚ä»¤ n ç­‰äºŽ 4ã€‚æˆ‘ä»¬ä»Ž { 1, 2, 3, 4 } å¼€å§‹ã€‚è®° i åˆ° N ä¹‹é—´çš„éšæœºæŠ½ç‰Œæ•°ä¸º random(i,N)ã€‚å‡è®¾æˆ‘ä»¬ç”Ÿæˆçš„éšæœºæ•°åºåˆ— random(i,4) (i=1, 2, 3, 4) ä¸º { 2, 4, 3, 4 }ã€‚åˆ™ Knuth æ´—ç‰Œæ³•æ˜¯è¿™æ ·æ‰§è¡Œçš„ï¼š random(1,4) = 2; å°†ä½ç½® 1 ä¸Žä½ç½® 2 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 1, 3, 4 } random(2,4) = 4; å°†ä½ç½® 2 ä¸Žä½ç½® 4 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } random(3,4) = 3; å°†ä½ç½® 3 ä¸Žä½ç½® 3 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } random(4,4) = 4; å°†ä½ç½® 4 ä¸Žä½ç½® 4 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } çŽ°ç»™å®šéšæœºæŠ½ç‰Œæ•°å­—åºåˆ—ï¼Œè¯·ä½ è¾“å‡º Knuth æ´—ç‰Œæ³•çš„ç»“æžœåºåˆ—ã€‚è¾“å…¥æ ¼å¼ï¼šè¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰ã€‚éšåŽä¸€è¡Œç»™å‡º N ä¸ªéšæœºæŠ½ç‰Œæ•°å­—ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯ç¬¬ i ä¸ªæ•°åœ¨ i åˆ° N ä¹‹é—´ã€‚è¾“å‡ºæ ¼å¼ï¼šåœ¨ç¬¬ä¸€è¡Œä¸­è¾“å‡º Knuth æ´—ç‰Œæ³•çš„ç»“æžœåºåˆ—ã€‚æ•°å­—é—´å¿…é¡»ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ Input12107 4 4 5 10 6 9 9 10 10 Output17 4 2 5 10 6 9 1 3 8 Analysisé¢˜ç›®å­—å¤ªå¤šäº†ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯å§¥å§¥æ•…æ„è¿™æ ·ï¼Œæ¥è¿·æƒ‘äººï¼Œéšè—é¢˜æ„ã€‚ å…¶å®žè¿™ä¸ªé¢˜ç›®å°±æ˜¯è®©ä½ äº¤æ¢æ•°å­—ï¼ˆç®—æ˜¯ç®€å•æ¨¡æ‹Ÿï¼‰ï¼Œä»¥æ ·ä¾‹ä¸ºä¾‹ï¼šç¬¬ä¸€æ¬¡ï¼Œå¤„äºŽç¬¬ä¸€ä½çš„æ•°å­—ä¸Žå¤„äºŽç¬¬ä¸ƒä½çš„æ•°å­—äº¤æ¢ï¼›ä»¥ç¬¬ä¸€æ¬¡å¾—åˆ°çš„ç»“æžœåºåˆ—ä¸ºåˆå§‹åºåˆ—ï¼Œäº¤æ¢å¤„äºŽç¬¬äºŒä½çš„æ•°å­—å’Œå¤„äºŽç¬¬å››ä½çš„æ•°å­—ï¼›ä¾æ¬¡ç±»æŽ¨å³å¯ã€‚ Code12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; seq[i] = i; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++) &#123; int tmp = seq[i], random; cin &gt;&gt; random; seq[i] = seq[random]; seq[random] = tmp; &#125; for(int i = 1; i &lt;= n - 1; i++) &#123; cout &lt;&lt; seq[i] &lt;&lt; ' '; &#125; cout &lt;&lt; seq[n]; return 0;&#125; 7-2 ä¸‰é˜¶å¹¸ç¦æ•°å¯¹ä¸€ä¸ªåè¿›åˆ¶æ•°çš„å„ä½æ•°å­—åšä¸€æ¬¡ç«‹æ–¹å’Œï¼Œç§°ä½œä¸€æ¬¡è¿­ä»£ã€‚å¦‚æžœä¸€ä¸ªåè¿›åˆ¶æ•°èƒ½é€šè¿‡ h æ¬¡è¿­ä»£å¾—åˆ° 1ï¼Œå°±ç§°è¯¥æ•°ä¸ºä¸‰é˜¶å¹¸ç¦æ•°ï¼Œè¿­ä»£çš„æ¬¡æ•° h ç§°ä¸ºå¹¸ç¦åº¦ã€‚ä¾‹å¦‚ 1579 ç»è¿‡ 1 æ¬¡è¿­ä»£å¾—åˆ° 1198ï¼Œ2 æ¬¡è¿­ä»£åŽå¾—åˆ° 1243ï¼Œ3 æ¬¡è¿­ä»£åŽå¾—åˆ° 100ï¼Œæœ€åŽå¾—åˆ° 1ã€‚åˆ™ 1579 æ˜¯å¹¸ç¦æ•°ï¼Œå…¶å¹¸ç¦åº¦ä¸º 4ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æžœä¸€ä¸ªå¤§äºŽ1çš„æ•°å­—ç»è¿‡æ•°æ¬¡è¿­ä»£åŽè¿›å…¥äº†æ­»å¾ªçŽ¯ï¼Œé‚£è¿™ä¸ªæ•°å°±ä¸å¹¸ç¦ã€‚ä¾‹å¦‚ 97 è¿­ä»£å¾—åˆ° 1072ã€352ã€160ã€217ã€352ã€â€¦â€¦ å¯è§ 352 åˆ° 217 å½¢æˆäº†æ­»å¾ªçŽ¯ï¼Œæ‰€ä»¥ 97 å°±ä¸å¹¸ç¦ï¼Œè€Œ 352 å°±æ˜¯å®ƒæœ€æ—©é‡åˆ°çš„å¾ªçŽ¯ç‚¹ã€‚æœ¬é¢˜å°±è¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œåˆ¤æ–­ä¸€ä¸ªç»™å®šçš„æ•°å­—æ˜¯å¦æœ‰ä¸‰é˜¶å¹¸ç¦ã€‚ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•° Nï¼ŒéšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 104 çš„æ­£æ•´æ•°ã€‚ å¯¹äºŽæ¯ä¸€ä¸ªè¾“å…¥çš„æ•°å­—ï¼Œå¦‚æžœå…¶æ˜¯ä¸‰é˜¶å¹¸ç¦æ•°ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡ºå®ƒçš„å¹¸ç¦åº¦ï¼›å¦åˆ™è¾“å‡ºæœ€æ—©é‡åˆ°çš„å¾ªçŽ¯ç‚¹ã€‚ Input123431579971 Output12343520 Analysisè¿™ä¸ªé¢˜ç›®æœ¬è´¨ä¸Šå…¶å®žæ˜¯ä¸ªæ•°å­—æ¸¸æˆ...æŒ‰ç…§é¢˜ç›®ç»™å®šçš„â€œæ¸¸æˆè§„åˆ™â€æ¥å¤„ç†å°±è¡Œäº†ï¼Œç”±äºŽéœ€è¦åˆ¤æ–­æ•°å­—æ˜¯å¦â€œå¹¸ç¦â€ï¼Œå€ŸåŠ©å“ˆå¸Œè¡¨æ— ç–‘æ˜¯æœ€å¿«æ·ã€æ–¹ä¾¿çš„é€‰æ‹©ã€‚ Codeä¸‹é¢æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œæœ‰ç‚¹ä¹±è§è°…ï¼Œè¿™æ®µä»£ç å…¶å®žç”¨åˆ°çš„æ€æƒ³éƒ½æ˜¯ C é‡Œé¢çš„ä¸œè¥¿ï¼Œå°† cin å’Œ cout æ¢æˆ scanf å’Œ printf è¯´ä¸å®šè¿˜èƒ½å¿«ç‚¹å‘¢ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100000 + 5;int hashtable[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; hashtable[i] = 0; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; while(n--) &#123; int num, degree = 0; cin &gt;&gt; num; init(); if(num == 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int tmp = num; while(1) &#123; int digit, res = 0; hashtable[tmp] = 1; while(tmp) &#123; digit = tmp % 10; res += pow(digit, 3); tmp /= 10; &#125; degree++; hashtable[res]++; if(res == 1) &#123; cout &lt;&lt; degree &lt;&lt; endl; break; &#125; else if(hashtable[res] == 2) &#123; cout &lt;&lt; res &lt;&lt; endl; break; &#125; tmp = res; &#125; &#125; return 0;&#125; 7-3 ä¸‰é˜¶å¹¸ç¦æ•°æ®é¦™æ¸¯ã€Šå—åŽæ—©æŠ¥ã€‹2019å¹´7æœˆ15æ—¥æ–‡ç« ï¼Œä¸Šæµ·ä¸¥æ ¼çš„åžƒåœ¾åˆ†ç±»æ–°è§„ä»¤ä¸å°‘å±…æ°‘æŠ“ç‹‚ã€‚è¿™å‚¬ç”Ÿå‡ºå¤§é‡å¸®åŠ©æ‰¾å‡ºæ­£ç¡®åˆ†ç±»ç­”æ¡ˆçš„Appå’Œå°ç¨‹åºã€‚ç›®å‰ä»…å¾®ä¿¡ä¸Šå°±è‡³å°‘æœ‰280ç§ä¸Žåžƒåœ¾å¤„ç†æœ‰å…³çš„Appï¼Œåœ¨è‹¹æžœåº”ç”¨å•†åº—ä¹Ÿè¾¾130ç§ã€‚æ”¯ä»˜å®è¡¨ç¤ºï¼Œå·²æœ‰60å¤šå®¶ç‹¬ç«‹Appå¼€å‘å•†ç”³è¯·ä¸ºè¯¥å¹³å°æä¾›ç±»ä¼¼æœåŠ¡ã€‚æœ¬é¢˜å°±è¯·ä½ çŽ°åœºå®žçŽ°ä¸€ä¸ªç®€å•çš„åžƒåœ¾åˆ†ç±»å°åŠ©æ‰‹ã€‚ è¾“å…¥é¦–å…ˆç»™å‡ºå®˜æ–¹åˆ†ç±»æŒ‡å—ä¸­æ¯ç§ç‰©å“çš„å½’å±žã€‚åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10â€‹5â‰¤10â€‹5 \le10â€‹^5â‰¤10â€‹5â€‹â€‹ï¼‰ï¼Œå³ç‰©å“æ•°é‡ï¼›éšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç‰©å“åç§°ï¼ˆé•¿åº¦ä¸è¶…è¿‡ 10 çš„ã€ç”±å°å†™è‹±æ–‡å­—æ¯å’Œä¸‹åˆ’çº¿ç»„æˆçš„å­—ç¬¦ä¸²ï¼‰å’Œè¯¥ç‰©å“æ‰€å±žçš„åˆ†ç±»ï¼ˆ1 ä»£è¡¨å¹²åžƒåœ¾ã€2 ä»£è¡¨æ¹¿åžƒåœ¾ã€3 ä»£è¡¨å¯å›žæ”¶ç‰©ã€4 ä»£è¡¨æœ‰å®³åžƒåœ¾ï¼‰ã€‚é¢˜ç›®ä¿è¯æ‰€æœ‰ç‰©å“åç§°æ— é‡å¤ã€‚éšåŽæ¯è¡Œç»™å‡ºä¸€ä¸ªæŸ¥è¯¢ç‰©å“çš„åç§°ï¼ˆæ ¼å¼ä¸ŽæŒ‡å—ç‰©å“åç§°ç›¸åŒï¼‰ã€‚æœ€åŽä¸€è¡Œç»™å‡ºç»“æŸç¬¦ #ï¼Œè¡¨ç¤ºæŸ¥è¯¢ç»ˆæ­¢ï¼Œè¿™ä¸€è¡Œä¸éœ€è¦æŸ¥è¯¢ã€‚ å¯¹æ¯ä¸ªæŸ¥è¯¢çš„ç‰©å“ï¼Œåœ¨ä¸€è¡Œä¸­ç»™å‡ºå…¶æ‰€å±žåˆ†ç±»ï¼šGan laji ä»£è¡¨å¹²åžƒåœ¾ï¼›Shi laji ä»£è¡¨æ¹¿åžƒåœ¾ï¼›Ke Hui Shou ä»£è¡¨å¯å›žæ”¶ç‰©ï¼›You Hai laji ä»£è¡¨æœ‰å®³åžƒåœ¾ã€‚å¦‚æžœæŸ¥è¯¢çš„ç‰©å“ä¸åœ¨æŒ‡å—ä¸­ï¼Œåˆ™è¾“å‡º ? è¡¨ç¤ºä¸çŸ¥é“ã€‚ Input12345678910114bao_zhi 3dian_chi 4dan_ke 2bei_ke 1dan_kedian_chiren_zhabao_zhibei_ke# Output12345Shi lajiYou Hai laji?Ke Hui ShouGan laji Analysisè€ƒè¯•æ—¶ï¼Œåšè¿™ä¸ªé¢˜åªæƒ³åˆ°äº† mapï¼Œæ²¡æƒ³åˆ° unordered mapï¼Œå•çº¯åªç”¨ mapï¼Œ3åˆ†ï¼Œunordered mapï¼ŒACã€‚æ„Ÿè§‰æŸå¤±æƒ¨é‡... å¦å¤–ï¼Œèƒ½ä¸ç”¨ cin å’Œ coutï¼Œè¿˜æ˜¯å°½é‡ä¸ç”¨... Codeä¸‹é¢æ˜¯å½“æ—¶ç”¨ map å†™çš„ä»£ç ï¼š123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; rab2id;int main() &#123; int n, id; cin &gt;&gt; n; string str; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; id; rab2id[str] = id; &#125; while(cin &gt;&gt; str &amp;&amp; str != "#") &#123; if(rab2id[str] == 1) &#123; cout &lt;&lt; "Gan laji\n"; &#125; else if(rab2id[str] == 2) &#123; cout &lt;&lt; "Shi laji\n"; &#125; else if(rab2id[str] == 3) &#123; cout &lt;&lt; "Ke Hui Shou\n"; &#125; else if(rab2id[str] == 4) &#123; cout &lt;&lt; "You Hai laji\n"; &#125; else cout &lt;&lt; "?\n"; &#125; return 0;&#125; ä¸‹é¢æ˜¯ AC çš„ä»£ç ï¼ˆå¦‚æžœä¸æƒ³é‚£ä¹ˆå¤š if-elseï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨å­—ç¬¦ä¸²æ•°ç»„æ¥è¾“å‡ºï¼‰ï¼š123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; rab2id;char s[20]; int main() &#123; int n, id; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", s, &amp;id); rab2id[s] = id; &#125; while(scanf("%s", s) != EOF) &#123; string str(s); if(str == "#") &#123; break; &#125; else if(rab2id[str] == 1) &#123; printf("Gan laji\n"); &#125; else if(rab2id[str] == 2) &#123; printf("Shi laji\n"); &#125; else if(rab2id[str] == 3) &#123; printf("Ke Hui Shou\n"); &#125; else if(rab2id[str] == 4) &#123; printf("You Hai laji\n"); &#125; else printf("?\n"); &#125; return 0;&#125; æ€»ç»“ä¸‰é“ 20 åˆ†çš„é¢˜ç›®ï¼Œåº”è¯¥å°±æ˜¯ä¹™çº§ 20 åˆ†é¢˜ç›®çš„éš¾åº¦ï¼Ÿ å¯èƒ½æ˜¯æˆ‘å¤ªä¹…æ²¡æœ‰å†™ä»£ç çš„ç¼˜æ•…äº†ï¼Œç¬¬ä¸€é“é¢˜ç›®è¢«è¿·æƒ‘äº†æŒºä¹…çš„ï¼ŒåŽŸæœ¬åº”è¯¥åå‡ åˆ†é’Ÿå°±æžå®šçš„ï¼Œç»“æžœå¥½åƒå¿«åŠä¸ªå°æ—¶æ‰æžå®š... ç¬¬äºŒé“é¢˜ç›®æžœç„¶è§£å†³èµ·æ¥å°±å¿«äº†è®¸å¤šï¼ˆç¨å¾®ç†Ÿæ‚‰äº†ä¸€ç‚¹ï¼‰ï¼Œä¸è¿‡æ„å¤–çš„æ˜¯æ²¡æƒ³åˆ°æœ‰è¿™ä¹ˆå¤šæµ‹è¯•ç‚¹... ç¬¬ä¸‰é“é¢˜ç›®åªæƒ³åˆ°äº† map æ— ç–‘æ˜¯ä¸ªè´¥ç¬”ï¼Œä¸è¿‡ä¹Ÿåæ˜ äº†è‡ªå·±å¿˜è®°äº†å¤ªå¤šä¸œè¥¿äº†...ðŸ˜±è€Œä¸”é¢å¯¹è¿™ç§å¡è¶…æ—¶çš„é¢˜ç›®ï¼ŒèŽ«åçš„æœ‰ç‚¹è™šã€‚ åæ­£ä¸‰é“é¢˜ç›®éƒ½ä¸éš¾å°±æ˜¯äº†ï¼Œæ²¡å…¨éƒ¨ ACï¼Œè¯¥æ£€è®¨ã€‚ç‰¹åˆ«æ˜¯æœ€åŽä¸€é¢˜ï¼Œå‡ åˆ†é’Ÿå°±æ‹¿åˆ°äº† 3 åˆ†ï¼ŒåŽé¢ 40 åˆ†é’Ÿéƒ½é˜µäº¡äº†... PSï¼šå‰ä¸¤é“é¢˜éƒ½æ˜¯ä¸€æ¬¡ AC]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_04-æ ‘ï¼ˆä¸­ï¼‰]]></title>
    <url>%2F2020%2F05%2F01%2FZJU-DS-04-%E6%A0%91%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[å‰é¢å­¦ä¹ äº†æ ‘çš„åŸºæœ¬æœ¯è¯­ã€æ€§è´¨ï¼Œä»¥åŠäºŒå‰æ ‘çš„å½¢æ€ã€éåŽ†æ–¹æ³•ç­‰ï¼Œè¿™æ¬¡ä¼šç»§ç»­å­¦ä¹ ä¸¤ç§â€œæ–°â€äºŒå‰æ ‘ Binary Search Treeå®šä¹‰äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼ŒBinary Search Treeï¼‰ï¼Œä¹Ÿæˆä¸ºäºŒå‰æŽ’åºæ ‘æˆ–äºŒå‰æŸ¥æ‰¾æ ‘ã€‚äºŒå‰æœç´¢æ ‘ï¼šå‰æå¾—æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå¯ä»¥ä¸ºç©ºï¼›å¦‚æžœä¸ä¸ºç©ºï¼Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š éžç©ºå·¦å­æ ‘çš„æ‰€æœ‰é”®å€¼å°äºŽå…¶æ ¹ç»“ç‚¹çš„é”®å€¼ éžç©ºå³å­æ ‘çš„æ‰€æœ‰é”®å€¼å¤§äºŽå…¶æ ¹èŠ‚ç‚¹çš„é”®å€¼ å·¦ã€å³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ ç‰¹åˆ«å‡½æ•°äºŒå‰æœç´¢æ ‘æœ¬è´¨ä¸Šè¿˜æ˜¯äºŒå‰æ ‘ï¼Œæ‰€ä»¥å…¶æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ä¸ŽäºŒå‰æ ‘æ˜¯ä¸€è‡´çš„ï¼Œä½†æ“ä½œé›†å­˜åœ¨å·®å¼‚ï¼Œå¤šäº†å‡ ä¸ªç‰¹åˆ«å‡½æ•°ï¼š Position Find(ElementType X, BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å…ƒç´ Xï¼Œè¿”å›žå…¶æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ Position FindMin(BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å¹¶è¿”å›žæœ€å°å…ƒç´ æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ Position FindMax(BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å¹¶è¿”å›žæœ€å¤§å…ƒç´ æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ BinTree Insert(ElementType X, BinTree BST)ï¼Œå‘äºŒå‰æœç´¢æ ‘ä¸­æ’å…¥ç»“ç‚¹ BinTree Delete(ElementType X, BinTree BST)ï¼Œåœ¨äºŒå‰æœç´¢æ ‘ä¸­åˆ é™¤ç»“ç‚¹ ä¸‹é¢ä»¥äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æž„ä¸ºå‡†ï¼Œå®Œæˆå‡ ä¸ªå¸¸ç”¨çš„ç‰¹åˆ«å‡½æ•°ã€‚ æŸ¥æ‰¾æŸ¥æ‰¾å‡½æ•°çš„å®žçŽ°æ€è·¯æ¯”è¾ƒç›´æŽ¥ï¼ŒæŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œæ¯”æ ¹ç»“ç‚¹å°åˆ™åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾ï¼Œæ¯”æ ¹èŠ‚ç‚¹å¤§åˆ™åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾ï¼Œå¾ªçŽ¯è¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚ é€’å½’123456Position Find(ElementType X, BinTree BST) &#123; if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(X, BST-&gt;Right); else if(X &lt; BST-&gt;Data) return Find(X, BST-&gt;Left); else return BST;&#125; éžé€’å½’12345678Position IterFind(ElementType X, BinTree BST) &#123; while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else return BST; &#125; return NULL;&#125; æŸ¥æ‰¾æœ€å€¼æœ‰äº†å‰é¢æŸ¥æ‰¾çš„æ€è·¯åŽï¼Œæ ¹æ® BST çš„æ€§è´¨ï¼Œç›´æŽ¥æŸ¥æ‰¾æœ€å€¼çš„å‡½æ•°ä¹Ÿå¾ˆå®¹æ˜“å¾—åˆ°ã€‚ é€’å½’1234567891011Position FindMax(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else FindMin(BST);&#125;Position FindMin(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else FindMin(BST);&#125; éžé€’å½’12345678910111213Position FindMax(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Right) BST = BST-&gt;Right; &#125; return BST;&#125;Position FindMin(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Left) BST = BST-&gt;Left; &#125; return BST;&#125; æ’å…¥æ’å…¥çš„å…³é”®åœ¨äºŽå…ˆç¡®å®šå¥½æ’å…¥çš„ä½ç½®ï¼Œæ—¢ç„¶è¦ç¡®å®šä½ç½®ï¼Œé‚£ä¹ˆå°±å¯ä»¥å€ŸåŠ©æŸ¥æ‰¾çš„æ€è·¯ã€‚ é€’å½’1234567891011BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST;&#125; éžé€’å½’123456789101112131415161718192021222324BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125; åˆ é™¤åˆ é™¤çš„æ€è·¯ä¸Žæ’å…¥çš„æ€è·¯ä¹Ÿç±»ä¼¼ï¼Œè¿˜æ˜¯éœ€è¦å…ˆæ‰¾åˆ é™¤çš„ä½ç½®ã€‚ä½†æ˜¯é’ˆå¯¹åˆ é™¤ç»“ç‚¹çš„ä¸åŒï¼ˆå¶ç»“ç‚¹å’Œéžå¶ç»“ç‚¹ï¼‰ï¼Œéœ€è¦åˆ†åˆ«è€ƒè™‘ã€‚å¦‚æžœåˆ é™¤çš„æ˜¯å¶ç»“ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥åˆ é™¤ï¼›ä½†è‹¥åˆ é™¤éžå¶ç»“ç‚¹ï¼Œå°±éœ€è¦åœ¨åˆ é™¤è¿™ä¸ªç»“ç‚¹åŽï¼Œç”¨å¦ä¸€ç»“ç‚¹æ›¿ä»£è¢«åˆ é™¤ç»“ç‚¹ï¼Œè¿™æ ·æ‰ä¸ä¼šä½¿é“¾å¼ç»“æž„æ–­è£‚ã€‚ å¯¹äºŽåº¦ä¸º 1 çš„è¢«åˆ é™¤ç»“ç‚¹ï¼Œå¦ä¸€ç»“ç‚¹ç›´æŽ¥ä½¿ç”¨å…¶å­ç»“ç‚¹å³å¯ï¼›å¯¹äºŽåº¦ä¸º 2 çš„è¢«åˆ é™¤ç»“ç‚¹ï¼Œå¦ä¸€ç»“ç‚¹å¯ä»¥ç”¨å…¶å³å­æ ‘çš„æœ€å°å…ƒç´ æˆ–è€…å…¶å·¦å­æ ‘çš„æœ€å¤§å…ƒç´ ï¼Œä¹‹æ‰€è¦ç”¨è¿™ä¸¤ä¸ªç»“ç‚¹ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç»“ç‚¹ä¸€å®šæ˜¯å¶ç»“ç‚¹ï¼Œå¯ä»¥ç›´æŽ¥æ‹¿æŽ‰ã€‚123456789101112131415161718192021222324252627BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125; Balanced Treeå¹³è¡¡äºŒå‰æ ‘éœ€è¦å¼•å…¥å¹³è¡¡å› å­çš„æ¦‚å¿µï¼Œå…¶è§£å†³äº†äºŒå‰æœç´¢æ ‘ä¸­å‡ºçŽ°â€œå•æžæ ‘â€è€Œå¯¼è‡´æŸ¥æ‰¾æ•ˆçŽ‡è¿‡ä½Žçš„æ ‘å½¢ç»“æž„é—®é¢˜ã€‚ å¹³è¡¡å› å­ï¼ˆBalance Factorï¼ŒBFï¼‰ï¼š$BF(T) = h_l - h_r$ï¼Œå…¶ä¸­$h_l$å’Œ$h_r$åˆ†åˆ«ä¸ºæ ‘ T çš„å·¦å³å­æ ‘é«˜åº¦ã€‚ å®šä¹‰å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Treeï¼Œä¹Ÿå« AVL æ ‘ï¼‰:ç©ºæ ‘ï¼Œæˆ–è€…ä»»ä½•ä¸€ç»“ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ï¼Œå³$|BF(T)| \le 1$ã€‚ è°ƒæ•´å¹³è¡¡äºŒå‰æ ‘çš„ç»“æž„è°ƒæ•´æƒ…å†µæœ‰ä»¥ä¸‹å››ç§æƒ…å†µï¼Œå…³é”®åœ¨äºŽè§‚å¯Ÿç¦»ç ´åè€…æœ€è¿‘çš„è¢«ç ´åè€…å’Œç ´åè€…ä¹‹é—´çš„ä½ç½®å…³ç³»ã€‚ä½†æ˜¯è¦æ³¨æ„æœ‰æ—¶å€™æ’å…¥å…ƒç´ å³ä¾¿ä¸éœ€è¦è°ƒæ•´ç»“æž„ï¼Œä¹Ÿå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—ä¸€äº›å¹³è¡¡å› å­ã€‚RRLLLRRLRRæ—‹è½¬ï¼ˆè™½ç„¶å« RR æ—‹è½¬ï¼Œä½†æ˜¯å®žé™…è¿‡ç¨‹æ˜¯å·¦æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å³å­æ ‘çš„å³å­æ ‘ä¸‹ã€‚ 12345678Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LLæ—‹è½¬ï¼ˆè™½ç„¶å« LL æ—‹è½¬ï¼Œä½†æ˜¯å®žé™…è¿‡ç¨‹æ˜¯å³æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å·¦å­æ ‘çš„å·¦å­æ ‘ä¸‹ã€‚ 12345678Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LRæ—‹è½¬ï¼ˆä¸Žåç§°ä¸€è‡´ï¼Œå…ˆå·¦æ—‹åŽå³æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å·¦å­æ ‘çš„å³å­æ ‘ä¸‹ã€‚ 1234Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;RLæ—‹è½¬ï¼ˆä¸Žåç§°ä¸€è‡´ï¼Œå…ˆå³æ—‹åŽå·¦æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å³å­æ ‘çš„å·¦å­æ ‘ä¸‹ã€‚ 1234Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125; Homework04-4 æ˜¯å¦åŒä¸€æ£µäºŒå‰æœç´¢æ ‘è¿™é“é¢˜ä¸Žæ ‘çš„åŒæž„æœ‰ç‚¹åƒï¼Œä¸‹é¢çš„ä»£ç åŒ…å«ä¸¤ç§åšæ³•ï¼š æž„é€ ä¸¤æ£µæ ‘ï¼Œåˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ä¸€è‡´ åªæž„é€ ä¸€æ£µæ ‘ï¼Œåˆ¤æ–­ç»™å®šåºåˆ—é¡ºåºæ˜¯å¦ä¸Žæ ‘çš„ç»“ç‚¹åºåˆ—ä¸€è‡´ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* method 1: use recursion to judge two trees is same or not */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;PtrToTNode createnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct TNode)); t-&gt;left = t-&gt;right = NULL; t-&gt;data = data; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = createnode(data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); return root;&#125;bool issame(Tree root1, Tree root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if((!root1 &amp;&amp; root2) &amp;&amp; (root1 &amp;&amp; !root2)) return false; else &#123; if(root1-&gt;data != root2-&gt;data) return false; else return issame(root1-&gt;left, root2-&gt;left) &amp;&amp; issame(root1-&gt;right, root2-&gt;right); &#125;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l; scanf("%d", &amp;n); while(n) &#123; scanf("%d", &amp;l); Tree root1 = NULL; int i, data; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root1 = insert(root1, data); &#125; while(l--) &#123; Tree root2 = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root2 = insert(root2, data); &#125; if(issame(root1, root2)) printf("Yes\n"); else printf("No\n"); destorytree(root2); &#125; scanf("%d", &amp;n); if(n == 0) destorytree(root1); &#125; return 0;&#125;/* method 2: constitute a tree, check the path of visiting everynodes is sameor not #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct node&#123; int flag, data; struct node *left, *right;&#125;;typedef struct node* Tree;typedef struct node* PtrToTNode;PtrToTNode newnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct node)); t-&gt;data = data; t-&gt;flag = 0; t-&gt;left = t-&gt;right = NULL; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = newnode(data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); return root;&#125;Tree buildtree(int n) &#123; int i, data; Tree root = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; return root;&#125;bool check(Tree root, int data) &#123; if(root-&gt;flag) &#123; if(data &lt; root-&gt;data) return check(root-&gt;left, data); else if(data &gt; root-&gt;data) return check(root-&gt;right, data); else return false; &#125; else &#123; if(data == root-&gt;data) &#123; root-&gt;flag = 1; return true; &#125; else return false; &#125;&#125;bool judge(Tree root, int n) &#123; int i, data; bool flag = false; scanf("%d", &amp;data); if(data != root-&gt;data) flag = true; else root-&gt;flag = 1; for(i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;data); if(!flag &amp;&amp; !check(root, data)) flag = 1; &#125; return !flag;&#125;void reset(Tree root) &#123; if(root-&gt;left) reset(root-&gt;left); if(root-&gt;right) reset(root-&gt;right); root-&gt;flag = 0;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l, i; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;l); Tree root = buildtree(n); while(l--) &#123; if(judge(root, n)) printf("Yes\n"); else printf("No\n"); reset(root); &#125; destorytree(root); &#125; return 0;&#125; */ 04-5 Root of AVL Treeè¿™é“é¢˜å°±æ˜¯ä½•è€å¸ˆè®²çš„å¹³è¡¡äºŒå‰æ ‘çš„å››ç§æ—‹è½¬æ–¹å¼ï¼Œé¢˜ç›®ä¸€æ¬¡å°†å››ç§æ—‹è½¬æ–¹å¼å…¨éƒ¨è€ƒå¯Ÿåˆ°äº†ï¼Œå‡ºçš„å¾ˆå¥½ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data, height; struct TNode *lchild, *rchild;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int getheight(Tree root) &#123; if(!root) return -1; else return root-&gt;height;&#125;Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125;Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;Tree insert(Tree root, int data) &#123; if(!root) &#123; root = (Tree)malloc(sizeof(struct TNode)); root-&gt;lchild = root-&gt;rchild = NULL; root-&gt;data = data; root-&gt;height = 0; &#125; else if(data &gt; root-&gt;data) &#123; root-&gt;rchild = insert(root-&gt;rchild, data); if(getheight(root-&gt;rchild) - getheight(root-&gt;lchild) == 2) &#123; if(data &gt; root-&gt;rchild-&gt;data) root = RRrotate(root); else root = RLrotate(root); &#125; &#125; else if(data &lt; root-&gt;data) &#123; root-&gt;lchild = insert(root-&gt;lchild, data); if(getheight(root-&gt;lchild) - getheight(root-&gt;rchild) == 2) &#123; if(data &lt; root-&gt;lchild-&gt;data) root = LLrotate(root); else root = LRrotate(root); &#125; &#125; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return root;&#125;int main() &#123; int i, n, data; scanf("%d", &amp;n); Tree root = NULL; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; printf("%d", root-&gt;data); return 0;&#125; 04-6 Complete Binary Search Treeè¿™é“é¢˜å¾ˆæœ‰éš¾åº¦ï¼Œè¦å¯¹å®Œå…¨äºŒå‰æ ‘ã€äºŒå‰æŸ¥æ‰¾æ ‘åŠäºŒå‰æ ‘çš„éåŽ†æœ‰è¾ƒæ·±çš„ç†è§£æ‰èƒ½è§£å‡ºæ¥ï¼Œä¸è¿‡è§£ä¸å‡ºæ¥ä¹Ÿæ²¡äº‹ï¼Œå§¥å§¥åŽé¢ä¼šè®²ã€‚123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1005int n, tree[maxn], seq[maxn], inde = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); tree[root] = seq[inde++]; inorder(2 * root + 1);&#125;int cmp(const void *a, const void *b) &#123; return (*(int*)a - *(int*)b);&#125;int main() &#123; scanf("%d", &amp;n); int i; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;seq[i]); &#125; qsort(seq, n, sizeof(seq[0]), cmp); inorder(1); for(i = 1; i &lt;= n; ++i) &#123; printf("%d", tree[i]); if(i &lt; n) printf(" "); &#125; return 0;&#125; 04-7 äºŒå‰æœç´¢æ ‘çš„æ“ä½œé›†è¿™é“é¢˜ç›®æ˜¯ç”¨æ¥æµ‹è¯•äºŒå‰æœç´¢æ ‘å¸¸ç”¨æ“ä½œçš„ï¼Œå¯ä»¥å°è¯•å¤šç§ä¸åŒçš„å†™æ³•æ¥æäº¤æ¥éªŒè¯æ˜¯å¦æ­£ç¡®ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT );void InorderTraversal( BinTree BT );BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST = NULL; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Insert(BST, X); &#125; printf("Preorder:"); PreorderTraversal(BST); printf("\n"); MinP = FindMin(BST); MaxP = FindMax(BST); scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); Tmp = Find(BST, X); if (Tmp == NULL) printf("%d is not found\n", X); else &#123; printf("%d is found\n", Tmp-&gt;Data); if (Tmp==MinP) printf("%d is the smallest key\n", Tmp-&gt;Data); if (Tmp==MaxP) printf("%d is the largest key\n", Tmp-&gt;Data); &#125; &#125; scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Delete(BST, X); &#125; printf("Inorder:"); InorderTraversal(BST); printf("\n"); return 0;&#125;void PreorderTraversal( BinTree BT ) &#123; if(!BT) return; printf("%d ", BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void InorderTraversal( BinTree BT ) &#123; if(!BT) return; InorderTraversal(BT-&gt;Left); printf("%d ", BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST; */ /* method 2: use loop */ if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125;Position Find( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) return Find(BST-&gt;Left, X); else return BST; */ /* method 2: use loop*/ while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else break; &#125; return BST;&#125;Position FindMin( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Left) BST = BST-&gt;Left; return BST;&#125;Position FindMax( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else return FindMax(BST-&gt;Right); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Right) BST = BST-&gt;Right; return BST;&#125;/*samples:in:105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3out:Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_03-æ ‘ï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F04%2F01%2FZJU-DS-03-%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯æ ‘ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿæ ‘åˆæœ‰ä»€ä¹ˆæ ·æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ å¼•è¨€åœ¨äº†è§£æ ‘ä¹‹å‰ï¼Œå…ˆäº†è§£ä¸€ä¸‹æ ‘åœ¨ç”Ÿæ´»ä¸­çš„åº”ç”¨ï¼Œæ¯”å¦‚ï¼šäººç±»ç¤¾ä¼šçš„å®¶è°±ã€ç¤¾ä¼šç»„ç»‡ç»“æž„å’Œå›¾ä¹¦ä¿¡æ¯ç®¡ç†ã€‚è¿™ç±»ä¿¡æ¯ç»“æž„éƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯å†…éƒ¨çš„ä¸åŒäº‹ç‰©ä¹‹é—´éƒ½å…·æœ‰å±‚æ¬¡å…³ç³»ã€‚ æŸ¥æ‰¾æŸ¥æ‰¾æ˜¯è®¡ç®—æœºä¸­çš„åŸºç¡€æ“ä½œï¼Œæ‰€è°“åŸºç¡€ï¼Œå³æ˜¯æŒ‡æŸ¥æ‰¾æ“ä½œå¹¿æ³›ä½¿ç”¨åœ¨è®¡ç®—æœºçš„å„ä¸ªåº”ç”¨ï¼Œä¼˜ç§€çš„æŸ¥æ‰¾ç®—æ³•å¯¹äºŽæé«˜ç¨‹åºæŸ¥æ‰¾æ•ˆçŽ‡å¾ˆæœ‰å¸®åŠ©ã€‚ æŸ¥æ‰¾ï¼šæ ¹æ®æŸä¸ªç»™å®šå…³é”®å­— K ï¼Œä»Žé›†åˆ R ä¸­æ‰¾å‡ºå…³é”®å­—ä¸ŽKç›¸åŒçš„è®°å½•ï¼ŒæŸ¥æ‰¾å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š é™æ€æŸ¥æ‰¾ï¼šé›†åˆä¸­è®°å½•æ˜¯å›ºå®šçš„ï¼Œæ²¡æœ‰æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œåªæœ‰æŸ¥æ‰¾ åŠ¨æ€æŸ¥æ‰¾ï¼šé›†åˆä¸­è®°å½•æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œé™¤æŸ¥æ‰¾æ“ä½œå¤–ï¼Œè¿˜å¯èƒ½ä¼šæœ‰æ’å…¥å’Œåˆ é™¤æ“ä½œ ä¸‹é¢ä»…å°±é™æ€æŸ¥æ‰¾å±•å¼€è®¨è®ºã€‚ é™æ€æŸ¥æ‰¾é™æ€æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œæ ¹æ®å­˜å‚¨ç»“æž„çš„ä¸åŒæœ‰ç€å¤šç§å¤šæ ·çš„æ–¹æ³•ï¼Œä¸‹é¢ä»¥æ•°ç»„ä¸ºä¾‹æ¥å±•å¼€è®¨è®ºã€‚ é¡ºåºæŸ¥æ‰¾åˆ©ç”¨æ•°ç»„ä¸‹æ ‡æ¥ä½œä¸ºå¾ªçŽ¯çš„è¾¹ç•Œï¼Œä¹Ÿå¯ä»¥é€šè¿‡â€œå“¨å…µâ€çš„è®¾è®¡æŠ€å·§æ¥é¿å…ä½¿ç”¨ä¸‹æ ‡ä½œä¸ºè¾¹ç•Œå€¼ï¼Œå…·ä½“è€Œè¨€ï¼Œå³å½“å‰ä¸‹æ ‡çš„æ•°ç»„å€¼ä¸Žå“¨å…µçš„å€¼ç›¸ç­‰æ—¶ï¼Œè·³å‡ºå¾ªçŽ¯ï¼Œä»£ç å¦‚ä¸‹ï¼š123456int SequentialSearch(StaticTable *Tbl, ElementType K) &#123; int i; Tbl-&gt;ElementType[0] = K; for(i = Tbl-&gt;Length; Tbl-&gt;ElementType[i] != K; i--); return i;&#125; æ˜¾ç„¶ï¼Œé¡ºåºæŸ¥æ‰¾ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ã€‚ äºŒåˆ†æŸ¥æ‰¾äºŒåˆ†æŸ¥æ‰¾åœ¨ç¬¬ä¸€å‘¨çš„ä½œä¸šé¢˜ä¸­å·²ç»è§è¿‡äº†ã€‚å®žé™…ä¸Šï¼ŒäºŒåˆ†æŸ¥æ‰¾æ˜¯æœ‰å‰æçš„ï¼š åºåˆ—æœ‰åº å­˜å‚¨åœ¨æ•°ç»„ä¸­ åœ¨æœ‰åºçš„åŸºç¡€ä¸‹ï¼Œå‡è‹¥è¦æŸ¥æ‰¾å€¼Xï¼Œåˆ†åˆ«è®¾ç½®leftã€midã€rightä¸‰ä¸ªä¸‹æ ‡å€¼ã€‚æ¯æ¬¡æ—¶ï¼ŒæŸ¥æ‰¾mid = (left + right)/2ï¼Œå¦‚è‹¥array[mid] &gt; Xï¼Œåˆ™æœ‰mid = right - 1ï¼Œå¦‚è‹¥array[mid] &lt; Xï¼Œåˆ™æœ‰mid = left + 1ï¼Œå½“left &lt;= rightè¿™ä¸ªæ¡ä»¶ä¸æˆç«‹æ—¶ï¼Œè·³å‡ºå¾ªçŽ¯ã€‚ æ³¨æ„ï¼šæ¯æ¬¡æ›´æ–°çš„leftå’Œrightä¸èƒ½ä¸ºmidã€‚ äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹å®žé™…ä¸Šå¯ä»¥æž„é€ å‡ºä¸€æ£µäºŒåˆ†æŸ¥æ‰¾åˆ¤å®šæ ‘ï¼Œè€Œåœ¨è¿™æ£µåˆ¤å®šæ ‘ä¸Šï¼Œæ¯ä¸ªç»“ç‚¹éœ€è¦æŸ¥æ‰¾çš„æ¬¡æ•°åˆšå¥½ä¸ºè¯¥èŠ‚ç‚¹æ‰€åœ¨çš„å±‚æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŸ¥æ‰¾æˆåŠŸæ—¶çš„æŸ¥æ‰¾æ¬¡æ•°ä¸ä¼šè¶…è¿‡åˆ¤å®šæ ‘çš„æ·±åº¦ï¼Œä»Žè€Œå¯ä»¥å¾—åˆ°ï¼Œn ä¸ªç»“ç‚¹çš„åˆ¤å®šæ ‘çš„æ·±åº¦ä¸º$[log_{2}n] + 1$ï¼Œè¿™é‡Œå°±åˆæœ‰äº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µ â€” ASL, Average Search Lengthï¼Œå¹³å‡æŸ¥æ‰¾æ¬¡æ•°ï¼ˆä¹Ÿå«å¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼ŒåŽé¢å•ç‹¬è®²æŸ¥æ‰¾æ—¶ä¼šå†æ¬¡é‡åˆ°ï¼‰ ,å¯å¾—ï¼š$ASL = (4 \times 4 + 4 \times 3 + 2 \times 2 + 1) \div 11 = 3$ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112int BinarySearch(StaticTable *Tbl, ElementType K) &#123; int left, right, mid, NotFound = -1; left = 1; right = Tbl-&gt;Length; while(left &lt;= right) &#123; mid = (left + right) / 2; if(K &lt; Tbl-&gt;ElementType[mid]) right = mid - 1; else if(K &gt; Tbl-&gt;ElementType[mid]) left = mid + 1; else return mid; &#125; return NotFound;&#125; äºŒåˆ†æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å‰é¢å·²ç»åˆ†æžè¿‡äº†æ˜¯$O(logN)$ã€‚ æ ‘å®šä¹‰æ ‘ï¼ˆTreeï¼‰ï¼šnï¼ˆnâ‰¥0ï¼‰ä¸ªç»“ç‚¹æž„æˆçš„æœ‰é™é›†åˆï¼Œå½“n=0æ—¶ï¼Œç§°ä¸ºç©ºæ ‘ï¼Œå¯¹äºŽä»»ä½•ä¸€æ£µéžç©ºæ ‘ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹æ€§è´¨ï¼š æ ‘ä¸­æœ‰ä¸€ä¸ªç§°ä¸ºâ€œæ ¹ï¼ˆrootï¼‰â€çš„ç‰¹æ®ŠèŠ‚ç‚¹ï¼Œç”¨rè¡¨ç¤º å…¶ä½™ç»“ç‚¹å¯åˆ†ä¸ºmï¼ˆmï¼ž0ï¼‰ä¸ªäº’ä¸ç›¸äº¤çš„æœ‰é™é›†$T_1, T_2, \ldots, T_m$ï¼Œå…¶ä¸­æ¯ä¸ªé›†åˆæœ¬èº«åˆæ˜¯ä¸€æ£µæ ‘ï¼Œç§°ä¸ºåŽŸæ¥æ ‘çš„â€œå­æ ‘ï¼ˆSubTreeï¼‰â€ã€‚æ³¨æ„ï¼š å­æ ‘ä¸èƒ½ç›¸äº¤ é™¤äº†æ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ ä¸€æ£µNä¸ªèŠ‚ç‚¹çš„æ ‘æœ‰N-1æ¡è¾¹ æ ‘æ˜¯ä¿è¯è¿žé€šä¸”è¾¹æ•°æœ€å°‘çš„ä¸€ç§è¿žæŽ¥æ–¹å¼ åŸºæœ¬æœ¯è¯­ä¸Žæ ‘ç›¸å…³çš„åŸºæœ¬æœ¯è¯­å¦‚ä¸‹ï¼š ç»“ç‚¹çš„åº¦ï¼ˆDegreeï¼‰ï¼šç»“ç‚¹çš„å­æ ‘ä¸ªæ•° æ ‘çš„åº¦ï¼šæ ‘çš„æ‰€æœ‰ç»“ç‚¹ä¸­æœ€å¤§çš„åº¦æ•° å¶ç»“ç‚¹ï¼ˆLeafï¼‰ï¼šåº¦ä¸º 0 çš„ç»“ç‚¹ çˆ¶ç»“ç‚¹ï¼ˆParentï¼‰ï¼šæœ‰å­æ ‘çš„ç»“ç‚¹æ˜¯å…¶å­æ ‘çš„çš„æ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ å­ç»“ç‚¹ï¼ˆChildï¼‰ï¼šè‹¥ A ç»“ç‚¹æ˜¯ B ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ï¼Œåˆ™ç§° B ç»“ç‚¹æ˜¯ A ç»“ç‚¹çš„å­ç»“ç‚¹ï¼Œå­ç»“ç‚¹ä¹Ÿç§°ä¸ºå­©å­ç»“ç‚¹ å…„å¼Ÿç»“ç‚¹ï¼ˆSiblingï¼‰ï¼šå…·æœ‰åŒä¸€çˆ¶ç»“ç‚¹çš„å„ç»“ç‚¹å½¼æ­¤æ˜¯å…„å¼Ÿç»“ç‚¹ è·¯å¾„å’Œè·¯å¾„é•¿åº¦ï¼šä»Žç»“ç‚¹ $n_1$ åˆ° $n_k$ çš„è·¯å¾„ä¸ºä¸€ä¸ªç»“ç‚¹åºåˆ— $n_1, n_2, \ldots, n_k, n_i$ æ˜¯ $n_{i+1}$ çš„çˆ¶ç»“ç‚¹ï¼Œè·¯å¾„æ‰€åŒ…å«çš„ä¸ªæ•°ä¸ºè·¯å¾„çš„é•¿åº¦ã€‚ ç¥–å…ˆç»“ç‚¹ï¼ˆAncestorï¼‰ï¼šæ²¿æ ‘æ ¹åˆ°æŸä¸€ç»“ç‚¹è·¯å¾„ä¸Šæ‰€æœ‰ç»“ç‚¹éƒ½æ˜¯è¿™ä¸ªç»“ç‚¹çš„ç¥–å…ˆç»“ç‚¹ å­å­™ç»“ç‚¹ï¼ˆDescendantï¼‰ï¼šæŸä¸€ç»“ç‚¹çš„å­æ ‘ä¸­çš„æ‰€æœ‰ç»“ç‚¹éƒ½æ˜¯è¿™ä¸ªç»“ç‚¹çš„å­å­™ ç»“ç‚¹çš„å±‚æ¬¡ï¼ˆLevelï¼‰ï¼šè§„å®šæ ¹èŠ‚ç‚¹åœ¨1å±‚ï¼Œå…¶ä»–ä»»ä¸€ç»“ç‚¹çš„å±‚æ•°æ˜¯å…¶çˆ¶ç»“ç‚¹å±‚æ•°åŠ 1 æ ‘çš„æ·±åº¦ï¼ˆDepthï¼‰ï¼šæ ‘ä¸­æ‰€æœ‰ç»“ç‚¹ä¸­çš„æœ€å¤§å±‚æ¬¡æ˜¯è¿™æ£µæ ‘çš„æ·±åº¦ è¡¨ç¤ºæ ‘çš„è¡¨ç¤ºæ–¹æ³•æœ‰å¤šç§ï¼Œå› éœ€è¦è¡¨ç¤ºå…¶ä¸­çš„é€»è¾‘å…³ç³»ï¼Œä¸€èˆ¬ä¼šç”¨é“¾è¡¨å®žçŽ°ï¼Œæ•°ç»„æ— æ³•è¡¨ç¤ºå…¶ä¸­çš„é€»è¾‘å…³ç³»ã€‚ å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•åˆ©ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ¥ä¿å­˜é€»è¾‘å…³ç³»ï¼Œå³ï¼šFirstChildæŒ‡é’ˆç”¨æ¥ä¿å­˜ç¬¬ä¸€ä¸ªå­©å­ç»“ç‚¹çš„åœ°å€ï¼ŒNextSiblingæŒ‡é’ˆç”¨æ¥ä¿å­˜ä¸‹ä¸€ä¸ªå…„å¼Ÿç»“ç‚¹çš„åœ°å€ã€‚è¿™æ ·ï¼Œæ¯ä¸ªç»“ç‚¹éœ€è¦ 2 ä¸ªæŒ‡é’ˆåŸŸï¼Œä¸€æ£µæ ‘å…±æœ‰ $n-1$ æ¡è¾¹ï¼Œè¿™æ ·æµªè´¹çš„æŒ‡é’ˆåŸŸä¸ªæ•°ä¸º $2n - (n-1) = n+1$ã€‚ äºŒå‰æ ‘è¡¨ç¤ºæ³•äºŒå‰æ ‘ç®€è¨€ä¹‹å°±æ˜¯åº¦ä¸º2çš„æ ‘ï¼Œä½†ç›¸è¾ƒåº¦ä¸º 2 çš„æ ‘è€Œè¨€ï¼ŒäºŒå‰æ ‘çš„å­æ ‘æœ‰å·¦å³ä¹‹åˆ†ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œæ‰€æœ‰èƒ½ç”¨å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•è¡¨ç¤ºçš„æ ‘éƒ½å¯ä»¥ç”¨äºŒå‰æ ‘æ¥è¡¨ç¤ºï¼Œåªéœ€å°†å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•å¾—åˆ°çš„æ ‘æ—‹è½¬ 45Â° å³å¯å¾—å¯¹åº”çš„äºŒå‰æ ‘ã€‚ äºŒå‰æ ‘å‰é¢æåˆ°è¿‡äº†ç”¨äºŒå‰æ ‘æ¥è¡¨ç¤ºæ ‘ï¼Œä½†å®žé™…ä¸ŠäºŒå‰æ ‘è‡ªèº«ä¹Ÿå…·æœ‰ååˆ†ç‹¬ç‰¹çš„æ€§è´¨ã€‚ å®šä¹‰äºŒå‰æ ‘Tï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆã€‚è¿™ä¸ªé›†åˆå¯ä»¥ä¸ºç©ºï¼ˆç©ºäºŒå‰æ ‘ï¼‰ï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™å®ƒæ˜¯ç”±æ ¹ç»“ç‚¹å’Œç§°ä¸ºå…¶å·¦å­æ ‘$T_L$å’Œå³å­æ ‘$T_R$çš„ä¸¤ä¸ªä¸ç›¸äº¤çš„äºŒå‰æ ‘ç»„æˆã€‚äºŒå‰æ ‘æœ‰äº”ç§åŸºæœ¬å½¢æ€ï¼šç©ºæ ‘ã€å•ç»“ç‚¹æ ‘ã€å·¦å­æ ‘ä¸ºç©ºçš„æ ‘ã€å³å­æ ‘ä¸ºç©ºçš„æ ‘å’Œå·¦å³å­æ ‘éƒ½ä¸ç©ºçš„æ ‘ã€‚ æ³¨æ„ï¼šäºŒå‰æ ‘ä¸Žæ™®é€šåº¦ä¸º2çš„æ ‘çš„åŒºåˆ«åœ¨äºŽï¼ŒäºŒå‰æ ‘çš„å­æ ‘æœ‰å·¦å³ä¹‹åˆ†ã€‚ ç‰¹æ®ŠäºŒå‰æ ‘ï¼ˆé¢˜ç›®ä¸­ä¹Ÿå¯èƒ½ä¼šå‡ºçŽ°ï¼‰ï¼š æ–œäºŒå‰æ ‘ï¼ˆSkewed Binary Treeï¼‰ï¼šåªæœ‰å·¦ï¼ˆå³ï¼‰å­æ ‘ï¼Œå½¢çŠ¶ä¸Šå‘ˆçŽ°ä¸€è¾¹å€’çš„æ ·å­ï¼Œç±»ä¼¼é“¾è¡¨ å®Œç¾ŽäºŒå‰æ ‘ï¼ˆPerfect Binary Treeï¼‰ï¼Œä¹Ÿå«æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰ï¼šé™¤äº†å¶ç»“ç‚¹å¤–ï¼Œæ¯ä¸€ä¸ªç»“ç‚¹éƒ½æœ‰ä¸¤ä¸ªå„¿å­ç»“ç‚¹ å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰ï¼šæœ‰nä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œå¯¹æ ‘ä¸­ç»“ç‚¹æŒ‰ä»Žä¸Šè‡³ä¸‹ã€ä»Žå·¦åˆ°å³é¡ºåºè¿›è¡Œç¼–å·ï¼Œç¼–å·ä¸ºiï¼ˆ1â‰¤iâ‰¤nï¼‰ç»“ç‚¹ä¸Žæ»¡äºŒå‰æ ‘ä¸­ç¼–å·ä¸ºiç»“ç‚¹åœ¨äºŒå‰æ ‘ä¸­ä½ç½®ç›¸åŒã€‚ æ€§è´¨äºŒå‰æ ‘çš„å‡ ä¸ªé‡è¦æ€§è´¨ï¼š ä¸€ä¸ªäºŒå‰æ ‘ç¬¬ i å±‚çš„æœ€å¤§ç»“ç‚¹æ•°ä¸ºï¼š$2^{i-1}, i \ge 1$ã€‚ æ·±åº¦ä¸º k çš„äºŒå‰æ ‘æœ‰æœ€å¤§ç»“ç‚¹æ ‘ä¸ºï¼š$2^k-1, k \ge 1$ã€‚ å¯¹ä»»ä½•éžç©ºäºŒå‰æ ‘Tï¼Œè‹¥$n_0$è¡¨ç¤ºå¶ç»“ç‚¹çš„ä¸ªæ•°ã€$n_2$æ˜¯åº¦ä¸º2çš„éžå¶ç»“ç‚¹ä¸ªæ•°ï¼Œé‚£ä¹ˆä¸¤è€…æ»¡è¶³å…³ç³»$n_0 = n_2 + 1$ï¼Œè¿™ä¸ªç»“è®ºå¯è¯æ˜Žã€‚ äºŒå‰æ ‘æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šäºŒå‰æ ‘æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™ç”±æ ¹ç»“ç‚¹å’Œå…¶å·¦ã€å³äºŒå‰å­æ ‘ç»„æˆã€‚æ“ä½œé›†ï¼šBT âˆˆ BinTreeï¼ŒItemâˆˆ ElementTypeï¼Œé‡è¦æ“ä½œæœ‰ï¼š Boolean IsEmpty(BinTree BT)ï¼Œåˆ¤åˆ«BTæ˜¯å¦ä¸ºç©º void Traversal(BinTree BT)ï¼ŒéåŽ†ï¼ŒæŒ‰ç…§æŸé¡ºåºè®¿é—®æ¯ä¸ªç»“ç‚¹ BinTree CreatBinTree()ï¼Œåˆ›å»ºä¸€ä¸ªäºŒå‰æ ‘ã€‚ å¸¸è§çš„éåŽ†æ–¹æ³•æœ‰ï¼š void PreOrderTraversal(BinTree BT)ï¼Œå…ˆåºéåŽ†ï¼Œæ ¹â†’å·¦â†’å³ void InOrderTraversal(BinTree BT)ï¼Œä¸­åºéåŽ†ï¼Œå·¦â†’æ ¹â†’å³ void PostOrderTraversal(BinTree BT)ï¼ŒåŽåºéåŽ†ï¼Œå·¦â†’å³â†’æ ¹ void LevelOrderTraversal(BinTree BT)ï¼Œå±‚æ¬¡éåŽ†ï¼Œä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³ äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨ç»“æž„äºŒå‰æ ‘é¡ºåºå­˜å‚¨ä¸€èˆ¬ç›´æŽ¥ä½¿ç”¨ï¼ˆç»“æž„ï¼‰æ•°ç»„å®žçŽ°ï¼Œè€Œå®Œå…¨äºŒå‰æ ‘ç›´æŽ¥ç”¨ä¸€ç»´æ•°ç»„å³å¯å®žçŽ°ï¼Œä¹Ÿæ˜“äºŽæ“ä½œã€‚å¯¹äºŽä½¿ç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼Œå¯ä»¥é€šè¿‡ç»“ç‚¹çš„åºå·ï¼ˆæ•°ç»„çš„ä¸‹æ ‡ï¼‰ä¸­çš„è§„å¾‹æ¥å¸®åŠ©åæ˜ ç»“ç‚¹ä¹‹é—´çš„çˆ¶å­ï¼ˆé€»è¾‘ï¼‰å…³ç³»ï¼Œå…·ä½“å¦‚ä¸‹ï¼š éžæ ¹ç»“ç‚¹ï¼ˆåºå·$iï¼ž1$ï¼‰çš„çˆ¶ç»“ç‚¹çš„åºå·æ˜¯$\lfloor i/2 \rfloor$ ç»“ç‚¹ï¼ˆåºå·ä¸º$i$ï¼‰çš„å·¦å­©å­ç»“ç‚¹çš„åºå·æ˜¯$2i$ï¼Œè‹¥$2i \geqslant n$ï¼Œå¦åˆ™æ²¡æœ‰å·¦å­©å­ ç»“ç‚¹ï¼ˆåºå·ä¸º$i$ï¼‰çš„å·¦å­©å­ç»“ç‚¹çš„åºå·æ˜¯$2i+1$ï¼Œè‹¥$2i+1 \geqslant n$ï¼Œå¦åˆ™æ²¡æœ‰å³å­©å­ ä¸€èˆ¬ç»“æž„çš„äºŒå‰æ ‘ä¹Ÿå¯ä»¥é‡‡ç”¨è¿™ç§ç»“æž„ï¼Œä½†æ˜¯ä¼šé€ æˆç©ºé—´çš„æµªè´¹ï¼Œå› ä¸ºæ•°ç»„ä¸­ä¹Ÿå­˜å‚¨äº†ç©ºç»“ç‚¹ã€‚ äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æž„å®šä¹‰å¦‚ä¸‹ï¼š123456struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree; äºŒå‰æ ‘çš„éåŽ†äºŒå‰æ ‘çš„éåŽ†æ—¢å¯ä»¥ç›´æŽ¥ç”¨é€’å½’çš„æ€æƒ³å®Œæˆï¼Œä¹Ÿå¯ä»¥å€ŸåŠ©æ ˆæ¥æž„é€ éžé€’å½’çš„éåŽ†ç®—æ³•ã€‚å°½ç®¡é€’å½’çš„ç¼ºç‚¹å¾ˆæ˜Žæ˜¾ï¼Œä½†å¥½åœ¨æ˜“äºŽç†è§£ï¼Œä¸”å½¢å¼ç®€å•ï¼Œä¸€èˆ¬è€Œè¨€éƒ½æ˜¯ç”¨é€’å½’æ¥éåŽ†äºŒå‰æ ‘ã€‚ä¸è¿‡ä»Žå­¦ä¹ çš„è§’åº¦æ¥è®²ï¼Œå¤šæŽ¢ç©¶ä¸€ä¸‹æ²¡æœ‰ä»»ä½•åå¤„ï¼Œæ‰€ä»¥ä¸‹é¢çš„å†…å®¹ä¹Ÿç»™å‡ºéžé€’å½’çš„ç®—æ³•ã€‚æ³¨ï¼šä¸‹é¢çš„ä»£ç æœ‰éƒ¨åˆ†æ˜¯ C++ çš„å†…å®¹ï¼Œä½†å¹¶æ²¡æœ‰ç‰¹åˆ«éš¾äºŽç†è§£åœ°æ–¹ã€‚ å…ˆåºéåŽ†éåŽ†è¿‡ç¨‹ï¼šè®¿é—®æ ¹ç»“ç‚¹ â†’ å…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘1234567891011121314151617181920212223void preorder(Tree root) &#123; /* method 1: use recursion if(!root) return; cout &lt;&lt; root-&gt;data &lt;&lt; ' '; preorder(root-&gt;left); preorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; &#125; ä¸­åºéåŽ†éåŽ†è¿‡ç¨‹ï¼šå…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ è®¿é—®æ ¹ç»“ç‚¹ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘1234567891011121314151617181920212223void inorder(Tree root) &#123; /* method 1: use recursion if(!root) return; inorder(root-&gt;left); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; inorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;right; &#125; &#125;&#125; åŽåºéåŽ†éåŽ†è¿‡ç¨‹ï¼šå…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘ â†’ è®¿é—®æ ¹ç»“ç‚¹åŽåºéåŽ†çš„éžé€’å½’ç®—æ³•å…¶å®žæœ‰å¾ˆå¤šï¼Œè¿™é‡Œä¸¾ä¸¤ä¸ªä¾‹å­ï¼Œåˆ†åˆ«ä½¿ç”¨äº† 2 ä¸ªæ ˆå’Œ 1 ä¸ªæ ˆæ¥å®Œæˆï¼Œä½¿ç”¨åŒæ ˆçš„æ€è·¯è¾ƒä¸ºç›´è§‚ä¸€äº›ï¼Œå»ºè®®åŠ¨æ‰‹æ¨¡æ‹Ÿä¸€ä¸‹ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void postorder(Tree root) &#123; /* method 1: use recursion if(!root) return; postorder(root-&gt;left); postorder(root-&gt;right); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; */ /* method 2: use loop and two stacks stack&lt;PtrToTNode&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; root = st2.top(); st2.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; &#125; */ /* method 3: use loop and one stack */ stack&lt;PtrToTNode&gt; st; PtrToTNode pre = NULL, cur = NULL; st.push(root); while(!st.empty()) &#123; cur = st.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur) &#123; if(cur-&gt;left != NULL) st.push(cur-&gt;left); else if(cur-&gt;right != NULL) st.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre) &#123; if(cur-&gt;right != NULL) &#123; st.push(cur-&gt;right); &#125; &#125; else &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; st.pop(); &#125; pre = cur; &#125;&#125; å±‚åºéåŽ†éåŽ†è¿‡ç¨‹ï¼šä»Žç¬¬ä¸€å±‚å¼€å§‹ï¼Œä»Žå·¦å¾€å³ä¾æ¬¡è®¿é—®æ¯ä¸ªç»“ç‚¹ã€‚å±‚åºéåŽ†ä¸€èˆ¬ç”¨é˜Ÿåˆ—å®žçŽ°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ ˆæ¥å®žçŽ°ã€‚å±‚åºéåŽ†ä¸€èˆ¬é‡‡ç”¨è¿­ä»£ï¼ˆå¾ªçŽ¯ï¼‰çš„æ€æƒ³æ¥å®žçŽ°ã€‚123456789101112void levelorder(Tree root) &#123; queue&lt;PtrToTNode&gt; q; q.push(root); while(!q.empty()) &#123; PtrToTNode front = q.front(); q.pop(); cout &lt;&lt; front-&gt;data &lt;&lt; ' '; if(front-&gt;left) q.push(front-&gt;left); if(front-&gt;right) q.push(front-&gt;right); &#125; cout &lt;&lt; endl;&#125; ä½œä¸š03-1 æ ‘çš„åŒæž„æŒ‰ç…§è¿™é“é¢˜ç›®ç»™å®šçš„æ•°æ®å½¢å¼ï¼Œç”¨é™æ€é“¾è¡¨çš„æ–¹å¼è¡¨ç¤ºæ ‘ï¼Œè§£èµ·é¢˜æ¥ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼ˆæ­£å¦‚å§¥å§¥å‰é¢è¯´è¿‡ï¼šåˆé€‚çš„æ•°æ®ç»“æž„èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬è§£å†³é—®é¢˜ï¼‰ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åŠ¨è„‘å­æƒ³ä¸€æƒ³æ€Žä¹ˆç”¨æŒ‡é’ˆæ¥è§£å†³ã€‚å¦å¤–ï¼Œåœ¨åˆ¤æ–­æ ‘æ˜¯å¦åŒæž„æ—¶è¦æ³¨æ„é—®é¢˜è€ƒè™‘å…¨é¢ï¼ˆè¯»é¢˜ä»”ç»†ï¼‰ï¼Œç†è§£é€’å½’çš„å«ä¹‰ï¼Œâ€œåŒæž„å…¶å®žå¹¶æ²¡æœ‰è¦æ±‚æ ‘çš„ç»“æž„å®Œå…¨ä¸€è‡´ï¼Œåªè¦æ±‚ç»“ç‚¹åˆ†å¸ƒä¸€è‡´å³å¯ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 15struct TNode&#123; char data; int left, right;&#125; T1[maxn], T2[maxn];void init() &#123; int i; for(i = 0; i &lt; maxn; i++) &#123; T1[i].left = T1[i].right = T2[i].left = T2[i].right = -1; &#125;&#125;int buildtree(struct TNode T[]) &#123; int i, n; scanf("%d%*c", &amp;n); char data, lc, rc; bool isRoot[maxn] = &#123;false&#125;; for(i = 0; i &lt; n; i++) &#123; scanf("%c %c %c%*c", &amp;data, &amp;lc, &amp;rc); T[i].data = data; if(lc != '-') &#123; T[i].left = lc - '0'; isRoot[lc - '0'] = true; &#125; if(rc != '-') &#123; T[i].right = rc - '0'; isRoot[rc - '0'] = true; &#125; &#125; int root = -1; for(i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; return root;&#125;bool Isomorphic(int root1, int root2) &#123; if(root1 == -1 &amp;&amp; root2 == -1) return true; if((root1 == -1 &amp;&amp; root2 != -1) || (root1 != -1 &amp;&amp; root2 == -1)) return false; if(T1[root1].data != T2[root2].data) return false; if(T1[root1].left == -1 &amp;&amp; T2[root2].left == -1) &#123; return Isomorphic(T1[root1].right, T2[root2].left); &#125; if((T1[root1].left != -1 &amp;&amp; T2[root2].left != -1) &amp;&amp; (T1[T1[root1].left].data == T2[T2[root2].left].data)) &#123; return Isomorphic(T1[root1].left, T2[root2].left) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].right); &#125; else return Isomorphic(T1[root1].left, T2[root2].right) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].left);&#125;int main() &#123; init(); int root1 = buildtree(T1); int root2 = buildtree(T2); if(Isomorphic(root1, root2)) printf("Yes"); else printf("No"); return 0;&#125;/*some samples:in:00out: Yes*/ 03-2 List Leavesé¢˜ç›®è¦æ±‚æ‰¾ä¸€æ£µæ ‘ä¸­çš„æ‰€æœ‰å¶å­ç»“ç‚¹ï¼ˆæ— å­©å­ï¼‰ï¼Œé¡ºåºæ˜¯ä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³ã€‚å¦‚æžœè¦è®¿é—®æ‰€æœ‰å¶å­ç»“ç‚¹ï¼Œé‚£ä¹ˆè‚¯å®šå°‘ä¸äº†æ ‘çš„éåŽ†ã€‚è¿›è€Œå¯ä»¥æƒ³åˆ°ï¼Œé¢˜ç›®è¦æ±‚çš„è¾“å‡ºé¡ºåºä¸Žå±‚åºéåŽ†çš„è¾“å‡ºé¡ºåºæ˜¯ä¸€è‡´çš„ã€‚æ‰€ä»¥å¯ä»¥å€ŸåŠ©å±‚åºéåŽ†çš„ä»£ç æ¥æž„é€ è¾“å‡ºå¶å­ç»“ç‚¹çš„ç®—æ³•ã€‚ç”±äºŽå±‚åºéåŽ†éœ€è¦ç”¨åˆ°é˜Ÿåˆ—ï¼Œç›´æŽ¥ç”¨ C++ çš„ STL å†…çš„ Queueã€‚æ ¹æ®é¢˜ç›®çš„å½¢å¼ï¼Œè¿˜æ˜¯ç”¨é™æ€é“¾è¡¨çš„æ–¹æ³•æ¥è¡¨ç¤ºæ ‘ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 20;struct node&#123; int left, right;&#125; Tree[maxn];bool isRoot[20] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;void levelorder(int root) &#123; queue&lt;int&gt; q; q.push(root); bool flag = true; while(!q.empty()) &#123; int tmp = q.front(); q.pop(); if(Tree[tmp].left == -1 &amp;&amp; Tree[tmp].right == -1) &#123; if(flag) &#123; cout &lt;&lt; tmp; flag = false; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; tmp; &#125; &#125; if(Tree[tmp].left != -1) q.push(Tree[tmp].left); if(Tree[tmp].right != -1) q.push(Tree[tmp].right); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; char c1, c2; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; c1 &gt;&gt; c2; if(c1 != '-') &#123; isRoot[c1 - '0'] = true; Tree[i].left = c1 - '0'; &#125; if(c2 != '-') &#123; isRoot[c2 - '0'] = true; Tree[i].right = c2 - '0'; &#125; &#125; int root; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; levelorder(root); return 0;&#125; 03-3 Tree Traversals Againé¢˜ç›®è€ƒå¯ŸäºŒå‰æ ‘çš„å…ˆåºã€ä¸­åºå’ŒåŽåºéåŽ†ï¼ˆä¸€é“é¢˜ç›®è€ƒåˆ°äº†æ ‘çš„ä¸‰ç§éåŽ†æ–¹æ³•ï¼‰ã€‚ é¢˜ç›®èƒŒæ™¯æ˜¯äºŒå‰æ ‘ä¸­åºéåŽ†çš„éžé€’å½’ç®—æ³•çš„å…¥ã€å‡ºæ ˆé¡ºåºï¼Œå®žé™…ä¸Šï¼Œå…¥æ ˆé¡ºåºå°±æ˜¯å…ˆåºåºåˆ—ï¼Œå‡ºæ ˆé¡ºåºå°±æ˜¯ä¸­åºåºåˆ—ã€‚è¿™æ ·å¯ä»¥ä½¿ç”¨å…ˆåºåºåˆ—å’Œä¸­åºåºåˆ—æž„é€ æ ‘ï¼Œè¿›è€Œåœ¨é€šè¿‡åŽåºéåŽ†æ¥è¾“å‡ºåŽåºåºåˆ—ã€‚é‚£ä¹ˆå¦‚ä½•è¡¨ç¤ºæ ‘å‘¢ï¼Ÿç”±äºŽæœ¬é¢˜ç»™å®šçš„æ•°æ®å¹¶æ²¡æœ‰ç»™å‡ºæ ‘çš„å…·ä½“ç»“æž„ï¼Œå®žé™…ä¸Šç”¨é“¾å¼ç»“æž„æˆ–è€…é¡ºåºç»“æž„çš„å¤æ‚åº¦éƒ½æ˜¯ä¸€æ ·çš„ã€‚ ä¸è¿‡æ­¤é¢˜ä¹Ÿå¯ä»¥ä¸ç”¨æž„é€ æ ‘ï¼Œç›´æŽ¥é€šè¿‡é€’å½’æ¥å¾—åˆ°åŽåºåºåˆ—ã€‚ä¸è¿‡ä¸æ˜¯é‚£ä¹ˆå¥½ç†è§£ï¼Œå»ºè®®æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œç¬”è¯•ä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„é¢˜ç›®ï¼Œæ€è·¯æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* method 1: Do not build a tree. use recursion */#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5; int in[maxn], pre[maxn], post[maxn], n;void solve(int preL, int inL, int postL, int n) &#123; if(n == 0) return; if(n == 1) &#123; post[postL] = pre[preL]; return; &#125; int root = pre[preL], i; post[postL + n - 1] = root; for(i = 0; i &lt; n; i++) &#123; if(in[inL + i] == root) break; &#125; int L = i, R = n - L - 1; solve(preL + 1, inL, postL, L); solve(preL + L + 1, inL + L + 1, postL + L, R);&#125;int main() &#123; string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; solve(0, 0, 0, n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if(i != n - 1) putchar(' '); &#125; return 0;&#125;/* method 2: use static tree #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5;struct node&#123; int left, right; int data;&#125; Tree[maxn];int in[maxn], pre[maxn], n;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;int buildtree(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) return -1; Tree[preL].data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) break; &#125; int numLeft = k - inL; Tree[preL].left = buildtree(preL + 1, preL + numLeft, inL, k - 1); Tree[preL].right = buildtree(preL + numLeft + 1, preR, k + 1, inR); return preL;&#125;int num = 0;void postorder(int root) &#123; if(root == -1) return; postorder(Tree[root].left); postorder(Tree[root].right); cout &lt;&lt; Tree[root].data; if(num &lt; n - 1) cout &lt;&lt; ' '; num++;&#125;int main() &#123; init(); string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; buildtree(0, n - 1, 0, n - 1); postorder(0); return 0;&#125;*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_02-çº¿æ€§ç»“æž„]]></title>
    <url>%2F2020%2F02%2F12%2FZJU-DS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯çº¿æ€§ç»“æž„ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿæœ‰å“ªäº›çº¿æ€§ç»“æž„ï¼Ÿå¯¹åº”çš„æœ‰ä»€ä¹ˆæ ·æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ Linear Liståœ¨ä»‹ç»çº¿æ€§è¡¨ä¹‹å‰ï¼Œä½•è€å¸ˆå…ˆä»‹ç»äº†çº¿æ€§è¡¨çš„ä¸€ä¸ªåº”ç”¨å®žä¾‹ â€”â€” ä¸€å…ƒå¤šé¡¹å¼åŠå…¶è¿ç®—ã€‚è€Œå…³äºŽä¸€å…ƒå¤šé¡¹å¼çš„è¡¨ç¤ºæ–¹æ³•ï¼Œè€å¸ˆä»‹ç»äº†ä¸‰ç§æ–¹æ³•ï¼š æ•°ç»„ï¼ˆé¡ºåºå­˜å‚¨ç»“æž„ï¼‰ç›´æŽ¥è¡¨ç¤ºï¼Œæ•°ç»„ä¸‹æ ‡å¯¹åº”æœªçŸ¥æ•° x çš„æŒ‡æ•°ï¼Œæ•°ç»„å…ƒç´ çš„å€¼å¯¹åº”å„é¡¹çš„ç³»æ•°ï¼Œä½†å¯¹äºŽæŸäº›ç‰¹æ®Šçš„å¤šé¡¹å¼ï¼Œæ­¤æ³•ä¼šæœ‰è¾ƒå¤šçš„ç©ºé—´æµªè´¹ã€‚ ç»“æž„æ•°ç»„ï¼ˆé¡ºåºå­˜å‚¨ç»“æž„ï¼‰è¡¨ç¤ºéžé›¶é¡¹ï¼Œå°†ä¸€ä¸ªå¤šé¡¹å¼çœ‹æˆæ˜¯ä¸€ä¸ªæŒ‡æ•°ä¸Žç³»æ•°çš„äºŒå…ƒç»„çš„é›†åˆï¼Œå¤šé¡¹å¼çš„æ¯ä¸€é¡¹éœ€æŒ‰ç…§æŒ‡æ•°å¤§å°æœ‰åºå­˜å‚¨ã€‚ é“¾è¡¨å­˜å‚¨éžé›¶é¡¹ï¼Œé“¾è¡¨ä¸­æ¯ä¸ªç»“ç‚¹å­˜å‚¨å¤šé¡¹å¼ä¸­çš„ä¸€ä¸ªéžé›¶é¡¹ï¼ŒåŒ…æ‹¬ç³»æ•°å’ŒæŒ‡æ•°ä¸¤ä¸ªæ•°æ®åŸŸå’Œä¸€ä¸ªæŒ‡é’ˆåŸŸã€‚ ä¸Šè¿°ä¸‰ç§æ–¹æ³•ä¸­ï¼Œåˆ©ç”¨æ•°ç»„è¡¨ç¤ºæ˜¯æ˜“äºŽå®žçŽ°çš„ï¼Œä½†æ˜¯ä¸æ˜“è®¾è®¡ä¸Žå¤šé¡¹å¼ç›¸å…³çš„åŠ å‡æ“ä½œã€‚è€Œä½¿ç”¨é“¾è¡¨æ¥è¡¨ç¤ºååˆ†çµæ´»ï¼Œä¸”æ˜“äºŽå®žçŽ°å¯¹åº”æ“ä½œã€‚ä»Žè¿™å¯ä»¥çœ‹å‡ºï¼ŒåŒä¸€ä¸ªé—®é¢˜å¯ä»¥æœ‰ä¸åŒçš„è¡¨ç¤ºï¼ˆå­˜å‚¨ï¼‰æ–¹æ³•ï¼›å­˜åœ¨ä¸€ç±»å…±æ€§é—®é¢˜ï¼Œå³ï¼šæœ‰åºçº¿æ€§åºåˆ—çš„ç»„ç»‡å’Œç®¡ç†ã€‚ç”±æ­¤å¯ä»¥å¼•å‡ºçº¿æ€§è¡¨çš„æ¦‚å¿µï¼šç”±åŒç±»åž‹æ•°æ®å…ƒç´ æž„æˆæœ‰åºåºåˆ—çš„çº¿æ€§ç»“æž„ï¼Œå…·å¤‡ä»¥ä¸‹ä¸‰ä¸ªç‰¹ç‚¹ï¼š è¡¨ä¸­å…ƒç´ ä¸ªæ•°ç§°ä¸ºçº¿æ€§è¡¨çš„é•¿åº¦ çº¿æ€§è¡¨æ²¡æœ‰å…ƒç´ æ—¶ï¼Œç§°ä¸ºç©ºè¡¨ è¡¨èµ·å§‹ä½ç½®ç§°è¡¨å¤´ï¼Œè¡¨ç»“æŸä½ç½®ç§°è¡¨å°¾ çº¿æ€§è¡¨çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šçº¿æ€§è¡¨ï¼ˆListï¼‰æ•°æ®å¯¹è±¡é›†ï¼šçº¿æ€§è¡¨æ˜¯$n(â‰¥0)$ä¸ªå…ƒç´ æž„æˆçš„æœ‰åºåºåˆ—æ“ä½œé›†ï¼šçº¿æ€§è¡¨$L âˆˆ List$ï¼Œæ•´æ•°$i$è¡¨ç¤ºä½ç½®ï¼Œå…ƒç´ $X âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œï¼š List MakeEmpty()ï¼Œåˆå§‹åŒ–ä¸€ä¸ªç©ºçº¿æ€§è¡¨ ElementType FindKth(int K, List L)ï¼Œæ ¹æ®ä½åºKï¼Œè¿”å›žç›¸åº”å…ƒç´  int Find(ElementType X, List L)ï¼Œåœ¨çº¿æ€§è¡¨Lä¸­æŸ¥æ‰¾Xçš„ç¬¬ä¸€æ¬¡å‡ºçŽ°ä¸ºæ­¢ void Insert(ElementType X, int i, List L)ï¼Œåœ¨ä½åºiå‰æ’å…¥ä¸€ä¸ªæ–°å…ƒç´ X void Delete(int i, List L)ï¼Œåˆ é™¤æŒ‡å®šä½åºiçš„å…ƒç´  int Length(List L)ï¼Œè¿”å›žçº¿æ€§è¡¨Lçš„é•¿åº¦n çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨å®žçŽ°é¡ºåºè¡¨çš„é¡ºåºå­˜å‚¨å®žçŽ°åˆ©ç”¨æ•°ç»„æ¥è¿žç»­å­˜å‚¨ç©ºé—´é¡ºåºå­˜æ”¾çº¿æ€§è¡¨çš„å„å…ƒç´ ï¼ŒC è¯­è¨€ç‰ˆæœ¬çš„å®šä¹‰ï¼ˆåŽæ–‡çš„ä»£ç éƒ½æ˜¯ C è¯­è¨€çš„ï¼‰å¦‚ä¸‹ï¼š1234567typedef int ElementType;typedef int Position; /*note here! */typedef struct LNode* List; /* struct LNode * = List */struct LNode&#123; ElementType Data[MAXSIZE]; /* #define MAXSIZE 100 */ Position Last; /* the length of list */&#125;; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºè¡¨ï¼‰æŒ‰ç…§ä¸Šé¢çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå»ºç«‹ç©ºè¡¨çš„æ“ä½œã€‚123456List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; /*use -1 to represent that the list is blank */ return L;&#125; æŸ¥æ‰¾å‰é¢ä¸€è®²ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†äºŒåˆ†æŸ¥æ‰¾ï¼Œé‚£ä¹ˆäºŒåˆ†æŸ¥æ‰¾æ˜¯å¦èƒ½åœ¨æ­¤å¤„åº”ç”¨å‘¢ï¼Ÿè¦æ³¨æ„çš„æ˜¯ï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„å‰ææ¡ä»¶æœ‰ä¸¤ä¸ªï¼š é¡ºåºå­˜å‚¨å’Œæ•°æ®æœ‰åºã€‚ è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨æŒ‰ç…§é¡ºåºä»Žå‰å¾€åŽæŸ¥æ‰¾çš„æ–¹æ³•æ¥ç¼–å†™è¿™ä¸ªæ“ä½œï¼Œéœ€è¦å°†è¢«æŸ¥æ‰¾çš„æ•°æ®å…ƒç´ å’Œæ‰€æŸ¥æ‰¾çš„çº¿æ€§è¡¨äº¤ç»™å‡½æ•°ã€‚å½“ç„¶ï¼Œå¦‚æžœçº¿æ€§è¡¨æ˜¯å…¨å±€å˜é‡ï¼Œé‚£ä¹ˆå¯ä»¥ä¸ç”¨ä¼ å…¥çº¿æ€§è¡¨ï¼Œè¿™é‡Œå‡è®¾çº¿æ€§è¡¨æ˜¯åœ¨mainå‡½æ•°ä¸­å£°æ˜Žçš„ã€‚12345678Position Find(ElementType X, List L) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return -1; /*can't find the element*/ else return i; /*return the index of this element*/&#125; é‚£ä¹ˆè¯¥å¦‚ä½•è®¡ç®—æŸ¥æ‰¾æˆåŠŸçš„å¹³å‡æ¯”è¾ƒæ¬¡æ•°å‘¢ï¼Ÿå‡è®¾æœ‰ n ä¸ªå…ƒç´ ï¼Œå¦‚æžœç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å…ƒç´ ï¼Œé‚£ä¹ˆæ­¤æ—¶æŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ 1 æ¬¡ï¼›ç»§è€Œå¯çŸ¥å½“ç¬¬äºŒä¸ªå…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å…ƒç´ æ—¶ï¼ŒæŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ 2 æ¬¡ï¼›ä»Žè€Œæˆ‘ä»¬å¯ä»¥çŸ¥é“å¯¹äºŽ n ä¸ªå…ƒç´ çš„çº¿æ€§è¡¨æŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ï¼š$(1 + 2 + ... + n) / n = (1 + n) / 2$ã€‚è¿™è¯´æ˜Žè¿™ç§æ€è·¯çš„æŸ¥æ‰¾ç®—æ³•çš„å¹³å‡æ—¶é—´æ€§èƒ½æ˜¯$O(n)$ã€‚ æ’å…¥åœ¨ç›´æŽ¥ä¸Šæ‰‹å†™æ’å…¥æ“ä½œä¹‹å‰éœ€è¦æƒ³ä¸€æƒ³æ’å…¥æ“ä½œçš„å‡ ç§æƒ…å†µï¼šè¡¨å¤´ã€è¡¨ä¸­å’Œè¡¨å°¾ã€‚é’ˆå¯¹è¿™ä¸‰ç§ä¸åŒçš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°åªæœ‰å½“åœ¨è¡¨å°¾æ’å…¥çš„æ—¶å€™æ‰ä¸éœ€è¦å°†å…ƒç´ ç§»åŠ¨ï¼›åŒæ—¶ï¼Œåœ¨æ¯ä¸€æ¬¡æ’å…¥æ“ä½œæ—¶ï¼Œç”±äºŽçº¿æ€§è¡¨å¯èƒ½å·²ç»æ»¡äº†ï¼Œé‚£ä¹ˆæ’å…¥æ“ä½œå°±ä¼šå¤±è´¥äº†ï¼Œè¿™ä¹Ÿæ˜¯éœ€è¦è€ƒè™‘çš„æƒ…å†µï¼ŒæŽ¥ç€ï¼Œæˆ‘ä»¬æ¥å†™ä¸€ä¸‹ä»£ç ã€‚12345678910111213141516void Insert(ElementType X, int i, List PtrL) &#123; int j; if(PtrL-&gt;Last == MAXSIZE - 1) &#123; printf("The list is full.\n"); return; &#125; if(i &lt; 1 || i &gt; PtrL-&gt;Last + 2) &#123; printf("The position of the insertion is not valid.\n"); return; &#125; for(j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; PtrL-&gt;Data[i - 1] = X; PtrL-&gt;Last++;&#125; ä»Žä¸Šè¿°ä»£ç å¯ä»¥çœ‹å‡ºï¼š ç”±äºŽçº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨ç»“æž„å€ŸåŠ©äº†æ•°ç»„ï¼Œæ‰€ä»¥å½“æ•°ç»„ä¸‹æ ‡ä¸º$MAXSIZE - 1$æ—¶ï¼Œè¡¨ç¤ºçº¿æ€§è¡¨å·²æ»¡ã€‚ å½“æ’å…¥ä½ç½® i å°äºŽ 1 æˆ–è€…å¤§äºŽPtrL-&gt;Last + 2æ—¶ï¼Œæ’å…¥ä½ç½®å°±æ˜¯ä¸åˆæ³•çš„ã€‚ä¹‹æ‰€ä»¥å¤§äºŽPtrL-&gt;Last + 2ä¸åˆæ³•æ˜¯å› ä¸ºï¼Œå½“PtrL-&gt;Last == MAXSIZE - 2æ—¶ï¼ŒPtrL-&gt;Last + 2 == MAXSIZEï¼Œé‚£ä¹ˆ i å°±å¤§äºŽäº†MAXSIZEï¼Œé‚£å°±è¶…å‡ºèŒƒå›´äº†ã€‚è¿™é‡Œè¦åŒºåˆ†å¥½ä¸¤ä¸ªæ¦‚å¿µï¼šæ’å…¥ä½ç½®å’Œå­˜å‚¨ä½ç½®ã€‚æ’å…¥ä½ç½®æ˜¯äººä¸ºè§„å®šä¸”ä»Ž 1 å¼€å§‹çš„ï¼ˆç¬¦åˆäººçš„æ€è€ƒä¹ æƒ¯ï¼‰ï¼Œè€Œå­˜å‚¨ä½ç½®æ˜¯ä»Ž 0 å¼€å§‹çš„ï¼Œå› ä¸ºæ•°ç»„ä¸‹æ ‡æ˜¯ä»Ž 0 å¼€å§‹çš„ã€‚åŽé¢çš„ç§»åŠ¨æ“ä½œä¹Ÿæ˜¯åŸºäºŽè¿™ä¸ªå‰ææ¥ç¼–å†™çš„ã€‚ æ‰€æ’å…¥ä½ç½®åŽçš„å…¨éƒ¨å…ƒç´ éœ€è¦å‘åŽç§»åŠ¨ã€‚ åˆ é™¤æœ‰äº†æ’å…¥æ“ä½œçš„åŸºç¡€ï¼Œåˆ é™¤æ“ä½œå°±æ¯”è¾ƒå®¹æ˜“äº†ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€å…ˆæ‰¾åˆ°è¦åˆ é™¤çš„å…ƒç´ ï¼Œç„¶åŽå°†æ­¤å…ƒç´ åŽçš„æ‰€æœ‰å…ƒç´ å‘å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®å³å¯ï¼Œä½†æ˜¯è¦æ³¨æ„è¡¨ä¸ºç©ºçš„æƒ…å†µï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112void Delete(int P, List PtrL) &#123; Position i; if(P &lt; 1 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125; æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXSIZE 10#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; return L;&#125;Position Find(List L, ElementType X) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return ERROR; else return i;&#125;bool Insert(List L, ElementType X, Position P) &#123; Position i; if(L-&gt;Last == MAXSIZE - 1) &#123; printf("Sequence List is full!\n"); return false; &#125; if(P &lt; 1 || P &gt; L-&gt;Last + 2) &#123; printf("The inserting position is illegal!\n"); return false; &#125; for(i = L-&gt;Last; i &gt;= P - 1; i--) &#123; L-&gt;Data[i + 1] = L-&gt;Data[i]; &#125; L-&gt;Data[P - 1] = X; L-&gt;Last++; return true;&#125;bool Delete(List L, Position P) &#123; Position i; if(P &lt; 0 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125;void Print(List L) &#123; if(L-&gt;Last == -1) printf("The Sequence List is empty!\n"); else &#123; int i = 0; while(i &lt; L-&gt;Last) &#123; printf("%d, ", L-&gt;Data[i]); i++; &#125; printf("%d\n", L-&gt;Data[i]); &#125;&#125;int main() &#123; List Sqlist = MakeEmpty(); bool flag = Insert(Sqlist, 11, 0); printf("flag = %d\n", flag); Insert(Sqlist, 22, 1); Insert(Sqlist, 33, 2); Insert(Sqlist, 44, 3); Print(Sqlist); bool del_flag = Delete(Sqlist, 2); printf("del_flag = %d\n", del_flag); Print(Sqlist); &#125; çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨å®žçŽ°çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨å®žçŽ°å°±æ˜¯å¤§å®¶ç†ŸçŸ¥çš„é“¾è¡¨äº†ï¼Œå­¦è¿‡ C è¯­è¨€çš„åŒå­¦å¯èƒ½å·²ç»å­¦ä¼šäº†å¦‚ä½•æž„é€ ã€ä½¿ç”¨é“¾è¡¨ç­‰ã€‚ç›¸æ¯”é¡ºåºè¡¨è€Œè¨€ï¼Œé“¾è¡¨çš„æœ€çªå‡ºçš„ä¸€ä¸ªç‰¹ç‚¹å°±æ˜¯ä¸å†è¦æ±‚é¡ºåºå­˜å‚¨äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé“¾è¡¨ä¸­çš„å„ä¸ªå…ƒç´ åœ¨å†…å­˜ä¸­çš„ä½ç½®æ˜¯ä¸ä¸€å®šç›¸é‚»çš„ã€‚å…ˆçœ‹ä¸€ä¸‹é“¾è¡¨çš„å®šä¹‰ï¼š123456789#define ERROR NULLtypedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List; è¿™é‡Œä½¿ç”¨ä¸åŒçš„å…³é”®è¯æ¥è¡¨ç¤ºæŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆï¼Œè¿™æ ·åœ¨åŽé¢çš„å„ç§æ“ä½œä¸­å¯ä»¥åŒºåˆ†å„ä¸ªæŒ‡é’ˆçš„ä½œç”¨ï¼Œè®©è¯»ä»£ç çš„äººæ›´åŠ æ˜“äºŽä»Žå•è¯æ„æ€æ¥ç†è§£ä»£ç ã€‚ åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºè¡¨ï¼‰é“¾è¡¨å»ºç«‹ç©ºè¡¨çš„åŸºæœ¬æ–¹æ³•æœ‰å¤´æ’æ³•å’Œå°¾æ’æ³•ï¼Œä½¿ç”¨ä¸åŒçš„æ–¹æ³•å»ºç«‹é“¾è¡¨å¯ä»¥å¾—åˆ°ä¸åŒçš„æ•ˆæžœï¼Œå¯ä»¥æ–¹ä¾¿æˆ‘ä»¬è§£å†³é—®é¢˜ï¼Œä»¥ä¸‹ä»£ç ä»¥å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸ºè¯´æ˜Žå¯¹è±¡ã€‚ æ±‚è¡¨é•¿é“¾è¡¨ä¸åŒäºŽé¡ºåºè¡¨ï¼Œé¡ºåºè¡¨çš„è¡¨åŽ‚æ˜¯é™å®šçš„ï¼Œä½†æ˜¯é“¾è¡¨çš„é•¿åº¦æ˜¯æ— é™çš„ï¼ˆå‡è®¾å†…å­˜æ— é™ï¼‰ï¼Œæ‰€ä»¥è‡ªç„¶å°±ä¼šæœ‰æ±‚é“¾è¡¨è¡¨é•¿çš„é—®é¢˜äº§ç”Ÿã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æœ€ç›´è§‚çš„æ€è·¯ä¹Ÿå°±æ˜¯å°†é“¾è¡¨éåŽ†ï¼ˆä»Žå¤´ç»“ç‚¹è®¿é—®åˆ°å°¾ç»“ç‚¹ï¼‰ä¸€éå³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789int GetLength(List L) &#123; List p = L-&gt;Next; /*Let's say the linked list has head node. */ int length = 0; while(p) &#123; p = p-&gt;Next; length++; &#125; return length;&#125; æŸ¥æ‰¾é“¾è¡¨çš„æŸ¥æ‰¾æœ‰ä¸¤ç§æƒ…å†µï¼Œåˆ†åˆ«æ˜¯ï¼šæŒ‰åºå·æŸ¥æ‰¾å’ŒæŒ‰å€¼æŸ¥æ‰¾ã€‚è¿™ä¸¤ç§æŸ¥æ‰¾æ–¹æ³•æ€è·¯æ¯”è¾ƒç®€å•ï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯å¯¹é“¾è¡¨è¿›è¡ŒéåŽ†ã€‚ æŒ‰åºå·æŸ¥æ‰¾12345678910List FindKth(int K, List PtrL) &#123; List p = PtrL; int i = 1; while(p != NULL &amp;&amp; i &lt; K) &#123; p = p-&gt;Next; i++; &#125; if(i == K) return p; else return NULL;&#125; æŒ‰å€¼æŸ¥æ‰¾123456Position Find(ElementType X, List L) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125; æ’å…¥å¾€é“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆå°±éœ€è¦å…ˆæž„é€ ä¸€ä¸ªæ–°çš„ç»“ç‚¹ï¼Œç„¶åŽå†å°†è¿™ä¸ªæ–°çš„ç»“ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ã€‚é‚£ä¹ˆï¼Œå¦‚ä½•è¿›è¡Œæ’å…¥å‘¢ï¼Ÿ å‡å¦‚è¦æ’å…¥åˆ°ç¬¬ i ä¸ªä½ç½®ï¼Œé‚£ä¹ˆå°±å¿…é¡»å…ˆè¦æ‰¾åˆ°ç¬¬ i - 1 ä¸ªä½ç½®ï¼Œç„¶åŽå†å°†è¿™ä¸ªæ–°ç»“ç‚¹æ’å…¥åˆ°ç¬¬ i - 1 ä¸ªç»“ç‚¹çš„åŽé¢ã€‚å¦å¤–ï¼Œæ­¤å¤„é“¾å¼ç»“æž„çš„æŒ‡é’ˆåº”ç”¨ä¸€ç›´æ˜¯è®©åˆå­¦è€…å¤´ç–¼çš„é—®é¢˜ã€‚ä½†å®žé™…ä¸Šï¼Œåˆ†æžè¿™ç±»é—®é¢˜æ—¶ï¼Œéƒ½æœ‰ä¸€ä¸ªåŽŸåˆ™ï¼šå¿…é¡»è¦å…ˆè®©æ–°ç»“ç‚¹æŒ‡å‘åŽé¢çš„ç»“ç‚¹ï¼Œæ‰èƒ½å†è®©å‰é¢çš„ç»“ç‚¹æŒ‡å‘æ–°ç»“ç‚¹ã€‚è¿™ç‚¹å…¶å®žä¹Ÿä¸éš¾ç†è§£ï¼Œå‡å¦‚è®©å‰é¢çš„ç»“ç‚¹å…ˆæŒ‡å‘æ–°ç»“ç‚¹ï¼Œé‚£ä¹ˆåŽé¢çš„ç»“ç‚¹å°±ä¸¢å¤±äº†ï¼Œå› ä¸ºæŒ‡å‘åŽé¢çš„ç»“ç‚¹çš„å”¯ä¸€æŒ‡é’ˆï¼ˆå³å‰é¢ç»“ç‚¹çš„æŒ‡é’ˆï¼‰å·²ç»æŒ‡å‘äº†æ–°ç»“ç‚¹ã€‚è¯è¯´èµ·æ¥æ˜¯å¾ˆæ‹—å£ä¸”ä¸é‚£ä¹ˆç›´è§‚ï¼Œå»ºè®®ç”¨ç¬”åœ¨çº¸ä¸Šç”»ä¸€ç”»ã€‚ æŒ‰ç…§ä¸åŒçš„æŸ¥æ‰¾æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥ç»™å‡ºä¸åŒçš„æ’å…¥æ–¹æ³•ã€‚ æŒ‰åºå·æ’å…¥1234567891011121314151617181920bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125; æŒ‰å€¼æ’å…¥1234567891011121314151617bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125; åˆ é™¤ç”±äºŽæˆ‘ä»¬å·²ç»æ˜Žç¡®äº†æŸ¥æ‰¾çš„æ–¹å¼ï¼Œæ‰€ä»¥åˆ é™¤æ“ä½œå¯ä»¥ç®€åŒ–ä¸€äº›äº†ï¼Œåªè¦ç¡®ä¿æŒ‡å‘è¢«åˆ é™¤å…ƒç´ çš„æŒ‡é’ˆæ­£ç¡®ä¼ ç»™åˆ é™¤å‡½æ•°å³å¯ã€‚12345678910111213141516bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125; æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define ERROR NULL#define MAXSIZE 10typedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List;Position Find(List L, ElementType X) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125;Position FindKth(List L, int k) &#123; PtrToLNode p = L; int i = 0; while(p &amp;&amp; i &lt; k) &#123; i++; p = p-&gt;Next; &#125; if(i == k) return p; else return NULL;&#125;List MakeEmpty() &#123; List L = (List)malloc(sizeof(struct LNode)); L-&gt;Next = NULL; return L;&#125;PtrToLNode CreateLNode(int value) &#123; PtrToLNode t = (PtrToLNode)malloc(sizeof(struct LNode)); t-&gt;Next = NULL; t-&gt;Data = value; return t;&#125;bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125;bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125;bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125;void Print(List L) &#123; if(L-&gt;Next == NULL) printf("The link list is empty!\n"); else &#123; L = L-&gt;Next; while(L-&gt;Next != NULL) &#123; printf("%d, ", L-&gt;Data); L = L-&gt;Next; &#125; printf("%d\n", L-&gt;Data); &#125;&#125;int main() &#123; List L = MakeEmpty(); PtrToLNode t = CreateLNode(11); L-&gt;Next = t; Print(L); int ins_flag = Insert_1(L, 22, Find(L, 11)); printf("ins_flag = %d\n", ins_flag); Print(L); Insert_1(L, 33, Find(L, 22)); Insert_1(L, 44, Find(L, 33)); Print(L); int del_flag = Delete(L, Find(L, 33)); printf("del_flag = %d\n", del_flag); Print(L); printf("/*--------------------*/\n"); Insert_2(L, 55, 3); Print(L); Insert_2(L, 8, 2); Print(L); printf("%d\n", Insert_2(L, 9, 10)); Print(L); return 0;&#125; Generalized Listå…³äºŽå¹¿ä¹‰è¡¨çš„å«ä¹‰ï¼Œä½•è€å¸ˆçš„ PPT é‡Œé¢è¯´çš„æ¯”è¾ƒæ¸…æ¥šäº†ï¼Œå³: å¹¿ä¹‰è¡¨æ˜¯çº¿æ€§è¡¨çš„æŽ¨å¹¿ å¯¹äºŽå¹¿ä¹‰è¡¨è€Œè¨€ï¼Œn ä¸ªå…ƒç´ éƒ½æ˜¯åŸºæœ¬çš„å•å…ƒç´  å¹¿ä¹‰è¡¨ä¸­ï¼Œè¿™äº›å…ƒç´ ä¸ä»…å¯ä»¥æ˜¯å•å…ƒç´ ä¹Ÿå¯ä»¥æ˜¯å¦ä¸€ä¸ªå¹¿ä¹‰è¡¨ å…¶å®žè¯´ç™½äº†ï¼Œå¹¿ä¹‰è¡¨æ˜¯ä¸ªå¤§é›†åˆï¼Œå›Šæ‹¬äº†çº¿æ€§è¡¨è¿™ä¸ªå°é›†åˆã€‚ å…³äºŽå¤šé‡é“¾è¡¨ï¼Œå…¶å®žæ˜¯å¹¿ä¹‰è¡¨çš„ä¸€ç§åº”ç”¨ï¼Œä¹Ÿå³çº¿æ€§è¡¨ä¸­çš„æ¯ä¸€ä¸ªâ€œç»“ç‚¹â€ï¼Œåˆæ˜¯ä¸€ä¸ªçº¿æ€§è¡¨ã€‚å¤šé‡é“¾è¡¨å¤šåº”ç”¨ä¸ŽäºŽæ ‘ï¼ˆçº¿ç´¢äºŒå‰æ ‘ç­‰ï¼‰å’Œå›¾ï¼ˆåå­—é“¾è¡¨ç­‰ï¼‰è¿™ç±»å¤æ‚çš„æ•°æ®ç»“æž„ï¼Œå½“ç„¶ï¼Œæ ‘å’Œå›¾ä¹Ÿå¯ä»¥ä¸é‡‡ç”¨å¤šé‡é“¾è¡¨æ¥å­˜å‚¨ã€‚ Stackå †æ ˆï¼ˆStackï¼‰ï¼Œå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨ï¼Œåªåœ¨ä¸€ç«¯ï¼ˆæ ˆé¡¶ï¼ŒTopï¼‰åšæ’å…¥ã€åˆ é™¤æ“ä½œã€‚æ’å…¥æ•°æ®ï¼šå…¥æ ˆï¼ˆPushï¼‰åˆ é™¤æ•°æ®ï¼šå‡ºæ ˆï¼ˆPopï¼‰åŽå…¥å…ˆå‡ºï¼šLast In First Outï¼ˆLIFOï¼‰ å †æ ˆçš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šå †æ ˆï¼ˆStackï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸ºMaxSizeçš„å †æ ˆS âˆˆ Stackï¼Œå †æ ˆå…ƒç´ item âˆˆ ElementTypeï¼Œä¸»è¦æ“ä½œï¼š Stack CreateStack(int MaxSize)ï¼Œç”Ÿæˆç©ºå †æ ˆï¼Œå…¶æœ€å¤§é•¿åº¦ä¸ºMaxSize int IsFull(Stack S, int MaxSize)ï¼Œåˆ¤æ–­å †æ ˆSæ˜¯å¦å·²æ»¡ void Push(Stack S, ElementType item)ï¼Œå°†å…ƒç´ itemåŽ‹å…¥å †æ ˆ int IsEmpty(Stack S)ï¼Œåˆ¤æ–­å †æ ˆSæ˜¯å¦ä¸ºç©º ElementType Pop(Stack S)ï¼Œåˆ é™¤å¹¶è¿”å›žæ ˆé¡¶å…ƒç´  æ ˆçš„é¡ºåºå­˜å‚¨å®žçŽ°æ ˆçš„é¡ºåºå­˜å‚¨ç»“æž„é€šå¸¸ç”±ä¸€ä¸ªä¸€ç»´æ•°ç»„å’Œä¸€ä¸ªè®°å½•æ ˆé¡¶å…ƒç´ ä½ç½®çš„å˜é‡ç»„æˆï¼ŒC è¯­è¨€ç‰ˆæœ¬çš„å®šä¹‰å¦‚ä¸‹ï¼š12345678910#define MAXSIZE 10 /*store the maximum number of data*/#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;typedef struct SNode *Stack; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºæ ˆï¼‰1234567Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125; åˆ¤æ–­æ ˆæ»¡123bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125; åˆ¤æ–­æ ˆç©º123bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125; å…¥æ ˆç”±äºŽé¡ºåºæ ˆæ˜¯ç”±æ•°ç»„å­˜å‚¨ï¼Œè€Œæ•°ç»„æœ‰å¤§å°ï¼Œå½“æ•°ç»„æ²¡æœ‰ç©ºé—´çš„æ—¶å€™å°±æ— æ³•è¿›è¡Œå…¥æ ˆæ“ä½œï¼Œæ‰€ä»¥åœ¨å…¥æ ˆæ“ä½œä¹‹å‰å°±å¿…é¡»è¦åˆ¤æ–­æ ˆæ˜¯å¦æ»¡äº†ã€‚123456789bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125; å‡ºæ ˆä¸Žå…¥æ ˆæ“ä½œç±»ä¼¼ï¼Œå½“æ ˆä¸ºç©ºæ—¶ï¼Œæ˜¾ç„¶æ— æ³•è¿›è¡Œå‡ºæ ˆæ“ä½œã€‚12345678ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125; æ±‚æ ˆå†…å…ƒç´ ä¸ªæ•°123int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125; æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct SNode&#123; ElementType *Data; Position Top; int MaxSize;&#125;;typedef struct SNode *Stack;Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125;bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125;bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125;bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125;ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125;int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125;int main() &#123; Stack S = Createstack(5); Pop(S); printf("S.size = %d\n", Getsize(S)); int push_flag = Push(S, 11); Push(S, 22); Push(S, 33); int x = Pop(S); printf("push_flag = %d, x = %d\n", push_flag, x); printf("S.size = %d\n", Getsize(S)); Push(S, 33); Push(S, 44); Push(S, 55); Push(S, 66); printf("S.size = %d\n", Getsize(S)); return 0;&#125; æ ˆçš„é“¾å¼å­˜å‚¨ç»“æž„å®žçŽ°æ ˆçš„é“¾å¼å­˜å‚¨ç»“æž„å®žé™…ä¸Šå°±æ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œå«åšé“¾æ ˆã€‚æ’å…¥å’Œåˆ é™¤æ“ä½œåªèƒ½åœ¨é“¾æ ˆçš„æ ˆé¡¶è¿›è¡Œï¼Œæ³¨æ„æ ˆé¡¶æŒ‡é’ˆ top åªèƒ½åœ¨é“¾è¡¨çš„è¡¨å¤´ã€‚1234567typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºæ ˆï¼‰123456Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; å…¥æ ˆç”±äºŽé“¾æ ˆæ˜¯é€šè¿‡ç”³è¯·å†…å­˜æž„é€ ç»“ç‚¹çš„ï¼Œæ‰€ä»¥ç†è®ºä¸Šä¸å­˜åœ¨æ ˆæ»¡çš„æƒ…å†µï¼ˆå†…å­˜æ»¡äº†å°±ä¸èƒ½åˆ†é…ç©ºé—´äº†ï¼‰ã€‚1234567bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125; åˆ¤æ–­æ ˆç©ºå°½ç®¡é“¾æ ˆä¸ç”¨åˆ¤æ–­æ ˆæ»¡ï¼Œä½†æ˜¯åœ¨è¿›è¡Œå‡ºæ ˆæ“ä½œæ—¶éœ€è¦åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºã€‚123bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125; å‡ºæ ˆ1234567891011121314ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125; æ±‚æ ˆå†…å…ƒç´ ä¸ªæ•°12345678int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125; æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack;Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125;bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125;bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125;ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125;int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125;int main() &#123; Stack S = Createstack(); Pop(S); printf("S.size = %d\n", Getsize(S)); Push(S, 11); Push(S, 22); Push(S, 33); printf("S.top = %d\n", Pop(S)); Push(S, 33); Push(S, 44); Push(S, 55); printf("S.size = %d\n", Getsize(S)); return 0;&#125; Queueé˜Ÿåˆ—ä¹Ÿæ˜¯å…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨ï¼ˆä¸Žå †æ ˆç±»ä¼¼ï¼‰ï¼Œåªèƒ½åœ¨ä¸€ç«¯æ’å…¥ï¼Œè€Œåœ¨å¦ä¸€ç«¯åˆ é™¤ã€‚æ•°æ®æ’å…¥ï¼šå…¥é˜Ÿåˆ—ï¼ˆAddQï¼‰æ•°æ®åˆ é™¤ï¼šå‡ºé˜Ÿåˆ—ï¼ˆDeleteQï¼‰å…ˆæ¥å…ˆæœåŠ¡ï¼Œå…ˆè¿›å…ˆå‡ºï¼ŒFirst In First Outï¼ŒFIFO é˜Ÿåˆ—çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šé˜Ÿåˆ—ï¼ˆQueueï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸ºMaxSizeçš„é˜Ÿåˆ—Q âˆˆ Queueï¼Œé˜Ÿåˆ—å…ƒç´ item âˆˆ ElementTypeï¼Œä¸»è¦æ“ä½œï¼š Queue CreatQueue(int MaxSize)ï¼Œç”Ÿæˆé•¿åº¦ä¸ºMaxSizeçš„ç©ºé˜Ÿåˆ— int IsFullQ(Queue Q, int MaxSize)ï¼Œåˆ¤æ–­é˜Ÿåˆ—Qæ˜¯å¦å·²æ»¡ void AddQ(Queue Q, ElementType item)ï¼Œå°†æ•°æ®å…ƒç´ itemæ’å…¥é˜Ÿåˆ—Qä¸­ int IsEmptyQ(Queue Q)ï¼Œåˆ¤æ–­é˜Ÿåˆ—Qæ˜¯å¦ä¸ºç©º ElementType DeleteQ(Queue Q)ï¼Œå°†å¯¹å¤´æ•°æ®å…ƒç´ ä»Žé˜Ÿåˆ—ä¸­åˆ é™¤å¹¶è¿”å›ž é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨å®žçŽ°é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨å®žçŽ°ä¸Žé¡ºåºæ ˆçš„å®žçŽ°æ–¹å¼ç›¸åŒï¼Œè¿˜æ˜¯éœ€è¦å€ŸåŠ©ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨å…ƒç´ ã€‚ä½†ä¸Žæ ˆä¸åŒçš„æ˜¯é˜Ÿåˆ—éœ€è¦æœ‰é˜Ÿå¤´ï¼ˆfrontï¼‰æŒ‡é’ˆå’Œé˜Ÿå°¾ï¼ˆrearï¼‰æŒ‡é’ˆï¼Œå®šä¹‰å¦‚ä¸‹ï¼š12345678typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºé˜Ÿåˆ—ï¼‰1234567Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125; åˆ¤æ–­é˜Ÿç©º123bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125; åˆ¤æ–­é˜Ÿæ»¡123bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125; å…¥é˜Ÿä¸ºäº†æ›´å¥½çš„åˆ©ç”¨æ•°ç»„ï¼Œé‡‡å–å¾ªçŽ¯é˜Ÿåˆ—çš„è®¾è®¡æ–¹æ³•ï¼Œå€ŸåŠ©å–ä½™è¿ç®—åˆšå¥½å¯ä»¥æ»¡è¶³è¦æ±‚ï¼Œå‡ºé˜Ÿæ—¶åŒç†ã€‚12345678910bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125; å‡ºé˜Ÿ123456789ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125; æ±‚é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°123int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125;bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125;ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125;int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125;void print(Queue q) &#123; int i; for(i = 0; i &lt; 5; i++) &#123; printf("%d ", q-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); printf("%d\n", Getsize(q)); Addq(q, 22); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 33); Addq(q, 44); Addq(q, 55); print(q); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); Addq(q, 66); x = Deleteq(q); x = Deleteq(q); Addq(q, 66); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); return 0;&#125; é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨å®žçŽ°é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨å®žçŽ°è¦æ¯”é“¾æ ˆçš„å®žçŽ°ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œéœ€è¦æœ‰ä¸€ä¸ªå•ç‹¬çš„é˜Ÿåˆ—ç»“æž„ï¼ˆåŒ…å«é˜Ÿå¤´æŒ‡é’ˆå’Œé˜Ÿå°¾æŒ‡é’ˆï¼‰æ¥æŒ‡å‘é˜Ÿåˆ—ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š123456789101112typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºé˜Ÿåˆ—ï¼‰123456Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125; æ±‚é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°123456789int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125; åˆ¤æ–­é˜Ÿç©º123bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125; åˆ¤æ–­é˜Ÿæ»¡ç”±äºŽä¸Šè¿°å®šä¹‰è®¾ç½®çš„æœ‰MaxSizeï¼Œé»˜è®¤é“¾é˜Ÿåˆ—æ˜¯æœ‰æœ€å¤§ç©ºé—´çš„ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºæ»¡ã€‚1234bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125; å…¥é˜Ÿ12345678910111213141516bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125; å‡ºé˜Ÿ123456789101112131415ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125;ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125;int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125;bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); Addq(q, 11); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); Addq(q, 22); Addq(q, 33); Addq(q, 44); Addq(q, 55); Addq(q, 66); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); return 0;&#125; Homework02-1 ä¸¤ä¸ªæœ‰åºé“¾è¡¨åºåˆ—çš„åˆå¹¶æ­¤é¢˜è€ƒå¯Ÿé“¾è¡¨çš„åˆå¹¶æ“ä½œï¼Œæ³¨æ„é“¾è¡¨æœ‰åºä¸”ç»™å®šé“¾è¡¨å¸¦å¤´ç»“ç‚¹ï¼Œè¦æ±‚åˆå¹¶åŽé“¾è¡¨ä¸ºéžé€’å‡åºåˆ—ï¼Œæ‰€ä»¥éœ€è¦å¯¹æ¯ä¸€ä¸ªç»“ç‚¹å€¼è¿›è¡Œæ¯”è¾ƒï¼Œä»£ç å¦‚ä¸‹ï¼ˆå…¶ä¸­å‡½æ•°ä½“ä¸ºéœ€è¦æäº¤çš„ä»£ç ï¼‰ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read();void Print( List L );List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;List Read() &#123; int i, n, temp; scanf("%d", &amp;n); List L, p; L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = temp; t-&gt;Next = NULL; p-&gt;Next = t; p = t; &#125; return L;&#125;void Print( List L ) &#123; PtrToNode p = L-&gt;Next; if(!p) &#123; printf("NULL\n"); return; &#125; while(p-&gt;Next != NULL) &#123; printf("%d ", p-&gt;Data); p = p-&gt;Next; &#125; printf("%d\n", p-&gt;Data);&#125;List Merge( List L1, List L2 ) &#123; PtrToNode p, p1 = L1-&gt;Next, p2 = L2-&gt;Next; L1-&gt;Next = L2-&gt;Next = NULL; List L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;Data &lt; p2-&gt;Data) &#123; p-&gt;Next = p1; p = p1; p1 = p1-&gt;Next; &#125; else &#123; p-&gt;Next = p2; p = p2; p2 = p2-&gt;Next; &#125; &#125; if(p1) p-&gt;Next = p1; if(p2) p-&gt;Next = p2; return L;&#125; 02-2 ä¸€å…ƒå¤šé¡¹å¼çš„ä¹˜æ³•ä¸ŽåŠ æ³•è¿ç®—è¿™é“é¢˜çš„ä½•è€å¸ˆå·²ç»è®²è¿‡äº†ï¼ŒæŒ‰ç…§ä½•è€å¸ˆç»™çš„æ€è·¯ï¼Œè¡¥å…¨æ‰€æœ‰ä»£ç å³å¯ï¼ˆæœ€åº•ä¸‹æä¾›äº†å‡ ç»„æµ‹è¯•ç”¨ä¾‹ï¼‰ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct PolyNode* Polynomial;typedef struct PolyNode* PtrToPolyNode;struct PolyNode &#123; int coef, expon; struct PolyNode *link;&#125;;PtrToPolyNode CreateNode(int c, int e) &#123; PtrToPolyNode t = (PtrToPolyNode)malloc(sizeof(struct PolyNode)); t-&gt;coef = c, t-&gt;expon = e; t-&gt;link = NULL; return t;&#125;Polynomial ReadPoly() &#123; int n, c, e; scanf("%d", &amp;n); Polynomial P, p; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; if(n == 0) &#123; PtrToPolyNode t = CreateNode(0, 0); p-&gt;link = t; &#125; else &#123; while(n--) &#123; scanf("%d %d", &amp;c, &amp;e); PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; &#125; return P;&#125;void Print(Polynomial P) &#123; if(P-&gt;link == NULL) &#123; printf("0 0\n"); return; &#125; else &#123; P = P-&gt;link; while(P-&gt;link != NULL) &#123; printf("%d %d ", P-&gt;coef, P-&gt;expon); P = P-&gt;link; &#125; printf("%d %d\n", P-&gt;coef, P-&gt;expon); &#125;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2 = P2-&gt;link; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;expon == p2-&gt;expon) &#123; int e = p1-&gt;expon, c = p1-&gt;coef + p2-&gt;coef; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else if(p1-&gt;expon &gt; p2-&gt;expon) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; else &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; &#125; while(p1 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; while(p2 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; return P;&#125;Polynomial Multi(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; while(p1) &#123; p2 = P2-&gt;link; while(p2) &#123; int c = p1-&gt;coef * p2-&gt;coef; int e = p1-&gt;expon + p2-&gt;expon; p = P; while(p-&gt;link != NULL &amp;&amp; p-&gt;link-&gt;expon &gt; e) p = p-&gt;link; if(p-&gt;link != NULL) &#123; if(p-&gt;link-&gt;expon == e) &#123; int ctmp = p-&gt;link-&gt;coef + c; if(ctmp == 0) &#123; PtrToPolyNode tmp = p-&gt;link; p-&gt;link = tmp-&gt;link; free(tmp); &#125; else &#123; p-&gt;link-&gt;coef = ctmp; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; p2 = p2-&gt;link; &#125; p1 = p1-&gt;link; &#125; return P;&#125;int main() &#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PS = Add(P1, P2); PP = Multi(P1, P2); Print(PP); Print(PS); return 0;&#125;/*some samples:in:1 -1 11 1 1out:-1 20 0in:2 -1 1 2 01 1 1out:-1 2 2 12 0in:2 1 1 1 02 1 1 -1 0out:1 2 -1 02 1in:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1out:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0in:1 0 03 1 3 1 2 1 1out:0 01 3 1 2 1 1in:2 2 0 0 03 3 2 2 1 1 0out:6 2 4 1 2 03 2 2 1 3 0in:01 10 0out:0 010 0*/ 02-3 Reversing Linked Listæ­¤é¢˜é¢˜æ„æ¯”è¾ƒç›´æŽ¥ï¼Œä½†æ˜¯æµ‹è¯•ç‚¹æ¯”è¾ƒå¤šï¼Œè¦è€ƒè™‘å…¨é¢ã€‚æŽ¨èä½¿ç”¨é™æ€é“¾è¡¨çš„æ–¹æ³•è§£é¢˜ï¼Œè¿™æ ·è€—æ—¶è¾ƒå°‘ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#define maxn 100005int addr[maxn], address[maxn], data[maxn], next[maxn];void reverse(int A[], int left, int right) &#123; for(; left &lt; right; left++, right--) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125;&#125;int main() &#123; int src, n, k, m; scanf("%d %d %d", &amp;src, &amp;n, &amp;k); m = n; int tmp_add, tmp_data, tmp_next; while(m--) &#123; scanf("%d %d %d", &amp;tmp_add, &amp;tmp_data, &amp;tmp_next); address[tmp_add] = tmp_add; next[tmp_add] = tmp_next; data[tmp_add] = tmp_data; &#125; int len = 1, i, j, tmp = src; addr[0] = src; while(src != -1) &#123; addr[len++] = next[src]; src = next[src]; &#125; for(i = 0, j = k; j &lt;= len - 1; i = j, j += k) &#123; reverse(addr, i, j - 1); &#125; for(i = 0; i &lt; len - 2; i++) &#123; src = addr[i]; printf("%05d %d %05d\n", src, data[src], addr[i + 1]); &#125; printf("%05d %d -1\n", address[addr[i]], data[addr[i]]); return 0;&#125;/*some samples:in:00100 6 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:68237 6 9999999999 5 0000000000 4 3321833218 3 1230912309 2 0010000100 1 -1in:00100 6 300000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:33218 3 1230912309 2 0010000100 1 6823768237 6 9999999999 5 0000000000 4 -1in:00100 6 100000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:00100 1 1230912309 2 3321833218 3 0000000000 4 9999999999 5 6823768237 6 -1in:00100 5 300000 4 9999900100 1 1230933218 3 0000099999 5 -112309 2 33218out:33218 3 1230912309 2 0010000100 1 0000000000 4 9999999999 5 -1in:00100 9 200000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 3321833333 7 2222244444 8 1111103333 9 02222out:12309 2 0010000100 1 0000000000 4 3321833218 3 6823768237 6 9999999999 5 -1in:00100 3 200100 1 -111111 2 2222233333 3 44444out:00100 1 -1*/ 02-4 Pop Sequenceæœ¬é¢˜è€ƒå¯Ÿæ ˆçš„ç›¸å…³çŸ¥è¯†ï¼Œæœ¬è´¨ä¸Šæ˜¯æ¨¡æ‹Ÿæ ˆçš„ç›¸å…³æ“ä½œï¼ŒæŽ¨èä½¿ç”¨ C++ è‡ªå¸¦çš„ STL æ¨¡æ¿é‡Œé¢çš„ Stack ï¼Œå¯ä»¥ç›´æŽ¥æ‹¿æ¥ä½¿ç”¨ï¼Œä½†éœ€è¦å…ˆäº†è§£ä¸€ä¸‹ç”¨æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];int main() &#123; int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; bool flag = true; while(k--) &#123; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; bool flag = true; int i = 1, j = 1; while(j &lt;= n + 1) &#123; if(st.size() &gt; m) &#123; flag = false; break; &#125; if(!st.empty()) &#123; if(st.top() == seq[i]) &#123; st.pop(); i++; &#125; else st.push(j++); &#125; else st.push(j++); &#125; if(flag &amp;&amp; st.size() == 1) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; /*some samples:in:5 7 15 6 4 3 7 2 1out:YESsome sample:in:2 4 41 2 3 42 1 3 41 2 4 33 1 2 4out:YESYESYESNO*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_01-åŸºæœ¬æ¦‚å¿µ]]></title>
    <url>%2F2020%2F02%2F11%2FZJU-DS-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[æ­¤ç¯‡ç³»åˆ—åšæ–‡æ˜¯åšä¸»è‡ªå·±åœ¨ MOOC ä¸Šè‡ªå­¦æµ™æ±Ÿå¤§å­¦æ•°æ®ç»“æž„è¯¾ç¨‹æ—¶çš„ç¬”è®°ï¼Œæ¯ä¸€è®²éƒ½æœ‰å¯¹åº”çš„ç¬”è®°ï¼Œå¯¹åº”ä¸€ç¯‡åšæ–‡ã€‚è™½ç„¶ä¹‹å‰ä¸Šè¯¾æ—¶å°±åšå¥½äº†ç¬”è®°ï¼Œä½†å¯¹å¾ˆå¤šçŸ¥è¯†ç‚¹çš„ç†è§£æ¯”è¾ƒæµ…æ˜¾ï¼ŒçŽ°åœ¨å›žè¿‡å¤´æ¥æ•´ç†ï¼Œå¸Œæœ›ä¼šæœ‰æ‰€å¯å‘ã€‚å¦å¤–ï¼Œè‡ªå­¦ä¹‹è·¯éš¾å…ä¼šæœ‰é”™è¯¯ï¼Œæ¬¢è¿Žçœ‹åˆ°æ–‡ç« çš„åŒå­¦ä¸åèµæ•™ã€‚å¦å¤–ï¼Œé¢˜è§£ä»£ç åœ¨ Github ä¸Šçš„åœ°å€ï¼š201909_MOOC_DS_ChenYue What is Data Structureä½•è°“æ•°æ®ç»“æž„ï¼ŸæŒ‰ç…§å§¥å§¥çš„è®²è§£ï¼Œæ²¡æœ‰ç‰¹å®šçš„æ•°æ®ç»“æž„çš„å®šä¹‰ã€‚ä¸è¿‡ï¼Œé€šè¿‡è¯¾ä¸Šå§¥å§¥ä¸¾çš„ä¸€äº›ä¾‹å­ï¼Œå¯ä»¥å¾—å‡ºï¼šæ•°æ®ç»“æž„å°±æ˜¯æ•°æ®å¯¹è±¡åœ¨è®¡ç®—æœºä¸­çš„ç»„ç»‡æ–¹å¼ã€‚å…·ä½“è€Œè¨€ï¼Œæ•°æ®å¯¹è±¡åŒ…å«ï¼š é€»è¾‘ç»“æž„ï¼šç¬¬ä¸€æ¬¡å­¦æ•°æ®ç»“æž„çš„äººå¯èƒ½ä¼šå¯¹è¿™ä¸ªæ¦‚å¿µæœ‰ç‚¹æ‡µï¼Œå¦‚æžœå·²ç»æŽŒæ¡äº†ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€ï¼Œå¹¶ä¸”å…·å¤‡äº†ä¸€å®šçš„æ°´å¹³çš„è¯ï¼Œç†è§£èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ã€‚è¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚å¾‹è¯—çš„é€»è¾‘ç»“æž„å°±æ˜¯ï¼šé¦–è”ã€é¢”è”ã€é¢ˆè”å’Œå°¾è”ã€‚ ç‰©ç†å­˜å‚¨ç»“æž„ï¼šå¯ä»¥æš‚æ—¶ç†è§£ä¸ºç¡¬ç›˜ä¹‹ç±»çš„å­˜å‚¨å™¨çš„ç»“æž„ã€‚ å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æŠ½è±¡æ•°æ®ç±»åž‹ï¼ˆAbstract Data Typeï¼‰æ¥æè¿°æ•°æ®ç»“æž„ï¼ŒåŒ…æ‹¬ï¼š æ•°æ®å¯¹è±¡é›†ï¼šç®€è€Œè¨€ä¹‹å°±æ˜¯ç”±æ•°æ®ç»„æˆçš„é›†åˆã€‚ æ•°æ®é›†åˆç›¸å…³è”çš„æ“ä½œé›†ï¼šå¤„ç†è¿™äº›æ•°æ®å¯¹è±¡çš„æ“ä½œæ–¹æ³•ã€‚ å…¶ä¸­ï¼ŒæŠ½è±¡çš„å«ä¹‰æ˜¯ï¼šæè¿°æ•°æ®ç±»åž‹çš„æ–¹æ³•ä¸ä¾èµ–äºŽå…·ä½“å®žçŽ°ï¼Œä¸Žå­˜æ”¾æ•°æ®çš„æœºå™¨æ— å…³ï¼Œä¸Žæ•°æ®å­˜å‚¨çš„ç‰©ç†ç»“æž„æ— å…³ï¼Œä¸Žå®žçŽ°æ“ä½œçš„ç®—æ³•å’Œç¼–ç¨‹è¯­è¨€å‡æ— å…³ã€‚ æŠ½è±¡æ•°æ®ç±»åž‹å…¶å®žå°±æ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡è¯­è¨€ä¸­çš„â€œç±»ï¼ˆClassï¼‰â€çš„å«ä¹‰ã€‚è¦æ³¨æ„ï¼Œæ•°æ®å¯¹è±¡å¿…å®šä¸Žä¸€ç³»åˆ—åŠ åœ¨ä¸Šé¢çš„æ“ä½œæ˜¯ç›¸å…³è”ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå•ç‹¬å­˜åœ¨çš„æ•°æ®å¯¹è±¡æˆ–æ“ä½œé›†æ˜¯æ— æ³•è¢«ç§°ä¹‹ä¸ºæ•°æ®ç»“æž„çš„ã€‚è€Œåœ¨æ•°æ®ç»“æž„ä¸­ï¼Œå®Œæˆç›¸å…³æ“ä½œé›†æ‰€ç”¨çš„æ–¹æ³•å°±æ˜¯ç®—æ³•ï¼ˆAlgorithmï¼‰ã€‚ å…¶å®žï¼Œæ•°æ®ç»“æž„æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€»è¾‘çš„æ¦‚å¿µã€‚ What is Algorithmç®—æ³•åŒ…å«ä»¥ä¸‹å‡ ä¸ªè¦ç´ ï¼š ä¸€ä¸ªæœ‰é™æŒ‡ä»¤é›† æŽ¥å—ä¸€äº›è¾“å…¥ï¼ˆæœ‰äº›æƒ…å†µä¸‹ä¸éœ€è¦è¾“å…¥ï¼‰ äº§ç”Ÿè¾“å‡º ä¸€å®šåœ¨æœ‰é™æ­¥éª¤ä¹‹åŽç»ˆæ­¢ æ¯ä¸€æ¡æŒ‡ä»¤å¿…é¡»ï¼šæœ‰å……åˆ†æ˜Žç¡®çš„ç›®æ ‡ï¼Œä¸å¯ä»¥æœ‰æ­§ä¹‰ï¼Œå¹¶ä¸”è®¡ç®—æœºèƒ½å¤„ç†çš„èŒƒå›´ä¹‹å†…ï¼Œå¦å¤–ï¼Œæè¿°åº”ä¸ä¾èµ–äºŽä»»ä½•ä¸€ç§è®¡ç®—æœºè¯­è¨€ä»¥åŠå…·ä½“çš„å®žçŽ°æ‰‹æ®µã€‚ Measure for Algorithmæ—¶é—´å¤æ‚åº¦ï¼ˆ$S(n)$ï¼‰ï¼šæ ¹æ®ç®—æ³•å†™æˆçš„ç¨‹åºåœ¨æ‰§è¡Œæ—¶è€—è´¹æ—¶é—´çš„é•¿åº¦ã€‚è¿™ä¸ªé•¿åº¦å¾€å¾€ä¹Ÿä¸Žè¾“å…¥æ•°æ®çš„è§„æ¨¡æœ‰å…³ã€‚æ—¶é—´å¤æ‚åº¦è¿‡é«˜çš„ä½Žæ•ˆç®—æ³•å¯èƒ½å¯¼è‡´æˆ‘ä»¬æœ‰ç”Ÿä¹‹å¹´éƒ½ç­‰ä¸åˆ°è¿è¡Œç»“æžœã€‚ ç©ºé—´å¤æ‚åº¦ï¼ˆ$T(n)$ï¼‰ï¼šæ ¹æ®ç®—æ³•å†™æˆçš„ç¨‹åºåœ¨æ‰§è¡Œæ—¶å ç”¨å­˜å‚¨å•å…ƒçš„é•¿åº¦ã€‚è¿™ä¸ªé•¿åº¦å¾€å¾€ä¸Žè¾“å…¥æ•°æ®çš„è§„æ¨¡æœ‰å…³ã€‚ç©ºé—´å¤æ‚åº¦è¿‡é«˜çš„ç®—æ³•å¯èƒ½å¯¼è‡´å†…å­˜è¶…é™ï¼Œé€ æˆç¨‹åºçš„éžæ­£å¸¸ä¸­æ–­ã€‚ åœ¨åˆ†æžä¸€èˆ¬ç®—æ³•çš„æ•ˆçŽ‡æ—¶ï¼Œæˆ‘ä»¬ç»å¸¸å…³æ³¨ä¸‹é¢ä¸¤ç§å¤æ‚åº¦ï¼š æœ€åæƒ…å†µå¤æ‚åº¦ï¼ˆworstï¼‰ å¹³å‡å¤æ‚åº¦ï¼ˆaverageï¼‰ Complexity Expressionå¤æ‚åº¦çš„æ¸è¿›è¡¨ç¤ºæ³•ï¼š$ T(n) = O(f(n)) $è¡¨ç¤ºå­˜åœ¨å¸¸æ•°$C&gt;0$ï¼Œ$n_0$ä½¿å¾—å½“$n â‰¥ n_0$æ—¶ï¼Œæœ‰$T(n) â‰¤ C * f(n)$ï¼› $ T(n) = Î©(g(n)) $è¡¨ç¤ºå­˜åœ¨å¸¸æ•°$C&gt;0$ï¼Œ$n_0$ä½¿å¾—å½“$n â‰¥ n_0$æ—¶ï¼Œæœ‰$T(n) â‰¥ C * g(n)$ï¼› $ T(n) = Î¸(h(n)) $è¡¨ç¤ºåŒæ—¶æœ‰$ T(n)=O(h(n)) $å’Œ$ T(n)=Î©(h(n)) $ï¼› è¿‡å¤§çš„ä¸Šç•Œå’Œä¸‹ç•Œå¯¹äºŽåˆ†æžç®—æ³•çš„â€œå¥½â€å’Œâ€œåâ€ï¼Œæ²¡æœ‰æ„ä¹‰ï¼Œæ‰€ä»¥ä¸€èˆ¬å–å€¼æ˜¯æˆ‘ä»¬èƒ½æ‰¾åˆ°çš„ã€æœ€å¤§å’Œæœ€å°çš„é‚£ä¸ªä¸Šç•Œå’Œä¸‹ç•Œã€‚ å½“é—®é¢˜çš„è§„æ¨¡ä¸º$n$æ—¶ï¼Œä¸åŒé‡çº§çš„æ—¶é—´å¤æ‚åº¦çš„å…³ç³»ä¸ºï¼š$log n &lt; n &lt; n*log n &lt; n^2 &lt; n^3 &lt; 2^n &lt; n!$ Complexity Analysiså¯¹ç®—æ³•è¿›è¡Œå¤æ‚åº¦çš„åˆ†æžæ˜¯è¡¡é‡ä¸€ä¸ªç®—æ³•â€œå¥½â€ä¸Žâ€œåâ€çš„åŸºæœ¬æ–¹æ³•ï¼Œå…³äºŽè¿™æ–¹é¢æœ‰ä»¥ä¸‹ä¸€äº›çªé—¨ï¼š è‹¥ä¸¤æ®µç®—æ³•åˆ†åˆ«æœ‰å¤æ‚åº¦$T_1(n) = O(f_1(n))$å’Œ$T_2(n) = O(f_2(n))$ï¼Œåˆ™ï¼š $T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))$ $T_1(n) \times T_2(n) = O(f_1(n) \times f_2(n))$ è‹¥$T(n)$æ˜¯å…³äºŽ$n$çš„$k$é˜¶å¤šé¡¹å¼ï¼Œé‚£ä¹ˆ$T(n) = Î¸(n^k)$ ä¸€ä¸ªforå¾ªçŽ¯çš„æ—¶é—´å¤æ‚åº¦ç­‰äºŽå¾ªçŽ¯æ¬¡æ•°ä¹˜ä»¥å¾ªçŽ¯ä½“ä»£ç çš„å¤æ‚åº¦ if-elseç»“æž„çš„å¤æ‚åº¦å–å†³äºŽifçš„æ¡ä»¶åˆ¤æ–­å¤æ‚åº¦å’Œä¸¤ä¸ªåˆ†æ”¯éƒ¨åˆ†çš„å¤æ‚åº¦ï¼Œæ€»ä½“å¤æ‚åº¦å–ä¸‰è€…ä¸­æœ€å¤§ å¹³æ—¶åœ¨åšåˆ°ä¸€äº›é¢˜ç›®çš„æ—¶å€™ä¼šé‡åˆ°è¦åˆ†æžæ—¶é—´å¤æ‚åº¦çš„ä¹ é¢˜ï¼Œå¯ä»¥ä»Žä¸Šè¿°çš„è§’åº¦å…¥æ‰‹ã€‚ä¸è¿‡ä¸€èˆ¬è€Œè¨€ï¼Œç¬¬å››æ¡ç”¨çš„è¦å¤šä¸€äº›ã€‚ Demo Codeexample 2 é¢˜ç›®ï¼šå†™ç¨‹åºå®žçŽ°ä¸€ä¸ªå‡½æ•° PrintN ï¼Œä½¿å¾—ä¼ å…¥ä¸€ä¸ªæ­£æ•´æ•°ä¸º N çš„å‚æ•°åŽï¼Œèƒ½é¡ºåºæ‰“å°ä»Ž 1 åˆ° N çš„å…¨éƒ¨æ­£æ•´æ•°ã€‚ å­¦è¿‡ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€çš„åŒå­¦ï¼Œåº”è¯¥ä¸ä¼šè§‰å¾—æœ‰å›°éš¾ï¼Œå› ä¸ºç›´æŽ¥åˆ©ç”¨å¾ªçŽ¯ä»Ž 1 æ•°åˆ° N å³å¯å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ä½†æ˜¯ï¼Œå¯èƒ½ä¼šæœ‰éƒ¨åˆ†åŒå­¦ä¼šå¯¹é€’å½’ä¸ç†Ÿæ‚‰ï¼Œå¥½åœ¨è€å¸ˆä¹Ÿç»™å‡ºäº†ä»£ç ã€‚123456789101112131415161718192021222324#include &lt;stdio.h&gt;void PrintN(int n) &#123; // method 1: use loop for(int i = 1; i &lt;= n; i++) &#123; printf("%d\n", i); &#125;&#125;/*void PrintN(int n) &#123; // method 2: use recursion if(n) &#123; PrintN(n - 1); printf("%d\n", n); &#125;&#125;*/int main() &#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125; example 3 é¢˜ç›®ï¼šå†™ç¨‹åºè®¡ç®—ç»™å®šå¤šé¡¹å¼åœ¨ç»™å®šç‚¹ x å¤„çš„å€¼ã€‚ å¤„ç†è¿™ä¸ªé¢˜æœ‰ä¸¤ç§æ–¹æ³•ï¼Œæ‰€ä»¥å¯ä»¥é¡ºä¾¿æ¯”è¾ƒä¸€ä¸‹ä¸¤ç§æ–¹æ³•è¿è¡Œçš„æ—¶é—´é•¿çŸ­ã€‚ç”±äºŽè®¡ç®—æœºçš„è¿è¡Œé€Ÿåº¦è¾ƒå¿«ï¼Œä»…è¿è¡Œä¸€æ¬¡æ— æ³•çœ‹å‡ºå·®å¼‚ï¼Œæ‰€ä»¥éœ€è¦å¤šæ‰§è¡Œå‡ æ¬¡ã€‚è®¡ç®—æ—¶é—´éœ€è¦å€ŸåŠ© C è¯­è¨€çš„åº“å‡½æ•°ï¼Œè€Œè¿™äº›åº“å‡½æ•°çš„å£°æ˜Žåœ¨time.hè¿™ä¸ªå¤´æ–‡ä»¶ä¸­ã€‚ç”±äºŽå§¥å§¥åˆç»™å‡ºäº†ä»£ç ï¼Œåˆå¯ä»¥å·æ‡’äº†~ä¸‹é¢ç»™å‡ºä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7double f1(int n, double a[], double x) &#123; int i; double p = a[0]; for(i = 1; i &lt;= n; i++) &#123; p += (a[i] * pow(x, i)); &#125; return p;&#125;double f2(int n, double a[], double x) &#123; int i; double p = a[n]; for(i = n; i &gt; 0; i--) &#123; p = a[i - 1] + x * p; &#125; return p;&#125; int main() &#123; int i; double a[MAXN]; for(i = 0; i &lt; MAXN; i++) a[i] = (double)i; start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f1(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks1 = %f\n", (double)(stop - start)); printf("duration1 = %6.2e\n", duration); start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f2(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks2 = %f\n", (double)(stop - start)); printf("duration2 = %6.2e\n", duration); return 0;&#125;/*result:ticks1 = 1969.000000duration1 = 1.97e+000ticks2 = 284.000000duration2 = 2.84e-001*/ ä»Žä¸Šé¢ä»£ç çš„ç»“æžœå¯ä»¥çœ‹å‡ºï¼Œé‡‡ç”¨ä¸åŒè®¡ç®—æ–¹æ³•çš„ä»£ç è¿è¡Œæ—¶é—´ç«Ÿç„¶ç›¸å·®äº†å‡ ä¹Ž 7 å€ï¼ Maximum Subsequence Sum é¢˜ç›®ï¼šæœ€å¤§å­åˆ—å’Œé—®é¢˜ æœ€å¤§å­åˆ—å’Œçš„é—®é¢˜æ˜¯å¾ˆç»å…¸çš„åŠ¨æ€è§„åˆ’ï¼ˆDP, dynamic programmingï¼‰é—®é¢˜ï¼Œè¿™æ˜¯åšä¸»åŽæ¥æŸ¥é˜…èµ„æ–™äº†è§£åˆ°çš„ã€‚æ—¢ç„¶å§¥å§¥å°†è¿™é“é¢˜å½“ä½œä¾‹é¢˜æ”¾åœ¨ç¬¬ä¸€è®²ï¼Œåº”è¯¥ä¹Ÿæœ‰å¥¹çš„é“ç†ï¼Œä½•å†µå¥¹è¿˜ä»‹ç»äº†è¿™ä¹ˆå¤šä¸ç”¨åŠ¨è§„æ€è·¯çš„è§£é¢˜æ–¹æ³•å‘¢ã€‚ä»Žé¢˜ç›®å‡ºå‘ï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´å¾—åˆ°è¿™é“é¢˜çš„ç­”é¢˜ä»£ç æ¡†æž¶ï¼š123456789101112131415#include &lt;stdio.h&gt;int MaxSubseqsum(int a[], int k) &#123;&#125;int main(int argc, char const *argv[]) &#123; int i, K; scanf("%d", &amp;K); int arr[K]; for(i=0; i&lt;K; i++) &#123; scanf("%d", &amp;arr[i]); &#125; printf("%d\n", MaxSubseqsum(arr, K)); return 0;&#125; ä¸‹é¢æ¥çœ‹çœ‹å„ç§ä¸åŒçš„è§£æ³•ï¼š directly calculating easy versionç›´æŽ¥æš´åŠ›æ±‚è§£çš„æ€è·¯è¾ƒä¸ºç›´è§‚ï¼Œåˆ©ç”¨ä¸‰é‡å¾ªçŽ¯ï¼Œå°†æ¯ä¸€ä¸ªæ•°æž„æˆçš„åºåˆ—å…¨éƒ¨æžšä¸¾ä¸€éï¼Œå¦‚æžœç¬¦åˆæ¡ä»¶ä¸”æ»¡è¶³æœ€å¤§ï¼Œå°±æ›´æ–°ç»“æžœã€‚å¾ªçŽ¯ç»“æŸåŽï¼Œå¾—åˆ°æœ€åŽç»“æžœã€‚1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j, k; for(i=0; i&lt;N; i++) &#123; for(j=i; j&lt;N; j++) &#123; ThisSum = 0; for(k=i; k&lt;=j; k++) &#123; ThisSum += a[k]; &#125; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; directly calculating advanced versionç»§ç»­æŒ‰ç…§æš´åŠ›æ±‚è§£çš„æ€è·¯è¿›è¡Œè®¡ç®—ï¼Œå¯ä»¥å‘çŽ°ï¼šå¯¹äºŽç›¸åŒçš„ i ï¼Œä¸åŒçš„ j ï¼Œåªè¦åœ¨ j - 1 æ¬¡å¾ªçŽ¯çš„åŸºç¡€ä¸Šç´¯åŠ  1 é¡¹å³å¯ï¼Œè€Œä¸éœ€è¦å†ä»Ž 1 ä¸€ç›´åŠ åˆ° iã€‚è¿™æ ·çš„è¯ï¼Œå°±å¯ä»¥èŠ‚çœä¸€å±‚forå¾ªçŽ¯çš„è¿è¡Œæ—¶é—´äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j; for(i=0; i&lt;N; i++) &#123; ThisSum = 0; for(j=i; j&lt;N; j++) &#123; ThisSum += a[j]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; divide and conquerè¿™é“é¢˜è¿˜å¯ä»¥é‡‡ç”¨åˆ†æ²»æ³•æ¥è§£å†³ï¼Œä¸è¿‡ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“ç†è§£ï¼Œä½†æ ¹æœ¬åœ¨äºŽè¦æŠŠæ¡æ­¤æ³•ä¸­è¾¹ç•Œçš„æ¦‚å¿µï¼Œå¹¶ä¸”è¦æ³¨æ„æœ€ç»ˆç»“æžœæ˜¯ 3 ç§æƒ…å†µä¸‹çš„æœ€å¤§å€¼ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142int MaxSubseqsum(int a[], int N) &#123; /*use same interface*/ return DivideAndConquer(a, 0, N-1);&#125;int DivideAndConquer(int a[], int left, int right) &#123; int MaxLeftSum, MaxRightSum; /*save the result of left and right subsequence */ int MaxLeftBorderSum, MaxRightBorderSum; /*save the result of each subsequence*/ int LeftBorderSum, RightBorderSum; int center, i; if(left == right) &#123; if(a[left] &gt; 0) return a[left]; else return 0; &#125; /*divide*/ center = (left + right) / 2; /*use recursion to get the result*/ MaxLeftSum = DivideAndConquer(a, left, center); MaxRightSum = DivideAndConquer(a, center+1, right); /*get the result of left subsequence*/ MaxLeftBorderSum = 0, LeftBorderSum = 0; for(i=center; i&gt;=left; i--) &#123; LeftBorderSum += a[i]; if(LeftBorderSum &gt; MaxLeftBorderSum) MaxLeftBorderSum = LeftBorderSum; &#125; /*get the result of right subsequence*/ MaxRightBorderSum = 0, RightBorderSum = 0; for(i=center+1; i&lt;=right; i++) &#123; RightBorderSum += a[i]; if(RightBorderSum &gt; MaxRightBorderSum) MaxRightBorderSum = RightBorderSum; &#125; return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);&#125;int Max3(int a, int b, int c)&#123; return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;&#125; online processingæ¯”èµ·ä¸Šé¢çš„å‡ ç§æ–¹æ³•ï¼Œåœ¨çº¿å¤„ç†å°±ç®€å•ç²—æš´äº†è®¸å¤šï¼Œä¸€è¶Ÿå¾ªçŽ¯ä¸‹æ¥å°±å®Œäº‹äº†ï¼Œä½†ä¸æ˜¯é‚£ä¹ˆå¥½ç†è§£ï¼Œæœ€å¥½æ ¹æ®æµ‹è¯•æ ·ä¾‹æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€éã€‚æ­¤æ³•ä¹‹æ‰€ä»¥å¿«çš„åŽŸå› åœ¨äºŽï¼Œä¸€æ—¦å‡ºçŽ°äº†åºåˆ—å‡ºçŽ°äº†è´Ÿæ•°ï¼Œè´Ÿæ•°å¹¶ä¸èƒ½ä½¿ç»“æžœå˜å¤§ï¼Œåè€Œä½¿ç»“æžœå˜å°äº†ã€‚é‚£ä¹ˆè¿™ç§æƒ…å†µå°±ä¸æ˜¯ç¬¦åˆæ¡ä»¶çš„ç»“æžœäº†ï¼Œç›´æŽ¥èˆå¼ƒï¼Œè¿™æ ·å°±ä¸ç”¨åšå¤šä½™çš„è®¡ç®—äº†ï¼Œè¿™å’Œâ€œå‰ªæžâ€æœ‰ç‚¹ç›¸ä¼¼ã€‚è€Œæ‰€è°“â€œåœ¨çº¿â€ï¼Œæ„æ€æ˜¯æŒ‡æ¯è¾“å…¥ä¸€ä¸ªæ•°æ®å°±è¿›è¡Œå³æ—¶å¤„ç†ï¼Œåœ¨ä»»ä½•ä¸€ä¸ªåœ°æ–¹ä¸­æ­¢è¾“å…¥ï¼Œç®—æ³•éƒ½èƒ½æ­£ç¡®ç»™å‡ºå½“å‰çš„è§£ã€‚1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for(i=0; i&lt;N; i++) &#123; ThisSum += a[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; &#125; &#125; return MaxSum;&#125; Homeworkæ­¤è¯¾ç¨‹çš„ä½œä¸šé¢˜ç›®å…¨éƒ¨éƒ½æ”¾åœ¨ PTA çš„ä¹ é¢˜é›†å†…ï¼ŒæŒ‰ç…§å§¥å§¥ç»™çš„é‚€è¯·ç å°±å¯ä»¥è¿›å…¥é¢˜ç›®é›†åšé¢˜å•¦ã€‚ 01-1 æœ€å¤§å­åˆ—å’Œé—®é¢˜è¿™é“é¢˜è¢«å§¥å§¥å½“æˆäº†åº”ç”¨å®žä¾‹è¿›è¡Œè®²è§£ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨å§¥å§¥ç»™çš„ä»£ç ï¼Œç¨åŠ ä¿®æ”¹ä¸€ä¸‹å°±å¯ä»¥ç›´æŽ¥ AC äº†ã€‚ä¸è¿‡ï¼Œæ ¹æ®è¿™é“é¢˜ç»™å®šçš„ä¸€äº›æ¡ä»¶ï¼Œéœ€è¦å¯¹ä¸€äº›æ•°æ®åšä¸€äº›å¤„ç†ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬å·ä¸‹æ‡’ï¼Œç›´æŽ¥ä½¿ç”¨åœ¨çº¿å¤„ç†æ€è·¯çš„ä»£ç è¿›è¡Œè§£é¢˜ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int f(int array[], int N) &#123; int ThisSum = 0, MaxSum = 0; int i; for(i = 0; i &lt; N; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; else if(ThisSum &lt; 0) ThisSum = 0; &#125; return MaxSum;&#125;int main() &#123; int k, i; scanf("%d", &amp;k); for(i = 0; i &lt; k ; i++) &#123; scanf("%d", &amp;array[i]); &#125; printf("%d", f(array, k)); return 0;&#125;/*samples:in:6-2 11 -4 13 -5 -2 out:20*/ 01-2 Maximum Subsequence Sumè¿™é“é¢˜æ˜¯ä¸Šé¢é¢˜ç›®çš„å‡çº§ç‰ˆï¼Œè¦æ±‚ç»™å‡ºæœ€ä½³ç»“æžœçš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹çš„ä¸‹æ ‡ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¿™é“é¢˜ç›®çš„è¾“å‡ºè¦æ±‚æ¯”è¾ƒå¤šï¼Œè¦å½“å¿ƒä¸€ç‚¹ã€‚æ­¤é¢˜è¿˜æ˜¯åˆ©ç”¨åœ¨çº¿å¤„ç†çš„æ€è·¯è¿›è¡Œæ±‚è§£ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int main() &#123; int k, i; scanf("%d", &amp;k); bool flag = false; for(i = 1; i &lt;= k; i++) &#123; scanf("%d", array + i); if(array[i] &gt;= 0) flag = true; &#125; if(!flag) &#123; printf("0 %d %d\n", array[1], array[k]); // all the numbers are negative &#125; else &#123; int left = 1, right = k, temp_left = 1; int ThisSum = 0, MaxSum = -1; // MaxSum need to be initialized as a negative number for(i = 1; i &lt;= k; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) &#123; // update max value, the left index and right index MaxSum = ThisSum; left = temp_left; right = i; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; printf("%d %d %d\n", MaxSum, array[left], array[right]); &#125; return 0;&#125; 01-3 äºŒåˆ†æŸ¥æ‰¾è¿™é“é¢˜ç›®ä»‹ç»çš„ç®—æ³•ç®—æ˜¯ååˆ†åŸºç¡€å…¥é—¨çš„ç®—æ³•äº†ï¼Œå¯¹äºŽå­¦è¿‡ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€çš„åŒå­¦æ¥è¯´ï¼Œè¦è§£å†³åº”è¯¥ä¸ä¼šæœ‰ä»€ä¹ˆå›°éš¾ã€‚ä¸è¿‡ï¼Œå¯èƒ½ä¼šæœ‰éƒ¨åˆ†åŒå­¦ä¼šå¯¹ PTA ä¸Šæ­¤ç±»é¢˜ç›®çš„åšé¢˜æ–¹æ³•æœ‰æ‰€ç–‘æƒ‘ã€‚å…¶å®žï¼Œè¿™ç§å‡½æ•°é¢˜å°±æ˜¯è®©ä½ å†™ä¸ªå‡½æ•°ï¼Œç„¶åŽç³»ç»Ÿä¼šè‡ªåŠ¨çš„å°†ä½ æäº¤çš„è¿™æ®µå‡½æ•°ä»£ç åµŒå…¥åˆ°é¢˜ç›®çš„ä»£ç ä¹‹ä¸­è¿è¡Œï¼Œç»§è€Œåˆ¤æ–­ç»“æžœæ˜¯å¦æ­£ç¡®ã€‚è¦æ³¨æ„è¿™ç±»é¢˜ç›®å¯¹å‡½æ•°æŽ¥å£å’Œä¸€äº›å…³é”®è¯çš„å®šä¹‰ï¼Œä¸è¦æžé”™äº†ã€‚ç¬”è€…åšè¿™ç±»é¢˜ç›®æ—¶ï¼Œéƒ½æ˜¯ç›´æŽ¥æŠŠæ‰€æœ‰ä»£ç å…¨éƒ¨æ‹·è´ä¸‹æ¥ï¼Œç„¶åŽæŠŠç¼ºå¤±çš„ä»£ç å…¨éƒ¨æŒ‰ç…§é¢˜æ„å†™å‡ºæ¥ï¼Œç„¶åŽå†å•ç‹¬çš„æäº¤é¢˜ç›®è¦æ±‚çš„é‚£ä¸ªå‡½æ•°ä»£ç ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* ä¿å­˜çº¿æ€§è¡¨ä¸­æœ€åŽä¸€ä¸ªå…ƒç´ çš„ä½ç½® */&#125;;List ReadInput(); /* è£åˆ¤å®žçŽ°ï¼Œç»†èŠ‚ä¸è¡¨ã€‚å…ƒç´ ä»Žä¸‹æ ‡1å¼€å§‹å­˜å‚¨ */Position BinarySearch( List L, ElementType X );int main() &#123; List L; ElementType X; Position P; L = ReadInput(); scanf("%d", &amp;X); P = BinarySearch( L, X ); printf("%d\n", P); return 0;&#125;List ReadInput() &#123; List L = (List)malloc(sizeof(struct LNode)); int n, t, i; scanf("%d", &amp;n); for(i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;L-&gt;Data[i]); &#125; L-&gt;Last = i; return L;&#125;Position BinarySearch( List L, ElementType X ) &#123; int left = 1, right = L-&gt;Last, mid, flag = 0; while(left &lt;= right) &#123; mid = (left + right) / 2; if(L-&gt;Data[mid] == X) &#123; flag = 1; break; &#125; else if(L-&gt;Data[mid] &lt; X) left = mid + 1; else right = mid - 1; &#125; if(flag) return mid; else return NotFound;&#125;/*some samples:in:512 31 55 89 10131out:2in:326 78 23331out:0in:426 78 88 23388out:3in:426 78 88 23378out:2*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice]]></title>
    <url>%2F2019%2F06%2F30%2FPAT-Advanced-Level-Practice%2F</url>
    <content type="text"><![CDATA[Introä»Žå…¥é—¨åˆ°å…¥åœŸç³»åˆ—ä¹‹ PAT ç”²çº§ é¢˜åº“å¿«ä¹ðŸ¤£å¯åŠ¨ã€‚é•¿æœŸæ›´æ–°ing~ 1001 A+B FormatAnalysisé¢˜ç›®æ„æ€æ¯”è¾ƒç®€å•ï¼Œç»™ä¿©æ•°ï¼Œç›¸åŠ ç®—ç»“æžœï¼Œç„¶åŽè¾“å‡ºçš„æ—¶å€™æ¯ä¸‰ä½ä¸€ä¸ª,éš”å¼€ï¼Œå¹¶ä¸”è´Ÿæ•°å¾—åœ¨å¼€å¤´è¾“å‡º-ã€‚ æŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„æ•°å­—èŒƒå›´ï¼š$-10^6 \le a,\ b \le 10^6$ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨intåž‹å˜é‡è¿›è¡Œç›¸åŠ ï¼Œç„¶åŽåœ¨è¾“å‡ºä¹‹å‰åœ¨åšæ•°ä½æ‹†åˆ†å³å¯ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int MAXN = 10;int main(int argc, char const *argv[]) &#123; int a, b, sum; scanf("%d %d", &amp;a, &amp;b); sum = a + b; if(sum &lt; 0) &#123; putchar('-'); sum = -sum; &#125; int len = 0, num[MAXN]; if(sum == 0) &#123; num[len++] = sum; &#125; while(sum) &#123; num[len++] = sum % 10; sum /= 10; &#125; for(int i = len - 1; i &gt;= 0; i--) &#123; printf("%d", num[i]); if(i &gt; 0 &amp;&amp; i % 3 == 0) &#123; putchar(','); &#125; &#125; return 0;&#125; è´´ä¸ª C++ ç”¨å­—ç¬¦ä¸²å¤„ç†çš„æ€è·¯ï¼š1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; '-'; c = -c; &#125; string str = to_string(c), tmp; int cnt = 0; for(int i = str.length() - 1; i &gt;= 0; i--) &#123; tmp.push_back(str[i]); cnt++; if(cnt == 3) &#123; if(i != 0) tmp += ','; cnt = 0; &#125; &#125; reverse(tmp.begin(), tmp.end()); cout &lt;&lt; tmp; return 0;&#125; ä¸è¿‡æ¢ä¸ªæ€è·¯ï¼Œè¿™ä¸ªé¢˜è¿˜èƒ½æ›´ç®€å•ï¼š12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b, c; cin &gt;&gt; a &gt;&gt; b; c = a + b; if(c &lt; 0) &#123; cout &lt;&lt; '-'; c = -c; &#125; if(c &gt;= 1000000) printf("%d,%03d,%03d", c / 1000000, c % 1000000 / 1000, c % 1000); else if(c &gt;= 1000) printf("%d,%03d", c / 1000, c % 1000); else printf("%d", c); return 0;&#125; 1002 A+B for PolynomialsAnalysisæ­¤é¢˜æ˜¯ ZJU æ•°æ®ç»“æž„è¯¾ç¨‹é‡Œé¢çš„ä¾‹é¢˜äº†ï¼Œè€Œä¸”è¿˜åªæ˜¯ä¸€åŠçš„å†…å®¹ï¼Œç®—æ³•æ€æƒ³ä¸éš¾ï¼ˆæ¯•ç«Ÿåªæ˜¯åˆä¸­æ•°å­¦çš„æ°´å¹³ï¼Œæˆ‘ä¸¢ðŸ˜…ï¼‰ï¼Œå…ˆæŒ‰ç…§é“¾è¡¨æ¥åšå§ï¼ŒåŽé¢åœ¨çœ‹çœ‹èƒ½ä¸èƒ½å°è¯•å…¶ä»–æ–¹æ³•ã€‚ä¸€å¼€å§‹å·æ‡’æ²¡æœ‰å°†ç»“æžœæž„é€ æˆä¸€ä¸ªæ–°çš„é“¾è¡¨ï¼Œå‘çŽ°æµ‹è¯•ç‚¹5æ— æ³•é€šè¿‡ï¼Œæ”¹äº†ä¸€ä¼šï¼Œè¿˜æ˜¯ä¸é€‰æ‹©å·æ‡’äº†... Codemethod 1ç”¨é“¾è¡¨åšæ¯”è¾ƒç¹çï¼Œä¸è¿‡å¯ä»¥é”»ç‚¼ä¸€ä¸‹é“¾è¡¨çš„åŸºæœ¬æ“ä½œã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*test point 5, like this:2 1 2.4 0 3.23 2 2.4 1 2.4 0 -3.2*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct Polynode* Polynomial;struct Polynode &#123; int expo; double coef; Polynomial link;&#125;;Polynomial ReadPoly();Polynomial Add(Polynomial P1, Polynomial P2);void Print(Polynomial PP);int GetNum(Polynomial P);void Attach(double c, int e, Polynomial *pRear);int main(int argc, char const *argv[]) &#123; Polynomial P1 = ReadPoly(); Polynomial P2 = ReadPoly(); Polynomial PP = Add(P1, P2); int number = GetNum(PP); if(number) &#123; printf("%d ", number); Print(PP); &#125; else &#123; printf("%d\n", number); &#125; return 0;&#125;Polynomial ReadPoly() &#123; int K; scanf("%d", &amp;K); Polynomial P, rear; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;link = NULL; rear = P; int e; double c; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;rear); &#125; return P;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial p1 = P1-&gt;link, p2 = P2-&gt;link, p, rear; p = (Polynomial)malloc(sizeof(struct Polynode)); p-&gt;link = NULL; rear = p; double sum; while(p1 &amp;&amp; p2) &#123; int temp = p1-&gt;expo - p2-&gt;expo; if(temp &gt; 0) &#123; Attach(p1-&gt;coef, p1-&gt;expo, &amp;rear); p1 = p1-&gt;link; &#125; else if(temp == 0) &#123; sum = p1-&gt;coef + p2-&gt;coef; if(sum) &#123; Attach(sum, p1-&gt;expo, &amp;rear); &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else &#123; Attach(p2-&gt;coef, p2-&gt;expo, &amp;rear); p2 = p2-&gt;link; &#125; &#125; if(p1) &#123; rear-&gt;link = p1; &#125; if(p2) &#123; rear-&gt;link = p2; &#125; return p;&#125;void Print(Polynomial PP) &#123; Polynomial P = PP-&gt;link; while(P) &#123; if(P-&gt;link == NULL) &#123; printf("%d %.1lf\n", P-&gt;expo, P-&gt;coef); &#125; else &#123; printf("%d %.1lf ", P-&gt;expo, P-&gt;coef); &#125; P = P-&gt;link; &#125;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P-&gt;link; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;coef = c; P-&gt;expo = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125; ç”¨ C++ çš„ç‰¹æ€§ï¼Œç®€åŒ–ä¸€ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;typedef struct Node* List;typedef struct Node* PtrtoNode;struct Node &#123; int exp; double coe; PtrtoNode next; Node() &#123; next = nullptr; &#125; Node(int _exp, double _coe) &#123; exp = _exp; coe = _coe; next = nullptr; &#125;&#125;;List createlist(int node_num) &#123; int exp; double coe; List head = new Node; List L = head; while(node_num--) &#123; scanf("%d %lf", &amp;exp, &amp;coe); head-&gt;next = new Node(exp, coe); head = head-&gt;next; &#125; head = L; L = L-&gt;next; delete(head); return L;&#125;int main() &#123; int k, exp; double coe; scanf("%d", &amp;k); List L, L1, L2; L1 = createlist(k); scanf("%d", &amp;k); L2 = createlist(k); L = new Node; List tmp = L; while(L1 &amp;&amp; L2) &#123; if(L1-&gt;exp == L2-&gt;exp) &#123; if(L1-&gt;coe + L2-&gt;coe != 0) &#123; L-&gt;next = new Node(L1-&gt;exp, L1-&gt;coe + L2-&gt;coe); L = L-&gt;next; &#125; L1 = L1-&gt;next; L2 = L2-&gt;next; &#125; else if(L1-&gt;exp &gt; L2-&gt;exp) &#123; L-&gt;next = L1; L1 = L1-&gt;next; L = L-&gt;next; &#125; else &#123; L-&gt;next = L2; L2 = L2-&gt;next; L = L-&gt;next; &#125; &#125; if(L1) L-&gt;next = L1; if(L2) L-&gt;next = L2; L = tmp-&gt;next; delete(tmp); tmp = L; int cnt = 0; while(tmp) &#123; if(tmp-&gt;coe != 0) cnt++; tmp = tmp-&gt;next; &#125; printf("%d", cnt); if(cnt) &#123; while(L) &#123; printf(" %d %.1lf", L-&gt;exp, L-&gt;coe); L = L-&gt;next; &#125; &#125; return 0;&#125; method 2å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜æ‹¿æ•°ç»„åšï¼Œç®€å•äº†ä¸æ­¢ä¸€ç‚¹åŠç‚¹ðŸ˜‚ã€‚123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;void readp(int nums, double *poly) &#123; int exp; double coe; for(int i = 0; i &lt; nums; i++) &#123; scanf("%d %lf", &amp;exp, &amp;coe); poly[exp] = coe; &#125;&#125;int main() &#123; double L1[1005] = &#123;0&#125;, L2[1005] = &#123;0&#125;, L[1005] = &#123;0&#125;; int k1, k2, exp; double coe; scanf("%d", &amp;k1); readp(k1, L1); scanf("%d", &amp;k2); readp(k2, L2); int cnt = 0; for(int i = 0; i &lt; 1005; i++) &#123; L[i] = L1[i] + L2[i]; if(L[i] != 0) cnt++; &#125; printf("%d", cnt); if(cnt) &#123; for(int i = 1000; i &gt;= 0; i--) &#123; if(L[i] != 0) printf(" %d %.1lf", i, L[i]); &#125; &#125; return 0;&#125; 1003 EmergencyAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šå‡ ä¸ªåŸŽå¸‚ä¹‹é—´çš„åœ°å›¾ï¼ŒåŸŽå¸‚ä¹‹é—´çš„è·¯æœ‰ç›¸åº”çš„æƒå€¼ï¼Œç„¶åŽç»™å®šèµ·å§‹åŸŽå¸‚å’Œç»ˆç‚¹åŸŽå¸‚ï¼Œé—®ä»Žèµ·å§‹åŸŽå¸‚åˆ°è¾¾ç»ˆç‚¹åŸŽå¸‚çš„è·¯å¾„æœ‰å‡ æ¡ï¼Œå¹¶ä¸”è¿™äº›è·¯å¾„ä¸Šç‚¹æƒä¹‹å’Œæœ€å¤§æ˜¯å¤šå°‘ã€‚ ç”±äºŽé¢˜ç›®çš„å®žé™…æ„ä¹‰ï¼Œæž„é€ å¥½çš„å›¾ä¸€å®šæ˜¯ä¸€ä¸ªæ— å‘å›¾ï¼Œå€ŸåŠ© Dijkstra ç®—æ³•æˆ– Bellman-Ford ç®—æ³•å¯ä»¥è§£å†³è¿™ä¸¤ä¸ªé—®é¢˜ã€‚ è·¯å¾„æ¡æ•°å’Œç‚¹æƒå’Œçš„æœ€å¤§å€¼ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥ç»Ÿè®¡å³å¯ã€‚ CodeDijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 510;const int INF = 1000000000;int n, m, st, ed, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;;bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, INF); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = INF; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != INF) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; //update the distance of each node w[v] = w[u] + weight[v]; // update the 'hands' num[v] = num[u]; // update the path for a new reachable node &#125; else if(d[u] + G[u][v] == d[v]) &#123; /*only one path can count the 'hands', so the w[v] will be covered by the sum of last node and its own 'hands' */ if(w[u] + weight[v] &gt; w[v]) &#123; w[v] = w[u] + weight[v]; &#125; //but the number of path is not only num[v] += num[u]; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v; fill(G[0], G[0] + maxv * maxv, INF); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v]; G[v][u] = G[u][v]; &#125; dijkstra(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; Bellman-Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct node &#123; int v, dis; node(int _v, int _dis) : v(_v), dis(_dis) &#123;&#125; // constructor&#125;;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, weight[maxv];int num[maxv] = &#123;0&#125;, w[maxv] = &#123;0&#125;, d[maxv];vector&lt;node&gt; Adj[maxv];set&lt;int&gt; pre[maxv];bool bellmanford(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; num[s] = 1; w[s] = weight[s]; for(int i = 0; i &lt; n - 1; i++) &#123; for(int u = 0; u &lt; n; u++) &#123; for(int j = 0; j &lt; Adj[u].size(); j++) &#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) &#123; // more optimal solution d[v] = d[u] + dis; w[v] = w[u] + weight[v]; num[v] = num[u]; pre[v].clear(); // attention: pre[v] must be clear firstly pre[v].insert(u); // save the precursor &#125; else if(d[u] + dis == d[v]) &#123; if(w[v] &lt; w[u] + weight[v]) &#123; // update the maximum w[v] = w[u] + weight[v]; &#125; pre[v].insert(u); // other shortest path also need save num[v] = 0; // the number of shortest path has been changed set&lt;int&gt;::iterator it; for(it = pre[v].begin(); it != pre[v].end(); it++) &#123; num[v] += num[*it]; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; Adj[u].push_back(node(v, dis)); Adj[v].push_back(node(u, dis)); &#125; bellmanford(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; 1004 Counting LeavesAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, child, seq, maxDepth = -1;int leaves[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(Node[front].depth &gt; maxDepth) &#123; maxDepth = Node[front].depth; &#125; if(Node[front].child.size() != 0) &#123; for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; q.push(child); &#125; &#125; else &#123; leaves[Node[front].depth]++; &#125; &#125; &#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); for(int i = 1; i &lt;= maxDepth; i++) &#123; cout &lt;&lt; leaves[i]; if(i &lt; maxDepth) cout &lt;&lt; ' '; &#125; return 0;&#125; 1005 Spell It RightAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œç»™ä¸€ä¸ªæ•°å­—ï¼Œè®¡ç®—å‡ºè¿™ä¸ªæ•°å­—æ¯ä¸€ä½ä¸Šçš„æ•°å­—ä¹‹å’Œï¼Œç„¶åŽç”¨è‹±æ–‡çš„æ–¹å¼åˆ†åˆ«è¾“å‡ºè¿™ä¸ªå’Œçš„æ¯ä¸€ä½æ•°å­—ï¼ˆå¥½å§ï¼Œæœ‰ç‚¹ç»•ðŸ˜…ï¼‰ã€‚ ä¸Žä¹™çº§é¢˜åº“çš„1002å¾ˆç±»ä¼¼ï¼Œè€ƒå¯Ÿæ•°ä½æ‹†åˆ†å§ï¼Œæ¯”è¾ƒç®€å•ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int MAXN = 100 + 5;char NumberTable[11][10] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",&#125;;int main(int argc, char const *argv[]) &#123; char num[MAXN]; int sum = 0; scanf("%s", num); char *p = num; while(*p != '\0') &#123; sum += *p++ - '0'; &#125; int temp = sum, mask = 1; while(temp &gt; 9) &#123; temp /= 10; mask *= 10; &#125; while(mask) &#123; printf("%s", NumberTable[sum / mask]); if(mask &gt; 9) &#123; putchar(' '); &#125; sum %= mask; mask /= 10; &#125; putchar('\n'); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, string&gt; num2english = &#123;&#123;0, "zero"&#125;, &#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;, &#123;4, "four"&#125;, &#123;5, "five"&#125;, &#123;6, "six"&#125;, &#123;7, "seven"&#125;, &#123;8, "eight"&#125;, &#123;9, "nine"&#125;&#125;;int main() &#123; string str; cin &gt;&gt; str; int sum = 0; for(int i = 0; i &lt; str.length(); i++) &#123; sum += str[i] - '0'; &#125; str = to_string(sum); for(int i = 0; i &lt; str.length(); i++) &#123; cout &lt;&lt; num2english[str[i] - '0']; if(i != str.length() - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; å†è¡¥ä¸ªç”¨ dfs è¾“å‡ºçš„åŠžæ³•ï¼š123456789101112131415161718192021222324#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;int, string&gt; num2english = &#123;&#123;0, "zero"&#125;, &#123;1, "one"&#125;, &#123;2, "two"&#125;, &#123;3, "three"&#125;, &#123;4, "four"&#125;, &#123;5, "five"&#125;, &#123;6, "six"&#125;, &#123;7, "seven"&#125;, &#123;8, "eight"&#125;, &#123;9, "nine"&#125;&#125;;void dfs(int n) &#123; if(n / 10 == 0) &#123; cout &lt;&lt; num2english[n % 10]; return; &#125; dfs(n / 10); cout &lt;&lt; ' ' &lt;&lt; num2english[n % 10];&#125;int main() &#123; string str; cin &gt;&gt; str; int sum = 0; for(int i = 0; i &lt; str.length(); i++) &#123; sum += str[i] - '0'; &#125; dfs(sum); return 0;&#125; 1006 Sign in and Sign OutAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œæœ€å…ˆåŽ»æœºæˆ¿çš„äººå¼€é—¨ï¼Œæœ€æ™šå‡ºæœºæˆ¿çš„äººå…³é—¨ï¼Œç”¨å­¦å·ä»£æ›¿äººåï¼Œè¾“å‡ºæœ€æ—©æ¥å’Œæœ€æ™šèµ°çš„äººçš„å­¦å·å³å¯ã€‚åˆ†æžè¾“å…¥æ•°æ®ï¼Œ1ä¸ªå­—ç¬¦ä¸²ï¼Œ6ä¸ªæ•´åž‹æ•°å­—ï¼Œæ¯3ä¸ªæ•°å­—ä¸ºä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œåˆ†åˆ«ä»£è¡¨åˆ°æ¥å’Œç¦»å¼€çš„æ—¶é—´ç‚¹ï¼Œæ—¢ç„¶è¦æ‰¾çš„åªæ˜¯æœ€æ—©å’Œæœ€æ™šçš„ä¸¤ä¸ªæ—¶é—´ç‚¹ï¼Œé‚£ä¹ˆæ¯æ¬¡å¯»æ‰¾æ—¶ï¼Œåªè¦åŽ»æ¯”è¾ƒä¸€ä¸ªæ—¶é—´ç‚¹å³å¯ã€‚æœ€æ—©æ¥çš„æ—¶é—´åˆå§‹åŒ–ä¸ºä¸€å¤©ä¸­æœ€åŽæ™šçš„æ—¶é—´ï¼ˆ23:59:59ï¼‰ï¼Œæœ€æ™šèµ°çš„æ—¶é—´åˆå§‹åŒ–ä¸ºä¸€å¤©ä¸­æœ€æ—©çš„æ—¶é—´ï¼ˆ00:00:00ï¼‰ï¼Œæ³¨æ„è¦åˆ†å¼€æ¯”è¾ƒï¼Œä¸èƒ½ç”¨if-elseå“¦ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;struct person&#123; char ID_number[20]; int start_hh, start_mm, start_ss, end_hh, end_mm, end_ss;&#125; first, last, temp;void Init();bool Earliest(person a, person b);bool Latest(person a, person b);int main(int argc, char const *argv[]) &#123; Init(); int M; scanf("%d", &amp;M); while(M--) &#123; scanf("%s %d:%d:%d %d:%d:%d", temp.ID_number, &amp;temp.start_hh, \ &amp;temp.start_mm, &amp;temp.start_ss, &amp;temp.end_hh, &amp;temp.end_mm, &amp;temp.end_ss); if(Earliest(temp, first)) &#123; first = temp; &#125; if(Latest(temp, last)) &#123; last = temp; &#125; &#125; printf("%s %s\n", first.ID_number, last.ID_number); return 0;&#125;void Init() &#123; first.start_hh = 23; first.start_mm = first.start_ss = 59; last.end_hh = last.end_mm = last.end_ss = 0;&#125;bool Earliest(person a, person b) &#123; if(a.start_hh != b.start_hh) return a.start_hh &lt;= b.start_hh; else if(a.start_mm != b.start_mm) return a.start_mm &lt;= b.start_mm; else return a.start_ss &lt;= a.start_ss;&#125;bool Latest(person a, person b) &#123; if(a.end_hh != b.end_hh) return a.end_hh &gt;= b.end_hh; else if(a.end_mm != b.end_mm) return a.end_mm &gt;= b.end_mm; else return a.end_ss &gt;= b.end_ss;&#125; å®žé™…ä¸Šï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨å­—ç¬¦ä¸²è¿›è¡Œæ¯”è¾ƒå¾—åˆ°ç¬¦åˆæ¡ä»¶çš„å€¼ï¼š123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main() &#123; int m; cin &gt;&gt; m; string early, late, earliest, latest, tmp, come, leave; cin &gt;&gt; early &gt;&gt; earliest &gt;&gt; latest; late = early; m--; while(m--) &#123; cin &gt;&gt; tmp &gt;&gt; come &gt;&gt; leave; if(come &lt; earliest) &#123; early = tmp; earliest = come; &#125; if(leave &gt; latest) &#123; late = tmp; latest = leave; &#125; &#125; cout &lt;&lt; early &lt;&lt; ' ' &lt;&lt; late; return 0;&#125; 1007 Maximum Subsequence SumAnalysisCodeDP123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int maxn = 10010;int a[maxn], dp[maxn];int s[maxn] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; bool flag = false; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if(a[i] &gt;= 0) flag = true; &#125; if(flag == false) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; a[n - 1]; &#125; else &#123; dp[0] = a[0]; for(int i = 1; i &lt; n; i++) &#123; if(dp[i - 1] + a[i] &gt; a[i]) &#123; dp[i] = dp[i - 1] + a[i]; s[i] = s[i - 1]; &#125; else &#123; dp[i] = a[i]; s[i] = i; &#125; &#125; int k = 0; for(int i = 1; i &lt; n; i++) &#123; if(dp[i] &gt; dp[k]) &#123; k = i; &#125; &#125; cout &lt;&lt; dp[k] &lt;&lt; ' ' &lt;&lt; a[s[k]] &lt;&lt; ' ' &lt;&lt; a[k]; &#125; return 0;&#125; Online-Processing1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxk = 10010;int main(int argc, char *argv[]) &#123; int k, arr[maxk] = &#123;0&#125;; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ThisSum = 0, MaxSum = -1; int left = 0, right = k - 1, temp_left = 0; for(int i = 0; i &lt; k; i++) &#123; ThisSum += arr[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; right = i; left = temp_left; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; if(MaxSum &lt; 0) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; else cout &lt;&lt; MaxSum &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; return 0;&#125; 1008 ElevatorAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç”µæ¢¯ç§»åŠ¨å’Œç­‰å¾…çš„æ—¶é•¿ï¼Œå†æŒ‰ç…§é¢˜ç›®ç»™å®šçš„åœç•™é¡ºåºï¼Œè®¡ç®—å‡ºç”µæ¢¯åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦çš„æ€»æ—¶é—´ã€‚ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼š åˆå§‹ä¸º0å±‚ï¼Œåˆ°2å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$2 \times 6 = 12\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$17s$ ä»Ž2å±‚åˆ°3å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$1 \times 6 = 6\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$11s$ ä»Ž3å±‚åˆ°1å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$2 \times 4 = 8\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$13s$ åˆè®¡ä¸ºï¼š$17 + 11 + 13 = 41\ s$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int n, array[105] = &#123;0&#125;; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; int total = 0, last = 0; for(int i = 0; i &lt; n; i++) &#123; if(array[i] == last) &#123; total += 5; &#125; else if(array[i] &gt; last) &#123; total += ((array[i] - last) * 6 + 5); &#125; else &#123; total += ((last - array[i]) * 4 + 5); &#125; last = array[i]; &#125; printf("%d\n", total); return 0;&#125; 1009 Product of PolynomialsAnalysisæ­¤é¢˜ä¹Ÿæ˜¯ ZJU æ•°æ®ç»“æž„è¯¾ç¨‹é‡Œé¢çš„ä¾‹é¢˜ï¼Œç®—æ˜¯å¦ä¸€åŠäº†ï¼Œä¸Ž 1002 æ˜¯ç±»ä¼¼çš„ï¼Œåªä¸è¿‡ 1002 æ˜¯åŠ æ³•ï¼Œè¿™ä¸ªæ˜¯ä¹˜æ³•ï¼Œè¿˜æ˜¯å…ˆç”¨é“¾è¡¨åšå§ã€‚ Codemethod 1é“¾è¡¨åšæ³•ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct PolyNode *Polynomial;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial *pRear);Polynomial ReadPoly();Polynomial Mult(Polynomial P1, Polynomial P2);void PrintPoly(Polynomial P);int Compare(int a, int b);int GetNum(Polynomial P);int main(int argc, char const *argv[])&#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PP = Mult(P1, P2); int numbers = GetNum(PP); if(numbers) &#123; printf("%d ", numbers); PrintPoly(PP); &#125; else &#123; printf("%d\n"); &#125; return 0;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125;Polynomial ReadPoly() &#123; Polynomial P, Rear, t; int e, K; double c; scanf("%d", &amp;K); P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t = P; P = P-&gt;link; free(t); return P;&#125;Polynomial Mult(Polynomial P1, Polynomial P2) &#123; Polynomial P, Rear, t1, t2, t; int e; double c; if(!P1 || !P2) return NULL; t1 = P1; t2 = P2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(t1) &#123; t2 = P2; Rear = P; while(t2) &#123; e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) &#123; Rear = Rear-&gt;link; &#125; if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if(Rear-&gt;link-&gt;coef + c) &#123; Rear-&gt;link-&gt;coef += c; &#125; else &#123; t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; &#125; t2 = P; P = P-&gt;link; free(t2); return P;&#125;void PrintPoly(Polynomial P) &#123; int flag = 0; while(P) &#123; if(!flag)&#123; flag = 1; &#125; else &#123; printf(" "); &#125; printf("%d %.1lf", P-&gt;expon, P-&gt;coef); P = P-&gt;link; &#125; printf("\n");&#125;int Compare(int a, int b) &#123; return a &gt; b ? 1 : a == b ? 0 : -1;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125; ç”¨ C++ çš„ç‰¹æ€§ç®€åŒ–ä¸€ä¸‹ï¼Œåˆ é™¤ä¸éœ€è¦çš„éƒ¨åˆ†ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;using namespace std;typedef struct Node* List;typedef struct Node* PtrtoNode;struct Node &#123; int exp; double coe; PtrtoNode next; Node() &#123; next = nullptr; &#125; Node(int _exp, double _coe) &#123; exp = _exp; coe = _coe; next = nullptr; &#125;&#125;;List createlist(int node_num) &#123; int exp; double coe; List head = new Node; List L = head; while(node_num--) &#123; scanf("%d %lf", &amp;exp, &amp;coe); head-&gt;next = new Node(exp, coe); head = head-&gt;next; &#125; head = L; L = L-&gt;next; delete(head); return L;&#125;int main() &#123; int k; scanf("%d", &amp;k); List L1 = createlist(k); scanf("%d", &amp;k); List L2 = createlist(k); List L = new Node, rear, t1 = L1, t2 = L2, t; rear = L; int exp_tmp; double coe_tmp; while(t1) &#123; t2 = L2; rear = L; while(t2) &#123; exp_tmp = t1-&gt;exp + t2-&gt;exp; coe_tmp = t1-&gt;coe * t2-&gt;coe; while(rear-&gt;next &amp;&amp; rear-&gt;next-&gt;exp &gt; exp_tmp) &#123; rear = rear-&gt;next; &#125; if(rear-&gt;next &amp;&amp; rear-&gt;next-&gt;exp == exp_tmp) &#123; if(rear-&gt;next-&gt;coe + coe_tmp) rear-&gt;next-&gt;coe += coe_tmp; else &#123; t = rear-&gt;next; rear-&gt;next = t-&gt;next; delete(t); &#125; &#125; else &#123; t = new Node(exp_tmp, coe_tmp); t-&gt;next = rear-&gt;next; rear-&gt;next = t; rear = rear-&gt;next; &#125; t2 = t2-&gt;next; &#125; t1 = t1-&gt;next; &#125; t = L; L = L-&gt;next; delete(t); int cnt = 0; t = L; while(t) &#123; cnt++; t = t-&gt;next; &#125; printf("%d", cnt); if(cnt) &#123; t = L; while(t) &#123; printf(" %d %.1lf", t-&gt;exp, t-&gt;coe); t = t-&gt;next; &#125; &#125; return 0;&#125; method 2æ•°ç»„åšæ³•ï¼š12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;void readp(int nums, double *poly) &#123; int exp; double coe; for(int i = 0; i &lt; nums; i++) &#123; scanf("%d %lf", &amp;exp, &amp;coe); poly[exp] = coe; &#125;&#125;int main() &#123; double L1[1005] = &#123;0&#125;, L2[1005] = &#123;0&#125;, L[2010] = &#123;0&#125;; int k1, k2, exp; double coe; scanf("%d", &amp;k1); readp(k1, L1); scanf("%d", &amp;k2); readp(k2, L2); for(int i = 0; i &lt; 1001; i++) &#123; for(int j = 0; j &lt; 1001; j++) &#123; exp = i + j; coe = L1[i] * L2[j]; L[exp] += coe; &#125; &#125; int cnt = 0; for(int i = 0; i &lt;= 2000; i++) &#123; if(L[i] != 0) cnt++; &#125; printf("%d", cnt); for(int i = 2000; i &gt;= 0; i--) &#123; if(L[i] != 0) printf(" %d %.1lf", i, L[i]); &#125; return 0;&#125; 1010 RadixAnalysisè¿™ä¸ªé¢˜çš„é¢˜æ„è¯´çš„æ¯”è¾ƒæ¨¡ç³Šï¼Œæ‰€ä»¥ä¸å¤ªå¥½å¯»æ‰¾æ€è·¯ã€‚å…ˆåˆ†æžä¸€ä¸‹é¢˜ç›®æ„æ€ï¼Œç»™å®šN1ï¼ŒN2ï¼Œtagå’Œradixå››ä¸ªæ•°å­—ï¼›è‹¥å½“tagä¸º1æ—¶ï¼Œradixçš„å€¼å°±æ˜¯N1çš„è¿›åˆ¶æ•°ï¼Œtagä¸º2æ—¶ï¼Œradixçš„å€¼å°±æ˜¯N2çš„è¿›åˆ¶æ•°ï¼ˆä¸€èˆ¬é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œæœ€å¥½äº¤æ¢ä¸‹N1å’ŒN2çš„å€¼ï¼Œå†ç»Ÿä¸€å¤„ç†ï¼‰ã€‚ ç´§æŽ¥ç€ï¼Œé¢˜ç›®è¦æ±‚åˆ¤æ–­N1å’ŒN2æ˜¯å¦ç›¸ç­‰ï¼Œç”±äºŽé¢˜ç›®ç»™å®šçš„ä¸¤ä¸ªæ•°å­—çš„è¿›åˆ¶ä¸ç›¸åŒï¼Œæ‰€ä»¥è¿˜å¿…é¡»è¦è½¬æ¢åŽè¿›è¡Œåˆ¤æ–­ã€‚ä¸Žå…¶è¿™æ ·ï¼Œä¸å¦‚ç›´æŽ¥å°†èƒ½ç¡®å®šè¿›åˆ¶çš„é‚£ä¸ªæ•°è½¬åŒ–ä¸ºåè¿›åˆ¶æ•°ï¼Œç„¶åŽä¸Žå¦ä¸€ä¸ªæ•°çš„æ¯ä¸€ä¸ªä¸åŒçš„è¿›åˆ¶å•ä½ä¸‹è½¬æ¢ä¸ºåè¿›åˆ¶æ•°åŽå€¼è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°ç›¸ç­‰ï¼ˆåªè¦åœ¨ä¸€ç§è¿›åˆ¶å•ä½ä¸‹ï¼Œä¸¤ä¸ªæ•°ç›¸ç­‰ï¼Œé‚£ä¹ˆåœ¨å…¶ä»–ä»»æ„è¿›åˆ¶å•ä½ä¸‹ï¼Œè¿™ä¸¤ä¸ªæ•°ä¸ç®¡å¦‚ä½•å˜åŒ–éƒ½æ˜¯ç›¸ç­‰çš„ï¼‰ã€‚ æ˜Žç™½é¢˜æ„åŽï¼Œå°±å¾—å¼€å§‹æ‰“ç äº†ã€‚ç”±äºŽé¢˜ç›®ç»™å®šçš„radixæ²¡æœ‰é™åˆ¶èŒƒå›´ï¼Œæ‰€ä»¥è½¬æ¢åŽçš„åè¿›åˆ¶æ•°æ˜¯æœ‰å¯èƒ½æº¢å‡ºçš„ï¼ˆlong longä¹Ÿä¼šï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨å­—ç¬¦ä¸²æ¥å­˜å‚¨æ•°å­—ã€‚ ç´§æŽ¥ç€ï¼ŒæŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œå…ˆæž„é€ å­—ç¬¦0 - 9å’Œa - zçš„åè¿›åˆ¶æ•°å¯¹åº”è¡¨ï¼Œæ–¹ä¾¿è°ƒç”¨ã€‚å¦å¤–ï¼Œä¸ç®¡tagçš„å€¼å¦‚ä½•ï¼Œå¯¹N1å’ŒN2è¿›è¡Œå¤„ç†ï¼Œé»˜è®¤N1æ˜¯è¿›åˆ¶ç¡®å®šçš„æ•°ã€‚åœ¨å¼€å§‹å¯¹N2è¿›è¡Œè¿›åˆ¶è½¬æ¢ä¹‹å‰ï¼Œè¦å…ˆç¡®å®šå…¶å¯èƒ½çš„è¿›åˆ¶èŒƒå›´ï¼Œè¿™ä¸ªç»“æžœå°±æ˜¯ï¼šä»¥å…¶å­—ç¬¦æœ€å¤§å€¼ä¸ºä¸‹ç•Œï¼ŒN1çš„åè¿›åˆ¶æ•°å€¼ä¸ºä¸Šç•Œã€‚åœ¨è¿™ä¸ªè¿›åˆ¶èŒƒå›´å†…ï¼Œä¸€ä¸ªä¸€ä¸ªåŽ»æžšä¸¾æ˜¾ç„¶æ˜¯å¾ˆæ…¢çš„ï¼Œæ‰€ä»¥ä½¿ç”¨äºŒåˆ†æ³•æ˜¯ä¸€ä¸ªå¾ˆä¸é”™çš„é€‰æ‹©ã€‚ æ³¨æ„ï¼š ä½¿ç”¨äºŒåˆ†æ³•æ—¶ï¼Œåªéœ€è¦æ‰¾åˆ°æ»¡è¶³æ¡ä»¶ï¼šä¸ŽN1çš„åè¿›åˆ¶æ•°ç›¸ç­‰çš„æ•°å³å¯ï¼Œæ­¤æ—¶å¾—è¿”å›žè¿›åˆ¶æ•°ã€‚ é’ˆå¯¹æ•°æ®çš„æº¢å‡ºæƒ…å†µï¼Œä¸€æ—¦ç»“æžœä¸ºè´Ÿï¼Œå°±å¯ä»¥åˆ¤æ–­ä¸ºæº¢å‡ºï¼Œæ­¤æ—¶N2åœ¨è¿™ä¸ªè¿›åˆ¶ä¸‹çš„è½¬æ¢å‡ºæ¥çš„åè¿›åˆ¶æ•°è‚¯å®šæ˜¯å¤§äºŽN1çš„åè¿›åˆ¶æ•°çš„ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL Map[256];LL inf = (1LL &lt;&lt; 63) - 1;void Init() &#123; for(char c = '0'; c &lt;= '9'; c++) &#123; Map[c] = c - '0'; &#125; for(char c = 'a'; c &lt;= 'z'; c++) &#123; Map[c] = c - 'a' + 10; &#125;&#125;LL ConvertNum10(char *a, LL radix, LL t) &#123; LL ret = 0; for(int i = 0; a[i] != '\0'; i++) &#123; ret = ret * radix + Map[a[i]]; if(ret &lt; 0 || ret &gt; t) &#123; ret = -1; break; &#125; &#125; return ret;&#125;int cmp(char *N2, LL radix, LL t) &#123; int len = strlen(N2); LL num = ConvertNum10(N2, radix, t); if(num &lt; 0) return 1; if(t &gt; num) return -1; else if(t == num) return 0; else return 1;&#125;LL BinarySearch(char *N2, LL left, LL right, LL t) &#123; LL mid; while(left &lt;= right) &#123; mid = (left + right) / 2; int flag = cmp(N2, mid, t); if(flag == 0) return mid; else if(flag == -1) left = mid + 1; else right = mid - 1; &#125; return - 1;&#125; int FindLargestDigit(char *N2) &#123; int ans = -1, len = strlen(N2); for(int i = 0; i &lt; len; i++) &#123; if(Map[N2[i]] &gt; ans) &#123; ans = Map[N2[i]]; &#125; &#125; return ans + 1;&#125;char N1[20], N2[20], temp[20];int tag, radix;int main(int argc, char const *argv[]) &#123; Init(); scanf("%s %s %d %d", N1, N2, &amp;tag, &amp;radix); if(tag == 2) &#123; strcpy(temp, N1); strcpy(N1, N2); strcpy(N2, temp); &#125; LL t = ConvertNum10(N1, radix, inf); LL low = FindLargestDigit(N2); LL high = max(low, t) + 1; LL ans = BinarySearch(N2, low, high, t); if(ans == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%lld\n", ans); &#125; return 0;&#125; 1011 World Cup BettingAnalysisé¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œä¸‰å±€æ¯”èµ›ï¼Œç»™å‡ºæ¯å±€çš„èµ”çŽ‡ï¼Œé»˜è®¤æ¯æ¬¡éƒ½èµŒå¯¹ï¼Œé—®æ€Žæ ·ä¹°æ”¶ç›Šæœ€å¤šã€‚å¾ˆç®€å•ï¼Œæ¯æ¬¡ä¹°èµ”çŽ‡æœ€å¤§çš„å°±å¥½å•¦~ç„¶åŽè¿˜æœ‰ä¸€ä¸ªéº»çƒ¦çš„åœ°æ–¹ï¼Œå°±æ˜¯è¦è¾“å‡ºæ¯å±€èµ”çŽ‡æœ€å¤§çš„æ˜¯å“ªä¸€ç§å±€ï¼Œå³ï¼šèŽ·èƒœï¼ˆWinï¼‰ã€å¹³å±€ï¼ˆTieï¼‰å’Œå¤±è´¥ï¼ˆLoseï¼‰ï¼Œå…ˆä¿å­˜æ¯æ¬¡çš„ä¸‹æ ‡ï¼Œç„¶åŽå†™ä¸ªå‡½æ•°è½¬æ¢ä¸€ä¸‹å°±å¥½äº†ã€‚è‡³äºŽæ”¶ç›Šçš„è®¡ç®—æ–¹æ³•ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å…¬å¼ç®—å°±å¥½äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;char change(int index);int main(int argc, char const *argv[]) &#123; double Bet[3][3], Profit = 0.0; for(int i = 0; i &lt; 3; i++) &#123; scanf("%lf %lf %lf", &amp;Bet[i][0], &amp;Bet[i][1], &amp;Bet[i][2]); &#125; int max_index[3]; double max[3] = &#123;0.0&#125;; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; if(max[i] &lt; Bet[i][j]) &#123; max[i] = Bet[i][j]; max_index[i] = j; &#125; &#125; &#125; Profit = (max[0] * max[1] * max[2] * 0.65 - 1.0) * 2.0; printf("%c %c %c %.2lf\n", change(max_index[0]), change(max_index[1]), change(max_index[2]), Profit); return 0;&#125;char change(int index) &#123; char ret; switch(index) &#123; case 0: ret = 'W'; break; case 1: ret = 'T'; break; case 2: ret = 'L'; break; &#125; return ret;&#125; è´´ä¸€ä¸ªç®€åŒ–ç‰ˆï¼š12345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; double turns[3][3], max, maxproduct = 1.0; char ans[3]; for(int i = 0; i &lt; 3; i++) &#123; max = -1000; for(int j = 0; j &lt; 3; j++) &#123; scanf("%lf", &amp;turns[i][j]); if(max &lt; turns[i][j]) &#123; max = turns[i][j]; if(j == 1) ans[i] = 'T'; else if(j == 2) ans[i] = 'L'; else ans[i] = 'W'; &#125; &#125; maxproduct *= max; &#125; double maxprofit = 0.0; maxprofit = (maxproduct * 0.65 - 1) * 2; for(int i = 0; i &lt; 3; i++) &#123; printf("%c ", ans[i]); &#125; printf("%.2lf", maxprofit); return 0;&#125; 1012 The Best RankAnalysisç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å„ç§‘æˆç»©ï¼Œè®¡ç®—å…¶å¹³å‡åˆ†ï¼Œå¹¶æ ¹æ®ä»–ä»¬çš„æˆç»©è¿›è¡ŒæŽ’åºï¼›ç„¶åŽæŸ¥æ‰¾æŒ‡å®šå­¦å·çš„å­¦ç”Ÿçš„æˆç»©ï¼Œè¾“å‡ºå…¶æŽ’åæœ€ä¼˜çš„æˆç»©å’Œç§‘ç›®åç§°ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000 + 5;struct student &#123; int id, grade[4];&#125; stu[MAXN];char course[4] = &#123;'A', 'C', 'M', 'E'&#125;;int Rank[10000000][4] = &#123;0&#125;;int now;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d %d", &amp;stu[i].id, &amp;stu[i].grade[1], &amp;stu[i].grade[2], &amp;stu[i].grade[3]); stu[i].grade[0] = (stu[i].grade[1] + stu[i].grade[2] + stu[i].grade[3]) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, cmp); Rank[stu[0].id][now] = 1; for(int i = 1; i &lt; N; i++) &#123; if(stu[i].grade[now] == stu[i - 1].grade[now]) &#123; Rank[stu[i].id][now] = Rank[stu[i - 1].id][now]; &#125; else &#123; Rank[stu[i].id][now] = i + 1; &#125; &#125; &#125; int query; while(M--) &#123; scanf("%d", &amp;query); if(Rank[query][0] == 0) &#123; printf("N/A\n"); &#125; else &#123; int k = 0; for(int j = 0; j &lt; 4; j++) &#123; if(Rank[query][j] &lt; Rank[query][k]) &#123; k = j; &#125; &#125; printf("%d %c\n", Rank[query][k], course[k]); &#125; &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade[now] &gt; b.grade[now];&#125; é‡æ–°å†™äº†ä¸€ä¸‹ï¼Œæ±‚æ¯ä¸ªå­¦ç”Ÿçš„å„ç§‘æŽ’åæ—¶ï¼Œä¸å†å¼€é‚£ä¹ˆå¤§çš„æ•°ç»„äº†ï¼Œä½†æ˜¯ä¼šæœ‰é¢å¤–çš„æŸ¥æ‰¾æ—¶é—´å¼€é”€ï¼ˆä¹Ÿèƒ½ ACï¼‰ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; string id; int grade[4]; int rank[4];&#125; stu[2005];char species[5] = "ACME";int now;int main() &#123; int N, M, c, m, e; cin &gt;&gt; N &gt;&gt; M; string str; for(int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; str &gt;&gt; c &gt;&gt; m &gt;&gt; e; stu[i].id = str; stu[i].grade[1] = c, stu[i].grade[2] = m, stu[i].grade[3] = e; stu[i].grade[0] = (c + m + e) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, [](student a, student b)&#123; return a.grade[now] &gt; b.grade[now]; &#125;); stu[0].rank[now] = 1; for(int j = 1; j &lt; N; j++) &#123; if(stu[j].grade[now] == stu[j - 1].grade[now]) stu[j].rank[now] = stu[j - 1].rank[now]; else stu[j].rank[now] = j + 1; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; cin &gt;&gt; str; int index = -1; for(int i = 0; i &lt; N; i++) &#123; if(stu[i].id == str) &#123; index = i; break; &#125; &#125; if(index == -1) cout &lt;&lt; "N/A" &lt;&lt; endl; else &#123; int k = 0; for(int i = 1; i &lt; 4; i++) &#123; if(stu[index].rank[i] &lt; stu[index].rank[k]) k = i; &#125; cout &lt;&lt; stu[index].rank[k] &lt;&lt; ' ' &lt;&lt; species[k] &lt;&lt; endl; &#125; &#125; return 0;&#125; 1013 Battle Over CitiesAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* method 1: use union-find set*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];int father[maxn];bool vis[maxn];int n, m, k;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = faB; &#125;&#125;void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; father[i] = i; vis[i] = false; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; int currentPoint; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; init(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; int u = i, v = G[i][j]; if(u == currentPoint || v == currentPoint) continue; Union(u, v); &#125; &#125; int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i == currentPoint) continue; int fa_i = findFather(i); if(vis[fa_i] == false) &#123; block++; vis[fa_i] = true; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;/*method 2: use DFS#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];bool vis[maxn] = &#123;false&#125;;int currentPoint;int n, m, k;void dfs(int v) &#123; if(v == currentPoint) return; vis[v] = true; for(int i = 0; i &lt; G[v].size(); i++) &#123; if(vis[G[v][i]] == false) &#123; dfs(G[v][i]); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; memset(vis, false, sizeof(vis)); int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i != currentPoint &amp;&amp; vis[i] == false) &#123; dfs(i); block++; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;*/ 1015 Reversible PrimesAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸¤ä¸ªæ•´æ•°Nã€Dï¼ŒNæ˜¯åè¿›åˆ¶ä¸‹çš„æ•´æ•°ï¼ŒDæ˜¯è¿›åˆ¶æ•°ï¼Œåˆ¤æ–­Nå’Œå°†Nè½¬æ¢ä¸ºDè¿›åˆ¶ä¸‹çš„æ•°æ˜¯å¦éƒ½æ˜¯ç´ æ•°ã€‚è‹¥æ˜¯ï¼Œè¾“å‡ºYesï¼Œåä¹‹è¾“å‡ºNoã€‚ è€ƒå¯Ÿè¿›åˆ¶è½¬æ¢å’Œç´ æ•°çš„åˆ¤æ–­ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;int Reverse(int number, int radix) &#123; int a[32], temp = number, count = 0, ret = 0; while(temp) &#123; a[count++] = temp % radix; temp /= radix; &#125; for(int i = 0; i &lt; count; i++) &#123; ret = ret * radix + a[i]; &#125; return ret;&#125;bool isPrime(int n) &#123; if(n &lt;= 1 || (n % 2 == 0 &amp;&amp; n != 2)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[]) &#123; int n, d; while(1) &#123; scanf("%d", &amp;n); if(n &lt; 0) break; scanf("%d", &amp;d); if(isPrime(n) &amp;&amp; isPrime(Reverse(n, d))) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;bool isprime(int n) &#123; if(n &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true; &#125;&#125;int main() &#123; int n, d; while(true) &#123; cin &gt;&gt; n; if(n &lt; 0) break; cin &gt;&gt; d; if(!isprime(n)) cout &lt;&lt; "No" &lt;&lt; endl; else &#123; vector&lt;int&gt; digits; int tmp = n; while(tmp) &#123; int r = tmp % d; digits.push_back(r); tmp /= d; &#125; tmp = 0; for(int i = 0; i &lt; digits.size(); i++) &#123; tmp = tmp * d + digits[i]; &#125; if(isprime(tmp)) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; &#125; &#125; return 0;&#125; 1016 Phone BillsAnalysiså…ˆåˆ†æžä¸€ä¸‹è¾“å…¥ï¼ŒåŒ…å«åç§°ã€æ—¶é—´å’ŒçŠ¶æ€ï¼Œå…¶ä¸­åç§°å’ŒçŠ¶æ€æ˜¯ä»¥å­—ç¬¦ä¸²çš„å½¢å¼è¾“å…¥çš„ï¼Œè€Œæ—¶é—´åˆ™æ˜¯åè¿›åˆ¶æ•°å­—ã€‚è¿™é‡Œè¦ç«‹åˆ»ååº”è¿‡æ¥ï¼Œä¸èƒ½ç”¨é¢˜ç›®å­—ç¬¦ä¸²æ¥è¡¨ç¤ºçŠ¶æ€ï¼Œåº”è¯¥æ¢æˆæ•°å­—æ¥è¡¨ç¤ºã€‚è‡³äºŽï¼Œæœ€å¼€å§‹è¾“å…¥çš„è´¹çŽ‡è¡¨ï¼Œä½¿ç”¨ä¸€ä¸ªæ•´åž‹æ•°ç»„æ¥å­˜å‚¨ï¼Œä½¿ç”¨çš„æ—¶å€™è¿›è¡Œè°ƒç”¨å°±å¥½ã€‚ æŽ¥ä¸‹æ¥ï¼Œéœ€è¦å¯¹è¾“å…¥çš„æ•°æ®è¿›è¡ŒæŽ’åºï¼Œä¼˜å…ˆçº§æœ€å¤§çš„æŽ’åºä¾æ®å°±æ˜¯åç§°ï¼ŒæŒ‰ç…§å­—å…¸åºæ¥æŽ’åˆ—ï¼Œæ³¨æ„å­—ç¬¦ä¸²éœ€è¦ç”¨strcmpå‡½æ•°æ¥è¿›è¡Œæ¯”è¾ƒï¼›å…¶æ¬¡ï¼Œç›¸åŒåç§°çš„å…ƒç´ æŒ‰ç…§æ—¶é—´çš„å…ˆåŽè¿›è¡ŒæŽ’åˆ—å°±å¥½äº†ã€‚ æŽ¥ç€å†æ¥çœ‹è¾“å‡ºï¼Œé¦–å…ˆè¦è¾“å‡ºçš„æ˜¯å®¢æˆ·çš„åç§°å’Œå…¶è¯è´¹è´¦å•æ‰€å¤„çš„æœˆä»½ï¼›ç¬¬äºŒè¡Œå¼€å§‹è¾“å‡ºå®¢æˆ·çš„è¯è´¹è´¦å•çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼Œç„¶åŽè¾“å‡ºå½“å‰è´¦å•çš„æ€»æ—¶é•¿å’Œè´¹ç”¨ï¼Œæ³¨æ„è´¹ç”¨ä¸ºæµ®ç‚¹åž‹ï¼›æ‰€æœ‰è´¦å•éƒ½è¾“å‡ºå®Œæ¯•åŽï¼Œæœ€åŽä¸€è¡Œè¾“å‡ºå®¢æˆ·æ€»è¯è´¹ã€‚ å¤§è‡´æ¸…æ¥šä¹‹åŽï¼Œå¦‚ä½•åŽ»è®¡ç®—è¯è´¹å‘¢ï¼Ÿæ ¹æ®é¢˜ç›®ï¼Œè¾“å…¥çš„æ¯ä¸€é¡¹å¿…é¡»æ˜¯é…å¯¹çš„on-lineå’Œoff-lineæ‰èƒ½ç»„æˆä¸€ä¸ªåˆæ³•çš„è´¦å•ï¼Œå¹¶ä¸”å¿…é¡»è¦æ˜¯è¿žç»­ã€ç›¸é‚»çš„æ‰èƒ½æ˜¯ä¸€å¯¹ï¼ˆè¿™ä¸ªæ¡ä»¶å¾ˆé‡è¦ï¼‰ã€‚è¯»æ‡‚è¿™ä¸ªæ¡ä»¶åŽï¼Œè®¡ç®—æ—¶é—´å°±æ¯”è¾ƒç®€å•äº†ï¼Œè®©å¼€å§‹æ—¶é—´ä¸€ç›´å¢žåŠ åˆ°ç»“æŸæ—¶é—´ï¼Œç»Ÿè®¡å¥½åˆ†é’Ÿæ•°æ—¢å¯å¾—åˆ°ç»åŽ†çš„æ—¶é—´ï¼Œç„¶åŽè®¡ç®—æ€»è´¹ç”¨ã€‚æ³¨æ„ï¼Œç»™å®šçš„è´¹çŽ‡æ˜¯cents/minuteï¼Œæœ€åŽå¾—è½¬åŒ–ä¸ºdollarï¼Œé™¤ä»¥100å³å¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct record&#123; char name[25]; int month, day, hour, minute; bool status;&#125; rec[MAXN], temp;int rate[25] = &#123;0&#125;;bool cmp(record a, record b);void get_time(int on, int off, int &amp;time, int &amp;money);int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; 24; i++) &#123; scanf("%d", rate + i); &#125; int N; scanf("%d", &amp;N); char line[10]; for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d:%d:%d:%d", rec[i].name, &amp;rec[i].month, &amp;rec[i].day, &amp;rec[i].hour, &amp;rec[i].minute); scanf("%s", line); if(!strcmp(line, "on-line")) &#123; rec[i].status = true; &#125; else &#123; rec[i].status = false; &#125; &#125; sort(rec, rec + N, cmp); int on = 0, off, next; while(on &lt; N) &#123; int needPrint = 0; next = on; // fint the next customer, and check the current customer has paired 'on-line' and 'off-line' or not while(next &lt; N &amp;&amp; strcmp(rec[next].name, rec[on].name) == 0) &#123; if(needPrint == 0 &amp;&amp; rec[next].status == true) &#123; needPrint = 1; &#125; else if(needPrint == 1 &amp;&amp; rec[next].status == false) &#123; needPrint = 2; &#125; next++; &#125; //the current customer has not paired 'on-line' and 'off-line', skip this customer if(needPrint &lt; 2) &#123; on = next; continue; &#125; //calculate the money for current customer int Total = 0; printf("%s %02d\n", rec[on].name, rec[on].month); while(on &lt; next) &#123; //find the paired 'on-line' and 'off-line' while(on &lt; next - 1 &amp;&amp; !(rec[on].status == true &amp;&amp; rec[on + 1].status == false)) &#123; on++; &#125; off = on + 1; if(off == next) &#123; on = next; break; &#125; printf("%02d:%02d:%02d ", rec[on].day, rec[on].hour, rec[on].minute); printf("%02d:%02d:%02d ", rec[off].day, rec[off].hour, rec[off].minute); int time = 0, money = 0; get_time(on, off, time, money); Total += money; printf("%d $%.2lf\n", time, money / 100.0); on = off + 1; &#125; printf("Total amount: $%.2lf\n", Total / 100.0); &#125; return 0;&#125;bool cmp(record a, record b) &#123; if(strcmp(a.name, b.name)) return strcmp(a.name, b.name) &lt; 0; else if(a.month != b.month) return a.month &lt; b.month; else if(a.day != b.day) return a.day &lt; b.day; else if(a.hour != b.hour) return a.hour &lt; b.hour; else return a.minute &lt; b.minute;&#125;void get_time(int on, int off, int &amp;time, int &amp;money) &#123; temp = rec[on]; while(temp.day &lt; rec[off].day || temp.hour &lt; rec[off].hour || temp.minute &lt; rec[off].minute) &#123; time++; money += rate[temp.hour]; temp.minute++; if(temp.minute &gt;= 60) &#123; temp.minute = 0; temp.hour++; &#125; if(temp.hour &gt;= 24) &#123; temp.hour = 0; temp.day++; &#125; &#125;&#125; 1018 Public Bike ManagementAnalysisé¢˜ç›®èƒŒæ™¯ç±»ä¼¼çŽ°åœ¨çš„å…±äº«å•è½¦ï¼Œè¿™ç§å…¬å…±è®¾æ–½æœåŠ¡æœ‰ä¸€ä¸ªç®¡ç†ä¸­å¿ƒï¼Œæœ¬é¢˜å«åš Public Bike Management Centerï¼Œç®€ç§° PMBCï¼Œè€Œè¿™ä¸ª PMBC ä¼šè°ƒæ•´æ¯ä¸ªåœé ç«™ç‚¹çš„è‡ªè¡Œè½¦æ•°ç›®ä»Žè€Œè¾¾åˆ°â€œå®Œç¾Žâ€çŠ¶æ€ï¼Œè¿™ç§â€œå®Œç¾Žâ€çŠ¶æ€æ˜¯æŒ‡åœé æ•°é‡ä¸ºè¯¥ç«™ç‚¹æœ€å¤§å®¹é‡çš„ä¸€åŠã€‚ é¢˜ç›®ç»™å®šå„ä¸ªç«™ç‚¹è·ç¦» PMBC çš„è·ç¦»ã€æ¯ä¸ªåœé ç«™ç‚¹å½“å‰çš„åœé æ•°é‡å’Œéœ€è¦æŠ•æ”¾è‡ªè¡Œè½¦çš„ç«™ç‚¹ï¼Œè¦æ±‚è¾“å‡ºå®ŒæˆæŠ•æ”¾å·¥ä½œéœ€è¦æºå¸¦çš„æœ€å°è‡ªè¡Œè½¦æ•°ç›®ã€å®ŒæˆæŠ•æ”¾å·¥ä½œçš„æœ€çŸ­è·¯å¾„å’Œå‰©ä½™å¸¦å›žçš„è½¦æ•°ï¼Œæ³¨æ„è·¯å¾„ä¸­çš„ç«™ç‚¹å¦‚æžœä¸æ˜¯å®Œç¾ŽçŠ¶æ€ï¼Œä¹Ÿéœ€è¦è°ƒæ•´ä¸ºå®Œç¾ŽçŠ¶æ€ã€‚ é¢˜ç›®çš„ç¬¬ä¸€è¦æ±‚æ˜¯æœ€çŸ­è·¯å¾„ï¼Œå€ŸåŠ© Dijkstra ç®—æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå†åˆ©ç”¨åŠ¨æ€æ•°ç»„ä¿å­˜å¥½æ¯ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œç„¶åŽå€ŸåŠ© DFS æ¥è®¡ç®—é¢˜ç›®è¦æ±‚çš„æ‰€æºå¸¦çš„æœ€å°è‡ªè¡Œè½¦æ•°ç›®åŠå‰©ä½™å¸¦å›žçš„è½¦æ•°ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int Cmax, n, m, sp, G[maxv][maxv], weight[maxv];int d[maxv], minneed = inf, minremain = inf;bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path; void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt;= n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt;= n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt;= n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); int need = 0, remain = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; if(weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; if(remain + weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; need += abs(remain + weight[id]); remain = 0; &#125; &#125; &#125; if(need &lt; minneed) &#123; minneed = need; minremain = remain; path = tempath; &#125; else if(need == minneed &amp;&amp; remain &lt; minremain) &#123; minremain = remain; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; Cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] -= Cmax / 2; //preprocessing: make it 'perfect' &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); dfs(sp); cout &lt;&lt; minneed &lt;&lt; ' '; for(int i = path.size() - 1; i &gt;=0; i--) &#123; cout &lt;&lt; path[i]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; ' ' &lt;&lt; minremain; return 0;&#125; 1019 General Palindromic NumberAnalysisæ­¤é¢˜å±žäºŽç»“åˆäº†è¿›åˆ¶è½¬æ¢å’Œå›žæ–‡åºåˆ—åˆ¤æ–­çš„æ··åˆé¢˜ç›®ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;bool PalindromicNum(long long *digits, long long count);int main(int argc, char const *argv[]) &#123; long long N, b, count = 0, digits[50] = &#123;0&#125;; scanf("%lld %lld", &amp;N, &amp;b); while(N) &#123; digits[count++] = N % b; N /= b; &#125; count--; if(PalindromicNum(digits, count)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(; count &gt; 0; count--) &#123; printf("%lld ", digits[count]); &#125; printf("%lld\n", digits[count]); return 0;&#125;bool PalindromicNum(long long *digits, long long count) &#123; bool flag = true; int i, j; if(count % 2 == 0) &#123; i = j = count / 2; &#125; else &#123; i = count / 2; j = i + 1; &#125; for(; i &gt;= 0 &amp;&amp; j &lt;= count; i--, j++) &#123; if(digits[i] != digits[j]) &#123; flag = false; break; &#125; &#125; return flag;&#125; è´´ä¸ª C++ ç‰ˆï¼Œç®€åŒ–äº†ä¸€ä¸‹å›žæ–‡çš„åˆ¤æ–­è¿‡ç¨‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; if(n == 0) &#123; cout &lt;&lt; "Yes\n" &lt;&lt; 0; &#125; else &#123; vector&lt;int&gt; digits; while(n) &#123; digits.push_back(n % k); n /= k; &#125; int size = digits.size(); bool flag = true; for(int i = 0; i &lt; size / 2; i++) &#123; if(digits[i] != digits[size - i - 1]) &#123; flag = false; break; &#125; &#125; if(flag) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; for(int i = size - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; digits[i]; if(i &gt; 0) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; 1020 Tree TraversalsAnalysisé¢˜ç›®å¤§æ„ï¼Œç»™å®šä¸¤ä¸ªæ ‘çš„ä¸­åºéåŽ†å’ŒåŽåºéåŽ†ï¼Œæ±‚å…¶å±‚æ¬¡éåŽ†ã€‚ æ­¤é¢˜å±žäºŽæ ‘çš„å¸¸è§„é¢˜åž‹ï¼Œæ€è·¯æ˜¯åˆ©ç”¨ä¸­åºéåŽ†å’ŒåŽåºéåŽ†å»ºæ ‘ï¼Œç„¶åŽå†å€ŸåŠ© BFS è¿›è¡Œå±‚æ¬¡éåŽ†ï¼Œå¹¶è¾“å‡ºå±‚æ¬¡éåŽ†åºåˆ—ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50;struct node &#123; int data; node *lchild; node *rchild;&#125;;int pre[maxn], in[maxn], post[maxn];int n;node *create(int postL, int postR, int inL, int inR) &#123; if(postL &gt; postR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = post[postR]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == post[postR]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(postL, postL + numLeft - 1, inL, k - 1); root-&gt;rchild = create(postL + numLeft, postR - 1, k + 1, inR); return root;&#125;int num = 0;void BFS(node *root) &#123; queue&lt;node*&gt; q; q.push(root); while(!q.empty()) &#123; node *now = q.front(); q.pop(); printf("%d", now-&gt;data); num++; if(num &lt; n) printf(" "); if(now-&gt;lchild != NULL) q.push(now-&gt;lchild); if(now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node *root = create(0, n - 1, 0, n - 1); BFS(root); return 0;&#125; 1022 Digital LibraryAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯æ•°å­—å›¾ä¹¦é¦†çš„æ£€ç´¢åŠŸèƒ½ï¼Œè¦æ±‚å¤§è‡´æ¨¡æ‹Ÿä¸€ä¸‹è¿™ä¸ªåŠŸèƒ½ã€‚ æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œè¾“å‡ºä¹¦åæ—¶ï¼Œéœ€è¦æŒ‰åºè¾“å‡ºï¼Œæ¯”èµ·æž„é€ æ–°çš„æ•°æ®ç»“æž„åŽä½¿ç”¨sortå‡½æ•°æ¥å®Œæˆè¿™é¡¹æ“ä½œï¼Œä¸å¦‚ç›´æŽ¥å€ŸåŠ©setã€‚è€Œåœ¨æŸ¥è¯¢æ—¶ï¼Œæ˜¯é€šè¿‡å­—ç¬¦ä¸²æ¥è¿›è¡Œçš„æŸ¥è¯¢ï¼Œä½¿ç”¨mapå»ºç«‹æ˜ å°„åŽï¼Œå°±å¯ä»¥ç±»ä¼¼æ•£åˆ—ä¸€æ ·è¿›è¡ŒæŸ¥è¯¢ã€‚ ç»¼åˆä¸Šè¿°çš„ä¸¤ç§éœ€æ±‚åŽï¼Œå¥½åœ¨mapæ˜¯æ”¯æŒstringå‘setçš„æ˜ å°„çš„ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨å³å¯ã€‚ ç”±äºŽå…³é”®å­—keyæ˜¯ä¸€ä¸ªä¸€ä¸ªç»™å‡ºçš„ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªä¸€ä¸ªè¾“å…¥å¹¶ç»Ÿè®¡ï¼Œä¾æ®cinæˆ–scanfè¾“å…¥å­—ç¬¦ä¸²çš„ç‰¹æ€§ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å•ä¸ªè¯»å…¥ï¼Œå¹¶ä½¿ç”¨getcharè¯»å–å›žè½¦ç¬¦ç»“æŸå¾ªçŽ¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; mpTitle, mpAuthor, mpKey, mpPub, mpYear;void query(map&lt;string, set&lt;int&gt; &gt; &amp;mp, string &amp;str) &#123; if(mp.find(str) == mp.end()) printf("Not Found\n"); else &#123; for(set&lt;int&gt;::iterator it = mp[str].begin(); it != mp[str].end(); it++) &#123; printf("%07d\n", *it); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, m, id, type; string title, author, key, pub, year; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;id); char c = getchar(); getline(cin, title); mpTitle[title].insert(id); getline(cin, author); mpAuthor[author].insert(id); while(cin &gt;&gt; key) &#123; mpKey[key].insert(id); c = getchar(); if(c == '\n') break; &#125; getline(cin, pub); mpPub[pub].insert(id); getline(cin, year); mpYear[year].insert(id); &#125; string temp; cin &gt;&gt; m; while(m--) &#123; scanf("%d: ", &amp;type); getline(cin, temp); cout &lt;&lt; type &lt;&lt; ": " &lt;&lt; temp &lt;&lt; endl; if(type == 1) query(mpTitle, temp); else if(type == 2) query(mpAuthor, temp); else if(type == 3) query(mpKey, temp); else if(type == 4) query(mpPub, temp); else query(mpYear, temp); &#125; return 0;&#125; æŸ¥è¯¢å‡½æ•°å¯ä»¥å†™çš„ç®€å•ç‚¹ï¼š12345678void query(map&lt;string, set&lt;int&gt;&gt;&amp; mp, string &amp;tmp) &#123; if(!mp.count(tmp)) printf("Not Found\n"); else &#123; for(auto &amp;i: mp[tmp]) &#123; printf("%07d\n", i); &#125; &#125;&#125; è¿™ä¸ªé¢˜çš„éš¾ç‚¹ä¸åœ¨ç®—æ³•çš„è®¾è®¡ä¸Šï¼Œè€Œæ˜¯åœ¨å¯¹æ•°æ®çš„å¤„ç†ä¸Šã€‚ä¸ºäº†èƒ½æ›´ç®€å•çš„å®Œæˆè¿™ä¸ªäº‹æƒ…ï¼Œå°±éœ€è¦å¯¹ STL å®¹å™¨ã€è¾“å…¥è¾“å‡ºå‡½æ•°åŠå…¶ä»– API çš„ç”¨æ³•å¾ˆç†Ÿæ‚‰ã€‚ 1023 Have Fun with NumbersAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™ä¸€ä¸ªä¸è¶…è¿‡20ä½çš„æ•´æ•°ï¼Œå°†è¿™ä¸ªæ•´æ•°ç¿»å€åŽï¼Œåˆ¤æ–­ç»„æˆè¿™ä¸ªæ–°æ•´æ•°çš„æ‰€æœ‰æ•°å­—æ˜¯å¦ä¸ŽåŽŸæ¥çš„æ•°å­—ç›¸åŒã€‚è‹¥æ˜¯ï¼Œè¾“å‡ºYesï¼›åä¹‹ï¼Œè¾“å‡ºNoã€‚æ³¨æ„ï¼Œæ— è®ºæ˜¯å¦ç¬¦åˆéƒ½éœ€è¦è¾“å‡ºç¿»å€åŽçš„æ–°æ•°å­—ã€‚ ç”±äºŽé¢˜ç›®æ˜Žç¡®è¯´äº†ç»™å®šçš„æ•°å­—ä½æ•°ä¸è¶…è¿‡20ä½ï¼Œä½†æ˜¯long longåªèƒ½åˆ°19ä½ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•°ç»„æ¥å­˜å‚¨æ•°å­—ï¼Œç„¶åŽåˆ©ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿä¹˜ä»¥2ã€‚ ç„¶åŽåˆ¤æ–­ä¸¤ä¸ªæ•°å­—çš„æ‰€æœ‰ä½æ•°å­—çš„å‡ºçŽ°æ¬¡æ•°æ˜¯å¦ä¸€è‡´å³å¯ï¼ˆåˆ©ç”¨æ•£åˆ—çš„æ€æƒ³ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼‰ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int Compare(int *original, int *now, int number);int main(int argc, char const *argv[]) &#123; char Num[22]; int original[22], now[22], original_occurrence[10] = &#123;0&#125;, now_occurrence[10] = &#123;0&#125;; scanf("%s", Num); char *p = Num; int i = 0, j, k, temp = 0, flag = 0; //conver the string to an array(int) while(*p != '\0') &#123; original[i++] = *p++ - '0'; &#125; //count the occurrence of the original number for(j = 0; j &lt; i; j++) &#123; original_occurrence[original[j]]++; &#125; //imitate multiplication for(k = 0, j = i - 1; j &gt;= 0; j--, k++) &#123; now[k] = (original[j] * 2 + temp) % 10; temp = original[j] * 2 / 10; &#125; if(temp) &#123; now[k] = temp; &#125; else &#123; k -= 1; &#125; //count the new number for(j = 0; j &lt;= k; j++) &#123; now_occurrence[now[j]]++; &#125; flag = Compare(original_occurrence, now_occurrence, 10); //print if(flag) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(j = k; j &gt; 0; j--) &#123; printf("%d", now[j]); &#125; printf("%d\n", now[j]); return 0;&#125;int Compare(int *original, int *now, int number) &#123; int i, j, ret = 1; for(i = 0; i &lt; number; i++) &#123; if(original[i] != now[i]) &#123; ret = 0; break; &#125; &#125; return ret;&#125; è´´ä¸ª C++ ç‰ˆï¼š1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; string num; cin &gt;&gt; num; vector&lt;int&gt; n, dn; for(int i = num.size() - 1; i &gt;= 0; i--) &#123; n.push_back(num[i] - '0'); &#125; int carry = 0; for(int i = 0; i &lt; n.size(); i++) &#123; dn.push_back((2 * n[i] + carry) % 10); carry = 2 * n[i] / 10; &#125; if(carry &gt; 0) dn.push_back(carry); string ans; for(int i = dn.size() - 1; i &gt;= 0; i--) &#123; ans.push_back(dn[i] + '0'); &#125; sort(n.begin(), n.end()); sort(dn.begin(), dn.end()); if(n == dn) cout &lt;&lt; "Yes" &lt;&lt; endl; else cout &lt;&lt; "No" &lt;&lt; endl; cout &lt;&lt; ans; return 0;&#125; æœ¬æ¥è¿˜æƒ³æ›´å·æ‡’ç”¨long doubleç›´æŽ¥ç®—çš„ï¼Œä½†æ˜¯åœ¨å­˜ 20 ä½æ•°æ—¶ï¼Œlong doubleè¿™ä¸ªæ•°æ®ç±»åž‹å·²ç»å¼€å§‹æœ‰è¯¯å·®äº†ï¼Œæ‰€ä»¥æœ€åŽä¸€ä¸ªæµ‹è¯•ç‚¹è¿‡ä¸åŽ»ï¼Œå¯æƒœäº†ã€‚æŒ‰ç†è¯´ï¼Œlong doubleèƒ½å­˜ç›¸å½“å¤§çš„æ•°äº†ï¼Œä¸åº”è¯¥æ‰ 20 ä½å°±å¼€å§‹å‡ºçŽ°è¯¯å·®å•Šï¼Ÿ 1024 Palindromic NumberAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•°å­—ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå›žæ–‡æ•°å­—ï¼Œå¹¶è¿›è¡Œä¸€ç³»åˆ—æ“ä½œã€‚å¦å¤–ï¼Œç»™å®šä¸€ä¸ªä¸Šé™æ¬¡æ•°ï¼Œå½“ç»™å®šçš„æ•°ä¸æ˜¯å›žæ–‡æ•°å­—æ—¶ï¼Œä»¤å…¶åŠ ä¸Šå°†å…¶é€†ç½®åŽçš„æ•°å­—ï¼Œåœ¨è¿›è¡Œåˆ¤æ–­æ˜¯å¦ä¸ºä¼šé—®æ•°å­—ï¼Œè‹¥æ˜¯ï¼Œåˆ™è¾“å‡ºè¿™ä¸ªæ•°å­—å’Œå˜æ¢æ¬¡æ•°ï¼Œåä¹‹ï¼Œåˆ™ç»§ç»­ç›´è‡³è¶…è¿‡ä¸Šé™æ¬¡æ•°ã€‚æ³¨æ„ï¼Œå³ä¾¿è¶…è¿‡äº†ä¸Šé™æ¬¡æ•°ï¼Œä¾ç„¶è¦å˜æ¢è¿‡ç¨‹ä¸­æœ€åŽçš„æ•°å­—ã€‚ è§£å†³æ­¤é¢˜éœ€è¦è§£å†³ä¸‹é¢3ä¸ªå­é—®é¢˜ï¼š å›žæ–‡æ•°å­—çš„åˆ¤å®š æ•°å­—é€†ç½® æ•°å­—ç›¸åŠ  é¢˜ç›®è¦æ±‚æ•°å­—çš„èŒƒå›´ä¸è¶…è¿‡$10^{10}$ï¼Œå¯ä»¥ä½¿ç”¨long longï¼Œä½†è¿™ä¼šä½¿å¾—å°†æ•°å­—é€†ç½®çš„è¿™ä¸ªæ­¥éª¤éžå¸¸éº»çƒ¦ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•°ç»„æ¥å­˜å‚¨æ•°å­—ï¼Œå¹¶æ¨¡æ‹Ÿæ•°å­—ä¹‹é—´çš„åŠ æ³•ã€‚å¦å¤–è¿™æ ·è¿˜æœ‰ä¸€ä¸ªå¥½å¤„ï¼Œå°±æ˜¯åœ¨åˆ¤æ–­æ˜¯å¦æ˜¯å›žæ–‡æ•°å­—æ—¶ï¼Œå¯ä»¥ç›´æŽ¥å¯¹æ•°ç»„è¿›è¡Œåˆ¤æ–­ã€‚ä½¿ç”¨long longä¼šæº¢å‡ºï¼Œç›´æŽ¥ç”¨å­—ç¬¦ä¸²å°±å¥½ï¼Œåˆ«æƒ³ç€å·é¸¡äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign &#123; int d[200], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign reversebign(bign a) &#123; int temp; for(int i = 0; i &lt; a.len / 2; i++) &#123; temp = a.d[i]; a.d[i] = a.d[a.len - i - 1]; a.d[a.len - i - 1] = temp; &#125; return a;&#125;bign add(bign a, bign b) &#123; bign c; int carry = 0; for(int i = 0; i &lt; a.len || i &lt; b.len; i++) &#123; int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10; carry = temp / 10; &#125; if(carry != 0) &#123; c.d[c.len++] = carry; &#125; return c;&#125;bool isPalindromic(bign a) &#123; for(int i = 0; i &lt;= a.len / 2; i++) &#123; if(a.d[i] != a.d[a.len - 1 - i]) return false; &#125; return true;&#125;void print(bign a) &#123; for(int i = a.len - 1; i &gt;= 0; i--) &#123; printf("%d", a.d[i]); &#125; putchar('\n');&#125;int main(int argc, char const *argv[]) &#123; char str[150]; int times, count = 0; scanf("%s %d", str, &amp;times); bign a = change(str), rev; while(times--) &#123; if(isPalindromic(a)) &#123; break; &#125; else &#123; rev = reversebign(a); a = add(a, rev); count++; &#125; &#125; print(a); printf("%d", count); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;bool ispalindromic(string &amp;num) &#123; int left = 0, right = num.length() - 1; while(left &lt; right) &#123; if(num[left] != num[right]) return false; left++, right--; &#125; return true;&#125;int main() &#123; int k; string num, tmp; cin &gt;&gt; num &gt;&gt; k; int i; reverse(num.begin(), num.end()); for(i = 0; i &lt; k; i++) &#123; if(ispalindromic(num)) break; tmp = num; reverse(tmp.begin(), tmp.end()); int carry = 0; for(int i = 0; i &lt; num.length(); i++) &#123; int t = (num[i] + tmp[i] + carry - 2 * '0'); num[i] = t % 10 + '0'; carry = t / 10; &#125; if(carry) num.push_back(carry + '0'); &#125; reverse(num.begin(), num.end()); cout &lt;&lt; num &lt;&lt; endl; cout &lt;&lt; (i == k ? k : i); return 0;&#125; 1025 PTA RankingAnalysisæ­¤é¢˜è€ƒå¯ŸæŽ’åºï¼Œç›´æŽ¥è°ƒç”¨åº“é‡Œçš„æŽ’åºå‡½æ•°æ¥å¸®åŠ©å®ŒæˆæŽ’åºå°±å¥½äº†ã€‚æ³¨æ„ï¼š ä¸€ä¸ªåœ°ç‚¹å†…çš„æ‰€æœ‰æ•°æ®è¾“å…¥å®Œäº†ä¹‹åŽï¼Œæœ¬åœ°æŽ’åå°±å¯ä»¥å®Œæˆäº† æ¯ä¸ªæ•°æ®åœ¨åœ¨è¾“å…¥çš„æ—¶å€™å°±å¯ä»¥é¡ºä¾¿å¯¹å…¶è¿›è¡Œåœ°ç‚¹ç¼–å· æœ€ç»ˆæŽ’åå¿…é¡»è¦åœ¨æœ¬åœ°æŽ’åä¹‹åŽæ‰èƒ½è¿›è¡Œ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char id[15]; int score; int location_number; int local_rank;&#125; stu[30010];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, K, num = 0; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;K); for(int j = 0; j &lt; K; j++) &#123; scanf("%s %d", stu[num].id, &amp;stu[num].score); stu[num].location_number = i; num++; &#125; sort(stu + num - K, stu + num, cmp); stu[num - K].local_rank = 1; //get local rank for(int j = num - K + 1; j &lt; num; j++) &#123; if(stu[j].score == stu[j - 1].score) &#123; stu[j].local_rank = stu[j - 1].local_rank; &#125; else &#123; stu[j].local_rank = j + 1 - (num - K); &#125; &#125; &#125; printf("%d\n", num); sort(stu, stu + num, cmp); //get final rank int r = 1; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].score != stu[i - 1].score) &#123; r = i + 1; &#125; printf("%s ", stu[i].id); printf("%d %d %d\n", r, stu[i].location_number, stu[i].local_rank); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.id, b.id) &lt; 0;&#125; 1027 Colors in MarsAnalysisè€ƒå¯Ÿè¿›åˆ¶è½¬æ¢çš„é¢˜ç›®ï¼Œ10è¿›åˆ¶è½¬æ¢ä¸º13è¿›åˆ¶ï¼Œä¸Žè½¬æ¢10è¿›åˆ¶è½¬æ¢ä¸º16è¿›åˆ¶æ˜¯ç±»ä¼¼çš„ï¼Œä»£ç å¯èƒ½å†™çš„ä¸å¤ªå¥½çœ‹ï¼Œå˜¿å˜¿~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;char Change(int number);int Transfer(char *dst, int number, int dex);int main(int argc, char const *argv[]) &#123; int R, G, B, index = 1; scanf("%d %d %d", &amp;R, &amp;G, &amp;B); char color[10] = "#00000000"; index = Transfer(color, R, index); index = Transfer(color, G, index); index = Transfer(color, B, index); color[index] = '\0'; puts(color); return 0;&#125;int Transfer(char *dst, int number, int index) &#123; int mask = 1, temp = number; while(temp &gt; 12) &#123; temp /= 13; mask *= 13; &#125; temp = number; if(mask &gt; 1) &#123; while(mask) &#123; dst[index++] = Change(temp / mask); temp %= mask; mask /= 13; &#125; &#125; else &#123; index++; dst[index++] = Change(temp); &#125; return index;&#125;char Change(int number) &#123; char ret; if(0 &lt;= number &amp;&amp; number &lt;= 9) &#123; ret = number + '0'; &#125; else &#123; ret = number - 10 + 'A'; &#125; return ret;&#125; è´´ä¸ª C++ ç›´æŽ¥ç”¨ map æ‰“è¡¨çš„æ–¹æ³•ï¼š1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;map&lt;int, string&gt; marscolors;char num2char(int num) &#123; char ret = '0'; if(0 &lt;= num &amp;&amp; num &lt;= 9) ret += num; else ret = 'A' + num - 10; return ret;&#125;int main() &#123; marscolors[0] = "00"; for(int i = 1; i &lt; 169; i++) &#123; int tmp = i; string s; while(tmp) &#123; s += num2char(tmp % 13); tmp /= 13; &#125; if(i &lt; 13) s += "0"; reverse(s.begin(), s.end()); marscolors[i] = s; &#125; int red, green, blue; cin &gt;&gt; red &gt;&gt; green &gt;&gt; blue; cout &lt;&lt; "#" &lt;&lt; marscolors[red] &lt;&lt; marscolors[green] &lt;&lt; marscolors[blue]; return 0;&#125; 1028 List SortingAnalysisè€ƒå¯ŸæŽ’åºï¼Œç”¨è¾“å…¥çš„æ•°å­—è¡¨ç¤ºä»¥å…ƒç´ çš„æŸä¸€é¡¹è¿›è¡ŒæŽ’åºï¼Œç›´æŽ¥æŠŠç±»åˆ«æ•°å­—ç”¨å…¨å±€å˜é‡ä»£æ›¿ï¼Œç„¶åŽåœ¨cmpå‡½æ•°ä¸­ç›´æŽ¥ä½¿ç”¨å³å¯ï¼Œæ³¨æ„å­—ç¬¦ä¸²éœ€è¦ç”¨strcmpå‡½æ•°è¿›è¡Œæ¯”è¾ƒã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char id[10], name[15]; int grade;&#125; stu[MAXN];int N, C;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;C); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].id, stu[i].name, &amp;stu[i].grade); &#125; sort(stu, stu + N, cmp); for(int i = 0; i &lt; N; i++) &#123; printf("%s %s %d\n", stu[i].id, stu[i].name, stu[i].grade); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(C == 1) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; else if(C == 2) &#123; int temp = strcmp(a.name, b.name); if(temp != 0) return temp &lt; 0; else return strcmp(a.id, b.id) &lt; 0; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return strcmp(a.id, b.id) &lt; 0; &#125;&#125; è´´ä¸ª C++ ç‰ˆï¼š12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string id, name; int grade;&#125; stu[maxn];bool cmp1(student a, student b) &#123; if(a.name != b.name) return a.name &lt; b.name; else return a.id &lt; b.id;&#125;int n, c;bool cmp(student a, student b) &#123; if(c == 1) return a.id &lt; b.id; else if(c ==2) &#123; if(a.name != b.name) return a.name &lt; b.name; else return a.id &lt; b.id; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return a.id &lt; b.id; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; c; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].id &gt;&gt; stu[i].name &gt;&gt; stu[i].grade; &#125; sort(stu, stu + n, cmp); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; stu[i].id &lt;&lt; ' ' &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].grade &lt;&lt; endl; &#125; return 0;&#125; 1029 MedianAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸¤ä¸ªé€’å¢žåºåˆ—ï¼Œæ±‚è¿™ä¸¤ä¸ªåºåˆ—åˆå¹¶åŽçš„ä¸­ä½æ•°ã€‚ æ˜Žç¡®äº†ä»€ä¹ˆæ˜¯ä¸­ä½æ•°ä¹‹åŽï¼Œè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•å°±æœ‰å¾ˆå¤šäº†ã€‚è¶…çº§æ— è„‘çš„åšæ³•å°±æ˜¯ç›´æŽ¥æŠŠå…¶ä¸­ä¸€ä¸ªåºåˆ—æ‹¼æŽ¥åœ¨å¦å¤–ä¸€ä¸ªåºåˆ—åŽé¢ï¼ŒæŽ’ä¸ªåºï¼Œç„¶åŽç›´æŽ¥è¾“å‡ºå…¶ä¸­ä½æ•°å°±å¥½äº†ã€‚ä½†æ˜¯æ³¨æ„åˆ°é¢˜ç›®çš„Memory Limit: 1.5 MBï¼Œè¯´æ˜Žé¢˜ç›®å¯¹å†…å­˜æœ‰è¦æ±‚ï¼Œç®€å•ç›´æŽ¥çš„åšæ³•å¯èƒ½å¯¼è‡´Memory Limit Exceededçš„é”™è¯¯ã€‚ é‚£ä¹ˆå°±éœ€è¦æƒ³åŠžæ³•ä¼˜åŒ–ç©ºé—´äº†ï¼Œé¢˜ç›®ç»™å®šçš„ä¸¤ä¸ªåºåˆ—ï¼ŒæŒ‰ç…§ä¸Šè¿°çš„æ€è·¯ï¼Œå°±éœ€è¦ä¸‰ä¸ªæ•°ç»„ï¼ˆä¸¤ä¸ªå­˜ç»™å®šçš„ï¼Œä¸€ä¸ªå­˜åˆå¹¶åŽçš„ï¼‰ï¼Œèƒ½ä¸èƒ½å°‘ç”¨ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œå…¶å®žå¯ä»¥ä¸ç”¨å®Œå…¨åˆå¹¶ï¼Œè€Œåªéœ€è¦æ¨¡æ‹Ÿè¿™ä¸ªåˆå¹¶æ“ä½œçš„è¿‡ç¨‹ï¼Œå¹¶åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼ŒæŒ‰ç…§é¡ºåºæ¥ç»Ÿè®¡æ˜¯å¦æžšä¸¾åˆ°äº†é‚£ä¸ªä¸­ä½æ•°ï¼ˆæ ¹æ®æ•°ç»„ä¸‹æ ‡çš„åˆå§‹å€¼ï¼Œä¸­ä½æ•°çš„ä½ç½®æ˜¯å¯ä»¥ç›´æŽ¥ç®—å‡ºæ¥çš„ï¼‰å³å¯ã€‚ ä¸è¿‡ï¼Œå¾ˆå¯æƒœï¼Œé“é«˜ä¸€å°ºé­”é«˜ä¸€ä¸ˆï¼Œè¿™ä¸ªé¢˜æ›´æ–°ï¼ˆ2018å¹´3æœˆä¹‹åŽï¼Ÿï¼‰äº†æµ‹è¯•æ ·ä¾‹ï¼Œæœ€åŽä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹è¿˜æ˜¯æ— æ³•é€šè¿‡ï¼Œå¹¶ä¸”è¿˜æ˜¯MLEçš„é”™è¯¯ã€‚ è¿™å°±å¾—é åœ¨çº¿å¤„ç†äº†ï¼Œåœ¨è¯»å…¥ç¬¬äºŒä¸ªåºåˆ—æ—¶ï¼Œå°†æ¯æ¬¡è¯»å…¥çš„æ•°å­—å­˜åœ¨ä¸€ä¸ªå˜é‡å†…ï¼Œæ¯æ¬¡éœ€è¦ç»Ÿè®¡ç¬¬ä¸€ä¸ªåºåˆ—ä¸­æœ‰å¤šå°‘æ•°å­—å°äºŽå®ƒï¼Œç„¶åŽæ ¹æ®è¿™ä¸€ç‚¹æ¥è®¡ç®—å‡ºè¿™ä¸ªæ•°å­—åœ¨åˆå¹¶åŽçš„åºåˆ—ä¸­æ‰€å¤„çš„ä½ç½®ï¼Œå¹¶ä¸Žä¸­ä½æ•°çš„ä½ç½®è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åŽæ¥å†³å®šæ˜¯å¦è¾“å‡ºã€‚åœ¨è¯»å…¥ç¬¬äºŒä¸ªåºåˆ—çš„è¿‡ç¨‹ä¸­å­˜åœ¨ä¸¤ç§æƒ…å†µï¼š æ•°å­—å­˜åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…ï¼Œå¹¶ä¸”æ­¤æ—¶å¯ä»¥ç¡®å®šä¸­ä½æ•°å¿…å®šæ¯”å½“å‰è¯»å…¥çš„æ•°å­—å° æ•°å­—å­˜åœ¨ç¬¬äºŒä¸ªåºåˆ—å†…ï¼Œå°±æ˜¯å½“å‰è¯»å…¥çš„æ•°å­— é’ˆå¯¹ä¸Šè¿°ä¸¤ç§æƒ…å†µï¼Œç»Ÿè®¡åˆ°ä¸­ä½æ•°åŽç›´æŽ¥è¾“å‡ºå³å¯ï¼Œä½†æ˜¯è¦æ³¨æ„ï¼Œè‹¥æ˜¯ç¬¬äºŒä¸ªåºåˆ—çš„æ•°å­—æ¯”ç¬¬ä¸€ä¸ªåºåˆ—å°‘å¾ˆå¤šï¼ˆæˆ–è€…å°å¾ˆå¤šç­‰æžç«¯æƒ…å†µï¼‰ï¼Œé‚£ä¹ˆä¸­ä½æ•°ä¾ç„¶è¿˜æ˜¯åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…æ‰¾ã€‚ Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 200000 + 10;int seq[MAXN];int main(int argc, char const *argv[]) &#123; int n1, n2, temp, count = 0; scanf("%d", &amp;n1); for(int i = 1; i &lt;= n1; i++) &#123; scanf("%d", &amp;seq[i]); &#125; seq[n1 + 1] = 0x7fffffff; scanf("%d", &amp;n2); int median = (n1 + n2 + 1) / 2, i = 1; for(int j = 1; j &lt;= n2; j++) &#123; scanf("%d", &amp;temp); while(seq[i] &lt; temp) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; count++; if(count == median) printf("%d", temp); &#125; while(i &lt;= n1) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; return 0;&#125; çŽ°åœ¨è¿™ä¸ªé¢˜çš„å†…å­˜é™åˆ¶å·²ç»æ”¹æˆ64 MBäº†ï¼Œå¯ä»¥ç›´æŽ¥æŽ’åºäº†ðŸ˜‚ï¼š1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;int&gt; arr; int n, tmp; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; arr.push_back(tmp); &#125; sort(arr.begin(), arr.end()); int pos = arr.size() % 2 == 1 ? arr.size() / 2 : arr.size() / 2 - 1; cout &lt;&lt; arr[pos]; return 0;&#125; 1030 Travel PlanAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ—…æ¸¸åœ°å›¾ï¼Œæ¯ä¸ªç»“ç‚¹ä¹‹é—´çš„è¾¹ï¼ŒåŒ…å«ä¸¤ä¸ªå±žæ€§å€¼ï¼šè·ç¦»å’ŒèŠ±é”€ã€‚ç„¶åŽï¼Œç»™å®šèµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¦æ±‚è¾“å‡ºäºŒè€…ä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„æ€»è·ç¦»å’Œå¯¹åº”çš„èŠ±é”€ï¼Œè‹¥å­˜åœ¨ç›¸åŒæ€»è·ç¦»çš„æœ€çŸ­è·¯å¾„ï¼Œæ­¤æ—¶éœ€è¾“å‡ºæœ€å°çš„èŠ±é”€å€¼ã€‚ ç”±äºŽé¢˜ç›®å·²ç»è¯´æ˜Žè¾“å…¥æ•°æ®ä¸å­˜åœ¨è´Ÿæ•°ï¼Œä¸”åªæœ‰ä¸€ä¸ªèµ·ç‚¹ï¼Œé—®é¢˜å°±å˜æˆäº†ä¸å­˜åœ¨è´ŸçŽ¯çš„å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚æ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨ Dijkstra ç®—æ³•è¿›è¡Œæ±‚è§£ã€‚ç”±äºŽéœ€è¦è¾“å‡ºå¯¹åº”çš„æœ€çŸ­è·¯å¾„ï¼Œæ‰€ä»¥å¯ä»¥åœ¨ Dijkstra ç®—æ³•æ±‚è§£æœ€çŸ­è·¯å¾„çš„è¿‡ç¨‹ä¸­ï¼Œé¡ºä¾¿åˆ©ç”¨ä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜æœ€ä¼˜è·¯å¾„ï¼Œä¹‹åŽå†åˆ©ç”¨ DFS æ¥æ­£åºè¾“å‡ºè·¯å¾„ï¼›å½“ç„¶ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨åŠ¨æ€æ•°ç»„ä¿å­˜æ‰€æœ‰çš„è·¯å¾„ï¼Œä¹‹åŽå†åˆ©ç”¨ DFS éåŽ†æ¯æ¡è·¯å¾„ï¼Œæ¥æ±‚è§£èŠ±é”€å€¼æœ€å°çš„è·¯å¾„ã€‚ CodeDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, s, t, G[maxv][maxv], cost[maxv][maxv];int d[maxv], c[maxv], pre[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, inf); // do not forget initialize the distance array for(int i = 0; i &lt; n; i++) pre[i] = i; d[s] = 0; c[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; pre[v] = u; // save the precursor &#125; else if(d[u] + G[u][v] == d[v]) &#123; if(c[u] + cost[u][v] &lt; c[v]) &#123; // more optimized result c[v] = c[u] + cost[u][v]; pre[v] = u; &#125; &#125; &#125; &#125; &#125;&#125; void dfs(int v) &#123; if(v == s) &#123; cout &lt;&lt; v &lt;&lt; ' '; return; &#125; dfs(pre[v]); cout &lt;&lt; v &lt;&lt; ' ';&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(s); dfs(t); cout &lt;&lt; d[t] &lt;&lt; ' ' &lt;&lt; c[t]; return 0;&#125; Dijkstra + DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, G[maxv][maxv], cost[maxv][maxv];int d[maxv], mincost = inf; // mincost need to be initialized to 'inf' bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); // do not forget clear pre[v].push_back(u); &#125; else if(d[u] + G[u][v] == d[v]) &#123; pre[v].push_back(u); // save other shortest path &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == st) &#123; tempath.push_back(v); int tempcost = 0; for(int i = tempath.size() - 1; i &gt; 0; i--) &#123; int id = tempath[i], idNext = tempath[i - 1]; tempcost += cost[id][idNext]; &#125; if(tempcost &lt; mincost) &#123; path = tempath; mincost = tempcost; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(st); dfs(ed); for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; path[i] &lt;&lt; ' '; &#125; cout &lt;&lt; d[ed] &lt;&lt; ' ' &lt;&lt; mincost; return 0;&#125; 1031 Hello World For UAnalysisè¿™é“é¢˜å±žäºŽæ‰“å°å›¾å½¢ç±»çš„é¢˜ç›®ï¼Œé¢˜çœ¼å¤§æ¦‚å°±æ˜¯æ‰¾åˆ°å›¾å½¢è¾“å‡ºçš„è§„å¾‹äº†ï¼Œæ‰€ä»¥è¯»é¢˜å¾—ä»”ç»†ä¸€ç‚¹ã€‚ä¸è¿‡ï¼Œå¾ˆå·§åœ°æ˜¯ï¼Œè¿™é“é¢˜ç›®ï¼Œç”¨æ¥æ‰¾è§„å¾‹çš„é‚£ä¸ªæ¡ä»¶ä¸æ˜¯å¾ˆæ˜Žæ˜¾ï¼Œå¯èƒ½è¿˜ä¸å¤ªå®¹æ˜“çœ‹æ‡‚ï¼ˆå¯èƒ½æˆ‘è‹±è¯­æ¸£~ï¼‰ï¼Œå°±æ˜¯è¿™ä¸ªæ¡ä»¶$n_1 = n_3 = max \lbrace{k | k \le n_2\ for\ all\ 3 \le n_2 \le N}\rbrace \ with \ n_1 + n_2 + n3 - 2 = N$äº†ã€‚æ„æ€å¤§è‡´æ˜¯ï¼š$n_1 = n_3 \le k$ï¼Œè€Œ$k$è¿™ä¸ªæ•°æ˜¯å¾—ä¸¥æ ¼å°äºŽç­‰äºŽ$n_2$ï¼Œè€Œ$n_2$çš„å–å€¼èŒƒå›´ä¸ºï¼š$[3, N]$ï¼Œå¦å¤–è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶$n_1 + n_2 + n_3 - 2 = N$ã€‚ å¦å¤–ï¼Œ$n_1$æ˜¯æŒ‡æœ€å·¦è¾¹ä¸€åˆ—â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$n_2$æ˜¯æŒ‡åº•éƒ¨â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$n_3$æ˜¯æŒ‡æœ€å³è¾¹ä¸€åˆ—â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$N$å°±æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å­—ç¬¦ä¸²é•¿åº¦äº†ã€‚ äº‹å®žä¸Šï¼Œ$n_1 = n_3 = (N + 2) / 3$ï¼Œç„¶åŽæ±‚å¾—$n_2$å³å¯å¼€å§‹æ‰“å°è¾“å‡ºäº†ðŸ˜’ã€‚ å¯ä»¥ç›´æŽ¥æ‰“å°è¾“å‡ºï¼Œä¸è¿‡è¿˜è¦æ‰¾äº›å°è§„å¾‹ï¼ˆæŠ˜ç£¨ä½ ðŸ˜†ï¼‰ï¼Œå¦‚ç¬¬ä¸€è¡Œè¾“å‡ºçš„æ˜¯å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åŽä¸€ä¸ªå­—ç¬¦ï¼›å…ˆè¾“å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åŽè¾“å‡ºç©ºæ ¼ï¼ŒæŽ¥ç€åœ¨è¾“å‡ºæœ€åŽä¸€ä¸ªå­—ç¬¦å³å¯ã€‚ä¹Ÿå¯ä»¥å…ˆæŠŠæ¯ä¸€ä¸ªå­—ç¬¦æ”¾åˆ°äºŒç»´æ•°ç»„å†…ï¼Œåˆ©ç”¨ç©ºæ ¼åˆå§‹åŒ–äºŒç»´æ•°ç»„ï¼Œç„¶åŽåœ¨æŒ‡å®šä½ç½®æ”¾å…¥å­—ç¬¦ï¼Œæœ€åŽè¾“å‡ºå³å¯ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n1, n2, n3, N; char str[85]; scanf("%s", str); N = strlen(str); n1 = n3 = (N + 2) / 3; //get n1 and n3 first n2 = N + 2 - 2 * n1; //use the condition: n1 + n2 + n3 - 2 = N for(int i = 0; i &lt; n1; i++) &#123; if(i == n1 - 1) &#123; //print the last line for(int j = i; j &lt;= N - i - 1; j++) &#123; printf("%c", str[j]); &#125; &#125; else &#123; printf("%c", str[i]); for(int j = 0; j &lt; n2 - 2; j++) &#123; putchar(' '); &#125; printf("%c", str[N - i - 1]); &#125; putchar('\n'); &#125; return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼Œæ²¡æœ‰ç”¨å…¬å¼æ±‚ n1, n2, n3ï¼š12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int n1, n2 = 3, n3, len = str.length(); while(true) &#123; int diff = len - n2; if(diff % 2 == 0) &#123; n1 = n3 = diff / 2; if(n2 &gt; n1) break; &#125; n2++; &#125; int i, j; for(i = 0, j = len - 1; i &lt; n1 &amp;&amp; j &gt; len - n3 - 1; i++, j--) &#123; cout &lt;&lt; str[i]; for(int k = 0; k &lt; n2 - 2; k++) cout &lt;&lt; ' '; cout &lt;&lt; str[j] &lt;&lt; endl; &#125; while(i &lt;= j) cout &lt;&lt; str[i++]; return 0;&#125; 1032 SharingAnalysisé¢˜ç›®å¤§æ„æ˜¯ä½¿ç”¨é“¾è¡¨å­˜å‚¨è‹±æ–‡å­—ç¬¦æ—¶ï¼Œå› ä¸ºè‹±æ–‡å­—ç¬¦å­˜åœ¨ç›¸åŒçš„åŽç¼€ï¼Œæ‰€ä»¥å…¬å…±åŽç¼€åªå­˜å‚¨ä¸€æ¬¡ï¼Œç„¶åŽè®©ä¸åŒä¸”å…·æœ‰è¿™ä¸ªå…¬å…±åŽç¼€å•è¯çš„æœ€åŽä¸€ä¸ªä¸å±žäºŽè¿™ä¸ªåŽç¼€çš„å­—æ¯çš„nextæŒ‡å‘å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯å³å¯ï¼Œè¿™æ ·å°±å¯ä»¥èŠ‚çº¦ä¸€å®šçš„å­˜å‚¨ç©ºé—´äº†ã€‚ æŒ‰ç…§é¢˜ç›®èƒŒæ™¯ï¼Œé¢˜ç›®è¦æ±‚æ‰¾å‡ºå…·æœ‰ä¸¤ä¸ªå•è¯çš„å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯çš„åœ°å€å¹¶è¾“å‡ºï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º-1ã€‚ç›´è§‚çš„åšæ³•æ˜¯ï¼ŒéåŽ†ç¬¬ä¸€ä¸ªé“¾è¡¨ï¼ŒåŒæ—¶éåŽ†ç¬¬äºŒä¸ªé“¾è¡¨ï¼Œæ‰¾åˆ°äºŒè€…ä¸­å…·æœ‰ç›¸åŒaddressçš„å…ƒç´ ï¼Œè¾“å‡ºå³å¯ï¼Œæ­¤æ—¶çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(n^2)$ã€‚ æŒ‰ç…§é¢˜ç›®ç»™å®šçš„å½¢å¼ï¼Œä½¿ç”¨é™æ€é“¾è¡¨æ¥å¤„ç†é—®é¢˜ï¼ŒæŽ¥ç€ä¸Šé¢çš„æ€è€ƒï¼Œè‹¥åœ¨éåŽ†ç¬¬ä¸€ä¸ªé“¾è¡¨æ—¶ï¼Œç»™å…¶æ¯ä¸€ä¸ªç»“ç‚¹éƒ½åŠ ä¸Šä¸€ä¸ªæ ‡å¿—ä½ï¼›æŽ¥ç€åœ¨éåŽ†ç¬¬äºŒä¸ªé“¾è¡¨æ—¶ï¼Œå°±å¯ä»¥ç›´æŽ¥åˆ¤æ–­ç¬¬äºŒä¸ªé“¾è¡¨çš„ç»“ç‚¹çš„æ ‡å¿—ä½æ˜¯å¦ä¸Žç¬¬ä¸€ä¸ªé“¾è¡¨ç»“ç‚¹çš„æ ‡å¿—ä½ç›¸åŒï¼Œè‹¥ç›¸åŒï¼Œåˆ™è¿™ä¸ªç»“ç‚¹å°±æ˜¯äºŒè€…å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯äº†ï¼Œå°±å¯ä»¥è¾“å‡ºäº†ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±é™ä¸ºï¼š$O(n)$äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125; node[maxn];int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int head1, head2, n; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); int address, next; char data; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;address, &amp;data, &amp;next); node[address].next = next; node[address].data = data; &#125; int p; for(p = head1; p != -1; p = node[p].next) &#123; node[p].flag = true; &#125; for(p = head2; p != -1; p = node[p].next) &#123; if(node[p].flag == true) break; &#125; if(p != -1) &#123; printf("%05d\n", p); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1033 To Fill or Not to FillAnalysisæ­¤é¢˜è€ƒå¯Ÿè´ªå¿ƒç®—æ³•ï¼Œå¦‚ä½•è¿›è¡Œâ€œè´ªå¿ƒâ€å¾—ä»Žç»“æžœå’Œé¢˜æ„ä¸ŠåŽ»åˆ†æžã€‚ ä¾æ®ç»“æžœï¼Œæ¯æ¬¡ç»è¿‡ä¸€ä¸ªåŠ æ²¹ç«™æ—¶ï¼Œéœ€è¦å°†å½“å‰åŠ æ²¹ç«™ä¸Žå°è½¦ä»Žå½“å‰åŠ æ²¹ç«™èƒ½åˆ°è¾¾çš„æ¯ä¸ªåŠ æ²¹ç«™çš„æ²¹ä»·è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥å­˜åœ¨æ²¹ä»·æ›´ä½Žçš„åŠ æ²¹ç«™ï¼Œé‚£ä¹ˆå°±åŠ åˆšå¥½èƒ½åˆ°è¾¾é‚£ä¸ªåŠ æ²¹ç«™çš„æ²¹é‡ï¼Œå¦åˆ™å°±åŠ æ»¡ã€‚æ‰€ä»¥éœ€è¦å°†åŠ æ²¹ç«™æŒ‰ç…§ç¦»æ­å·žçš„è·ç¦»ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åˆ—ï¼Œå¹¶å‡è®¾ç›®çš„åœ°ç¦»æ­å·žçš„è·ç¦»ä¸ºè¾“å…¥è·ç¦»ï¼Œæ²¹ä»·ä¸º0ï¼ˆè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿æ¯”è¾ƒï¼Œä¸ç”¨å¤„ç†ç‰¹æ®Šæƒ…å†µï¼‰ã€‚ç„¶åŽï¼Œå¼€å§‹æ¨¡æ‹Ÿå°è½¦ä»Žèµ·ç‚¹å‡ºå‘ã€‚ å½“ç¬¬ä¸€ä¸ªåŠ æ²¹ç«™ç¦»æ­å·žçš„è·ç¦»ä¸ä¸º0æ—¶ï¼Œè¯´æ˜Žå°è½¦æ— æ³•å‡ºåŸŽï¼Œç›´æŽ¥è¾“å‡ºThe maximum travel distance = 0.00å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 500 + 5;const int INF = 1000000000;struct station &#123; double price, dis;&#125; sta[MAXN];bool cmp(station a, station b);int main(int argc, char const *argv[]) &#123; double cmax, d, davg; int N; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[N].price = 0; sta[N].dis = d; sort(sta, sta + N, cmp); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, capacity = 0, max = cmax * davg; while(now &lt; N) &#123; int k = -1; double priceMin = INF; for(int i = now + 1; i &lt;= N &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; priceMin) &#123; priceMin = sta[i].price; k = i; if(priceMin &lt; sta[now].price) &#123; break; &#125; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(priceMin &lt; sta[now].price) &#123; if(capacity &lt; need) &#123; ans += (need - capacity) * sta[now].price; capacity = 0; &#125; else &#123; capacity -= need; &#125; &#125; else &#123; ans += (cmax - capacity) * sta[now].price; capacity = cmax - need; &#125; now = k; &#125; if(now == N) &#123; printf("%.2lf\n", ans); &#125; else &#123; printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; &#125; return 0;&#125;bool cmp(station a, station b) &#123; return a.dis &lt; b.dis;&#125; é‡æ–°å†™äº†ä¸€ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cfloat&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 500 + 5;struct station &#123; double price, dis;&#125; sta[maxn];int main() &#123; double cmax, d, davg; int n; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[n].dis = d, sta[n].price = 0; sort(sta, sta + n, [&amp;](station a, station b) &#123; return a.dis &lt; b.dis; &#125;); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, tank = 0, max = cmax * davg; while(now &lt; n) &#123; int k = -1; double minprice = DBL_MAX; for(int i = now + 1; i &lt;= n &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; minprice) &#123; minprice = sta[i].price; k = i; if(minprice &lt; sta[now].price) break; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(minprice &lt; sta[now].price) &#123; if(tank &lt; need) &#123; ans += (need - tank) * sta[now].price; tank = 0; &#125; else tank -= need; &#125; else &#123; ans += (cmax - tank) * sta[now].price; tank = cmax - need; &#125; now = k; &#125; if(now == n) printf("%.2lf\n", ans); else printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; return 0;&#125; 1034 Head of a GangAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2010;const int INF = 1000000000;map&lt;int, string&gt; intTostring;map&lt;string, int&gt; stringToint;map&lt;string, int&gt; Gang;int G[maxn][maxn] = &#123;0&#125;, weight[maxn] = &#123;0&#125;;int n, k, numPerson = 0;bool visited[maxn] = &#123;false&#125;;void DFS(int nowVisit, int &amp;head, int &amp;numMember, int &amp;totalValue) &#123; numMember++; visited[nowVisit] = true; if(weight[nowVisit] &gt; weight[head]) &#123; head = nowVisit; &#125; for(int i = 0; i &lt; numPerson; i++) &#123; if(G[nowVisit][i] &gt; 0) &#123; totalValue += G[nowVisit][i]; G[nowVisit][i] = G[i][nowVisit] = 0; if(visited[i] == false) &#123; DFS(i, head, numMember, totalValue); &#125; &#125; &#125;&#125;void DFSTrave() &#123; for(int i = 0; i &lt; numPerson; i++) &#123; if(visited[i] == false) &#123; int head = i, numMember = 0, totalValue = 0; DFS(i, head, numMember, totalValue); if(numMember &gt; 2 &amp;&amp; totalValue &gt; k) &#123; Gang[intTostring[head]] = numMember; &#125; &#125; &#125;&#125;int change(string s) &#123; if(stringToint.find(s) != stringToint.end()) &#123; return stringToint[s]; &#125; else &#123; stringToint[s] = numPerson; intTostring[numPerson] = s; return numPerson++; &#125;&#125;int main(int argc, char const *argv[]) &#123; int w; string s1, s2; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = change(s1); int id2 = change(s2); weight[id1] += w; weight[id2] += w; G[id1][id2] += w; G[id2][id1] += w; &#125; DFSTrave(); cout &lt;&lt; Gang.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator it; for(it = Gang.begin(); it != Gang.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; 1035 PasswordAnalysisé¢˜ç›®çœ‹ç€è‡­é•¿è‡­é•¿çš„ï¼Œå…¶å®žæ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æœ‰äº›å°å°çš„ç»†èŠ‚... å…ˆåˆ†æžè¾“å…¥æ ¼å¼ï¼Œç»™ä¸ªNä»£è¡¨Nç»„æ•°æ®ï¼Œç„¶åŽæ¯ä¸€ç»„æ•°ç»„æŒ‰ç…§name passwordçš„æ ¼å¼æ¥ç»™å‡ºï¼Œéƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œç”±äºŽè¾“å‡ºæ—¶åŽè¦åŒç­‰è¾“å‡ºï¼Œæ‰€ä»¥æ–¹ä¾¿èµ·è§å®šä¹‰ä¸€ä¸ªç»“æž„ä½“æ¥ä¿å­˜è¿™äº›æ•°æ®ï¼›å†è€…ï¼Œç”±äºŽæœ€åŽå¾—å…ˆè¾“å‡ºè¢«ä¿®æ”¹çš„æ•°é‡ï¼Œæ‰€ä»¥å¾—å…ˆæŠŠæ•°æ®éƒ½å­˜å‚¨ä¸‹æ¥ï¼Œæ‰èƒ½åœ¨è¾“å‡ºæ•°é‡åŽï¼Œåœ¨è¾“å‡ºä¿®æ”¹çš„ä¿¡æ¯ã€‚ å†çœ‹è¾“å‡ºæ ¼å¼ï¼Œè‹¥æœ‰ä¿®æ”¹ï¼Œå°±è¾“å‡ºä¿®æ”¹çš„æ•°é‡ï¼Œç„¶åŽæ¯è¡Œç´§æŽ¥ç€æ¯ä¸ªç»“æž„ä½“å†…çš„ä¿¡æ¯ï¼›è‹¥æ²¡æœ‰ä¿®æ”¹ï¼Œå°±è¾“å‡ºThere are N accounts and no account is modifiedï¼Œæ³¨æ„è¿™é‡Œçš„ç»†èŠ‚ï¼Œå½“Nä¸º1æ—¶ï¼Œå¾—è¾“å‡ºThere is 1 account and no account is modifiedï¼Œè¿™ä¸¤å¥è‹±æ–‡åœ¨Nä¸º1å’Œå…¶ä»–æ•°æ—¶ä½¿ç”¨çš„BeåŠ¨è¯ä¸ä¸€æ ·ï¼ˆè€å¸ˆå‡ºé¢˜å¾ˆä¸¥è°¨çš„ï¼ŒðŸ¤£è‹±è¯­è¦å­¦å¥½ï¼Œå“ˆå“ˆ~ï¼‰ã€‚ å…¶ä»–å°±æ²¡ä»€ä¹ˆäº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;const int MAXN = 1000 + 5;struct info &#123; char name[12], password[12]; int flag;&#125; Info[MAXN];int main(int argc, char const *argv[]) &#123; int N, count = 0; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s", Info[i].name, Info[i].password); char *p = Info[i].password; while(*p != '\0') &#123; if(*p == '1') &#123; *p = '@'; Info[i].flag = 5; &#125; else if(*p == '0') &#123; *p = '%'; Info[i].flag = 5; &#125; else if(*p == 'l') &#123; *p = 'L'; Info[i].flag = 5; &#125; else if(*p == 'O') &#123; *p = 'o'; Info[i].flag = 5; &#125; p++; &#125; if(Info[i].flag != 5) &#123; count++; &#125; &#125; if(count == N) &#123; if(count == 1) printf("There is %d account and no account is modified\n", count); else printf("There are %d accounts and no account is modified", count); &#125; else &#123; printf("%d\n", N - count); for(int i = 0; i &lt; N; i++) &#123; if(Info[i].flag == 5) &#123; printf("%s %s\n", Info[i].name, Info[i].password); &#125; &#125; &#125; return 0;&#125; è´´ä¸ª C++ ç‰ˆæœ¬çš„ï¼š1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int m, cnt = 0; cin &gt;&gt; m; string account, password; vector&lt;vector&lt;string&gt;&gt; ans; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; account &gt;&gt; password; bool flag = false; for(int j = 0; j &lt; password.length(); j++) &#123; switch(password[j]) &#123; case '1': password[j] = '@'; flag = true; break; case '0': password[j] = '%'; flag = true; break; case 'l': password[j] = 'L'; flag = true; break; case 'O': password[j] = 'o'; flag = true; break; default: break; &#125; &#125; if(flag) &#123; ans.push_back(&#123;account, password&#125;); cnt++; &#125; &#125; if(!cnt) &#123; if(m &lt;= 1) cout &lt;&lt; "There is " &lt;&lt; m &lt;&lt; " account"; else cout &lt;&lt; "There are " &lt;&lt; m &lt;&lt; " accounts"; cout &lt;&lt; " and no account is modified"; &#125; else &#123; cout &lt;&lt; cnt &lt;&lt; endl; for(int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i][0] &lt;&lt; ' ' &lt;&lt; ans[i][1] &lt;&lt; endl; &#125; &#125; return 0;&#125; å¤ªéº»çƒ¦äº†ï¼Œè¿™ä¸ªé¢˜... 1036 Boys vs GirlsAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œæ‰¾å‡ºå¥³ç”Ÿä¸­åˆ†æœ€é«˜çš„ï¼Œç”·ç”Ÿä¸­åˆ†æœ€ä½Žçš„ï¼Œåˆ†åˆ«è¾“å‡ºä»–ä»¬çš„å§“åã€å­¦å·å’Œåˆ†æ•°ä¹‹å·®å³å¯ï¼Œç”±äºŽæœ€åŽéœ€è¦çš„ä¸¤ä¸ªç»“æžœå¯èƒ½æ²¡æœ‰å‡ºçŽ°ï¼Œåˆ©ç”¨ä¸¤ä¸ªæ ‡è®°æ¥è®°å½•çŠ¶æ€ï¼Œç„¶åŽæ ¹æ®4ç§ä¸åŒçš„çŠ¶æ€ï¼Œåˆ†åˆ«å¯¹åº”è¾“å‡ºå³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;struct student&#123; char name[15]; char id[15]; char gender; int grade;&#125; Fhighest, Mlowest, temp;void Init();bool Highest(student a, student b);bool Lowest(student a, student b);int main(int argc, char const *argv[]) &#123; Init(); int N; bool Fflag = false, Mflag = false; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %c %s %d", temp.name, &amp;temp.gender, temp.id, &amp;temp.grade); if(temp.gender == 'F') &#123; if(Highest(temp, Fhighest)) &#123; Fhighest = temp; Fflag = true; &#125; &#125; else if(temp.gender == 'M') &#123; if(Lowest(temp, Mlowest)) &#123; Mlowest = temp; Mflag = true; &#125; &#125; &#125; if(!Fflag &amp;&amp; !Mflag) &#123; printf("Absent\nAbsent\nNA\n"); &#125; else if(Fflag &amp;&amp; !Mflag) &#123; printf("%s %s\nAbsent\nNA\n", Fhighest.name, Fhighest.id); &#125; else if(!Fflag &amp;&amp; Mflag) &#123; printf("Absent\n%s %s\nNA\n", Mlowest.name, Mlowest.id); &#125; else &#123; printf("%s %s\n%s %s\n%d\n", Fhighest.name, Fhighest.id, Mlowest.name, Mlowest.id, Fhighest.grade - Mlowest.grade); &#125; return 0;&#125;void Init() &#123; Fhighest.grade = -1; Mlowest.grade = 100;&#125;bool Highest(student a, student b) &#123; return a.grade &gt;= b.grade;&#125;bool Lowest(student a, student b) &#123; return a.grade &lt;= b.grade;&#125; è´´ä¸ª C++ ç‰ˆï¼š12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; string malename, femalename, maleid, femaleid, name, clas, maleclass, femaleclass; char gender; int grade, highest = -1, lowest = 101; while(n--) &#123; cin &gt;&gt; name &gt;&gt; gender &gt;&gt; clas &gt;&gt; grade; if(gender == 'M') &#123; if(grade &lt; lowest) &#123; lowest = grade; malename = name; maleclass = clas; &#125; &#125; if(gender == 'F') &#123; if(grade &gt; highest) &#123; highest = grade; femalename = name; femaleclass = clas; &#125; &#125; &#125; if(highest &lt; 0) cout &lt;&lt; "Absent\n"; else cout &lt;&lt; femalename &lt;&lt; ' ' &lt;&lt; femaleclass &lt;&lt; endl; if(lowest &gt; 100) cout &lt;&lt; "Absent\n"; else cout &lt;&lt; malename &lt;&lt; ' ' &lt;&lt; maleclass &lt;&lt; endl; if(lowest &gt; 100 || highest &lt; 0) cout &lt;&lt; "NA\n"; else cout &lt;&lt; highest - lowest; return 0;&#125; 1037 Magic CouponAnalysisè¿™é“é¢˜è€ƒå¯Ÿè´ªå¿ƒç®—æ³•ï¼Œé¢˜ç›®è¦æ±‚è¾“å‡ºå¯ä»¥å¾—åˆ°çš„æœ€å¤§é’±æ•°ã€‚æ³¨æ„è¿™æ®µè¯ï¼šprint in a line the maximum amount of money you can get backçš„è¡¨è¿°ï¼Œæ‰€ä»¥åªéœ€è¦å¾—åˆ°èƒ½å¾—åˆ°çš„æœ€å¤§å€¼å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦ç»Ÿè®¡è´Ÿæ•°çš„æƒ…å†µæ‰€ä»¥åªéœ€è¦ç»Ÿè®¡æ”¶é’±çš„æƒ…å†µï¼Œä»˜é’±çš„æƒ…å†µä¸ç”¨ç»Ÿè®¡äº†ã€‚è‹¥åªç»Ÿè®¡ä¸€å¼ åˆ¸ä¹˜ä»¥ä¸€ä»¶å•†å“ä»·æ ¼çš„ç»“æžœä¸ºæ­£æ•°çš„æƒ…å†µï¼Œå°±åˆ†ä¸ºä¸¤ç§ï¼š åˆ¸å€¼ä¸ºæ­£ï¼Œå•†å“ä»·æ ¼ä¸ºæ­£ï¼Œé¢å€¼æœ€å¤§çš„åˆ¸éœ€è¦ä¹˜ä»¥ä»·æ ¼æœ€é«˜çš„å•†å“ï¼Œå°±èƒ½å¾—åˆ°æœ€å¤§çš„ç»“æžœã€‚ åˆ¸å€¼ä¸ºè´Ÿï¼Œå•†å“ä»·æ ¼ä¸ºè´Ÿï¼Œé¢å€¼æœ€å°ï¼ˆè´Ÿæ•°ï¼‰çš„åˆ¸éœ€è¦ä¹˜ä»¥ä»·æ ¼æœ€ä½Žï¼ˆè´Ÿæ•°ï¼‰çš„å•†å“ï¼Œå°±èƒ½å¾—åˆ°æœ€å¤§çš„ç»“æžœã€‚ åˆ©ç”¨ä¸¤ä¸ªæ•°ç»„æ¥åˆ†åˆ«å­˜å‚¨åˆ¸å€¼å’Œå•†å“ä»·æ ¼ï¼ŒæŒ‰ç…§å¤§å°æŽ’åºåŽï¼Œå¼€å§‹ç›¸ä¹˜ï¼Œè®¡ç®—æœ€ç»ˆç»“æžœã€‚æ³¨æ„ï¼Œå‡åºå’Œé™åºä¸å½±å“ç»“æžœï¼Œä½†éœ€è¦ä¸¤ç§æƒ…å†µéœ€è¦åˆ†å¼€å¤„ç†ã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int Nc, Np, coupon[MAXN] = &#123;0&#125;, product[MAXN] = &#123;0&#125;; scanf("%d", &amp;Nc); for(int i = 0; i &lt; Nc; i++) &#123; scanf("%d", &amp;coupon[i]); &#125; scanf("%d", &amp;Np); for(int i = 0; i &lt; Np; i++) &#123; scanf("%d", &amp;product[i]); &#125; sort(coupon, coupon + Nc); sort(product, product + Np); int i = 0, j, ans = 0; while(i &lt; Nc &amp;&amp; i &lt; Np &amp;&amp; coupon[i] &lt; 0 &amp;&amp; product[i] &lt; 0) &#123; ans += coupon[i] * product[i]; i++; &#125; i = Nc - 1; j = Np - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; coupon[i] &gt; 0 &amp;&amp; product[j] &gt; 0) &#123; ans += coupon[i] * product[j]; i--, j--; &#125; printf("%d\n", ans); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c1, p1;priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; c2, p2;int main() &#123; int nc, np, tmp; cin &gt;&gt; nc; for(int i = 0; i &lt; nc; i++) &#123; cin &gt;&gt; tmp; if(tmp &lt; 0) c1.push(tmp); if(tmp &gt; 0) c2.push(tmp); &#125; cin &gt;&gt; np; for(int i = 0; i &lt; np; i++) &#123; cin &gt;&gt; tmp; if(tmp &lt; 0) p1.push(tmp); if(tmp &gt; 0) p2.push(tmp); &#125; long long ans = 0; while(!c1.empty() &amp;&amp; !p1.empty()) &#123; int ctmp = c1.top(); c1.pop(); int ptmp = p1.top(); p1.pop(); ans += ctmp * ptmp; &#125; while(!c2.empty() &amp;&amp; !p2.empty()) &#123; int ctmp = c2.top(); c2.pop(); int ptmp = p2.top(); p2.pop(); ans += ctmp * ptmp; &#125; cout &lt;&lt; ans; return 0;&#125; ç²—ç•¥åˆ†æžä¸€ä¸‹ï¼Œå †çš„æ—¶é—´å¤æ‚åº¦åº”è¯¥ä¼˜äºŽæŽ’åºï¼ŒåŒæ ·éœ€è¦ $O(n)$ çš„å­˜å‚¨ç©ºé—´ï¼Œä¸è¿‡æžç«¯æƒ…å†µä¸‹ï¼ŒäºŒè€…åº”è¯¥å·®ä¸å¤šã€‚å¦å¤–ï¼Œå…¶å®žå¯ä»¥åœ¨æœ€åŽçš„ç»“æžœansè¿™é‡ŒæŒ–å‘ï¼Œæ•…æ„å¼„æˆæº¢å‡ºçš„æƒ…å†µï¼Œå› ä¸ºé¢˜ç›®åªè¯´äº†ä¿è¯ç»™çš„æ•°ç»„ä¸è¶…è¿‡ $2^{30}$ã€‚ 1038 Recover the Smallest NumberAnalysisé¢˜ç›®ä¼šç»™ä¸€äº›æ•°å­—ï¼Œè¦æ±‚å°†ç»™å®šçš„æ‰€æœ‰æ•°å­—â€œæ‹¼æŽ¥â€èµ·æ¥ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªç»„åˆæ•°ï¼Œè¿™ä¸ªæ•°å­—è¦æ¯”æŒ‰ç…§å…¶ä»–æ–¹å¼ç»„åˆå¾—åˆ°çš„ç»“æžœå°ã€‚ ç”±äºŽä¸èƒ½æ‰“ä¹±ç»™å®šçš„æ¯ä¸ªæ•°å­—çš„æ•°ä½é¡ºåºï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šæƒ³åˆ°ç›´æŽ¥æŒ‰ç…§å­—å…¸åºæ¯”è¾ƒæ¯ä¸ªæ•°å­—çš„å¤§å°ï¼Œç„¶åŽè®©å°çš„çš„åœ¨å‰é¢ï¼Œå¤§çš„åœ¨åŽé¢ã€‚ä½†è¦æ³¨æ„ï¼Œå¦‚æžœæ•°å­—32, 321ï¼ŒæŒ‰å­—å…¸åºå¤§å°æŽ’åˆ—åŽçš„ç»„åˆæ•°æ˜¯32321ï¼Œæ­¤æ—¶å­˜åœ¨æ›´å°çš„ç»“æžœ32132ï¼Œæ‰€ä»¥ä¸èƒ½å•çº¯çš„æŒ‰ç…§è¿™ç§æ€è·¯è¿›è¡Œã€‚ å¯¹äºŽ32, 321è¿™ä¸¤ä¸ªæ•°å­—è€Œè¨€ï¼ŒæŒ‰ç…§ä¸Šé¢çš„ç»“æžœï¼š32132 &lt; 32321ï¼Œä»Žå­—ç¬¦ä¸²çš„è§’åº¦å‡ºå‘ï¼Œå‡è®¾a = 32, b = 321ï¼Œåˆ™æœ‰ba &lt; abï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ä¸¤ä¸ªæ•°ä¸­æ‰¾å‡ºâ€œæ‹¼æŽ¥â€å‡ºçš„æœ€å°æ•°äº†ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå¯¹æ¯ä¸€ä¸ªæ•°å­—ï¼ˆä»¥å­—ç¬¦ä¸²å½¢å¼å­˜å‚¨ï¼‰éƒ½è¿™æ ·æŽ’åºï¼Œæœ€åŽé€ä¸ªè¾“å‡ºçš„ç»“æžœå°±æ˜¯é¢˜ç›®è¦æ±‚çš„æœ€å°æ•°å­—äº†ã€‚ ç¡®å®šè¦ç”¨å­—ç¬¦ä¸²äº†åŽï¼Œç›´æŽ¥ä½¿ç”¨STLå†…çš„stringç±»å¯ä»¥å¾ˆæ–¹ä¾¿çš„å¯¹å­—ç¬¦ä¸²è¿›è¡Œæ“ä½œã€‚ æ³¨æ„ï¼Œå½“è¾“å…¥çš„å…¨éƒ¨ä¸º0æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤è¾“å‡º0ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;string str[MAXN];bool cmp(string a, string b);int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += str[i]; &#125; while(ans.size() != 0 &amp;&amp; ans[0] == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.size() == 0) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans; &#125; return 0;&#125;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125; åˆå†™äº†ä¸€éï¼š12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; vector&lt;string&gt; strs; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n ; i++) &#123; string tmp; cin &gt;&gt; tmp; strs.push_back(tmp); &#125; sort(strs.begin(), strs.end(), [](string &amp;a, string &amp;b) &#123; return a + b &lt; b + a; &#125;); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += strs[i]; &#125; while(ans.length() != 0 &amp;&amp; *ans.begin() == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.length() == 0) cout &lt;&lt; "0"; else cout &lt;&lt; ans; return 0;&#125; è¿™ä¸ªé¢˜çš„è´ªå¿ƒç­–ç•¥å°±æ˜¯å±€éƒ¨æœ€ä¼˜ï¼Œç„¶åŽè¾¾åˆ°çš„å…¨å±€æœ€ä¼˜ã€‚ 1039 Course List for StudentAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè¯¾ç¨‹æ•°ç›®å’Œæ¯é—¨è¯¾ç¨‹å‚åŠ çš„å­¦ç”Ÿå§“åï¼Œå½“ç”¨å­¦ç”Ÿå§“åæŸ¥æ‰¾æ—¶ï¼Œè¾“å‡ºè¯¥åå­¦ç”Ÿæ‰€æœ‰çš„è¯¾ç¨‹ã€‚ æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œéœ€è¦ä¿å­˜æ¯åå­¦ç”Ÿçš„é€‰è¯¾ä¿¡æ¯ï¼Œè¯¾ç¨‹éƒ½æ˜¯ç”¨æ•°å­—ä»£æ›¿çš„ï¼Œæ‰€ä»¥ä½¿ç”¨æ•°ç»„å°±å¯ä»¥æ»¡è¶³éœ€æ±‚ã€‚ç”±äºŽéœ€è¦æŒ‰åºè¾“å‡ºæ¯åå­¦ç”Ÿçš„è¯¾ç¨‹ç¼–å·ï¼Œæ‰€ä»¥éœ€è¦å¯¹æ¯åå­¦ç”Ÿçš„è¯¾ç¨‹ç¼–å·è¿›è¡ŒæŽ’åºï¼›å¹¶ä¸”ï¼Œè¿˜éœ€è¦å…ˆè¾“å‡ºè¯¥åå­¦ç”Ÿé€‰è¯¾çš„æ€»æ•°ã€‚ç»¼åˆè€ƒè™‘åŽï¼Œä½¿ç”¨vectoræ¥ä¿å­˜æ•°æ®æ¯”è¾ƒåˆé€‚ã€‚å¦å¤–ä¸ºäº†ä¾¿äºŽæŸ¥æ‰¾ï¼Œé‡‡ç”¨æ•£åˆ—çš„æ€æƒ³ï¼Œå°†å­¦ç”Ÿçš„å§“åè½¬æ¢ä¸ºæ•°å­—ï¼Œä½œä¸ºä¸‹æ ‡æ¥ä¿å­˜æ•°æ®ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010;const int M = 26 * 26 * 26 * 10 + 1;vector&lt;int&gt; selectCourse[M];int getID(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) &#123; id = id * 26 + (name[i] - 'A'); &#125; id = id * 10 + (name[3] - '0'); return id;&#125;int main(int argc, char const *argv[]) &#123; char name[5]; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; int course, x; scanf("%d %d", &amp;course, &amp;x); for(int j = 0; j &lt; x; j++) &#123; scanf("%s", name); int id = getID(name); selectCourse[id].push_back(course); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%s", name); int id = getID(name); sort(selectCourse[id].begin(), selectCourse[id].end()); printf("%s %d", name, selectCourse[id].size()); for(int j = 0; j &lt; selectCourse[id].size(); j++) &#123; printf(" %d", selectCourse[id][j]); &#125; putchar('\n'); &#125; return 0;&#125; çŽ°åœ¨æ—¶é—´é™åˆ¶æ”¾å®½åˆ°äº†600msï¼Œæ‰€ä»¥å¯ä»¥æ”¾å¿ƒå¤§èƒ†çš„ç”¨ mapã€cin å’Œ cout äº†ï¼š123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;unordered_map&gt; #include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;unordered_map&lt;string, vector&lt;int&gt;&gt; stu;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; string name; while(k--) &#123; int cid, amount; cin &gt;&gt; cid &gt;&gt; amount; for(int i = 0; i &lt; amount; i++) &#123; cin &gt;&gt; name; stu[name].push_back(cid); &#125; &#125; while(n--) &#123; cin &gt;&gt; name; cout &lt;&lt; name &lt;&lt; ' ' &lt;&lt; stu[name].size(); sort(stu[name].begin(), stu[name].end()); for(int &amp;i: stu[name]) &#123; cout &lt;&lt; ' ' &lt;&lt; i; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1040 Longest Symmetric StringAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€é•¿å›žæ–‡å­ä¸²ã€‚æ­¤é¢˜å¹¶æ²¡æœ‰è®¾ç½®è¶…æ—¶æµ‹è¯•ç‚¹ï¼Œç›´æŽ¥ä½¿ç”¨æš´åŠ›è§£æ³•å¯ä»¥è¿‡ã€‚ä¸è¿‡ï¼Œè¿™ç±»æœ€é•¿å…¬å…±å­ä¸²ï¼ˆLongest Palindromic Substringï¼‰çš„é¢˜ç›®ï¼Œè¿˜æœ‰å¦å¤–ä¸€ç§æ€è·¯â€”â€”åŠ¨æ€è§„åˆ’ã€‚ CodeViolent Solution123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;bool palindrome(char *s1, char *s2) &#123; bool flag = true; for(; s1 &lt; s2; s1++, s2--) &#123; if(*s1 != *s2) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main(int argc, char const *argv[]) &#123; char str[maxn]; fgets(str, maxn, stdin); char *p1, *p2; int max_len = 0, temp; for(p1 = str; *p1 != '\0'; p1++) &#123; for(p2 = p1 + 1; *p2 != '\0'; p2++) &#123; if(*p1 == *p2) &#123; temp = p2 - p1; if(temp &lt;= max_len) continue; else if(palindrome(p1, p2)) max_len = temp; &#125; &#125; &#125; printf("%d", max_len + 1); return 0;&#125; DP123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;char str[maxn];int dp[maxn][maxn];int main(int argc, char const *argv[]) &#123; fgets(str, maxn, stdin); int len = strlen(str), ans = 1; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; len; i++) &#123; dp[i][i] = 1; if(i &lt; len - 1) &#123; if(str[i] == str[i + 1]) &#123; dp[i][i + 1] = 1; ans = 2; &#125; &#125; &#125; for(int l = 3; l &lt;= len; l++) &#123; for(int i = 0; i + l - 1 &lt; len; i++) &#123; int j = i + l - 1; if(str[i] == str[j] &amp;&amp; dp[i + 1][j - 1] == 1) &#123; dp[i][j] = 1; ans = l; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 Be UniqueAnalysisæ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œæœ€å…ˆçŒœåˆ°åªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­—å°±èµ¢äº†ï¼Œæ‰€ä»¥å¾—å…ˆæŒ‰ç…§é¡ºåºè¯»å…¥æ¯ä¸ªæ•°ï¼ŒåŒæ—¶ç»Ÿè®¡æ¯ä¸ªæ•°å­—çš„å‡ºçŽ°æ¬¡æ•°ã€‚ç„¶åŽå†æŒ‰ç…§è¾“å…¥é¡ºåºï¼Œæ£€æŸ¥æ¯ä¸ªæ•°å­—çš„å‡ºçŽ°æ¬¡æ•°ï¼Œè‹¥å‡ºçŽ°ä¸€æ¬¡å³ä¸ºèµ¢çš„é‚£ä¸ªæ•°å­—ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int N, Num[MAXN] = &#123;0&#125;, times[MAXN] = &#123;0&#125;; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Num[i]); times[Num[i]]++; &#125; int i; for(i = 0; i &lt; N; i++) &#123; if(times[Num[i]] == 1) &#123; printf("%d", Num[i]); break; &#125; &#125; if(i == N) &#123; printf("None"); &#125; return 0;&#125; 1042 Shuffling MachineAnalysisæ ¹æ®é¢˜ç›®çš„ä¾‹å­ï¼Œè¯»æ‡‚é¢˜ç›®ï¼Œæ³¨æ„ä»…åœ¨ä¸€ä¸ªæ•°ç»„å†…äº¤æ¢å…ƒç´ ä¼š WA ï¼Œè¦ç”¨ä¸¤ä¸ªæ•°ç»„è¿›è¡Œå€’æ¢æ‰èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æžœã€‚å½“ç„¶ï¼Œä¹Ÿå¯ä»¥åœ¨æ¯æ¬¡å€’æ¢å®Œæˆä¹‹åŽï¼Œå°†å¾—åˆ°çš„åºåˆ—ç›´æŽ¥æ”¾åˆ°ç»“æžœæ•°ç»„ä¸­ï¼Œè¿™æ ·å°±ä¸ç”¨åœ¨åˆ¤æ–­äº†ã€‚ éœ€è¦è¾“å‡ºçš„å­—ç¬¦ä¸²å¯ä»¥å…ˆå†™ä¸ªå¾ªçŽ¯è¾“å‡ºï¼Œç„¶åŽä»Žé»‘æ¡†æ¡†ä¸­å¤åˆ¶ç²˜è´´è¦åˆå§‹åŒ–çš„äºŒç»´æ•°ç»„ä¸­ã€‚å¦‚æžœä¸æƒ³è¿™ä¹ˆå¹²ä¹Ÿå¯ä»¥åªä¿å­˜ç¬¦å·ä¿¡æ¯ï¼Œä¹Ÿå°±æ˜¯1char cards[6] = "SHCDJ"; è¿™æ ·ï¼Œæ•°ç»„ä¸­æ•°å­—è·Ÿå¡ç‰‡ç±»åž‹ä¸‹æ ‡çš„å¯¹åº”å…³ç³»å°±æ˜¯index = (arr[i] - 1) % 13ï¼Œé‚£åºå·å‘¢ï¼Ÿå®žé™…ä¸Šä¹Ÿæ˜¯å·®ä¸å¤šçš„ï¼Œä¹Ÿå°±æ˜¯(arr[i] - 1) % 13 + 1ï¼Œæ‰€ä»¥å°±å¯ä»¥å¾—åˆ°ç¬¬äºŒä¸ªç‰ˆæœ¬çš„ä»£ç ã€‚ Codeversion 112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;char playcards[55][5] = &#123; " ", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "J1", "J2",&#125;;int main() &#123; int k, arr[55], brr[55], order[55], flag = 1; cin &gt;&gt; k; for(int i = 1; i &lt;= 54; i++) &#123; cin &gt;&gt; order[i]; brr[i] = i; &#125; while(k--) &#123; if(flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; arr[order[i]] = brr[i]; &#125; flag = 0; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; brr[order[i]] = arr[i]; &#125; flag = 1; &#125; &#125; if(!flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[arr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[brr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; version 2123456789101112131415161718192021222324#include &lt;cstdio&gt;int k, shuffle[55], tmp1[55], tmp2[55];char cards[5] = &#123;'S', 'H', 'C', 'D', 'J'&#125;;int main() &#123; scanf("%d", &amp;k); for(int i = 1; i &lt;= 54; i++) &#123; scanf("%d", &amp;shuffle[i]); tmp2[i] = i; &#125; for(int i = 1; i &lt;= k; i++) &#123; for(int i = 1; i &lt;= 54; i++) &#123; tmp1[shuffle[i]] = tmp2[i]; &#125; for(int i = 1; i &lt;= 54; i++) &#123; tmp2[i] = tmp1[i]; &#125; &#125; for(int i = 1; i &lt;= 54; i++) &#123; printf("%c%d", cards[(tmp1[i] - 1) / 13] , (tmp1[i] - 1) % 13 + 1); if(i != 54) printf(" "); &#125; return 0;&#125; 1043 Is It a Binary Search TreeAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int data; node *left, *right; &#125;;void insert(node *&amp;root, int data) &#123; if(root == NULL) &#123; root = new node; root-&gt;data = data; root-&gt;left = root-&gt;right = NULL; return; &#125; if(data &lt; root-&gt;data) insert(root-&gt;left, data); else insert(root-&gt;right, data);&#125;void preorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preorder(root-&gt;left, vi); preorder(root-&gt;right, vi);&#125;void preordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preordermirror(root-&gt;right, vi); preordermirror(root-&gt;left, vi);&#125;void postorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postorder(root-&gt;left, vi); postorder(root-&gt;right, vi); vi.push_back(root-&gt;data);&#125;void postordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postordermirror(root-&gt;right, vi); postordermirror(root-&gt;left, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, preM, post, postM;int main(int argc, char const *argv[]) &#123; int n, data; node *root = NULL; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); origin.push_back(data); insert(root, data); &#125; preorder(root, pre); preordermirror(root, preM); postorder(root, post); postordermirror(root, postM); if(origin == pre) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if(i &lt; post.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else if(origin == preM) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; postM.size(); i++) &#123; cout &lt;&lt; postM[i]; if(i &lt; postM.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else &#123; cout &lt;&lt; "NO\n"; &#125; return 0;&#125; 1044 Shopping in MarsAnalysiså…ˆåˆ†æžé¢˜ç›®è¾“å…¥ï¼Œç¬¬ä¸€è¡Œç»™å®šä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªæ•°å­—ä»£è¡¨ä¸€æ¡â€œé“¾â€ä¸Šé’»çŸ³çš„æ•°é‡ï¼Œç¬¬äºŒä¸ªæ•°å­—åˆ™ä»£è¡¨éœ€è¦æ”¯ä»˜çš„é’±ï¼›ç¬¬äºŒè¡Œä¾æ¬¡ç»™å‡ºâ€œé“¾â€ä¸Šæ¯é¢—é’»çŸ³çš„å¯¹åº”çš„ä»·å€¼ï¼ˆç”¨äºŽæ”¯ä»˜ï¼‰ã€‚ ç„¶åŽï¼Œé¢˜ç›®è¦æ±‚ä»Žè¿™æ¡â€œé“¾â€ä¸­æ‰¾å‡ºèƒ½åˆšå¥½ç”¨äºŽæ”¯ä»˜ï¼ˆé’»çŸ³çš„ä»·å€¼å’Œä¸Žå¾…æ”¯ä»˜çš„é’±ç›¸ç­‰ï¼‰çš„â€œé’»çŸ³åºåˆ—â€ï¼Œå½“ç„¶ï¼Œè‹¥æ˜¯æ²¡æœ‰å®Œå…¨ç›¸ç­‰çš„æƒ…å†µï¼Œæ‰¾å‡ºåˆšå¥½å¤§äºŽå¾…æ”¯ä»˜çš„é’±çš„é’»çŸ³åºåˆ—ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ å°†æœ¬ä½“çš„é¢˜æ„æŠ½è±¡å‡ºæ¥å°±æ˜¯ï¼Œç»™å®šä¸€ä¸ªåºåˆ—ï¼Œæ‰¾å‡ºè¿™ä¸ªåºåˆ—ä¸­è¿žç»­å­åºåˆ—å’Œåˆšå¥½å¤§äºŽæˆ–ç­‰äºŽç»™å®šæ•°å­—çš„æ‰€æœ‰å­åºåˆ—ï¼ˆå¦‚æžœæœ‰ç›¸ç­‰çš„æƒ…å†µï¼Œå°±ä¸éœ€è¦å†æ‰¾å¤§äºŽçš„æƒ…å†µï¼‰ã€‚ æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªsumæ•°ç»„æ¥ä¿å­˜è¿žç»­çš„å­åºåˆ—å’Œï¼ˆæ¯æ¬¡ç´¯åŠ å³å¯ï¼‰ï¼Œè¿™æ ·åœ¨iå’Œjä¹‹é—´çš„å­åºåˆ—å’Œå°±æ˜¯sum[j] - sum[i - 1]ï¼Œè¿™ä¸ªæ€æƒ³ä¸Ž 1046 æ˜¯ä¸€è‡´çš„ã€‚è¿™æ ·ï¼Œè¦åšçš„äº‹æƒ…å°±æ˜¯ä»Žsumè¿™ä¸ªæ•°ç»„ä¸­æ‰¾å‡ºæ»¡è¶³æ¡ä»¶çš„åºåˆ—äº†ã€‚åŒæ—¶æ³¨æ„åˆ°ï¼Œç”±äºŽsumæ•°ç»„æ˜¯ç´¯åŠ å¾—å‡ºçš„ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯ä¸¥æ ¼é€’å¢žçš„ï¼Œä¹Ÿå°±å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥æ‰¾è¿™ä¸ªå€¼ã€‚ æ³¨æ„é¢˜ç›®çš„æ¡ä»¶ï¼šIt is guaranteed that the total value of diamonds is sufficient to pay the given amount.ï¼Œè¯´æ˜Žè‚¯å®šä¼šæœ‰è§£ï¼Œé‚£ä¹ˆå¯¹åº”çš„ä¹Ÿå°±åªæœ‰ä¸¤ç§æƒ…å†µï¼š èƒ½æ‰¾åˆ°ç›¸ç­‰çš„åºåˆ—ï¼Œæ­¤æ—¶ç”±äºŽåºåˆ—æœ¬èº«å°±æ˜¯ä¸¥æ ¼é€’å¢žçš„ åªèƒ½æ‰¾åˆ°åˆšå¥½å¤§äºŽç»™å®šå€¼çš„åºåˆ—ï¼Œæ­¤æ—¶éœ€è¦ç”¨ä¸€ä¸ªå˜é‡nearSæ¥ä¿å­˜åˆšå¥½å¤§äºŽç»™å®šå€¼çš„è¿žç»­å­åºåˆ—å’Œ æ‰¾åˆ°åˆç†çš„å€¼åŽï¼ŒæŒ‰ç…§è¿™ä¸ªå€¼è¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int sum[MAXN];int n, S, nearS = 100000000 + 10;int UpperBound(int L, int R, int x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;S); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;sum[i]); sum[i] += sum[i - 1]; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + S); if(sum[j - 1] - sum[i - 1] == S) &#123; nearS = S; break; &#125; else if(j &lt;= n &amp;&amp; sum[j] - sum[i - 1] &lt; nearS) &#123; nearS = sum[j] - sum[i - 1]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + nearS); if(sum[j - 1] - sum[i - 1] == nearS) &#123; printf("%d-%d\n", i, j - 1); &#125; &#125; return 0;&#125;int UpperBound(int L, int R, int x) &#123; int left = L, right = R, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(sum[mid] &gt; x) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; åŽŸæ¥ä½¿ç”¨äºŒåˆ† + å‰ç¼€å’Œçš„æ€è·¯åšçš„ï¼ŒçŽ°åœ¨åˆå†™äº†ä¸€ä¸‹ï¼Œæ€è·¯æ˜¯æ»‘åŠ¨çª—å£ + å‰ç¼€å’Œï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;pair&lt;int, int&gt;&gt; ans1, ans2;const int maxn = 100000 + 5;int arr[maxn];long long prefixsum[maxn];int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; prefixsum[1] = 0; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; prefixsum[i + 1] = prefixsum[i] + arr[i]; &#125; int left = 1, right = 2, minimum = 1000; while(left &lt;= n) &#123; while(right &lt;= n + 1) &#123; if(prefixsum[right] - prefixsum[left] &lt; m) right++; else if(prefixsum[right] - prefixsum[left] == m) &#123; if(right &gt; left) ans1.push_back(&#123;left, right - 1&#125;); else if(right == left) ans1.push_back(&#123;left - 1, right - 1&#125;); break; &#125; else if(prefixsum[right] - prefixsum[left] &gt; m) &#123; int tmp = prefixsum[right] - prefixsum[left] - m; if(tmp &lt; minimum) &#123; ans2.clear(); minimum = tmp; if(right &gt; left) ans2.push_back(&#123;left, right - 1&#125;); else if(right == left) ans2.push_back(&#123;left - 1, right - 1&#125;); &#125; else if(tmp == minimum) &#123; if(right &gt; left) ans2.push_back(&#123;left, right - 1&#125;); else if(right == left) ans2.push_back(&#123;left - 1, right - 1&#125;); &#125; break; &#125; &#125; left++; &#125; if(ans1.size() != 0) &#123; sort(ans1.begin(), ans1.end()); for(auto p: ans1) &#123; cout &lt;&lt; p.first &lt;&lt; '-' &lt;&lt; p.second &lt;&lt; endl; &#125; &#125; else &#123; sort(ans2.begin(), ans2.end()); for(auto p: ans2) &#123; cout &lt;&lt; p.first &lt;&lt; '-' &lt;&lt; p.second &lt;&lt; endl; &#125; &#125; return 0;&#125; è¿™ä¸ªé¢˜çš„æµ‹è¯•ç”¨ä¾‹ä¸­æ²¡æœ‰ 0 çš„å­˜åœ¨...å¼±äº†ä¸å°‘ 1045 Favorite Color StripeAnalysisé¢˜ç›®å¤§æ„ï¼šç”¨ä¸åŒçš„æ•°å­—è¡¨ç¤ºä¸åŒçš„é¢œè‰²ï¼Œä¸€å…±æœ‰ 220 ç§é¢œè‰²ï¼Œç»™å®šä¸€ä¸²æ•°å­—åºåˆ—ï¼Œä½œä¸º Eva å–œæ¬¢çš„é¢œè‰²ç§ç±»ï¼ˆè¶Šé åŽè¶Šå–œæ¬¢ï¼‰ï¼Œç„¶åŽåœ¨ç»™å®šä¸€ä¸²æ•°å­—åºåˆ—ã€‚çŽ°åœ¨ä»Žä¸­æŒ‘å‡º Eva å–œæ¬¢çš„æ‰€æœ‰æ•°å­—ï¼Œå¹¶ä¸”è¦æ±‚æŒ‰ç…§ç»™å®šçš„é¡ºåºè¿›è¡ŒæŽ’åˆ—ï¼Œæ±‚å‡ºè¿™ä¸ªæœ€å¤§çš„é•¿åº¦ã€‚ å¦‚æžœç›´æŽ¥ä½¿ç”¨æš´åŠ›è§£æ³•ï¼Œå®šä¼šè¶…æ—¶ï¼Œè¦æƒ³å®Œç¾Žè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ€è€ƒçš„æ–¹å‘æœ‰ä¸¤ä¸ªï¼Œä½†éƒ½åŒ…å«äº†åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰çš„æ€æƒ³ï¼š ä»Žæœ€é•¿éžé€’å‡åºåˆ—çš„è§’åº¦æ€è€ƒ ä»Žæœ€é•¿å…¬å…±å­ä¸²çš„è§’åº¦æ€è€ƒ CodeLIS123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int stripe[maxn], hashTable[maxc], dp[maxn];int main(int argc, char const *argv[]) &#123; int n, m, x; cin &gt;&gt; n &gt;&gt; m; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; hashTable[x] = i; &#125; int l, num = 0; cin &gt;&gt; l; for(int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; stripe[num++] = hashTable[x]; &#125; int ans = -1; for(int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for(int j = 0; j &lt; i; j++) &#123; if(stripe[j] &lt;= stripe[i] &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; &#125; &#125; ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans; return 0;&#125; LCS123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int A[maxc], B[maxn], dp[maxc][maxn];int main(int argc, char const *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; A[i]; &#125; int l; cin &gt;&gt; l; for(int i = 1; i &lt;= l; i++) &#123; cin &gt;&gt; B[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; dp[i][0] = 0; &#125; for(int j = 1; j &lt;= l; j++) &#123; dp[0][j] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= l; j++) &#123; int Max = max(dp[i - 1][j], dp[i][j - 1]); if(A[i] == B[j]) &#123; dp[i][j] = Max + 1; &#125; else &#123; dp[i][j] = Max; &#125; &#125; &#125; cout &lt;&lt; dp[m][l]; return 0;&#125; 1046 Shortest DistanceAnalysisé¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œç»™ä½ ä¸€ä¸ªâ€œçŽ¯â€å½¢åœ°å›¾ï¼Œé—®ä½ ä»Žè¿™é‡Œåˆ°é‚£é‡Œæ€Žä¹ˆèµ°æœ€è¿‘ã€‚æ ¹æ®é¢˜ç›®æ„æ€ï¼Œä¸€èˆ¬éƒ½æœ‰ä¸¤ç§èµ°æ³•ï¼Œä¸€ç§é¡ºç€çŽ¯èµ°ï¼Œä¸€ç§é€†ç€çŽ¯èµ°ï¼Œæ‰¾å‡ºäºŒè€…çš„æœ€å°å€¼å³å¯ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬åˆ†åˆ«æ‰¾å‡ºå…¶ä¸­ä¸¤æ¬¡çš„å€¼ï¼Œè¿›è¡Œæ¯”è¾ƒåŽè¾“å‡ºæœ€å°å€¼å³å¯ã€‚ä¸è¿‡ç”±äºŽåœ°åæ˜¯æŒ‰ç…§æ•°å­—ç»™å‡ºçš„ï¼Œå¯èƒ½ä¼šå‡ºçŽ°èµ·å§‹ç‚¹çš„æ•°å­—å¤§äºŽç»ˆç‚¹çš„æƒ…å†µï¼Œæ­¤æ—¶æœ€å¥½äº¤æ¢äºŒè€…çš„å€¼ï¼Œæˆ–è€…åˆ†æƒ…å†µè®¨è®ºã€‚ å¦å¤–ï¼Œè¿˜å¯ä»¥å‘çŽ°ï¼Œå¦‚æžœæ±‚å‡ºäº†ä¸€ç§èµ°æ³•ï¼Œé‚£ä¹ˆæŒ‰ç…§çŽ¯å½¢åœ°å›¾çš„ç‰¹ç‚¹ï¼Œåˆ©ç”¨æ€»è·ç¦»å‡åŽ»æ±‚å¾—çš„ä¸å°±å¾—åˆ°å¦ä¸€ç§èµ°æ³•çš„è·ç¦»äº†å—ï¼Ÿ æŠŠæ¡ä½ä¸Šé¢çš„ç‚¹åŽï¼Œå¯ä»¥é€šè¿‡ 0 å’Œ 1 ä¸¤ä¸ªæµ‹è¯•ç‚¹äº†ï¼Œç¬¬ä¸‰ä¸ªæµ‹è¯•ç‚¹ä¼šå› ä¸ºè¶…æ—¶æ— æ³•é€šè¿‡ã€‚ åœ¨ä»”ç»†åˆ†æžä¸€ä¸‹ï¼Œå¦‚æžœä¸€å¼€å§‹ç”¨ä¸€ä¸ªæ•°ç»„Dis[MAXN]ï¼ŒæŒ‰ç…§é¡ºåºè¡¨ç¤º1å·åœ°ç‚¹åˆ°è¾¾å…¶ä»–åœ°ç‚¹çš„è·ç¦»ï¼Œé‚£ä¹ˆå¯¹äºŽæ¯ä¸€æ¬¡æŸ¥è¯¢çš„startå’Œendï¼Œå…¶è·ç¦»å°±æ˜¯Dis[end - 1] - Dis[start - 1]ã€‚ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œå¯ä»¥å¾—åˆ°æ•°ç»„ï¼ˆä¸‹æ ‡ä»Ž1å¼€å§‹ï¼‰Dis[6] = {0, 1, 3, 7, 21, 30}ï¼Œæ­¤æ—¶å¦‚æžœè¦è®¡ç®—5åˆ°2çš„è·ç¦»ï¼Œæ ¹æ®æ€è·¯å°±æ˜¯ï¼šDis[5 - 1] - Dist[2 - 1] = 21 - 1 = 20ï¼Œè¿™å°±æ˜¯æŒ‰é¡ºåºæ–¹å‘ä»Ž2åˆ°5çš„è·ç¦»ã€‚ æ­¤æ³•ææ€–ä¹‹æžåœ¨äºŽåŽŸæœ¬æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ çš„æŸ¥æ‰¾ä¸€ä¸‹å­å°±å˜ä¸º $O(1)$ äº†ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int M, N, Exits[MAXN] = &#123;0&#125;, Dis[MAXN], Sum_D = 0, src, dst; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Exits[i]); Sum_D += Exits[i]; Dis[i] = Sum_D; &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d %d", &amp;src, &amp;dst); if(src &gt; dst) &#123; swap(src, dst); &#125; int temp = Dis[dst - 1] - Dis[src - 1]; printf("%d\n", temp &lt; (Sum_D - temp) ? temp : (Sum_D - temp)); &#125; return 0;&#125; 1047 Student List for CourseAnalysisæ­¤é¢˜ä¸Ž1039çš„é¢˜ç›®èƒŒæ™¯å®Œå…¨ä¸€æ ·ï¼Œè¾“å…¥ä¸Žè¾“å‡ºæ­£å¥½ç›¸åï¼Œæ€è·¯ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚åªæ˜¯æœ¬é¢˜ï¼Œä¸éœ€è¦åœ¨åˆ©ç”¨æ•£åˆ—äº†ã€‚ è¿™ä¸ªé¢˜ä¹Ÿå¯ä»¥ç”¨stringæ¥åšï¼Œä½†æ˜¯è€—è´¹çš„æ—¶é—´ä¼šé•¿ä¸€äº›ï¼Œç”¨æ•°å­—æ¥ä»£æ›¿å­—ç¬¦ä¸²çš„æ¯”è¾ƒä¼šæ–¹ä¾¿å¿«æ·å¾ˆå¤šã€‚ä¸è¿‡è¿™ä¸ªé¢˜ï¼Œç”¨stringä¹Ÿå¯ä»¥è¿‡ã€‚ Codeuse number123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40010;const int maxc = 2510;char name[maxn][5];vector&lt;int&gt; course[maxc];bool cmp(int a, int b) &#123; return strcmp(name[a], name[b]) &lt; 0;&#125;int main(int argc, char const *argv[]) &#123; int n, k, c, courseID; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name[i], &amp;c); for(int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;courseID); course[courseID].push_back(i); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; printf("%d %d\n", i, course[i].size()); sort(course[i].begin(), course[i].end(), cmp); for(int j = 0; j &lt; course[i].size(); j++) &#123; printf("%s\n", name[course[i][j]]); &#125; &#125; return 0;&#125; use string1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int K = 2500 + 5;vector&lt;string&gt; course[K];int main() &#123; int n, k, course_num; scanf("%d %d", &amp;n, &amp;k); char name[5]; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name, &amp;course_num); for(int j = 0; j &lt; course_num; j++) &#123; int course_id; scanf("%d", &amp;course_id); course[course_id].push_back(name); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; sort(course[i].begin(), course[i].end()); printf("%d %d\n", i, course[i].size()); for(int j = 0; j &lt; course[i].size(); j++) &#123; cout &lt;&lt; course[i][j] &lt;&lt; '\n'; &#125; &#125; return 0;&#125; 1048 Find CoinsAnalysisç»™å®šç¡¬å¸ç§ç±»å’Œé¢å€¼ï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚è¾“å‡ºå’Œä¸Žé¢˜ç›®ç›¸ç­‰ä¸¤æžšç¡¬å¸ï¼Œè¦æ±‚V1çš„é¢å€¼å°äºŽç­‰äºŽV2ã€‚åœ¨è¾“å…¥æ—¶ï¼Œåˆ©ç”¨æ•£åˆ—çš„æ€è·¯ï¼Œå…ˆå°†æ¯ä¸€æžšç¡¬å¸çš„ä¸ªæ•°ç»Ÿè®¡ä¸‹æ¥ã€‚ç„¶åŽï¼Œåˆ©ç”¨sortå°†é¢å€¼æŒ‰å‡åºæŽ’åºï¼Œè¿™æ ·æ–¹ä¾¿æŸ¥æ‰¾ã€‚è¾“å‡ºæ—¶æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š V1å’ŒV2ç›¸ç­‰æ—¶ï¼Œè¦åˆ¤æ–­è¿™æžšç¡¬å¸æ—¶å€™æ˜¯å¦æœ‰ä¸¤æžš å½“V1å’ŒV2ç›¸ç­‰æ—¶ï¼Œå°±å·²ç»æ˜¯é¢˜ç›®è¦æ±‚çš„æœ€åŽä¸€ç§æƒ…å†µäº†ï¼Œè‹¥è¿™ç§æƒ…å†µéƒ½ä¸åˆæ¡ä»¶ï¼Œå°±æ²¡å¿…è¦å†ç»§ç»­æŸ¥æ‰¾ä¸‹åŽ»äº†ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªæ ‡è¯†flagæ¥ååŠ©è¾“å‡º æ³¨æ„æ‰€ä½¿ç”¨æ•°ç»„çš„ä¸‹æ ‡ï¼Œä»¥å…è°ƒç”¨sortæ—¶å‡ºé”™ åªè¦V1æœ€å°çš„é‚£ä¸€ç»„å°±è¡Œäº†ï¼Œæ‰€ä»¥è¦åœ¨å¾ªçŽ¯å†…è°ƒç”¨break Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int main(int argc, char const *argv[]) &#123; int N, M, coins[MAXN]; scanf("%d %d", &amp;N, &amp;M); int value[MAXN] = &#123;0&#125;; for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;coins[i]); value[coins[i]]++; &#125; sort(coins + 1, coins + N + 1); int i, v1, v2; bool flag = false; for(i = 1; i &lt;= N; i++) &#123; v1 = coins[i]; v2 = M - v1; if(value[v1] &amp;&amp; value[v2]) &#123; if(v1 == v2 &amp;&amp; value[v1] != 2) &#123; break; &#125; printf("%d %d", v1, v2); flag = true; break; &#125; &#125; if(!flag) &#123; printf("No Solution"); &#125; return 0;&#125; æœ‰äº† C++ çš„ map å°±ä¸éœ€è¦åœ¨æŽ’åºäº†ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int main() &#123; int n, m, tmp; cin &gt;&gt; n &gt;&gt; m; map&lt;int, int&gt; ht; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; ht[tmp]++; &#125; bool flag = false; for(auto it = ht.begin(); it != ht.end(); it++) &#123; int diff = m - it-&gt;first; if(diff == it-&gt;first) &#123; if(it-&gt;second &gt;= 2) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;first; flag = true; break; &#125; &#125; else &#123; if(ht.count(diff)) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; diff; flag = true; break; &#125; &#125; &#125; if(!flag) cout &lt;&lt; "No Solution"; return 0;&#125; å†è´´ä¸ªäºŒåˆ†çš„æ€è·¯ï¼š12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; vector&lt;int&gt; arr(n); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; &#125; sort(arr.begin(), arr.end()); bool flag = false;; for(auto v1 = arr.begin(); v1 != arr.end(); v1++) &#123; auto v2 = lower_bound(arr.begin(), arr.end(), m - *v1); if(v1 != v2 &amp;&amp; *v1 + *v2 == m) &#123; cout &lt;&lt; *v1 &lt;&lt; ' ' &lt;&lt; *v2; flag = true; break; &#125; &#125; if(!flag) cout &lt;&lt; "No Solution"; return 0;&#125; 1049 Counting OnesAnalysisé¢˜æ„å¾ˆç®€å•ï¼Œç»™å®šä¸€ä¸ªæ•°å­— nï¼Œç®—å‡ºä»Ž 1 åˆ° n æ‰€æœ‰çš„æ•°å­—ä¸­ 1 çš„ä¸ªæ•°å’Œã€‚ Codeè¿™ä¸ªé¢˜åŽŸæ¥çš„æ—¶é—´é™åˆ¶æ˜¯ 10 msï¼ŒçŽ°åœ¨æ”¹æˆäº† 400 msï¼Œæ‰€ä»¥ç›´æŽ¥æš´åŠ›ä¹Ÿèƒ½æœ‰ 22 åˆ†ã€‚ä¸è¿‡è¦æƒ³æ‹¿åˆ°æ»¡åˆ†ï¼Œéœ€è¦ä»Žæ•°å­¦çš„è§’åº¦æ¥åˆ†ç±»è®¨è®ºä¸€ä¸‹ã€‚å¯¹äºŽä¸€ä¸ªæ•°çš„æ¯ä¸€ä½æ•°å­— $mid$ è€Œè¨€ï¼š è‹¥ $mid$ ä¸º 0ï¼Œè¦ä½¿ $mid$ ä¸€å®šèƒ½å–åˆ° 1ï¼Œé‚£ä¹ˆå…¶å·¦è¾¹çš„æ•°å­—åªèƒ½å– $[0, n / 10 ^ {k+1} - 1]$ï¼Œå…¶ä¸­ k æ˜¯å³è¾¹æ•°å­—çš„ä½æ•°ï¼Œè€Œå…¶å³è¾¹çš„æ•°åˆ™å¯ä»¥å–åˆ° $[0, 10^k - 1]$ï¼Œé‚£ä¹ˆæ€»å…±èƒ½å–åˆ°çš„æ•°å­—å°±æ˜¯ $n / 10 ^ {k+1} \times 10^k$ã€‚ è‹¥ $mid$ ä¸º 1ï¼Œå…¶å·¦è¾¹çš„æ•°å­—åªèƒ½å– $[0, n / 10 ^ {k+1}]$ï¼Œå…¶ä¸­ $k$ æ˜¯å³è¾¹æ•°å­—çš„ä½æ•°ã€‚æ­¤æ—¶ï¼Œå½“å·¦è¾¹æ•°å­—å– $[0, n / 10 ^ {k+1} - 1]$ æ—¶ï¼Œå³è¾¹æ•°å­—å¯ä»¥å– $[0, 10 ^ k - 1]$ï¼›å½“å·¦è¾¹æ•°å­—å– $n / 10 ^ {k+1}$ æ—¶ï¼Œå³è¾¹æ•°å­—åªèƒ½å– $[0, n \% 10^{k}]$ã€‚é‚£ä¹ˆæ€»å…±èƒ½å–åˆ°çš„æ•°å­—å°±æ˜¯ $n / 10 ^ {k+1} \times 10^k + n % 10^{k} + 1$ã€‚ è‹¥ $mid$ å¤§äºŽ 1ï¼Œå·¦è¾¹èƒ½å–åˆ°çš„æ•°å­—å°±æ˜¯ $[0, n / 10 ^ {k+1}]$ï¼Œå³è¾¹èƒ½å–åˆ°çš„æ•°å­—å°±æ˜¯ $[0, 10 ^ k - 1]$ï¼Œé‚£ä¹ˆæ€»å…±èƒ½å–åˆ°çš„æ•°å­—å°±æ˜¯ $(n / 10 ^ {k+1} + 1) \times 10^k$ã€‚ æ‰€æœ‰æ•°å­—ä¸­ 1 çš„ä¸ªæ•°å°±æ˜¯ä¾æ¬¡æ‹†åˆ†æ•°ä½åˆ†ç±»è®¨è®ºåŽçš„æ€»å’Œã€‚12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int main() &#123; int n, ans = 0; cin &gt;&gt; n; int mask = 1, left, mid, right; while(n / mask != 0) &#123; left = n / (mask * 10); mid = n / mask % 10; right = n % mask; if(mid == 0) ans += left * mask; else if(mid == 1) ans += left * mask + right + 1; else ans += (left + 1) * mask; mask *= 10; &#125; cout &lt;&lt; ans; return 0;&#125; è¿™ä¸ªé¢˜æ€è·¯ä¸æ˜¯é‚£ä¹ˆå¥½æƒ³ã€‚ 1050 String SubtractionAnalysisåˆ©ç”¨æ•£åˆ—çš„æ€æƒ³æ¥å¤„ç†ï¼Œå…ˆéåŽ†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç»Ÿè®¡å…¶ä¸­æ‰€æœ‰å­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼ˆä¹Ÿå¯ä»¥åªç”¨trueæˆ–falseæ¥åŒºåˆ†ï¼‰ï¼Œç„¶åŽéåŽ†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ï¼Œå°†åŒæ—¶å‡ºçŽ°åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²å†…çš„å­—ç¬¦çš„æ¬¡æ•°æ ‡è®°ä¸º0ï¼Œç„¶åŽæŒ‰ç…§ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„é¡ºåºï¼Œè¾“å‡ºæ ‡è®°ä¸æ˜¯0çš„å­—ç¬¦å³å¯ã€‚ Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int times[128] = &#123;0&#125;; char *p = str2; while(*p != '\0') &#123; times[*p++] = 1; &#125; p = str1; while(*p != '\0') &#123; if(!times[*p]) &#123; putchar(*p); &#125; p++; &#125; return 0;&#125; 1051 Pop SequenceAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ ˆçš„å®¹é‡ã€å‡ºæˆ˜åºåˆ—é•¿åº¦å’Œå¯èƒ½çš„å‡ºæ ˆåºåˆ—ï¼Œåˆ¤æ–­åœ¨å½“å‰æ ˆçš„é•¿åº¦ä¸‹ï¼Œå‡ºæ ˆåºåˆ—æ˜¯å¦åˆæ³•ï¼Œè‹¥æ˜¯ï¼Œè¾“å‡ºYESï¼Œåä¹‹ï¼Œè¾“å‡ºNOã€‚ æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚æ¨¡æ‹Ÿæ ˆçš„æ“ä½œå³å¯ï¼Œä½¿ç”¨ C++ çš„stackå®¹å™¨å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ æ³¨æ„æ¯æ¬¡åˆ¤æ–­è¦è®©æ ˆæ¸…ç©ºï¼Œä¸ç„¶ä¼šå½±å“åˆ¤æ–­ã€‚ä¸è¿‡ä¸Žå…¶åå¤æ¸…ç©ºæ ˆï¼Œä¸å¦‚ç›´æŽ¥æ–°å»ºä¸€ä¸ªã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 5;int seq[maxn] = &#123;0&#125;;int main() &#123; int n, m, k, tmp; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; while(k--) &#123; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; int index = 1; bool flag = true; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; st.push(i); if(st.size() &gt; m) &#123; flag = false; break; &#125; while(!st.empty() &amp;&amp; st.top() == seq[index]) &#123; st.pop(); index++; &#125; &#125; if(st.empty() &amp;&amp; flag) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; 1052 Linked List SortingAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯å±žäºŽé“¾è¡¨çš„åº”ç”¨ï¼Œå®žé™…æ˜¯æ¨¡æ‹Ÿé“¾è¡¨çš„æ“ä½œï¼Œä½¿ç”¨é™æ€é“¾è¡¨æ¨¡æ‹Ÿè¾ƒä¸ºæ–¹ä¾¿ã€‚ é™æ€é“¾è¡¨éœ€è¦å€ŸåŠ©æ•£åˆ—çš„æ¦‚å¿µï¼Œå€ŸåŠ©ç»“æž„æ•°ç»„ï¼Œä½¿ç”¨é¢˜ç›®ç»™å®šçš„åœ°å€å¯¹åº”æ•°ç»„çš„ä¸‹æ ‡ï¼Œå¯ä»¥è¾ƒä¸ºæ–¹ä¾¿çš„å­˜å‚¨ç»“ç‚¹å€¼å’Œä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ã€‚ é¢˜ç›®è¦æ±‚çš„æŽ’åºå¯ä»¥ä½¿ç”¨sortå‡½æ•°æ¥å®Œæˆï¼Œæ­¤æ—¶è¦æ³¨æ„ç”±äºŽé¢˜ç›®å¯èƒ½ä¼šè¾“å…¥æ— æ•ˆç»“ç‚¹ï¼Œæ‰€ä»¥éœ€è¦å¢žåŠ ä¸€ä¸ªflagæ¥åˆ¤æ–­æ˜¯å¦å±žäºŽæ— æ•ˆç»“ç‚¹ï¼Œè¿™æ ·sortå‡½æ•°æ‰èƒ½å°†æœ‰æ•ˆç»“ç‚¹æŒ‰åºæŽ’å¥½ï¼Œå¹¶å°†æ— æ•ˆç»“ç‚¹æŽ’åœ¨æœ€åŽä¸€ä¸ªæœ‰æ•ˆç»“ç‚¹çš„åŽé¢ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct Node &#123; int address, data, next; bool flag;&#125; node[maxn];bool cmp(Node a, Node b) &#123; if(a.flag == false || b.flag == false) &#123; return a.flag &gt; b.flag; &#125; else &#123; return a.data &lt; b.data; &#125;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int n, begin, address; scanf("%d %d", &amp;n, &amp;begin); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int count = 0, p = begin; while(p != -1) &#123; node[p].flag = true; count++; p = node[p].next; &#125; if(count == 0) &#123; printf("0 -1"); &#125; else &#123; sort(node, node + maxn, cmp); printf("%d %05d\n", count, node[0].address); for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) &#123; printf("%05d %d %05d\n", node[i].address, node[i].data, node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", node[i].address, node[i].data); &#125; &#125; &#125; return 0;&#125; 1053 Path of Equal WeightAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1054 The Dominant ColorAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªçŸ©é˜µï¼Œæ‰¾å‡ºå…¶ä¸­è¶…è¿‡çŸ©é˜µä¸€åŠå…ƒç´ ä¸ªæ•°çš„å€¼ã€‚é¢˜ç›®ä¿è¯æµ‹è¯•æ ·ä¾‹ä¸­ä¼šæœ‰ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸€åŠçš„çŸ©é˜µå…ƒç´ éƒ½æ˜¯åŒä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæ¯«æ— ç–‘é—®ï¼Œè¿™ä¸ªå…ƒç´ çš„å‡ºçŽ°æ¬¡æ•°ä¸€å®šæ˜¯è¿™ä¸ªçŸ©é˜µæ‰€æœ‰å…ƒç´ å‡ºçŽ°æ¬¡æ•°çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥ç›´æŽ¥æŸ¥æ‰¾æœ€å¤§å€¼å³å¯ã€‚ ç”±äºŽåƒç´ ç‚¹æ˜¯ç”±0-24ä½æ•°å­—å­—ç¬¦ç»„æˆï¼Œæ‰€ä»¥éœ€è¦å°†çŸ©é˜µå†…å…ƒç´ å½“ä½œå­—ç¬¦ä¸²å¯¹å¾…ï¼ŒåŒæ—¶éœ€è¦å»ºç«‹ä¸Žæ¬¡æ•°çš„å”¯ä¸€æ˜ å°„ï¼Œä½¿ç”¨ C++ çš„mapå®¹å™¨å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®Œæˆè¿™ä¸ªæ“ä½œã€‚ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; color;int main(int argc, char const *argv[]) &#123; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; temp = n * m; getchar(); while(temp--) &#123; string s; cin &gt;&gt; s; color[s]++; &#125; temp = n * m; map&lt;string, int&gt;::iterator max = color.begin(); map&lt;string, int&gt;::iterator it = color.begin(); for(; it != color.end(); it++) &#123; if(it-&gt;second &gt; max-&gt;second) &#123; max = it; &#125; &#125; cout &lt;&lt; max-&gt;first; return 0;&#125; ç”¨ C++11 æ ‡å‡†å†™ç®€å•ä¸€ç‚¹ï¼š123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;int, int&gt; ht;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; tmp; ht[tmp]++; &#125; &#125; int ans, condition = (m * n) / 2; for(auto &amp;p: ht) &#123; if(p.second &gt; condition) ans = p.first; &#125; cout &lt;&lt; ans; return 0;&#125; 1055 The Worldâ€™s RichestAnalysiså…ˆæŒ‰ç…§é¢˜ç›®è¦æ±‚æŽ’å¥½åºï¼Œç„¶åŽæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å¹´é¾„åŒºé—´è¿›è¡Œè¾“å‡ºï¼Œæ³¨æ„æ²¡æœ‰ç¬¦åˆçš„è¾“å‡ºæ—¶ï¼Œéœ€è¦è¾“å‡ºNoneã€‚ æ­¤æ—¶ï¼Œè€ƒè™‘åˆ°é¢˜ç›®ç»™çš„æ¡ä»¶$M (\le 100)$ï¼Œè¯´æ˜Žå¯¹äºŽåŒä¸€ä¸ªå¹´é¾„çš„æ•°æ®ï¼Œæœ€å¤šåªè¾“å‡º100é¡¹ã€‚æ‰€ä»¥å¯ä»¥æ–°å»ºä¸€ä¸ªæ•°ç»„ï¼Œç„¶åŽæŒ‰ç…§æŽ’å¥½åºçš„åºåˆ—ï¼Œé¡ºåºä¿å­˜æ¯ä¸ªå¹´é¾„çš„æ•°æ®ï¼Œä½†åªä¿å­˜100ä¸ªï¼Œè¿™æ ·åœ¨æŸ¥æ‰¾çš„æ—¶å€™èƒ½æžå¤§çš„èŠ‚çº¦æ—¶é—´ã€‚ å°½ç®¡è¿™é“é¢˜åœ¨ç”²çº§é¢˜åº“å†…çš„æ—¶é—´é™åˆ¶æ˜¯500msï¼Œè€ƒè¯•çš„æ—¶å€™è¯´ä¸å®šå°±æ˜¯200msäº†ï¼Œè¦æ³¨æ„ç”¨æœ€ä¼˜è§£æ³•ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int Age[MAXN] = &#123;0&#125;;struct people&#123; char name[10]; int age, worth;&#125; peo[MAXN], valid[MAXN];bool cmp(people a, people b);int main(int argc, char const *argv[]) &#123; int N, K; scanf("%d %d", &amp;N, &amp;K); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", peo[i].name, &amp;peo[i].age, &amp;peo[i].worth); &#125; sort(peo, peo + N, cmp); int validNum = 0; for(int i = 0; i &lt; N; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; valid[validNum++] = peo[i]; &#125; &#125; int M, Amin, Amax; for(int i = 1; i &lt;= K; i++) &#123; bool flag = false; scanf("%d %d %d", &amp;M, &amp;Amin, &amp;Amax); printf("Case #%d:\n", i); for(int j = 0; j &lt; validNum &amp;&amp; M; j++) &#123; if(Amin &lt;= valid[j].age &amp;&amp; valid[j].age &lt;= Amax) &#123; printf("%s %d %d\n", valid[j].name, valid[j].age, valid[j].worth); M--; flag = true; &#125; &#125; if(!flag) &#123; printf("None\n"); &#125; &#125; return 0;&#125;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return strcmp(a.name, b.name) &lt; 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct people &#123; string name; int age, worth;&#125; peo[maxn], output[maxn]; int Age[maxn] = &#123;0&#125;;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return a.name &lt; b.name;&#125;int main() &#123; int n, k; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; peo[i].name &gt;&gt; peo[i].age &gt;&gt; peo[i].worth; &#125; sort(peo, peo + n, cmp); int index = 0; for(int i = 0; i &lt; n; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; output[index++] = peo[i]; &#125; &#125; int M, amin, amax; for(int i = 1; i &lt;= k; i++) &#123; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ":" &lt;&lt; endl; cin &gt;&gt; M &gt;&gt; amin &gt;&gt; amax; int cnt = M; for(int i = 0; i &lt; index; i++) &#123; if(amin &lt;= output[i].age &amp;&amp; output[i].age &lt;= amax) &#123; cout &lt;&lt; output[i].name &lt;&lt; ' ' &lt;&lt; output[i].age &lt;&lt; ' ' &lt;&lt; output[i].worth &lt;&lt; endl; if(--cnt == 0) break; &#125; &#125; if(cnt == M) cout &lt;&lt; "None" &lt;&lt; endl; &#125; return 0;&#125; cin å’Œ cout ç¡®å®žæ¯” scanf å’Œ printf æ…¢äº†è®¸å¤š... 1056 Mice and RiceAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯ä¸€ä¸ªå«åš Mice and Rice çš„æ¸¸æˆï¼Œæ ¹æ®é¢˜ç›®çš„æè¿°å¯ä»¥çŸ¥é“ï¼Œä½“é‡æ•°å­—æœ€å¤§çš„è€é¼ å°±æ˜¯èƒœåˆ©çš„è€é¼ ï¼Œå¹¶ä¸”åœ¨æœ¬é¢˜ä¸­ï¼Œè€é¼ ä¹‹é—´çš„æ¯”èµ›éœ€è¦åˆ†ç»„è¿›è¡Œï¼Œåˆ†ç»„å¤§å°ä¼šç»™å‡ºã€‚æ³¨æ„all the mice left will be put into the last groupæ˜¯æŒ‡ï¼Œç”±äºŽå¯èƒ½å­˜åœ¨æœ€åŽä¸€ç»„è€é¼ å°‘äºŽåˆ†ç»„å¤§å°çš„æƒ…å†µï¼Œé»˜è®¤å°†å‰©ä½™çš„è€é¼ å…¨éƒ¨åŠ å…¥åˆ°ä¸‹ä¸€è½®æ¯”èµ›ä¸­ã€‚ä¾æ¬¡è¿›è¡Œæ¯ä¸€è½®æ¯”èµ›ï¼Œç›´è‡³æœ€åŽå¾—åˆ°å† å†›è€é¼ ï¼Œå¹¶è¾“å‡ºæ‰€æœ‰è€é¼ çš„æŽ’åã€‚ æŒ‰ç…§é¢˜ç›®çš„æ„æ€ï¼Œé¢˜ç›®ä¸€å¼€å§‹ä¼šç»™å®šè€é¼ æ€»æ•°å’Œåˆ†ç»„å¤§å°ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥å¾—åˆ°è¿™ä¸€è½®çš„åˆ†ç»„æ•°ï¼›åŒç†ï¼Œæ¯ä¸€è½®çš„åˆ†ç»„æ•°éƒ½å¯ä»¥è¿™æ ·å¾—åˆ°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;struct mouse&#123; int weight; int r;&#125; mouse[maxn];int main(int argc, char const *argv[]) &#123; int np, ng, order; scanf("%d %d", &amp;np, &amp;ng); for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;mouse[i].weight); &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;order); q.push(order); &#125; int temp = np, group; while(q.size() != 1) &#123; if(temp % ng == 0) group = temp / ng; else group = temp / ng + 1; for(int i = 0; i &lt; group; i++) &#123; int k = q.front(); for(int j = 0; j &lt; ng; j++) &#123; if(i * ng + j &gt;= temp) break; int front = q.front(); if(mouse[front].weight &gt; mouse[k].weight) &#123; k = front; &#125; mouse[front].r = group + 1; q.pop(); &#125; q.push(k); &#125; temp = group; &#125; mouse[q.front()].r = 1; for(int i = 0; i &lt; np; i++) &#123; printf("%d", mouse[i].r); if(i &lt; np - 1) putchar(' '); &#125; return 0;&#125; 1058 A+B in HogwartsAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œç»™ä½ ä¸¤ä¸ªåœ¨éœæ ¼æ²ƒèŒ¨æœ¬åœ°ä½¿ç”¨çš„è´§å¸æ•°é‡ï¼ŒåŠ èµ·æ¥å°±å¥½ã€‚å°±è·Ÿç”Ÿæ´»ä¸­$100 + 150 = 250$å—ä¸€æ ·å“ˆã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;struct money&#123; int g, k, s;&#125; A, B, Result;int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;A.g, &amp;A.s, &amp;A.k, &amp;B.g, &amp;B.s, &amp;B.k); Result.g = A.g + B.g; Result.k = A.k + B.k; Result.s = A.s + B.s; if(Result.k &gt;= 29) &#123; Result.s += (Result.k / 29); Result.k %= 29; &#125; if(Result.s &gt;= 17) &#123; Result.g += (Result.s / 17); Result.s %= 17; &#125; printf("%d.%d.%d\n", Result.g, Result.s, Result.k); return 0;&#125; è´´ä¸ªç®€å•ç‰ˆï¼šk1 å’Œ k2 çš„å’Œå¯èƒ½ä¼šè¶…è¿‡ int çš„èŒƒå›´ï¼Œæ‰€ä»¥è¦ä½¿ç”¨ long longã€‚1234567891011121314#include &lt;cstdio&gt;int main() &#123; long long g1, s1, k1, g2, s2, k2; scanf("%lld.%lld.%lld %lld.%lld.%lld", &amp;g1, &amp;s1, &amp;k1, &amp;g2, &amp;s2, &amp;k2); k1 += s1 * 29 + g1 * 29 * 17; k2 += s2 * 29 + g2 * 29 * 17; k1 += k2; g1 = k1 / 29 / 17; s1 = k1 / 29 % 17; k1 = k1 % 29; printf("%lld.%lld.%lld\n", g1, s1, k1); return 0;&#125; 1059 Prime FactorsAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ­£æ•´æ•°ï¼Œç”¨è´¨æ•°å¯¹å…¶è¿›è¡Œåˆ†è§£ï¼Œä¹Ÿå³è´¨å› å­åˆ†è§£ã€‚ æ—¢ç„¶éœ€è¦ç”¨åˆ°è´¨æ•°ï¼Œä¸Žå…¶ä¸€ä¸ªä¸€ä¸ªçš„åˆ¤æ–­ï¼Œä¸å¦‚ä¸€å¼€å§‹å…ˆå°†ç´ æ•°è¡¨æ‰“å°å¥½ï¼Œæ­¤é¢˜ç»™å®šçš„æ•°ä¸ºlong intï¼Œåˆ™ç´ æ•°è¡¨ä¸º$10^5$å³å¯ã€‚ æŽ¥ç€å®šä¹‰ä¸€ä¸ªç»“æž„ä½“æ•°ç»„ï¼Œä¿å­˜è´¨å› å­å’Œå…¶ä¸ªæ•°ã€‚å¯¹äºŽlong intåž‹çš„æ•°è€Œè¨€ï¼Œ2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29å°±å·²ç»æº¢å‡ºäº†ï¼Œæ‰€ä»¥ç»“æž„ä½“æ•°ç»„çš„å¤§å°å–10ä»¥ä¸Šå³å¯ã€‚ ä»Žå°åˆ°å¤§æžšä¸¾è´¨å› å­ï¼Œå¦‚æžœèƒ½æ•´é™¤ç»™å®šçš„æ•°ï¼Œå°±è¿›å…¥å¾ªçŽ¯ï¼Œè®©è¿™ä¸ªæ•°ä¸æ–­çš„æ•´é™¤å®ƒï¼Œä»Žè€Œè®¡ç®—è¿™ä¸ªè´¨å› å­çš„æ•°ç›®ã€‚æ³¨æ„ï¼Œn = 1æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤è¾“å‡º1=1ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100010;bool isPrime(int n) &#123; if(n &lt;= 1) return false; int sqr = sqrt(n); for(int i = 2; i &lt;= sqr; i++) &#123; if(n % i == 0) return false; &#125; return true;&#125;int prime[maxn], pNum = 0;void filterPrime() &#123; for(int i = 1; i &lt; maxn; i++) &#123; if(isPrime(i) == true) &#123; prime[pNum++] = i; &#125; &#125;&#125;struct factor&#123; int x, cnt;&#125; fac[11];int main(int argc, char const *argv[]) &#123; filterPrime(); int n, num = 0; scanf("%d", &amp;n); if(n == 1) printf("1=1"); else &#123; printf("%d=", n); int sqr = sqrt(n); for(int i = 0; i &lt; pNum &amp;&amp; prime[i] &lt;= sqr; i++) &#123; if(n % prime[i] == 0) &#123; fac[num].x = prime[i]; fac[num].cnt = 0; while(n % prime[i] == 0) &#123; fac[num].cnt++; n /= prime[i]; &#125; num++; &#125; if(n == 1) break; &#125; if(n != 1) &#123; fac[num].x = n; fac[num++].cnt = 1; &#125; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0) putchar('*'); printf("%d", fac[i].x); if(fac[i].cnt &gt; 1) &#123; printf("^%d", fac[i].cnt); &#125; &#125; &#125; return 0;&#125; è´´ä¸ª C++ ç‰ˆçš„æ¨¡æ‹Ÿåšæ³•ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;map&lt;long long, int&gt; factors;bool isprime(long long n) &#123; if(n &lt;= 1) return false; else &#123; for(long long i = 2; i &lt;= sqrt(n); i++) &#123; if(n % i == 0) return false; &#125; return true; &#125;&#125;int main() &#123; long long n, tmp, sqr; scanf("%lld", &amp;n); printf("%lld=", n); if(n == 1) printf("%lld", n); else &#123; tmp = n; sqr = sqrt(n); for(long long fa = 2; fa &lt;= sqr; fa++) &#123; if(tmp == 1) break; if(isprime(fa)) &#123; while(tmp % fa == 0) &#123; factors[fa]++; tmp /= fa; &#125; &#125; &#125; if(factors.size() == 0) printf("%lld", n); else &#123; auto it = factors.begin(); while(it != factors.end()) &#123; printf("%lld", it-&gt;first); if(it-&gt;second != 1) printf("^%d", it-&gt;second); it++; if(it != factors.end()) printf("*"); &#125; &#125; &#125; return 0;&#125; åŒæ ·ï¼Œä¸€ä¸ªæ•°çš„æœ€å¤§å› å­ä¸ä¼šè¶…è¿‡å®ƒçš„ç®—æœ¯å¹³æ–¹æ ¹ï¼Œæ‰€ä»¥å¾ªçŽ¯è¾¹ç•Œç›´æŽ¥ç”¨å°±å¥½äº†ã€‚æœ‰äº† map ä¹‹åŽï¼Œå°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»Ÿè®¡è´¨å› å­å’Œå¯¹åº”çš„ä¸ªæ•°ã€‚ 1060 Are They EqualAnalysisè¿™é“é¢˜è€ƒå¯Ÿå­—ç¬¦ä¸²å¤„ç†ï¼Œä½¿ç”¨STLå†…çš„stringå®¹å™¨ï¼Œå¹¶è°ƒç”¨å…¶ä¸­çš„ä¸€äº›æ–¹æ³•ï¼Œä¼šååˆ†æ–¹ä¾¿ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string s, int &amp;e);int main(int argc, char const *argv[]) &#123; string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if(s3 == s4 &amp;&amp; e1 == e2) &#123; cout &lt;&lt; "YES 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; " 0." &lt;&lt; s4 &lt;&lt; "*10^" &lt;&lt; e2 &lt;&lt; endl; &#125; return 0;&#125;string deal(string s, int &amp;e) &#123; unsigned int k = 0; while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); &#125; if(s[0] == '.') &#123; s.erase(s.begin()); while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); e--; &#125; &#125; else &#123; while(k &lt; s.length() &amp;&amp; s[k] != '.') &#123; k++; e++; &#125; if(k &lt; s.length()) &#123; s.erase(s.begin() + k); &#125; &#125; if(s.length() == 0) &#123; e = 0; &#125; int num = 0; k = 0; string res; while(num &lt; n) &#123; if(k &lt; s.length()) &#123; res += s[k++]; &#125; else &#123; res += '0'; &#125; num++; &#125; return res;&#125; 1061 DatingAnalysisè¿™é“é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1014æ˜¯ä¸€æ ·çš„ï¼Œä¸éš¾ï¼Œå°±æ˜¯æœ‰äº›åœ°æ–¹å¥½åƒè¯´çš„ä¸å¤ªæ˜Žç¡®ï¼Œæ¯”å¦‚ï¼Œæ˜ŸæœŸè¿™ä¸ªä¿¡æ¯å¿…é¡»å¾—æ˜¯å±žäºŽ $[A, G]$ çš„å¤§å†™å­—æ¯æ‰èƒ½å¯ä»¥è¿›è¡Œåˆ¤æ–­... Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;char *Week[7] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1062 Talent and VirtueAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“ 1015 ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student &#123; char id[10]; int scoreD, scoreC, sumDC, flag;&#125; stu[MAXN];int N, L, H, M = 0;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumDC = stu[i].scoreD + stu[i].scoreC; if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L) &#123; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= L) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else &#123; stu[i].flag = 4; &#125; M++; &#125; else &#123; stu[i].flag = 5; &#125; &#125; printf("%d\n", M); sort(stu, stu + N, cmp); for(int i = 0; i &lt; M; i++) &#123; printf("%s %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumDC != b.sumDC) return a.sumDC &gt; b.sumDC; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return strcmp(a.id, b.id) &lt; 0;&#125; 1063 Set SimilarityAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè‹¥å¹²ä¸ªé›†åˆï¼Œç»™å‡ºä¸¤ä¸ªé›†åˆçš„â€œç›¸ä¼¼ç¨‹åº¦â€ã€‚è¿™é‡Œçš„â€œç›¸ä¼¼ç¨‹åº¦â€æ˜¯æŒ‡ä¸¤ä¸ªé›†åˆäº¤é›†çš„å…ƒç´ ä¸ªæ•°é™¤ä»¥ä¸¤ä¸ªé›†åˆå¹¶é›†çš„å…ƒç´ ä¸ªæ•°çš„ç™¾åˆ†æ¯”ï¼Œä¸”æ²¡æœ‰é‡å¤å…ƒç´ ã€‚ æŒ‰ç…§é¢˜ç›®èƒŒæ™¯ï¼Œä½¿ç”¨ STL çš„setæ¥å¤„ç†è¿™ä¸ªé—®é¢˜æ¯”è¾ƒæ–¹ä¾¿ï¼Œä¼˜ç‚¹å¦‚ä¸‹ï¼š setåœ¨å­˜å‚¨æ•°æ®æ—¶ï¼Œä¼šè‡ªåŠ¨åŽ»é™¤é‡å¤æ•°æ® setå†…å…ƒç´ çš„ä¸ªæ•°ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨set.size()å¾—åˆ° æŸ¥æ‰¾setå†…å…ƒç´ æ—¶ï¼Œç›´æŽ¥ä½¿ç”¨set.find(elements)å³å¯ ä½¿ç”¨setè¯»å…¥æ‰€æœ‰è¾“å…¥æ•°æ®åŽï¼Œå¼€å§‹æŸ¥è¯¢ã€‚æ¯æ¬¡æŸ¥è¯¢éœ€è¦å¾—åˆ°ä¸€ä¸ªç™¾åˆ†æ¯”ï¼Œæ‰€ä»¥å°±éœ€è¦æ±‚ä¸¤ä¸ªé›†åˆäº¤é›†çš„å…ƒç´ ä¸ªæ•°å’Œå¹¶é›†çš„å…ƒç´ ä¸ªæ•°ã€‚ å…·ä½“æ–¹æ³•æ˜¯ï¼šéåŽ†å…¶ä¸­ä¸€ä¸ªé›†åˆï¼Œä»¤totalNumä¸ºå¦ä¸€ä¸ªé›†åˆçš„å…ƒç´ ä¸ªæ•°ï¼ŒsameNumä¸ºç›¸åŒå…ƒç´ çš„ä¸ªæ•°ï¼ˆåˆå§‹åŒ–ä¸º0ï¼‰ã€‚æ­¤æ—¶åœ¨å¦ä¸€ä¸ªé›†åˆä¸­æŸ¥æ‰¾å½“å‰éåŽ†çš„é›†åˆä¸­çš„å…ƒç´ ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™sameNum++ï¼Œåä¹‹åˆ™totalNum++ï¼ŒéåŽ†ç»“æŸåŽï¼Œéœ€è¦çš„æ•°å­—å°±ç®—å¥½äº†ï¼ŒæŽ¥ç€ç›¸é™¤å¾—åˆ°ç™¾åˆ†æ¯”å³å¯è¾“å‡ºã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int MAXN = 50 + 5;set&lt;int&gt; st[MAXN];void compare(int x, int y) &#123; int totalNum = st[y].size(), sameNum = 0; for(set&lt;int&gt;::iterator it = st[x].begin(); it != st[x].end(); it++) &#123; if(st[y].find(*it) != st[y].end()) sameNum++; else totalNum++; &#125; printf("%.1lf%\n", sameNum * 100.0 / totalNum);&#125;int main(int argc, char const *argv[]) &#123; int n, m, k, temp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;m); for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;temp); st[i].insert(temp); &#125; &#125; scanf("%d", &amp;k); while(k--) &#123; int s1, s2; scanf("%d %d", &amp;s1, &amp;s2); compare(s1, s2); &#125; return 0;&#125; å†™ç®€å•ä¸€ç‚¹ï¼š123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;set&gt; using namespace std;const int maxn = 50 + 5;set&lt;int&gt; st[maxn];int main() &#123; int n, m, k; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; m; for(int j = 0; j &lt; m; j++) &#123; int tmp; cin &gt;&gt; tmp; st[i].insert(tmp); &#125; &#125; cin &gt;&gt; k; while(k--) &#123; int set1, set2, nc = 0, nt; cin &gt;&gt; set1 &gt;&gt; set2; nt = st[set2].size(); for(auto &amp;tmp: st[set1]) &#123; if(st[set2].count(tmp)) nc++; else nt++; &#125; printf("%.1lf%%\n", nc * 100.0 / nt); &#125; return 0;&#125; 1064 Complete Binary Search TreeAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç»“ç‚¹ä¸ªæ•°å’Œç»“ç‚¹å€¼ï¼Œå»ºç«‹ä¸€é¢—å®Œå…¨äºŒå‰æŽ’åºæ ‘ï¼ˆCBTï¼‰ï¼Œæ ¹æ®åç§°ï¼Œå¯ä»¥çŸ¥é“è¿™ç±»æ ‘æ—¢æœ‰å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼Œåˆæœ‰äºŒå‰æŽ’åºæ ‘çš„æ€§è´¨ã€‚ ç»è¿‡ä¸Šé¢çš„åˆ†æžï¼Œä½¿ç”¨ç»“æž„æ•°ç»„å»ºæ ‘å°±ååˆ†æ–¹ä¾¿ï¼Œå¯¹å®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼Œæ•°ç»„çš„ä¸‹æ ‡å³ä»£è¡¨ç»“ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•´åž‹æ•°ç»„å³å¯ï¼Œå¹¶ä¸”åœ¨æ•°ç»„çš„é¡ºåºå°±æ˜¯å±‚æ¬¡éåŽ†çš„åºåˆ—ã€‚æŽ¥ç€è¦è§£å†³çš„é—®é¢˜å°±æ˜¯å°†ç»“ç‚¹å€¼èµ‹ç»™ç»“ç‚¹ï¼Œæ ¹æ®äºŒå‰æŽ’åºæ ‘çš„æ€§è´¨ï¼Œåˆ©ç”¨ä¸­åºéåŽ†å³å¯å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int n, number[maxn], CBT[maxn], index = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); CBT[root] = number[index++]; inorder(root * 2 + 1);&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(1); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; CBT[i]; if(i &lt; n) cout &lt;&lt; ' '; &#125; return 0;&#125; 1065 A+B and C (64bit)Analysisè¿™é“é¢˜ç®—æ˜¯ä¹™çº§é¢˜ç›®1011 A+B å’Œ Cçš„åŠ å¼ºç‰ˆäº†ï¼Œé¢˜ç›®ç»™å®šçš„æ•°æ®èŒƒå›´æ˜¯$(-2^{63}, 2^{63})$ï¼Œæ­£å¥½æ˜¯64ä½å¸¦ç¬¦å·æ•´åž‹çš„æ•°æ®èŒƒå›´ï¼Œä¸‹é¢æ¥åˆ†æžå¯èƒ½å‡ºçŽ°çš„å„ç§æƒ…å†µï¼ˆåªç”¨å¯¹Aå’ŒBä¹‹å’Œåˆ†æžå°±å¥½ï¼‰ï¼š Aå’ŒBä¹‹å’Œä»ç„¶åœ¨$(-2^{63}, 2^{63})$ä¹‹å†…ï¼Œå¯ä»¥ç›´æŽ¥ä¸ŽCè¿›è¡Œåˆ¤æ–­ Aå’ŒBä¹‹å’Œå¤§äºŽ$2^{63}$ï¼Œæ­¤æ—¶ä¼šå‘ç”Ÿæ­£æº¢å‡ºï¼Œä¸”å…¶å€¼çš„èŒƒå›´ä¸ºï¼š$[-2^{63}, -2]$ï¼ˆæº¢å‡ºè¿›ä½ï¼Œç¬¦å·ä¸ºä»Ž0å˜ä¸º1ï¼Œæ‰€ä»¥ä¸ºè´Ÿï¼Œå‰©ä¸‹63ä½æž„æˆçš„æ•°å­—å°±åœ¨è¿™ä¸ªèŒƒå›´å†…äº†ï¼‰ã€‚ Aå’ŒBä¹‹å’Œå°äºŽ$-2^{63}$ï¼Œæ­¤æ—¶ä¼šå‘ç”Ÿè´Ÿæº¢å‡ºï¼Œå…¶å€¼èŒƒå›´ä¸ºï¼š$[0, 2^{63})$ï¼ˆåŽŸç†ç±»ä¼¼ï¼‰ å¯¹åº”ä¸Šè¿°ä¸‰ç§æƒ…å†µï¼ŒæŒ‰ç…§å®žé™…è§„åˆ™è¿›è¡Œæ¯”å¤§å°å³å¯ã€‚ Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; ä»¥ä¸Šæ˜¯åŽŸæ¥æœªæ›´æ–°æµ‹è¯•æ•°æ®ä¹‹å‰çš„ AC ä»£ç ï¼ŒçŽ°åœ¨åªèƒ½æ‹¿åˆ° 16 åˆ†äº†ï¼Œæœ€åŽä¸€ä¸ªæµ‹è¯•ç‚¹æ— æ³•é€šè¿‡ã€‚ç©¶å…¶åŽŸå› ï¼Œå…¶å®žæ˜¯è¿™ä¸ªé¢˜ç›®åˆå¼€å§‹çŽ©æ–‡å­—æ¸¸æˆäº†ï¼ŒC çš„èŒƒå›´æ˜¯ $(2^{-63}, 2^{63})$ï¼Œä½† A å’Œ B ä¸æ˜¯çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ A å’Œ B çš„ä½æ•°å¯èƒ½è¦è¶…è¿‡ 9223372036854775807ã€‚ä»Žè¿™é‡Œå¼€å§‹ï¼Œè¿™ä¸ªé¢˜è€ƒå¯Ÿçš„å†…å®¹å°±ä¸å†æ˜¯å¯¹æ•°æ®æº¢å‡ºçš„åˆ¤æ–­äº†ï¼Œé‚£è€ƒå¯Ÿä»€ä¹ˆï¼Ÿè€ƒå¯Ÿçš„æ˜¯cinå’Œscanf ä»Žè¾“å…¥æµèŽ·å–è¾“å…¥çš„å·®åˆ«ï¼Œä¹Ÿä¸çŸ¥é“è¿™æ ·æ”¹æ˜¯ä¸ºäº†ä»€ä¹ˆðŸ˜“ã€‚è‡³äºŽcinå’Œscanfæœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œå¾—å•ç‹¬å†™æ–‡ç« æ€»ç»“ï¼ŒçŽ°åœ¨è´´å‡º AC çš„ä»£ç ï¼ˆå…¶å®žå°±åªæ˜¯æ¢æŽ‰äº†cinè€Œå·²ï¼‰ï¼š12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; scanf("%lld %lld %lld", &amp;a, &amp;b, &amp;c); cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; çœ‹åˆ°è¿™é‡Œï¼Œä¸€ä¸Šæ¥å°±ç”¨cinçš„äººï¼Œä¼°è®¡è¦è¢«æ°”åè¡€äº†ã€‚æŒ‰ç…§å‡ºé¢˜äººçš„æ„å›¾å’Œè¿™é“é¢˜çš„åˆ†å€¼è€Œè¨€ï¼Œè€ƒå¯Ÿäº†æº¢å‡ºçš„ç›¸å…³çŸ¥è¯†å°±å¯ä»¥äº†ã€‚è¿™æ ·æ”¹äº†ä¹‹åŽï¼Œè¿˜éœ€è¦å¯¹åº“å‡½æ•°æœ‰ä¸€å®šçš„äº†è§£ã€‚å½“ç„¶ï¼Œç›´æŽ¥ä¸Šæ¥å°±ç”¨scanfçš„ï¼Œå½“æˆ‘æ²¡è¯´ã€‚ä½†é’ˆå¯¹è¿™é“é¢˜è€Œè¨€ï¼Œè¿˜æœ‰ä¸€ç§åšæ³•ï¼Œé‚£å°±æ˜¯é€‰ç”¨æ›´é«˜ç²¾åº¦çš„æ•°æ®ç±»åž‹ long doubleï¼Œå¦‚ä¸‹ï¼š1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; long double a, b, c; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; åœ¨ C++11 æ ‡å‡†ä¸­æµ‹è¯•ï¼Œlong doubleçš„æ•°æ®ç±»åž‹å äº† 16 ä¸ªå­—èŠ‚ï¼Œèƒ½è¡¨ç¤ºç›¸å½“å¤§çš„æ•°äº†ã€‚ 1066 Root of AVL TreeAnalysisé¢˜ç›®å¤§æ„ç»™å®šä¸€æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œå†ç»™å®šå„ä¸ªç»“ç‚¹çš„å€¼ï¼Œå»ºç«‹ä¸€é¢—å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVLï¼‰ï¼Œç„¶åŽè¾“å‡ºç»“ç‚¹çš„å€¼å³å¯ã€‚ ç”±äºŽé¢˜ç›®éœ€è¦å»ºç«‹ AVL æ ‘ï¼Œä¾æ® AVL æ ‘çš„æ€§è´¨ï¼Œæ¯ä¸ªç»“ç‚¹çš„å¹³è¡¡å› å­ç»å¯¹å€¼ä¸èƒ½å¤§äºŽ1ï¼Œæ‰€ä»¥åœ¨æ’å…¥æ¯ä¸ªç»“ç‚¹æ—¶ï¼Œéœ€è¦å¯¹æ ‘è¿›è¡Œè°ƒæ•´ï¼Œä½¿å…¶æ»¡è¶³ AVL æ ‘çš„æ€§è´¨ã€‚ AVL æ ‘å¤±è¡¡çš„æƒ…å†µæ€»å…±æœ‰4ç§ï¼šLLã€LRã€RR å’Œ RL å››ç§ï¼Œä¼šæ ¹æ®æ¯ç§æƒ…å†µåšå¯¹åº”çš„æ—‹è½¬å³å¯ã€‚æ³¨æ„æ¯æ¬¡æ’å…¥ç»“ç‚¹æ—¶éƒ½éœ€è¦æ£€æŸ¥æ ‘æ˜¯å¦å¤±è¡¡ï¼Œè¿™æ ·èƒ½å¤ŸåŠæ—¶è°ƒæ•´ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 25;struct node &#123; int v, height; node *left, *right;&#125; *root;int n;node *newnode(int v) &#123; node *Node = new node; Node-&gt;v = v; Node-&gt;height = 1; Node-&gt;left = Node-&gt;right = NULL; return Node;&#125;int getheight(node *root) &#123; if(root == NULL) return 0; return root-&gt;height;&#125;void updateheight(node *root) &#123; root-&gt;height = max(getheight(root-&gt;left), getheight(root-&gt;right)) + 1;&#125;int getbalancefactor(node *root) &#123; return getheight(root-&gt;left) - getheight(root-&gt;right);&#125;void leftRotation(node *&amp;root) &#123; node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; updateheight(root); updateheight(temp); root = temp;&#125;void rightRotation(node *&amp;root) &#123; node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; updateheight(root); updateheight(temp); root = temp;&#125;void insert(node *&amp;root, int v) &#123; if(root == NULL) &#123; root = newnode(v); return; &#125; if(v &lt; root-&gt;v) &#123; insert(root-&gt;left, v); updateheight(root); if(getbalancefactor(root) == 2) &#123; if(getbalancefactor(root-&gt;left) == 1) &#123; rightRotation(root); &#125; else if(getbalancefactor(root-&gt;left) == -1) &#123; leftRotation(root-&gt;left); rightRotation(root); &#125; &#125; &#125; else &#123; insert(root-&gt;right, v); updateheight(root); if(getbalancefactor(root) == -2) &#123; if(getbalancefactor(root-&gt;right) == -1) &#123; leftRotation(root); &#125; else if(getbalancefactor(root-&gt;right) == 1) &#123; rightRotation(root-&gt;right); leftRotation(root); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int value; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; insert(root, value); &#125; cout &lt;&lt; root-&gt;v; return 0;&#125; 1067 Sort with SwapAnalysisè¿™é“é¢˜è€ƒå¯Ÿè´ªå¿ƒï¼Œå‚æ‚äº†ä¸€äº›æ¨¡æ‹Ÿã€‚ å¯¹å¾…è´ªå¿ƒç±»çš„é¢˜ç›®ï¼Œå¿…é¡»å¾—æ‰¾å‡†è´ªå¿ƒçš„ç­–ç•¥ï¼Œä¸ç„¶å°±æ²¡æ³•è§£é¢˜äº†ï¼Œå¾—ä»”ç»†è§‚å¯Ÿæ ·ä¾‹ã€‚å‡è®¾æ•°å­—éƒ½å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¯´æ˜Žï¼Œå¯ä»¥å‘çŽ°ï¼š0å€¼æ¯æ¬¡äº¤æ¢çš„å¯¹è±¡éƒ½æ˜¯ä¸‹æ ‡å€¼ä¸Žå…¶æœ¬èº«å€¼ä¸ä¸€æ ·çš„æ•°å­—ã€‚æ‰€ä»¥ï¼Œæ¯æ¬¡å°†0å€¼ä¸Žå…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„å€¼äº¤æ¢å³å¯ï¼›ä½†è¦æ³¨æ„ï¼Œè‹¥0çš„ä¸‹æ ‡ä¸º0æ—¶ï¼Œç®—æ³•å°±æ— æ³•ç»§ç»­è¿›è¡Œäº†ï¼Œæ­¤æ—¶éœ€è¦ç‰¹åˆ«å¤„ç†ä¸‹ï¼Œå°†0ä¸Žå½“å‰å€¼æœ€å°ä¸”å…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„æ•°å­—ç›´æŽ¥è¿›è¡Œäº¤æ¢ã€‚ è¿™æ—¶å¯ä»¥å‘çŽ°ï¼Œå¦‚æžœä»Žæ•°ç»„å¤´éƒ¨å¼€å§‹å‘åŽæŸ¥æ‰¾è¿™æ ·çš„æ•°å­—ï¼Œå°±ä¼šæœ‰å¾ˆå¤šå·²ç»æŽ’å¥½çš„æ•°è¢«éåŽ†åˆ°ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„æƒ…å†µï¼Œéœ€è¦å°†å½“å‰å€¼æœ€å°ä¸”å…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„æ•°å­—ä¿å­˜åœ¨ä¸€ä¸ªå˜é‡å†…ï¼Œè¿™æ ·ä¸‹æ¬¡æŸ¥æ‰¾æ—¶ç›´æŽ¥ä»Žè¿™ä¸ªæ•°å­—å¼€å§‹å°±å¯ä»¥é¿å…é‡å¤æŸ¥æ‰¾çš„æƒ…å†µäº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int pos[MAXN];int main(int argc, char const *argv[]) &#123; int n, ans = 0; scanf("%d", &amp;n); int left = n - 1, num; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); pos[num] = i; if(num == i &amp;&amp; num != 0) &#123; left--; &#125; &#125; int k = 1; while(left &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; left--; &#125; &#125; printf("%d\n", ans); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn = 100000 + 5;int arr[maxn];unordered_map&lt;int, int&gt; numandindex;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; arr[i]; numandindex[arr[i]] = i; &#125; int index0 = numandindex[0], i = 0; while(true) &#123; if(index0 == 0) &#123; for(; i &lt; n; i++) &#123; if(arr[i] != i) break; &#125; if(i != n) &#123; numandindex[arr[i]] = 0; numandindex[0] = i; &#125; else break; &#125; int index = numandindex[index0]; swap(arr[index0], arr[index]); cnt++; index0 = index; &#125; cout &lt;&lt; cnt; return 0;&#125; æœ¬è´¨ä¸Šæ˜¯ä¸‹æ ‡åœ¨äº¤æ¢ï¼Œæ‰€ä»¥ç”¨ä¸€ä¸ª map æ¥å»ºç«‹æ•°ç»„å…ƒç´ ä¸Žå¯¹åº”ä¸‹æ ‡çš„æ˜ å°„ï¼Œè¿™æ ·ç†è§£èµ·æ¥ä¼šæ¸…æ¥šä¸€äº›ã€‚ 1069 The Black Hole of NumbersAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1019ä¸€æ · Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1070 MooncakeAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1020ç±»ä¼¼ï¼ˆå¥½åƒåªæ˜¯æ•°æ®ä¸ä¸€æ ·ï¼‰ï¼Œè€ƒå¯Ÿè´ªå¿ƒã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; ans += cake[i].sell; D -= cake[i].store; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125;bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1071 Speech PatternsAnalysisé¢˜ç›®è¦æ±‚è¾“å…¥ä¸€å¥è¯ï¼Œè¾“å‡ºå…¶ä¸­å‡ºçŽ°æ¬¡æ•°æœ€é•¿çš„å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²åªèƒ½åŒ…å«0-9ã€A-Zå’Œa-zå†…çš„å­—ç¬¦ï¼Œå…¶ä»–å­—ç¬¦å‡è¢«è®¤ä¸ºæ˜¯å­—ç¬¦ä¸²ä¹‹é—´çš„åˆ†éš”ç¬¦ã€‚ å…ˆå°†å­—ç¬¦ä¸²æ•´è¡Œè¯»å…¥ï¼Œåœ¨é€ä¸ªæ‹†åˆ†å‡ºæ¯ä¸ªå•è¯ï¼Œå¹¶åˆ©ç”¨mapæ¥å»ºç«‹å­—ç¬¦ä¸²ï¼ˆstringï¼‰ä¸Žæ¬¡æ•°ï¼ˆintï¼‰ä¹‹é—´çš„æ˜ å°„ï¼Œæ¯ç»Ÿè®¡åˆ°ç›¸åŒçš„å­—ç¬¦ä¸²ï¼Œæ¬¡æ•°åŠ 1ã€‚ è¾“å‡ºæ—¶ï¼ŒéåŽ†mapï¼Œæ‰¾å‡ºå…¶ä¸­å‡ºçŽ°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦ä¸²å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; mp;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; if('a' &lt;= c &amp;&amp; c &lt;= 'z') return true; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') return true; return false;&#125;int main(int agrc, char const *argv[]) &#123; map&lt;string, int&gt; count; string str; getline(cin, str); int i = 0; while(i &lt; str.length()) &#123; string word; while(i &lt; str.length() &amp;&amp; check(str[i]) == true) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] += 32; &#125; word += str[i]; i++; &#125; if(word != "") &#123; if(count.find(word) == count.end()) count[word] = 1; else count[word]++; &#125; while(i &lt; str.length() &amp;&amp; check(str[i]) == false) &#123; i++; &#125; &#125; string ans; int max = 0; for(map&lt;string, int&gt;::iterator it = count.begin(); it != count.end(); it++) &#123; if(it-&gt;second &gt; max) &#123; max = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; max; return 0;&#125; å†™ç®€å•ä¸€ç‚¹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cctype&gt;using namespace std;map&lt;string, int&gt; stringcnt;const int maxn = 1048576 + 10;int main() &#123; string str, tmp; getline(cin, str); int maxcnt = 0; for(int i = 0; i &lt; str.length(); i++) &#123; if(isalnum(str[i])) &#123; if(isupper(str[i])) str[i] = tolower(str[i]); tmp.push_back(str[i]); &#125; if(!isalnum(str[i]) || i == str.length() - 1) &#123; if(tmp != "") &#123; stringcnt[tmp]++; maxcnt = max(maxcnt, stringcnt[tmp]); &#125; tmp.clear(); &#125; &#125; for(auto &amp;p: stringcnt) &#123; if(p.second == maxcnt) &#123; cout &lt;&lt; p.first &lt;&lt; ' ' &lt;&lt; p.second; break; &#125; &#125; return 0;&#125; ä»¥ä¸ºå¯ä»¥ç›´æŽ¥ç”¨ç©ºæ ¼å­—ç¬¦ä½œä¸ºå•è¯çš„åˆ†éš”ç¬¦ï¼Œç»“æžœä»”ç»†ä¸€çœ‹Here a &quot;word&quot; is defined as a continuous sequence of alphanumerical characters separated by non-alphanumerical characters or the line beginning/end.ï¼Œä¹Ÿå°±æ˜¯è¯´é¢˜ç›®æ²¡è¯´ä¸€å®šä¼šç”¨ç©ºæ ¼æ¥åˆ†éš”å•è¯ï¼Œè¿™æ ·å°±æ²¡æ³•åˆ©ç”¨ cin å’Œ scanf è‡ªåŠ¨æŒ‰ç©ºæ ¼è¯»å…¥ç‰¹æ€§äº†ï¼Œåªèƒ½èŽ·å–ä¸€è¡ŒåŽé€ä¸ªæå–å‡ºæ¥ã€‚æœ€åŽä¸€ä¸ªå•è¯çš„ç»“å°¾ä¹Ÿå¯èƒ½æ˜¯å­—æ¯ã€æ•°å­—ï¼Œæ‰€ä»¥ä¹Ÿè¦ç»Ÿè®¡åœ¨å†…ï¼Œæµ‹è¯•ç‚¹ 4 åº”è¯¥æ˜¯è¿™æ ·ã€‚ 1072 Gas StationAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè‹¥å¹²ä¸ªæºç‚¹å’Œå›ºå®šç‚¹ï¼Œæ±‚è¿™äº›æºç‚¹åˆ°æ‰€æœ‰å›ºå®šç‚¹è·ç¦»æœ€å°çš„æºç‚¹ï¼Œå¦‚æžœå­˜åœ¨ç›¸åŒè§£ï¼Œå°±è¾“å‡ºå¹³å‡è·ç¦»æœ€å°çš„æºç‚¹ã€‚ æŒ‰ç…§é¢˜ç›®å¤§æ„ï¼Œå¯ä»¥å°†é¢˜ç›®æè¿°æŠ½è±¡ä¸ºå›¾ï¼ŒæŽ¥ç€åˆ©ç”¨ Dijkstra ç®—æ³•å°±å¯ä»¥æ±‚è§£æºç‚¹åˆ°å›ºå®šç‚¹çš„æœ€çŸ­è·ç¦»ï¼›ç”±äºŽé¢˜ç›®ç»™å®šçš„æºç‚¹æœ‰å¤šä¸ªï¼Œæ‰€ä»¥è¦ä½¿ç”¨å¤šæ¬¡ Dijkstra ç®—æ³•ï¼Œæ‰€ä»¥æ¯æ¬¡æ‰§è¡Œç®—æ³•ä¹‹å‰éœ€è¦å°†ç”¨åˆ°çš„boolæ•°ç»„åˆå§‹åŒ–ä¸ºfalseã€‚ç„¶åŽï¼ŒæŒ‰ç…§é¢˜ç›®æ¡ä»¶æ¥åˆ¤æ–­æˆ–ç­›é€‰æœ€ä¼˜è§£ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1020;const int inf = 0x3fffffff;int n, m, k, ds, G[maxv][maxv];int d[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; memset(vis, false, sizeof(vis)); //do not forget initializing this array fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n + m; i++) &#123; int u = -1, min = inf; for(int j = 1; j &lt;= n + m; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 1; v &lt;= n + m; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int getid(char str[]) &#123; //tranfer the id of gas station int len = strlen(str), id = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != 'G') id = id * 10 + (str[i] - '0'); &#125; if(str[0] == 'G') return n + id; else return id;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;ds); int u, v, w; char city1[5], city2[5]; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 0; i &lt; k; i++) &#123; scanf("%s %s %d", city1, city2, &amp;w); u = getid(city1); v = getid(city2); G[v][u] = G[u][v] = w; &#125; double ansdis = -1, ansavg = inf; int ansid = -1; for(int i = n + 1; i &lt;= n + m; i++) &#123; double mindis = inf, avg = 0; dijkstra(i); //every station should execute this dijkstra for(int j = 1; j &lt;=n; j++) &#123; if(d[j] &gt; ds) &#123; //this solution does not fit the problem mindis = -1; break; &#125; if(d[j] &lt; mindis) mindis = d[j]; //cal minimum of distance avg += 1.0 * d[j] / n; //calculate the average &#125; if(mindis == -1) continue; if(mindis &gt; ansdis) &#123; //more optimal solution ansid = i; ansdis = mindis; ansavg = avg; &#125; else if(mindis == ansdis &amp;&amp; avg &lt; ansavg) &#123; //more optimal solution ansid = i; ansavg = avg; &#125; &#125; if(ansid == -1) printf("No Solution\n"); else &#123; printf("G%d\n", ansid - n); printf("%.1lf %.1lf\n", ansdis, ansavg); &#125; return 0;&#125; 1073 Scientific NotationAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1024ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int Epos, exp = 0; for(Epos = 1; Num[Epos] != 'E'; Epos++); for(int i = Epos + 2; Num[i] != '\0'; i++) &#123; exp = exp * 10 + Num[i] - '0'; &#125; if(Num[0] == '-') &#123; putchar(Num[0]); &#125; if(exp == 0) &#123; for(int i = 1; Num[i] != 'E'; i++) &#123; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '-') &#123; printf("0."); for(int i = exp - 1; i &gt; 0; i--) &#123; putchar('0'); &#125; for(int i = 1; Num[i] != 'E'; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '+') &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == exp + 2 &amp;&amp; Epos - 3 != exp) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; exp - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; putchar('\n'); return 0;&#125; 1074 Reversing Linked ListAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1025ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node&#123; int address, data, next; int order;&#125; Node[maxn];bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125; int head, n, k, address; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].data, &amp;Node[address].next); Node[address].address = address; &#125; int p = head, count = 0; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) &#123; printf("-1\n"); &#125; else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1075 PAT JudgeAnalysisè€ƒå¯ŸæŽ’åºï¼Œé¢˜ç›®è¯´æ˜Žæ¯”è¾ƒå¤šï¼Œè¦ä»”ç»†è¯»é¢˜ã€‚å…³é”®æ˜¯è¾“å…¥æ•°æ®çš„å¤„ç†ï¼Œå¤„ç†åŽè¦è¾¾åˆ°ä¾¿äºŽæŽ’åºï¼ˆä¸Žé¢˜ç›®ä¸€è‡´ï¼‰å’Œè¾“å‡ºçš„æ•ˆæžœã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;struct user&#123; int id, score[6], sum, perfect; bool flag;&#125; us[MAXN];int N, K, M;int full[6] = &#123;0&#125;;bool cmp(user a, user b);void Init();int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;K, &amp;M); Init(); for(int i = 1; i &lt;= K; i++) &#123; scanf("%d", full + i); &#125; int uid, pid, score_ob; for(int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;uid, &amp;pid, &amp;score_ob); if(score_ob != -1) &#123; us[uid].flag = true; &#125; if(score_ob == -1 &amp;&amp; us[uid].score[pid] == -1) &#123; us[uid].score[pid] = 0; &#125; if(score_ob == full[pid] &amp;&amp; us[uid].score[pid] &lt; full[pid]) &#123; us[uid].perfect++; &#125; if(score_ob &gt; us[uid].score[pid]) &#123; us[uid].score[pid] = score_ob; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] != -1) &#123; us[i].sum += us[i].score[j]; &#125; &#125; &#125; sort(us + 1, us + N + 1, cmp); int r = 1; for(int i = 1; i &lt;= N &amp;&amp; us[i].flag == true; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) &#123; r = i; &#125; printf("%d %05d %d", r, us[i].id, us[i].sum); for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] == -1) &#123; printf(" -"); &#125; else &#123; printf(" %d", us[i].score[j]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void Init() &#123; for(int i = 1; i &lt;= N; i++) &#123; us[i].id = i; us[i].sum = 0; us[i].perfect = 0; us[i].flag = false; memset(us[i].score, -1, sizeof(us[i].score)); &#125;&#125; é‡æ–°å†™äº†ä¸€ä¸‹ï¼Œæ•´ä½“æ€è·¯ä¸å˜ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 5;struct student &#123; int id, grade[6], cnt; bool flag;&#125; stu[maxn];int perfect[6], n, k, m;bool cmp(student a, student b) &#123; if(a.grade[0] != b.grade[0]) return a.grade[0] &gt; b.grade[0]; else if(a.cnt != b.cnt) return a.cnt &gt; b.cnt; else return a.id &lt; b.id; &#125;void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; stu[i].id = i; stu[i].cnt = 0; stu[i].flag = false; memset(stu[i].grade, -1, sizeof(stu[i].grade)); stu[i].grade[0] = 0; &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); Init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", &amp;perfect[i]); &#125; int id, grade, pronum; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;pronum, &amp;grade); if(grade != -1) stu[id].flag = true; if(grade == -1 &amp;&amp; stu[id].grade[pronum] == -1) stu[id].grade[pronum] = 0; if(grade == perfect[pronum] &amp;&amp; stu[id].grade[pronum] &lt; perfect[pronum]) stu[id].cnt++; if(grade &gt; stu[id].grade[pronum]) stu[id].grade[pronum] = grade; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(stu[i].grade[j] &gt; 0) stu[i].grade[0] += stu[i].grade[j]; &#125; &#125; sort(stu + 1, stu + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; stu[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; stu[i].grade[0] != stu[i - 1].grade[0]) rank = i; printf("%d %05d %d", rank, stu[i].id, stu[i].grade[0]); for(int j = 1; j &lt;= k; j++) &#123; if(stu[i].grade[j] == -1) printf(" -"); else printf(" %d", stu[i].grade[j]); &#125; putchar('\n'); &#125; return 0;&#125; 1076 Forwards on WeiboAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;struct node &#123; int id; int layer;&#125;;vector&lt;node&gt; Adj[maxn];bool inq[maxn] = &#123;false&#125;;int BFS(int s, int L) &#123; int numFoward = 0; queue&lt;node&gt; q; node start; start.id = s; start.layer = 0; q.push(start); inq[start.id] = true; while(!q.empty()) &#123; node top = q.front(); q.pop(); int u = top.id; for(int i = 0; i &lt; Adj[u].size(); i++) &#123; node next = Adj[u][i]; next.layer = top.layer + 1; if(inq[next.id] == false &amp;&amp; next.layer &lt;= L) &#123; q.push(next); inq[next.id] = true; numFoward++; &#125; &#125; &#125; return numFoward;&#125;int main(int argc, char const *argv[]) &#123; node user; int n, L, numFollow, idFollow; cin &gt;&gt; n &gt;&gt; L; for(int i = 1; i &lt;= n; i++) &#123; user.id = i; cin &gt;&gt; numFollow; for(int j = 0; j &lt; numFollow; j++) &#123; cin &gt;&gt; idFollow; Adj[idFollow].push_back(user); &#125; &#125; int numQuery, s; cin &gt;&gt; numQuery; while(numQuery--) &#123; memset(inq, false, sizeof(inq)); cin &gt;&gt; s; int numFoward = BFS(s, L); cout &lt;&lt; numFoward &lt;&lt; endl; &#125; return 0;&#125; 1077 KuchiguseAnalysisæœ¬é¢˜çš„å®žè´¨æ˜¯åœ¨æ±‚å­—ç¬¦ä¸²çš„æœ€é•¿ç›¸åŒåŽç¼€ï¼Œä»ŽåŽéåŽ†å­—ç¬¦ä¸²æ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥é‡‡å–å…ˆé€†è½¬å­—ç¬¦ä¸²ï¼Œç„¶åŽä»Žå‰éåŽ†çš„åšæ³•ï¼Œè¿™æ ·å°±ä¼šæ–¹ä¾¿è®¸å¤šã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 256 + 5;char str[100][MAXN];void Reverse(char *s);int main(int argc, char const *argv[]) &#123; int N, minLen = 256, ans = 0; scanf("%d", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) &#123; fgets(str[i], MAXN, stdin); int len = strlen(str[i]); if(len &lt; minLen) minLen = len; Reverse(str[i]); &#125; for(int i = 0; i &lt; minLen; i++) &#123; char c = str[0][i]; bool same = true; for(int j = 1; j &lt; N; j++) &#123; if(c != str[j][i]) &#123; same = false; break; &#125; &#125; if(same) &#123; ans++; &#125; else &#123; break; &#125; &#125; if(ans &gt; 1) &#123; for(int i = ans - 1; i &gt;= 0; i--) &#123; putchar(str[0][i]); &#125; &#125; else &#123; puts("nai"); &#125; return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; è´´ä¸ª C++ ç‰ˆï¼š1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int n, minlen = 0x3fffffff; cin &gt;&gt; n; getchar(); vector&lt;string&gt; strs; for(int i = 0; i &lt; n; i++) &#123; string tmp; getline(cin, tmp); reverse(tmp.begin(), tmp.end()); strs.push_back(tmp); if(tmp.length() &lt; minlen) minlen = tmp.length(); &#125; string ans; bool flag = false; for(int i = 0; i &lt; minlen; i++) &#123; char tmp = strs[0][i]; for(int j = 1; j &lt; n; j++) &#123; if(strs[j][i] != tmp) &#123; flag = true; break; &#125; &#125; if(flag) break; ans += tmp; &#125; reverse(ans.begin(), ans.end()); if(ans != "") cout &lt;&lt; ans; else cout &lt;&lt; "nai"; return 0;&#125; 1078 HashingAnalysisé¢˜ç›®å¤§æ„æ˜¯ç”¨çº¿æ€§æŽ¢æµ‹çš„æ–¹æ³•ï¼Œæž„é€ å“ˆå¸Œè¡¨ï¼Œç”¨å¹³æ–¹æŽ¢æµ‹çš„åŠžæ³•è§£å†³å†²çªã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXM = 10005;bool isPrime(int n) &#123; if(n &lt;= 1 || (n != 2 &amp;&amp; n % 2 == 0)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int nearPrime(int n) &#123; while(!isPrime(n)) n++; return n;&#125;int hashTable[MAXM] = &#123;0&#125;; int main(int argc, char const *argv[]) &#123; int m, n, temp, index; scanf("%d %d", &amp;m, &amp;n); m = nearPrime(m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); index = temp % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); &#125; else &#123; int step; for(step = 1; step &lt; m; step++) &#123; index = (temp + step * step) % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); break; &#125; &#125; if(step &gt;= m) &#123; printf("-"); &#125; &#125; if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 1079 Total Sales of SupplyAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1080 Graduate AdmissionAnalysisè¿™ä¸ªé¢˜ç›¸å½“éº»çƒ¦ï¼ŒåŸºæœ¬æ€æƒ³æ˜¯æŽ’åº + è´ªå¿ƒã€‚æŽ’åºçš„è§„åˆ™å¾ˆç®€å•ï¼Œç¬¬ä¸€åˆ¤æ–­ä¾æ®æ˜¯æ€»åˆ†ï¼ˆä¸ç”¨ä¸Žé¢˜ç›®çš„è®¡ç®—å…¬å¼ä¸€è‡´ï¼‰ï¼Œç¬¬äºŒæŽ’åºä¾æ®æ˜¯ Ge è¿™ä¸ªåˆ†æ•°ï¼Œé¡ºåºä¸ºéžå¢žåºã€‚æŽ’åºçš„é—®é¢˜æ¯”è¾ƒå®¹æ˜“è§£å†³ï¼Œéš¾ç‚¹åœ¨å­¦æ ¡æŒ‘é€‰å­¦ç”Ÿä¸Šã€‚å…·ä½“è€Œè¨€ï¼Œæ•´ä¸ªå½•å–è¿‡ç¨‹æ˜¯ä¸€ä¸ªè´ªå¿ƒçš„è¿‡ç¨‹ã€‚é¦–å…ˆæŒ‰ç…§åˆ†æ•°ï¼Œå°†æ¯ä½å­¦ç”Ÿçš„æŽ’åæ±‚å‡ºã€‚ç„¶åŽæ ¹æ®æŽ’åï¼ŒæŒ‰ç…§æ¯ä½å­¦ç”Ÿçš„é€‰æ‹©ï¼Œä¾æ¬¡è¿›è¡Œå½•å–ã€‚ä¹‹æ‰€ä»¥è¯´æ˜¯è´ªå¿ƒï¼Œæ˜¯å› ä¸ºä»¥å‰é¢çš„é€‰æ‹©ä¼˜å…ˆï¼ˆä¹Ÿå°±æ˜¯ç¬¬ä¸€å¿—æ„¿ä¼˜å…ˆçš„è§„åˆ™ï¼‰ï¼Œå‰é¢é€‰æ‹©çš„å­¦æ ¡åé¢ä¸è¶³æ—¶å°±é¡ºæŽ’åˆ°åŽé¢çš„å­¦æ ¡ã€‚ç”±äºŽé¢˜ç›®è¿˜è¦æ±‚ï¼Œå¯¹äºŽæŽ’åç›¸åŒä¸”é€‰æ‹©ç›¸åŒå­¦æ ¡çš„ï¼Œå­¦æ ¡åº”è¯¥æ‰©é¢å½•å–ã€‚æ‰€ä»¥éœ€è¦è®°å½•ä¸‹ï¼Œåœ¨ä¸è¶…è¿‡é™é¢çš„æƒ…å†µï¼Œæ¯ä¸ªå­¦æ ¡èƒ½å½•å–çš„æœ€åŽä¸€åçš„åæ¬¡ï¼Œå¹¶ä¸ŽåŽé¢çš„å­¦ç”Ÿè¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœæŽ’åç›¸åŒï¼Œå°±å¾—å½•å–ã€‚æœ€åŽè¿˜æœ‰ä¸€ç‚¹ï¼Œå­¦æ ¡çš„å½•å–åå•éœ€è¦æŒ‰ç…§ id éžé™åºæŽ’åºã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 40000 + 5;struct student&#123; int ge, gi, sum; int r, id; int cho[6];&#125; stu[MAXN];struct school&#123; int quota; int stuNum; int id[MAXN]; int lastAdmit;&#125; sch[110];bool cmpStu(student a, student b);bool cmpID(int a, int b);int main(int argc, char const *argv[]) &#123; int N, M, K; scanf("%d %d %d", &amp;N, &amp;M, &amp;K); for(int i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;sch[i].quota); sch[i].stuNum = 0; sch[i].lastAdmit = -1; &#125; for(int i = 0; i &lt; N; i++) &#123; stu[i].id = i; scanf("%d %d", &amp;stu[i].ge, &amp;stu[i].gi); stu[i].sum = stu[i].ge + stu[i].gi; for(int j = 0; j &lt; K; j++) &#123; scanf("%d", &amp;stu[i].cho[j]); &#125; &#125; sort(stu, stu + N, cmpStu); for(int i = 0; i &lt; N; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) &#123; stu[i].r = stu[i - 1].r; &#125; else &#123; stu[i].r = i; &#125; &#125; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; K; j++) &#123; int choice = stu[i].cho[j]; int num = sch[choice].stuNum; int last = sch[choice].lastAdmit; if(num &lt; sch[choice].quota || (last != -1 &amp;&amp; stu[i].r == stu[last].r)) &#123; sch[choice].id[num] = i; sch[choice].lastAdmit = i; sch[choice].stuNum++; break; &#125; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; if(sch[i].stuNum &gt; 0) &#123; sort(sch[i].id, sch[i].id + sch[i].stuNum, cmpID); for(int j = 0; j &lt; sch[i].stuNum; j++) &#123; printf("%d", stu[sch[i].id[j]].id); if(j &lt; sch[i].stuNum - 1) &#123; printf(" "); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmpStu(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;bool cmpID(int a, int b) &#123; return stu[a].id &lt; stu[b].id;&#125; è´´ä¸ª C++ ç‰ˆï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40000 + 5;struct student &#123; int ge, gi, id, rank; int sum; int choices[6];&#125; stu[maxn];int n, m, k;int quota[105] = &#123;0&#125;;int lastrank[105] = &#123;0&#125;;bool cmp(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; quota[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].ge &gt;&gt; stu[i].gi; stu[i].sum = stu[i].ge + stu[i].gi; stu[i].id = i; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; stu[i].choices[j]; &#125; &#125; sort(stu, stu + n, cmp); stu[0].rank = 1; for(int i = 1; i &lt; n; i++) &#123; if(stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) stu[i].rank = stu[i - 1].rank; else stu[i].rank = i + 1; &#125; vector&lt;vector&lt;int&gt;&gt; ans(105); for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; k; j++) &#123; int school = stu[i].choices[j]; if(quota[school] != 0) &#123; ans[school].push_back(stu[i].id); quota[school]--; lastrank[school] = stu[i].rank; break; &#125; else &#123; if(stu[i].rank == lastrank[school]) &#123; ans[school].push_back(stu[i].id); break; &#125; &#125; &#125; &#125; for(int i = 0; i &lt; m; i++) &#123; int size = ans[i].size(); if(size == 0) &#123; cout &lt;&lt; endl; continue; &#125; else &#123; sort(ans[i].begin(), ans[i].end()); cout &lt;&lt; ans[i][0]; for(int j = 1; j &lt; size; j++) &#123; cout &lt;&lt; ' ' &lt;&lt; ans[i][j]; &#125; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 1081 Rational SumAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šNä¸ªa/bå½¢å¼çš„åˆ†æ•°ï¼Œaä¸ºåˆ†å­ï¼Œbä¸ºåˆ†æ¯ï¼Œæ±‚è¿™Nä¸ªåˆ†æ•°çš„å’Œå†è¾“å‡ºã€‚ ç»™å®šçš„åˆ†æ•°åªæœ‰ä¸¤ç§æƒ…å†µï¼šçœŸåˆ†æ•°å’Œå‡åˆ†æ•°ï¼Œä¸å­˜åœ¨å¸¦åˆ†æ•°ï¼Œä½†è¾“å‡ºè¦è¾“å‡ºå¸¦åˆ†æ•°ï¼Œå¹¶ä¸”æ˜¯æœ€ç®€å½¢å¼ã€‚åŒ–ç®€çš„ç›®çš„å…¶å®žé¢˜ç›®è€ƒå¯Ÿæ±‚æœ€å¤§å…¬çº¦æ•°ï¼Œåˆ©ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯æ±‚å¾—ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct fraction &#123; long long up, down;&#125; Fraction;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; long long d = gcd(abs(result.up), result.down); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;void printResult(Fraction result) &#123; Fraction r = Reduction(result); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125;&#125;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); Fraction ans, temp; ans.up = 0; ans.down = 1; while(N--) &#123; scanf("%lld/%lld", &amp;temp.up, &amp;temp.down); ans = Add(ans, temp); &#125; printResult(ans); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼ŒæŠŠåŠ æ³•è¿ç®—ã€åŒ–ç®€å’Œè¾“å‡ºæ“ä½œéƒ½å°è£…èµ·æ¥ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;struct Fraction &#123; long long up, down; void reduction() &#123; if(this-&gt;down &lt; 0) &#123; this-&gt;up = - this-&gt;up; this-&gt;down = - this-&gt;down; &#125; if(this-&gt;up == 0) this-&gt;down = 1; else &#123; long long d = gcd(abs(this-&gt;up), this-&gt;down); this-&gt;up /= d; this-&gt;down /= d; &#125; &#125; void Add(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down + this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Print() &#123; if(this-&gt;down == 1) printf("%lld", this-&gt;up); else if(abs(this-&gt;up) &gt; this-&gt;down) &#123; printf("%lld %lld/%lld", this-&gt;up / this-&gt;down, abs(this-&gt;up) % this-&gt;down, this-&gt;down); &#125; else printf("%lld/%lld", this-&gt;up, this-&gt;down); printf("\n"); &#125;&#125;;int main() &#123; int n; scanf("%d", &amp;n); Fraction ans, tmp; ans.down = 1, ans.up = 0; while(n--) &#123; scanf("%lld/%lld", &amp;tmp.up, &amp;tmp.down); ans.Add(tmp); &#125; ans.Print(); return 0;&#125; 1082 Read Number in ChineseAnalysiså°†æ•°å­—æŒ‰æ¯4ä½ä¸€ç»„åˆ†å‰²ä¸ºä¸åŒçš„ç»„ï¼Œè‹¥æ˜¯ 9 ä½æ•°ï¼Œåˆ™æœ‰ä¸‰ç»„åˆ†åˆ«ä¸ºï¼šä¸ªä½ç»„ã€ä¸‡ä½ç»„å’Œäº¿ä½ç»„ï¼Œç„¶åŽé’ˆå¯¹æ¯ä¸€ç»„å•ç‹¬è¿›è¡Œåˆ¤æ–­ã€‚å¯¹æ¯ä¸€å°ç»„è€Œè¨€ï¼Œè¦æ³¨æ„1001åªèƒ½è¾“å‡ºä¸ºyi Qian ling yiè€Œä¸æ˜¯yi Qian ling ling yiï¼Œå³æœ‰ç´¯ç§¯çš„0æ—¶ï¼Œåªèƒ½è¾“å‡ºä¸€ä¸ªlingã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;char NumberTable[10][10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu", &#125;;char Digit[5][10] = &#123; "Shi", "Bai", "Qian", "Wan", "Yi", &#125;;int main(int argc, char const *argv[]) &#123; char Num[15]; scanf("%s", Num); int len = strlen(Num), left = 0, right = len - 1; if(Num[0] == '-') &#123; printf("Fu"); left++; &#125; while(left + 4 &lt;= right) &#123; right -= 4; &#125; while(left &lt; len) &#123; bool flag = false, isPrint = false; while(left &lt;= right) &#123; if(left &gt; 0 &amp;&amp; Num[left] == '0') &#123; flag = true; &#125; else &#123; if(flag == true) &#123; printf(" ling"); flag = false; &#125; if(left &gt; 0) printf(" "); printf("%s", NumberTable[Num[left] - '0']); isPrint = true; if(left != right) &#123; printf(" %s", Digit[right - left - 1]); &#125; &#125; left++; &#125; if(isPrint == true &amp;&amp; right != len - 1) &#123; printf(" %s", Digit[(len - 1 - right) / 4 + 2]); &#125; right += 4; &#125; return 0;&#125; 1083 List GradesAnalysisè‡ªå®šä¹‰ç»“æž„ä½“ï¼Œè¾“å…¥æ•°æ®åŽè°ƒç”¨sortå‡½æ•°æŒ‰ç…§é™åºæŽ’åºï¼Œç„¶åŽæ ¹æ®é¢˜ç›®ç»™å®šçš„åŒºé—´é¡ºåºè¾“å‡ºç¬¦åˆè¿™ä¸ªåŒºé—´å†…çš„å…ƒç´ å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char name[15], id[15]; int grade;&#125; stu[MAXN];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, grade1, grade2; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].id, &amp;stu[i].grade); &#125; scanf("%d %d", &amp;grade1, &amp;grade2); sort(stu, stu + N, cmp); bool flag = false; for(int i = 0; i &lt; N; i++) &#123; if(grade1 &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= grade2) &#123; printf("%s %s\n", stu[i].name, stu[i].id); flag = true; &#125; &#125; if(!flag) &#123; printf("NONE\n"); &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade &gt; b.grade;&#125; è´´ä¸ª C++ ç‰ˆï¼š1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string name, id; int grade;&#125; stu[maxn];int n;int main() &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].name &gt;&gt; stu[i].id &gt;&gt; stu[i].grade; &#125; sort(stu, stu + n, [](student a, student b) &#123; return a.grade &gt; b.grade; &#125;); int left, right, cnt = 0; cin &gt;&gt; left &gt;&gt; right; for(int i = 0; i &lt; n; i++) &#123; if(left &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= right) &#123; cout &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].id &lt;&lt; endl; cnt++; &#125; &#125; if(!cnt) cout &lt;&lt; "NONE" &lt;&lt; endl; return 0;&#125; 1084 Broken KeyboardAnalysiséåŽ†å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°è¿‡ï¼Œä½†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­æœªå‡ºçŽ°çš„å­—ç¬¦å³å¯ï¼Œå­—æ¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œä½†å­—ç¬¦ä¸²å†…æœ‰ç©ºæ ¼å’Œæ•°å­—ï¼Œç”¨_è¡¨ç¤ºï¼Œæ³¨æ„ä¸èƒ½è¾“å‡ºå°å†™å­—æ¯ï¼Œä¸”é‡å¤çš„å­—ç¬¦åªè¾“å‡ºä¸€æ¬¡ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;int main(int argc, char const *argv[]) &#123; char str1[85], str2[85]; scanf("%s %s", str1, str2); bool HashTable[128] = &#123;false&#125;; for(int i = 0; str1[i] != '\0'; i++) &#123; int j = 0; char c1 = str1[i]; for(; str2[j] != '\0'; j++) &#123; char c2 = str2[j]; if(islower(c1)) c1 = toupper(c1); if(islower(c2)) c2 = toupper(c2); if(c1 == c2) break; &#125; if(str2[j] == '\0' &amp;&amp; HashTable[c1] == false) &#123; printf("%c", c1); HashTable[c1] = true; &#125; &#125; putchar('\n'); return 0;&#125; 1085 Perfect SequenceAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1030ä¸€æ ·ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;long long n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%lld %lld", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1086 Tree Traversals AgainAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç”¨æ ˆæ¨¡æ‹ŸäºŒå‰æ ‘ä¸­åºéåŽ†çš„å…¥æ ˆã€å‡ºæ ˆé¡ºåºï¼ŒçŽ°åœ¨è¦æ±‚è¾“å‡ºè¿™ä¸ªäºŒå‰æ ‘åŽåºéåŽ†åºåˆ—ã€‚ æ ¹æ®é¢˜ç›®ç»™å®šçš„å…¥æ ˆã€å‡ºæ ˆåºåˆ—ï¼Œå¯ä»¥å¾—åˆ°äºŒå‰æ ‘çš„å…ˆåºéåŽ†åºåˆ—å’ŒåŽåºéåŽ†åºåˆ—ï¼Œæ ¹æ®è¿™ä¸¤ä¸ªåºåˆ—å»ºæ ‘ï¼Œç„¶åŽå†åŽåºéåŽ†è¿™ä¸ªäºŒå‰æ ‘å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int data; node *lchild; node *rchild;&#125;;int n, pre[50], in[50], order;stack&lt;int&gt; st;node *create(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(preL + 1, preL + numLeft, inL, k - 1); root-&gt;rchild = create(preL + numLeft + 1, preR, k + 1, inR); return root;&#125;int num = 0;void postorder(node *root) &#123; if(root == NULL) return; postorder(root-&gt;lchild); postorder(root-&gt;rchild); printf("%d", root-&gt;data); if(num &lt; n - 1) &#123; printf(" "); &#125; num++;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); char str[5]; int x, preIndex = 0, inIndex = 0; for(int i = 0; i &lt; 2 * n; i++) &#123; scanf("%s", str); if(strcmp("Push", str) == 0) &#123; scanf("%d", &amp;x); pre[preIndex++] = x; st.push(x); &#125; else &#123; in[inIndex++] = st.top(); st.pop(); &#125; &#125; node *root = create(0, n - 1, 0, n - 1); postorder(root); return 0;&#125; 1087 All Roads Lead to RomeAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯æ—…æ¸¸çš„è·¯çº¿å›¾ï¼Œè¦æ±‚æŒ‰ç…§æ¡ä»¶æ±‚å‡ºæœ€çŸ­è·¯å¾„åŠç‰¹å®šçš„å€¼ã€‚ é¢˜ç›®é¦–å…ˆè¦æ±‚å‡ºçš„æ˜¯ä»Žèµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œç”±äºŽä¸å­˜åœ¨è´ŸçŽ¯ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨ Dijkstra ç®—æ³•æ±‚å¾—ï¼›åŒæ—¶æ³¨æ„åˆ°ï¼Œé¢˜ç›®è¦æ±‚çš„æŸäº›ç‰¹æ®Šå€¼ä¸Žå¯¹åº”çš„è·¯å¾„å¯ä»¥åœ¨æ±‚è§£æœ€çŸ­è·¯æ—¶ï¼Œä¸€å¹¶æ±‚å‡ºï¼Œåªä¸è¿‡éœ€è¦ä½¿ç”¨å¤šä¸ªæ•°ç»„è€Œå·²ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯¹é¢˜ç›®è¦æ±‚çš„å€¼å¢žåŠ å¯¹åº”çš„æ•°ç»„ï¼Œå¹¶åœ¨æ±‚è§£æœ€æœ€çŸ­è·¯çš„è¿‡ç¨‹ä¸­å†™æ¸…æ¥šè¿™äº›æ¡ä»¶ä¹‹é—´çš„å±‚æ¬¡å…³ç³»å³å¯ã€‚ å½“ç„¶äº†ï¼Œæœ¬é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨ Dijkstra ç®—æ³•å…ˆæ±‚å‡ºæ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ï¼Œç„¶åŽå†åˆ©ç”¨ DFS æ¥æ±‚å‡ºç¬¦åˆæ¡ä»¶çš„æœ€ä¼˜è§£å’Œå¯¹åº”çš„å€¼ã€‚ CodeDijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;, pt[maxv] = &#123;0&#125;, pre[maxv];bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v] = u; num[v] = num[u]; w[v] = w[u] + weight[v]; pt[v] = pt[u] + 1; &#125; else if(d[v] == d[u] + G[u][v]) &#123; num[v] += num[u]; if(w[v] &lt; w[u] + weight[v]) &#123; w[v] = w[u] + weight[v]; pre[v] = u; pt[v] = pt[u] + 1; &#125; else if(w[v] == w[u] + weight[v]) &#123; double uavg = 1.0 * (w[u] + weight[v]) / (pt[u] + 1); double vavg = 1.0 * w[v] / pt[v]; if(uavg &gt; vavg) &#123; pt[v] = pt[u] + 1; pre[v] = u; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; cout &lt;&lt; index2city[v]; return; &#125; dfs(pre[v]); cout &lt;&lt; "-&gt;" &lt;&lt; index2city[v];&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; city2index[city1] = i; index2city[i] = city1; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1], v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; cout &lt;&lt; num[rom] &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; w[rom] &lt;&lt; ' ' &lt;&lt; w[rom] / pt[rom] &lt;&lt; endl; dfs(rom); return 0;&#125; Dijkstra + DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], numpath = 0, maxw = 0;double maxavg = 0;bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); numpath++; int tempw = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; tempw += weight[id]; &#125; double tempavg = 1.0 * tempw / (tempath.size() - 1); if(tempw &gt; maxw) &#123; maxw = tempw; maxavg = tempavg; path = tempath; &#125; else if(tempw == maxw &amp;&amp; tempavg &gt; maxavg) &#123; maxavg = tempavg; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; index2city[i] = city1; city2index[city1] = i; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1]; v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; dfs(rom); cout &lt;&lt; numpath &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; maxw &lt;&lt; ' ' &lt;&lt; (int)maxavg &lt;&lt; endl; for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; index2city[path[i]]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; return 0;&#125; 1088 Rational ArithmeticAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1034ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b);struct Fraction&#123; ll up, down;&#125; a, b;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /=d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void showResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); //add showResult(a); printf(" + "); showResult(b); printf(" = "); showResult(Add(a, b)); putchar('\n'); //minu showResult(a); printf(" - "); showResult(b); printf(" = "); showResult(Minu(a, b)); putchar('\n'); //mult showResult(a); printf(" * "); showResult(b); printf(" = "); showResult(Mult(a, b)); putchar('\n'); //divide showResult(a); printf(" / "); showResult(b); printf(" = "); if(b.up == 0) printf("Inf"); else showResult(Divide(a, b)); return 0;&#125; ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125; è´´ä¸ª C++ ç‰ˆï¼ŒæŠŠåŸºæœ¬è¿ç®—å…¨éƒ½å°è£…èµ·æ¥ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;struct Fraction &#123; long long up, down; void reduction() &#123; if(this-&gt;down &lt; 0) &#123; this-&gt;up = - this-&gt;up; this-&gt;down = - this-&gt;down; &#125; if(this-&gt;up == 0) this-&gt;down = 1; else &#123; long long d = gcd(abs(this-&gt;up), this-&gt;down); this-&gt;up /= d; this-&gt;down /= d; &#125; &#125; void Add(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down + this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Minu(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down - this-&gt;down * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Mult(Fraction b) &#123; this-&gt;up = this-&gt;up * b.up; this-&gt;down = this-&gt;down * b.down; this-&gt;reduction(); &#125; void Div(Fraction b) &#123; this-&gt;up = this-&gt;up * b.down; this-&gt;down = this-&gt;down * b.up; this-&gt;reduction(); &#125; void printResult() &#123; this-&gt;reduction(); if(this-&gt;up &lt; 0) printf("("); if(this-&gt;down == 1) printf("%lld", this-&gt;up); else if(abs(this-&gt;up) &gt; this-&gt;down) &#123; printf("%lld %lld/%lld", this-&gt;up / this-&gt;down, abs(this-&gt;up) % this-&gt;down, this-&gt;down); &#125; else &#123; printf("%lld/%lld", this-&gt;up, this-&gt;down); &#125; if(this-&gt;up &lt; 0) printf(")"); &#125;&#125;;int main() &#123; Fraction res, a, b; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); res = a; a.printResult(); printf(" + "); b.printResult(); printf(" = "); res.Add(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" - "); b.printResult(); printf(" = "); res.Minu(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" * "); b.printResult(); printf(" = "); res.Mult(b); res.printResult(); printf("\n"); res = a; a.printResult(); printf(" / "); b.printResult(); printf(" = "); if(b.up == 0) printf("Inf"); else &#123; res.Div(b); res.printResult(); &#125; printf("\n"); return 0;&#125; 1089 Insert or MergeAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1035ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 10;int ori[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;bool InsertionSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;ori[i]); tempOri[i] = ori[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertionSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = ori[i]; &#125; MergeSort(); &#125; return 0;&#125; 1090 Highest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;struct node &#123; double data; vector&lt;int&gt; child;&#125; Node[maxn];int n, num = 0;double p, r, maxDepth = 0;void DFS(int index, int depth) &#123; if(Node[index].child.size() == 0) &#123; if(depth &gt; maxDepth) &#123; maxDepth = depth; num = 1; &#125; else if(depth == maxDepth) &#123; num++; &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; DFS(Node[index].child[i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100; int root, parent; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;parent); if(parent != -1) &#123; Node[parent].child.push_back(i); &#125; else &#123; root = i; &#125; &#125; DFS(root, 0); printf("%.2lf %d\n", p * pow(1 + r, maxDepth), num); return 0;&#125; 1091 Acute StrokeAnalysisé¢˜ç›®çš„èƒŒæ™¯å¤§æ¦‚æ˜¯è®¡ç®—ä½“ç§¯ä¹‹å’Œå§... æ ¹æ®é¢˜ç›®è¾“å…¥æ•°æ®çš„å½¢å¼å’Œé¢˜ç›®å¤§æ„ï¼Œæ€è·¯æ˜¯å€ŸåŠ© BFS å¯¹ä¸‰ç»´æ•°ç»„è¿›è¡ŒéåŽ†ï¼Œè®¡ç®—å‡ºæ¯ä¸€ä¸ªè–„ç‰‡ï¼ˆsliceï¼‰ä¸­ä¸ºâ€œ1â€çš„ä¸ªæ•°ï¼Œå¦‚æžœå¤§äºŽé¢˜ç›®ç»™å®šçš„Tï¼Œåˆ™å½“å‰è¿™ä¸ªè–„ç‰‡å†…â€œ1â€çš„ä¸ªæ•°å°±å¯ä»¥è®¤ä¸ºæ˜¯è¿™ä¸ªè–„ç‰‡çš„â€œæ€¥æ€§è„‘å’ä¸­â€åŒºçš„ä½“ç§¯ã€‚é‚£ä¹ˆï¼Œä¾æ¬¡éåŽ†æ¯ä¸ªè–„ç‰‡å³å¯å¾—åˆ°æœ€ç»ˆç»“æžœã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, z;&#125; Node;int n, m, slice, T;int pixel[1290][130][61];bool inqueue[1290][130][61];int X[6] = &#123;0, 0, 0, 0, 1, -1&#125;;int Y[6] = &#123;0, 0, 1, -1, 0, 0&#125;;int Z[6] = &#123;1, -1, 0, 0, 0, 0&#125;;bool judge(int x, int y, int z) &#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0 || z &gt;= slice || z &lt; 0) return false; if(pixel[x][y][z] == 0 || inqueue[x][y][z] == true) return false; return true;&#125;int BFS(int x, int y, int z) &#123; int tot = 0; queue&lt;node&gt; Q; Node.x = x, Node.y = y, Node.z = z; Q.push(Node); inqueue[x][y][z] = true; while(!Q.empty()) &#123; node top = Q.front(); Q.pop(); tot++; for(int i = 0; i &lt; 6; i++) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; int newZ = top.z + Z[i]; if(judge(newX, newY, newZ)) &#123; Node.x = newX, Node.y = newY, Node.z = newZ; Q.push(Node); inqueue[newX][newY][newZ] = true; &#125; &#125; &#125; if(tot &gt;= T) return tot; else return 0;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;slice, &amp;T); for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; scanf("%d", &amp;pixel[x][y][z]); &#125; &#125; &#125; int ans = 0; for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; if(pixel[x][y][z] == 1 &amp;&amp; inqueue[x][y][z] == false) &#123; ans += BFS(x, y, z); &#125; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1092 To Buy or Not to BuyAnalysisä¸Žä¹™çº§é¢˜åº“çš„1039ä¸€æ ·ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1093 Count PATâ€™sAnalysisä¸Žä¹™çº§é¢˜åº“çš„1040ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') leftNumP[i]++; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt; 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; è´´ä¸ª C++ ç‰ˆï¼š123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;int main() &#123; string str; cin &gt;&gt; str; int pcnt = 0, tcnt = 0; for(char &amp;ch: str) &#123; if(ch == 'T') tcnt++; &#125; int ans = 0; for(char &amp;ch: str) &#123; if(ch == 'A') &#123; ans += tcnt * pcnt; ans %= 1000000007; &#125; else if(ch == 'P') pcnt++; else tcnt--; &#125; cout &lt;&lt; ans; return 0;&#125; 1094 The Largest GenerationAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, seq, child;int Depth[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; Depth[Node[1].depth]++; while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; Depth[Node[child].depth]++; q.push(child); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); int max = -1, l = 1; for(int i = 0; i &lt; maxn; i++) &#123; if(Depth[i] &gt; max) &#123; max = Depth[i]; l = i; &#125; &#125; cout &lt;&lt; Depth[l] &lt;&lt; ' ' &lt;&lt; l &lt;&lt; endl; return 0;&#125; 1095 Cars on CampusAnalysisè¿™åˆæ˜¯ä¸€é“ç›¸å½“éº»çƒ¦çš„æŽ’åºé¢˜ï¼Œå’Œ 1016 å¾ˆåƒï¼Œæœ‰äº›åœ°æ–¹åˆæ¯” 1016 ç®€å•ä¸€ç‚¹ã€‚é¦–å…ˆè¦æ³¨æ„çš„äº‹æƒ…æ˜¯ï¼Œå¦‚ä½•æŠŠé¢˜ç›®çš„ä¸€äº›æ¡ä»¶ç®€åŒ–ï¼Œæ¯”å¦‚æ—¶é—´å…¨éƒ¨ç®€åŒ–æˆç§’ï¼Œè¿™æ ·æŽ’åºæ—¶å°±å¯ä»¥ç›´æŽ¥æŒ‰ç…§ç§’æ•°çš„å¤§å°è¿›è¡ŒæŽ’åºäº†ã€‚ä¸è¿‡ï¼Œå¯¹äºŽè¿™ä¸ªé¢˜è€Œè¨€ï¼Œç¬¬ä¸€æŽ’åºä¾æ®æ˜¯plate_numberï¼Œç„¶åŽæ‰æ˜¯æ—¶é—´ã€‚æŽ’åºå®ŒæˆåŽï¼Œéœ€è¦å°†æ‰€æœ‰åˆæ³•çš„è®°å½•å¯¹æŒ‘å‡ºæ¥ï¼Œä½œä¸ºåŽé¢æŸ¥è¯¢æ¯ä¸ªæ—¶é—´å†…åœè½¦åœºå†…è½¦è¾†æ•°æ®çš„ä¾æ®ï¼Œä¹Ÿå°±æ˜¯ç›¸é‚»çš„ä¸¤ä¸ªè®°å½•ç»„æˆä¸€å¯¹ï¼Œplate_numberç›¸åŒï¼Œä¸€ä¸ªæ˜¯inï¼Œå¦å¤–ä¸€ä¸ªæ˜¯outã€‚æ­¤æ—¶ï¼Œå¯ä»¥é¡ºä¾¿æŠŠæ¯è¾†è½¦çš„åœè½¦æ—¶é—´å’Œæœ€é•¿çš„åœè½¦æ—¶é—´ç®—å‡ºæ¥ï¼Œæ¯è¾†è½¦çš„åœè½¦æ—¶é—´å¯ä»¥å€ŸåŠ© map æ¥ç»Ÿè®¡ã€‚æŽ¥ç€å°±æ˜¯æŸ¥è¯¢çš„è¿‡ç¨‹ï¼Œå› ä¸ºé¢˜ç›®è§„å®šäº†ç»™å®šçš„æŸ¥è¯¢æ—¶é—´æ˜¯ä»Žå°åˆ°å¤§çš„ã€‚æ‰€ä»¥ï¼Œåœ¨æŸ¥è¯¢å‰ï¼Œå…ˆå¯¹åˆæ³•è®°å½•æŒ‰æ—¶é—´æŽ’åºã€‚ç„¶åŽï¼Œè®¾ç½®ä¸€ä¸ªå˜é‡ nowï¼Œä»Žå¤´å¼€å§‹è¿›è¡ŒéåŽ†ï¼Œé‡åˆ°inçš„è®°å½•ï¼Œå½“å‰è½¦è¾†æ•°å°±åŠ  1ï¼Œé‡åˆ°outçš„è®°å½•ï¼Œå°±å‡ä¸€ï¼Œè¿™æ ·å°±åªç”¨éåŽ†ä¸€æ¬¡æ‰€æœ‰çš„åˆæ³•è®°å½•ã€‚æœ€åŽå°±æ˜¯è¾“å‡ºåœè½¦æ—¶é—´ä¸Žæœ€é•¿åœè½¦æ—¶é—´ç›¸ç­‰çš„è½¦ç‰Œå·å’Œæ€»æ—¶é—´äº†ã€‚ä¸¤ä¸ªå­—ï¼šéº»çƒ¦~ðŸ™ƒ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 10;struct car &#123; char pnum[8], status[5]; int time;&#125; all[maxn], valid[maxn];int n, k, validcnt = 0;map&lt;string, int&gt; parktime; bool cmpbypnumandtime(car a, car b) &#123; if(strcmp(a.pnum, b.pnum) != 0) return strcmp(a.pnum, b.pnum) &lt; 0; else return a.time &lt; b.time;&#125;bool cmpbytime(car a, car b) &#123; return a.time &lt; b.time;&#125;int time2int(int hh, int mm, int ss) &#123; return hh * 3600 + mm * 60 + ss; &#125;int main() &#123; scanf("%d %d", &amp;n, &amp;k); int hh, mm, ss; for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d:%d:%d %s", all[i].pnum, &amp;hh, &amp;mm, &amp;ss, all[i].status); all[i].time = time2int(hh, mm, ss); &#125; sort(all, all + n, cmpbypnumandtime); int maxtime = -1; for(int i = 0; i &lt; n - 1; i++) &#123; if(!strcmp(all[i].pnum, all[i + 1].pnum) &amp;&amp; !strcmp(all[i].status, "in") &amp;&amp; !strcmp(all[i + 1].status, "out")) &#123; valid[validcnt++] = all[i]; valid[validcnt++] = all[i + 1]; int intime = all[i + 1].time - all[i].time; if(parktime.count(all[i].pnum) == 0) &#123; parktime[all[i].pnum] = 0; &#125; parktime[all[i].pnum] += intime; maxtime = max(maxtime, parktime[all[i].pnum]); &#125; &#125; sort(valid, valid + validcnt, cmpbytime); int now = 0, numcar = 0; for(int i = 0; i &lt; k; i++) &#123; scanf("%d:%d:%d", &amp;hh, &amp;mm, &amp;ss); int time = time2int(hh, mm, ss); while(now &lt; validcnt &amp;&amp; valid[now].time &lt;= time) &#123; if(!strcmp(valid[now].status, "in")) numcar++; else numcar--; now++; &#125; printf("%d\n", numcar); &#125; for(auto it = parktime.begin(); it != parktime.end(); it++) &#123; if(it-&gt;second == maxtime) printf("%s ", it-&gt;first.c_str()); &#125; printf("%02d:%02d:%02d", maxtime / 3600, maxtime % 3600 / 60, maxtime % 60); return 0;&#125; 1096 Consecutive FactorsAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå…¶æœ€é•¿çš„å› å­åºåˆ—å¹¶è¦æ±‚è¿žç»­å› å­å°½å¯èƒ½å°ï¼Œä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œ630=3*5*6*7ï¼Œæ‰€ä»¥å…¶è¿žç»­å› å­åºåˆ—ä¸º5*6*7ï¼Œé•¿åº¦ä¸º 3 ä¸”æ­¤ä¸ºå…¶æœ€é•¿è¿žç»­å› å­åºåˆ—ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[]) &#123; ll n; scanf("%lld", &amp;n); ll sqr = sqrt(n), ansI = 0, ansLen = 0; for(ll i = 2; i &lt;= sqr; i++) &#123; ll temp = 1, j = i; while(1) &#123; temp *= j; if(n % temp != 0) break; if(j - i + 1 &gt; ansLen) &#123; ansI = i; ansLen = j - i + 1; &#125; j++; &#125; &#125; if(ansLen == 0) &#123; printf("1\n%lld\n", n); &#125; else &#123; printf("%lld\n", ansLen); for(ll i = 0; i &lt; ansLen; i++) &#123; printf("%lld", ansI + i); if(i &lt; ansLen - 1) putchar('*'); &#125; &#125; return 0;&#125; è´´ä¸ª C++ æš´åŠ›æ¨¡æ‹Ÿçš„è§£æ³•ï¼š123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;int main() &#123; int n; cin &gt;&gt; n; int anslen = 0; vector&lt;int&gt; ans; for(int i = 2; i &lt;= sqrt(n); i++) &#123; int len = 0, j = i; long long t = 1; vector&lt;int&gt; tmp; while(true) &#123; tmp.push_back(j); t *= j; if(n % t == 0) len++; else break; if(len &gt; anslen) &#123; anslen = len; ans = tmp; &#125; j++; &#125; &#125; if(anslen == 0) cout &lt;&lt; 1 &lt;&lt; endl &lt;&lt; n; else &#123; cout &lt;&lt; anslen &lt;&lt; endl; for(int i = 0; i &lt; anslen; i++) &#123; cout &lt;&lt; ans[i]; if(i &lt; anslen - 1) cout &lt;&lt; '*'; &#125; &#125; return 0;&#125; å› ä¸ºæ˜¯ä»Žå°åˆ°å¤§æžšä¸¾å› å­çš„ï¼Œæ‰€ä»¥å¦‚æžœæ˜¯ç¬¦åˆæ¡ä»¶çš„æœ€ç»ˆè§£ï¼Œé‚£ä¹ˆä¸€å®šæ»¡è¶³å› å­æ˜¯æœ€å°çš„ã€‚å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥ä»Žæ»‘åŠ¨çª—å£çš„è§’åº¦æ¥æ€è€ƒã€‚ 1097 Deduplication on a Linked ListAnalysisé¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸²é“¾è¡¨çš„å„ä¸ªç»“ç‚¹ï¼Œåˆ é™¤å…¶ä¸­é‡å¤çš„ç»“ç‚¹ï¼Œå¹¶å°†åˆ é™¤çš„ç»“ç‚¹é‡æ–°ç»„æˆä¸€ä¸ªé“¾è¡¨ã€‚ç„¶åŽï¼Œå…ˆè¾“å‡ºåŽŸé“¾è¡¨åˆ é™¤ç»“ç‚¹åŽçš„æ–°é“¾è¡¨ï¼Œç´§æŽ¥ç€åœ¨è¾“å‡ºç”±æ‰€åˆ é™¤çš„ç»“ç‚¹æž„æˆçš„é“¾è¡¨ã€‚ ä½¿ç”¨é™æ€é“¾è¡¨æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå…ˆé»˜è®¤åˆå§‹åŒ–é“¾è¡¨å†…çš„æ‰€æœ‰ç»“ç‚¹å…¨éƒ¨ä¸ºæ— æ•ˆç»“ç‚¹ï¼Œå³ç½®ä¸º2 * maxnï¼Œç„¶åŽå°†é“¾è¡¨å†…æ‰€æœ‰ç»“ç‚¹æ ¹æ®åœ°å€å­˜å‚¨ã€‚ç´§æŽ¥ç€ï¼ŒéåŽ†é“¾è¡¨ï¼Œä½¿ç”¨ä¸€ä¸ªboolæ•°ç»„æ¥è®°å½•ç»“ç‚¹æ˜¯å¦å‡ºçŽ°è¿‡ï¼Œå¯¹äºŽæ²¡æœ‰å‡ºçŽ°çš„åˆæ³•ç»“ç‚¹ï¼Œä»Ž0å¼€å§‹ç¼–å·ï¼Œå‡ºçŽ°è¿‡çš„ç»“ç‚¹ï¼Œä»Žmaxnå¼€å§‹ç¼–å·ã€‚æœ€åŽï¼Œä½¿ç”¨sortå‡½æ•°æ ¹æ®orderæ¥æŽ’åºï¼Œå°±å¯ä»¥å°†ç»“ç‚¹æŒ‰åºåˆ†ä¸ºåˆ é™¤ç»“ç‚¹åŽçš„é“¾è¡¨ã€æ–°é“¾è¡¨å’Œæ— æ•ˆç»“ç‚¹ä¸‰éƒ¨åˆ†ï¼Œåœ¨è¾“å‡ºå³å¯ã€‚ æ³¨æ„è¦ä½¿ç”¨%05dæ¥è¾“å‡ºåœ°å€ä½æ•°è¾ƒå°‘çš„ç»“ç‚¹ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;const int Table = 2 * maxn;struct node&#123; int address, next, key; int order;&#125; Node[maxn];bool isExist[Table] = &#123;false&#125;;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = 2 * maxn; &#125; int n, head, address; scanf("%d %d", &amp;head, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].key, &amp;Node[address].next); Node[address].address = address; &#125; int countValid = 0, countRemoved = 0, p = head; while(p != -1) &#123; if(!isExist[abs(Node[p].key)]) &#123; isExist[abs(Node[p].key)] = true; Node[p].order = countValid++; &#125; else &#123; Node[p].order = maxn + countRemoved++; &#125; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); int count = countValid + countRemoved; for(int i = 0; i &lt; count; i++) &#123; if(i != countValid - 1 &amp;&amp; i != count - 1) &#123; printf("%05d %d %05d\n", Node[i].address, Node[i].key, Node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", Node[i].address, Node[i].key); &#125; &#125; return 0;&#125; 1098 Insertion or Heap SortAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int origin[maxn], tempori[maxn], changed[maxn];int n;bool isSame(int A[], int B[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;bool showArray(int A[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", A[i]); if(i &lt; n) putchar(' '); &#125; putchar('\n');&#125;bool insertSort() &#123; bool flag = false; for(int i = 2; i &lt;= n; i++) &#123; if(i != 2 &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; sort(tempori, tempori + i + 1); if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void downAdjust(int low, int high) &#123; int i = low, j = 2 * i; while(j &lt;= high) &#123; if(j + 1 &lt;= high &amp;&amp; tempori[j + 1] &gt; tempori[j]) &#123; j = j + 1; &#125; if(tempori[j] &gt; tempori[i]) &#123; swap(tempori[j], tempori[i]); i = j; j = i * 2; &#125; else &#123; break; &#125; &#125;&#125;void heapSort() &#123; bool flag = false; for(int i = n / 2; i &gt;= 1; i--) &#123; downAdjust(i, n); &#125; for(int i = n; i &gt; 1; i--) &#123; if(i != n &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; swap(tempori[i], tempori[1]); downAdjust(1, i - 1); if(flag == true) &#123; showArray(tempori); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;origin[i]); tempori[i] = origin[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(insertSort()) &#123; printf("Insertion Sort\n"); showArray(tempori); &#125; else &#123; printf("Heap Sort\n"); for(int i = 1; i &lt;= n; i++) &#123; tempori[i] = origin[i]; &#125; heapSort(); &#125; return 0;&#125; 1099 Build A Binary Search TreeAnalysisé¢˜ç›®å¤§æ„ç»™å®šä¸€é¢—äºŒå‰æŽ’åºæ ‘ï¼ˆBSTï¼‰ï¼Œè¾“å‡ºè¿™æ£µæ ‘çš„å±‚æ¬¡åºåˆ—ã€‚ æ ¹æ®é¢˜ç›®è¾“å…¥æ•°æ®çš„å½¢å¼ï¼Œåˆ©ç”¨ç»“æž„æ•°ç»„å»ºæ ‘æ¯”è¾ƒæ–¹ä¾¿ã€‚å»ºæ ‘ä¹‹åŽï¼Œä¸­åºéåŽ†è¿™æ£µæ ‘ï¼Œå°†æŒ‰å‡åºæŽ’å¥½çš„ç»“ç‚¹å€¼åºåˆ—ï¼ŒæŒ‰ç…§é¡ºåºèµ‹ç»™æ¯ä¸ªç»“ç‚¹ï¼Œè¿™æ ·æ¯ä¸ªç»“ç‚¹çš„å€¼å°±ç¬¦åˆ BST çš„æ€§è´¨äº†ï¼ŒæŽ¥ç€å±‚æ¬¡éåŽ†ï¼Œè¾“å‡ºå…¶åºåˆ—å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int data; int left, right; &#125; Node[maxn];int n, number[maxn], index = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].left); Node[root].data = number[index++]; inorder(Node[root].right);&#125;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int front = q.front(); q.pop(); cout &lt;&lt; Node[front].data; if(num &lt; n - 1) &#123; cout &lt;&lt; ' '; num++; &#125; if(Node[front].left != -1) q.push(Node[front].left); if(Node[front].right != -1) q.push(Node[front].right); &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int lchild, rchild; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; lchild &gt;&gt; rchild; Node[i].left = lchild, Node[i].right = rchild; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(0); levelorder(0); return 0;&#125; 1100 Mars NumbersAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1044ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const*argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); string s; while(n--) &#123; string str; getline(cin, str); if('0' &lt;= str[0] &amp;&amp; str[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; str.length(); i++) &#123; num = num * 10 + (str[i] - '0'); &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[str] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1101 Quick SortAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1045ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int n, array[MAXN], leftmax[MAXN], rightmin[MAXN], pivot[MAXN]; int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftmax[0] = array[0]; for(int i = 1; i &lt; n; i++) &#123; leftmax[i] = max(leftmax[i - 1], array[i - 1]); &#125; rightmin[n - 1] = 0x3fffffff; for(int i = n - 2; i &gt;= 0; i--) &#123; rightmin[i] = min(rightmin[i + 1], array[i + 1]); &#125; int count = 0; for(int i = 0; i &lt; n; i++) &#123; if(leftmax[i] &lt;= array[i] &amp;&amp; array[i] &lt;= rightmin[i]) &#123; pivot[count++] = array[i]; &#125; &#125; printf("%d\n", count); for(int i = 0; i &lt; count; i++) &#123; printf("%d", pivot[i]); if(i &lt; count - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1102 Invert a Binary TreeAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåè½¬è¿™ä¸ªäºŒå‰æ ‘å¹¶è¾“å‡ºåè½¬åŽçš„äºŒå‰æ ‘çš„ä¸­åºåºåˆ—å’Œå±‚åºåºåˆ—ã€‚ æœ¬é¢˜ä½¿ç”¨ç»“æž„æ•°ç»„å»ºæ ‘æ¯”è¾ƒæ–¹ä¾¿ï¼Œå¹¶ä¸”åè½¬æ—¶ç›´æŽ¥äº¤æ¢æ¯ä¸ªç»“ç‚¹çš„å·¦å³å­©å­æŒ‡é’ˆå³å¯ã€‚ç„¶åŽå†åˆ©ç”¨ä¸­åºéåŽ†å’Œå±‚åºéåŽ†ï¼Œè¾“å‡ºå¯¹åº”çš„åºåˆ—ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int data; int lchild, rchild;&#125; Node[15]; int n;bool isRoot[15] = &#123;false&#125;;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;node&gt; q; q.push(Node[root]); while(!q.empty()) &#123; node top = q.front(); q.pop(); printf("%d", top.data); if(num &lt; n - 1) &#123; printf(" "); num++; &#125; if(top.lchild != -1) q.push(Node[top.lchild]); if(top.rchild != -1) q.push(Node[top.rchild]); &#125; putchar('\n');&#125;int num2 = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].lchild); printf("%d", Node[root].data); if(num2 &lt; n - 1) &#123; printf(" "); num2++; &#125; inorder(Node[root].rchild);&#125;int getroot() &#123; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; ret = i; break; &#125; &#125; return ret;&#125;void invert() &#123; int i = 0; for(int i = 0; i &lt; n; i++) &#123; swap(Node[i].lchild, Node[i].rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); getchar(); char left, right; for(int i = 0; i &lt; n; i++) &#123; scanf("%c %c", &amp;left, &amp;right); getchar(); if(left != '-') &#123; Node[i].lchild = left - '0'; isRoot[left - '0'] = true; &#125; else Node[i].lchild = -1; if(right != '-') &#123; Node[i].rchild = right - '0'; isRoot[right - '0'] = true; &#125; else Node[i].rchild = -1; Node[i].data = i; &#125; int root = getroot(); invert(); levelorder(root); inorder(root); return 0;&#125; 1103 Integer FactorizationAnalysisé¢˜ç›®å¤§æ„ï¼Œç»™å®šä¸‰ä¸ªæ•°Nã€Kå’ŒPï¼Œå°†Nè¡¨ç¤ºä¸ºKä¸ªå› å­çš„Pæ¬¡æ–¹çš„è¿žåŠ ã€‚æ³¨æ„é¢˜ç›®çš„è¦æ±‚ï¼š å› å­ä¹‹å’Œå¿…é¡»æœ€å¤§ å› å­åºåˆ—æŒ‰å­—å…¸åºæœ€å¤§ ç”±äºŽå­˜åœ¨å¤šè§£çš„æƒ…å†µï¼Œæœ¬é¢˜éœ€è¦å€ŸåŠ© DFS æ¥æœç´¢æ‰€æœ‰è§£ï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æœ€ä¼˜è§£ï¼Œå¯¹äºŽä¸Šè¿°ä¸¤ä¸ªé¢˜ç›®çš„è¦æ±‚ï¼Œå…¶å¯¹åº”çš„è§£å†³æ–¹æ³•ï¼š ä½¿ç”¨å…¨å±€å˜é‡ï¼Œè®°å½•æ¯ä¸ªè§£å’Œå…¶å› å­å’Œï¼Œé€‰æ‹©å› å­å’Œæœ€å¤§çš„ä¸ºæœ€ä¼˜è§£ å°†å› å­çš„Pæ¬¡æ–¹ä¾æ¬¡ç®—å¥½å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼Œç„¶åŽä»ŽåŽå¾€å‰æžšä¸¾å³å¯ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, k, p, maxFacsum = -1;vector&lt;int&gt; fac, ans, temp;int power(int x) &#123; int ret = 1; for(int i = 0; i &lt; p; i++) &#123; ret *= x; &#125; return ret;&#125;void init() &#123; int i = 0, temp = 0; while(temp &lt;= n) &#123; fac.push_back(temp); temp = power(++i); &#125;&#125;void DFS(int index, int nowK, int sum, int facSum) &#123; if(sum == n &amp;&amp; nowK == k) &#123; if(facSum &gt; maxFacsum) &#123; ans = temp; maxFacsum = facSum; &#125; return; &#125; if(sum &gt; n || nowK &gt; k) return; if(index - 1 &gt;= 0) &#123; temp.push_back(index); DFS(index, nowK + 1, sum + fac[index], facSum + index); temp.pop_back(); DFS(index - 1, nowK, sum, facSum); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;p); init(); DFS(fac.size() - 1, 0, 0, 0); if(maxFacsum == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%d = %d^%d", n, ans[0], p); for(int i = 1; i &lt; ans.size(); i++) &#123; printf(" + %d^%d", ans[i], p); &#125; &#125; return 0;&#125; 1104 Sum of Number SegmentsAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1049ä¸€æ ·ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; int i = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1106 Lowest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;vector&lt;int&gt; child[maxn];int tot = 0, n, minDepth = maxn;double p, r;void DFS(int index, int depth) &#123; if(child[index].size() == 0) &#123; if(depth &lt; minDepth) &#123; minDepth = depth; tot = 1; &#125; else if(depth == minDepth) &#123; tot++; &#125; return; &#125; for(int i = 0; i &lt; child[index].size(); i++) &#123; DFS(child[index][i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100.0; int num, subchild; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf("%d", &amp;subchild); child[i].push_back(subchild); &#125; &#125; DFS(0, 0); double ans = p * pow(1 + r, minDepth); printf("%.4lf %d", ans, tot); return 0;&#125; 1107 Social ClustersAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int father[maxn], isroot[maxn] = &#123;0&#125;, hobby[maxn] = &#123;0&#125;;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = father[faB]; &#125;&#125;void init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main(int argc, char const *argv[]) &#123; int n, k, h; scanf("%d", &amp;n); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d:", &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;h); if(hobby[h] == 0) &#123; hobby[h] = i; &#125; Union(i, hobby[h]); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; isroot[findFather(i)]++; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; if(isroot[i] != 0) &#123; ans++; &#125; &#125; printf("%d\n", ans); sort(isroot + 1, isroot + n + 1, cmp); for(int i = 1; i &lt;= ans; i++) &#123; printf("%d", isroot[i]); if(i &lt; ans) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitç®€æ˜“æŒ‡å—]]></title>
    <url>%2F2019%2F06%2F23%2FGit%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[IntroGit æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œè€Œ Github åˆ™æ˜¯ç›®å‰å…¨çƒæœ€å¤§çš„å¼€æºç¤¾åŒºï¼Œé‚£ä¹ˆä½•è°“â€œç‰ˆæœ¬æŽ§åˆ¶â€ï¼Ÿç‰ˆæœ¬æŽ§åˆ¶æ˜¯ä¸€ç§è®°å½•ä¸€ä¸ªæˆ–è‹¥å¹²æ–‡ä»¶å†…å®¹å˜åŒ–ï¼Œä»¥ä¾¿å°†æ¥æŸ¥é˜…ç‰¹å®šç‰ˆæœ¬ä¿®è®¢æƒ…å†µçš„ç³»ç»Ÿï¼Œä½¿ç”¨Gitå¯ä»¥å¯¹ä»»ä½•ç±»åž‹çš„æ–‡ä»¶è¿›è¡Œç‰ˆæœ¬æŽ§åˆ¶ã€‚ ä¸åŒäºŽæœ¬åœ°ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿå’Œé›†ä¸­å¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œåˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„ä¼˜ç‚¹åœ¨äºŽå…¶å¯¹æ–‡ä»¶ä¸¢å¤±é£Žé™©çš„è§„é¿èƒ½åŠ›ã€‚ç®€è€Œè¨€ä¹‹ï¼Œåˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿä¸­çš„æ¯ä¸ªå®¢æˆ·ç«¯ï¼Œéƒ½å…·æœ‰å®Œæ•´çš„æ–‡ä»¶ï¼Œå³åŽŸå§‹ä»“åº“çš„é•œåƒã€‚ Basic Conceptionåœ¨å¼€å§‹ç›´æŽ¥ä½¿ç”¨ Git ä¹‹å‰ï¼Œå¾—å…ˆäº†è§£ä¸€ä¸‹ Git å†…çš„åŸºæœ¬æ¦‚å¿µðŸ§ï¼Œäº†è§£è¿™äº›æ¦‚å¿µä¼šæ›´å¥½çš„ç†è§£ Git çš„å·¥ä½œæ–¹å¼å’ŒåŽŸç†ã€‚ Snapshots, Not Differenceså¦‚æ ‡é¢˜æ‰€è¨€ï¼Œï¼ˆè®°å½•ï¼‰å¿«ç…§ï¼Œè€Œä¸æ˜¯å·®å¼‚ã€‚ä¸åŒäºŽå…¶ä»–ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„å·®å¼‚æ¯”è¾ƒï¼ŒGit ä¼šå°†æ–‡ä»¶è§†ä½œâ€œå¿«ç…§â€ï¼Œæ¯æ¬¡æäº¤æ›´æ–°åŽï¼ŒGit ä¼šå¯¹ä¹‹å‰çš„æ–‡ä»¶åˆ¶ä½œä¸€ä¸ªå¿«ç…§å¹¶ä¿å­˜è¿™ä¸ªå¿«ç…§çš„ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒGit ä¼šå°†æ›´æ–°åŽçš„æ–‡ä»¶æ›¿æ¢æŽ‰ä¹‹å‰æ–‡ä»¶ï¼ŒåŒæ—¶ï¼ŒGit ä¸å†é‡æ–°å­˜å‚¨è¯¥æ–‡ä»¶ï¼Œè€Œæ˜¯åªä¿ç•™ä¸€ä¸ªé“¾æŽ¥æŒ‡å‘ä¹‹å‰å­˜å‚¨çš„æ–‡ä»¶ï¼ˆå¿«ç…§ï¼‰ã€‚ Nearly Every Operation Is Localåœ¨ Git ä¸­çš„ç»å¤§å¤šæ•°æ“ä½œéƒ½åªéœ€è¦è®¿é—®æœ¬åœ°æ–‡ä»¶å’Œèµ„æºï¼Œä¸€èˆ¬ä¸éœ€è¦æ¥è‡ªç½‘ç»œä¸Šå…¶ä»–è®¡ç®—æœºçš„ä¿¡æ¯ã€‚å› ä¸ºï¼Œåœ¨æœ¬åœ°ä¿å­˜ç€è¿™ä¸ªé¡¹ç›®æ–‡ä»¶çš„é•œåƒï¼Œä½ å¯ä»¥ç¦»çº¿è¿›è¡Œæäº¤ï¼Œå¹¶åœ¨ç½‘ç»œçŠ¶æ€è‰¯å¥½çš„æ—¶å€™ï¼Œåœ¨æŽ¨é€åˆ°ä¸»æœåŠ¡å™¨ä¸Šã€‚ The Three StatesGit æœ‰ä¸‰ç§çŠ¶æ€ï¼Œæœ¬åœ°ä»“åº“å†…çš„æ–‡ä»¶å¯èƒ½å¤„äºŽå…¶ä¸­ä¹‹ä¸€ï¼šå·²æäº¤ï¼ˆcommittedï¼‰ã€å·²ä¿®æ”¹ï¼ˆmodifiedï¼‰å’Œå·²æš‚å­˜ï¼ˆstagedï¼‰ã€‚å·²æäº¤å·²ä¿®æ”¹å·²æš‚å­˜æ•°æ®å·²ç»å®‰å…¨çš„ä¿å­˜åœ¨æœ¬åœ°æ•°æ®åº“ä¸­ã€‚ä¿®æ”¹äº†æ–‡ä»¶ï¼Œä½†è¿˜æ²¡ä¿å­˜åˆ°æ•°æ®åº“ä¸­ã€‚å¯¹ä¸€ä¸ªå·²ä¿®æ”¹æ–‡ä»¶çš„å½“å‰ç‰ˆæœ¬åšäº†æ ‡è®°ï¼Œä½¿ä¹‹åŒ…å«åœ¨ä¸‹æ¬¡æäº¤çš„å¿«ç…§ä¸­ã€‚ ç”±æ­¤å¼•å…¥ Git é¡¹ç›®çš„ä¸‰ä¸ªå·¥ä½œåŒºåŸŸçš„æ¦‚å¿µï¼šGit ä»“åº“ã€å·¥ä½œç›®å½•åŠæš‚å­˜åŒºåŸŸã€‚ Git ä»“åº“å·¥ä½œç›®å½•æš‚å­˜åŒºåŸŸGit ç”¨æ¥ä¿å­˜é¡¹ç›®çš„å…ƒæ•°æ®å’Œå¯¹è±¡æ•°æ®åº“çš„åœ°æ–¹ï¼Œä»Žå…¶ä»–è®¡ç®—æœºå…‹éš†ä»“åº“æ—¶ï¼Œæ‹·è´çš„å°±æ˜¯è¿™é‡Œçš„æ•°æ®ã€‚å¯¹é¡¹ç›®çš„æŸä¸ªç‰ˆæœ¬ç‹¬ç«‹æå–å‡ºæ¥çš„å†…å®¹ï¼Œè¿™äº›ä»Ž Git ä»“åº“çš„åŽ‹ç¼©æ•°æ®ä¸­æå–å‡ºæ¥çš„æ–‡ä»¶ï¼Œæ”¾åœ¨ç£ç›˜ä¸Šä¾›ç”¨æˆ·ä½¿ç”¨æˆ–ä¿®æ”¹ã€‚æš‚å­˜åŒºåŸŸæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œä¿å­˜äº†ä¸‹æ¬¡å°†æäº¤çš„æ–‡ä»¶åˆ—è¡¨ä¿¡æ¯ï¼Œä¸€èˆ¬åœ¨ Git ä»“åº“ç›®å½•ä¸­ï¼Œæœ‰æ—¶ä¹Ÿè¢«ç§°ä½œâ€œç´¢å¼•â€ã€‚ åŸºæœ¬çš„ Git å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š åœ¨å·¥ä½œç›®å½•ä¸­ä¿®æ”¹æ–‡ä»¶ æš‚å­˜æ–‡ä»¶ï¼Œå°†æ–‡ä»¶çš„å¿«ç…§æ”¾å…¥æš‚å­˜åŒºåŸŸ æäº¤æ›´æ–°ï¼Œæ‰¾åˆ°æš‚å­˜åŒºåŸŸçš„æ–‡ä»¶ï¼Œå°†å¿«ç…§æ°¸ä¹…æ€§å­˜å‚¨åˆ° Git ä»“åº“å†… How to useGit æœ‰å¤šç§ä½¿ç”¨æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨åŽŸç”Ÿçš„å‘½ä»¤è¡Œæ¨¡å¼ï¼ˆæŽ¨èï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ GUI æ¨¡å¼ï¼Œä½†åªæœ‰åœ¨å‘½ä»¤è¡Œæ¨¡å¼ä¸‹ï¼Œæ‰å¯ä»¥æ‰§è¡Œ Git çš„æ‰€æœ‰å‘½ä»¤ã€‚ Installing Gité’ˆå¯¹ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼ŒGit çš„å®‰è£…æ–¹æ³•ä¹Ÿä¸ç›¸åŒï¼Œå¯¹äºŽçŽ°åœ¨æ¯”è¾ƒæˆç†Ÿçš„ Git è€Œè¨€ï¼Œä¸åŒå®‰è£…æ–¹å¼æ‰€å¸¦æ¥çš„åŠŸèƒ½ä¸Šçš„å·®å¼‚å·²ç»ä¸æ˜¯é‚£ä¹ˆæ˜Žæ˜¾ã€‚å¯¹äºŽWindowsç”¨æˆ·è€Œè¨€ï¼Œåœ¨ Git å®˜ç½‘ä¸Šä¸‹è½½åŽå®‰è£…å³å¯ã€‚å…¶ä»–æ–¹å¼è¿™é‡Œä¸å†åšè¿‡å¤šä»‹ç»ã€‚ First-Time Git Setupå®‰è£…å¥½äº† Git ä¹‹åŽï¼Œéœ€è¦å¯¹ Git çŽ¯å¢ƒåšå®šé‡çš„å®šåˆ¶åŒ–æ“ä½œï¼Œæ¯å°è®¡ç®—æœºä¸Šåªç”¨é…ç½®ä¸€æ¬¡ï¼Œç¨‹åºå‡çº§æ—¶ä¼šä¿ç•™é…ç½®ä¿¡æ¯ï¼Œä¹Ÿå¯ä»¥åœ¨ä»»ä½•æ—¶å€™å†æ¬¡é€šè¿‡è¿è¡Œå‘½ä»¤æ¥ä¿®æ”¹å®ƒä»¬ã€‚ User Identityå½“å®‰è£…å®Œ Git åŽåº”è¯¥åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯è®¾ç½®ä½ çš„ç”¨æˆ·åç§°ä¸Žé‚®ä»¶åœ°å€ï¼ŒåŽé¢çš„æ¯ä¸€æ¬¡æäº¤éƒ½ä¼šä½¿ç”¨è¿™äº›ä¿¡æ¯ï¼Œå¹¶ä¸”å®ƒä¼šå†™å…¥åˆ°ä½ çš„æ¯ä¸€æ¬¡æäº¤ä¸­ï¼Œä¸å¯æ›´æ”¹ã€‚12$ git config --global user.name "Bachzart"$ git config --global user.email "whistlesilp@gmail.com" å¦‚æžœä½¿ç”¨äº†--globalé€‰é¡¹ï¼Œé‚£ä¹ˆè¯¥å‘½ä»¤åªéœ€è¦è¿è¡Œä¸€æ¬¡ï¼Œå› ä¸ºä¹‹åŽæ— è®ºåšä»»ä½•äº‹æƒ…ï¼ŒGit éƒ½ä¼šä½¿ç”¨é‚£äº›ä¿¡æ¯ã€‚è‹¥åƒé’ˆå¯¹ç‰¹å®šé¡¹ç›®ä½¿ç”¨ä¸åŒçš„ç”¨æˆ·åç§°ä¸Žé‚®ä»¶åœ°å€æ—¶ï¼Œå¯ä»¥åœ¨é‚£ä¸ªé¡¹ç›®ç›®å½•ä¸‹è¿è¡Œæ²¡æœ‰--globalé€‰é¡¹çš„å‘½ä»¤æ¥é…ç½®ã€‚ User Editorç”¨æˆ·ä¿¡æ¯è®¾ç½®å®Œæ¯•åŽï¼Œå¯ä»¥é…ç½®é»˜è®¤æ–‡æœ¬ç¼–è¾‘å™¨ï¼Œå½“ Git éœ€è¦ä½ è¾“å…¥ä¿¡æ¯æ—¶ä¼šè°ƒç”¨å®ƒã€‚å¦‚æžœæœªé…ç½®ï¼ŒGit ä¼šä½¿ç”¨æ“ä½œç³»ç»Ÿé»˜è®¤çš„æ–‡æœ¬ç¼–è¾‘å™¨ã€‚1$ git config --gloabl core.editor emacs Checkingå¦‚ä½•æ£€æŸ¥ Git é…ç½®ä¿¡æ¯å‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥åˆ—å‡ºåœ¨å½“å‰ç›®å½•ä¸‹ Git èƒ½æ‰¾åˆ°çš„æ‰€æœ‰é…ç½®ä¿¡æ¯ã€‚1$ git config --list å¯ä»¥å¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºç»“æžœï¼š12345678910111213141516171819core.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslcainfo=D:/Git/Git/mingw64/ssl/certs/ca-bundle.crthttp.sslbackend=openssldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecredential.helper=manageruser.name=Bachzartuser.email=whistlesilp@gmail.com Getting HelpGit è‡ªå¸¦æœ‰è¯´æ˜Žæ–‡æ¡£ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨ä»¥ä¸‹ä¸‰ä¸ªå‘½ä»¤æŸ¥æ‰¾æŒ‡å®šå‘½ä»¤çš„ä½¿ç”¨è¯´æ˜Žï¼Œæˆ–ç™¾åº¦ã€googleã€‚123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; è‹¥æƒ³èŽ·å¾—configå‘½ä»¤çš„æ‰‹å†Œï¼Œæ‰§è¡Œ1$ git help config Summaryä¸Šé¢çš„å†…å®¹ä»‹ç»äº† Git æ˜¯ä»€ä¹ˆï¼ŒGit å’Œå…¶ä»–ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„åŒºåˆ«å’ŒåŸºæœ¬ç”¨æ³•ç­‰ï¼ŒæŽ¥ä¸‹æ¥å°±å¼€å§‹ä½¿ç”¨å§~ Basic Usageåœ¨ç†Ÿæ‚‰äº† Git çš„åŸºæœ¬æ¦‚å¿µå’Œç”¨æ³•åŽï¼Œå°±å¯ä»¥å¼€å§‹ä½¿ç”¨äº†ã€‚ Getting a Git RepositoryèŽ·å– Git é¡¹ç›®ä»“åº“çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼š åœ¨çŽ°æœ‰é¡¹ç›®æˆ–ç›®å½•ä¸‹å¯¼å…¥æ‰€æœ‰æ–‡ä»¶åˆ° Git ä¸­ ä»Žä¸€ä¸ªæœåŠ¡å™¨å…‹éš†çŽ°æœ‰çš„ Git ä»“åº“ Initializing a Repository in an Existing Directoryå¦‚æžœåªæƒ³åœ¨æœ¬åœ°é€šè¿‡ Git æ¥è¿›è¡Œç‰ˆæœ¬æŽ§åˆ¶ï¼Œé‚£ä¹ˆåœ¨bashå†…è¿›å…¥åˆ°æƒ³è¦å»ºç«‹ä»“åº“çš„ç›®å½•ï¼Œé€šè¿‡ä»¥ä¸‹å‘½ä»¤å°±å¯ä»¥å»ºç«‹ä¸€ä¸ªä»“åº“äº†ã€‚1$ git init æ­¤æ—¶ï¼Œåœ¨è¿™ä¸ªæœ¬åœ°ç›®å½•ä¸‹ä¼šè‡ªåŠ¨äº§ç”Ÿä¸€ä¸ªâ€œ.gitâ€çš„ç›®å½•ï¼Œè¿™ä¸ªå°±æ˜¯ Git ç®¡ç†ä¿¡æ¯çš„ç›®å½•ï¼Œåœ¨ Windows ä¸‹é»˜è®¤éšè—ã€‚ Cloning an Existing Repositoryå¦‚æžœåªæ˜¯æƒ³èŽ·å–ä¸€ä»½ç½‘ç»œä¸Šï¼ˆæˆ–å±€åŸŸç½‘æœåŠ¡å™¨ï¼‰å·²å­˜åœ¨çš„ Git ä»“åº“çš„æ‹·è´ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ¥å°†ä»“åº“å…‹éš†åˆ°æœ¬åœ°ã€‚1$ git clone https://github.com/example ä¸Šè¿°å‘½ä»¤çš„æ ¼å¼ä¸ºgit clone [url]ï¼Œhttps://github.com/exampleè¿™ä¸ªurlå¹¶ä¸æ˜¯çœŸæ­£çš„å­˜åœ¨ï¼Œè¿™é‡Œåªåšè¯´æ˜Žä½¿ç”¨ã€‚ æ­¤æ—¶åœ¨å½“å‰ç›®å½•ä¸‹ä¼šåˆ›å»ºä¸€ä¸ªâ€œexampleâ€çš„ç›®å½•ï¼Œå¹¶åœ¨è¿™ä¸ªç›®å½•ä¸‹åˆå§‹åŒ–ä¸€ä¸ª.gitç›®å½•ï¼Œä»Žè¿œç¨‹ä»“åº“æ‹‰å–ä¸‹æ‰€æœ‰æ•°æ®æ”¾å…¥.gitç›®å½•ï¼Œç„¶åŽä»Žä¸­è¯»å–æœ€æ–°ç‰ˆæœ¬çš„æ–‡ä»¶æ‹·è´ã€‚å¦‚æžœæƒ³é‡å‘½åå…‹éš†ä¸‹æ¥çš„æœ¬åœ°ä»“åº“çš„åå­—ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤ï¼š1$ git clone https://github.com/example myexample Local Repositoryå‰é¢å·²ç»æåˆ°äº†å¦‚ä½•åœ¨æœ¬åœ°åˆ›å»º Git ä»“åº“ï¼ŒçŽ°åœ¨æ¥ä½¿ç”¨ä¸€ä¸‹ Git çš„éƒ¨åˆ†åŠŸèƒ½ã€‚ Checking the Status of Local Reposityè¦æŸ¥çœ‹å½“å‰ç›®å½•ä¸‹å“ªäº›æ–‡ä»¶å¤„äºŽä»€ä¹ˆçŠ¶æ€ï¼Œå¯ä»¥ä½¿ç”¨git statusã€‚ä»¥åœ¨æœ¬åœ°æ–°å»ºçš„ä»“åº“ä¸ºä¾‹ï¼Œå½“ä½¿ç”¨git statuså‘½ä»¤æ—¶ï¼Œä¼šå‡ºçŽ°å¦‚ä¸‹ç»“æžœï¼š1234$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track) æ ¹æ®æ˜¾ç¤ºçš„è‹±æ–‡çš„å«ä¹‰ï¼Œå¯ä»¥å¾—çŸ¥å½“å‰ç›®å½•ä¸‹ï¼Œæ²¡æœ‰æ–‡ä»¶ï¼Œä¹Ÿæ— æ³•è¿›è¡Œæäº¤ï¼Œå¯ä»¥ä½¿ç”¨git addå‘½ä»¤æ¥è·Ÿè¸ªæ–‡ä»¶ã€‚ Tracking a new fileçŽ°åœ¨ï¼Œåœ¨ä»“åº“å†…åˆ›å»ºä¸€ä¸ªæ–°çš„test.cæ–‡ä»¶ï¼Œåœ¨ä½¿ç”¨git statuså‘½ä»¤æ¥æŸ¥çœ‹å½“å‰ç›®å½•çš„çŠ¶æ€ã€‚123456789$ git statusOn branch masterNo commits yetUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.cnothing added to commit but untracked files present (use "git add" to track) æ­¤æ—¶ï¼Œåœ¨Untracked filesä¸‹é¢ï¼Œå‡ºçŽ°äº†test.cæ–‡ä»¶ï¼Œè¿™æ„å‘³ç€ Git åœ¨ä¹‹å‰çš„å¿«ç…§ï¼ˆæäº¤ï¼‰ä¸­æ²¡æœ‰è¿™äº›æ–‡ä»¶ï¼ˆå®žé™…ä¸Šï¼Œç›®å‰è¿˜æ²¡æœ‰ä¸€æ¬¡æäº¤ï¼‰ã€‚Gitä¸ä¼šè‡ªåŠ¨å°†æ–‡ä»¶çº³å…¥è·Ÿè¸ªèŒƒå›´ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨git add [file name]å‘½ä»¤æ¥è·Ÿè¸ªæŒ‡å®šæ–‡ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c æ­¤æ—¶ï¼Œå¯ä»¥çœ‹åˆ°Changes to be committedè¿™è¡Œä¸‹ï¼Œå­˜åœ¨new file: test.cï¼Œå°±è¯´æ˜Žtest.cæ–‡ä»¶æ˜¯å·²æš‚å­˜çŠ¶æ€ï¼ˆstagedï¼‰äº†ã€‚å¦å¤–ï¼Œgit addå‘½ä»¤ä½¿ç”¨æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ä½œä¸ºå‚æ•°ï¼›å¦‚æžœå‚æ•°æ˜¯ç›®å½•çš„è·¯å¾„ï¼Œè¯¥å‘½ä»¤å°†é€’å½’åœ°è·Ÿè¸ªè¯¥ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ã€‚ Staging Modified Filesç´§æŽ¥ä¸Šé¢çš„æ­¥éª¤ï¼Œè‹¥æ­¤æ—¶ï¼Œä¿®æ”¹äº†å·²æš‚å­˜çš„test.cæ–‡ä»¶ï¼Œæ­¤æ—¶ä½¿ç”¨git statuså‘½ä»¤ï¼Œä¼šçœ‹åˆ°å¦‚ä¸‹ç»“æžœï¼š123456789101112On branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.cChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: test.c è¿™å®žé™…ä¸Šå°±æ˜¯ Git çš„ç‰ˆæœ¬æŽ§åˆ¶æœºåˆ¶çš„ç‰¹ç‚¹â€”ä¿å­˜æ–‡ä»¶çš„å¿«ç…§è€Œä¸æ˜¯å·®å¼‚ã€‚ä¹Ÿå³æ˜¯è¯´ï¼ŒçŽ°åœ¨ Git æš‚å­˜åŒºåŸŸå†…å­˜å‚¨çš„æ–‡ä»¶æ˜¯ä»æœªä¿®æ”¹çš„test.cï¼Œè¦æš‚å­˜è¿™æ¬¡æ›´æ–°ï¼Œéœ€è¦å†æ¬¡ä½¿ç”¨git addå‘½ä»¤æ¥å®Œæˆæš‚å­˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c git statuså‘½ä»¤çš„è¾“å‡ºååˆ†è¯¦ç»†ï¼Œä½¿ç”¨git status -sæˆ–git status --shortå¯ä»¥å¾—åˆ°æ›´åŠ ç´§å‡‘çš„ä¿¡æ¯ï¼š1234$ git status -sA change.cAM test.c?? test.exe æ–°æ·»åŠ çš„æœªè·Ÿè¸ªæ–‡ä»¶å‰é¢æœ‰??æ ‡è®°ï¼Œæ–°æ·»åŠ åˆ°æš‚å­˜åŒºåŸŸçš„æ–‡ä»¶å‰é¢æœ‰Aæ ‡è®°ï¼Œä¿®æ”¹è¿‡çš„æ–‡ä»¶å‰é¢æœ‰Mæ ‡è®°ï¼›å½“ç„¶ï¼ŒMçš„æœ‰ä¸¤ä¸ªå¯èƒ½çš„å‡ºçŽ°ä½ç½®ï¼Œå‡ºçŽ°åœ¨å³è¾¹çš„Mè¡¨ç¤ºè¯¥æ–‡ä»¶è¢«ä¿®æ”¹äº†ä½†æ˜¯è¿˜æ²¡æ”¾å…¥æš‚å­˜åŒºï¼Œå‡ºçŽ°åœ¨å·¦è¾¹çš„Mè¡¨ç¤ºè¯¥æ–‡ä»¶è¢«ä¿®æ”¹å¹¶æ”¾å…¥äº†æš‚å­˜åŒºã€‚ä¾‹å¦‚ï¼Œä¸Šé¢çš„çŠ¶æ€æ˜¾ç¤ºtest.cæ–‡ä»¶åœ¨å·¥ä½œåŒºè¢«ä¿®æ”¹äº†ï¼Œè¿˜æœªæ”¾å…¥æš‚å­˜åŒºã€‚ Ignoring Filesä¸€èˆ¬æ€»ä¼šæœ‰äº›æ–‡ä»¶æ— éœ€çº³å…¥ Git çš„ç®¡ç†ï¼Œä¹Ÿä¸å¸Œæœ›å®ƒä»¬æ€»å‡ºçŽ°åœ¨æœªè·Ÿè¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œé€šå¸¸è¿™ç±»æ–‡ä»¶éƒ½æ˜¯äº›è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ï¼Œæ¯”å¦‚æ—¥å¿—æ–‡ä»¶ï¼Œæˆ–è€…ç¼–è¯‘è¿‡ç¨‹ä¸­åˆ›å»ºçš„ä¸´æ—¶æ–‡ä»¶ç­‰ã€‚æ­¤æ—¶ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªåä¸º.gitignoreçš„æ–‡ä»¶ï¼Œåˆ—å‡ºè¦å¿½ç•¥çš„æ–‡ä»¶æ¨¡å¼ã€‚12345$ vim .gitignore*.[oa]*~*.exe*.txt .gitignoreæ–‡ä»¶çš„æ ¼å¼è§„èŒƒå¦‚ä¸‹ï¼š æ‰€æœ‰ç©ºè¡Œæˆ–è€…ä»¥#å¼€å¤´çš„è¡Œéƒ½ä¼šè¢« Git å¿½ç•¥ å¯ä»¥ä½¿ç”¨æ ‡å‡†çš„ glob æ¨¡å¼åŒ¹é… åŒ¹é…æ¨¡å¼å¯ä»¥ä»¥/å¼€å¤´é˜²æ­¢é€’å½’ åŒ¹é…æ¨¡å¼å¯ä»¥ä»¥/ç»“å°¾æŒ‡å®šç›®å½• è¦å¿½ç•¥æŒ‡å®šæ¨¡å¼ä»¥å¤–çš„æ–‡ä»¶æˆ–ç›®å½•ï¼Œå¯ä»¥åœ¨æ¨¡å¼å‰åŠ ä¸ŠæƒŠå¹å·!å–å æ‰€è°“çš„ glob æ¨¡å¼æ˜¯æŒ‡ shell æ‰€ä½¿ç”¨çš„ç®€åŒ–äº†çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ¯”å¦‚*å°±å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªä»»æ„å­—ç¬¦ã€‚ TIPSï¼šGitHubæœ‰ä¸€ä¸ªååˆ†è¯¦ç»†çš„é’ˆå¯¹æ•°åç§é¡¹ç›®åŠè¯­è¨€çš„.gitignoreæ–‡ä»¶åˆ—è¡¨ï¼Œå¯ä»¥è®¿é—® https://github.com/github/gitignore èŽ·å–æ›´å¤šå¸®åŠ©ã€‚ Viewing Changesgit statuså‘½ä»¤è¾“å‡ºçš„ä¿¡æ¯åªå¯¹æ–‡ä»¶æ‰€å¤„çš„çŠ¶æ€è¿›è¡Œäº†å±•ç¤ºï¼Œå¯èƒ½è§‰å¾—æ¨¡ç³Šï¼Œå¦‚æžœæƒ³çŸ¥é“å…·ä½“æ”¹äº†ä»€ä¹ˆåœ°æ–¹ï¼Œå¯ä»¥ä½¿ç”¨git diffå‘½ä»¤ã€‚git diffå‘½ä»¤ä¼šå›žç­”ä¸¤ä¸ªé—®é¢˜ï¼š å½“å‰åšçš„é‚£äº›æ›´æ–°è¿˜æ²¡æœ‰æš‚å­˜ï¼Ÿ æœ‰å“ªäº›æ›´æ–°å·²ç»æš‚å­˜èµ·æ¥å‡†å¤‡å¥½äº†ä¸‹æ¬¡æäº¤ï¼Ÿ git diffä¼šé€šè¿‡æ–‡ä»¶è¡¥ä¸çš„æ ¼å¼åœ¨ç›¸åº”æ ä¸‹æ˜¾ç¤ºå…·ä½“å“ªäº›è¡Œå‘ç”Ÿäº†æ”¹å˜ã€‚çŽ°åœ¨ä¿®æ”¹test.cæ–‡ä»¶ï¼Œåœ¨æ–‡ä»¶ä¸­åŠ å…¥å¦‚ä¸‹ä¸€è¡Œï¼štest.c12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0;&#125; æŽ¥ä¸‹æ¥ï¼Œä½¿ç”¨git diffå‘½ä»¤æŸ¥çœ‹ä¿®æ”¹çš„éƒ¨åˆ†ï¼š12345678910111213$ git diffdiff --git a/test.c b/test.cindex e0e5171..8642431 100644--- a/test.c+++ b/test.c@@ -3,5 +3,6 @@ int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0; &#125;\ No newline at end of file å¯ä»¥çœ‹åˆ°ï¼ŒGit å›žæ˜¾äº†æ–‡ä»¶æ›´æ–°åŒºåŸŸçš„ä¿¡æ¯ä»¥åŠå¯¹åº”çš„æ›´æ–°å†…å®¹ï¼Œè€Œæ­¤æ—¶ï¼Œgit diffæ¯”è¾ƒçš„æ˜¯å·¥ä½œç›®å½•ä¸­å½“å‰æ–‡ä»¶ï¼ˆæœªæš‚å­˜ï¼‰å’Œæš‚å­˜åŒºåŸŸå¿«ç…§ï¼ˆå·²æš‚å­˜ï¼‰ä¹‹é—´çš„å·®å¼‚ï¼Œä¹Ÿå°±æ˜¯ä¿®æ”¹ä¹‹åŽè¿˜æ²¡æš‚å­˜èµ·æ¥çš„å˜åŒ–å†…å®¹ã€‚ ä½¿ç”¨git diff --cached/git diff --stagedå¯ä»¥æŸ¥çœ‹å·²æš‚å­˜çš„å°†è¦æ·»åŠ åˆ°ä¸‹æ¬¡æäº¤é‡Œçš„å†…å®¹ã€‚123456789101112131415$ git diff --cacheddiff --git a/test.c b/test.cnew file mode 100644index 0000000..e0e5171--- /dev/null+++ b/test.c@@ -0,0 +1,7 @@+#include &lt;stdio.h&gt;++int main(int argc, char const *argv[]) &#123;+ printf("Hello Git!\n");+ printf("I want to change this file.\n");+ return 0;+&#125;\ No newline at end of file æ³¨æ„åˆ°ä¸Šé¢å¹¶æ²¡æœ‰printf(&quot;Test git diff!\n&quot;);ï¼Œé‚£æ˜¯å› ä¸ºï¼Œæ›´æ–°åŽçš„test.cæ–‡ä»¶å¹¶æ²¡æœ‰æš‚å­˜ã€‚å¦å¤–ï¼Œgit diffåªèƒ½æ˜¾ç¤ºå°šæœªæš‚å­˜çš„æ”¹åŠ¨ï¼Œè€Œä¸æ˜¯è‡ªä¸Šæ¬¡æäº¤ï¼ˆcommitï¼‰ä»¥æ¥æ‰€ä½œçš„æ‰€æœ‰æ”¹åŠ¨ã€‚ Committing ChangesçŽ°åœ¨çš„æš‚å­˜åŒºä¸Žå·²ç»æ‘¸ç†Ÿäº†ï¼Œå¯ä»¥æ¥æ„‰å¿«çš„æäº¤äº†ðŸ˜Šï¼Œä¸è¿‡æ­£å¼ä½¿ç”¨ä»“åº“çš„æ—¶å€™ï¼Œæäº¤ä¹‹å‰æœ€å¥½çœ‹çœ‹æœ‰æ²¡æœ‰ä»€ä¹ˆè®°å½•æ²¡æœ‰æš‚å­˜èµ·æ¥ï¼Œå¯ä»¥å…ˆç”¨git statuså‘½ä»¤çœ‹ä¸‹ï¼Œæ˜¯ä¸æ˜¯éƒ½å·²æš‚å­˜èµ·æ¥äº†ï¼Œç„¶åŽè¿è¡Œæäº¤å‘½ä»¤ï¼š1$ git commit æäº¤åŽï¼Œä¼šè·³å…¥åˆ° vi/vim ç¼–è¾‘å™¨ç•Œé¢ï¼ˆä¸åŒç³»ç»Ÿå¯èƒ½ä¸ä¸€è‡´ï¼‰ï¼ŒåŸºæœ¬ä¸Šéƒ½æ˜¯é»˜è®¤çš„æäº¤æ¶ˆæ¯ï¼Œä¿å­˜åœ¨.gitç›®å½•ä¸‹çš„COMMIT_EDITMSGæ–‡ä»¶å†…ï¼Œå¼€å¤´çš„ç©ºè¡Œç”¨æ¥é”®å…¥æäº¤è¯´æ˜Žï¼Œå…¶ä»–#å¼€å¤´çš„éƒ½æ˜¯æ³¨é‡Šï¼ŒåŽ»æŽ‰ä¸Žå¦å–å†³äºŽä¸ªäººï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥ç®€åŒ–æäº¤ï¼š123456$ git commit -m "Test Commit"[master (root-commit) 88ba107] Test Commit 3 files changed, 18 insertions(+) create mode 100644 .gitignore create mode 100644 change.c create mode 100644 test.c æ³¨æ„ï¼Œmasterè¡¨ç¤ºå½“å‰æäº¤æ˜¯åœ¨masteråˆ†æ”¯è¿›è¡Œçš„æäº¤ï¼Œ88ba107å°±æ˜¯æœ¬æ¬¡æäº¤çš„å®Œæ•´ SHA-1 æ ¡éªŒå’Œï¼Œä¸‹é¢çš„ä¿¡æ¯è¡¨ç¤ºæœ¬æ¬¡æäº¤ä¸­ï¼Œæœ‰å¤šå°‘æ–‡ä»¶ä¿®è®¢è¿‡ï¼Œå¤šå°‘è¡Œæ·»åŠ å’Œä¿®æ”¹è¿‡ã€‚ ä½¿ç”¨git commit -aå¯ä»¥è·³è¿‡æäº¤ä¹‹å‰å…ˆä½¿ç”¨git addæš‚å­˜æ–‡ä»¶ï¼ˆè¿™äº›æ–‡ä»¶å¿…é¡»å·²ç»è¢«æš‚å­˜è¿‡ï¼‰çš„æ­¥éª¤è€Œç›´æŽ¥æäº¤ã€‚ Removing Filesè¦ä»Ž Git ä¸­ç§»é™¤æŸä¸ªæ–‡ä»¶ï¼Œå°±å¿…é¡»è¦ä»Žå·²è·Ÿè¸ªæ–‡ä»¶æ¸…å•ä¸­ç§»é™¤ï¼ˆç¡®åˆ‡åœ°è¯´ï¼Œæ˜¯ä»Žæš‚å­˜åŒºåŸŸï¼‰ï¼Œç„¶åŽæäº¤ã€‚å¯ä»¥ä½¿ç”¨git rmå‘½ä»¤å®Œæˆæ­¤é¡¹å·¥ä½œï¼Œå¹¶è¿žå¸¦çš„ä»Žå·¥ä½œç›®å½•ä¸­åˆ é™¤æŒ‡å®šçš„æ–‡ä»¶ï¼Œè¿™æ ·ä»¥åŽå°±ä¸ä¼šå‡ºçŽ°åœ¨æœªè·Ÿè¸ªæ–‡ä»¶æ¸…å•ä¸­äº†ã€‚ å¦‚æžœåªæ˜¯ç®€å•åœ°ä»Žå·¥ä½œç›®å½•ä¸­æ‰‹å·¥åˆ é™¤æ–‡ä»¶ï¼Œè¿è¡Œgit statusæ—¶å°±ä¼šåœ¨â€œChanges not staged for commitâ€éƒ¨åˆ†ï¼ˆä¹Ÿå°±æ˜¯æœªæš‚å­˜æ¸…å•ï¼‰çœ‹åˆ°è¯¥æ–‡ä»¶çš„åˆ é™¤è®°å½•äº†ã€‚ä¾‹å¦‚ï¼Œåœ¨Testç›®å½•ä¸‹ï¼Œåˆ é™¤change.cæ–‡ä»¶ï¼Œä½¿ç”¨git statuså‘½ä»¤å¯ä»¥çœ‹åˆ°ï¼š123456789$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: change.cno changes added to commit (use "git add" and/or "git commit -a") ç„¶åŽè¿˜éœ€åœ¨è¿è¡Œgit rmè®°å½•æ­¤æ¬¡ç§»é™¤æ–‡ä»¶çš„æ“ä½œï¼š12345678$ git rm change.crm 'change.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: change.c è¿™æ ·ä¸‹ä¸€æ¬¡æäº¤æ—¶ï¼Œè¯¥æ–‡ä»¶å°±ä¸å†çº³å…¥ç‰ˆæœ¬ç®¡ç†äº†ã€‚ å¦‚æžœå°†æ–‡ä»¶ä¿ç•™åœ¨ç£ç›˜å†…ï¼Œä½†æ˜¯å¹¶ä¸æƒ³è®© Git ç»§ç»­è·Ÿè¸ªï¼Œå¯ä»¥ä½¿ç”¨--cachedé€‰é¡¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678910111213$ git rm --cached update.crm 'update.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: update.cUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) update.c æŽ¥ç€ä½¿ç”¨git commitå‘½ä»¤æäº¤åŽupdate.cæ–‡ä»¶å°±ä¸åœ¨ä»“åº“å†…ï¼Œä½†ä»åœ¨ç£ç›˜ä¸Šäº†ã€‚ Moving FilesGit å¾ˆèªæ˜Žï¼Œä¸€æ¡ç§»åŠ¨æ–‡ä»¶çš„å‘½ä»¤å°±èƒ½é‡å‘½åæ–‡ä»¶å¹¶ä¿ç•™ç›¸åŒå¼‚åæ–‡ä»¶çš„çŠ¶æ€ï¼Œå¦‚ä¸‹ï¼š1$ git mv file_from file_to ä¸Šè¿°å‘½ä»¤ä¸Žä¸‹é¢ä¸‰æ¡å‘½ä»¤ç±»ä¼¼ï¼š123$ mv file_from file_to$ git rm file_from$ git add file_from ä½¿ç”¨ä¸€æ¡å‘½ä»¤å¹²ä¸‰ä»¶äº‹ï¼Œå¾ˆæ£’å§~]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç´ æ•°çš„æ±‚æ³•]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%B4%A0%E6%95%B0%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å®šä¹‰ä»‹ç»å¦‚ä½•æ±‚ç´ æ•°ä¹‹å‰ï¼Œé¦–å…ˆå¾—æ˜Žç™½ç´ æ•°æ˜¯ä»€ä¹ˆï¼Ÿæ‰€è°“ç´ æ•°ï¼ˆä¹Ÿå«è´¨æ•°ï¼‰ï¼Œæ˜¯æŒ‡å¤§äºŽ1ï¼Œä¸”åªèƒ½è¢«1å’Œå…¶æœ¬èº«æ•´é™¤çš„æ•°ï¼ˆæ­¤å®šä¹‰ä¸Žåˆæ•°çš„å®šä¹‰ç›¸å¯¹ï¼‰ã€‚ ç®€ä¾¿æ±‚æ³•åœ¨å¯¹æ—¶é—´å¤æ‚åº¦æ²¡æœ‰è¦æ±‚çš„æƒ…å†µä¸‹ï¼Œç›´æŽ¥ä»Žå®šä¹‰å‡ºå‘ï¼Œåˆ©ç”¨å¾ªçŽ¯ï¼Œä¸€ç›´åšå–ä½™è¿ç®—ï¼Œå°±å¯ä»¥å¾ˆå®¹æ˜“çš„å¾—åˆ°åˆ¤æ–­ä¸€ä¸ªæ•°å­—æ˜¯å¦ä¸ºç´ æ•°çš„ç®—æ³•ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1) &#123; flag = false; &#125; else &#123; for(i = 2; i &lt; number; i++) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; å¾ˆæ˜Žæ˜¾ï¼Œå› ä¸ºå€ŸåŠ©äº†ä¸€å±‚å¾ªçŽ¯ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦$O(n)$ï¼Œä¼˜ç‚¹å°±æ˜¯ååˆ†å®¹æ˜“ç†è§£äº†ã€‚ ç»“åˆæ•°å­¦çŸ¥è¯†çš„ä¼˜åŒ–åœ¨ç†è§£äº†ç®€ä¾¿æ±‚æ³•ä¹‹åŽï¼Œæ¥ç¨å¾®æ€è€ƒä¸€ä¸‹ï¼Œå¶æ•°èƒ½è¢«2æ•´é™¤ï¼Œæ‰€ä»¥è‚¯å®šä¸æ˜¯ç´ æ•°ï¼Œå¦‚æžœä¸€å¼€å§‹å…ˆåˆ¤æ–­numberæ˜¯ä¸æ˜¯å¶æ•°ï¼Œç„¶åŽåœ¨ä»Ž 3 å¼€å§‹åˆ¤æ–­numberæ˜¯å¦èƒ½è¢«å¥‡æ•°æ•´é™¤ï¼Œå¦‚æ­¤ä¸€æ¥ï¼Œæ•´ä¸ªå¾ªçŽ¯æ¬¡æ•°å°±æ˜¯$(n - 3) / 2 + 1$ï¼ˆå¥‡æ•°æ¯æ¬¡å¢žåŠ 2ï¼Œæ‰€ä»¥åˆ†æ¯ä¸º2ï¼‰äº†ï¼Œå½“$n$è¾ƒå¤§çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼æ˜¯è¶‹è¿‘äºŽ$n / 2$çš„ã€‚æŽ¥ç€æ¥æ”¹å†™ä¸€ä¸‹ä»£ç ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ç›¸æ¯”ç®€ä¾¿æ±‚æ³•ï¼Œå°†æ€»ä½“æ—¶é—´ç¼©çŸ­äº†ä¸€åŠï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(n/2)$ã€‚ å®žé™…ä¸Šï¼Œå¾ªçŽ¯åŒºé—´å¯ä»¥ç¼©å‡ä¸º$[3, \sqrt{number})$ï¼ˆæ­¤å¤„çš„æ•°å­¦è¯æ˜Žå°±ä¸å¤šè¯´äº†ðŸ˜ï¼Œå¯ä»¥ç®€å•æƒ³ä¸€ä¸‹ï¼Œä¸€ä¸ªæ•°$n$ï¼Œå¯¹äºŽ$x &lt;= n$ï¼Œå¦‚æžœ$n$èƒ½æ•´é™¤$x$ï¼Œåˆ™$n$ä¹Ÿä¸€å®šèƒ½æ•´é™¤$n/x$ï¼Œè¿™ä¸¤ä¸ªæ•°ä¸­å¿…å®šæœ‰ä¸€ä¸ªå¤§äºŽç­‰äºŽ$\sqrt{n}$ï¼‰ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i * i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ä¸Šè¿°ä»£ç å—ä¸­ç”¨i * iæ¥ä»£è¡¨å¹³æ–¹æ ¹çš„å†™æ³•è¾ƒä¸ºå¸¸è§ï¼Œè¿™æ ·æ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å°±ä¸º$O(\sqrt{n})$ã€‚ä½†æ˜¯ï¼Œi * iè¿™ç§å†™æ³•ï¼Œä¼šæº¢å‡ºï¼Œæœ€å¥½å°±ä½¿ç”¨sqrtå‡½æ•°ã€‚ è½¬æ¢æ€è·¯æŒ‰ç…§ä¹‹å‰çš„åšæ³•ï¼Œæ— è®ºiçš„å€¼æ˜¯ç´ æ•°è¿˜æ˜¯åˆæ•°ï¼Œéƒ½å¯¹numberè¿›è¡Œäº†æ•´é™¤çš„è¿ç®—ã€‚å®žé™…ä¸Šï¼Œåˆ¤æ–­numberæ˜¯å¦ä¸ºç´ æ•°ï¼Œåªéœ€è¦åœ¨içš„å€¼ä¸ºç´ æ•°çš„æƒ…å†µä¸‹ï¼Œåˆ¤æ–­numberæ˜¯å¦èƒ½è¢«iæ•´é™¤å³å¯ï¼Œè‹¥èƒ½æ•´é™¤åˆ™ä¸æ˜¯ç´ æ•°ï¼Œåä¹‹åˆ™æ˜¯ã€‚åœ¨è¿›è¡Œä¸Šè¿°è®¡ç®—çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦æå‰å‡†å¤‡ä¸€å¼ ç´ æ•°è¡¨æ¥å¸®åŠ©è®¡ç®—ï¼Œå…·ä½“å¦‚ä¸‹ï¼š1234567891011bool Is_Prime(int number, int Prime[], int NumOfPrime) &#123; bool flag = true; int i; for(i = 0; i &lt; NumOfPrime; i++) &#123; if(a % Prime[i] == 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; åœ¨è®¡ç®—çš„æ•°æ®è¾ƒå¤§çš„æƒ…å†µä¸‹ï¼Œæ— æ³•ç›´æŽ¥ç»™å®šç´ æ•°è¡¨ï¼Œéœ€è¦è¾¹åˆ¤æ–­è¾¹æ›´æ–°ï¼Œè¿™æ ·ä¼šæ¶ˆè€—æŽ‰ä¸€å®šçš„æ—¶é—´ï¼Œæ‰€ä»¥ä¸Šè¿°ç®—æ³•çš„å®žé™…æ—¶é—´å¤æ‚åº¦$O(n) âˆˆ (\sqrt{n}, n/2)$ï¼Œä½†æ­¤æ³•å¾ˆé€‚åˆéœ€è¦æž„é€ ç´ æ•°è¡¨å¹¶æ±‚å’Œçš„åœºæ™¯ã€‚ ç´§æŽ¥ç€åˆšæ‰çš„æ€è·¯ï¼Œä»¥2ä¸ºä¾‹ï¼Œåœ¨åˆ¤æ–­å‡ºå…¶ä¸ºç´ æ•°åŽï¼Œå…¶å€æ•°$4ã€6ã€8ã€10...$å°±æ˜¯éžç´ æ•°äº†ï¼Œé‚£ä¹ˆä¸€æ¬¡æ€§å°†è¿™äº›æ•°å­—æ ‡è®°ä¸ºéžç´ æ•°ï¼Œä¹Ÿå¯ä»¥æé«˜æ•ˆçŽ‡ï¼Œè¿™å°±æ˜¯â€œç­›é€‰æ³•â€æž„é€ ç´ æ•°è¡¨ï¼Œå…·ä½“å¦‚ä¸‹ï¼š1234567891011121314bool IsPrime[NumOfPrime];for(i = 2; i &lt; NumOfPrime; i++) &#123; IsPrime[NumOfPrime] = 1;&#125;void Get_Prime() &#123; int x, i; for(x = 2; x &lt; MaxNum; x++) &#123; if( IsPrime[x] ) &#123; for(i = 2; i * x &lt; MaxNum; i++) &#123; IsPrime[i*x] = 0; &#125; &#125; &#125;&#125; ç²—ç•¥åˆ†æžä»£ç ï¼Œå¯çŸ¥æ­¤ç®—æ³•æ—¶é—´çš„å¤æ‚åº¦ä¸º$O(n * loglog{n})$ï¼Œä¹‹æ‰€ä»¥æ˜¯è¿™ä¸ªæ—¶é—´å¤æ‚åº¦ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡æ€§è®¡ç®—å‡ºäº†$[0, MaxNum)$è¿™ä¸ªåŒºé—´å†…çš„æ‰€æœ‰ç´ æ•°ï¼Œæ­¤ç®—æ³•å®žé™…æ•ˆæžœè¾ƒå¥½ï¼Œå¯¹äºŽéœ€è¦æž„é€ ç´ æ•°è¡¨çš„æƒ…å†µå¾ˆæ–¹ä¾¿ã€‚ æ‰©å±•ä¸Šé¢ä»‹ç»çš„â€œç­›é€‰æ³•â€ï¼Œå…¶å®žæ˜¯å¤å¸Œè…Šæ•°å­¦å®¶åŸƒæ‹‰æ‰˜è‰²å°¼ï¼ˆEratosthenesï¼Œ274 B.C ~ 194 B.Cï¼‰æå‡ºçš„ä¸€ç§ç­›é€‰æ³•ï¼Œä¹Ÿç§°åŸƒæ°ç­›æ³•ã€‚å®žé™…ä¸Šï¼Œç»“åˆåˆ©ç”¨ç´ æ•°è¡¨æ¥åˆ¤æ–­ç´ æ•°çš„æ€è·¯ï¼Œå¯¹äºŽåˆæ•°è€Œè¨€ï¼Œå¦‚æžœå…¶åªè¦è¢«å…¶æœ€å°è´¨å› å­æ•´é™¤ï¼Œå³å¯åˆ¤æ–­å…¶ä¸æ˜¯ç´ æ•°ã€‚é‚£ä¹ˆåŽ»æŽ‰è¿™éƒ¨åˆ†é‡å¤è®¡ç®—çš„è¿‡ç¨‹ï¼Œä¸å°±å¯ä»¥æé«˜æ•ˆçŽ‡äº†å—ï¼Ÿä»¥16ä¸ºä¾‹ï¼Œåœ¨åŸƒæ°ç­›æ³•ä¸­ï¼Œ$x = 2$æ—¶ï¼Œç­›é€‰æŽ‰äº†$4ã€6ã€8ã€10...$ï¼Œå½“$x = 3$æ—¶ï¼Œåˆé‡å¤è®¡ç®—äº†$6ã€12...$ç­‰æ•°ã€‚æŽ¥ç€æ¥ä¿®æ”¹ä¸‹ä»£ç ï¼š123456789101112bool Number[MaxNum];memset(Number, true, sizeof(Number));int Prime[MaxNum], count = 0;for(i = 2; i &lt; MaxNum; i++) &#123; if( Number[i] ) &#123; Prime[count++] = i; for(j = 1; j &lt;= num &amp;&amp; i * Prime[j] &lt;= n; j++) &#123; Number[i * Prime[j]] = false; if(i % Prime[j] == 0) break; &#125; &#125;&#125; ä¸Šè¿°ä»£ç çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ï¼ˆè®¡ç®—è¿‡ç¨‹æš‚ä¸æ·±ç©¶ï¼‰ï¼Œæ‰€ä»¥æ­¤ç§ç­›æ³•ä¹Ÿå«çº¿æ€§ç­›æ³•ï¼Œä¸è¿‡æå‡æ•ˆçŽ‡çš„ä»£ä»·å°±æ˜¯å¤šä½™çš„ç©ºé—´å¼€é”€äº†ï¼Œä¸€èˆ¬è€Œè¨€çš„ä¼˜åŒ–éƒ½æ˜¯ç”¨ç©ºé—´æ¢æ—¶é—´è¿™æ ·çš„æ€è·¯ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>Prime</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é›¨å¤œæ‚æ€]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%9B%A8%E5%A4%9C%E6%9D%82%E6%80%9D%2F</url>
    <content type="text"><![CDATA[æ˜¯å¤œï¼Œçª—å¤–çš„é›¨å£°æ·…æ·…æ²¥æ²¥çš„ä¸‹ç€ï¼Œå¿ƒé‡Œæƒ³ç€è‡ªå·±è¿™æ®µæ—¶é—´çš„ç”Ÿæ´»ï¼Œä¸ç”±å¾—æœ‰äº†äº›æ„Ÿæ…¨ï¼Œæ¯•ç«Ÿåˆæ˜¯ä¸€å¹´é€åŽ»äº†ã€‚ See the sky about the rain - Neil YoungYour browser does not support the audio tag. é›¨ï¼ŒåŽŸæ¥æˆ‘æ˜¯å¾ˆè®¨åŽŒçš„ã€‚å› ä¸ºï¼Œä¸‹é›¨å°±æ„å‘³ç€è¦æ‰“ä¼žï¼Œä¼šå«Œéº»çƒ¦ï¼Œè€Œä¸”è¿˜ä¼šæ·‹æ¹¿ã€‚æ›´ç”šè€…ï¼Œè‹¥æ˜¯é›¨ä¸‹çš„å¤ªå¤§ï¼Œä¸€æ—¦æŠŠéž‹æ‰“æ¹¿äº†ï¼Œé‚£æ»‹å‘³å¯å°±ä¸å¥½å—äº†ã€‚ä¸è¿‡ï¼Œå³ä¾¿å¦‚æ­¤ï¼ŒçŽ°åœ¨çš„æˆ‘ï¼ŒäºŽé›¨ï¼Œæ˜¯å–œæ¬¢çš„ã€‚ æ¯å½“ä¸‹é›¨ä¹‹æ—¶ï¼Œæˆ‘æ€»ä¼šæœ‰è¿™æ ·çš„æƒ³æ³•ï¼šæ˜¯è°åˆåœ¨ç‹¬è‡ªä¼¤å¿ƒï¼Ÿæƒ¹å¾—è€å¤©çˆ·é™ªå¥¹ï¼ˆä»–ï¼‰ä¸€èµ·å“­ï¼Ÿã€‚æœ€åˆèŒç”Ÿè¿™ä¸ªæƒ³æ³•çš„æ—¶é—´ï¼Œæ˜¯è‡ªå·±çš„é«˜ä¸­é˜¶æ®µï¼Œå…·ä½“æ— æ³•è®°æ¸…æ˜¯é‚£ä¸ªå¹´çº§äº†ï¼ŒåªçŸ¥é“é‚£æ˜¯ä¸€ä¸ªå‚æ™šï¼Œä¸‹è¯¾åŽå¤§å®¶éƒ½åŽ»åƒé¥­äº†ï¼Œæ­£å·§é‚£å¤©æˆ‘å¿ƒä¸­æœ‰äº‹ï¼Œå°±åœ¨æ•™å®¤å‘å‘†ï¼Œç­‰å›žè¿‡ç¥žæ¥çš„æ—¶å€™ï¼Œæ‰å‘çŽ°è¿˜å¾—åŽ»åƒé¥­ï¼Œæ¯•ç«Ÿæ™šä¸Šè¿˜å¾—ä¸Šè¯¾ã€‚äºŽæ˜¯ä¸‹æ¥¼ï¼Œå‡ºåŽ»æ‰å‘çŽ°ä¸‹é›¨äº†ï¼Œæƒ³ä¹Ÿæ²¡æƒ³ï¼Œè¿ˆç€æ­¥å­å°±å¾€å‰èµ°ï¼Œèµ°ç€èµ°ç€ï¼Œçªç„¶å‘çŽ°ï¼Œå¥½åƒæ²¡é‚£ä¹ˆå¤§ï¼ŒäºŽæ˜¯åŽŸå…ˆçš„ç–¾æ­¥æˆäº†æ¼«æ­¥ï¼Œç´§æŽ¥ç€ï¼Œè„‘ä¸­å°±å†’å‡ºäº†è¿™ä¸ªæƒ³æ³•ï¼Œå›žè¿‡ç¥žæ¥æ‰å‘çŽ°ï¼Œæˆ‘æ€Žä¹ˆä¼šæœ‰è¿™æ ·çš„æƒ³æ³•ï¼Ÿå› çƒ¦äº‹åƒµç›´çš„å˜´è§’ï¼Œæ­¤æ—¶æœ‰äº†å¾®å¾®ä¸Šæ‰¬çš„å¼§åº¦ï¼Œå¿ƒä¸­ä¸å…ä¹è§‚äº†èµ·æ¥ã€‚è‡³æ­¤ä¹‹åŽï¼Œæ¯å½“ä¸‹é›¨çš„æ—¶å€™ï¼Œåœ¨å…¶ä»–äººéƒ½æŠ±æ€¨ä¸‹é›¨åœ°æ»‘ã€æ·‹æ¹¿ä¹‹ç±»çš„æ—¶å€™ï¼Œæˆ‘æ€»ä¼šåœ¨å¿ƒä¸­æƒ³ï¼Œåˆ°åº•æ˜¯è°åˆåœ¨ä¼¤å¿ƒå‘¢ï¼Ÿå¸Œæœ›è€å¤©çˆ·çš„é›¨å¯ä»¥æŠšæ…°ä½å¥¹ï¼ˆä»–ï¼‰å—ä¼¤çš„å¿ƒ...åŽæ¥æ¯å½“è‡ªå·±å¿ƒæƒ…ä¸å¥½çš„æ—¶å€™ï¼Œæ€»çœ‹çœ‹å¤©ä¸Šæ˜¯å¦æœ‰é›¨ï¼Œåƒæ˜¯è¦å¾—åˆ°å®‰æ…°çš„å­©å­ä¸€æ ·ï¼Œä¸è¿‡å¥½åœ¨ï¼Œè‡ªå·±æ˜¯è¢«æ»¡è¶³çš„ã€‚ çŽ°åœ¨åˆä¸€å¹´çš„äº”æœˆæœ€åŽçš„æ—¥å­äº†ï¼Œé¢ä¸´å³å°†åˆ°æ¥çš„å…­æœˆï¼Œå¿ƒä¸­ä¸å…æœ‰äº›ä¸èˆï¼Œæ—¶å…‰å¥½åƒåˆè¶ç€è‡ªå·±ä¸æ³¨æ„æºœèµ°äº†ã€‚æ›¾ç»æ„Ÿå¹æ—¶é—´è¿‡çš„å¤ªæ…¢çš„è‡ªå·±ï¼ŒçŽ°åœ¨å·²ç»æˆäº†æ„Ÿå¹æ—¶å…‰çš„â€œè€äººâ€ã€‚æ˜¯ä»Žä»€ä¹ˆæ—¶å€™å¼€å§‹ï¼Œè‡ªå·±çš„å¿ƒæ²¡æœ‰å½“åˆçš„é‚£ä»½â€œå¹´è½»â€äº†å‘¢ï¼Ÿå¥½åƒè¿žè‡ªå·±è¿™ä¸ªå˜åŒ–ä¹Ÿè®°ä¸æ¸…äº†ï¼Œè¿™ä¸ªé—®é¢˜æ­å¼€æ¥çœ‹ï¼Œæ„Ÿè§‰è‡ªå·±æœ‰ç‚¹å¯æ‚²å‘ã€‚ä»¥ä¸ºè‡ªå·±æ˜¯æŒ‰ç…§è‡ªå·±çš„æ–¹å‘å‰è¡Œï¼Œä½†å´è¿žè‡ªå·±çš„è½¬æŠ˜ç‚¹éƒ½ä¸æ¸…æ¥šï¼Œé‚£ä¹Ÿå°±æ„å‘³ç€å¤šå¹´æ¥çš„è‡ªå·±ä¾ç„¶æ˜¯ä¸€ä¸ªè¢«åŠ¨çš„é€‰æ‹©è€…ï¼Ÿè¯¶ï¼Œä¸å¯¹ï¼Œæœ‰å¥è¯ï¼Œä¸æ˜¯å«æ—¶é—´æ€»æ˜¯åœ¨ä¸ç»æ„é—´æ”¹å˜äº†å¤§å®¶å—ï¼Ÿè¿™åº”è¯¥æ˜¯â€œå¸¸ç†â€ï¼Œä¸æ˜¯æˆ‘å¯æŠ—çš„...å§ï¼Ÿè¯´è¿™ä¹ˆå¤šï¼Œå…¶å®žç»“æžœå¦‚ä½•ï¼Œå¿ƒä¸­æ‰€æ€ï¼Œç­”æ¡ˆæ—©å·²ä¸å˜ã€‚ çª—å¤–çš„é›¨å£°å¥½åƒå°äº†äº›ï¼Œä»Žçª—æˆ·çš„ç»†ç¼ä¸­æœ‰å‡‰é£Žå¹è¿›æ¥ï¼Œå¾®å¾®æ‹‚èµ·äº†çª—å¸˜ï¼Œæ˜¯æ¥æé†’æˆ‘è¯¥ç¡è§‰äº†å—ï¼Ÿå¥½åƒåˆæ˜¯åœ¨è‡ªæˆ‘å®‰æ…°å‘¢ï¼ˆå›§ï¼‰ï¼Œå¤§åŠå¤œéš”å£ç«Ÿç„¶è¿˜æœ‰æ€çŒªä¸€æ ·çš„ç¬‘å£°ä¼ å‡ºæ¥ï¼Œæ˜¯ä»€ä¹ˆäº‹æƒ…è®©ä»–ä»¬è¿™ä¹ˆå…´å¥‹ï¼Ÿç®—äº†ï¼Œæ²¡æœ‰å…´è¶£åŽ»äº†è§£ï¼ŒçŽ°åœ¨çš„è‡ªå·±åªæƒ³ä¸“æ³¨åˆ°è‡ªå·±çš„äº‹æƒ…ä¸Šã€‚ æŒ‡ç”²è¿˜æœ‰ä¸€ä¸¤å‘¨å°±é•¿å‡ºæ¥äº†ï¼Œè¿™æ ·æˆ‘åˆå¯ä»¥åšæ‰‹æŒ‡æ“äº†ã€‚ç³Ÿç³•ï¼Œç¬”è®°æœ¬å¥½åƒè¦æ²¡ç”µäº†ï¼Œè¿™æ¬¡å°±å…ˆå†™åˆ°è¿™é‡Œå§ï¼Œæ»šåŽ»ç¡è§‰ingã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cè¯­è¨€å¸¸ç”¨åº“å‡½æ•°]]></title>
    <url>%2F2019%2F05%2F24%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Introæœ€è¿‘å‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼Œåšé¢˜çš„æ—¶å€™ï¼Œä¸ç®¡æœ‰çš„æ²¡çš„ï¼Œè¦ç”¨çš„å‡½æ•°å…¨é è‡ªå·±å†™ï¼Œå†™æ¥å†™åŽ»ä¹Ÿæ‡’å¾—åŽ»ç®¡åˆ°åº•æœ‰æ²¡æœ‰é‚£ä¸ªåº“å‡½æ•°äº†â€¦è¿™æ ·ä¸å¤ªå¥½ï¼Œæ—¥åŽè¿˜ä¸æ˜¯å¾—æŠŠè‡ªå·±ç´¯æ­»ï¼Œè¿˜æ˜¯å¾—å–„äºŽåˆ©ç”¨ä¸œè¥¿æ‰è¡Œï¼ˆåˆä¸ºè‡ªå·±å·æ‡’æ‰¾å€Ÿå£ðŸ¤£ï¼‰ã€‚äºŽæ˜¯ï¼Œè¿™ç¯‡æ–‡ç« å°±ç”¨æ¥è®°å½•Cä¸­å¸¸ç”¨çš„ä¸€äº›åº“å‡½æ•°ï¼Œä»¥å…æ—¥åŽåˆå¿˜è®°äº†ã€‚ stdlib.hstdlib.hå³standard libraryæ ‡å‡†åº“å¤´æ–‡ä»¶ï¼Œè¿™ä¸ªå¤´æ–‡ä»¶å†…æœ‰å¾ˆå¤šæœ‰ç”¨çš„å·¥å…·å‡½æ•°ã€‚ qsortqsortå‡½æ•°æ˜¯Cè¯­è¨€è‡ªå¸¦çš„æŽ’åºå‡½æ•°ï¼Œé‡‡ç”¨æŽ’åºæ–¹æ³•æ˜¯å¿«é€ŸæŽ’åºï¼Œå…¶å£°æ˜Žä½äºŽå¤´æ–‡ä»¶stdlib.hä¸­ï¼Œè²Œä¼¼å¿«é€ŸæŽ’åºæ˜¯å®žé™…ä½¿ç”¨æ•ˆæžœæœ€å¥½çš„å‡ ç§æŽ’åºæ–¹æ³•ä¹‹ä¸€ã€‚ Function Prototypeå‡½æ•°åŽŸåž‹å¦‚ä¸‹ï¼š1void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *)); å‚æ•°è¯´æ˜Žï¼šbasenumsizecomparebaseæŒ‡å‘æ•°ç»„çš„èµ·å§‹åœ°å€ï¼Œé€šå¸¸ä¼šä¼ å…¥ä¸€ä¸ªæ•°ç»„ånumè¡¨ç¤ºè¯¥æ•°ç»„å…ƒç´ çš„ä¸ªæ•°sizeè¡¨ç¤ºæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„å¤§å°ï¼ˆå­—èŠ‚æ•°ï¼‰(*compare)(const void*, const void*)ä¸ºæŒ‡å‘æ¯”è¾ƒå‡½æ•°çš„å‡½æ•°æŒ‡é’ˆï¼Œå†³å®šäº†æŽ’åºé¡ºåº Compare Functionqsortå‡½æ•°å£°æ˜Žä¸­çš„compareå‚æ•°æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªæ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„å‡½æ•°ã€‚æ¯”è¾ƒå‡½æ•°çš„åŽŸåž‹åº”è¯¥æ˜¯int compare(const void *a, const void *b);ï¼Œæ³¨æ„è¿™ä¸ªå‡½æ•°çš„å½¢å‚æ˜¯const void *åž‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯ä¸é™åˆ¶å‚æ•°æŒ‡é’ˆç±»åž‹çš„ï¼Œå¹¶ä¸”ï¼Œè¿”å›žå€¼æ˜¯intåž‹çš„ã€‚qsortå‡½æ•°åœ¨ä½¿ç”¨compareå‡½æ•°æŒ‡é’ˆè°ƒç”¨compareæ¯”è¾ƒå‡½æ•°æ—¶ï¼Œä¼ å…¥çš„å®žå‚æ˜¯æ²¡æœ‰é™å®šæŒ‡é’ˆç±»åž‹çš„ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œcompareå‡½æ•°æŒ‰ç…§ä¸‹é¢çš„ä»£ç æ¥å†™ï¼š123456int compare(const void *a, const void *b)&#123; if(*(int*)a &lt; *(int*)b) return -1; if(*(int*)a == *(int*)b) return 0; if(*(int*)a &gt; *(int*)b) return 1;&#125; ä»Žä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒæŒ‡é’ˆaå’Œbåœ¨ä¼ å…¥åˆ°compareæ¯”è¾ƒå‡½æ•°å†…åŽï¼Œå…ˆè¿›è¡Œäº†æŒ‡é’ˆç±»åž‹çš„å¼ºè½¬æ“ä½œï¼Œç„¶åŽå†åˆ†åˆ«å¯¹å¼ºè½¬åŽçš„aå’ŒbæŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨ï¼Œå¹¶åšå·®æ¥åˆ¤æ–­*aå’Œ*bçš„å¤§å°ï¼Œæ ¹æ®ä¸‰ç§ä¸åŒçš„æƒ…å†µè¿”å›žä¸‰ä¸ªå€¼ï¼Œåˆ†åˆ«å¯¹åº”ä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼š-101(*a)æ‰€æŒ‡å‘å…ƒç´ ä¼šè¢«æŽ’åœ¨*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹å‰(*a)æ‰€æŒ‡å‘å…ƒç´ å’Œ*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹é—´é¡ºåºä¸ç¡®å®š(*a)æ‰€æŒ‡å‘å…ƒç´ ä¼šè¢«æŽ’åœ¨*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹åŽ Exampleså¯¹æ™®é€šintåž‹æ•°ç»„è¿›è¡ŒæŽ’åºæ—¶ï¼š1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(const void *a, const void *b)&#123; return (*(int*)a - *(int*)b);&#125;int main(int argc, char const *argv[])&#123; int i, array[8] = &#123;30, 52, 11, 29, 58, 3, 88, 60&#125;; qsort(array, 8, sizeof(array[0]), compare); for(i=0; i&lt;8; i++) &#123; printf("%d ", array[i]); &#125; return 0;&#125;/*Print: 3 11 29 30 52 58 60 88if '(*(int*)b - *(int*)a)' replaces '(*(int*)a - *(int*)b)'then Print: 88 60 58 52 30 29 11 3*/ å¯¹å…¶ä»–ç±»åž‹çš„æ•°ç»„è€Œè¨€ï¼Œä½¿ç”¨æ–¹æ³•ä¹Ÿå¤§è‡´å¦‚æ­¤ï¼Œå¯¹å­—ç¬¦ä¸²æ•°ç»„ï¼ˆå³äºŒç»´å­—ç¬¦æ•°ç»„ï¼‰ä½¿ç”¨æ—¶ï¼Œå¯ä»¥å°†æ¯”è¾ƒå‡½æ•°è¿™æ ·å†™ï¼š1234int compare(const void *a, const void *b)&#123; return (strcmp((char*)a, (char*)b));&#125; é…åˆstrcmpå‡½æ•°ä½¿ç”¨å°±ä¼šå¾ˆæ–¹ä¾¿ã€‚å¦å¤–ï¼Œå¿«é€ŸæŽ’åºæ˜¯ä¸ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œå¯¹äºŽç»“æž„ä½“è€Œè¨€ï¼Œå½“ä¸¤ä¸ªå…ƒç´ çš„å€¼ç›¸ç­‰æ—¶ï¼Œç»è¿‡å¿«é€ŸæŽ’åºåŽï¼Œå…¶ç›¸å¯¹ä½ç½®å¯èƒ½å‘ç”Ÿäº†æ”¹å˜ï¼Œè¿™å°±å¯¼è‡´ç»“æž„ä½“æŽ’åºå®Œæˆä¹‹åŽï¼Œè¾“å‡ºç»“æžœä¸å¯¹ï¼ˆä½†æ˜¯åºåˆ—æœ‰åºæ— è¯¯ï¼‰ï¼Œä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œéœ€è¦åœ¨ç»“æž„ä½“å†…æ–°å¢žä¸€ä¸ªæ ‡è®°ä½ï¼Œå½“ä¸¤ä¸ªç»“æž„ä½“å€¼ç›¸ç­‰æ—¶ï¼Œæ¯”è¾ƒæ ‡å¿—ä½çš„å¤§å°ï¼Œä»Žè€Œä¿æŒäºŒè€…ç›¸å¯¹ä½ç½®ä¸å‘ç”Ÿæ”¹å˜ã€‚ ctype.hctype.hè¿™ä¸ªå¤´æ–‡ä»¶å…¨ç§°åº”è¯¥æ˜¯character typeå§ï¼Œå› ä¸ºå…¶å†…éƒ¨å®šä¹‰äº†ä¸€æ‰¹ C è¯­è¨€å­—ç¬¦åˆ†ç±»å‡½æ•°ï¼Œç”¨äºŽæµ‹è¯•å­—ç¬¦æ˜¯å¦å±žäºŽç‰¹å®šçš„å­—ç¬¦ç±»åˆ«ã€‚è¿™äº›å‡½æ•°å®žçŽ°èµ·æ¥éƒ½ä¸éš¾ï¼Œå†é‡å¤é€ è½®å­å°±æœ‰ç‚¹åˆ’ä¸æ¥äº†ã€‚ åœ¨ C è¯­è¨€ä¸­ï¼Œå¯¹äºŽä¸€ä¸ªå­—ç¬¦å˜é‡è€Œè¨€ï¼Œå…¶æœ¬è´¨ä¾ç„¶æ˜¯æ•´åž‹å˜é‡ï¼Œæ‰€ä»¥ä¸‹é¢å‡½æ•°å½¢å‚ç±»åž‹å°±ç›´æŽ¥ç”¨intäº†ã€‚æ¢å¥è¯æ¥è®²ï¼Œè¿™äº›å‡½æ•°çš„å®žçŽ°åŽŸç†åº”è¯¥å°±æ˜¯ç›´æŽ¥ä¸Ž ASCII ç è¿›è¡Œæ¯”è¾ƒã€‚ isalphaè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å­—æ¯ï¼ˆåŒ…å«å¤§å°å†™ï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isalpha(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isdigitè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯ç½—é©¬æ•°å­—ï¼ˆ0-9ï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isdigit(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯æ•°å­—ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isxdigitè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯åå…­è¿›åˆ¶å­—ç¬¦ï¼ˆ0-9ã€A-Zã€a-zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isxdigit(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯åå…­è¿›åˆ¶å­—ç¬¦ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ islowerè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å°å†™å­—æ¯ï¼ˆa-zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int islower(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å°å†™å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isupperè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å¤§å†™å­—æ¯ï¼ˆA-Zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isupper(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å¤§å†™å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ tolowerè¿™ä¸ªå‡½æ•°ç”¨äºŽå°†ä¼ å…¥çš„å­—ç¬¦è½¬æ¢ä¸ºå°å†™å­—æ¯ã€‚å‡½æ•°åŽŸåž‹ï¼š1int tolower(int ch); è¿”å›žå€¼ä¸ºæ‰€ä¼ å…¥å­—ç¬¦å˜é‡çš„å°å†™å­—æ¯ã€‚ toupperè¿™ä¸ªå‡½æ•°ç”¨äºŽå°†ä¼ å…¥çš„å­—ç¬¦è½¬æ¢ä¸ºå¤§å†™å­—æ¯ã€‚å‡½æ•°åŽŸåž‹ï¼š1int tolower(int ch); è¿”å›žå€¼ä¸ºæ‰€ä¼ å…¥å­—ç¬¦å˜é‡çš„å¤§å†™å­—æ¯ã€‚ isalnumè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å­—æ¯æˆ–æ•°å­—ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isalnum(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å­—æ¯æˆ–æ•°å­—ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ string.hstrcpyè¿™ä¸ªå‡½æ•°ç”¨äºŽæ‹·è´å­—ç¬¦ä¸²ã€‚å‡½æ•°åŽŸåž‹ï¼š1char *strcpy(char *dest, char *src); éœ€è¦æ³¨æ„çš„æ˜¯ dest æ•°ç»„å¿…é¡»è¦è¶³å¤Ÿå¤§ï¼Œä¸ç„¶å¯èƒ½ä¼šé€ æˆç¼“å†²æº¢å‡ºçš„æƒ…å†µã€‚ math.hceilè¿”å›žä¸å°äºŽ x çš„æœ€å°æ•´æ•°ï¼ˆå‘ä¸Šå–æ•´ï¼‰ï¼Œå‡½æ•°åŽŸåž‹ï¼š1double ceil(double x); floorè¿”å›žä¸å¤§äºŽ x çš„æœ€å¤§æ•´æ•°ï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼Œå‡½æ•°åŽŸåž‹ï¼š1double floor(double x); roundè¿”å›ž x çš„å››èˆäº”å…¥æ•´æ•°å€¼ï¼Œå‡½æ•°åŽŸåž‹ï¼š1double round(double x);]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cè¯­è¨€é‡Œçˆ¬è¿‡çš„â€œå‘â€]]></title>
    <url>%2F2019%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E9%87%8C%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Introé‚£æ˜¯ä¸€ä¸ªä¸‹ç€å¤§é›¨çš„å¤œæ™šï¼Œå®¤å¤–æ€¥ä¿ƒçš„é›¨å£°æ­£å¥½æ˜ è¡¬ç€å®¤å†…ç´§å¼ çš„æ°”æ°›ï¼Œå¿«ï¼Œåªå‰©ä¸‹æœ€åŽä¸€ä¸ªBUGäº†ï¼ç»ˆäºŽåœ¨å¤§åŠä¸ªå°æ—¶ä¹‹åŽè§£å†³äº†ï¼Œä»”ç»†ä¸€çœ‹ï¼ŒåŽŸæ¥æ˜¯ä¹‹å‰ç¢°åˆ°è¿‡ä¸€æ¬¡çš„é—®é¢˜äº†...å¿ƒä¸­ä¸å…æƒ³åˆ°ï¼Œè¦æ˜¯ä¸Šæ¬¡æœ‰å¥½å¥½è®°å½•å°±å¥½äº†ã€‚äºŽæ˜¯ï¼Œå°±åŠ¨äº†æ•´ç†è¿™ç¯‡Blogçš„å¿ƒæ€å•¦~æ­¤Blogä¼šé•¿æœŸä¸å®šæ—¶æ›´æ–°ï¼Œè®°å½•ä¸‹è‡ªå·±åœ¨è·Ÿè€çˆ·å­CçŽ©è€çš„è¿‡ç¨‹ä¸­ï¼Œç¢°åˆ°çš„ä¸€äº›å‘çˆ¹ä¹‹å¤„ï¼ˆèœè¯·è½»å–·ï¼Œå˜¿å˜¿ï¼‰~ scanf å…³äºŽscanfå…ˆè¯´ä¸€ç‚¹ï¼Œscanfå‡½æ•°æ˜¯å¸¦è¿”å›žå€¼çš„ï¼Œæœ‰çš„ç¼–è¯‘å™¨ä¼šå¿½ç•¥æŽ‰è¿™ä¸ªè¿”å›žå€¼ï¼ˆæ²¡æœ‰å‘Šè­¦äº§ç”Ÿï¼‰ï¼Œä½†æ˜¯å®žé™…ä¸Šæ˜¯å­˜åœ¨çš„ï¼Œåˆ‡è®°ã€‚ scanfè¿™ä¸ªå‡½æ•°ç»™ç”¨æˆ·ç•™ä¸‹çš„å‘ï¼Œå®žé™…ä¸Šä¸æ˜¯å®ƒçš„è¿”å›žå€¼ï¼Œè€Œæ˜¯è¿™ä¸ªå‡½æ•°å¯¹ç”¨æˆ·èƒ½å‘å…¶è¾“å…¥çš„ä¸œè¥¿çš„è§„å®šï¼ˆðŸ˜“è¯´äº†ä¸€å¤§å †è®©äººå¬ä¸æ‡‚çš„è¯...ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œä¹Ÿå°±æ˜¯scanfè‡ªèº«å¯¹è¾“å…¥æµä¸­çš„æ•°æ®çš„èŽ·å–çš„æœºåˆ¶å¯èƒ½ä¼šè®©ç”¨æˆ·â€œå‘çˆ¹â€ã€‚å¯¹äºŽCè¯­è¨€è€Œè¨€ï¼Œåœ¨è¯»å–é”®ç›˜è¾“å…¥çš„æ•°æ®æ—¶ï¼Œä¸€èˆ¬æ˜¯å¸¦ç¼“å­˜çš„æ•°æ®è¾“å…¥ï¼Œéœ€è¦æŒ‰å›žè½¦é”®æ‰èƒ½å®Œæˆè¯¥â€œè¡Œâ€æ•°æ®çš„è¾“å…¥ç¡®å®šã€‚è€Œscanfå¯¹è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦å¹¶ä¸è¿›è¡Œå¤„ç†ï¼Œå›žè½¦ç¬¦ä¼šç•™åœ¨è¾“å…¥ç¼“å­˜åŒºä¸­ã€‚å› æ­¤ï¼Œåœ¨ä¸‹ä¸€ä¸ªâ€œå­—ç¬¦â€æ“ä½œå‡½æ•°ï¼ˆgetchar()ã€scanf(&quot;%c&quot;, &amp;x)ã€gets(s)ç­‰ï¼‰è¿è¡Œæ—¶ï¼Œä¼šè¯»åˆ°è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ã€‚å¦å¤–ï¼Œåœ¨è¯»å–æ•°å€¼åž‹æ•°æ®æˆ–å­—ç¬¦ä¸²ï¼ˆæ³¨æ„è¿™é‡Œæ²¡æœ‰å­—ç¬¦å˜é‡ï¼‰æ—¶ï¼Œscanfä¼šä»Žç¬¬ä¸€ä¸ªéžç©ºç™½å­—ç¬¦ï¼ˆç©ºç™½å­—ç¬¦æŒ‡ï¼šå›žè½¦ã€ç©ºæ ¼ã€TABç­‰ï¼‰å¼€å§‹è¯»å–ï¼Œè‡ªåŠ¨å¿½ç•¥å‰é¢çš„ç©ºç™½å­—ç¬¦ï¼Œè€Œé‡åˆ°ç©ºç™½å­—ç¬¦ç»“æŸè¯¥ç±»åž‹æ•°æ®çš„è¾“å…¥ã€‚å› æ­¤ï¼Œå¯¹äºŽè¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ï¼ˆç©ºç™½å­—ç¬¦ï¼‰çš„å¤„ç†ï¼Œéœ€è¦çœ‹ä¸‹ä¸€ä¸ªè¾“å…¥çš„æ•°æ®ç±»åž‹æ˜¯ä»€ä¹ˆï¼Œå¦‚æžœæ˜¯å­—ç¬¦ç±»ï¼Œé‚£å°±éœ€è¦æ¶ˆé™¤æŽ‰è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ï¼Œå¤„ç†åŠžæ³•æœ‰å¤šç§æ–¹å¼ï¼Œä¸‹é¢ä»‹ç»3ç§æ–¹æ³•ï¼šMethod 1Method 2Method 3ä½¿ç”¨fflush(stdin)å‘½ä»¤å¼ºåˆ¶åˆ·æ–°è¾“å…¥ç¼“å­˜ï¼Œä¸¢å¼ƒç¼“å­˜ä¸­çš„æ•°æ®ï¼Œæ³¨æ„æ­¤ç§æ–¹æ³•åœ¨windowsä¸‹ä½¿ç”¨æœ‰æ•ˆï¼Œlinuxæ— æ•ˆï¼Œå› ä¸ºLinuxæ²¡æœ‰fflushã€‚ 12345int a;char c;scanf(â€œ%dâ€, &amp;a);fflush(stdin); //clear the â€˜enterâ€™ charscanf(â€œ%câ€, &amp;c);å›žè½¦ç¬¦ä¹Ÿæ˜¯å­—ç¬¦ï¼Œå¯ä»¥ä½¿ç”¨getchar();æ¥åƒæŽ‰è¿™ä¸ªå›žè½¦ç¬¦å·ã€‚ 12345int a;char c;scanf(â€œ%dâ€, &amp;a);getchar(); //clear the â€˜enterâ€™ charscanf(â€œ%câ€, &amp;c);åˆ©ç”¨scanfå‡½æ•°çš„ä¸€äº›æœºåˆ¶ï¼Œå¦‚ï¼šscanf(&quot;%d%*c&quot;, &amp;i)ï¼Œ%*cè¡¨ç¤ºè¯»ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸èµ‹å€¼ç»™ä»»ä½•å˜é‡ã€‚ 123int a;char c;scanf(â€œ%d%*c%câ€, &amp;a, &amp;c); å¦å¤–ï¼Œå…³äºŽscanfè¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰ç‰¹ç‚¹çš„åœ°æ–¹ï¼Œå°±æ˜¯æ— æ³•è¯»å…¥ç©ºæ ¼å­—ç¬¦ï¼Œæ‰€ä»¥åŒ…å«ç©ºæ ¼å­—ç¬¦çš„å­—ç¬¦ä¸²å°±å¾—ä½¿ç”¨getsæˆ–è€…fgetså‡½æ•°æ¥è¯»å…¥äº†ã€‚è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯&amp;çš„ä½¿ç”¨ã€‚æ³¨æ„ï¼Œé™¤äº†è¯»å…¥å­—ç¬¦ä¸²å¤–ï¼Œå…¶ä»–éƒ½éœ€è¦ä½¿ç”¨&amp;ï¼Œä¼°è®¡è¿™æ˜¯ä¸å°‘æ–°æ‰‹ä¼šçŠ¯çš„é”™è¯¯äº†ðŸ˜€ï¼Œé—®é¢˜æ˜¯ä¸ä¼šç¼–è¯‘ä¸æŠ¥é”™ä¹Ÿä¸è­¦å‘Šï¼Œå¶å°”ä¸ä»”ç»†ï¼Œè€æ‰‹éƒ½è¦æ‰¾åŠå¤©... ififå…³é”®å­—å¯ä¸â€œå‘â€ï¼Œâ€œå‘â€çš„æ˜¯ä½¿ç”¨å®ƒçš„äººï¼ˆåˆé»‘è‡ªå·±ä¸€æŠŠ...ðŸ˜‚ï¼‰ï¼Œifä¸€èˆ¬å’ŒelseåŠelse ifé…åˆä½¿ç”¨ï¼ˆä¹Ÿå¯ä»¥å•ç‹¬ä½¿ç”¨ï¼‰ï¼Œä¸€èˆ¬ç”¨æ³•å¦‚ä¸‹ï¼š123456789101112131415/*if-else*/if(expression)&#123; statement1;&#125;else&#123; statement2;&#125;/*if-else if-else*/if(expression)&#123; statement1;&#125;else if(expression)&#123; statement2;&#125;else&#123; statement3;&#125; ä¸Šè¿°å†…å®¹ï¼Œè¯»æ‡‚å¾ˆå®¹æ˜“ï¼Œä½†é—®é¢˜å…¶å®žå°±åœ¨è¿™ä¸ªexpressionä¸Šï¼Œè¿™ä¸ªè¡¨è¾¾çš„å€¼ä¼šå½±å“ifè¿™ç±»è¯­å¥çš„åˆ¤æ–­ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œexpressionä¸ºtrueæ‰§è¡Œstatement1ï¼Œä¸ºfalseåˆ™æ‰§è¡Œstatement2ï¼Œelse ifåŒç†ã€‚æ‰€ä»¥ä¸¥æ ¼ä¸Šè®²ï¼Œifè®¤ä¸ºçš„trueæ˜¯éž0ï¼ˆå…¶ä»–è¯­å¥ï¼Œå¦‚whileçš„æ¡ä»¶åˆ¤æ–­æœºåˆ¶åº”è¯¥ä¹Ÿæ˜¯è¿™æ ·ï¼‰ï¼Œå•¥æ„æ€ï¼Ÿå°±æ˜¯è¯´ï¼Œä¸ç®¡expressionçš„å€¼æ˜¯1è¿˜æ˜¯-1ï¼Œiféƒ½æ˜¯è®¤ä¸ºæ˜¯trueï¼ˆå»ºè®®å°è¯•ï¼‰ï¼Œæ‰€ä»¥ï¼Œå¯åˆ«çœ‹åˆ°è¡¨è¾¾å¼çš„å€¼æ˜¯è´Ÿæ•°ï¼Œå°±è®¤ä¸ºæ¡ä»¶ä¸æˆç«‹äº†ã€‚ parameter passingè¿™é‡Œæ‰€ä»‹ç»çš„å‚æ•°ä¼ é€’ä¸»è¦æ˜¯é’ˆå¯¹Cè¯­è¨€å†…çš„å‡½æ•°ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼ŒCçš„å‡½æ•°é‡‡ç”¨çš„æ˜¯å€¼ä¼ é€’çš„æ–¹å¼ï¼Œä¹Ÿå³ä¼ å…¥åˆ°å‡½æ•°å†…çš„å‚æ•°ï¼Œä¸ç®¡ä¼ å…¥çš„å€¼å¦‚ä½•ä¿®æ”¹ï¼Œä¾ç„¶ä¸ä¼šæ”¹å˜mainæˆ–å…¶ä»–å‡½æ•°å†…å˜é‡çš„å€¼ï¼Œè¦æƒ³æ”¹å˜æœ‰å¤šç§æ–¹å¼ï¼Œè¿™é‡Œç®€å•ä»‹ç»ä¸‰ç§ï¼Œå…·ä½“å¦‚ä¸‹ï¼šWay 1Way 2Way 3ä½¿ç”¨å…¨å±€å˜é‡åˆ©ç”¨å‡½æ•°è¿”å›žå€¼ï¼Œå½¢å¦‚ï¼ša = abs(a);è¿™æ ·çš„ä½¿ç”¨æ–¹æ³•ä½¿ç”¨æŒ‡é’ˆï¼Œåˆ©ç”¨&amp;ä¼ å…¥å˜é‡åœ°å€ï¼Œä¿®æ”¹æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ä¿å­˜çš„å€¼ï¼Œå¦‚ï¼š*p = x;çš„ç”¨æ³•å¦‚æžœåªæ˜¯ä»‹ç»è¿™äº›ï¼Œé‚£å¤ªç®€å•äº†ï¼Œè¿™é‡Œæƒ³è¦è¯´æ˜Žçš„æ˜¯æŒ‡é’ˆåœ¨å‡½æ•°å‚æ•°ä¼ é€’è¿‡ç¨‹ä¸­çš„å˜åŒ–ã€‚å¦‚æžœä¸€ä¸ªå‡½æ•°çš„å‚æ•°ä¸­å­˜åœ¨æŒ‡é’ˆï¼Œå¹¶ä¸”è¿™ä¸ªå‡½æ•°å†…ä¼šæ”¹å˜ä¼ å…¥è¿™ä¸ªæŒ‡é’ˆçš„æŒ‡å‘ï¼ˆå¦‚ï¼šé“¾è¡¨éåŽ†ï¼‰ï¼Œé’ˆå¯¹è¿™ç§æƒ…å†µï¼ŒCä¾ç„¶éµå¾ªå€¼ä¼ é€’çš„è§„åˆ™ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå³ä¾¿æŒ‡é’ˆè¢«ä¼ å…¥å‡½æ•°ä¸­äº†ï¼Œå®ƒä¹Ÿä¸ä¼šæ”¹å˜è¿™ä¸ªæŒ‡é’ˆåœ¨mainæˆ–å…¶ä»–å‡½æ•°ä¸­çš„æŒ‡å‘ï¼Œå…·ä½“è¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š1234567891011121314#include &lt;stdio.h&gt;void f(int *a);int main(int argc, char const * argv[])&#123; int *A; printf("%p\n", A); f(A); printf("%p\n", A); return 0;&#125;void f(int *a)&#123; a++;&#125; ä¸Šè¿°è¿™æ®µä»£ç çš„ä¸¤æ¬¡è¾“å‡ºç»“æžœæ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿå³æŒ‡é’ˆä¹Ÿæ˜¯éµå¾ªå€¼ä¼ é€’çš„åŽŸåˆ™çš„ã€‚ typedefå…³äºŽtypedefçš„ç”¨æ³•ï¼Œè¿™é‡Œä¸åšè¿‡å¤šä»‹ç»ï¼Œåªæ”¶é›†ä¸€ä¸‹å¹³å¸¸è§åˆ°çš„ä½¿ç”¨æ–¹æ³•ã€‚ ä¸ºåŸºæœ¬æ•°æ®ç±»åž‹å®šä¹‰æ–°çš„ç±»åž‹å1typedef int Data; ä¸Šè¿°ä»£ç çš„ä½œç”¨èƒ½è¾¾åˆ°çš„æ•ˆæžœå°±æ˜¯intå’ŒDataç­‰ä»·ï¼Œä¹Ÿå³int a;å’ŒData a;æ˜¯ä¸¤ç§ç›¸åŒçš„å†™æ³•ï¼Œæ­¤ç§æ–¹æ³•åœ¨è·¨å¹³å°ç§»æ¤å’Œä½œæœ‰æ„ä¹‰çš„ç±»åž‹åæ—¶å¾ˆæ–¹ä¾¿ã€‚ ä¸ºè‡ªå®šä¹‰ç»“æž„ç±»åž‹å®šä¹‰ç±»åž‹åç§°æ³¨æ„è¯´æ³•ï¼Œä¸ºè‡ªå®šä¹‰ç»“æž„ç±»åž‹å®šä¹‰ç±»åž‹åç§°ï¼Œæ³¨æ„åªæ˜¯ç±»åž‹åç§°å“¦ï¼Œä¸‹é¢æ˜¯ä¸€èˆ¬çš„ä½¿ç”¨æ–¹æ³•ã€‚1234typedef struct point&#123; int x, y;&#125; Point; å¦‚æžœéœ€è¦ä¸ºç»“æž„å®šä¹‰æŒ‡é’ˆï¼Œéœ€è¦æ¢ä¸€ç§æ–¹æ³•ï¼š12345typedef struct LNode *List;struct LNode&#123; int Data; List Next;&#125;; ä¸è¿‡ä¸€èˆ¬è€Œè¨€ï¼Œæ ‡å‡†çš„å†™æ³•æ˜¯ä¸‹é¢è¿™ç§ï¼š12345struct LNode&#123; int Data; struct LNode *Next;&#125;;typedef struct LNode *List; ä¸¤ç§å†™æ³•éƒ½æ˜¯ç¼–è¯‘é€šè¿‡çš„ï¼ˆNo Warningsï¼‰ï¼Œç©¶ç«Ÿæ€Žä¹ˆå†™ï¼Œå°±æ˜¯æ™ºè€…è§æ™ºçš„äº‹æƒ…äº†ã€‚ ä¸ºæ•°ç»„å®šä¹‰ç±»åž‹åç§°12typedef int int_array[10];int_array array; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œ arrayå°±æ˜¯ä¸€ä¸ªå®¹é‡ä¸º10çš„æ•´åž‹æ•°ç»„äº†ã€‚ ä¸ºæŒ‡é’ˆå®šä¹‰åç§°123456/*odinary pointer*/typedef char* Pchar;/*function pointer*/typedef int *(*Pfun)(int, char *);Pfun a[5]; //Pfun a[5] &lt;==&gt; int *(*a[5])(int, char *); ä¸Šè¿°ä»£ç ä¸­ï¼Œint *(*a[5])(int, char *)å®žé™…ä¸Šæ˜¯å®šä¹‰äº†ä¸€ä¸ªè¿”å›žå€¼ä¸ºint*çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œå‡½æ•°çš„æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«æ˜¯intå’Œchar *ã€‚ two-dimensional arrayCè¯­è¨€ä¸­å®žé™…ä¸Šå¹¶æ²¡æœ‰ä¸¥æ ¼æ„ä¹‰ä¸Šçš„äºŒç»´æ•°ç»„ï¼ˆå…¶ä»–ç¨‹åºè®¾è®¡è¯­è¨€å¯èƒ½ä¹Ÿæ˜¯å¦‚æ­¤ï¼Ÿï¼‰ï¼Œå› ä¸ºç‰©ç†å†…å­˜çš„åœ°å€æ˜¯è¿žç»­ä¸”ä¸€å—ä¸€å—çš„ï¼Œé‚£Cè¯­è¨€æ˜¯å¦‚ä½•åŽ»ä¿å­˜äºŒç»´æ•°ç»„å’Œå¯»å€çš„å‘¢ï¼Ÿ æŒ‰ç…§ä¸Šè¿°çš„æ€è·¯ï¼Œå…ˆæ¥æ€»ç»“ä¸€ä¸‹äºŒç»´æ•°ç»„çš„ç‰¹ç‚¹ã€‚å¾ˆæ˜Žæ˜¾ï¼ŒäºŒç»´æ•°ç»„åŒ…å«ä¸‰ä¸ªå‚æ•°ï¼šè¡Œï¼ˆRowï¼‰ã€åˆ—ï¼ˆColumnï¼‰å’Œéœ€è¦å­˜çš„æ•°æ®ï¼ˆDataï¼‰ï¼Œæ—¢ç„¶å‰é¢å·²ç»è¯´è¿‡äº†ç‰©ç†å†…å­˜æ˜¯è¿žç»­åˆ†å¸ƒçš„ï¼Œé‚£æ¯«æ— ç–‘é—®ï¼ŒäºŒç»´æ•°ç»„ä¸­çš„ Data ä¾ç„¶æ˜¯è¿žç»­çš„å­˜å‚¨åœ¨ç‰©ç†å†…å­˜ä¸­çš„ï¼Œè¿™ä¸ªçŽ°è±¡æ˜¯ä¸æ˜¯åœ¨å“ªè§è¿‡ï¼Ÿæ²¡é”™ï¼Œå°±æ˜¯ä¸€ç»´æ•°ç»„ï¼›æŽ¥ç€ï¼Œå¦‚ä½•åŽ»å¯»å€å‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜å…¶å®žå¯ä»¥ç”¨äºŒç»´æ•°ç»„çš„è¡Œå’Œåˆ—æ¥è§£å†³ï¼Œå‡è®¾æ€»è¡Œæ•°ä¸ºRï¼Œæ€»åˆ—æ•°ä¸ºCï¼Œæ‰¾ç¬¬2è¡Œï¼Œç¬¬3åˆ—çš„å…ƒç´ ï¼ŒæŒ‰ç…§é¡ºåºå­˜å‚¨çš„è§„åˆ™ï¼Œå®žé™…ä¸Šå¯¹åº”å…ƒç´ çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä»Ž0å¼€å§‹ï¼‰åº”è¯¥æ˜¯2 * C + 3ï¼Œä¸€èˆ¬åŒ–å°±æ˜¯i * C + jã€‚ä¸¾ä¸ªå®žä¾‹ï¼ŒæŒ‰ç…§å¦‚ä¸‹çš„çŸ©é˜µï¼š$$\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6\\7 &amp; 8 &amp; 9\\10 &amp; 11 &amp; 12\\\end{matrix}$$Cè¯­è¨€ç¼–è¯‘å™¨è¦æå–8è¿™ä¸ªå…ƒç´ ï¼Œæ•´ä¸ªçŸ©é˜µæ˜¯4è¡Œ3çš„ï¼Œè‹¥è¡Œã€åˆ—ä¸‹æ ‡ä»Ž0å¼€å§‹ï¼Œè¡Œã€åˆ—å¾ªçŽ¯å˜é‡åˆ†åˆ«ä¸ºiã€jï¼Œé‚£ä¹ˆ8è¿™ä¸ªå…ƒç´ å¯¹åº”çš„ä¸‹æ ‡ï¼ˆi = 2, j = 2ï¼‰å°±æ˜¯i * C + j = 2 * 3 + 2 = 8ï¼Œå®žé™…ä¸Šä¹Ÿå°±æ˜¯ä»Žå·¦å¾€å³ä¾æ¬¡æŒ‰åºæ•°ä¸‹æ¥çš„ç»“æžœã€‚ characteräºŒç»´æ•°ç»„ä¹Ÿæœ‰å­—ç¬¦äºŒç»´æ•°ç»„å’Œæ•´åž‹äºŒç»´æ•°ç»„ï¼Œå­—ç¬¦äºŒç»´æ•°ç»„çš„ä½¿ç”¨ä¼šç®€å•ç‚¹ï¼Œå’±å…ˆä»Žç®€å•çš„æ¥ã€‚å­—ç¬¦äºŒç»´æ•°ç»„å®žé™…ä¸Šå¾ˆå®¹æ˜“ç†è§£ï¼Œå¯ä»¥æŠŠäºŒç»´æ•°ç»„æƒ³è±¡æˆä¸€æ ¹ä¸€æ ¹â€œè¾£æ¡â€ï¼ˆåˆ«è¯´ä½ æ²¡åƒè¿‡...å›§ï¼‰ï¼Œè¿™ä¸€æ ¹æ ¹â€œè¾£æ¡â€ï¼Œæ¯ä¸€æ ¹éƒ½æ˜¯ä¸€ä¸ªä¸€ç»´å­—ç¬¦æ•°ç»„ï¼ˆå…¶å®žå°±æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å•¦~ï¼‰ã€‚1char str[3][5]; ä¸Šé¢è¿™è¡Œä»£ç çš„æ„æ€æ˜¯å£°æ˜Žä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²æ•°ç»„çš„å®¹é‡å¤§å°æ˜¯3ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²èƒ½å­˜å‚¨çš„æœ€å¤§é•¿åº¦æ˜¯4ï¼ˆå› ä¸º\0ä¹Ÿè¦å ä¸€ä½ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‰ç…§ä¸‹é¢çš„æ–¹æ³•åˆå§‹åŒ–ï¼š123char str[3][5] = &#123;"str1", "str2", "str3"&#125;; ä¹‹æ‰€ä»¥åˆ†å¼€ä¸‰è¡Œå†™ï¼Œæ˜¯å› ä¸ºæƒ³å±•ç¤ºå‡ºä¸€æ¡ä¸€æ¡çš„æ ·å­ï¼ˆç¬‘ingï¼‰ï¼Œè¿™æ˜¯å¯ä»¥ç›´æŽ¥è¾“å‡ºçš„å“¦~ å¦‚æžœä½ æŒ‡é’ˆå­¦çš„ä¸é”™çš„è¯ï¼Œä½ ä¸€å®šä¼šå‘çŽ°str[0]ã€str[1]å’Œstr[2]å…¶å®žå°±æ˜¯åˆ†åˆ«æŒ‡å‘è¿™ä¸‰ä¸ªå­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚ æ‰€ä»¥ï¼Œå­—ç¬¦ä¸²æ•°ç»„è¿˜å¯ä»¥è¿™æ ·å£°æ˜Žå’Œåˆå§‹åŒ–ï¼š123char *str[3] = &#123;"str1", "str2", "str3"&#125;; ä¸¥æ ¼ä¸Šæ¥è®²ï¼Œchar *str[3]å…¶å®žå£°æ˜Žäº†ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œè¿™ä¸ªæŒ‡é’ˆæ•°ç»„æœ‰3ä¸ªå­—ç¬¦åž‹æŒ‡é’ˆå˜é‡ï¼Œåˆ†åˆ«æŒ‡å‘ä¸‰ä¸ªå­—ç¬¦ä¸²ã€‚å…¶ä¸­çš„æ¯ä¸ªæŒ‡é’ˆå˜é‡ï¼Œå…¶å®žå¯ä»¥å½“ä½œæ¯ä¸ªå­—ç¬¦ä¸²çš„å¤´æŒ‡é’ˆæ¥ç”¨ã€‚ numberæ˜Žç™½äº†å­—ç¬¦äºŒç»´æ•°ç»„åŽï¼Œæ•°å­—åž‹çš„äºŒç»´æ•°ç»„ç†è§£èµ·æ¥å°±ç®€å•äº†ã€‚é¦–å…ˆï¼Œå®ƒä¸å†æ˜¯â€œè¾£æ¡â€äº†ï¼Œä»–æ˜¯å•ç‹¬ä¸€ä¸ªä¸€ä¸ªçš„ï¼Œä¸è¿‡å­˜å‚¨æ–¹å¼ä¾ç„¶æ˜¯é¡ºåºå­˜å‚¨çš„ï¼ŒäºŒç»´æ•°ç»„çš„é€»è¾‘ç»“æž„ï¼Œå…¶å®žå°±æ˜¯ä¸Šé¢æåˆ°è¿‡çš„çŸ©é˜µã€‚ä¸è¿‡å®ƒçš„å®¹é‡è®¡ç®—å¾ˆç®€å•ï¼Œä¹Ÿå°±æ˜¯è¡Œåˆ—ä¹‹ç§¯äº†ã€‚ how to useå¦‚ä½•ä½¿ç”¨è¿™ç±»äºŒç»´æ•°ç»„ï¼Œæˆ‘ä»¬è€ƒè™‘ä¸‰ä¸ªæ–¹é¢çš„åº”ç”¨ï¼šè¾“å…¥ã€è¾“å‡ºå’Œä¼ é€’ã€‚ input and outputæ‡‚äº†è¾“å…¥ï¼Œå…¶å®žä¹Ÿå°±ä¼šè¾“å‡ºäº†ï¼Œé‚£å°±åªä»‹ç»è¾“å…¥äº†ï¼ˆå·æ‡’ðŸ˜œï¼‰ã€‚ å¯¹äºŽå­—ç¬¦ä¸²æ•°ç»„ï¼ˆè¿™æ ·å«å…¶å®žæ›´åˆé€‚ä¹Ÿæ›´æ˜“äºŽç†è§£ï¼‰ï¼Œä¸Žæ™®é€šä¸€ç»´æ•°ç»„ä¸€æ ·ï¼Œè‹¥æœ‰å¤šä¸ªè¾“å…¥ï¼Œåˆ™ä½¿ç”¨å¾ªçŽ¯ï¼Œé€ä¸ªè¯»å…¥å³å¯ã€‚ å¯¹äºŽæ•°å­—åž‹äºŒç»´æ•°ç»„ï¼Œå…ˆè¾“å…¥è¡Œï¼Œè¿˜æ˜¯å…ˆè¾“å…¥åˆ—å–å†³äºŽå®žé™…åº”ç”¨ï¼Œç”±äºŽä¸ä»…è¦è¾“å…¥è¡Œï¼Œè¿˜éœ€è¦è¾“å…¥åˆ—ï¼Œæ‰€ä»¥å¾—ä½¿ç”¨äºŒé‡å¾ªçŽ¯æžå®šã€‚ function parameter transfer äºŒç»´æ•°ç»„ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’çš„è¿‡ç¨‹å°±æ˜¯ä¸ªæœ‰ç‚¹çŽ„ä¹Žçš„è¿‡ç¨‹äº†ï¼Œä¸è¿‡åˆ‡è®°ä¸€ç‚¹ï¼Œæ•°ç»„ä¼ é€’åˆ°å‡½æ•°ä¸­çš„éƒ½æ˜¯æŒ‡é’ˆã€‚ å­—ç¬¦ä¸²æ•°ç»„ä¼ é€’æ—¶ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹æ³•ï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼šCharacter 1Character 21void fun(char (*str)[5], int n);1void fun(char str[][5], int n); ä¸Šè¿°çš„è¿™ä¸¤ç§æ–¹æ³•æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œä¹Ÿå³éœ€è¦ç»™å®šæ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ æ•°å­—åž‹äºŒç»´æ•°ç»„çš„ä¼ é€’ä¸Žå­—ç¬¦ä¸²æ•°ç»„çš„ä¼ é€’ç±»ä¼¼ï¼šNumber 1Number 21void fun(int (*array)[5], int n);1void fun(int array[][5], int n); boolæ—©æœŸçš„Cæ ‡å‡†å†…å…¶å®žæ˜¯æ²¡æœ‰boolç±»åž‹çš„ï¼ŒåŽŸå…ˆä¸€ç›´å­˜åœ¨äºŽC++ä¸­ï¼ŒåŽæ¥åœ¨C99æ ‡å‡†å‘å¸ƒçš„æ—¶å€™ï¼ŒåŠ å…¥äº†boolç±»åž‹ã€‚ åœ¨ä½¿ç”¨boolç±»åž‹æ—¶ï¼Œéœ€è¦å¼•å…¥å¤´æ–‡ä»¶stdlib.hï¼Œç”¨æ³•å¦‚ä¸‹ï¼š1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool func(int a) &#123; if(a &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main(int argc, char const *argv[]) &#123; printf("func(-1) = %d, func(1) = %d, func(0) = %d\n", func(-1), func(1), func(0)); return 0;&#125;/*Result:func(-1) = 0, func(1) = 1, func(0) = 1*/ æ˜Žæ˜¾å¯ä»¥çœ‹å‡ºæ­¤æ—¶false = 0, true = 1ã€‚ è‹¥æ— æ³•å¼•å…¥å¤´æ–‡ä»¶stdbool.hæ—¶ï¼Œè¯¥å¦‚ä½•ç»§ç»­ä¼˜é›…çš„ä½¿ç”¨boolç±»åž‹å‘¢ï¼Ÿ ä¸€èˆ¬è€Œè¨€ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼štypedef#define1typedef enum&#123;false, true&#125; bool;åˆ©ç”¨typedefå’Œenumå…³é”®å­—æž„é€ æžšä¸¾ã€‚123#define bool int#define false 0#define true 1ä½¿ç”¨å®å®šä¹‰ç›´æŽ¥å®šä¹‰ï¼ˆC99å°±æ˜¯è¿™æ ·å¹²çš„ï¼Œå¯ä»¥çœ‹çœ‹stdbool.hå¤´æ–‡ä»¶çš„å†…å®¹ï¼‰ã€‚ operatorå…³äºŽCè¯­è¨€è¿ç®—ç¬¦çš„é—®é¢˜ï¼Œå®žé™…ä¸Šå°±æ˜¯ä¸åŒè¿ç®—ç¬¦ä¹‹é—´ä¼˜å…ˆçº§ï¼ˆprecedenceï¼‰çš„é—®é¢˜ï¼Œè¿™éƒ¨åˆ†é—®é¢˜ï¼Œä¸»è¦æ˜¯é’ˆå¯¹åº”è¯•å§ï¼Œç”Ÿäº§çŽ¯å¢ƒä¸­å¤§æ¦‚å†™ä¸ªæµ‹è¯•ç¨‹åºå°±èƒ½å¾—å‡ºç»“è®ºäº†å§~ ä¼˜å…ˆçº§ è¿ç®—ç¬¦ ç»“åˆæ€§ 1 () ä»Žå·¦åˆ°å³ 2 !ã€+ã€-ã€++ã€â€“ ä»Žå³åˆ°å·¦ï¼ˆå•ç›®+ã€-ï¼‰ 3 *ã€/ã€% ä»Žå·¦åˆ°å³ 4 +ã€- ä»Žå·¦åˆ°å³ 5 &lt;ã€&lt;=ã€&gt;ã€&gt;= ä»Žå·¦åˆ°å³ 6 ==ã€!= ä»Žå·¦åˆ°å³ 7 &amp;&amp; ä»Žå·¦åˆ°å³ 8 &#124;&#124; ä»Žå·¦åˆ°å³ 9 =ã€+=ã€-=ã€*=ã€/=ã€%= ä»Žå·¦åˆ°å³ æ³¨æ„ï¼šä¸Šè¿°è¡¨æ ¼ç¬¬äºŒè¡Œä¸­ï¼Œâ€œå•ç›®+ã€-â€æŒ‡çš„å³æ˜¯æ­£è´Ÿå·ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æˆ¿å±‹è£…ä¿®ä¹‹â€œå‘â€]]></title>
    <url>%2F2019%2F05%2F15%2F%E8%A3%85%E4%BF%AE%2F</url>
    <content type="text"><![CDATA[å¼•å­è¿™å‡ å¤©å®¶é‡Œçš„æˆ¿å­åœ¨è£…ä¿®ï¼Œçœ‹ç€æ¯äº²é‚£ä¹ˆå¿™ç¢Œå’Œæ“å¿ƒçš„æ ·å­ï¼ŒäºŽæ˜¯ä¾¿è¶ç€è‡ªå·±å·æ‡’çš„æ—¶é—´ï¼Œå›žåŽ»ååŠ©ä¸€ä¸‹æ¯äº²ï¼Œå¹¶é¡ºä¾¿æ”¶æ‹¾ç‚¹è‡ªå·±ä¹‹å‰çš„â€œå®¶å½“â€â€”â€” å°±æ˜¯ä¹¦å’Œå†™è¿‡çš„ç¬”è®°äº†ã€‚ ä½•è°“è£…ä¿®è¯´èµ·è£…ä¿®ï¼Œæˆ‘å¯¹è¿™ä¸ªåè¯çš„æ¦‚å¿µç•¥å¾®æœ‰ç‚¹æ¨¡ç³Šï¼Œå¾—åœ¨è¿™ä¸ªè¯å‰é¢åŠ ç‚¹å•¥æ¥å¸®åŠ©ç†è§£å’Œæƒ³è±¡ï¼Œæ¯”å¦‚ï¼šæˆ¿å­è£…ä¿®ã€‚ä»”ç»†æ¥è®²ï¼Œè£…ä¿®åˆç§°è£…æ½¢æˆ–è£…é¥°ï¼Œæ˜¯æŒ‡åœ¨ä¸€å®šåŒºåŸŸå’ŒèŒƒå›´å†…è¿›è¡Œçš„ï¼ŒåŒ…æ‹¬æ°´ç”µæ–½å·¥ã€å¢™ä½“ã€åœ°æ¿ã€å¤©èŠ±æ¿ã€æ™¯è§‚ç­‰æ‰€å®žçŽ°çš„ï¼Œä¾æ®ä¸€å®šè®¾è®¡ç†å¿µå’Œç¾Žè§‚è§„åˆ™å½¢æˆçš„ä¸€æ•´å¥—æ–½å·¥æ–¹æ¡ˆå’Œè®¾è®¡æ–¹æ¡ˆã€‚ä¸€èˆ¬è€Œè¨€ï¼Œé’ˆå¯¹ä¸åŒçš„çŽ¯å¢ƒï¼Œæœ‰ç€ä¸åŒçš„è£…ä¿®æ–¹æ¡ˆå’Œé£Žæ ¼ï¼Œé…’åº—å’Œå•†åœºçš„è£…ä¿®æ–¹æ¡ˆå’Œé£Žæ ¼å°±å¤§ä¸ç›¸åŒï¼Œè€Œè¿™æ˜¯ç”±è¿™äº›åœºæ‰€çš„èŒèƒ½æ‰€ç¡®å®šçš„ï¼Œå¿…é¡»è¦æ»¡è¶³å¤§ä¼—åŒ–çš„è®¤çŸ¥ï¼Œå³è£…ä¿®èƒ½è¢«å¤§ä¼—æ‰€æŽ¥å—ã€ç†è§£ï¼Œè¿›è€Œè¾¾åˆ°å–œæ¬¢ã€‚è£…ä¿®ï¼Œéœ€è¦æ–½å·¥ï¼Œä¾æ®æ–½å·¥çš„å¯¹è±¡ï¼ˆæ°´ç”µã€å¢™ä½“ã€åœ°æ¿ã€å¤©èŠ±æ¿ç­‰ï¼‰ï¼Œå¯¹åº”çš„å·¥äººå¸ˆå‚…ä¹Ÿå¯ä»¥åˆ†ä¸ºï¼šæœ¨å·¥ã€æ°´ç”µå·¥ã€ç“¦å·¥ã€æ²¹å·¥ï¼Œè€Œæ‚¨å®¶ä½çš„æˆ¿å­çš„â€œå¤–è§‚â€å°±æ˜¯ç”±è¿™äº›äººï¼Œä¸€æ­¥ä¸€æ­¥æ¥å®Œæˆçš„ã€‚ å¦‚ä½•â€œè£…ä¿®â€çœ‹ç€ä¸Šé¢çš„å¤§æ ‡é¢˜ï¼Œä¹‹æ‰€ä»¥åŠ ä¸Šå¼•å·çš„åŽŸå› åœ¨äºŽï¼Œå¯¹äºŽæˆ¿ä¸»ï¼ˆä¹°æˆ¿çš„äººï¼‰è€Œè¨€ï¼Œå¦‚ä½•è£…ä¿®å‘¢ï¼Œå…¶å®žå°±æ˜¯èŠ±é’±æ‰¾äººå¹²æ´»ç½¢äº†ï¼Œæ¯•ç«Ÿå’±åˆä¸ä¼šå’Œæ°´æ³¥ã€åšæœ¨å·¥çš„ã€‚å—¯ï¼Œæ—¢ç„¶æ˜¯è¦èŠ±é’±ï¼Œé‚£å’±è¿™é’±å¾—èŠ±çš„åœ¨â€œç‚¹â€ä¸Šæ‰è¡Œï¼Œè‡³äºŽä¼šä¸ä¼šè¢«å‘ï¼Œè¿™å°±å¾—æ‰¾å¯¹äººäº†ã€‚é‚£ä¹ˆå›žåˆ°æ­£é¢˜ï¼Œå°±ç›®å‰å¸‚åœºè€Œè¨€ï¼Œæˆ¿å­è£…ä¿®çš„æ–¹å¼ï¼ˆå’Œå¸ˆå‚…çš„â€œå•†åŠ¡â€åˆä½œæ–¹å¼ðŸ˜‚ï¼‰å¤§æ¦‚æœ‰ä¸¤ç§ï¼š åŒ…å·¥åŒ…æ–™ï¼Œä¹Ÿå³â€œåŒ…å¹²â€ï¼ˆè¿™ç§å®£ä¼ æ‰‹æ®µéšå¤„å¯è§â€¦ï¼‰åŒ…å·¥ä¸åŒ…æ–™ï¼Œææ–™éœ€è¦ä¸»äººè´­ä¹°ï¼Œå¸ˆå‚…åªè´Ÿè´£å¹²æ´»äº† é‚£ä¹ˆï¼ŒæŒ‰ç…§ä»¥ä¸Šçš„ä¸¤ç§æ–¹å¼ï¼Œä¹Ÿæœ‰ä¸åŒçš„ä¼˜ç‚¹å’Œç¼ºç‚¹ï¼ŒåŒ…å·¥åŒ…æ–™æœ€ç›´æŽ¥çš„ä¼˜ç‚¹å°±æ˜¯ï¼Œå®¢å®˜æ‚¨ç»™é’±å°±æˆï¼Œä¸€åˆ‡å¸ˆå‚…æ›¿æ‚¨æžå®šã€‚è¿™ç§æ–¹å¼ï¼Œå¾—çœ‹æ‰¾çš„å¸ˆå‚…çš„äººå“äº†ï¼Œè¦ä¸ç„¶ç»™æ‚¨å·ç‚¹å·¥ã€å‡ç‚¹æ–™ï¼Œæˆ¿å­ä½ä¸ªä¸€å¹´åŠè½½å°±è¿”å·¥çš„ï¼Œé‚£å¯æ­£æ˜¯æœ‰çš„å—äº†ï¼Œå½“ç„¶äº†ï¼Œè¦æ˜¯æ‚¨é’±ç»™çš„è¶³ï¼Œé‚£å½“å’±æ²¡è¯´è¿™è¯ã€‚ä¸è¿‡ï¼Œå¯¹äºŽä¸€èˆ¬å®¶åº­è€Œè¨€ï¼Œå¤šå°‘è¿˜æ˜¯ä¼šè€ƒè™‘åˆ°ç»¼åˆé¢„ç®—åŠæ€§ä»·æ¯”ç­‰æ–¹é¢çš„ã€‚æ‰€ä»¥å‘¢ï¼Œé€‰æ‹©è¿™ç§æ–¹å¼çš„ï¼Œä¸€èˆ¬ä¼šæ‰¾äº²æˆšæˆ–å…³ç³»ç‰¹åˆ«é“çš„â€œå“¥ä»¬â€ï¼ˆäº²æœ‹å¥½å‹ï¼‰ã€‚å¯¹äºŽå¦å¤–ä¸€ç§æ–¹å¼è€Œè¨€ï¼Œé‚£å°±æ„å‘³ç€æˆ¿ä¸»åˆå¾—æƒ³åŠžæ³•æ‰¾äººï¼Œåˆå¾—æƒ³åŠžæ³•åŽ»æ‰¾æ¸ é“è´­ä¹°åˆæ ¼çš„ææ–™ï¼ˆåŠ³å¿ƒå•ŠðŸ˜ï¼‰ã€‚å…ˆä¸è¯´æ‰¾äººå¹²æ´»å¾—æ‰¾ä¸ªé è°±çš„äººï¼Œå•å•åªä»Žè´­ä¹°ææ–™çš„è§’åº¦è®²ï¼Œæˆ¿ä¸»è‹¥ä¸æ˜¯ç›¸å…³è¡Œä¸šå†…çš„äººå£«ï¼Œåœ¨è´­ä¹°è¿™äº›ææ–™çš„æ—¶å€™ï¼Œä¼šæ¯”è¾ƒå›°éš¾ã€‚é¦–å…ˆï¼Œä¸çŸ¥é“è´­ä¹°é‚£ä¸ªåž‹å·ã€é‚£ä¸ªå“ç‰Œçš„ææ–™ï¼Œä¸è¿‡è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡åŽ»è¯¢é—®é›‡ä½£çš„å¸ˆå‚…æ¥è§£å†³ã€‚ç´§æŽ¥ç€çš„é—®é¢˜ï¼Œå°±æ˜¯è´­ä¹°çš„æ¸ é“å’Œâ€œè¯†è´§â€çš„æœ¬é¢†äº†ï¼Œè´­ä¹°æ¸ é“ç•¥å¸¦é£Žé™©ï¼Œä¸ç„¶ä¹°åˆ°æ¬¡å“æˆ–å‡è´§å°±éš¾å—äº†ï¼Œå½“ç„¶å¦‚è‹¥èƒ½è‡ªå·±åˆ†è¾¨å‡è´§ï¼Œé‚£æœ€å¥½ä¸è¿‡äº†ï¼ˆéœ€è¦ç»éªŒï¼‰ã€‚å…¶å®žï¼Œåœ¨æ•´ä¸ªè£…ä¿®è¿‡ç¨‹ä¸­ï¼Œä»…ä»…åªæ³¨æ„ä¸Šé¢çš„å†…å®¹è¿˜ä¸å¤Ÿï¼Œä»Žä¸€å¼€å§‹ç¡®å®šè£…ä¿®çš„æ—¶å€™ï¼Œæœ‰ç‚¹éœ€è¦ç¡®å®šçš„å°±æ˜¯ï¼Œè£…ä¿®çš„é¡ºåºäº†ï¼ä¸€èˆ¬è€Œè¨€ï¼Œå¯ä»¥å¤§æ¦‚æŒ‰ç…§ä¸‹é¢è¿™ä¸ªé¡ºåºæ¥è¿›è¡Œï¼š ä¸»ä½“æ”¹é€  â†’ æ°´ç”µ â†’ ç“¦å·¥ â†’ æœ¨å·¥ â†’ æ²¹å·¥ â†’ ç¯é¥° â†’ æ¸…æ´ â†’ éªŒæ”¶å½“ç„¶äº†ï¼Œä¸åŒåœ°åŒºçš„è£…ä¿®å¸‚åœºçš„è£…ä¿®é¡ºåºå¯èƒ½ä¸æ˜¯ä¸€è‡´çš„ï¼Œä½†å¤§ä½“ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œä¸ç„¶çš„è¯ï¼Œä¸åŒæ‰‹è‰ºçš„å¸ˆå‚…æ— æ³•é…åˆå¹²æ´»çš„ã€‚ è£…ä¿®ä¹‹â€œå‘â€ä¿—è¯è¯´çš„å¥½ï¼šåƒä¸€å ‘é•¿ä¸€æ™ºæ‰€è°“çš„è£…ä¿®ä¹‹â€œå‘â€ï¼Œâ€œå‘â€åœ¨ä»€ä¹ˆåœ°æ–¹å‘¢ï¼Ÿè¿˜èƒ½åœ¨å“ªâ€¦é’±å‘—ï¼Œæ­£æ‰€è°“ï¼Œæ— å•†ä¸å¥¸ï¼Œä¸œè¥¿å–ç»™ä½ ï¼Œå•†å®¶å“ªèƒ½ä¸èµšé’±å‘¢ï¼Œæ˜¯å§ã€‚ä¸è¿‡è¯è¯´å›žæ¥ï¼Œå’±è¿˜æ˜¯é‚£ä¸ªæ€åº¦ï¼Œèµšé’±å¯ä»¥ï¼Œä»·æ ¼åˆç†å…¬é“ï¼Œè´¨é‡ä¼˜è‰¯è€ç”¨ï¼Œè¯¥ä»˜çš„é’±å’±ç…§æ ·ç»™ï¼ˆå“‡ï¼Œå¥½æ— åŠ›çš„æ„Ÿè„š~ï¼‰ã€‚ä¸è¿‡å‘¢ï¼Œä¸åŒåœ°åŒºçš„å¸‚åœºå¯èƒ½åœ¨æŸäº›åœ°æ–¹ä¸Šæœ‰æ‰€å·®å¼‚ã€‚å°±æ‹¿å‰å‡ å¤©ï¼Œå’±ç¢°åˆ°çš„ä¸€ä¸ªâ€œå‘çˆ¹â€çš„äº‹æƒ…ä¸ºä¾‹ã€‚ èµ·å› å®¶ä¸­æˆ¿å­è£…ä¿®ï¼Œéœ€è¦å®‰è£…é˜²ç›—ç½‘ï¼ŒäºŽæ˜¯ä¾¿æ‰¾äººåŽ»åšäº†ï¼Œä½†æ²¡æœ‰æå‰æŠŠä»·æ ¼è°ˆå¥½ï¼ˆè¿™ä¸ªæ˜¯çœŸçš„çƒ¦ï¼Œä»¥åŽåšäº‹ä¹‹å‰ä¸€å®šå¾—å…ˆæŠŠè¿™äº›åˆ©ç›Šå…³ç³»å¤„ç†å¥½ï¼‰ã€‚ å®‰è£…åšå¥½ä¹‹åŽï¼Œå³è¿›è¡Œå®‰è£…ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸­ä¸€åˆ‡OKã€‚ é—®é¢˜ç”±äºŽåœ¨åšä¹‹å‰ï¼Œæ²¡æœ‰è°ˆå¥½ä»·æ ¼çš„é—®é¢˜ï¼Œä»Žè€Œå¯¼è‡´ï¼Œæœ€åŽåœ¨ç»“è´¦çš„æ—¶å€™ï¼Œæˆäº†â€œç³Šæ¶‚è´¦â€ï¼Œé€ æˆäº†ä¸€ç§å…¬è¯´å…¬æœ‰ç†ï¼Œå©†è¯´å©†æœ‰ç†çš„å±€é¢ï¼Œæ‰‹åŠ¨æ‚è„¸ingã€‚ é—®é¢˜æˆå› ä¹‹æ‰€ä»¥ä¼šå­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œå’±å¾—å…ˆæ˜Žç¡®è¿™ä¸ªé˜²ç›—ç½‘çš„è®®ä»·è§„åˆ™ï¼ŒæŒ‰ç…§æˆ‘è¿™è¾¹æœ¬åœ°çš„å¸‚åœºï¼Œé˜²ç›—ç½‘æ˜¯æŒ‰ç…§$Xå…ƒ/m^2$çš„ä»·æ ¼æ¥è®¡ç®—çš„ï¼Œè€Œé˜²ç›—ç½‘çš„ç»“æž„æ˜¯ä¸‹é¢è¿™ç§ç»“æž„ï¼šæŽ¥ä¸‹æ¥çš„é—®é¢˜æ˜¯æŒ‰ç…§è¿™ä¸ªç»“æž„ï¼Œå¦‚ä½•è®¡ç®—è¿™ä¸ªç‰©ä½“æ‰€å çš„é¢ç§¯ï¼ˆ$m^2$ï¼‰ï¼Œæ°å·§é—®é¢˜å°±å‡ºåœ¨è¿™é‡Œäº†ã€‚ è®¡ç®—æ–¹å¼æŒ‰ç…§ä¹‹å‰çš„æ€è·¯ï¼Œé˜²ç›—é—¨çª—é¢ç§¯çš„è®¡ç®—æ–¹æ³•å…¶å®žæœ‰ä¸¤ç§ï¼š é€é¢è®¡ç®—ï¼Œç´¯åŠ å¾—ç»“æžœé€é¢å¹³é“ºï¼Œè®¡ç®—æ•´ä½“ï¼Œå‡åŽ»ä¸å­˜åœ¨é¢ï¼Œå³å¾—ç»“æžœ å…·ä½“è€Œè¨€ï¼Œå¯ä»¥å‚ç…§ä¸‹å›¾è¿›è¡Œè®¡ç®—ï¼šä»Žå›¾ä¸­å¯ä»¥åˆ†åˆ«çŸ¥é“ä¸¤ç§æ–¹æ³•å¯¹åº”çš„è®¡ç®—æ–¹æ³•ï¼š $1.\ S_{sum} = S_1 + S_2 + S_3 + S_4 + S_5$$2.\ S_{sum} = S - 4 \times S_1$ åªè¦å°ºå¯¸é‡çš„æ˜¯æ­£ç¡®çš„ï¼Œä¸¤ç§æ–¹æ³•çš†å¯è®¡ç®—å‡ºé˜²ç›—é—¨çª—çš„çœŸå®žé¢ç§¯ï¼Œå•†å®¶é‡‡ç”¨çš„æ˜¯ç¬¬äºŒç§æ–¹æ³•ï¼Œä¸è¿‡æ²¡æœ‰å‡åŽ»é‚£4å—ä¸å­˜åœ¨çš„é¢ç§¯ï¼Œè€Œè¿™ä¹Ÿå°±å¯¼è‡´æŒ‰ç…§è¿™ä¸¤ç§æ–¹æ³•è®¡ç®—å‡ºæ¥çš„ç»“æžœç›¸å·®äº†å¤§æ¦‚10ä¸ª$m^2$å·¦å³ï¼Œä¸Žå•ä»·ä¸€åˆè®¡ï¼Œå·®å€¼è¿˜æ˜¯æ¯”è¾ƒå¤§çš„ã€‚å¦‚æžœæ˜¯å­˜åœ¨çš„é¢ç§¯è®¡ç®—åœ¨å†…ï¼Œè¿˜å¯ä»¥ç†è§£ï¼Œä½†é‚£4å—é¢ç§¯æ˜¯ä¸å­˜åœ¨çš„ï¼Œä¸å­˜åœ¨è¿˜ç®—è¿›åŽ»ï¼Œé‚£ä¸æ˜¯æ— ä¸­ç”Ÿæœ‰å—ï¼ŸäºŽæ˜¯åŽ»æ‰¾å•†å®¶ç†è®ºï¼Œç»“æžœè¢«å‘ŠçŸ¥æ˜¯å¸‚åœºè§„åˆ™ã€è¡Œä¸šè§„åˆ™ï¼ˆæ€»ä¹‹å°±æ˜¯ä¸è®©ä»·ï¼‰ï¼Œè¿™ä¸æ˜¯æ‘†æ˜Žäº†å‘äººä¹ˆï¼ŸåŽæ¥ï¼Œåˆäº†è§£åˆ°ï¼Œæ®è¯´å¦‚æžœæ˜¯ç»™äº²æœ‹å¥½å‹åšï¼Œæ˜¯å¾—å‡åŽ»é‚£å››ä¸ªä¸å­˜åœ¨çš„é¢ç§¯çš„ï¼Œå¦‚æžœä¸æ˜¯äº²æœ‹å¥½å‹ï¼Œé‚£å°±æ­‡èœäº†ï¼ˆðŸ˜‚ï¼Œæžœç„¶æ˜¯æ— å•†ä¸å¥¸ï¼‰ã€‚ è§£å†³æ–¹å¼ç£¨å˜´çš®å­ç£¨å˜´çš®å­ç£¨å˜´çš®å­â€¦æ²¡æœ‰å•¥æ·å¾„å“ˆ~ æ€»ç»“è¿˜æ˜¯é‚£å¥è¯ï¼Œåšäº‹ä¹‹å‰ï¼Œåƒä¸‡è¦å¤„ç†å¥½åˆ©ç›Šå…³ç³»ã€‚ä¸è¿‡è¯è¯´å›žæ¥ï¼Œå•†å®¶è¿™ç¡®å®žæœ‰ç‚¹â€œå‘â€äººï¼Œæ˜Žé‡Œæ¥è¯´ææ–™è´µå³å¯ï¼Œè¿˜çŽ©è¿™äº›â€œèŠ±æ‹›â€ï¼ŒçœŸæ˜¯â€œå…µä¸åŽŒè¯ˆâ€ï¼Ÿæ›´ä½•å†µåªæ˜¯ç®€å•çš„å°å­¦æ•°å­¦ðŸ˜‚ï¼å“Žï¼Œè¿™ä¹Ÿå°±æ¬ºè´Ÿä¸€ä¸‹å¸¸å¹´åœ¨å¤–æ‰“å·¥æŒ£é’±çš„å’Œæ–‡åŒ–æ°´å¹³ä¸é«˜çš„äººï¼Œæ°å·§æ­£å¥½æ˜¯å’±ä»¬çˆ¶äº²ã€æ¯äº²é‚£ä¸€è¾ˆäººã€‚å¦å¤–ï¼Œä»Žè¿™äº›äº‹æƒ…ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œå®¶è£…è¿™ä¸ªè¡Œä¸šçš„æ°´ä¹Ÿæ˜¯è¶³å¤Ÿæ·±çš„å“ˆï¼Œå…ˆä¸è¯´ææ–™å¯èƒ½ä¼šæžé¬¼äº†ï¼Œå…‰ç€ç®—è´¦éƒ½ç€å®žè®©äººè§‰ç€å‘çˆ¹ðŸ˜‘ï¼Œéƒ½ä¸çŸ¥é“è¯¥è¯´å•¥å¥½äº†ã€‚ç±»ä¼¼çš„é—®é¢˜ï¼Œåœ¨æœ¨å·¥ã€ç“¦å·¥ç­‰è£…ä¿®è¿‡ç¨‹ä¸­åŒæ ·å­˜åœ¨ï¼ˆå…¶ä»–è¡Œä¸šä¼°è®¡ä¹Ÿè¿™æ ·ï¼‰ï¼Œæ‰€ä»¥ï¼Œåƒä¸€å ‘é•¿ä¸€æ™ºï¼Œè¿™è¯è®°ä½å‡†æ²¡é”™~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>Interior Finish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¥‡è‘©çš„å›½å†…BGPä¸šåŠ¡æž¶æž„]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%A5%87%E8%91%A9%E7%9A%84%E5%9B%BD%E5%86%85BGP%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Introå›½å†…å­˜åœ¨BGPä¸šåŠ¡ï¼Œä½†æ˜¯å®žé™…ä¸Šå¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„BGPï¼Œè€Œæ˜¯é€šè¿‡æ¨¡æ‹Ÿæ¥æž„å»ºçš„â€œé™æ€BGPâ€ï¼›ä¹‹æ‰€ä»¥æ˜¯è¿™æ ·çš„æƒ…å†µï¼ŒåŽŸå› æ˜¯è¿è¥å•†å’Œæ”¿ç­–â€¦æ‰“ä½ï¼Œæ‰¯è¿œäº†ï¼Œæˆ‘ä»€ä¹ˆéƒ½ä¸çŸ¥é“ðŸ¤«ã€‚åæ­£å®¢æˆ·éœ€è¦å°±åšðŸ˜‚ï¼Œæœ¬ç€å…ˆåšå…ˆå®Œäº‹ï¼Œéšæ‚£æ—¥åŽå†è¯´çš„åŽŸåˆ™ï¼ˆç¬‘ingï¼‰ï¼Œå¥½æ­¹ç®—æ˜¯æ¯é¥¬å‡ºæ¥ä¸€ä¸ªã€‚ Static BGP Brief Descriptionä¸ŽBGPç›¸å…³çš„åŽŸç†å†…å®¹åœ¨è¿™é‡Œä¸ä»‹ç»äº†ï¼ˆå’±ä¹Ÿä¸å¤ªæ‡‚ðŸ¤£ï¼‰ï¼Œå…·ä½“è¯´ä¸‹åšè¿™çŽ©æ„çš„å‰å› åŽæžœå§ï¼Œè¿™éƒ¨åˆ†å†…å®¹å°±å½“â€œä¾ƒå¤§å±±â€å§ðŸ¤”ã€‚ å›½å†…è¿è¥å•†ä¸‰å·¨å¤´ï¼šä¸­å›½ç”µä¿¡ã€ä¸­å›½ç§»åŠ¨ã€ä¸­å›½è”é€šï¼Œè¿™ä¸‰å®¶å›½ä¼æƒ³å¿…å¤§å®¶éƒ½æ¯”è¾ƒç†Ÿï¼ˆtaoï¼‰çŸ¥ï¼ˆyanï¼‰ï¼›è€Œä¸Žè¿™ä¸‰å®¶è¿è¥å•†äº’è”çš„æ–¹å¼å‘¢ï¼Œä¸€å¾‹å…¨éƒ¨éƒ½æ˜¯é‡‡ç”¨é™æ€äº’è”çš„æ–¹å¼ï¼›ä¹‹æ‰€ä»¥é‡‡ç”¨é™æ€äº’è”ï¼Œä¹Ÿä¸æ˜¯å› ä¸ºåŠ¨æ€æŠ€æœ¯ä¸æˆç†Ÿç­‰ä¹‹ç±»çš„ç¼˜ç”±ï¼Œå…¶å®žå°±æ˜¯ç®€å•ä¸”æ˜“æŽ§åˆ¶ï¼Œç›´æŽ¥æ”¾ç»™ä½ å°±å®Œäº‹ï¼Œæƒ³æŽ§åˆ¶ç›´æŽ¥ä¿®æ”¹é…ç½®å°±å¥½ï¼Œå…¶å®žè¿˜æœ‰ä¸€ä¸ªç‚¹ï¼Œé‚£å°±æ˜¯é‡‡ç”¨åŠ¨æ€åŽï¼Œå¯¹æŸäº›ç½‘ç»œæä¾›å•†è€Œè¨€ä¼šæ¯”è¾ƒâ€œä¸å…¬å¹³â€ï¼ŒåŠ¨æ€è·¯ç”±æ”¶æ•›å¯æ˜¯é€‰æ‹©å»¶è¿Ÿæœ€å°ã€æŸè€—æœ€ä½Žçš„çº¿è·¯çš„ã€‚å…·ä½“å˜›ï¼Œå’±ä¹Ÿåˆ«å¤ªæ·±ç©¶ï¼Œæ˜¯è¿™ä¹ˆä¸ªè§„å®šï¼Œå¤§çŽ¯å¢ƒæ˜¯è¿™æ ·ï¼Œå’±æ”¹å˜ä¸äº†ï¼Œéµå®ˆå°±è¡Œäº†ã€‚è¯åœ¨è¯´å›žæ¥ï¼ŒæŒ‰ç…§è¿™æ ·çš„çŽ¯å¢ƒï¼Œå¯¹äºŽç½‘ç»œæä¾›å•†å’Œè¿è¥å•†æŽ¥å…¥çš„è·¯ç”±å™¨è€Œè¨€å°±åªèƒ½ä¿è¯ä¸€ä¸ªçº¿è·¯çš„æ–¹å‘äº†ï¼ˆå•ã€å¤šçº¿æ— æ³•ä¸ŽBGPå…±å­˜ï¼‰ï¼Œé‚£BGPåˆæ˜¯ä»Žä½•è°ˆèµ·çš„å‘¢ï¼Ÿè¿˜æœ‰å…¶ä»–çš„åŒçº¿ã€ä¸‰çº¿ä¹‹ç±»çš„ä¸šåŠ¡åˆæ˜¯æ€Žä¹ˆåšçš„ï¼Ÿ å¾—å˜žï¼Œå’±è¿˜æ˜¯å…ˆä»Žå•çº¿ä¸šåŠ¡è¯´èµ·å§ï¼Œè¿™æ²¡å•¥éš¾åº¦çš„ï¼Œå•çº¿ä¸šåŠ¡ï¼Œç»™æœåŠ¡å™¨é…ä¸€ä¸ªIPå®Œäº‹ï¼Œæ²¡å•¥è¯´çš„ã€‚è¿™ç±»ä¸šåŠ¡çš„ç‰¹ç‚¹å°±æ˜¯â€”ä¸ç®¡ä½ ç”¨æºIPåŽ»è®¿é—®ä»€ä¹ˆåœ°å€ï¼Œéƒ½æ˜¯ä»Žä¸€ä¸ªçº¿è·¯å‡ºåŽ»çš„ï¼Œæ¯”å¦‚ï¼ŒæºIPç”µä¿¡çš„ï¼Œé‚£ä½ å‡ºå±€å°±æ˜¯ç”µä¿¡çº¿è·¯ï¼ŒæºIPè”é€šçš„ï¼Œå‡ºå±€å°±æ˜¯è”é€šçº¿è·¯ã€‚ åœ¨è¯´åŒçº¿ä¸šåŠ¡ï¼Œå•çº¿ä¸šåŠ¡é…ä¸€ä¸ªIPï¼Œé‚£åŒçº¿ä¸šåŠ¡ä¸å°±é…ä¸¤ä¸ªIPå®Œäº‹å—ï¼Ÿ(âŠ™ï¹âŠ™)ï¼Œå¯¹äº†ä¸€åŠï¼›åŒçº¿ä¸šåŠ¡çš„ç¡®éœ€è¦é…ç½®ä¸¤ä¸ªIPï¼Œä½†æ˜¯å¹¶ä¸æ˜¯é…ç½®ä¸¤ä¸ªIPå°±å®Œäº‹äº†ï¼Œè¿˜éœ€è¦åœ¨æœåŠ¡å™¨ä¸Šå¯¼å…¥åŽ»å¾€å„ä¸ªåœ°å€æ®µçš„è·¯ç”±ã€‚ä»€ä¹ˆé¬¼ï¼ŸæœåŠ¡å™¨è¿˜èƒ½åŠ è·¯ç”±ï¼Œè¿˜çœŸèƒ½åŠ ðŸ˜“ï¼Œè¿™å¦‚æžœè¦è¯´ï¼Œåˆè¦ç‰µæ‰¯åˆ°ä¸€äº›ä¸œè¥¿ï¼Œå—¯ï¼Œåˆ«æ€¥ï¼Œç»™ä½ å¨“å¨“é“æ¥ã€‚ å’±å…ˆä¸è¯´æ€Žä¹ˆåŽ»åŠ è·¯ç”±ï¼Œå’±å…ˆä»‹ç»ä¸‹å›½å†…çš„ç½‘ç»œçŽ¯å¢ƒã€‚é¦–å…ˆå¾—æ˜Žç¡®IPåœ°å€è¿™ä¸ªçŽ©æ„åœ¨å¤§ç½‘çŽ¯å¢ƒå†…æ˜¯å”¯ä¸€å­˜åœ¨çš„ï¼ˆç§ç½‘åœ°å€ä½ å°±æŠ˜è…¾åŽ»å§ï¼‰ï¼Œæ¢å¥è¯è¯´ï¼Œä¸‰å¤§è¿è¥å•†æ˜¯æ‹¥æœ‰åªå±žäºŽè‡ªå·±çš„IPåœ°å€çš„ï¼ˆä»€ä¹ˆï¼Ÿä½ ä¹Ÿæƒ³è¦å±žäºŽè‡ªå·±çš„IPåœ°å€ï¼Ÿè‡ªå·±åŽ»æ‰¾ç®¡ç†IPçš„ç»„ç»‡åŽ»ä¹°å§ï¼Œå¤šå°‘é’±ï¼Ÿå˜¿å˜¿ï¼Œè‡ªå·±åŽ»é—®ã€‚ï¼‰ï¼Œå¹¶ä¸”è¿™äº›åœ°å€åœ¨å›½å†…çš„å¤§ç½‘çŽ¯å¢ƒä¸‹æ˜¯å”¯ä¸€çš„ã€‚è¿™æ ·å°±ä¼šäº§ç”Ÿä¸€ä¸ªé—®é¢˜ï¼Œæ—¢ç„¶è”é€šçš„åœ°å€åªå±žäºŽè”é€šï¼Œé‚£ç”µä¿¡ç”¨æˆ·å¦‚ä½•åŽ»è®¿é—®è”é€šçš„åœ°å€å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯è¿è¥å•†ä¹‹é—´åšäº†äº’è”ï¼Œè‡³äºŽæ˜¯åŠ¨æ€çš„è¿˜æ˜¯é™æ€çš„ï¼Œè¿™ä¸ªï¼Œå˜¿å˜¿ï¼Œä¸æ˜¯å’±è®¨è®ºçš„èŒƒå›´ï¼Œåœ¨æœ‰äº’è”çš„å‰æä¸‹ï¼Œç”µä¿¡ç”¨æˆ·ä¹Ÿå°±å¯ä»¥åŽ»è®¿é—®è”é€šçš„åœ°å€å•¦ã€‚å¥½ï¼Œè¿™ä¸ªé—®é¢˜æ˜Žç™½äº†ï¼Œå’±åœ¨æ¥çœ‹çœ‹å¦å¤–ä¸€ä¸ªçŽ°è±¡ï¼Œä¸çŸ¥é“å„ä½çœ‹å®˜æœ‰æ²¡æœ‰ç•™æ„è¿‡ï¼Œç½‘ç»œæ¸¸æˆæ€»ä¼šæœ‰ä¸€äº›ç½‘é€šåŒºã€ç”µä¿¡åŒºç­‰ï¼Œå¦‚æžœç”µä¿¡ç”¨æˆ·å·²ç»å¯ä»¥è®¿é—®è”é€šåœ°å€äº†ï¼Œé‚£ä¹ˆè¿è¥å•†éƒ½åšæˆå…¨ç½‘å¯ä»¥äº’ç›¸è®¿é—®ä¸å°±å¾—äº†ï¼Œé‚£è¿™æ ·è¿˜æžè¿™äº›åŒºå¹²æ¯›ï¼Ÿè¯¶ï¼Œè¿™ä¸ªå…¶å®žæ˜¯æœ‰ç‚¹è®²ç©¶çš„ï¼Œå˜¿å˜¿ã€‚ç­”æ¡ˆå°±æ˜¯ï¼Œå¦‚æžœä½ æ˜¯è”é€šç”¨æˆ·ï¼Œä½ é€‰æ‹©ç½‘é€šåŒºè¿›è¡Œæ¸¸æˆï¼Œä½ ä¼šè§‰å¾—ç½‘é€Ÿéžå¸¸å¿«ã€‚ä½ é—®ä¸ºå•¥ï¼Ÿå› ä¸ºç½‘é€šåŒºçš„æ¸¸æˆæœåŠ¡å™¨IPè‚¯å®šä¹Ÿæ˜¯è”é€šçš„IPï¼Œè¿™æ ·åœ¨æœ¬è¿è¥å•†å†…éƒ¨è¿›è¡Œè®¿é—®çš„æ—¶å€™ï¼Œé‚£ä¸å°±æ˜¯åœ¨â€œå†…ç½‘â€é‡Œé¢è¿›è¡Œæ•°æ®äº¤äº’äº†å—ï¼Ÿéƒ½æ²¡è·‘åˆ°â€œå…¬ç½‘â€ä¸ŠåŽ»ï¼Œé€Ÿåº¦è‚¯å®šå¿«å•ŠðŸ˜‚ã€‚å…¶ä»–ä¹ŸåŒç†ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºå•¥æœ‰äººä¼šè¯´ä¸­å›½çš„ç½‘ç»œå®žé™…ä¸Šæ˜¯ä¸€ä¸ªå¤§çš„å±€åŸŸç½‘ï¼Œç‰¹åˆ«æ˜¯è¢«Great Firewall of Chinaç¦æŽ‰ä¸€äº›å›½é™…IPåŽðŸ™Šã€‚ å¥½äº†ï¼Œåœ¨å›žåˆ°åŠ è·¯ç”±çš„é—®é¢˜ä¸Šæ¥ï¼Œå’±å·²ç»çŸ¥é“ç»™æœåŠ¡å™¨é…ç½®ä¸¤ä¸ªIPäº†ï¼ˆçŽ°åœ¨åº”è¯¥ä¹ŸçŸ¥é“ä¸ºå•¥è¦æžè¿™ç§åŒçº¿æœºå™¨äº†å§ï¼Œæ‰‹åŠ¨ç¬‘å“­ï¼‰ï¼Œé‚£åŠ è·¯ç”±æ€Žä¹ˆåŠ å‘¢ï¼Ÿå¯¹äºŽä¸€ä¸ªIPåœ°å€è€Œè¨€ï¼Œå¦‚æžœè¦å’Œå…¶ä»–å­ç½‘é€šä¿¡ï¼Œå¿…é¡»å­˜åœ¨ç½‘å…³ï¼Œåˆ©ç”¨ç½‘å…³æ¥æŽ¥æ”¶ã€å‘é€æ•°æ®åŒ…ï¼ŒåŒçº¿æœºå™¨ä¸¤ä¸ªIPï¼Œè‚¯å®šä¹Ÿæœ‰ä¸¤ä¸ªç½‘å…³å•Šï¼ŒæœåŠ¡å™¨èƒ½åŒæ—¶é…ç½®ä¸¤ä¸ªç½‘å…³ï¼Ÿç­”æ¡ˆæ˜¯ä¸èƒ½ï¼Œé‚£ta niangçš„æ€Žä¹ˆåŠžå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å†™è·¯ç”±å•Šï¼ˆä¸ºäº†å¼•å‡ºä½ æ¥ï¼Œå†™äº†è¿™ä¹ˆå¤šå­—ï¼Œæ‰‹é…¸å•ŠðŸ™ƒï¼‰ã€‚ä»¥é…ç½®äº†è”é€šã€ç”µä¿¡çš„åœ°å€çš„åŒçº¿æœºå™¨ä¸ºä¾‹ï¼Œè®¿é—®è”é€šåœ°å€ä½¿ç”¨è”é€šç½‘å…³ï¼Œè®¿é—®ç”µä¿¡åœ°å€ä½¿ç”¨ç”µä¿¡ç½‘å…³ï¼Œè¿™æ ·å°±å¯ä»¥å•¦ï¼Œå°±å¯ä»¥æ„‰å¿«çš„è®¿é—®æŒ‰æŒ‡å®šçº¿è·¯è®¿é—®æŒ‡å®šçš„è¿è¥å•†çš„IPåœ°å€å•¦ã€‚ å†™åˆ°è¿™é‡Œï¼Œç½‘ç»œå·¥ç¨‹å¸ˆå¯èƒ½ä¼šæœ‰é—®é¢˜äº†ï¼Œè·¯ç”±å™¨ã€äº¤æ¢æœºä¸Šæ€Žä¹ˆåŽ»é…ç½®å¤šä¸ªç½‘å…³ï¼ˆå­ç½‘åˆ’åˆ†ï¼‰ï¼Œå¹¶ä¸”åšåˆ°ä¸åŒçº¿è·¯çš„å‡ºå±€å‘¢ï¼Ÿ å½“ç„¶äº†ï¼Œå¯¹äºŽç½‘ç»œå·¥ç¨‹å¸ˆè€Œè¨€ï¼Œè¿™é‡Œè¿˜éœ€è¦è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼ŒåŒçº¿æœºå™¨æœ‰å‡ ä¸ªç½‘å¡ï¼Œå‡å¦‚æœ‰å¤šä¸ªç½‘å¡ï¼Œé‚£å¾ˆç®€å•ï¼Œä¸åŒçš„ç½‘å¡åšé€šä¸åŒçš„æ•°æ®å°±å¥½å•¦ï¼Œé‚£ä¸€ä¸ªç½‘å¡æ€Žä¹ˆåŠžï¼Ÿ é¦–å…ˆï¼Œå…ˆæ¥è§£å†³å¤šä¸ªç½‘å…³çš„é—®é¢˜ï¼ŒæœåŠ¡å™¨å¦‚ä½•åŽ»é…ç½®ï¼Œè¿ç»´å·¥ç¨‹å¸ˆè‡ªæœ‰å¦™è®¡ï¼Œå’±ä¸åŽ»ç®¡å®ƒï¼›è·¯ç”±å™¨ã€äº¤æ¢æœºå¦‚ä½•é…ç½®å‘¢ï¼Ÿä»¥åŽä¸ºè®¾å¤‡ä¸ºä¾‹ï¼Œé…ç½®è¿‡ç¨‹å¤§æ¦‚å¦‚ä¸‹ï¼š1234[R1]vlan 10[R1-vlan10]interface vlanif 10[R1-Vlanif10]ip address 10.0.254.1 24[R1-Vlanif10]ip address 10.0.253.1 24 sub å®Œäº‹åŽæ˜¯è¿™æ ·ï¼š12345#interface Vlanif10 ip address 10.0.254.1 255.255.255.0 ip address 10.0.253.1 255.255.255.0 sub# è¿™æ ·å°±æŠŠä¸¤ä¸ªä¸åŒç½‘æ®µçš„æ•°æ®åšåˆ°ä¸€ä¸ªvlanä¸‹äº†ã€‚ å’±ä»¬åœ¨çœ‹å‡ºå±€çš„é—®é¢˜ï¼Œå‡ºå±€éœ€è¦å€ŸåŠ©ä¸€ä¸ªå«PBR, Policy Based Routingçš„çŽ©æ„ï¼Œå˜¿å˜¿ï¼ŒåŽ‚å•†çœŸä¼šçŽ©ï¼Œæ˜¯è·Ÿè¿è¥å•†å·å·å•†é‡å¥½äº†æ˜¯å§ã€‚å…·ä½“å¦‚ä½•åŽ»åšï¼Œè¦è§†å…·ä½“çš„ç½‘ç»œæž¶æž„å’ŒçŽ¯å¢ƒåŽ»åšï¼ˆè‡ªå·±åŽ»ç™¾åº¦ðŸ˜ï¼‰ã€‚ å¥½ï¼ŒåŒçº¿ä¸šåŠ¡å¤§è‡´å°±æ˜¯è¿™æ ·äº†ï¼Œå¯¹åº”çš„ä¸‰çº¿ä¸šåŠ¡ï¼Œå°±ä¸ç”¨æˆ‘è¯´äº†å§ï¼Œå˜¿å˜¿ï¼Œä¸è¿‡ç½‘ç»œæä¾›å•†å¯èƒ½ä¼šç”¨â€œBGPâ€åœ°å€æ¥ä»£æ›¿å¤šçº¿ä¸šåŠ¡é…ç½®çš„å¤šä¸ªIPåœ°å€æ¥é¿å…IPåœ°å€çš„æµªè´¹ï¼ˆä½†æ®è¯´â€œBGPâ€åœ°å€è´µå•Šï¼Œä¸è¿‡ï¼Œè¿™æ˜¯å•†åŠ¡çš„äº‹æƒ…ï¼Œå•†åŠ¡è‡ªæœ‰å•†åŠ¡çš„ä¸€å¥—ï¼‰ã€‚ å›žè¿‡å¤´æ¥çœ‹ä¸€ä¸‹ï¼ŒåŒçº¿ã€ä¸‰çº¿ä¸šåŠ¡éœ€è¦åšçš„é…ç½®è¿˜æ˜¯æ¯”è¾ƒå¤šçš„ï¼Œä¸ç®¡æ˜¯æœåŠ¡å™¨è¿˜æ˜¯è·¯ç”±å™¨ï¼Œä¸ä¹Ÿæ˜¯ç´¯çš„ä¸€é€¼å—ï¼Ÿæœ‰æ²¡æœ‰ä»€ä¹ˆèƒ½ä¸€æ¬¡æ€§æžå®šï¼Œè€Œä¸”ä¸‰ç½‘å†…éƒ½è·Ÿè·‘â€œå†…ç½‘â€ä¸€æ ·å‘¢ï¼Ÿè¯¶ï¼Œè¿è¥å•†åˆå‡ºé©¬äº†ï¼šè§‰å¾—éº»çƒ¦æ˜¯ä¸æ˜¯ï¼Œå¥½ï¼Œæˆ‘ç»™ä½ ä»¬å‡è´Ÿï¼ˆçœŸæ˜¯è¿™æ ·ä¹ˆï¼Ÿè¿è¥å•†ä¼šè¿™ä¹ˆå¥½å¿ƒï¼Ÿï¼‰ï¼Œæˆ‘ä»¬çŽ°åœ¨èƒ½æä¾›ä¸€ç§â€œBGPâ€çš„äº§å“ï¼Œè¿™ç±»åœ°å€å…·æœ‰èƒ½ä»Žä¸‰ç½‘çº¿è·¯ç‹¬ç«‹è®¿é—®çš„ç‰¹æ€§ã€‚ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿä¹Ÿå°±æ˜¯è¯´å„ä¸ªè¿è¥å•†çš„ç”¨æˆ·è®¿é—®è¿™äº›â€œBGPâ€åœ°å€çš„æ—¶å€™èƒ½ç”¨è‡ªèº«è¿è¥å•†çš„çº¿è·¯åŽ»è®¿é—®ï¼Œè€Œä¸éœ€è¦è·¨è¿è¥å•†ã€‚æ‰€è¾¾åˆ°çš„æ•ˆæžœå…¶å®žæ˜¯å’Œä¸‰çº¿ä¸šåŠ¡ä¸€æ ·çš„ï¼Œåªä¸è¿‡ä¼šæ–¹ä¾¿å¾ˆå¤šï¼ˆå¯¹å®¢æˆ·è€Œè¨€ï¼ŒIPé…ç½®ä¸€ä¸ªï¼ŒæœåŠ¡å™¨ä¹Ÿä¸ç”¨å†™è·¯ç”±ï¼Œå—¨å•Šï¼‰ï¼Œä½†æ˜¯ä¸€æ ·éœ€è¦å‰æœŸæŠŠè·¯ç”±å™¨ä¸Šçš„é…ç½®éƒ½åšå¥½å•Šå•Šå•Šï¼Œè¿˜æ˜¯å¥½éº»çƒ¦å•Šã€‚ åŽæ¥ï¼Œäººä»¬ç»™è¿™ç§â€œBGPâ€åœ°å€ä¸€ä¸ªæ´‹æ°”çš„åå­—ï¼Œå°±å«åšStatic BGPðŸ¤£ã€‚ å¥½ï¼Œæ•…äº‹åˆ°æ­¤ç»“æŸðŸ¤£ã€‚ Static BGP Routingä¸‹é¢å°±è¿›å…¥æ­£é¢˜å•¦ã€‚å…·ä½“æž¶æž„å°±æŒ‰ç…§ä¸‹é¢è¿™ä¸ªå›¾å§~ åˆå¼„äº†ä¸€å¼ å›¾ï¼Œä¸¤å¼ å›¾ç»“åˆä¸€èµ·çœ‹ï¼Œå¯¹æ¯”æ¥çœ‹ï¼Œå®¹æ˜“ä¸€äº›ï¼ˆæ®è¯´æ˜¯TXçš„ç½‘ç»œéƒ¨é—¨å¤§ç‰›ç”»çš„ï¼‰ã€‚ Basic Connectionåº•å±‚äº’è”ï¼Œä½¿ç”¨é™æ€äº’è”å³å¯ï¼Œä½†è¿™éœ€è¦åº•å±‚çš„ä¼ è¾“ç½‘ç»œè¶³å¤Ÿå¥å£®ã€ç¨³å®šã€‚ä¿è¯äºŒå±‚ä¼ è¾“ç½‘ç»œå¥å£®æ€§æŠ€æœ¯ä¸»è¦æœ‰VCSã€ERPSç­‰ï¼Œè¿™äº›éƒ½å±žäºŽäºŒå±‚æ— çŽ¯è·¯ä¿æŠ¤åè®®ï¼Œå…·ä½“å¦‚ä½•é…ç½®ï¼Œåœ¨è‡ªè¡Œç ”ç©¶ã€‚çŽ°åœ¨å°±ä»¥äºŒå±‚å·²ç»é…ç½®å¥½äº†ä¿æŠ¤åè®®ä¸ºä¾‹ï¼Œç»™å‡ºä¸¤å°è·¯ç”±å™¨çš„é™æ€äº’è”IPä¿¡æ¯æ¥ååŠ©é…ç½®BGPã€‚ R1-CM-Access1234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# R2-BGP-Router1234!interface ve 925 ip address 10.0.254.1/30! å•å‘æµ‹è¯•ä¸€ä¸‹ï¼šBGP-Router1ping 10.0.254.1 source 10.254.0.2 BGP Configä¸‹é¢ä»‹ç»BGPçš„ç›¸å…³é…ç½®ï¼Œä»¥ä¸Žä¸€ä¸ªè¿è¥å•†æŽ¥å…¥çš„æƒ…å†µä¸ºä¾‹ï¼Œå…¶ä¸­CM-Accessä¸ºåŽä¸ºè®¾å¤‡ï¼ŒBGP-Routerä¸ºåšç§‘è®¾å¤‡ã€‚ä¸Žè¿è¥å•†æŽ¥å…¥çš„è®¾å¤‡é…ç½®æ¯”è¾ƒç®€å•ï¼Œå’±åªç”¨åšå¥½BGPè¿žæŽ¥å°±å¥½äº†ã€‚R1-CM-Access12345678910111213&lt;R1&gt;system-view[R1]bgp 9527 //å»ºç«‹BGPè¿›ç¨‹ï¼Œè®¾ç½®ASå·ä¸º9527[R1-bgp]router-id x.x.x.x //è®¾ç½®router-idï¼Œä¸€èˆ¬ä¸ºçŽ¯å›žæŽ¥å£åœ°å€[R1-bgp]peer 10.0.254.1 as-number 35129 //è®¾ç½®BGPå¯¹ç­‰ä½“[R1-bgp]peer 10.0.254.1 description BGP-Router //æ·»åŠ è¯¥å¯¹ç­‰ä½“çš„æè¿°ä¿¡æ¯[R1-bgp]peer 10.0.254.1 enable //å»ºç«‹å’ŒBGPå¯¹ç­‰ä½“çš„TCPè¿žæŽ¥[R1-bgp-af-ipv4]import-route static //å¯¼å…¥é™æ€è·¯ç”±[R1-bgp-af-ipv4]quit[R1-bgp]quit[R1]ip route-static ..... //å†™å…¥ç§»åŠ¨è¿è¥å•†è·¯ç”±[R1]ip route-static ...[R1]quit&lt;R1&gt;save //ä¿å­˜é…ç½® BGPæ ¸å¿ƒè·¯ç”±å™¨R2çš„é…ç½®ç›¸æ¯”R1è¦å¤šå¾ˆå¤šäº†ï¼Œå¹¶ä¸”æ˜¯åœ¨æœ‰æ„è¯†çš„è¿›è¡Œé…ç½®ã€‚R2-BGP-Router1234567891011121314151617181920212223242526272829R2#configure terminalR2(config)#router bgpR2(config-bgp)#local-as 35129 //è®¾ç½®æœ¬åœ°ASå·R2(config-bgp)#neighbor 10.0.254.2 remote-as 9527 //è®¾ç½®BGPå¯¹ç­‰ä½“R2(config-bgp)#neighbor 10.0.254.2 soft-reconfiguration inbound //å¼€å¯å¯¹ç­‰ä½“æµå…¥è·¯ç”±è½¯åˆ·æ–°R2(config-bgp)#neighbor 10.0.254.2 description CM-Access //æ·»åŠ è¯¥å¯¹ç­‰ä½“çš„æè¿°ä¿¡æ¯R2(config-bgp)#show ip bgp summary //æ£€æŸ¥BGPå¯¹ç­‰ä½“ä¹‹é—´çš„çŠ¶æ€æ˜¯å¦ä¸ºEstablishedR2(config-bgp)#neighbor 10.0.254.2 shutdown //æ£€æŸ¥æ­£å¸¸åˆ™å…ˆå…³é—­TCPè¿žæŽ¥R2(config-bgp)#exitR2(config)#ip prefix-list Private_Deny seq 5 deny 0.0.0.0/8 le 32 //åˆ›å»ºå‰ç¼€åˆ—è¡¨R2(config)#ip prefix-list Private_Deny seq 10 deny 10.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 15 deny 172.16.0.0/12 le 32 R2(config)#ip prefix-list Private_Deny seq 20 deny 192.168.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 25 deny 127.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 30 deny 169.254.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 35 deny 192.0.2.0/24 le 32 R2(config)#ip prefix-list Private_Deny seq 40 deny 224.0.0.0/3 le 32 R2(config)#ip prefix-list Private_Deny seq 45 deny 172.160.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 50 permit 0.0.0.0/0 le 32R2(config)#router bgpR2(config-bgp)#neighbor 10.0.254.2 prefix-list Private_Deny in //æ‹’ç»ç§ç½‘åœ°å€ç­‰æµå…¥R2(config-bgp)#redistribute connected //é‡åˆ†å¸ƒå‘ç›´è¿žè·¯ç”±R2(config-bgp)#redistribute static //é‡åˆ†å¸ƒå‘é™æ€è·¯ç”±R2(config-bgp)#default-information-origina //é‡åˆ†å¸ƒå‘é»˜è®¤è·¯ç”±R2(config-bgp)#no neighbor 10.0.254.2 shutdown //æ‰“å¼€BGPå¯¹ç­‰ä½“ä¹‹é—´çš„TCPè¿žæŽ¥R2(config-bgp)#show ip bgp routes //æŸ¥çœ‹ä»ŽBGPå¯¹ç­‰ä½“èŽ·å–åˆ°çš„è·¯ç”±ä¿¡æ¯R2(config-bgp)#exitR2(config)#exitR2#write-memory //ä¿å­˜é…ç½® CM-Accesså’ŒBGP-Routerä¹‹é—´çš„EBGPå»ºç«‹å¥½åŽï¼Œç›¸äº’ä¹‹é—´ä¼šè‡ªåŠ¨å­¦ä¹ è·¯ç”±ï¼Œå…¶ä»–è¿è¥å•†å¯¹æŽ¥çš„æƒ…å†µä¹Ÿå¯ä»¥è¿™æ ·æ¥åšã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯åšå¥½ä¹‹åŽï¼Œæ˜¯å¦å°±å®Œäº‹äº†å‘¢ï¼Ÿè¿™ä¸ªå¾—ä»Žéœ€æ±‚ä¸Šçœ‹ï¼Œå…¶å®žä¸»è¦åˆ†ä¸¤ç§æƒ…å†µï¼š BGP-Routerå’ŒISP-AccessåŒ…å«å•çº¿ã€å¤šçº¿åŠBGPåŠŸèƒ½ BGP-Routerå’ŒISP-Accessåªç”¨ä½œBGPçº¿è·¯ ä¸€èˆ¬è€Œè¨€ï¼Œå¯¹äºŽç¬¬äºŒç§æƒ…å†µï¼Œä¸Šè¿°çš„åšæ³•å·²ç»å®Œäº‹äº†ï¼Œä½†å¯¹äºŽä¸€å®¶ä¼ä¸šè€Œè¨€ï¼Œè®¾å¤‡çš„å¯åˆ©ç”¨æ€§å¯èƒ½æ˜¯è¶Šé«˜è¶Šå¥½çš„ï¼Œè¿™æ ·å¯¹åº”çš„æˆæœ¬å°±è¶Šä½Žï¼ˆé¢†å¯¼ï¼šèŠ‚çº¦æˆæœ¬å•Šï¼Œæˆ‘å¯éƒ½æ˜¯è¡€æ±—é’±ï¼Œ23333ï¼‰ã€‚æ‰€ä»¥ï¼Œå¦‚ä½•åŽ»å°†å•çº¿ã€å¤šçº¿åŠBGPåŠŸèƒ½å…¨éƒ¨æ‰¿è½½åœ¨è¿™ä¸ªæž¶æž„ä¸­å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨VRFï¼Œåˆ©ç”¨VRFæ¥å»ºç«‹BGPçº¿è·¯çš„EBGPè¿žæŽ¥ï¼Œè¿™æ ·å¯¹äºŽBGPä¸šåŠ¡å°±å¯ä»¥åœ¨å•ä¸ªVRFå†…å®žçŽ°äº†ï¼Œè€Œå…¶ä»–çš„ä¸šåŠ¡ä¹Ÿåœ¨ä¸åŒçš„VRFå†…å®žçŽ°å³å¯ã€‚å¦å¤–ï¼Œè€Œå¯¹äºŽå„ä¸ªISP-Accessè®¾å¤‡ï¼ŒCT-Accesså‘EBGPå†…é‡åˆ†å¸ƒé»˜è®¤è·¯ç”±ï¼Œå…¶ä»–ISP-Accesså‘EBGPé‡åˆ†å¸ƒæ˜Žç»†é™æ€è·¯ç”±ï¼ŒCT-Accesséœ€è¦æ‹’ç»ï¼ˆä½¿ç”¨ip-prefix listå®Œæˆå³å¯ï¼‰ä»ŽBGP-Routerå­¦ä¹ åˆ°çš„CMæ˜Žç»†è·¯ç”±å’ŒCUæ˜Žç»†è·¯ç”±ç­‰ï¼Œå¦åˆ™å°±ä¼šå½±å“å•çº¿åŠå¤šçº¿ä¸šåŠ¡çš„é»˜è®¤å‡ºå±€ã€‚åŒæ—¶ï¼Œä¸ºäº†ä¿è¯å•ã€å¤šçº¿ä¸šåŠ¡ï¼Œå…¶ä»–ISP-Accessä¹Ÿéƒ½éœ€è¦å†™å…¥é»˜è®¤è·¯ç”±ï¼Œä½†ä¸èƒ½é‡åˆ†å¸ƒåˆ°EBGPå†…ï¼Œé¿å…é€ æˆçŽ¯è·¯å’Œè·¯ç”±é”™ä¹±ã€‚ SummaryæŒ‰ç…§è¿™æ ·çš„æž¶æž„å®žçŽ°çš„Static BGPç»“æž„æ¯”è¾ƒç®€å•ï¼Œä¸éœ€è¦Traffic-Policyç­‰ä¹‹ç±»çš„æŠ€æœ¯æ¥é…åˆå®žçŽ°ï¼ŒæŽ§åˆ¶èµ·æ¥ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œç›´æŽ¥æ”¾é™æ€è·¯ç”±å°±å¥½ï¼Œè‡³äºŽä»ŽBGP-Routeråˆ°BGP-Accessä¹‹é—´çš„ç¨³å®šæ€§ï¼Œè¿™ä¸ªä¹Ÿå¯ä»¥ç”¨Static with BFDçš„æ–¹å¼æ¥å®žçŽ°ï¼Œæˆ–è€…çº¯ä¾é åº•å±‚ä¼ è¾“ç½‘çš„å¥å£®æ€§ã€‚ä¸è¿‡æœ‰ä¸ªé—®é¢˜åœ¨äºŽï¼Œè¿™æ ·åšå¥½ä¹‹åŽï¼ŒBGP-Routerå°±åªèƒ½ç”¨ä½œBGPåœ°å€çš„å‡ºå£ç½‘å…³è·¯ç”±å™¨äº†ï¼Œå½“ç„¶æ ¹æ®è®¾å¤‡çš„åŠŸèƒ½ç‰¹æ€§ï¼Œå¼ºè¡Œè¦ä½¿ç”¨æŸæŸåŠŸèƒ½ï¼Œä¾ç„¶å¯ä»¥ç”¨VRFç­‰å®žçŽ°ï¼Œä½†è¿™æ ·å°±ä¼šä½¿å¾—è®¾å¤‡çš„åŠŸèƒ½å˜å¾—ç¹æ‚ï¼Œåœ¨æ“ä½œçš„æ—¶ï¼Œè¯¯æ“ä½œæˆ–å…¶ä»–BUGå°±ä¼šå½±å“åˆ°æ•´ä¸ªBGPç½‘ç»œæž¶æž„çš„ç¨³å®šæ€§ã€‚å¦å¤–ï¼Œè¿™ä¸ªæž¶æž„çš„ä¼˜ç‚¹å…¶å®žå¾ˆç›´è§‚ï¼Œå°±æ˜¯ç®€å•ï¼Œæ˜“äºŽæŽ’éšœï¼ˆç½‘ç»œæž¶æž„åœ¨ä¸å¤±å¥å£®æ€§çš„åŸºç¡€ä¸‹ï¼Œè¶Šç®€å•è¶Šå¥½ï¼ŒçœŸç†å•ŠðŸ˜­ï¼‰ï¼Œå¹¶ä¸”ä¸åŒè¿è¥å•†çš„è·¯ç”±è¡¨æ˜“äºŽç»´æŠ¤ã€‚ç¼ºç‚¹å°±æ˜¯ï¼Œå¯¹åº•å±‚ä¼ è¾“ç½‘çš„ç¨³å®šæ€§è¦æ±‚æ¯”è¾ƒé«˜ã€‚ä½†æ˜¯ï¼Œå¦‚æžœæ˜¯è·¨åŒºåŸŸçš„BGPä¸šåŠ¡çš„è¯ï¼Œåˆä¼šé¢ä¸´æ–°çš„é—®é¢˜ï¼šéš¾é“æ¯ä¸ªåœ°æ–¹éƒ½æžä¸€å°BGPæ ¸å¿ƒè·¯ç”±å™¨å—ï¼Ÿé‚£åœ¨å†…ç½‘é‡Œï¼Œè¿™äº›åœ°å€åˆå¦‚ä½•äº’ç›¸è®¿é—®å‘¢ï¼Ÿ]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFDåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F29%2FBFD%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroBFDå¸¸ç”¨äºŽå¤šçº¿é™æ€è·¯ç”±çš„æ£€æµ‹å’Œè‡ªåŠ¨åˆ‡æ¢ï¼Œåœ¨æ²¡æœ‰ä½¿ç”¨å…¶ä»–åŠ¨æ€åè®®çš„æƒ…å†µä¸‹ï¼Œè‹¥ç½‘ç»œå‡ºçŽ°æ•…éšœï¼Œå¯ä»¥ä½¿ç”¨BFDè¾¾åˆ°æ•…éšœçº¿è·¯å’Œæ­£å¸¸çº¿è·¯çš„è·¯ç”±åˆ‡æ¢æ•ˆæžœã€‚å½“ç„¶ï¼ŒBFDä¾ç„¶å¯ä»¥å’Œå…¶ä»–åè®®é…åˆä½¿ç”¨ï¼ˆMPLSä¹Ÿå¯ä»¥ï¼‰ï¼Œè¿™é‡Œåªä»‹ç»BFDå’Œé™æ€è·¯ç”±çš„é…åˆä½¿ç”¨ï¼Œåœ¨ä¸åŒçš„åº”ç”¨åœºæ™¯å†…æŠŠæ¡å¥½BFDæœ¬èº«çš„ä½œç”¨æœºåˆ¶ï¼Œä»Žè€Œè¾¾åˆ°ä½¿ç”¨è€…æƒ³è¦è¾¾åˆ°çš„æ•ˆæžœå³å¯ã€‚å¦å¤–ï¼Œä¸€èˆ¬çš„åŠ¨æ€åè®®æ”¶æ•›é€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œä¸ºç§’çº§ï¼ŒBFDå¯ä»¥å°†æ”¶æ•›æ—¶é—´é™ä½Žåˆ°æ¯«ç§’çº§ã€‚ BFD Brief Descriptionä¸€èˆ¬è€Œè¨€ï¼ŒBFDéœ€è¦è®¾ç½®çš„å‚æ•°ä¸å¤šï¼Œå¤§è‡´åŒ…å«ï¼šsource ipã€destination ipã€multiplierã€min_rxã€intervalï¼Œå„ä¸ªå‚æ•°åªè¦è®¾ç½®å¥½äº†ï¼Œè®¾å¤‡ä¹‹é—´çš„BFDè¿žæŽ¥éƒ½é…ç½®OKï¼Œé‚£ä¹ˆBFDè¿žæŽ¥å°±å¯ä»¥UPäº†ã€‚ä¸åŒè®¾å¤‡å¯èƒ½å¯¹è¿™äº›åè¯çš„å«æ³•ä¸ä¸€è‡´ï¼Œä½†æ˜¯å·®ä¸å¤šéƒ½æ˜¯è¿™äº›â€œè¯â€ã€‚ Source IPBFDçš„æºIPï¼Œæœ¬ç«¯è®¾å¤‡è®¾ç½®æœ¬ç«¯IPå³å¯ã€‚ Destination IPBFDçš„ç›®çš„IPï¼Œæœ¬ç«¯è®¾å¤‡è®¾ç½®å¯¹ç«¯IPå³å¯ã€‚ Multiplierå…è®¸BFDè¿žæŽ¥æŠ¥æ–‡å¤±æ•ˆçš„æœ€å¤§ä¸ªæ•°ï¼Œä¾‹å¦‚è®¾ç½®ä¸º5ï¼Œé‚£ä¹ˆç”¨äºŽè¿™ä¸ªBFDè¿žæŽ¥çš„Control packetä¸€æ—¦å¤±æ•ˆè¶…è¿‡5ä¸ªï¼Œè¿™æ¡BFDè·¯å¾„è¿žæŽ¥å°±ä¼šdownï¼Œç±»ä¼¼pingæµ‹è¯•ä¸¢åŒ…è¶…è¿‡5ä¸ªã€‚ Min_rxBFDæ£€æµ‹æŠ¥æ–‡çš„æŽ¥æ”¶å‘¨æœŸã€‚ intervalBFDæ£€æµ‹æŠ¥æ–‡çš„å‘é€å‘¨æœŸã€‚ TipsBFDæ£€æµ‹çš„æ—¶é—´å‘¨æœŸè®¾ç½®ï¼Œæ˜¯ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ä¸œè¥¿ã€‚å‡è®¾æ€»ä½“æ€§èƒ½çš„æŒ‡æ ‡æ˜¯è¦æ±‚é“¾è·¯æ£€æµ‹ä¸Šçš„æ—¶é—´ä¸è¦è¶…è¿‡150msï¼Œè¿™æ ·å¯ä»¥è®¾ç½®BFDçš„helloæŠ¥æ–‡å‘¨æœŸä¸º50msï¼Œè¿žç»­ä¸¢å¤±3ä¸ªæŠ¥æ–‡å³è®¤ä¸ºé“¾è·¯å¤±æ•ˆã€‚å¦‚æžœæ¢ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬è®¾ç½®BFDçš„helloæŠ¥æ–‡å‘¨æœŸä¸º30msï¼Œè¿žç»­ä¸¢å¤±5ä¸ªæŠ¥æ–‡å³è®¤ä¸ºé“¾è·¯å¤±æ•ˆï¼Œè¿™æ ·å‡†ç¡®åº¦ä¼šæ›´é«˜äº›ä¸”ä¾ç„¶å¯ä»¥è¾¾åˆ°æŒ‡æ ‡ã€‚ä½†æ˜¯éœ€è¦è·¯ç”±å™¨æ”¯æŒè®¾ç½®30msè¿™ä¸ªæ—¶é—´ã€‚ BFD Connectiongä¸‹é¢å¼€å§‹é…ç½®ã€‚æ³¨ï¼šR1ä¸ºåšç§‘è®¾å¤‡ï¼ŒR2ä¸ºåŽä¸ºè®¾å¤‡ Basic Connectionåº•å±‚äº’è”é‡‡ç”¨é™æ€çš„æ–¹å¼ï¼Œç›´æŽ¥ç»™å‡ºR1å’ŒR2äº’è”çš„ä¸‰å±‚æŽ¥å£é…ç½®ã€‚R11234!interface ve 925 ip address 10.0.254.1/30! R21234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# BFD ConfigæŽ¥ä¸‹æ¥å¼€å§‹é…ç½®BFDã€‚R1123456R1#configure terminalR1(config)#interface ve 925R1(config-vif-ve-925)#bfd interval 500 min-rx 500 multiplier 5 //è®¾ç½®å‚æ•°R1(config-vif-ve-925)#exitR1(config)#ip route static-bfd 10.0.254.2 10.0.254.1 //å¼€å¯bfdR1(config)#ip route 192.168.1.0/24 10.0.254.2 bfd //ä¸ºé™æ€è·¯ç”±ç»‘å®šbfd R21234567&lt;R2&gt;system-view[R2]bfd to-r1 bind peer-ip 10.0.254.1 interface vlanif925 source-ip 10.0.254.1 auto //è®¾ç½®bfd[R2-bfd-session-to-r1]detect-multiplier 5 //è®¾ç½®å‚æ•°[R2-bfd-session-to-r1]min-tx-interval 500[R2-bfd-session-to-r1]min-rx-interval 500[R2-bfd-session-to-r1]quit[R2]ip route-static 192.168.2.0 24 10.0.254.1 track bfd-session to-r1 //ä¸ºé™æ€è·¯ç”±ç»‘å®šbfd é…ç½®å¥½äº†ä¹‹åŽï¼ŒBFDå°±æ­£å¼å¯åŠ¨äº†ï¼Œå¹¶ä¸”æ­¤æ—¶R1è®¿é—®192.168.1.0/24ç½‘æ®µçš„è·¯ç”±æ˜¯ä¸ŽR1å’ŒR2ä¹‹é—´çš„BFDç»‘å®šåœ¨ä¸€èµ·çš„ï¼ŒR2è®¿é—®192.168.2.0/24ç½‘æ®µçš„è·¯ç”±ä¹Ÿæ˜¯ä¸ŽR1å’ŒR2ä¹‹é—´çš„BFDç»‘å®šåœ¨ä¸€èµ·çš„ã€‚ ManagementR1å¯ä»¥ä½¿ç”¨show bfd neighborså‘½ä»¤æ¥æ£€æŸ¥BFDè¿žæŽ¥æ˜¯å¦æ­£å¸¸ï¼›R2å¯ä»¥ä½¿ç”¨display bfd session allæ¥æ£€æŸ¥BFDè¿žæŽ¥æ˜¯å¦æ­£å¸¸ï¼›å½“ç„¶äº†ï¼Œä¸åŒè®¾å¤‡è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç®€æ·å‘½ä»¤æ¥æ–¹ä¾¿ç®¡ç†ã€‚é…åˆä½¿ç”¨éœ€è¦æŸ¥è®¾å¤‡çš„æ‰‹å†Œï¼Œä½†æ˜¯éœ€è¦è®¾ç½®çš„å‚æ•°æ˜¯ä¸€æ ·çš„ï¼Œè¿™å°±å¾ˆNICEäº†ã€‚æ‰€ä»¥ï¼Œä¸ç®¡åŠ¨æ€åè®®æ˜¯å•¥ï¼Œä½¿ç”¨BFDå®žçŽ°çš„åŠŸèƒ½æ˜¯ä¸Žå…¶ä»–ä¸ç›¸å…³çš„ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPLSåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F27%2FMPLS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroMPLSï¼ŒMulti-Protocol Label Switchingï¼Œå…¨ç§°å¤šåè®®æ ‡è®°äº¤æ¢ï¼Œæ˜¯ä¸€ç§æ ‡è®°æœºåˆ¶çš„åŒ…äº¤æ¢æŠ€æœ¯ï¼Œé€šè¿‡ç®€å•çš„2å±‚äº¤æ¢æ¥é›†æˆIP Routingçš„æŽ§åˆ¶ã€‚MPLSç©¶ç«Ÿæ˜¯ä¸æ˜¯è·¯ç”±åè®®ï¼Œç©¶ç«Ÿå·¥ä½œåœ¨ç¬¬å‡ å±‚ï¼Œåœ¨è¿™é‡Œï¼Œä¸åšæŽ¢è®¨ï¼Œä»¥ä¸‹å†…å®¹åªä»‹ç»å…¶åŸºç¡€çš„é…ç½®ï¼Œå¹¶è¡”æŽ¥ISISåŸºç¡€é…ç½®è¿™ç¯‡æ–‡ç« ã€‚ ä»¥ä¸‹é…ç½®å‘½è¿˜æ˜¯ä»¥åšç§‘è®¾å¤‡ä¸ºä¾‹ Network Informationè´´å‡ºR1å’ŒR2çš„éƒ¨åˆ†é…ç½®ä¿¡æ¯ååŠ©æž„å»ºISIS + MPLSã€‚R1123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.10/30!interface ve 922 ip router isis ip address 10.0.254.14/30!!interface loopback 1 ip router isis ip address 169.254.254.1/32!ip router-id 169.254.254.1!router isis net 49.0001.0000.0000.1000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! R2123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.9/30!interface ve 922 ip router isis ip address 10.0.254.13/30!!interface loopback 1 ip router isis ip address 169.254.254.2/32!ip router-id 169.254.254.2!router isis net 49.0002.0000.0000.2000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! MPLS Brief Descriptionç®€è¦è¯´æ˜Žä¸€ä¸‹MPLSä¸­çš„æŸäº›ç»„æˆéƒ¨åˆ†ï¼Œå…¶ä½™çš„éƒ¨åˆ†ä¸åœ¨èµ˜è¿°äº†ðŸ˜´ã€‚ Network Componentså°±åƒBGPå¯¹ç­‰ä½“ä¸€æ ·ï¼ŒMPLSå†…ä¹ŸåŒ…å«ä¸€äº›æ¦‚å¿µï¼Œä¾æ¬¡å¦‚ä¸‹ï¼š Pç½‘ç»œï¼šæä¾›å•†ç½‘ç»œPè·¯ç”±å™¨ï¼šéƒ¨ç½²MPLS/IPç½‘ç»œçŽ¯å¢ƒçš„è·¯ç”±å™¨PEè·¯ç”±å™¨ï¼šæä¾›å•†ç½‘ç»œçš„è¾¹ç•Œè·¯ç”±å™¨ï¼Œæä¾›VPNç»ˆç«¯å®¢æˆ·è¿žæŽ¥å’ŒæœåŠ¡CEè·¯ç”±å™¨ï¼šå®¢æˆ·çš„è·¯ç”±å™¨ï¼Œç”¨åšå®¢æˆ·ç½‘ç»œå’Œæä¾›å•†ç½‘ç»œä¹‹é—´çš„ç½‘å…³Cç½‘ç»œï¼šå®¢æˆ·çš„ç½‘ç»œ MPLS-Interfaceç”¨äºŽå»ºç«‹pathçš„ä¸‰å±‚æŽ¥å£ï¼Œæ³¨æ„ï¼Œæ˜¯ä¸‰å±‚æŽ¥å£ã€‚ LSPLSP, Label Switched Pathï¼Œæ ‡ç­¾äº¤æ¢è·¯å¾„ï¼Œå³åˆ°è¾¾åŒä¸€ç›®çš„åœ°å€çš„æŠ¥æ–‡åœ¨MPLSç½‘ç»œä¸­ç»è¿‡çš„è·¯å¾„ã€‚è¿™çŽ©æ„ï¼Œå°±æ˜¯æµé‡çš„â€œæ–¹å‘â€äº†ã€‚ LDPLDP, Label Distribution Protocolï¼Œæ ‡ç­¾åˆ†å‘åè®®ï¼Œè¿™çŽ©æ„æ˜¯è·¯ç”±å™¨åœ¨æž„å»ºMPLSæ ‡ç­¾è½¬å‘è¡¨æ—¶éµå®ˆçš„è§„åˆ™ï¼ŒMPLSçš„æ ‡ç­¾è½¬å‘è¡¨çš„å»ºç«‹å°±æ˜¯é è¿™çŽ©æ„ã€‚ VPLSVPLSï¼ŒVirtual Private Lan Serviceï¼Œè¿™çŽ©æ„å…¶å®žå¹¶åªæ˜¯MPLSæ‰€æœ‰çš„ä¸œè¥¿ï¼ŒæŒ‰ç…§ä¸åŒçš„ä¿¡ä»¤åè®®ï¼Œä¹Ÿæœ‰ä¸åŒçš„åº”ç”¨æ–¹æ³•ï¼ˆBGP-l2vpnï¼‰ï¼Œè¿™é‡Œæ‰€ä»‹ç»çš„VPLSæœ¬è´¨ä¸Šæ˜¯åŸºäºŽIP/MPLSçš„L2VPNæŠ€æœ¯ï¼ˆå…¶å®žæ˜¯çŽ°åœ¨ç”¨çš„æœ€å¤šçš„ä¹Ÿå°±æ˜¯MPLSä¸‹çš„VPLSäº†ðŸ˜‚ï¼‰ã€‚ä¸è¿‡ï¼Œè¿™çŽ©æ„è¿˜æœ‰ä¸ªæ›´åŠ é€šä¿—çš„ç†è§£æ–¹å¼ï¼Œé‚£å°±æ˜¯è¿è¥å•†ç»™å®¢æˆ·çš„â€œä¸šåŠ¡ç½‘â€ã€‚ MPLS Configæƒ³è¦MPLSèƒ½æ­£å¸¸ä½¿ç”¨ï¼Œéœ€è¦åšçš„è·¯ç”±å™¨é…ç½®å…¶å®žå¹¶ä¸æ˜¯å¾ˆå¤šï¼Œå¤§ä½“ä¸Šå°±åŒ…æ‹¬ï¼šmpls-interfaceã€pathå’Œlspè¿™äº›ã€‚ä»¥ä¸‹çš„é…ç½®æ­¥éª¤å¯ä½œä¸ºå‚è€ƒï¼šR11234567891011121314151617181920212223242526272829R1#configure terminalR1(config)#router mpls //å¯ç”¨mplsR1(config-mpls)#ldp //è¿›å…¥ldpåè®®R1(config-mpls-ldp)#load-sharing 8 //è®¾ç½®lspçš„èƒ½æ”¯æŒçš„æœ€å¤§è·¯å¾„æ¡æ•°ä¸º8R1(config-mpls-ldp)#exitR1(config-mpls)#path To-R2-1 //åˆ›å»ºpathR1(config-mpls-path-To-R2-1)#strict 10.0.254.9 //æŒ‡å®šè¿™æ¡è·¯å¾„çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯10.0.254.9R1(config-mpls-path-To-R2-1)#exitR1(config-mpls)#path To-R2-2R1(config-mpls-path-To-R2-2)#strict 10.0.254.13R1(config-mpls-path-To-R2-2)#exitR1(config-mpls)#mpls-interface ve921 //å°†ve 921è¿™ä¸ªä¸‰å±‚æŽ¥å£å¯ç”¨åˆ°mplsä¸­R1(config-mpls-if-ve-921)#ldp-enable //å¼€å¯æ­¤æŽ¥å£ldpåŠŸèƒ½R1(config-mpls-if-ve-921)#exitR1(config-mpls)#mpls-interface ve922R1(config-mpls-if-ve-922)#ldp-enableR1(config-mpls-if-ve-922)#exitR1(config-mpls)#lsp To-R2-1 //åˆ›å»ºæ ‡ç­¾è½¬å‘è·¯å¾„R1(config-mpls-lsp-To-R2-1)#to 169.254.254.2 //è®¾ç½®æ ‡ç­¾è½¬å‘è·¯å¾„çš„å‡ºå£è·¯ç”±å™¨åœ°å€R1(config-mpls-lsp-To-R2-1)#primary-path To-R2-1 //è®¾ç½®ä¸»è·¯å¾„R1(config-mpls-lsp-To-R2-1)#secondary-path To-R2-2R1(config-mpls-lsp-To-R2-1)#enableR1(config-mpls-lsp-To-R2-1)#lsp To-R2-2R1(config-mpls-lsp-To-R2-2)#to 169.254.254.2R1(config-mpls-lsp-To-R2-2)#primary-path To-R2-2R1(config-mpls-lsp-To-R2-2)#secondary-path To-R2-1R1(config-mpls-lsp-To-R2-2)#enableR1(config-mpls-lsp-To-R2-2)#exitR1(config-mpls)#write memory R21234567891011121314151617181920R2#configure terminalR2(config)#router mplsR2(config-mpls)#path To-R1-1R2(config-mpls-path-To-R1-1)#strict 10.0.254.10R2(config-mpls-path-To-R1-1)#path To-R1-2R2(config-mpls-path-To-R1-2)#strict 10.0.254.14R2(config-mpls-path-To-R1-2)#exitR2(config-mpls)#lsp To-R1-1R2(config-mpls-lsp-To-R1-1)#to 169.254.254.1R2(config-mpls-lsp-To-R1-1)#primary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#enableR2(config-mpls-lsp-To-R1-1)#lsp To-R1-2R2(config-mpls-lsp-To-R1-2)#to 169.254.254.1R2(config-mpls-lsp-To-R1-2)#primary-path To-R1-2R2(config-mpls-lsp-To-R1-2)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-2)#enableR2(config-mpls-lsp-To-R1-2)#exitR2(config-mpls)#exitR2(config)#write memory ä¸Šé¢è´´å‡ºçš„æ˜¯å®Œæ•´çš„é…ç½®è¿‡ç¨‹ï¼Œä½†æ˜¯å®žé™…ä¸Šä¸¤å°è®¾å¤‡çš„é…ç½®é¡ºåºæ˜¯äººä¸ºè‡ªå®šçš„ï¼Œä¸è¿‡éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œä¸€æ—¦åˆ›å»ºäº†pathï¼Œä½¿ç”¨show mpls routeså‘½ä»¤æ—¶ï¼Œå°±å¯ä»¥çœ‹åˆ°mplsçš„æ ‡ç­¾è½¬å‘è¡¨äº†ã€‚å…¶æ¬¡ï¼Œåˆ›å»ºlspæ—¶å¯ä»¥ä¸æŒ‡å®šprimary-pathå’Œsecondary-pathï¼Œæ­¤æ—¶lspä¼šé»˜è®¤ä½¿ç”¨mplså†…å­˜åœ¨ä¸”upçš„pathï¼ˆå·²è¿žæŽ¥çš„è·¯å¾„ï¼‰ï¼Œå¹¶ä¸”lspä¸€æ—¦åˆ›å»ºåŽè®¾å¤‡ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªtunnelç”¨äºŽä¼ è¾“æ•°æ®ï¼Œè¿™ä¸ªå¯ä»¥ä¸ç”¨ç®¡ï¼›ä¹‹æ‰€ä»¥åˆ›å»ºprimary-pathå’Œsecondary-pathï¼Œå®žè´¨ä¸Šæ˜¯ä¸ºäº†æ‰‹åŠ¨è°ƒåº¦æµé‡æ¯”è¾ƒæ–¹ä¾¿ã€‚å¦å¤–ï¼Œåœ¨ä¿®æ”¹lspæ—¶ï¼Œå¿…é¡»è¦å…ˆdisableè¿™æ¡lspï¼ˆå…ˆå…³é—­è¿™æ¡è·¯å¾„ï¼‰æ‰å¯ä»¥è¿›è¡Œä¿®æ”¹ï¼ˆåšç§‘çš„è®¾å¤‡æ˜¯è¿™æ ·ï¼‰ã€‚è¿˜æœ‰ï¼Œä½¿ç”¨router-idæ¥ä½œä¸ºå‡ºå£PEè·¯ç”±å™¨çš„åœ°å€ï¼Œååˆ†æ–¹ä¾¿ã€‚å½“ç„¶äº†ï¼Œä¸åŒåŽ‚å•†è®¾æ‰€æ”¯æŒçš„MPLSæ‰©å±•åŠŸèƒ½å¯èƒ½ä¸ä¸€æ ·çš„ï¼ˆåŽ‚å•†ç‰¹è‰²ï¼Œ23333ï¼‰ï¼Œä½†æ˜¯åŸºæœ¬ä¸Šéƒ½æ˜¯ä¸€æ ·çš„ã€‚ VPLSMPLSç½‘ç»œæž„å»ºå¥½äº†ä¹‹åŽï¼Œåˆ›å»ºVPLSå°±å¾ˆç®€å•å•¦ã€‚å¯ä»¥æŒ‰ç…§ä¸‹é¢çš„è„šæœ¬è¿›è¡Œæ‰§è¡Œã€‚R112345678910R1#configure terminalR1(config)#router mpls //è¿›å…¥mplsåè®®R1(config)#vpls Test911 911 //åˆ›å»ºvplsR1(config-mpls-vpls-Test911)#vpls-peer 169.254.254.2 load-balance //æ·»åŠ vpls peerR1(config-mpls-vpls-Test911)#vlan 911 //åˆ›å»ºvpls vlanR1(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/x //é€ä¼ åˆ°æ±‡èšç«¯å£R1(config-mpls-vpls-Test911-vlan-911)#exitR1(config-mpls-vpls-Test911)#exitR1(config-mpls)#exitR1(config)#write memory //ä¿å­˜é…ç½® R212345678910R2#configure terminalR2(config)#router mplsR2(config)#vpls Test911 911R2(config-mpls-vpls-Test911)#vpls-peer 169.254.254.1R2(config-mpls-vpls-Test911)#vlan 911R2(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/xR2(config-mpls-vpls-Test911-vlan-911)#exitR2(config-mpls-vpls-Test911)#exitR2(config-mpls)#exitR2(config)#write memory åˆ›å»ºå¥½äº†ä¹‹åŽï¼Œå¯ä»¥ä½¿ç”¨show mpls vplsæ¥æŸ¥çœ‹vpls peeræ˜¯å¦upï¼Œå¦‚æžœupï¼Œåˆ™åˆ›å»ºæˆåŠŸï¼Œåä¹‹ï¼Œåˆ™ä¸æˆåŠŸï¼Œéœ€è¦æ£€æŸ¥é…ç½®ã€‚ Summaryæ€»çš„æ¥è¯´ï¼ŒMPLSå’ŒVPLSçš„åˆ›å»ºè¿˜æ˜¯ååˆ†ç®€å•çš„ï¼Œéš¾ç‚¹åœ¨äºŽï¼Œéª¨å¹²ç½‘èŠ‚ç‚¹è¿‡å¤šçš„ç½‘ç»œçŽ¯å¢ƒä¸­ï¼Œå®žçŽ°MPLSçš„æµé‡è°ƒåº¦å·¥ç¨‹ï¼Œåšè¿™ä¸ªäº‹æƒ…ä¸€å®šè¦æ€è·¯æ¸…æ™°æ‰è¡Œã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISISåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F27%2FISIS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroISISä¹Ÿæ˜¯IGPè·¯ç”±åè®®æ—ä¸­ä¸€å‘˜ï¼Œä¸ŽOSPFååˆ†ç±»ä¼¼ï¼ŒOSPFä¸»è¦ç”¨äºŽå›­åŒºç½‘ï¼ŒISISä¸»è¦ç”¨äºŽéª¨å¹²ç½‘ã€‚æ³¨ï¼šæœ¬æ–‡å†…æ‰€æœ‰å‘½ä»¤ï¼Œå‡å·²åšç§‘è®¾å¤‡(ä¸ŽCiscoç±»ä¼¼)ä¸ºä¾‹ã€‚ ISIS Brief Descriptionç®€çŸ­è¯´æ˜Žä¸€ä¸‹ï¼ŒISISä¸­çš„ä¸€äº›éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œå¯èƒ½ä¸æ¸…æ™°å’Œå®Œå…¨ï¼Œæ¬¢è¿Žä¸€èµ·äº¤æµã€‚ ISIS NETæç¤ºï¼šè¿™éƒ¨åˆ†å†…å®¹ä¸è¦æ·±ç©¶ðŸ¤£ï¼Œä¸çŸ¥é“ä¸ºå•¥ä¼šè¿™ä¹ˆå†—æ‚ï¼Œå¯èƒ½æ˜¯å› ä¸ºISISæ˜¯ä¸ºOSIè®¾è®¡çš„ï¼Œè€ŒOSIç”¨çš„æ˜¯NSAPæ ¼å¼çš„åœ°å€å§ï¼ŒXDï¼Œå»ºè®®ç‚¹å¼€é“¾æŽ¥ç»“åˆå›¾ç‰‡ä¸€èµ·çœ‹ã€‚ ISISçš„NET(ç½‘ç»œå®žä½“å)é‡‡ç”¨çš„æ ¼å¼ä¸€ç§å«åšNSAPçš„â€œæ ¼å¼â€(Network Service Access Point)ï¼Œå…¶å½¢å¼æœ‰ç‚¹åƒIPåœ°å€åŠ ç«¯å£å·çš„å½¢å¼ï¼Œå¦‚:169.254.254.1:80ï¼Œä»¥NETä¸º49.0001.0000.0000.0001.00ä¸ºä¾‹ï¼Œ49.0001æ˜¯Area IDï¼Œé•¿åº¦å¯å˜ï¼›0000.0000.0001æ˜¯System IDï¼Œé•¿åº¦ä¸å˜ï¼›00æ˜¯N-SELï¼Œé•¿åº¦ä¸å˜ï¼Œè¿™ä¸ªç±»ä¼¼äºŽTCP/IPä¸­çš„ç«¯å£ã€‚ å¦‚æžœæ¢ä¸€ç§æ ‡è¯†çš„æ–¹æ³•ï¼Œé‚£ä¹ˆ49å°±æ˜¯IDPï¼Œç”¨AFIå’ŒIDIæ¥æ ‡è¯†ï¼›0001å°±æ˜¯Areaï¼ŒSystem IDå’ŒN-SELä¸å˜ï¼Œæ­¤æ—¶ï¼ŒAreaã€System IDå’ŒN-SELåˆç§°ä¸ºDSPã€‚ æ³¨ï¼šå¯¹äºŽåŒä¸€å°è·¯ç”±å™¨è€Œè¨€ï¼Œåœ¨æœ‰å¤šä¸ªISIS Areaè¿žæŽ¥çš„æƒ…å†µä¸‹ï¼ŒArea IDä¸åŒï¼Œä½†æ˜¯System IDå¿…é¡»ç›¸åŒå¯¹äºŽä¸åŒè·¯ç”±å™¨è€Œè¨€ï¼ŒSystem IDä¸€å®šä¸èƒ½ç›¸åŒä¸åŒè·¯ç”±å™¨çš„domainè¦ç›¸åŒï¼Œè¿™æ ·ISISæ‰å¯ä»¥äº’è”å¸¸ç”¨çš„NETè®¾ç½®ä¸ºï¼š49.0001.0000.0000.1000.00ï¼Œè¿™ä¸ªç®—æ˜¯æœ€çŸ­ä¸”ç¬¦åˆè¦æ±‚çš„é•¿åº¦äº† ISIS RoutingISISçš„è·¯ç”±èŽ·å–æ–¹å¼ä¸ŽOSPFæ˜¯ååˆ†ç±»ä¼¼çš„ï¼ŒåŒ…å«IPåœ°å€çš„å‘å¸ƒã€é™æ€è·¯ç”±çš„å¯¼å…¥ã€è·¯ç”±çš„é‡åˆ†é…ç­‰ç­‰ï¼Œä½†ISISçš„è·¯ç”±æ˜¯æ‹¥æœ‰Levelï¼ˆè·¯ç”±ç­‰çº§ï¼‰è¿™ä¸ªå±žæ€§çš„ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œå·¥ä¸šä¸Šä½¿ç”¨çš„è®¾å¤‡éƒ½æ˜¯æ˜¯æ”¯æŒLevel 1/2ï¼ˆè·¯ç”±ç­‰çº§ä¸º1æˆ–2ï¼‰çš„è·¯ç”±ï¼Œä½†è¿™ä¸ªå®žé™…ä¸Šæ˜¯å¯ä»¥è®¾ç½®çš„ï¼ˆè®¾å¤‡å¯ä»¥è®¾ç½®å¯¹ç‰¹å®šç­‰çº§è·¯ç”±ä¸åŠ è¡¨ï¼‰ã€‚å¦å¤–ï¼Œéª¨å¹²ç½‘ä¸Šä½¿ç”¨çš„ISISå…¶å®žåªå‚ä¸Žäº†ä¸åŒæœºæˆ¿çš„æ ¸å¿ƒè·¯ç”±å™¨ä¹‹é—´çš„äº’è”ï¼Œå¹¶æ²¡æœ‰é€šè¿‡ISISè·¨æœºæˆ¿ä¼ é€’æœ¬åœ°çš„IPè·¯ç”±ä¿¡æ¯ï¼Œè€Œè¿™éƒ¨åˆ†åŠŸèƒ½æ˜¯é€šè¿‡MPLSæ¥å®Œæˆçš„ï¼Œå½“ç„¶MPLSçš„æž„å»ºä¹Ÿå¯ä»¥å’Œå…¶ä»–çš„åŠ¨æ€è·¯ç”±åè®®é…åˆå®Œæˆã€‚ä¸åŒç­‰çº§çš„è·¯ç”±ç‰¹æ€§å¦‚ä¸‹ï¼šLevel 1Level 2åªèƒ½å…è®¸åœ¨ä¸€ä¸ªareaå†…è·¯ç”±å…è®¸åœ¨ä¸€ä¸ªdomainå†…è·¯ç”±ï¼Œåªå«Level 1çš„è·¯ç”±å™¨è‹¥è¦åˆ°è¾¾å¦å¤–ä¸€ä¸ªareaï¼Œéœ€è¦è½¬å‘åˆ°ç¦»å®ƒâ€œæœ€è¿‘â€çš„å«Level 2è·¯ç”±çš„è·¯ç”±å™¨ã€‚ä¸‹é¢ä»‹ç»çš„å†…å®¹æ˜¯åˆ©ç”¨ISISæ¥æž„å»ºéª¨å¹²ç½‘çš„å®žè·µåœºæ™¯ã€‚ Basic Connetionä¸ŽOSPFçš„é…ç½®ç±»ä¼¼ï¼ŒISISçš„é…ç½®ä¾ç„¶éœ€è¦å…ˆåœ¨ä¸¤å°è®¾å¤‡ä¸Šé…ç½®å¥½é™æ€äº’è”IPã€‚æœ¬æ¬¡å®žéªŒé‡‡ç”¨vlan 921å’Œvlan 922æ¥ä½œä¸ºä¸¤å°è®¾å¤‡çš„äº’è”vlanï¼Œä½¿ç”¨10.0.254.8/30å’Œ10.0.254.12/30ä½œä¸ºä¸¤å¯¹äº’è”IP(ä¸¤æ¡çº¿è·¯)ã€‚é…ç½®å¥½åŽçš„éƒ¨åˆ†é…ç½®å¦‚ä¸‹ï¼šR21234567!interface ve 921 ip address 10.0.254.9/30!interface ve 922 ip address 10.0.254.13/30! R11234567!interface ve 921 ip address 10.0.254.10/30!interface ve 922 ip address 10.0.254.14/30! è®¾å¤‡ä¹‹é—´çš„vlané€ä¼ ï¼Œè‡ªå·±åŽ»ä¼ å§ï¼Œæ³¨æ„åˆ«æˆçŽ¯äº†å°±è¡Œã€‚é…ç½®å¥½äº†ä¹‹åŽï¼Œæµ‹è¯•ä¸€ä¸‹ã€‚R2#12ping 10.0.254.10 source 10.0.254.9ping 10.0.254.13 source 10.0.254.14 R1#12ping 10.0.254.9 source 10.0.254.10ping 10.0.254.13 source 10.0.254.14 ISIS Configä¸‹é¢ä»‹ç»ISISç›¸å…³çš„é…ç½®ï¼Œä¸åŒåŽ‚å•†çš„å‘½ä»¤å’Œå¼€å¯æ–¹å¼å¯èƒ½ä¸ä¸€æ ·ï¼Œä½†å¤§éƒ¨åˆ†åŠŸèƒ½æ˜¯ä¸€è‡´çš„ã€‚æŒ‰ç…§ä»¥ä¸‹çš„è„šæœ¬æ¥é…ç½®å³å¯ï¼šR112345678910111213141516R1#configure terminalR1(config)#router isis //è¿›å…¥isisåè®®ï¼Œè¿›å…¥åŽï¼Œä¼šæç¤ºå…ˆè®¾ç½®netR1(config-isis-router)#net 49.0001.0000.0000.1000.00 //è®¾ç½®netR1(config-isis-router-ipv4u)#address-family ipv4 unicast //å¼€å¯isisçš„ipv4å•æ’­åŠŸèƒ½R1(config-isis-router-ipv4u)#maximum-paths 8 //è®¾ç½®æœ€å¤§è·¯å¾„ï¼Œä¸åŒè®¾å¤‡ä¸ä¸€è‡´R1(config-isis-router-ipv4u)#exit //é€€å‡ºR1(config)#ip router-id 169.254.254.1 //è®¾ç½®router-idR1(config)#interface loopback 1 //è¿›å…¥çŽ¯å›žæŽ¥å£R1(config-lbif-1)#ip address 169.254.254.1/32 //è®¾ç½®çŽ¯å›žæŽ¥å£IPä¸ºrouter-idR1(config-lbif-1)#ip router isis //å¼€å¯isisåŠŸèƒ½R1(config-lbif-1)#interface ve 921 //è¿›å…¥ä¸‰å±‚è™šæ‹ŸæŽ¥å£R1(config-vif-921)#ip router isisR1(config-vif-921)#interface ve 922R1(config-vif-922)#ip router isisR1(config-vif-922)#exitR1(config)#write memory R2è·¯ç”±å™¨çš„é…ç½®è¿‡ç¨‹ä¸ŽR1æ˜¯ç›¸ä¼¼çš„ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒR2çš„netå°†è®¾ç½®ä¸º49.0002.0000.0000.2000.00ï¼Œrouter-idå°†è®¾ç½®ä¸º169.254.254.2ï¼Œå¯¹åº”çš„çŽ¯å›žåœ°å€æŽ¥å£çš„IPè®¾ç½®ä¸º169.254.254.2/32ã€‚è®¾ç½®å¥½åŽæ‰§è¡Œå‘½ä»¤show isis routesæ¥æ£€æŸ¥ISISæ˜¯å¦æ­£å¸¸å­¦ä¹ è·¯ç”±ã€‚R1/R212R1#show isis routesR2#show isis routes æŒ‰ç…§ä¹‹å‰çš„é…ç½®æ€è·¯ï¼Œæ­¤æ—¶å¯ä»¥åœ¨R2ä¸­çœ‹åˆ°ä»¥ä¸‹è·¯ç”±ä¿¡æ¯ï¼šR112345678910111213Total number of IS-IS routes: 3Destination Mask Cost Type Tag Flags10.0.254.8 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 10.0.254.12 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 169.254.254.1 255.255.255.255 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 å¯¹åº”çš„R1ä¹Ÿä¼šæœ‰ç±»ä¼¼çš„è·¯ç”±ä¿¡æ¯ï¼Œè¿™é‡Œä¸åœ¨èµ˜è¿°äº†ã€‚ Summaryåˆ°è¿™é‡Œï¼ŒR1å’ŒR2ä¹‹é—´çš„ISISäº’è”å°±å»ºç«‹å¥½äº†ï¼Œä¹Ÿå°±æ˜¯è¯´éª¨å¹²ç½‘çŽ°åœ¨å·²ç»å»ºç«‹å¥½äº†ï¼ŒçŽ°åœ¨å°±å¯ä»¥åœ¨ISISä¹‹ä¸Šåœ¨æ¥æž„å»ºå…¶ä»–çš„ç½‘ç»œé…ç½®äº†ã€‚æ•´ä¸ªè¿‡ç¨‹ï¼Œä¸ŽOSPFçš„åŸºç¡€æž„å»ºè¿‡ç¨‹å¾ˆç±»ä¼¼ï¼Œå¤§éƒ¨åˆ†åŠ¨æ€è·¯ç”±åè®®éƒ½æ”¯æŒç”¨å¯†é’¥çš„æ–¹å¼æ¥å…è®¸å»ºç«‹è¿žæŽ¥ï¼ŒISISä¹Ÿä¸ä¾‹å¤–çš„ï¼Œä½†éœ€è¦è®¾å¤‡æ”¯æŒä¸”é€šä¿¡åŒæ–¹éƒ½å·²çŸ¥å¯†é’¥ï¼Œå½“ç„¶ï¼ŒBFDä¾ç„¶å¯ä»¥ç”¨åœ¨ISISä¸­ï¼ˆåˆç†ç»“åˆä½¿ç”¨ä¼šä½¿å¾—ISISçš„è·¯ç”±æ”¶æ•›é€Ÿåº¦æ›´å¿«ï¼‰ï¼Œä½†è¿™éœ€è¦è®¾å¤‡æ”¯æŒï¼Œå¹¶ä¸”è¦æŸ¥é˜…è®¾å¤‡æ‰‹å†Œï¼Œæ‰¾åˆ°å…¶å…·ä½“é…ç½®æ–¹æ³•ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brocade VDX VCSé…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F19%2FBrocade-VDX-VCS%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroductionVCSå…¨ç§°å«åšVCSçŸ©é˜µéƒ¨ç½²æ¨¡å¼ï¼Œæ˜¯å°†å¤šå°VDXç³»åˆ—ä»»æ„åž‹å·çš„ç‰©ç†äº¤æ¢æœºè®¾å¤‡é€šè¿‡ä¸‡å…†æˆ–è€…40Gä»»æ„æ‹“æ‰‘äº’è”å½¢æˆä¸€ä¸ªçŸ©é˜µï¼Œè¿›è¡Œç»Ÿä¸€é…ç½®ã€ç®¡ç†ã€ç›‘æŽ§(å¥—è¯)ã€‚æ³¨æ„ï¼š åªèƒ½ç”¨10Gæˆ–è€…40Gé“¾è·¯å®žçŽ°ï¼Œä¹Ÿå°±æ˜¯è¯´åªèƒ½ç”¨ç‰©ç†æŽ¥å£ï¼ˆport-channgelå¯ä»¥è¯•è¯•ï¼‰åŽ»å®žçŽ°ï¼Œä½†æ˜¯å¥½åœ¨å¯ä»¥ä½¿ç”¨å¤šæ¡10Gé“¾è·¯ï¼Œä¸”æµé‡æ˜¯è´Ÿè½½å‡è¡¡çš„ã€‚ æ‰€æœ‰ç‰©ç†äº¤æ¢æœºçš„è½¯ä»¶(å°±æ˜¯ç³»ç»Ÿç‰ˆæœ¬)å¿…é¡»ä¸€è‡´ éœ€æ‰‹åŠ¨è®¾å®šVCSé›†ç¾¤çš„IPå·ç ï¼Œé›†ç¾¤å”¯ä¸€çš„ç¼–å·ï¼Œä»Ž1-8192 éœ€æ‰‹åŠ¨è®¾å®šVCSé›†ç¾¤å†…éƒ¨ç‰©ç†äº¤æ¢æœºrbridge-idç¼–å·ï¼Œï¼Œè¯¥ç¼–å·å”¯ä¸€ï¼Œä»Ž1-239 éƒ¨ç½²å®ŒVCSé…ç½®åŽä¼šæ¸…ç©ºç‰©ç†äº¤æ¢æœºå†…éƒ¨å·²æœ‰çš„é…ç½® Configurationä¸‹é¢ä»‹ç»å¤§è‡´é…ç½®ã€‚ Physical Interfaceç‰©ç†æŽ¥å£çš„é…ç½®åŸºæœ¬éƒ½æ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥ä»¥ä¸€ä¸ªç«¯å£ä¸ºä¾‹å³å¯ã€‚1234567#interface TenGigabitEthernet 1/0/1 des xxxx //æè¿°ä¿¡æ¯ fabric isl enable //è®¾ç½®ç§°ä¸ºVCSçš„fabric isl port fabric trunk enable //è®¾ç½®ç«¯å£çš„æ¨¡å¼ä¸ºtrunk no shutdown //å¼€å¯ç«¯å£# è‹¥ä¸æƒ³è®¾ç½®æ­¤æŽ¥å£ä¸ºVCSçŸ©é˜µäº’è”çš„ISLæŽ¥å£ï¼Œéœ€è¦é…ç½®ä»¥ä¸‹å‘½ä»¤åœ¨æŽ¥å£ä¸Šï¼š12fabric neighbor-discovery disableno fabric isl enable æ£€æŸ¥äº’è”ç«¯å£æ­£å¸¸ä¹‹åŽï¼Œå³å¯ä»¥å¼€å§‹ä¸‹ä¸€æ­¥æ“ä½œã€‚ Set VCS Cluster Numberåˆ©ç”¨consoleå£è¿›å…¥åˆ°æ¯å°VDXåŽï¼Œæ‰§è¡Œå‘½ä»¤ï¼švcs vcsid X rbridge-id Y logical-chassis enableXä»£è¡¨VCSé›†ç¾¤IDç¼–å·ï¼Œæ˜¯æ•´ä¸ªé›†ç¾¤å†…éƒ¨å”¯ä¸€çš„ç¼–å·ï¼›Yä»£è¡¨VCSé›†ç¾¤å†…éƒ¨æ¯ä¸€å°VDXäº¤æ¢æœºçš„ç¼–å·ï¼Œä¹Ÿå°±æ˜¯rbridge-idï¼Œç”¨äºŽæ ‡è¯†é›†ç¾¤å†…éƒ¨æ¯ä¸€å°VDXäº¤æ¢æœºï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä½œä¸ºæŽ¥å£ç¼–å·çš„ç¬¬ä¸€ä½ï¼Œæ¯”å¦‚TenGigabitEthernet 1/0/1ä¸­çš„1å°±æ˜¯rbridge-id 1ï¼ŒåŽé¢çš„1å°±æ˜¯ç¬¬ä¸€ä¸ªç«¯å£ã€‚ æ³¨æ„ï¼Œä¸€æ—¦æ‰§è¡Œè¿™æ¡å‘½ä»¤ï¼Œå¾…VDXè‡ªåŠ¨é‡å¯åŽï¼Œæ‰€æœ‰åœ¨VCSé›†ç¾¤å†…çš„VDXå°±åœ¨é€»è¾‘ä¸Šæˆä¸ºä¸€å°äº†ï¼›ç†è®ºä¸Šè€Œè¨€ï¼Œæˆ‘ä»¬åªéœ€è¦æ“ä½œä¸€å°å°±å¯ä»¥å®Œæˆå¯¹æ‰€æœ‰è®¾å¤‡çš„é…ç½®äº†ï¼Œæ­¤æ—¶ï¼ŒVCSçš„æ¨¡å¼æ˜¯Logical Chassisã€‚VDXçš„VCSæ¨¡å¼æ˜¯Fabric Clusterï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è®¾ç½®vcs vcsid X rbridge-id Yå°±å¥½ã€‚ è‹¥é€‰æ‹©ä½¿ç”¨Logical Chassisæ¨¡å¼ï¼Œé»˜è®¤æƒ…å†µä¸‹æ˜¯ï¼Œæœºå™¨é‡å¯åŽï¼Œå…ˆå¯åŠ¨å®Œæˆçš„æœºå™¨ä¸ºç®¡ç†å‘˜ï¼Œè‹¥æƒ³æŒ‡å®šæŸå°æœºå™¨ï¼Œåˆ™æ‰§è¡Œå‘½ä»¤ï¼šlogical-chassis principal-priority 1å…¶ä¸­ï¼Œ1æ˜¯rbridge-idã€‚VCSé›†ç¾¤å†…éƒ¨çš„principalåˆ‡æ¢å‘½ä»¤ï¼šlogical-chassis principal switchover Management And SummaryVCSçŸ©é˜µé›†ç¾¤å¸¸ç”¨çš„æ£€æŸ¥å‘½ä»¤ï¼š1234567show vcs detailshow fabric allshow fabric islshow fabric islports rbridge-id 1/2/3...show fabric trunkreload rbridge-id 1/2/3... #é‡å¯rbridge-idä¸º1/2/3...çš„æŸä¸ªäº¤æ¢æœºvcs replace rbridge-id x #éœ€è¦æ›´æ¢å’Œæ›¿æ¢rbridge-idæ—¶ï¼Œå¯ä»¥å…ˆæ›¿æ¢æŽ‰ï¼Œéœ€è¦ç³»ç»Ÿæ”¯æŒ é»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨VCSåˆ›å»ºä¹‹åŽï¼Œç”¨æˆ·ç®¡ç†å‘˜æ“ä½œä»»ä½•é…ç½®éƒ½ä¸éœ€è¦æ‰§è¡Œä¿å­˜çš„åŠ¨ä½œï¼Œå› ä¸ºç³»ç»Ÿä¼šè‡ªåŠ¨ä¿å­˜ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F03%2F14%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[IntroPTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†å¥½æ­¹ç®—æ˜¯å†™å®Œäº†ï¼Œä¹°äº†ç´«ä¹¦ï¼Œå¤šå¤šå°‘å°‘ç®—æ˜¯ä¼‘æ¯äº†ä¸‰å››å¤©å§ï¼ŒçŽ°åœ¨ä¹Ÿè¯¥é‡æ–°å¼€å§‹æ–°çš„æ—…ç¨‹(å—è™ðŸ˜¤)äº†ã€‚PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†å› ä¸ºæŒ‰ç…§PTAç½‘ç«™çš„æ ¼å¼ï¼Œåœ¨Blogä¸­ç»™å‡ºäº†é¢˜ç›®çš„å†…å®¹ã€è¾“å…¥è¾“å‡ºæ ·ä¾‹ã€è¦æ±‚ç­‰ä¿¡æ¯ï¼Œå—¯ï¼Œå†™çš„ååˆ†è¯¦ç»†(æ°´æ–‡)ï¼Œæ´‹æ´‹æ´’æ´’çš„å¥½å‡ ä¸‡å­—å‘¢(å‡‘å­—æ•°)ï¼Œå“ˆå“ˆã€‚è¯´åˆ°åº•æ˜¯è‡ªå·±æ•´ç†çš„ç´¯ï¼Œåˆ«äººçœ‹çš„ä¹Ÿç´¯ã€‚æ‰€ä»¥ï¼Œåœ¨æœ¬ç¯‡Blogä¸­å°±ä¸åœ¨ç»™å‡ºå…¶ä»–ä¿¡æ¯äº†ï¼Œåªç»™å‡ºä»£ç å’Œåˆ†æžå§ã€‚é¢˜ç›®ä¿¡æ¯ï¼Œè¯·ç‚¹å‡»ï¼šPAT (Basic Level) Practiceã€‚ä¸è¿‡ï¼Œæƒ³æ¥å„ä½çœ‹å®˜åº”è¯¥ä¹Ÿåªæœ‰åœ¨çœ‹åˆ°é¢˜ç›®æ‘¸å¤´ã€æŒ å¤´çš„æ—¶å€™ï¼Œæ‰ä¼šæ¥çœ‹è¿™é‡Œçš„å†…å®¹å§ï¼Œè¿™ä¹Ÿå°±æ›´åŠ æ²¡æœ‰æ˜¾ç¤ºé¢˜ç›®ä¿¡æ¯çš„å¿…è¦äº†ã€‚å—¯ï¼Œå°±æŒ‰ç…§è¿™æ ·çš„æƒ³æ³•æ¥åšå§ã€‚ è¯è¯´ï¼Œåœ¨Basic Levelå†…å¥½åƒåªæœ‰ç¼–ç¨‹é¢˜å“¦ã€‚ Classificationè¿™éƒ¨åˆ†å†…å®¹æ˜¯è‡ªå·±åšå®Œé¢˜ç›®ä¹‹åŽï¼Œå›žè¿‡å¤´å†æ¥çœ‹è¿™äº›é¢˜ç›®æ—¶åšçš„ï¼Œæ‰€ä»¥ä¹Ÿç®—æ˜¯æ€»ç»“æ€§çš„å†…å®¹ï¼Œå»ºè®®åˆ·é¢˜çš„æ—¶å€™ï¼Œä¸€æ¬¡æ€§å°†ä¸€ä¸ªç±»åž‹çš„é¢˜ç›®å…¨éƒ¨åšå®Œã€‚ æ¨¡æ‹Ÿ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³ 15 - 1008 æ•°ç»„å…ƒç´ å¾ªçŽ¯å³ç§»é—®é¢˜ 20 - 1011 A+B å’Œ C 15 - 1012 æ•°å­—åˆ†ç±» 20 - 1016 éƒ¨åˆ†A+B 15 - 1018 é”¤å­å‰ªåˆ€å¸ƒ 20 - 1019 æ•°å­—é»‘æ´ž 20 - 1026 ç¨‹åºè¿è¡Œæ—¶é—´ 15 å››èˆäº”å…¥ 1031 æŸ¥éªŒèº«ä»½è¯ 15 - 1035 æ’å…¥ä¸Žå½’å¹¶ 25 - 1045 å¿«é€ŸæŽ’åº 25 - 1046 åˆ’æ‹³ 15 - 1053 ä½æˆ¿ç©ºç½®çŽ‡ 20 - 1055 é›†ä½“ç…§ 25 - 1061 åˆ¤æ–­é¢˜ 15 - 1066 å›¾åƒè¿‡æ»¤ 15 - 1067 è¯•å¯†ç  20 - 1068 ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢ 20 - 1069 å¾®åšè½¬å‘æŠ½å¥– 20 - 1071 å°èµŒæ€¡æƒ… 15 - 1077 äº’è¯„æˆç»©è®¡ç®— 20 å››èˆäº”å…¥ 1086 å°±ä¸å‘Šè¯‰ä½  15 - 1089 ç‹¼äººæ€-ç®€å•ç‰ˆ 20 - 1091 N-è‡ªå®ˆæ•° 15 - 1096 å¤§ç¾Žæ•° 15 æ±‚å› æ•° 1097 çŸ©é˜µè¡Œå¹³ç§» 20 - 1101 Bæ˜¯Açš„å¤šå°‘å€ 15 - 1103 ç¼˜åˆ†æ•° 20 - 1106 2019æ•°åˆ— 15 - å­—ç¬¦ä¸²å¤„ç† é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1002 å†™å‡ºè¿™ä¸ªæ•° 20 - 1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•° 15 - 1009 è¯´åè¯ 20 - 1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼š 20 - 1021 ä¸ªä½æ•°ç»Ÿè®¡ 15 - 1024 ç§‘å­¦è®¡æ•°æ³• 20 - 1048 æ•°å­—åŠ å¯† 20 - 1052 å–ä¸ªèŒ 20 - 1054 æ±‚å¹³å‡å€¼ 20 sscanf 1057 æ•°é›¶å£¹ 20 2 è¿›åˆ¶è½¬æ¢ 1058 é€‰æ‹©é¢˜ 20 1073 1073 å¤šé€‰é¢˜å¸¸è§è®¡åˆ†æ³• 20 1058 1076 Wifiå¯†ç  15 - 1078 å­—ç¬¦ä¸²åŽ‹ç¼©ä¸Žè§£åŽ‹ 20 - 1081 æ£€æŸ¥å¯†ç  15 - 1084 å¤–è§‚æ•°åˆ— 20 - 1093 å­—ç¬¦ä¸²A+B 20 å­—ç¬¦ä¸²çš„å¹¶é›† 1094 è°·æ­Œçš„æ‹›è˜ 20 ç´ æ•°åˆ¤æ–­ 1109 æ“…é•¿C 20 - æ•°å­¦ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1003 æˆ‘è¦é€šè¿‡ï¼ 20 æ‰¾è§„å¾‹ 1007 ç´ æ•°å¯¹çŒœæƒ³ 20 ç´ æ•° 1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼ 25 æ±‚å¯¼ 1013 æ•°ç´ æ•° 20 ç´ æ•° 1017 Aé™¤ä»¥B 20 å¤§æ•°é™¤æ³• 1034 æœ‰ç†æ•°å››åˆ™è¿ç®— 20 åˆ†æ•°è¿ç®— 1040 æœ‰å‡ ä¸ªPAT 25 æ‰¾è§„å¾‹ 1049 æ•°åˆ—çš„ç‰‡æ®µå’Œ 20 æ³¨æ„è¯¯å·® 1051 å¤æ•°ä¹˜æ³• 15 æ³¨æ„è¯¯å·® 1056 ç»„åˆæ•°çš„å’Œ 15 æ¨¡æ‹Ÿä¹Ÿå¯ä»¥ 1060 çˆ±ä¸é¡¿æ•° 25 - 1062 æœ€ç®€åˆ†æ•° 20 åˆ†æ•°è¿ç®— 1063 è®¡ç®—è°±åŠå¾„ 20 å¤æ•°æ±‚æ¨¡ 1079 å»¶è¿Ÿçš„å›žæ–‡æ•° 20 å¤§æ•°åŠ æ³•ã€å›žæ–‡æ•°åˆ¤æ–­ 1082 å°„å‡»æ¯”èµ› 20 ç‚¹çš„è·ç¦»å…¬å¼ã€æŸ¥æ‰¾æœ€å€¼ 1088 ä¸‰äººè¡Œ 20 å¤šå…ƒæ–¹ç¨‹æ±‚å¯èƒ½è§£ 1099 æ€§æ„Ÿç´ æ•° 20 ç´ æ•° 1104 å¤©é•¿åœ°ä¹… 20 ç´ æ•°ã€æœ€å¤§å…¬çº¦æ•°ã€æŽ’åº æŸ¥æ‰¾ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1004 æˆç»©æŽ’å 20 - 1028 äººå£æ™®æŸ¥ 20 string 1030 å®Œç¾Žæ•°åˆ— 25 binary search or two pointer 1032 æŒ–æŽ˜æœºæŠ€æœ¯å“ªå®¶å¼º 20 - 1041 è€ƒè¯•åº§ä½å· 20 - 1059 Cè¯­è¨€ç«žèµ› 20 - 1065 å•èº«ç‹— 25 set &amp; map 1072 å¼€å­¦å¯„è¯­ 20 - 1090 å±é™©å“è£…ç®± set - 1092 æœ€å¥½åƒçš„æœˆé¥¼ 20 find max 1100 æ ¡åº† 25 find &amp; sort 1102 æ•™è¶…å† å†›å· 20 find max 1107 è€é¼ çˆ±å¤§ç±³ 20 find max æ•£åˆ— é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1005 ç»§ç»­(3n+1)çŒœæƒ³ 25 - 1029 æ—§é”®ç›˜ 20 string 1033 æ—§é”®ç›˜æ‰“å­— 20 string 1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”Ÿ 20 - 1039 åˆ°åº•ä¹°ä¸ä¹° 20 - 1042 å­—ç¬¦ç»Ÿè®¡ 20 - 1043 è¾“å‡ºPATest 20 - 1047 ç¼–ç¨‹å›¢ä½“èµ› 20 æŸ¥æ‰¾æœ€å¤§å€¼ 1064 æœ‹å‹æ•° 20 - 1083 æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·® 20 - 1087 æœ‰å¤šå°‘ä¸åŒçš„å€¼ 20 æ•°å­¦ 1108 Stringå¤è¯»æœº 20 - æŽ’åº é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1015 å¾·æ‰è®º 25 - 1080 MOOCæœŸç»ˆæˆç»© 25 æ³¨æ„è®¡ç®— 1085 PATå•ä½æŽ’è¡Œ 25 - 1095 è§£ç PATå‡†è€ƒè¯ 25 - è´ªå¿ƒ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1020 æœˆé¥¼ 25 - 1023 ç»„ä¸ªæœ€å°æ•° 20 - 1070 ç»“ç»³ 25 æŽ’åçš„å¤„ç† 1098 å²©æ´žæ–½å·¥ 20 - è¿›åˆ¶è½¬æ¢ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1022 Dè¿›åˆ¶çš„A+B 20 - 1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’± 20 - 1044 ç«æ˜Ÿæ•°å­— 20 map 1074 å®‡å®™æ— æ•ŒåŠ æ³•å™¨ 20 å­—ç¬¦ä¸²å¤„ç† é“¾è¡¨ é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1025 åè½¬é“¾è¡¨ 25 - 1075 é“¾è¡¨å…ƒç´ åˆ†ç±» 25 - 1105 é“¾è¡¨åˆå¹¶ 25 - 1110 åŒºå—åè½¬ 25 - å›¾å½¢è¾“å‡º é¢˜å· åç§° åˆ†å€¼ å¤‡æ³¨ 1027 æ‰“å°æ²™æ¼ 20 - 1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹ 15 - 1050 èžºæ—‹çŸ©é˜µ 25 - 1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³Analysisé¢˜ç›®æ¯”è¾ƒç®€å•ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„ç®—æ³•åŽ»æž„é€ è®¡ç®—è¿‡ç¨‹å³å¯ï¼Œcount++å…¶å®žåªåœ¨æœ€åŽå†™ä¸€å¥å°±å¯ä»¥äº†ã€‚ Code12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, count = 0; cin &gt;&gt; n; while(n != 1) &#123; if(n % 2 == 1) n = 3 * n + 1; n /= 2; count++; &#125; cout &lt;&lt; count; return 0;&#125; 1002 å†™å‡ºè¿™ä¸ªæ•°Analysisè¿™ä¸ªé¢˜ç›®20åˆ†å‘¢ï¼Œä¸è¿‡ä¸éš¾ï¼Œå˜»å˜»ï¼Œå°±æ˜¯æ¯”è¾ƒéº»çƒ¦ï¼Œçœ‹ç€é¢˜ç›®ä¸­çš„è¯ï¼šè¿™é‡Œä¿è¯$n$å°äºŽ$10^{100}$ï¼Œå¥½åƒçœ‹åˆ°äº†å‡ºé¢˜äººâ€œå–„æ„â€çš„å¾®ç¬‘ä¸€æ ·å‘¢(wo zhen xiang da si ni~)ã€‚å¤§è‡´æ€è·¯ï¼Œå…ˆè¦ç®—å‡ºæ¯ä¸ªæ•°ä½ä¸Šæ•°å­—çš„æ€»å’Œï¼Œç„¶åŽå†å°†ç»“æžœè¿›è¡Œæ•°ä½æ‹†åˆ†è¾“å‡ºä¸€ä½ä¸€ä½çš„æ•°å­—å°±å¥½äº†ã€‚å¯¹äºŽè¾“å…¥çš„æ•°å­—ä¸²ï¼Œå¯ä»¥ç”¨å•å­—ç¬¦çš„å½¢å¼æ¥å¤„ç†ï¼Œä¹Ÿå¯ä»¥ä»Žå­—ç¬¦ä¸²çš„è§’åº¦åŽ»å¤„ç†ï¼Œå¦å¤–æ³¨æ„åšæ•°ä½æ‹†åˆ†æ—¶çš„ä¸ªä½æ•°ï¼Œæ³¨æ„0çš„æ‹¼éŸ³æ˜¯lingä¸æ˜¯linã€‚ ç»§ç»­åˆ†æžä¸€ä¸‹é¢˜ç›®æ¡ä»¶ï¼Œâ€œä¿è¯$n$å°äºŽ$10^{100}$è¿™ä¸ªæ¡ä»¶å¥½åƒè¿˜æœ‰ç‚¹çŒ«è…»ï¼Ÿå°äºŽ$10^{100}$é‚£èƒ½å–åˆ°çš„æœ€å¤§çš„æ•°ä¸å°±æ˜¯$10^{100} - 1$äº†ï¼Ÿè€Œä¸”è¿™ä¸ªæ•°çš„æ¯ä¸€ä½éƒ½æ˜¯ 9ï¼Œæ€»å…± 99 ä½ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åŽå¾—åˆ°çš„å„ä½æ•°å­—ä¹‹å’Œè‚¯å®šä¸ä¼šå¤§äºŽ$9 \times 100 = 900$ï¼Œæœ€å¤šä¹Ÿä¸ä¼šè¶…è¿‡ä¸‰ä½æ•°äº†ï¼Œè¿™æ˜¯ä¸ªå¥½æ¶ˆæ¯ï¼æ˜Žç¡®äº†è¿™ç‚¹åŽï¼Œæ•°ä½æ‹†åˆ†çš„è¿‡ç¨‹å°±ç®€å•äº†ï¼›å¦å¤–ï¼Œéœ€è¦è¾“å‡ºçš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥å•ç‹¬æ”¾åœ¨äºŒç»´æ•°ç»„å†…ï¼Œåˆ©ç”¨èƒ½åˆ°çš„æ•°ä½ä»£æ›¿ä¸‹æ ‡ï¼Œæ¥è¾“å‡ºå°±å¾ˆæ–¹ä¾¿äº†ï¼ Codeversion 1æŒ‰ç…§ä¸Šè¿°çš„ä¸¤ç§æ€è·¯å¾—åˆ°çš„ AC åˆ†åˆ«ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; char c; int num, sum=0; while((c=getchar()) != '\n') &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; num = c - '0'; sum+=num; &#125; else continue; &#125; /* method 1: int digit, temp=sum, mask=1; while(temp &gt; 9) &#123; temp/=10; mask*=10; &#125; temp=sum; do &#123; digit = temp / mask; temp %= mask; mask /= 10; switch(digit) &#123; case 0:printf("ling");break; case 1:printf("yi");break; case 2:printf("er");break; case 3:printf("san");break; case 4:printf("si");break; case 5:printf("wu");break; case 6:printf("liu");break; case 7:printf("qi");break; case 8:printf("ba");break; case 9:printf("jiu");break; &#125; if(mask == 0) printf("\n"); else printf(" "); &#125; while(mask &gt; 0); */ /*method 2:*/ char num2chi[][6] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; int unit, tens, hundred; unit = sum % 10; tens = sum / 10 % 10; hundred = sum / 100; if(sum &gt; 100) printf("%s %s %s\n", num2chi[hundred], num2chi[tens], num2chi[unit]); else if (10 &lt; sum &amp;&amp; sum &lt; 100) printf("%s %s\n", num2chi[tens], num2chi[unit]); else printf("%s\n", num2chi[unit]); return 0;&#125; version 2è¿™ä¸ªé¢˜è¿˜å¯ä»¥å€ŸåŠ© C++ è‡ªå¸¦çš„ä¸€äº›å·¥å…·å‡½æ•°ã€‚123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string s; cin &gt;&gt; s; int sum = 0; string num[10] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; for(int i = 0; i &lt; s.length(); i++) &#123; sum += (s[i] - '0'); &#125; s = to_string(sum); for(int i = 0; i &lt; s.length(); i++) &#123; if(i != 0) cout &lt;&lt; ' '; cout &lt;&lt; num[s[i] - '0']; &#125; return 0;&#125; 1003 æˆ‘è¦é€šè¿‡ï¼Analysisè¿™ä¸ªé¢˜ç›®æ˜¯çœŸçš„å‘ï¼Œå…‰æ˜¯ç†è§£é¢˜æ„å°±å¾—èŠ±ä¸å°‘æ—¶é—´ï¼Œç¬¬ä¸€çœ¼çœ‹åˆ°æ¡ä»¶ 3 ä¼°è®¡ä¼šæŠŠäººç»™å¼„æ‡µé€¼ã€‚ä½†å®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜ç›®å…¶å®žç®—æ˜¯ä¸ªæ‰¾è§„å¾‹çš„é¢˜ç›®ï¼Œå…ˆç†è§£ä¸€ä¸‹è¿™ 3 ä¸ªæ¡ä»¶ï¼š æ¡ä»¶ 1 å¾ˆç›´æŽ¥ xPATxè¿™ç±»å­—ç¬¦ä¸²éƒ½æ˜¯ç­”æ¡ˆæ­£ç¡® aPbTcæ­£ç¡®ï¼Œé‚£ä¹ˆaPbATcaä¹Ÿæ˜¯æ­£ç¡®çš„ã€‚å°±æ ·ä¾‹è€Œè¨€ï¼ŒAAPATAAæ˜¯æ­£ç¡®çš„ï¼ŒåŽŸå› æ˜¯ç¬¦åˆxPATxï¼›è€ŒAAPAATAAAAæ­£ç¡®æ˜¯å› ä¸ºAAPATAAæ­£ç¡®ä¸”ä¹Ÿç¬¦åˆaPbATcaï¼Œæ­¤æ—¶æœ‰a = AA, b = A, c = AAã€‚åŒç†ï¼ŒAPAAATAAä¸­a = A, b = AA, c = Aï¼Œé‚£ä¹ˆaPbTcå°±æ˜¯APAATAï¼Œè¿™ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸ç¬¦åˆxPATxçš„ï¼Œæ‰€ä»¥é”™è¯¯ã€‚ ç†è§£é¢˜æ„ä¹‹åŽï¼Œå°±å¯ä»¥è¿›ä¸€æ­¥æ‰¾è§„å¾‹äº†ã€‚é¦–å…ˆï¼Œå¯ä»¥å‘çŽ°xPATxæ˜¯æ‰€æœ‰æ­£ç¡®ç­”æ¡ˆçš„æ ¹æºï¼Œå› ä¸ºå®ƒå¯ä»¥é€šè¿‡å˜æ¢æˆä¸ºå…¶ä»–å­—ç¬¦ä¸²ã€‚å‡è®¾ x æ˜¯ P å·¦è¾¹çš„ A çš„ä¸ªæ•°ï¼Œ y æ˜¯ P å’Œ T ä¸­é—´ A çš„ä¸ªæ•°ï¼Œz æ˜¯ T å³è¾¹ A çš„ä¸ªæ•°ã€‚é‚£ä¹ˆï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹è§„å¾‹ï¼š P å’Œ T çš„ä¸ªæ•°ä¸€å®šæ˜¯ 1ï¼ŒA çš„ä¸ªæ•°ä¸å®šï¼Œä½†å…¶ä»–å­—ç¬¦ä¸ªæ•°ä¸€å®šæ˜¯ 0 y &gt;= 1 ä¸ºäº†ç¡®ä¿aPbTcaç»è¿‡å˜æ¢åŽç¬¦åˆxPATxï¼Œbæ¯æ¬¡åªèƒ½å¢žåŠ  1 ä¸ª Aï¼Œä¹Ÿå³ï¼Œy æ¯æ¬¡åªèƒ½å¢žåŠ  1ï¼Œcä¸­ A çš„ä¸ªæ•°åˆ™ä¸€å®šæ˜¯ x çš„å€æ•°ã€‚åŒæ ·åœ°ï¼Œä¸ç®¡å¦‚ä½•å˜æ¢ï¼Œx æ˜¯ä¸å˜çš„ï¼Œæ¯æ¬¡ y å¢žåŠ  1ï¼Œå°±ä¼šè®© z å¢žåŠ  xï¼ˆå¯ä»¥ç»“åˆä¸Šé¢æ¡ä»¶ 3 ä¸­çš„ä¾‹å­åˆ†æžï¼‰ã€‚æŒ‰ç…§è¿™æ ·çš„è§„å¾‹ï¼Œå¯ä»¥åˆ©ç”¨å¾ªçŽ¯åˆ¤æ–­å½“y = 1æ—¶ï¼Œz å’Œ x æ˜¯å¦ç›¸ç­‰æ¥ç¡®å®šç­”æ¡ˆæ˜¯å¦æ­£ç¡®ã€‚è‹¥ä»¥aPbATcaä¸ºæ¨¡æ¿ï¼Œå¯ä»¥å¾—åˆ°z = x + x * (y - 1)è¿™ä¸ªä¸€èˆ¬æ€§çš„å¼å­ï¼Œè¿™æ ·å°±å¯ä»¥çœåŽ»å¾ªçŽ¯ã€‚ å‘çŽ°è¿™äº›è§„å¾‹åŽï¼Œè¿™ä¸ªé¢˜ç›®åŸºæœ¬ä¸Šå°±æ¸…æ™°äº†ã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); while(n--) &#123; char str[105]; scanf("%s", str); int len = strlen(str); int num_p = 0, num_t = 0, other = 0; int pos_p = -1, pos_t = -1; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') &#123; num_p++; pos_p = i; &#125; else if(str[i] == 'T') &#123; num_t++; pos_t = i; &#125; else if(str[i] != 'A') other++; &#125; if(num_p != 1 || num_t != 1 || other != 0 || pos_t - pos_p &lt;= 1) &#123; printf("NO\n"); continue; &#125; int x = pos_p, y = pos_t - pos_p - 1, z = len - pos_t - 1; if(z - x * (y - 1) == x) printf("YES\n"); else printf("NO\n"); &#125; return 0;&#125; 1004 æˆç»©æŽ’åAnalysisè¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œç®—æ˜¯æŸ¥æ‰¾å§ï¼Œå®šä¹‰å¥½ç»“æž„ä½“è¿›è¡Œå¤„ç†å°±å¥½ï¼Œæ³¨æ„æœ€å¤§ã€æœ€å°å€¼å¾—åˆ†å¼€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯åªç”¨if-elseå°±å®Œäº‹å¤§å‰ã€‚ Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef struct Stu &#123; char name[12]; char number[12]; int grade;&#125; students;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); int i=0; students stu, max, min; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); max = min = stu; for(i=1; i&lt;n; i++) &#123; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); /*online processing, find the minimum and maximum when inputing. */ if(stu.grade &lt; min.grade) min = stu; if(stu.grade &gt; max.grade) max = stu; &#125; printf("%s %s\n%s %s\n", max.name, max.number, min.name, min.number); return 0;&#125; 1005 ç»§ç»­(3n+1)çŒœæƒ³AnalysisæŒ‰ç…§1001çš„æ€è·¯ï¼Œå¯¹è¾“å…¥çš„æ¯ä¸ªæ•°è¿›è¡Œæ¨¡æ‹Ÿï¼Œå¼€è¾Ÿä¸€ä¸ªboolæ•°ç»„æ¥è®°å½•æŸä¸ªæ•°å­—æ˜¯å¦å‡ºçŽ°ï¼Œå‡ºçŽ°åˆ™å°†ä¸‹æ ‡ä¸ºå…¶å€¼çš„boolé‡ç½®ä¸ºtrueï¼Œç”±äºŽæ¯ä¸ªæ•°åœ¨æ¨¡æ‹Ÿä¸­å¯èƒ½ä¼šå‡ºçŽ°ä¸åŒçš„æ•°å­—ï¼Œæœ€å¥½è¿˜æ˜¯æ¯ä¸ªæ•°å­—éƒ½æ¨¡æ‹Ÿä¸€ä¸‹ã€‚å¦å¤–ï¼Œç”±äºŽæœ€åŽéœ€è¦ä»Žå°åˆ°å¤§è¾“å‡ºï¼Œæ‰€ä»¥å°†è¾“å…¥æ•°å­—åºåˆ—æŒ‰ä»Žå¤§åˆ°å°æŽ’åºåŽï¼Œåœ¨è¿›è¡Œè¾“å‡ºã€‚ç‰¹åˆ«è¦æ³¨æ„ï¼Œæ•°ç»„çš„å¤§å°ä¸€å®šè¦å¼€åˆ° 10000ï¼Œå¯èƒ½å‡ºçŽ°çš„æœ€å¤§æ•°æ˜¯ä¼šè¶…è¿‡ 1000 çš„ï¼Œä¸ç„¶æµ‹è¯•ç‚¹ 4 ä¼šå‡ºçŽ°æº¢å‡ºçš„é”™è¯¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;int main(int argc, char const *argv[]) &#123; int K, Num[105] = &#123;0&#125;, temp; bool times[MAXN] = &#123;false&#125;; scanf("%d", &amp;K); for(int i = 0; i &lt; K; i++) &#123; scanf("%d", &amp;Num[i]); temp = Num[i]; while(temp != 1) &#123; if(temp % 2 == 1) &#123; temp = 3 * temp + 1; &#125; temp /= 2; times[temp] = true; &#125; &#125; sort(Num, Num + K); bool flag = true; for(int i = K - 1; i &gt;= 0; i--) &#123; if(!times[Num[i]]) &#123; if(flag) &#123; printf("%d", Num[i]); flag = false; &#125; else &#123; printf(" %d", Num[i]); &#125; &#125; &#125; return 0;&#125; 1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•°Analysisæ°´é¢˜ä¸€é“ï¼Œé¢˜ç›®å·²ç»è¯´äº†ç»™ä¸€ä¸ªä¸è¶…è¿‡3ä½çš„æ­£æ•´æ•° n &lt; 1000ï¼Œåšå¥½æ•°ä½æ‹†åˆ†åŽï¼ŒæŒ¨ä¸ªè¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, num, unit, tens, hundred; scanf("%d", &amp;num); unit = num % 10; tens = num / 10 % 10; hundred = num / 100; for(i=0; i&lt;hundred; i++) &#123; printf("B"); &#125; for(i=0; i&lt;tens; i++) &#123; printf("S"); &#125; for(i=1; i&lt;=unit; i++) &#123; printf("%d", i); &#125; printf("\n"); return 0;&#125; 1007 ç´ æ•°å¯¹çŒœæƒ³Analysisè¿™é“é¢˜è¦ç¨å¾®ç†è§£ä¸€ä¸‹é¢˜ç›®æ„æ€ï¼Œä¹ä¸€çœ‹ï¼Œå¯èƒ½ä¼šæ²¡æ˜Žç™½é¢˜ç›®çš„æ„æ€ã€‚å…³é”®çš„æ¡ä»¶ï¼šå­˜åœ¨æ— ç©·å¤šå¯¹ç›¸é‚»ä¸”å·®ä¸º2çš„ç´ æ•°ï¼Œä¹Ÿå³æ˜¯è¯´ï¼Œå¯¹äºŽé¢˜ç›®ç»™å®šçš„$N = 20$è€Œè¨€ï¼Œåœ¨$2 - 20$ä¹‹é—´ï¼Œå¿…ç„¶å­˜åœ¨ç›¸é‚»ä¸”å·®ä¸º2çš„ç´ æ•°å¯¹ï¼è€Œé¢˜ç›®çš„é—®é¢˜æ˜¯ï¼šè®¡ç®—ä¸è¶…è¿‡$N$çš„æ»¡è¶³çŒœæƒ³çš„ç´ æ•°å¯¹çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆç›´æŽ¥è¿›è¡Œè®¡ç®—å°±å¥½äº†ã€‚è‡³äºŽå¦‚ä½•åˆ¤æ–­ç´ æ•°ï¼Œè¿™å°±æ˜¯è€ç”Ÿå¸¸è°ˆçš„é—®é¢˜äº†ï¼Œæ–¹æ³•å¾ˆå¤šã€‚ è¿™ä¸ªé¢˜ç›®æ²¡æœ‰è¶…æ—¶çš„æµ‹è¯•ç‚¹ï¼Œä¸ç”¨æƒ³çš„å¤ªå¤æ‚ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef enum&#123; false, true&#125; bool;bool IsPrime(int n);int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d", &amp;N); for(i = 2; i &lt;= N - 2; i++) &#123; if(IsPrime(i) &amp;&amp; IsPrime(i + 2)) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;bool IsPrime(int n) &#123; bool flag = true; if(n &lt;= 1 || n % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(n); i+=2) &#123; if(n % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 1008 æ•°ç»„å…ƒç´ å¾ªçŽ¯å³ç§»é—®é¢˜Analysisæœ¬é¢˜çš„è§£ç­”æ–¹æ³•è¾ƒå¤šï¼Œé¦–å…ˆéœ€è¦å¯¹ç§»åŠ¨æ¬¡æ•°$M$è¿›è¡Œå¤„ç†ï¼Œåˆ†åˆ«å¯¹åº”ä¸¤ç§æƒ…å†µï¼Œ$M &gt;= N$å’Œ$M &lt; N$ï¼Œä½¿ç”¨å–ä½™è¿ç®—å³å¯ã€‚ä¸‹é¢ä»‹ç»ä¸€ä¸‹å„ç§æ–¹æ³•ï¼š ä¸ç§»åŠ¨ï¼Œå…ˆè¾“å‡ºæŒ‡å®šä½ç½®ï¼Œå†è¾“å‡ºä½™ä¸‹ä½ç½®å³å¯ åˆ©ç”¨é˜Ÿåˆ—ï¼Œç§»åŠ¨çš„è¿‡ç¨‹æ­£å¥½å¯¹åº”é˜Ÿåˆ—å‡ºä¸€æ¬¡é˜Ÿï¼Œå†å…¥ä¸€æ¬¡é˜Ÿ é‡‡ç”¨ç§»ä½ç®—æ³•reverse å‡½æ•°ï¼Œå¤§è‡´è¿‡ç¨‹ï¼ˆä»¥æ ·ä¾‹ä¸ºä¾‹ï¼‰ï¼š 12345n = 6, m = 2, move 3 turns-&gt; 1 2 3 4 5 6 - start-&gt; 6 5 4 3 2 1-&gt; 5 6 4 3 2 1-&gt; 5 6 1 2 3 4 - end ç§»ä½ç®—æ³•reverse å‡½æ•°çš„å¤§è‡´ä»£ç ï¼š1234567void reverse(int *array, int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = array[i]; array[i] = array[start + end - i]; array[start + end - i] = temp; &#125;&#125; Codedirect output12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; for(int i = n - m; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; for(int i = 0; i &lt; n - m; i++) &#123; cout &lt;&lt; a[i]; if(i != n - m - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; use queue12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt; q; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; m %= n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q.push(temp); &#125; for(int i = 0; i &lt; n - m; i++) &#123; temp = q.front(); q.pop(); q.push(temp); &#125; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); if(q.size() != 0) cout &lt;&lt; ' '; &#125; return 0;&#125; reverse function1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn = 110;void Reverse(int a[], int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = a[i]; a[i] = a[end + start - i]; a[end + start - i] = temp; &#125;&#125;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; Reverse(a, 0, n - m - 1); Reverse(a, n - m, n - 1); Reverse(a, 0, n - 1); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; ä½¿ç”¨ C++ å°±ä¸ç”¨è‡ªå·±å®žçŽ° reverse å‡½æ•°äº†ï¼Œè¿™é‡Œå…ˆé€†ç½®å‰é¢çš„å…ƒç´ ï¼Œå†é€†ç½®åŽé¢çš„å…ƒç´ ï¼Œæœ€åŽæ•´ä½“é€†ç½®ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112131415161718192021#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; reverse(a, a + n - m); reverse(a + n - m, a + n); reverse(a, a + n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 1009 è¯´åè¯Analysisè¿™ä¸ªé¢˜å¦‚æžœå•çº¯çš„å¤„ç†å­—ç¬¦ä¸²çš„è¯ï¼Œä¼šæ¯”è¾ƒéº»çƒ¦ã€‚ä¸è¿‡è‹¥æ˜¯ä½¿ç”¨äºŒç»´æ•°ç»„ï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰å°±å¾ˆç®€å•äº†ï¼Œåˆ©ç”¨çš„æ˜¯scanfæ— æ³•è¯»å…¥å¸¦ç©ºæ ¼çš„å­—ç¬¦ä¸²çš„ç‰¹æ€§ã€‚åŒç†ï¼Œä½¿ç”¨ cin ä¹Ÿå¯ä»¥åšåˆ°åŒæ ·çš„äº‹æƒ…ï¼Œè¾“å‡ºçš„æ—¶å€™å®žé™…ä¸Šæ˜¯æ ˆçš„æ€æƒ³ã€‚ Codeversion 1123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int count = 0; char Str[85][85], c; while(1) &#123; scanf("%s", Str[++count]); c = getchar(); if(c == '\n') &#123; break; &#125; &#125; for(; count &gt; 1; count--) &#123; printf("%s ", Str[count]); &#125; puts(Str[count]); return 0;&#125; version 2åŽŸæ¥æ²¡æœ‰ä»Žå­—ç¬¦ä¸²çš„è§’åº¦æ¥åšï¼ŒçŽ°åœ¨å†æ¥ä»Žå­—ç¬¦ä¸²å¤„ç†çš„è§’åº¦æ¥åšä¸€ä¸‹ï¼š123456789101112131415161718#include &lt;iostream&gt;using namespace std;int main() &#123; string str, res; getline(cin, str); for(int i = str.length() - 1; i &gt;= 0; i--) &#123; int j = i - 1; for(; j &gt; 0; j--) &#123; if(str[j] == ' ') break; &#125; if(j &gt;= 0 &amp;&amp; str[j] == ' ') res += str.substr(j + 1, i - j) + ' '; else res += str.substr(0, i + 1); i = j; &#125; cout &lt;&lt; res; return 0;&#125; è¦æ³¨æ„çš„ç‚¹å°±æ˜¯å¯èƒ½ä¼šå­˜åœ¨å­—ç¬¦ä¸²å‰é¢æœ‰å¤šä¸ªç©ºæ ¼çš„æƒ…å†µã€‚ 1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼Analysé¢˜ç›®å¤§æ„è¾ƒä¸ºæ˜Žç¡®ï¼Œä½†æ„Ÿè§‰æœ‰äº›ä¸œè¥¿æ²¡è¯´æ˜Žç™½...æ³¨æ„çš„åœ°æ–¹å¤§è‡´å¦‚ä¸‹ï¼š å› ä¸ºæ²¡è¯´è¾“å…¥ä»€ä¹ˆæ—¶å€™ç»“æŸï¼Œæ‰€ä»¥åªèƒ½æ‰‹åŠ¨ä½¿ç”¨ Windows ä¸‹çš„Ctrl + Zæ¥ç»“æŸè¾“å…¥ï¼Œåˆ¤é¢˜ç³»ç»Ÿå»ºåœ¨ Linux ä¸Šï¼Œåº”è¯¥è‡ªåŠ¨ä½¿ç”¨çš„Ctrl + Dï¼Œè¿™ä¸¤ä¸ªæ“ä½œéƒ½è¡¨ç¤ºEOFï¼Œæ‰€ä»¥å¾—ä½¿ç”¨!= EOFæ¥ä½œä¸ºè¾“å…¥ç»“æŸçš„æ ‡å¿— å¸¸æ•°é¡¹æ±‚å¯¼åŽä¸º0ï¼Œéœ€è¦è¾“å‡ºä¸º0 0ï¼Œè¿™åº”è¯¥æ˜¯é¢˜ç›®æœ€åŽä¸€ä¸ªæ¡ä»¶çš„æç¤ºäº† å¯èƒ½å‡ºçŽ°æŒ‡æ•°ä¸ºè´Ÿçš„é¡¹ï¼Œè¾“å‡ºé¡ºåºæ˜¯æŒ‡æ•°é€’é™çš„ï¼Œè¿™é‡Œç”¨é“¾è¡¨å°±å¾ˆæ— è„‘ï¼Œå› ä¸ºè¾“å…¥ç»å¯¹æ˜¯æŒ‡æ•°é€’é™çš„ï¼Œé‚£ä¹ˆæ±‚å¯¼å®ŒåŽï¼Œä¹Ÿç»å¯¹æ˜¯æŒ‡æ•°é€’é™çš„ï¼Œç›´æŽ¥è¾“å‡ºå³å¯ è¿™é“é¢˜ä¹Ÿå¯ä»¥ç”¨é“¾è¡¨æ¥åšï¼Œæ±‚å¯¼çš„è¿‡ç¨‹ä¼šå¤æ‚ä¸€äº›ã€‚ Codeuse linked list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node* List;typedef struct node&#123; int coef, expo; List next;&#125; Node;List CreateList(void);void Derivation(List L);void Print(List L);int main(int argc, char const *argv[]) &#123; List L = CreateList(); Derivation(L); Print(L); return 0;&#125; List CreateList(void) &#123; List L = (List)malloc(sizeof(Node)), rear; L-&gt;next = NULL; rear = L; int c, e; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; List temp_node = (List)malloc(sizeof(Node)); temp_node-&gt;next = NULL; rear-&gt;next = temp_node; rear = temp_node; temp_node-&gt;coef = c; temp_node-&gt;expo = e; &#125; return L;&#125;void Print(List L) &#123; List Temp = L-&gt;next; int flag = 1; while(Temp) &#123; if(flag) &#123; printf("%d %d", Temp-&gt;coef, Temp-&gt;expo); flag = 0; &#125; else &#123; if(Temp-&gt;coef != 0) &#123; printf(" %d %d", Temp-&gt;coef, Temp-&gt;expo); &#125; &#125; Temp = Temp-&gt;next; &#125; putchar('\n');&#125;void Derivation(List L) &#123; List p = L-&gt;next; while(p) &#123; if(p-&gt;expo) &#123; p-&gt;coef = p-&gt;coef * p-&gt;expo; p-&gt;expo--; &#125; else &#123; p-&gt;coef = 0; &#125; p = p-&gt;next; &#125;&#125; use array123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, items[1005] = &#123;0&#125;, c, e, count = 0; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; items[e] = c; &#125; items[0] = 0; for(i = 1; i &lt;= 1000; i++) &#123; items[i - 1] = items[i] * i; items[i] = 0; if(items[i - 1] != 0) &#123; count++; &#125; &#125; if(count == 0) printf("0 0\n"); else &#123; for(i = 1000; i &gt;= 0; i--) &#123; if(items[i]) &#123; printf("%d %d", items[i], i); count--; if(count != 0) &#123; putchar(' '); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125; 1011 A+Bå’ŒCAnalysisç”±äºŽé¢˜ç›®é™å®šäº†è¾“å…¥æ•°æ®èŒƒå›´ä¸º$[-2^{31}, 2^{31}]$ï¼Œæœ¬é¢˜å¯ä»¥æœ‰ä¸¤ç§è§£æ³•ï¼š ç›´æŽ¥ä½¿ç”¨long longï¼Œé¿å…ä½¿ç”¨intå¸¦æ¥çš„æº¢å‡º ä¾æ—§ä½¿ç”¨intï¼Œä½†æ˜¯éœ€è¦åšæº¢å‡ºå¤„ç†ï¼ŒåŒ…æ‹¬æ­£æº¢å‡ºå’Œè´Ÿæº¢å‡ºä¸¤ç§æƒ…å†µ Codeuse long long1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &gt; c) cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; &#125; return 0;&#125; use int1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; //positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; //negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; //normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1012 æ•°å­—åˆ†ç±»AnalysisæŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œä¾æ¬¡æ±‚å‡ºæ‰€æœ‰æ•°å­—ï¼Œä½†åœ¨è¾“å‡ºçš„æ—¶å€™è¦æ³¨æ„ï¼Œ$A_2$çš„ç»“æžœå¯èƒ½æ˜¯ 0 ï¼Œæ­¤æ—¶$A_2$æ˜¯å­˜åœ¨çš„ï¼Œè¦è¾“å‡º0ï¼Œè€Œä¸æ˜¯Nï¼Œç±»ä¼¼çš„æœ‰$A_4$ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;int main() &#123; int n, temp, a[6] = &#123;0&#125;, sign = 1, count = 0, flag = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;temp); int remain = temp % 5; if(remain == 0 &amp;&amp; temp % 2 == 0) a[1] += temp; if(remain == 1) &#123; a[2] += sign * temp; sign = -sign; flag = 1; &#125; if(remain == 2) a[3]++; if(remain == 3) &#123; a[4] += temp; count++; &#125; if(remain == 4 &amp;&amp; temp &gt; a[5]) &#123; a[5] = temp; &#125; &#125; if(a[1]) printf("%d ", a[1]); else printf("N "); if(flag) printf("%d ", a[2]); else printf("N "); if(a[3]) printf("%d ", a[3]); else printf("N "); if(a[4]) printf("%.1lf ", (double)a[4] / count); else printf("N "); if(a[5]) printf("%d", a[5]); else printf("N"); return 0;&#125; 1013 æ•°ç´ æ•°Analysisç´ æ•°ç›¸å…³çš„é¢˜ç›®å¥½åƒå·²ç»æ˜¯è€ç”Ÿå¸¸è°ˆçš„é¢˜åž‹äº†ï¼Œæ³¨æ„ä¸è¦è¶…æ—¶ã€‚å…³äºŽç´ æ•°çš„æ±‚æ³•ï¼Œå¯ä»¥çœ‹è¿™é‡Œï¼šç´ æ•°çš„æ±‚æ³• Codeéžç­›æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX 15000bool IsPrime(int number);int main(int argc, char const *argv[]) &#123; int M, N, Prime[MAX]; scanf("%d %d", &amp;M, &amp;N); int i, count = 2; Prime[1] = 2; for(i = 3; i &lt;= 105000; i++) &#123; if( IsPrime(i) ) &#123; Prime[count++] = i; &#125; &#125; count = 0; for(; M &lt; N; M++) &#123; printf("%d", Prime[M]); count++; if(count % 10 == 0) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; printf("%d\n", Prime[M]); return 0;&#125; bool IsPrime(int number) &#123; bool flag = true; if(number &lt;= 1 || number % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(number); i+=2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ç­›æ³•1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 1000001;int prime[MAXN], pNum = 0;bool p[MAXN] = &#123;false&#125;;void filterPrime(int n) &#123; for(int i = 2; i &lt; MAXN; i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; if(pNum &gt;= n) break; for(int j = i + i; j &lt; MAXN; j += i) &#123; p[j] = true; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int m, n, count = 0; scanf("%d %d", &amp;m, &amp;n); filterPrime(n); for(int i = m; i &lt;= n; i++) &#123; printf("%d", prime[i - 1]); count++; if(count % 10 != 0 &amp;&amp; i &lt; n) putchar(' '); else putchar('\n'); &#125; return 0;&#125; 1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼šAnalysisè¿™ä¸ªé¢˜ç›®çš„ç»†èŠ‚å¤„ç†ï¼ŒçœŸæ˜¯...å¤ªå¤ªå¤ªéº»çƒ¦å•¦~å¤§è‡´åˆ†æžä¸€ä¸‹ï¼š å­—ç¬¦ç›¸åŒçš„æ—¶å€™æ‰èƒ½åˆ¤æ–­æ˜¯å¦è¾“å‡º æ˜ŸæœŸåˆ¤æ–­å¿…é¡»æ˜¯å¤§å†™å­—æ¯ï¼Œä¸”å¿…é¡»å±žäºŽ $[A, G]$ è¿™ä¸ªèŒƒå›´å†…ï¼ˆæµ‹è¯•ç‚¹4ï¼‰ï¼Œç”¨å–ä½™ä¸æ˜¯æ›´å¥½ä¹ˆï¼Ÿ æ—¶é—´å•ä½éœ€è¦ç”¨0æ¥è¡¥å…¨2ä½ ç‰¹åˆ«è¦æ³¨æ„çš„å°±è¿™äº›ï¼Œå…¶ä»–çš„å†ä»”ç»†è¯»è¯»é¢˜ç›®å°±OKäº†~ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char Week[7][5] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1015 å¾·æ‰è®ºAnalysisè¿™é“é¢˜ä¸€å¼€å§‹åšçš„æ—¶å€™è¿˜æƒ³äº†æŒºä¹…çš„ï¼Œè€Œä¸”è¿˜æ²¡æƒ³å‡ºæ¥ï¼Œä¸‹é¢æ¥åˆ†æžä¸€ä¸‹ã€‚ ä½¿ç”¨åº“å‡½æ•°sortæ¥å®ŒæˆæŽ’åºçš„åŸºæœ¬æ“ä½œå°±ä¸è¯´äº†ï¼Œå¤§æ¦‚å¾—æ³¨æ„ä¸¤ä¸ªç‚¹ï¼š æ€»åˆ†éœ€è¦è®¡ç®—å‡ºæ¥ä½œä¸ºæŽ’åºçš„ä¾æ®ï¼Œè¿™ä¸ªæ˜¯é¢˜ç›®æ˜Žç¡®è¯´æ˜Žçš„ é¢˜ç›®ç»™çš„è€ƒç”Ÿç§ç±»å¾ˆå¤šï¼Œä¸ºäº†æŽ’åºæ–¹ä¾¿å¯ä»¥ç»™è¿™äº›è€ƒç”Ÿåˆ†ç±»ï¼Œæ•°å­—è¶Šå¤§ç­‰çº§è¶Šä½Žï¼ˆæˆ–åä¹‹ï¼‰ èƒ½æ³¨æ„åˆ°è¿™ä¸¤ä¸ªç‚¹ï¼Œé¢˜ç›®åŸºæœ¬å°±å¯ä»¥å®Œæˆäº†ã€‚æ‰€ä»¥ï¼Œä»¥åŽåœ¨é‡åˆ°ç±»ä¼¼çš„é¢˜ç›®ï¼Œå°±æå‰åˆ†å¥½ç±»å§ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; int id, scoreD, scoreC, sumCD, flag;&#125; stu[MAXN];bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumCD != b.sumCD) return a.sumCD &gt; b.sumCD; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return a.id &lt; b.id;&#125;int N, L, H, M = 0;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d", &amp;stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumCD = stu[i].scoreC + stu[i].scoreD; if(stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreC &gt;= L) &#123; M++; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &lt; H) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else stu[i].flag = 4; &#125; else &#123; stu[i].flag = 5; &#125; &#125; sort(stu, stu + N, cmp); printf("%d\n", M); for(int i = 0; i &lt; M; i++) &#123; printf("%d %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125; 1016 éƒ¨åˆ†A+BAnalysisæ ¹æ®é¢˜ç›®çš„è¦æ±‚è¿›è¡Œè®¡ç®—å³å¯ï¼Œä»Žå­—ç¬¦ä¸²æˆ–è€…æ•°å­—çš„è§’åº¦éƒ½å¯ä»¥å¾—åˆ°è§£å†³æ–¹æ³•ã€‚ Codeuse string123456789101112131415161718#include &lt;iostream&gt;using namespace std;int getnum(char *str, char D) &#123; int ret = 0; char *p = str; for(; *p != '\0'; p++) &#123; //loop condition also can use str[i] != '\0' if(*p == D) &#123; ret = ret * 10 + (*p - '0'); &#125; &#125; return ret;&#125;int main() &#123; char A[12], B[12], a, b; scanf("%s %c %s %c", A, &amp;a, B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; use int12345678910111213141516#include &lt;iostream&gt;using namespace std;int getnum(int A, int a) &#123; int ret = 0; do&#123; if(A % 10 == a) ret = ret * 10 + a; A /= 10; &#125; while(A &gt; 0); return ret;&#125;int main() &#123; int A, B, a, b; scanf("%d %d %d %d", &amp;A, &amp;a, &amp;B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; 1017 Aé™¤ä»¥BAnalysisæ­¤é¢˜è€ƒå¯Ÿå¤§æ•´æ•°è¿ç®—ï¼Œå…¶ä¸­Aä¸ºå¤§æ•´æ•°ï¼ŒBä¸ºintç±»åž‹çš„æ•´æ•°ï¼Œè®¡ç®—è¿™ä¸¤ä¸ªæ•°çš„å•†å’Œä½™æ•°ã€‚æ­¤ç±»åž‹çš„é¢˜ç›®ï¼Œéœ€è¦ä½¿ç”¨æ•°ç»„æ¥ä¿å­˜å¤§æ•´æ•°ï¼Œå¹¶ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿé¢˜ç›®è¦æ±‚åšçš„è¿ç®—ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign&#123; int d[1005], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign divide(bign a, int b, int &amp;r) &#123; bign c; c.len = a.len; for(int i = a.len - 1; i &gt;= 0; i--) &#123; r = r * 10 + a.d[i]; if(r &lt; b) c.d[i] = 0; else &#123; c.d[i] = r / b; r %= b; &#125; &#125; while(c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) &#123; c.len--; &#125; return c;&#125;int main(int argc, char const *argv[]) &#123; char str[1005]; int b, r = 0; cin &gt;&gt; str &gt;&gt; b; bign a = change(str), c; c = divide(a, b, r); for(int i = c.len - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; c.d[i]; &#125; cout &lt;&lt; ' ' &lt;&lt; r ;; return 0;&#125; 1018 é”¤å­å‰ªåˆ€å¸ƒAnalysisé¢˜ç›®å¤§æ„å°±æ˜¯å‰ªåˆ€çŸ³å¤´å¸ƒçš„æ¸¸æˆè§„åˆ™ï¼Œå¯¹åº” 9 ç§æƒ…å†µï¼Œè¿›è¡Œæ¨¡æ‹Ÿå³å¯ï¼Œæ³¨æ„è¾“å‡ºèµ¢çš„æ¬¡æ•°æœ€å¤šä¸”å­—å…¸åºæœ€å°çš„è§£ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;char gesture(int *a) &#123; int index = 1; char ges = '\0'; for(int i = 1; i &lt;= 3; i++) &#123; if(a[i] &gt; a[index]) index = i; &#125; switch(index) &#123; case 1: ges = 'B'; break; case 2: ges = 'C'; break; case 3: ges = 'J'; break; &#125; return ges;&#125;int main() &#123; int n, tie = 0, win = 0, ar[4] = &#123;0&#125;, br[4] = &#123;0&#125;; cin &gt;&gt; n; char a, b; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if(a == b) tie++; else if(a == 'C' &amp;&amp; b == 'J') &#123; win++; ar[2]++; &#125; else if(a == 'J' &amp;&amp; b == 'B') &#123; win++; ar[3]++; &#125; else if(a == 'B' &amp;&amp; b == 'C') &#123; win++; ar[1]++; &#125; else if(b == 'C' &amp;&amp; a == 'J') &#123; br[2]++; &#125; else if(b == 'J' &amp;&amp; a == 'B') &#123; br[3]++; &#125; else if(b == 'B' &amp;&amp; a == 'C') &#123; br[1]++; &#125; &#125; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; n - tie - win &lt;&lt; endl; cout &lt;&lt; n - tie - win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; cout &lt;&lt; gesture(ar) &lt;&lt; ' ' &lt;&lt; gesture(br); return 0;&#125; 1019 æ•°å­—é»‘æ´žAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªå››ä½æ•°å­—ï¼Œæ‹†åˆ†å‡ºå…¶å„ä½æ•°åŽï¼Œèƒ½å¾—åˆ°ä¸€ä¸ªæœ€å¤§å€¼å’Œæœ€å°å€¼ï¼ŒäºŒè€…ç›¸å‡åŽï¼Œä¼šå¾—åˆ°ä¸€ä¸ªæ–°æ•°å­—ã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œæœ€åŽå·®ä¼šä¸€ç›´ç­‰äºŽ6174ã€‚æ‰€ä»¥ï¼Œå½“å·®ä¸º6174æ—¶ï¼Œå°±åœæ­¢å¾ªçŽ¯ã€‚ æŒ‰ç…§ä¸‹é¢çš„ä»£ç æ€è·¯ï¼Œæ¯æ¬¡å¿…é¡»è¦å°†ä¿å­˜å„ä½æ•°å­—çš„æ•°ç»„åˆå§‹åŒ–ä¸º0ï¼Œå¦åˆ™ä¼šæœ‰é”™è¯¯ï¼ˆå› ä¸ºæ•°ç»„æœ‰å››ä¸ªå…ƒç´ å‚ä¸Žäº†è¿ç®—ï¼‰ã€‚å¦å¤–ï¼Œéœ€è¦è¾“å‡ºå‰å¯¼ 0ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1020 æœˆé¥¼Analysisè¿™æ˜¯é“è€ƒå¯Ÿè´ªå¿ƒç®—æ³•çš„é¢˜ç›®ï¼Œé¢˜ç›®è¦æ±‚è¾“å‡ºçš„æœ€å¤§æ”¶ç›Šï¼Œå®žé™…ä¸Šå°±æ˜¯å¯¹åº”å•ä»·æœ€é«˜çš„æœˆé¥¼å–å‡ºåŽçš„æ€»æ”¶ç›Šã€‚è‹¥å•ä»·æœ€é«˜çš„æœˆé¥¼çš„è´®å­˜é‡ä¸æ»¡è¶³å¸‚åœºéœ€æ±‚ï¼ŒæŒ‰ç…§å‰©ä½™çš„å¸‚åœºéœ€æ±‚é‡ç»§ç»­å–å•ä»·ç¬¬äºŒé«˜çš„æœˆé¥¼ã€‚æ‰€ä»¥ï¼Œéœ€è¦è®¡ç®—å‡ºæ¯ç§æœˆé¥¼çš„å•ä»·ï¼Œå†å¯¹å…¶è¿›è¡ŒæŽ’åºï¼ŒæŽ¥ç€æŒ‰ç…§é¢˜ç›®è¦æ±‚è®¡ç®—æ€»æ”¶ç›Šï¼Œæœ€åŽåœ¨è¾“å‡ºã€‚ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125;int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; D -= cake[i].store; ans += cake[i].sell; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125; 1021 ä¸ªä½æ•°ç»Ÿè®¡Analysisä»¥å­—ç¬¦ä¸²çš„å½¢å¼è¯»å…¥é¢˜ç›®ç»™å®šçš„æ•°å­—ï¼Œå†åˆ©ç”¨æ•£åˆ—çš„æ€æƒ³ï¼Œç»Ÿè®¡å„ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°ï¼Œç»§è€Œè¾“å‡ºã€‚ Code123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 1005int main(int argc, char const *argv[]) &#123; char num[MAXN]; int i, digit[10]=&#123;0&#125;; scanf("%s", num); char *p; p = num; while(*p) &#123; digit[*p - '0']++; p++; &#125; for(i=0; i&lt;10; i++) &#123; if(digit[i] != 0) printf("%d:%d\n", i, digit[i]); &#125; return 0;&#125; 1022 Dè¿›åˆ¶çš„A+BAnalysisè¿›åˆ¶è½¬æ¢çš„å¸¸è§„é¢˜åž‹ï¼Œåˆ©ç”¨å–ä½™è¿ç®—èŽ·å–åˆ°è½¬æ¢è¿›åˆ¶çš„æ¯ä¸€ä½ï¼Œç„¶åŽä»Žé«˜ä½å¾€åœ°ä½è¾“å‡ºå³å¯ï¼Œæ³¨æ„è¾“å…¥0 0 8æ—¶ç‰¹åˆ¤ï¼Œè¾“å‡ºä¸º0ã€‚ Code1234567891011121314151617181920#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; long long A, B, D, digit[50] = &#123;0&#125;, count = 0; scanf("%lld %lld %lld", &amp;A, &amp;B, &amp;D); A += B; while(A) &#123; digit[count++] = A % D; A /= D; &#125; if(count) &#123; for(count--; count &gt;= 0; count--) &#123; printf("%d", digit[count]); &#125; &#125; else &#123; printf("0"); &#125; putchar('\n'); return 0;&#125; 1023 ç»„ä¸ªæœ€å°æ•°Analysisè¾“å‡ºç¬¬ä¸€ä¸ªæ•°å­—æ—¶ï¼Œä¸èƒ½è¾“å‡º0ï¼Œæ‰€ä»¥ç›´æŽ¥ä»Žæ•°å­—1å¼€å§‹éåŽ†ï¼Œå­˜åœ¨åˆ™è¾“å‡ºï¼Œç„¶åŽä¸ªæ•°å‡1ï¼Œå¹¶è·³å‡ºå¾ªçŽ¯ï¼›æŽ¥ç€åœ¨è¾“å‡ºå‰©ä¸‹çš„æ•°å­—ï¼Œæ­¤æ—¶0æ˜¯å¯ä»¥è¢«ç›´æŽ¥è¾“å‡ºçš„ï¼Œæ‰€ä»¥ä»Žæ•°å­—0å¼€å§‹éåŽ†ï¼ˆä¹Ÿæ˜¯ä»Žå°åˆ°å¤§çš„è§„å¾‹ï¼‰ï¼Œå°†æ¯ä¸€ä¸ªæ•°å­—å…¨éƒ¨è¾“å‡ºå®ŒåŽï¼Œå†å¼€å§‹è¾“å‡ºä¸‹ä¸€ä¸ªæ•°å­—ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int count[10] = &#123;0&#125;; for(int i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;count[i]); &#125; //print the first number for(int i = 1; i &lt; 10; i++) &#123; if(count[i]) &#123; printf("%d", i); count[i]--; break; &#125; &#125; //print the rest of numbers for(int i = 0; i &lt; 10; i++) &#123; while(count[i]) &#123; printf("%d", i); count[i]--; &#125; &#125; return 0;&#125; 1024 ç§‘å­¦è®¡æ•°æ³•Analysisé¢˜ç›®æ„æ€æ¯”è¾ƒæ˜Žç¡®ï¼Œç§‘å­¦è®°æ•°æ³•è½¬æ¢æˆæ­£å¸¸çš„æ•°å­—ï¼Œè¦æŠŠæŒ‡æ•°æå–å‡ºæ¥ï¼Œåœ¨æŒ‡æ•°ä¸ºæ­£ã€è´Ÿæˆ–é›¶æ—¶ï¼Œåˆ†åˆ«å¯¹åº”ä¸åŒçš„æƒ…å†µã€‚ Codeversion 11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int Getexpon(char *s, int Epos);int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int count = 0, expo, Epos = 0, len = strlen(Num); for(; Num[Epos] != 'E'; Epos++); if(Num[0] == '-') putchar(Num[0]); expo = Getexpon(Num, Epos); if(expo &gt; 0) &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; Epos - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; Num[Epos] = '\0'; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; Epos; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125;int Getexpon(char *s, int Epos) &#123; int ret = 0, flag = 1, i = Epos + 1; if(s[i] == '-') &#123; flag = -1; &#125; i++; for(; s[i] != '\0'; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; return ret * flag;&#125; version 2è¿™ä¸ªé¢˜å¦‚æžœåˆ©ç”¨äº† scanf çš„æ ¼å¼åŒ–ä¸²å°±ä¼šæœ‰å¥‡æ•ˆï¼Œä½¿ç”¨%[^E]E%då¯ä»¥ç›´æŽ¥å°†æŒ‡æ•°è¯»å‡ºæ¥ï¼Œ%[^E]ä¸Ž%sæ˜¯ç±»ä¼¼çš„ï¼Œä½†æ˜¯ä¼šä¸€ç›´è¯»å–ï¼Œç›´åˆ°è¯»åˆ°Eè¿™ä¸ªå­—ç¬¦ã€‚å¦‚æžœè¦ç”¨ scanf è¯»å–ä¸€è¡Œï¼Œé‚£ä¹ˆå°±æ˜¯%[^&#39;\n&#39;]äº†ã€‚scanf è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç”¨æ³•ï¼Œå‚è€ƒé“¾æŽ¥ï¼šscanf æ ¼å¼åŒ–å­—ç¬¦ä¸²è¯¦è§£ã€‚å›žåˆ°è¿™é“é¢˜ï¼Œè¿™æ ·ä¸Šé¢çš„ä»£ç å°±å¯ä»¥ç®€å•ä¸€ç‚¹äº†ã€‚12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int main(int argc, char const *argv[]) &#123; char Num[MAXN]; int count = 0, expo, len; scanf("%[^E]E%d", Num, &amp;expo); len = strlen(Num); if(Num[0] == '-') putchar(Num[0]); if(expo &gt; 0) &#123; for(int i = 1; i &lt; len; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; len - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (len - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; len; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125; 1025 åè½¬é“¾è¡¨Analysisé¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œæ¯ k ä¸ªç»“ç‚¹è¿›è¡Œé€†ç½®ï¼Œè‹¥æœ€åŽå‰©ä¸‹å°äºŽ k ä¸ªç»“ç‚¹ï¼Œåˆ™ä¸éœ€é€†ç½®ï¼Œè¾“å‡ºé€†ç½®åŽçš„é“¾è¡¨ã€‚ å¯¹å¾…æ­¤ç±»é¢˜ç›®ï¼Œè¿˜æ˜¯ä½¿ç”¨é™æ€é“¾è¡¨çš„æ€è·¯æ¥å¤„ç†ã€‚å…ˆé»˜è®¤ç»“æž„æ•°ç»„å†…çš„ç»“ç‚¹å…¨éƒ¨ä¸ºæ— æ•ˆç»“ç‚¹ï¼Œå†æŒ‰ç…§åœ°å€é€ä¸ªè¾“å…¥æ¯ä¸ªç»“ç‚¹ã€‚ç„¶åŽï¼Œåˆ©ç”¨ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€éåŽ†é“¾è¡¨ï¼Œå°†åˆæ³•ç»“ç‚¹çš„orderæ”¹ä¸ºé“¾è¡¨ç»“ç‚¹çš„é¡ºåºï¼Œå†åˆ©ç”¨sortå‡½æ•°å°†åˆæ³•ç»“ç‚¹å…¨éƒ¨æŽ’åœ¨ç»“æž„æ•°ç»„çš„å·¦ç«¯ï¼Œéžæ³•ç»“ç‚¹åˆ™åœ¨å³ç«¯ã€‚ æŽ¥ç€ï¼Œå†å¼€å§‹é€†ç½®è¾“å‡ºã€‚å¯¹äºŽå…·æœ‰ n ä¸ªåˆæ³•ç»“ç‚¹çš„é“¾è¡¨ï¼ŒæŒ‰ç…§ k æ¥é€†ç½®ï¼Œåˆ™å…¶å¿…å¯è¢«åˆ†ä¸º n/k ä¸ªå­å—æ¥åˆ†åˆ«é€†ç½®ã€‚ç”±äºŽæ˜¯é€†ç½®ï¼Œæ‰€ä»¥éœ€è¦å°†æ¯ä¸€ä¸ªå­å—å€’ç€è¾“å‡ºã€‚ä½†è¿™ä¸€å—çš„æœ€åŽä¸€ä¸ªéœ€è¦è¾“å‡ºçš„ç»“ç‚¹éœ€è¦åˆ†å¼€è€ƒè™‘ï¼Œå› ä¸ºå…¶nextå·²ç»å˜æˆäº†ä¸‹ä¸€ä¸ªå—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼ˆè¿™é‡Œè¯´çš„æ˜¯åˆå§‹é¡ºåºï¼‰çš„åœ°å€äº†ã€‚é’ˆå¯¹æ¯æ¬¡è¾“å‡ºçš„æœ€åŽè¿™ä¸ªç»“ç‚¹çš„ä½ç½®æœ‰ä¸‰ç§æƒ…å†µï¼š è‹¥å½“å‰è¾“å‡ºçš„å—ä¸æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œé‚£ä¹ˆå…¶nextå°±æ˜¯(i + 2) * K - 1ç»“ç‚¹ï¼ˆä¹Ÿå°±æ˜¯ä¸‹ä¸€ä¸ªæ•´å—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼‰çš„åœ°å€ è‹¥å½“å‰è¾“å‡ºçš„å—æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œä¸”æ˜¯æœ€åŽä¸€ä¸ªæ•´å—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆå…¶nextå³ä¸º-1 è‹¥å½“å‰è¾“å‡ºçš„å—æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œä½†å…¶åŽé¢è¿˜æœ‰å°äºŽKçš„ç»“ç‚¹ä¸ªæ•°ï¼Œæ‰€ä»¥å…¶nextæœ€åŽâ€œå°¾å·´â€çš„ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ï¼Œå³(i + 1) * Kå·ç»“ç‚¹ï¼Œç„¶åŽå†å°†å‰©ä½™ç»“ç‚¹è¾“å‡ºå³å¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node &#123; int address, data, next; int order;&#125; Node[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; init(); int n, k, head, address; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n ; i++) &#123; cin &gt;&gt; address; cin &gt;&gt; Node[address].data &gt;&gt; Node[address].next; Node[address].address = address; &#125; int count = 0, p = head; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) printf("-1\n"); else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1026 ç¨‹åºè¿è¡Œæ—¶é—´Analysisç»™å®šçš„æ˜¯æ•´æ•°ï¼Œä½†æ˜¯è¦æ±‚å››èˆäº”å…¥ï¼ŒåˆçŸ¥é¢˜ç›®ç»™å®šçš„é™¤æ•°æ˜¯ 100 ï¼Œç»™è¢«é™¤æ•°åŠ ä¸Š 50 åŽï¼Œå°±å¯ä»¥æ¨¡æ‹Ÿå‡ºå››èˆäº”å…¥çš„æ•ˆæžœã€‚ Code123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int c1, c2, c; scanf("%d %d", &amp;c1, &amp;c2); c = (c2 - c1 + 50) / 100; printf("%02d:%02d:%02d", c / 3600, c / 60 % 60, c % 60); return 0;&#125; 1027 æ‰“å°æ²™æ¼Analysisè¿™ç§æ‰“å°å›¾åƒçš„é¢˜ç›®ï¼Œéœ€è¦æ‰¾æ‰¾è§„å¾‹ã€‚ ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œåªçœ‹å›¾åƒä¸€åŠï¼Œä»Žä¸­å¿ƒå¼€å§‹å‡ºå‘ï¼Œå°±æ˜¯$a_1 = 1, a_2 = 3, a_3 = 5$çš„ç­‰å·®æ•°åˆ—ï¼ŒæŒ‰ç…§è¿™ç§æ€è·¯çš„è¯ï¼Œéœ€è¦æ‰“å°çš„å›¾åƒå…¶å®žå°±æ˜¯ä¸¤ä¸ªç­‰å·®æ•°åˆ—ï¼Œåªä¸è¿‡ç¬¬äºŒä¸ªç­‰å·®æ•°åˆ—æ²¡æœ‰é¦–é¡¹ï¼Œåªæœ‰ä¸¤é¡¹$a_1 = 3, a_2 = 5$ï¼Œä½†è¿™å¹¶ä¸å½±å“è®¡ç®—ï¼Œå½“ä½œä¸¤ä¸ªç›¸åŒçš„ç­‰å·®æ•°åˆ—è®¡ç®—å¥½åŽï¼Œå‡åŽ»å¤šä½™çš„éƒ¨åˆ†å³å¯ã€‚ ä»Žè€Œæœ‰ï¼š$2S_n - 1= 2 \times \frac{3 \times (1 + 5)}2 = 17$ï¼Œè¿™å°±æ˜¯éœ€è¦æ‰“å°å‡ºæ¥çš„ç¬¦å·æ•°é‡ï¼Œè€Œæ­¤æ—¶çš„å±‚æ•°ä¸º3ï¼ˆå…¶å®žä¹Ÿæ˜¯ç­‰å·®æ•°åˆ—çš„é¡¹æ•°ï¼‰ã€‚ ä¸‹é¢å†æ¥è¿›è¡Œè¾“å‡ºï¼Œæ³¨æ„æ¯è¡Œè¦å…ˆè¾“å‡ºç©ºæ ¼ï¼Œåœ¨è¾“å‡ºå­—ç¬¦ï¼Œæœ€åŽä¸€è¡Œè¾“å‡ºæœªä½¿ç”¨çš„å­—ç¬¦æ•°ã€‚ä½¿ç”¨ç»å¯¹å€¼ï¼Œèƒ½ç®€åŒ–ä¸€åŠçš„ä»£ç é‡ï¼Œçœ‹ç€å¾ˆæ¸…çˆ½~ Code123456789101112131415161718192021#include &lt;cstdio&gt;#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))int main(int argc, char const *argv[]) &#123; int N, layers; char c; scanf("%d %c", &amp;N, &amp;c); for(layers = 1; 2 * layers * layers - 1 &lt;= N; layers++); layers--; for(int i = 0; i &lt; 2 * layers - 1; i++) &#123; for(int j = 0; j &lt; layers - ABS(layers - i - 1) - 1; j++) &#123; putchar(' '); &#125; for(int k = 0; k &lt; 2 * ABS(layers - i - 1) + 1; k++) &#123; putchar(c); &#125; putchar('\n'); &#125; printf("%d\n", N - 2 * layers * layers + 1); return 0;&#125; 1028 äººå£æ™®æŸ¥Analysisè¿™é“é¢˜å¦‚æžœåœ¨å¤„ç†æ—¥æœŸä¸Šé¢æ²¡æœ‰ç»éªŒçš„è¯ï¼Œå°±å¾ˆéš¾å—...ä¸€å¼€å§‹åœ¨åˆ¤æ–­æ—¥æœŸåˆæ³•æ€§çš„æ—¶å€™ï¼Œæƒ³åˆ°äº†å…¨éƒ¨è½¬åŒ–ä¸ºå¤©æ•°ï¼Œå…‰æ˜¯è½¬æ¢å¤©æ•°ï¼Œè¿˜æœ‰å¹³é—°å¹´çš„åŒºåˆ†ï¼Œæ„Ÿè§‰åˆæ˜¯ä¸€é“é¢˜äº†ðŸ¤”ï¼Œè¿™åº”è¯¥ä¸æ˜¯å§¥å§¥æƒ³è®©ç­”é¢˜è€…å¹²çš„æ´»ã€‚äº‹å®žè¯æ˜Žï¼Œç¡®å®žæƒ³æ­ªäº†ðŸ˜‚ï¼Œå¯¹äºŽè¿™ç±»æ—¥æœŸçš„åˆ¤æ–­ï¼Œä»Žå¹´è¿™ä¸ªæ•°å­—å¼€å§‹é€ä¸ªè¿›è¡Œæ¯”è¾ƒå³å¯ï¼ˆå‚è€ƒä¸‹é¢çš„ä»£ç ï¼‰ï¼ŒåŒæ—¶æ³¨æ„ä¸è¦ç”¨if-elseæ¥å¾—åˆ°æœ€å¹´é•¿å’Œå¹´è½»çš„äººå°±å¥½ï¼Œè¦åˆ†å¼€åˆ¤æ–­ã€‚ Codeuse sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;struct citizen&#123; int year, month, day; char name[7];&#125; youngest, oldest, left, right, temp;void Init();bool Less(citizen a, citizen b);bool More(citizen a, citizen b);int main(int argc, char const *argv[]) &#123; Init(); int N, valid = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d/%d/%d", temp.name, &amp;temp.year, &amp;temp.month, &amp;temp.day); if(Less(temp, right) &amp;&amp; More(temp, left)) &#123; valid++; if(More(temp, youngest)) &#123; youngest = temp; &#125; if(Less(temp, oldest)) &#123; oldest = temp; &#125; &#125; &#125; if(valid) &#123; printf("%d %s %s\n", valid, oldest.name, youngest.name); &#125; else &#123; printf("0\n"); &#125; return 0;&#125;void Init() &#123; left.year = youngest.year = 1814; right.year = oldest.year = 2014; youngest.month = oldest.month = left.month = right.month = 9; youngest.day = oldest.day = left.day = right.day = 6;&#125;bool Less(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &lt;= b.year; else if(a.month != b.month) return a.month &lt;= b.month; else return a.day &lt;= b.day;&#125;bool More(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &gt;= b.year; else if(a.month != b.month) return a.month &gt;= b.month; else return a.day &gt;= b.day;&#125; use stringè¿™ä¸ªé¢˜ï¼Œä¸€æ—¦ç”¨ string å®¹å™¨æ¥å¤„ç†ï¼Œå°±éžå¸¸ç®€å•ã€‚123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;int main() &#123; int n, cnt = 0; cin &gt;&gt; n; string name, birth, maxname, minname, maxbirth = "1814/09/06", minbirth = "2014/09/06"; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; birth; if("1814/09/06" &lt;= birth &amp;&amp; birth &lt;= "2014/09/06") &#123; cnt++; if(maxbirth &lt;= birth) &#123; maxbirth = birth; maxname = name; &#125; if(minbirth &gt;= birth) &#123; minbirth = birth; minname = name; &#125; &#125; &#125; cout &lt;&lt; cnt; if(cnt) cout &lt;&lt; ' ' &lt;&lt; minname &lt;&lt; ' ' &lt;&lt; maxname; return 0;&#125; å®žé™…ä¸Šï¼Œç”¨ strcmp å‡½æ•°ä¹Ÿèƒ½å®Œæˆè¿™æ ·çš„åŠŸèƒ½ã€‚ 1029 æ—§é”®ç›˜AnalysiséåŽ†å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°è¿‡ï¼Œä½†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­æœªå‡ºçŽ°çš„å­—ç¬¦å³å¯ï¼Œå­—æ¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œä½†å­—ç¬¦ä¸²å†…æœ‰ç©ºæ ¼å’Œæ•°å­—ï¼Œç”¨_è¡¨ç¤ºç©ºæ ¼ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œå¯èƒ½åæŽ‰çš„é”®ç›˜ä¸€å…±æœ‰ 37 ä¸ªï¼‰ï¼Œæ³¨æ„ä¸èƒ½è¾“å‡ºå°å†™å­—æ¯ï¼Œä¸”é‡å¤çš„å­—ç¬¦åªè¾“å‡ºä¸€æ¬¡ã€‚è¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨æ•£åˆ—çš„æ€æƒ³æ¥åšï¼Œä¼šæ›´åŠ ç®€å•ç›´æŽ¥ã€‚ Codetraverse string12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cctype&gt;void levelup(char *str);int main(int argc, char const *argv[]) &#123; char str1[85], str2[85], Result[40]; scanf("%s %s", str1, str2); levelup(str1); levelup(str2); int count = 0; for(int i = 0; str1[i] != '\0'; i++) &#123; char temp = str1[i]; bool flag = true; for(int j = 0; str2[j] != '\0'; j++) &#123; if(temp == str2[j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; int k = 0; for(k = 0; k &lt; 40; k++) &#123; if(temp == Result[k]) &#123; break; &#125; &#125; if(k == 40) &#123; Result[count++] = temp; &#125; &#125; &#125; Result[count] = '\0'; puts(Result); return 0;&#125;void levelup(char *str) &#123; char *p = str; while(*p != '\0') &#123; if(islower(*p)) &#123; *p = toupper(*p); &#125; p++; &#125;&#125; use string.find()ä¸Šé¢ä»£ç åšçš„äº‹æƒ…ï¼Œå®Œå…¨å¯ä»¥ç”¨ find å‡½æ•°æ›¿ä»£ï¼Œå¦‚ä¸‹ï¼š1234567891011121314#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s1, s2, ans; cin &gt;&gt; s1 &gt;&gt; s2; for(int i = 0; i &lt; s1.length(); i++) &#123; if(s2.find(s1[i]) == string::npos &amp;&amp; ans.find(toupper(s1[i])) == string::npos) &#123; ans += toupper(s1[i]); &#125; &#125; cout &lt;&lt; ans; return 0;&#125; å®žé™…ä¸Šï¼Œstrstr å‡½æ•°ä¹Ÿå¯ä»¥å®ŒæˆåŒæ ·çš„åŠŸèƒ½ã€‚ hash12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#define maxn 85char A[maxn], B[maxn];int hashtable[128] = &#123;0&#125;;int main() &#123; scanf("%s %s", A, B); for(int i = 0; i &lt; strlen(B); i++) &#123; if('a' &lt;= B[i] &amp;&amp; B[i] &lt;= 'z') hashtable[B[i] - 32]++; else hashtable[B[i]]++; &#125; for(int i = 0; i &lt; strlen(A); i++) &#123; if('a' &lt;= A[i] &amp;&amp; A[i] &lt;= 'z') &#123; if(!hashtable[A[i] - 32]) &#123; printf("%c", A[i] - 32); hashtable[A[i] - 32]++; &#125; &#125; else if(!hashtable[A[i]]) &#123; printf("%c", A[i]); hashtable[A[i]]++; &#125; &#125; return 0;&#125; 1030 å®Œç¾Žæ•°åˆ—Analysisé¢˜ç›®å¤§æ„æ˜¯ç»™ä¸€å †æ•°å­—ï¼Œè¿™äº›æ•°å­—ä»¥ä»»æ„ä¸ªæ•°å’Œé¡ºåºç»„æˆåºåˆ—ï¼Œä½¿å¾—è¿™ä¸ªæ•°åˆ—çš„æœ€å¤§ã€æœ€å°å€¼å­˜åœ¨è¿™æ ·çš„å…³ç³»ï¼š$M\ \le\ m \times p$ï¼Œå¹¶è¦æ±‚è¿™ä¸ªæ•°åˆ—åŒ…å«çš„æ•°å­—æ•°é‡è¦å°½å¯èƒ½çš„å¤šã€‚ çœ‹åˆ°é¢˜ç›®ä¸€èˆ¬ä¼šæƒ³åˆ°å…ˆå°†åºåˆ—æŽ’åºï¼Œç„¶åŽæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œå†ä»Žå°åˆ°å¤§æžšä¸¾æ¯ä¸€ä¸ªæ•°å­—ï¼Œç›´åˆ°ä¸æ»¡è¶³å…³ç³»æ—¶ï¼Œé€€å‡ºå¾ªçŽ¯ï¼Œä¸‹æ ‡ä¹‹å·®å³æ˜¯ç»“æžœï¼Œä½†è¿™è¿™ç§æ€è·¯å®žé™…ä¸ŠåªæŠŠé¢˜ç›®çš„è¾“å…¥æ•°æ®å½“ä½œäº†ä¸€ä¸ªæ•°åˆ—æ¥å¤„ç†ï¼ˆæ­¤æ—¶æäº¤å¯å¾— 20 åˆ†ï¼‰ã€‚è‹¥è¿™ä¸ªæ•°åˆ—è¿˜å­˜åœ¨æ¯”$m \times p$å°çš„æ•°ï¼ŒæŒ‰ç…§è¿™æ ·çš„æ€è·¯å°±æ— æ³•è®©æ•°å­—æ•°é‡å¢žåŠ äº†ï¼ˆå› ä¸ºæœ€å¤§å€¼å·²ç»é™å®šäº†ï¼‰ã€‚ä¸¾ä¸ªä¸Žæ ·ä¾‹ç›¸åŒçš„ä¾‹å­ï¼Œå”¯ä¸€ä¸åŒæ˜¯æ€»æ•°å­—æœ‰ 20 ä¸ªï¼Œå‰ 10 ä¸ªæ•°å­—ä¸Žæ ·ä¾‹ä¸€æ ·ï¼ŒåŽ 10 ä¸ªå…¨æ˜¯ 1ï¼Œè¿™ç§æ€è·¯å¾—åˆ°çš„ç»“æžœè¿˜æ˜¯ 8ã€‚ä½†å®žé™…ä¸Šï¼Œé‚£ 10 ä¸ª 1 å¯ä»¥è·Ÿåˆ«çš„æ•°å­—æž„æˆ$M \le m \times p$çš„å…³ç³»ã€‚ ç»§ç»­æ·±å…¥æ€è€ƒï¼Œå¯¹æœ‰åºåºåˆ—è€Œè¨€ï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œå°±éœ€è¦ä»¥å½“å‰æ•°å­—ä¸ºå·¦ç«¯ç‚¹ï¼Œç„¶åŽæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„æœ€å¤§çš„å³ç«¯ç‚¹å€¼ï¼ˆæ­¤æ—¶è¿™ä¸ªå³ç«¯ç‚¹å€¼çš„ä¸‹æ ‡æœ€å¤§ï¼Œå› ä¸ºä¸‹æ ‡å·®è¶Šå¤§ï¼Œæ•°å­—æ•°é‡å°±è¶Šå¤šï¼‰ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ä¾æ¬¡æžšä¸¾æ¯ä¸ªæ•°å­—å°±å¯ä»¥å¾—åˆ°æœ€ç»ˆç»“æžœï¼Œæ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n^2)$ã€‚ å¦‚ä½•èƒ½å°†æŸ¥æ‰¾å³ç«¯ç‚¹å€¼è¿‡ç¨‹ç¼©çŸ­ä¸€ç‚¹å‘¢ï¼Ÿæ³¨æ„åˆ°æ•°ç»„å·²ç»è¢«æŽ’å¥½åºäº†ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥åšè¿™ä»¶äº‹ã€‚æ­¤æ—¶ï¼Œé—®é¢˜å°±æ¼”å˜ä¸ºï¼šä»Žä¸€ä¸ªæ•°çš„åŽé¢æ‰€æœ‰æ•°ä¸­ï¼Œæ‰¾å‡ºåˆšå¥½æ»¡è¶³ $M\ \le\ m \times p$ è¿™ä¸ªæ¡ä»¶çš„æ•°å­—ï¼Œå…¶ä¸­$M$å’Œ$m$åˆ†åˆ«ä¸ºç¬¬ä¸€ä¸ªæ•°å­—ä¸ŽæŸ¥æ‰¾åˆ°çš„æ•°å­—ç»„æˆçš„æ•°åˆ—çš„æœ€å¤§å’Œæœ€å°å€¼ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±æ˜¯$O(nlogn)$äº†ã€‚æ³¨æ„ï¼Œç”±äºŽ p ä¸Žæ•°å­—éƒ½æ˜¯ä¸è¶…è¿‡$10^9$çš„æ•°ï¼Œä½†ç›¸ä¹˜å°±æº¢å‡ºäº†ï¼Œæ‰€ä»¥éœ€è¦è½¬æ¢æˆ long longã€‚ Codeuse binarysearch123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; // you can also use upper_bound function // int j = upper_bound(Num + i + 1, Num + n, (long long)Num[i] * p) - Num; int j = BinarySearch(i, (long long)Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; use two pointerå®žé™…ä¸Šï¼Œè¿™ä¸ªé¢˜è¿˜å¯ä»¥ç”¨åŒæŒ‡é’ˆçš„æ€æƒ³æ¥æ‰¾å³ç«¯ç‚¹çš„ä¸‹æ ‡ï¼Œå¦‚ä¸‹ï¼š123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int i = 0, j = 0, ans = 1; while(i &lt; n &amp;&amp; j &lt; n) &#123; while(j &lt; n &amp;&amp; Num[j] &lt;= (long long)Num[i] * p) &#123; ans = max(ans, j - i + 1); j++; &#125; i++; &#125; printf("%d", ans); return 0;&#125; 1031 æŸ¥éªŒèº«ä»½è¯Analysisé¢˜ç›®ä¸éš¾ï¼Œå°±æ˜¯è¦è®¤çœŸè¯»é¢˜ï¼Œæ ¹æ®é¢˜ç›®è¦æ±‚è¿›è¡Œè®¡ç®—å³å¯ï¼Œç•¥å¾®æœ‰ç‚¹éº»çƒ¦ï¼Œåˆ«é©¬è™Žã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;cstring&gt;char idnum[20];int weight[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;char check[12] = &#123;'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'&#125;;int main() &#123; int n, invalid = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s", idnum); int z = 0, flag = 1; for(int i = 0; i &lt; 17; i++) &#123; if(!('0' &lt;= idnum[i] &amp;&amp; idnum[i] &lt;= '9')) &#123; printf("%s\n", idnum); invalid++; flag = 0; break; &#125; z = z + (idnum[i] - '0') * weight[i]; &#125; if(flag) &#123; z %= 11; if(check[z] != idnum[17]) &#123; printf("%s\n", idnum); invalid++; &#125; &#125; &#125; if(!invalid) printf("All passed\n"); return 0;&#125; 1032 æŒ–æŽ˜æœºæŠ€æœ¯å“ªå®¶å¼ºAnalysisè¿™é“é¢˜å¾ˆç®€å•ï¼Œç”¨æ•°ç»„ç®€å•æ¨¡æ‹Ÿä¸€ä¸‹å¤„ç†æ•°æ®ï¼Œç„¶åŽæŸ¥æ‰¾æœ€å¤§å€¼å°±å¥½äº†ï¼Œæ³¨æ„æœ€åŽä¸€ä¸ªå¤§æ•°æ®çš„æµ‹è¯•ç‚¹ã€‚ Code12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 100005int main(int argc, char const *argv[]) &#123; int i, Num, Max = 0, N, School_Num[MAXN] = &#123;0&#125;, temp; scanf("%d", &amp;N); while(N--) &#123; scanf("%d %d", &amp;Num, &amp;temp); School_Num[Num] += temp; &#125; for(i = 0; i &lt; MAXN; i++) &#123; if(Max &lt; School_Num[i]) &#123; Num = i; Max = School_Num[i]; &#125; &#125; printf("%d %d\n", Num, Max); return 0;&#125; 1033 æ—§é”®ç›˜æ‰“å­—Analysisä¸Ž 1029 æ­£å¥½ç›¸åçš„ä¸€é“é¢˜ç›®ï¼Œè¦æ³¨æ„çš„ç‚¹ï¼š ä¸åŒºåˆ†å¤§å°å†™ï¼Œåªè¦æ˜¯ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å‡ºçŽ°è¿‡çš„å­—æ¯ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²åœ¨è¾“å‡ºæ—¶ï¼Œæ— è®ºå¤§å°å†™ï¼Œéƒ½ä¸èƒ½è¾“å‡ºã€‚ ä¸Šæ¡£é”®åäº†ï¼Œå°½ç®¡æŸä¸ªå­—æ¯æŒ‰é”®æ²¡åï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½è¾“å‡ºè¿™ä¸ªå­—æ¯çš„å¤§å†™äº†ã€‚ ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¯èƒ½æ˜¯ç©ºä¸²ã€‚ strlenå¯èƒ½ä¼šè¶…æ—¶ã€‚ scanfæ— æ³•è¯»å…¥æµ‹è¯•ç‚¹ 2 çš„ç©ºä¸²ï¼Œæ‰€ä»¥è¦ç”¨fgetsã€‚ Codehash123456789101112131415161718192021#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; bool brokenkey[128] = &#123;false&#125;; fgets(str2, MAXN, stdin); fgets(str1, MAXN, stdin); for(int i = 0; str2[i] != '\0'; i++) &#123; brokenkey[str2[i]] = true; if(isupper(str2[i])) brokenkey[str2[i] + 32] = true; &#125; for(int i = 0; str1[i] != '\0'; i++) &#123; if(!brokenkey[str1[i]]) &#123; if(isupper(str1[i]) &amp;&amp; brokenkey['+']) continue; printf("%c", str1[i]); &#125; &#125; return 0;&#125; use string.find()è¿™ä¸ªé¢˜ä¸€æ ·å¯ä»¥ç”¨ find å‡½æ•°æ¥å®Œæˆï¼Œå¦‚ä¸‹ï¼š123456789101112131415161718#include &lt;iostream&gt;#include &lt;cctype&gt;using namespace std;int main() &#123; string s1, s2, ans; getline(cin, s1); getline(cin, s2); for(int i = 0; i &lt; s1.length(); i++) &#123; s1[i] = tolower(s1[i]); &#125; for(int i = 0; i &lt; s2.length(); i++) &#123; if(s1.find(s2[i]) == string::npos) &#123; if(!isupper(s2[i])) cout &lt;&lt; s2[i]; else if(s1.find('+') == string::npos &amp;&amp; s1.find(tolower(s2[i])) == string::npos) cout &lt;&lt; s2[i]; &#125; &#125; return 0;&#125; 1034 æœ‰ç†æ•°è¿ç®—Analysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®š2ä¸ªa/bå½¢å¼çš„åˆ†æ•°ï¼Œaä¸ºåˆ†å­ï¼Œbä¸ºåˆ†æ¯ï¼Œæ±‚è¿™2ä¸ªåˆ†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ï¼Œå†è¾“å‡ºã€‚ ç»™å®šçš„åˆ†æ•°åªæœ‰ä¸¤ç§æƒ…å†µï¼ˆå½¢å¼ä¸Šï¼‰ï¼šçœŸåˆ†æ•°å’Œå‡åˆ†æ•°ï¼Œä¸å­˜åœ¨å¸¦åˆ†æ•°ï¼Œä½†è¾“å‡ºè¦è¾“å‡ºå¸¦åˆ†æ•°ï¼Œå¹¶ä¸”æ˜¯æœ€ç®€å½¢å¼ã€‚åŒ–ç®€çš„ç›®çš„å…¶å®žæ˜¯é¢˜ç›®åœ¨è€ƒå¯Ÿæ±‚æœ€å¤§å…¬çº¦æ•°ï¼Œåˆ©ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯æ±‚å¾—ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ æ³¨æ„ï¼š é™¤æ•°ä¸º0æ—¶ï¼Œéœ€è¦è¾“å‡ºInf è´Ÿæ•°éœ€è¦ä½¿ç”¨()æ‹¬èµ·æ¥ è¿™ç§é¢˜ï¼Œå»ºè®®éƒ½ç”¨è¿™ç§æ¨¡æ¿åšã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Fraction &#123; ll up, down;&#125; f1, f2;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void printResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;f1.up, &amp;f1.down, &amp;f2.up, &amp;f2.down); //add printResult(f1); printf(" + "); printResult(f2); printf(" = "); printResult(Add(f1, f2)); putchar('\n'); //minu printResult(f1); printf(" - "); printResult(f2); printf(" = "); printResult(Minu(f1, f2)); putchar('\n'); //mult printResult(f1); printf(" * "); printResult(f2); printf(" = "); printResult(Mult(f1, f2)); putchar('\n'); //divide printResult(f1); printf(" / "); printResult(f2); printf(" = "); if(f2.up == 0) printf("Inf"); else printResult(Divide(f1, f2)); return 0;&#125; 1035 æ’å…¥ä¸Žå½’å¹¶Analysisé¢˜ç›®çš„æ„æ€æ¯”è¾ƒæ˜Žç¡®ï¼Œç»™å®šä¸¤ä¸ªåºåˆ—ï¼Œåˆ¤æ–­å±žäºŽå“ªä¸€ç§æŽ’åºï¼Œç„¶åŽè¾“å‡ºè¿™ä¸ªåºåˆ—åœ¨è¿™ç§æŽ’åºä¸‹çš„ä¸‹ä¸€è½®æŽ’åºç»“æžœã€‚ å¯¹ç»™å®šçš„åˆå§‹åºåˆ—ï¼ŒæŒ‰ç…§æ’å…¥æŽ’åºçš„è¿‡ç¨‹è¿›è¡Œæ¨¡æ‹Ÿï¼Œæ¯è½®æŽ’åºéƒ½ä¸Žç»™å®šçš„ä¸­é—´åºåˆ—è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœç›¸åŒå°±å±žäºŽInsertion Sortï¼Œå¦åˆ™å°±æ˜¯Merge Sortäº†ã€‚ åœ¨æ•´ä¸ªæŽ’åºå’Œæ¯”è¾ƒçš„è¿‡ç¨‹ä¸­ï¼Œå…ˆè¿›è¡Œæ¯”è¾ƒï¼Œåœ¨éœ€è¦è¾“å‡ºçš„æ—¶å€™å°±ä¸éœ€è¦å†è¿›è¡Œä¾æ¬¡æŽ’åºæ“ä½œï¼Œå¯ä»¥å‡å°‘ä¸€éƒ¨åˆ†çš„ä»£ç é‡ã€‚å¦å¤–ï¼Œé‡æ–°å†™å½’å¹¶æŽ’åºæ¯”è¾ƒéº»çƒ¦ï¼Œç›´æŽ¥ä½¿ç”¨sortå‡½æ•°æ¥æ¨¡æ‹Ÿå½’å¹¶æŽ’åºçš„è¿‡ç¨‹å°±æ¯”è¾ƒæ–¹ä¾¿ï¼Œè¦æ³¨æ„sortå‡½æ•°æ¯æ¬¡åªèƒ½æŽ’æŒ‡å®šé—´éš”å†…çš„æ•°å­—ã€‚æ‰€ä»¥é‡‡ç”¨min(i + step, n)çš„å†™æ³•é¿å…æœ€åŽä¸€æ¬¡æŽ’åºæ—¶å…ƒç´ ä¸ªæ•°ä½ŽäºŽå½’å¹¶é—´éš”çš„æƒ…å†µï¼Œå³å†æœ€åŽä¸€æ¬¡æŽ’åºè¿‡ç¨‹ä¸­ï¼ŒåªæŽ’å‰©ä¸‹çš„å…ƒç´ ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 5;int origin[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125; putchar('\n');&#125;bool InsertSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag == true) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;origin[i]); tempOri[i] = origin[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = origin[i]; &#125; MergeSort(); &#125; return 0;&#125; 1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹Analysisè¿™ç§æ‰“å°å›¾å½¢ç±»çš„é¢˜ç›®ä¸»è¦æ˜¯åœ¨æ‰¾è¾“å‡ºçš„ä½ç½®ï¼Œæ³¨æ„é¢˜ç›®ç»™å®šçš„æ˜¯å­—ç¬¦å˜é‡Cï¼Œè€Œä¸æ˜¯Cå­—ç¬¦ã€‚ Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int N, i, j; char C; scanf("%d %c", &amp;N, &amp;C); /*actually, you just need to find the place you want print */ for(i = 0; i &lt; (N + 1) / 2; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(i == 0 || i == (N - 1) / 2 || j == 0 || j == N - 1) putchar(C); else putchar(' '); &#125; putchar('\n'); &#125; return 0;&#125; 1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’±Analysisé¢˜ç›®æ„æ€å¾ˆç›´è§‚å°±æ˜¯æ‰¾é›¶é’±äº†ï¼Œåªä¸è¿‡åº¦é‡å•ä½ä¸ä¸€æ ·ï¼Œåœ¨è®¡ç®—çš„æ—¶å€™ï¼ŒæŒ‰ç…§ç»™å®šçš„é‡è¿›è¡Œè®¡ç®—å³å¯ã€‚æ³¨æ„ç”±äºŽï¼Œæœ¬é¢˜ä¸­é’±çš„å½¢å¼æœ‰ä¸‰æ ·ï¼Œæ‰€ä»¥åœ¨è®¡ç®—å‰å¾—å…ˆåˆ¤æ–­å¤§å°ï¼Œç„¶åŽè®©å¤§çš„å‡å°çš„ï¼Œè¿™æ ·è®¡ç®—èµ·æ¥å°±å¾ˆç®€å•äº†ï¼›å¦å¤–ï¼Œç›¸ç­‰çš„æ—¶å€™è¦ç‰¹åˆ¤è¾“å‡º0.0.0ã€‚ è¿™ä¸ªé¢˜ç›®ç›´æŽ¥å…ˆå…¨éƒ¨è½¬æ¢æˆ Knut ç„¶åŽå†è¿›è¡Œè®¡ç®—ï¼Œå¾—åˆ°ç»“æžœåŽå†è½¬æ¢å›žæ¥ä¼šæ›´ç®€å•ä¸€äº›ã€‚ Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;struct money &#123; int g, s, k;&#125; P, A, Result;bool Bigger(money a, money b);money Substract(money big, money small);int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;P.g, &amp;P.k, &amp;P.s, &amp;A.g, &amp;A.k, &amp;A.s); if(Bigger(P, A)) &#123; Result = Substract(P, A); if(!Result.g &amp;&amp; !Result.k &amp;&amp; !Result.s) printf("0.0.0\n"); else printf("-%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; else &#123; Result = Substract(A, P); printf("%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; return 0;&#125;bool Bigger(money a, money b) &#123; if(a.g != b.g) return a.g &gt;= b.g; else if(a.k != b.k) return a.k &gt;= b.k; else return a.s &gt;= b.s;&#125;money Substract(money big, money small) &#123; money ret; if(big.s &gt;= small.s) &#123; ret.s = big.s - small.s; &#125; else &#123; ret.s = big.s + 29 - small.s; big.k--; &#125; if(big.k &gt;= small.k) &#123; ret.k = big.k - small.k; &#125; else &#123; ret.k = big.k + 17 - small.k; big.g--; &#125; ret.g = big.g - small.g; return ret;&#125; version 2123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;int change2knut(int g, int s, int k) &#123; int res = k; s = s + g * 17; res = res + s * 29; return res;&#125;int main() &#123; int g, s, k, p, a; scanf("%d.%d.%d", &amp;g, &amp;s, &amp;k); p = change2knut(g, s, k); scanf("%d.%d.%d", &amp;g, &amp;s, &amp;k); a = change2knut(g, s, k); int ans = a - p; if(ans == 0) printf("0.0.0\n"); else &#123; int flag = 1; if(ans &lt; 0) &#123; ans = -ans; flag = 0; &#125; k = ans % 29; s = (ans / 29) % 17; g = ans / 29 / 17; if(!flag) printf("-"); printf("%d.%d.%d\n", g, s, k); &#125; return 0;&#125; 1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”ŸAnalysisè€ƒå¯ŸåŸºæœ¬æ•£åˆ—çš„æ€æƒ³ï¼Œå°†è¾“å…¥çš„åˆ†æ•°å€¼ä½œä¸ºæ•°ç»„ä¸‹æ ‡ï¼Œæ¯æ¬¡æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å°±å˜ä¸ºäº†ï¼š$O(1)$ã€‚ Code123456789101112131415161718#include &lt;cstdio&gt;int grade[101] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int N, K, temp; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;temp); grade[temp]++; &#125; scanf("%d", &amp;K); while(K--) &#123; scanf("%d", &amp;temp); printf("%d", grade[temp]); if(K &gt; 0) putchar(' '); &#125; return 0;&#125; 1039 åˆ°åº•ä¹°ä¸ä¹°Analysiså°†å­—ç¬¦å¸¸é‡ä½œä¸ºä¸‹æ ‡æ•£åˆ—åœ¨ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ä¸­ï¼Œå°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»Ÿè®¡ç å­çš„ä¸ªæ•°äº†ã€‚ä¹°ä¸Žä¸ä¹°å¯¹åº”ä¸¤ç§æƒ…å†µï¼š ä¹°ï¼Œå¤šä½™çš„ç å­æ•°ç›®å°±æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹å·® ä¸ä¹°ï¼ŒéåŽ†ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°æ¬¡æ•°æ¯”ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°æ¬¡æ•°å¤šçš„å­—ç¬¦ï¼Œå¹¶è®°å½•ä¸‹å…¶å·®å€¼ã€‚ Codeversion 112345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; version 2å…¶å®žè¿™ä¸ªé¢˜ï¼Œå®Œå…¨å¯ä»¥åªç”¨ä¸€ä¸ª hash æ•°ç»„æ¥å®Œæˆï¼Œå¦‚ä¸‹ï¼š12345678910111213141516171819#include &lt;iostream&gt;using namespace std;int hashtb[256] = &#123;0&#125;;int main() &#123; string a, b; cin &gt;&gt; a &gt;&gt; b; for(int i = 0; i &lt; a.length(); i++) &#123; hashtb[a[i]]++; &#125; int less = 0; for(int i = 0; i &lt; b.length(); i++) &#123; if(hashtb[b[i]] &gt; 0) hashtb[b[i]]--; else less++; &#125; if(less) cout &lt;&lt; "No " &lt;&lt; less; else cout &lt;&lt; "Yes " &lt;&lt; a.length() - b.length(); return 0;&#125; 1040 æœ‰å‡ ä¸ªPATAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªåªå«Pã€Aã€Tä¸‰ä¸ªå­—æ¯çš„å­—ç¬¦ä¸²ï¼ŒæŒ‰ç…§PATçš„é¡ºåºï¼Œåœ¨ä¸æ”¹å˜å­—ç¬¦ä¸²å†…å­—ç¬¦æŽ’åˆ—é¡ºåºçš„å‰æä¸‹ï¼Œæœ€å¤šèƒ½æœ‰å‡ ä¸ªPATè¿™æ ·çš„å­ä¸²ã€‚ æŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œæœ€å®¹æ˜“æƒ³åˆ°çš„æ€è·¯å°±æ˜¯åˆ©ç”¨ä¸‰ä¸ªå¾ªçŽ¯æš´åŠ›æžšä¸¾æ‰€æœ‰å¯èƒ½çš„å‡ºçŽ°æƒ…å†µï¼Œç„¶åŽç»Ÿè®¡ç¬¦åˆè¦æ±‚çš„æƒ…å†µï¼Œæœ€åŽåœ¨è¾“å‡ºã€‚ä½†è¿™æ ·ä¼šè¶…æ—¶ï¼Œæ‰€ä»¥éœ€è¦æ¢ä¸ªæ€è·¯ã€‚ å¯¹äºŽå­—ç¬¦ä¸²ä¸­ç¡®å®šä½ç½®çš„æ¯ä¸€ä¸ªAè€Œè¨€ï¼Œå…¶èƒ½å¤Ÿä¸ŽPã€Tç»„æˆPATçš„ä¸ªæ•°ï¼Œç­‰äºŽå…¶å·¦è¾¹Pçš„ä¸ªæ•°ä¹˜ä»¥å…¶å³è¾¹Tçš„ä¸ªæ•°ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªé—®é¢˜å°±å˜æˆäº†ï¼ŒéåŽ†å­—ç¬¦ä¸²æ—¶ï¼Œç´¯åŠ æ¯ä¸€ä¸ªAçš„å·¦è¾¹Pçš„ä¸ªæ•°ä¸Žå³è¾¹Tçš„ä¸ªæ•°çš„ä¹˜ç§¯ã€‚ é‚£ä¹ˆï¼Œå¦‚ä½•æ‰èƒ½è¾ƒå¿«çš„èŽ·å¾—Pçš„ä¸ªæ•°å‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ä¸€æ¬¡æ€§è®¡ç®—å‡ºå­—ç¬¦ä¸²ä¸­æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å·¦è¾¹Pçš„ä¸ªæ•°ã€‚ç›´æŽ¥ä»Žå·¦è‡³å³éåŽ†å­—ç¬¦ä¸²ï¼Œå¦‚æžœå½“å‰ä½æ˜¯Pï¼Œé‚£ä¹ˆæ­¤ä½ç½®çš„æ•°ç›®å°±æ˜¯å‰ä¸€ä½çš„æ•°ç›®åŠ 1ï¼›å¦‚æžœå½“å‰ä½ä¸æ˜¯Pï¼Œé‚£ä¹ˆæ­¤ä½ç½®çš„æ•°ç›®å°±æ˜¯å‰ä¸€ä½çš„æ•°ç›®ã€‚ è§£å†³äº†Pçš„é—®é¢˜ï¼ŒTæ€Žä¹ˆåŠžå‘¢ï¼Ÿå®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œä»Žå³å¾€å·¦éåŽ†å­—ç¬¦ä¸²ï¼ŒçŽ°åœ¨åªè€ƒè™‘ä¸¤ç§æƒ…å†µï¼š å½“å‰å­—ç¬¦ä¸ºTï¼Œå˜é‡åŠ  1ã€‚ å½“å‰å­—ç¬¦ä¸ºAï¼Œç»Ÿè®¡æ­¤ä½ç½®Aèƒ½ç»„æˆçš„å­ä¸²PATçš„æ•°ç›®ï¼ˆè®¡ç®—æ—¶åˆ«å¿˜äº†å–ä½™ï¼‰ï¼Œå†ç´¯åŠ ã€‚ éåŽ†ç»“æŸåŽï¼Œå°±å¯ä»¥ç›´æŽ¥è¾“å‡ºæ€»æ•°ç›®äº†ã€‚ Codeversion 11234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt; const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') &#123; leftNumP[i]++; &#125; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt;= 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; version 2å®žé™…ä¸Šï¼Œè¦æ±‚ A å·¦è¾¹ P çš„ä¸ªæ•°å…¶å®žå®Œå…¨å¯ä»¥ä¸ç”¨æ•°ç»„ï¼Œå¦‚æžœä¸ç”¨æ•°ç»„ï¼Œé‚£ä¹ˆå¦‚ä½•è®¡ç®— PAT çš„ä¸ªæ•°å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯ï¼Œå…ˆæŠŠ T çš„ä¸ªæ•°æ±‚å‡ºæ¥ã€‚æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼ŒæŠŠ T çš„ä¸ªæ•°æ±‚å‡ºæ¥åŽï¼Œæ¯é‡åˆ° P å°±è®°å½• P çš„ä¸ªæ•°ï¼Œé‡åˆ° T ä¹Ÿè®°å½• T çš„ä¸ªæ•°ï¼Œé‡åˆ° A å°±è®¡ç®— PAT çš„ä¸ªæ•°ï¼Œä½†æ˜¯è¦å‡åŽ»è®°å½•çš„ T çš„ä¸ªæ•°ï¼Œå› ä¸ºè¿™ä¸ª T çš„ä¸ªæ•°æ˜¯å½“å‰ A å‰é¢çš„ T çš„ä¸ªæ•°ï¼ŒäºŒè€…çš„å·®æ‰æ˜¯å½“å‰ A åŽé¢çš„ä¸ªæ•°ï¼Œæœ€åŽåˆ«å¿˜äº†å–ä½™ã€‚12345678910111213141516171819202122232425#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MOD 1000000007const int maxn = 100000 + 10;char str[maxn];int main() &#123; scanf("%s", str); int len = strlen(str), P_cnt = 0, t_cnt = 0, T_cnt = 0; long long sum = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'T') T_cnt++; &#125; for(int i = 0; i &lt; len; i++) &#123; if(str[i] == 'P') P_cnt++; else if(str[i] == 'T') t_cnt++; else if(str[i] == 'A') &#123; T_cnt -= t_cnt; t_cnt = 0; sum = (sum + (P_cnt * T_cnt)) % MOD; &#125; &#125; printf("%d", sum); return 0;&#125; å‚è€ƒé“¾æŽ¥ï¼š1040. æœ‰å‡ ä¸ªPATï¼ˆ25ï¼‰-PATä¹™çº§çœŸé¢˜ version 3è¿™ä¸ªé¢˜å…¶å®žè¿˜æœ‰æ›´ç›´è§‚çš„æ€è·¯ï¼š æ¯ä¸ª A å¯¹åº”çš„ PA ç»„åˆæ˜¯ A ä¹‹å‰ P çš„æ•°é‡ã€‚ æ¯ä¸ª T å¯¹åº”çš„ PAT ç»„åˆæ˜¯ T ä¹‹å‰æ‰€æœ‰ A å¯¹åº”çš„ PA ç»„åˆæ•°é‡çš„ç´¯åŠ ã€‚ æ‰€æœ‰ PAT ç»„åˆæ•°é‡æ˜¯æ‰€æœ‰ T å¯¹åº”çš„ PAT ç»„åˆæ•°é‡çš„ç´¯åŠ ã€‚ ä»Žè€Œï¼Œå°±å¯ä»¥å¾—åˆ°ï¼š123456789101112131415#include &lt;iostream&gt;#define mod 1000000007using namespace std;int main() &#123; int p = 0, pa = 0, pat = 0; char c; while((c = getchar()) != EOF &amp;&amp; c != '\n') &#123; if(c == 'P') p++; if(c == 'A') pa = (pa + p) % mod; if(c == 'T') pat = (pat + pa) % mod; &#125; cout &lt;&lt; pat; return 0;&#125; å‚è€ƒé“¾æŽ¥ï¼šPAT Basic 1040. æœ‰å‡ ä¸ªPAT (25) (Cè¯­è¨€å®žçŽ°) 1041 è€ƒè¯•åº§ä½å·Analysisç”±äºŽæœ€åŽè¦è¾“å‡ºå‡†è€ƒè¯å·ï¼Œæ‰€ä»¥æ¯æ¬¡è¾“å…¥éƒ½å¿…é¡»ä¿å­˜è¾“å…¥çš„å‡†è€ƒè¯å·ç­‰ä¿¡æ¯ã€‚è¿™æ ·çš„è¯ï¼Œä½¿ç”¨ç»“æž„ä½“æ•°ç»„æ— ç–‘æ˜¯ä¸€ç§å¾ˆæ–¹ä¾¿çš„é€‰æ‹©ï¼Œä¹‹åŽå†éåŽ†ç»“æž„ä½“æ•°ç»„è¾“å‡ºç¬¦åˆæ¡ä»¶çš„ä¿¡æ¯å³å¯ï¼Œ Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct examinee_info&#123; char number[17]; int test_seat; int exam_seat;&#125; Examinee_Info[1005];int main(int argc, char const *argv[]) &#123; int N, M, i, temp; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", Examinee_Info[i].number, &amp;Examinee_Info[i].test_seat, &amp;Examinee_Info[i].exam_seat); &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;temp); for(i = 0; i &lt; N; i++) &#123; if(temp == Examinee_Info[i].test_seat) &#123; printf("%s %d\n", Examinee_Info[i].number, Examinee_Info[i].exam_seat); &#125; &#125; &#125; return 0;&#125; 1042 å­—ç¬¦ç»Ÿè®¡Analysisåˆ©ç”¨æ•°ç»„ç»Ÿè®¡æ¯ä¸ªè‹±æ–‡å­—ç¬¦ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰çš„å‡ºçŽ°æ¬¡æ•°ï¼Œç›´æŽ¥ä½¿ç”¨å­—ç¬¦å˜é‡ï¼ˆASCII ç å€¼ï¼‰ä½œä¸ºä¸‹æ ‡ä¼šå¾ˆæ–¹ä¾¿ï¼ŒåŒæ—¶å¾—åˆ°å‡ºçŽ°çš„æœ€å¤§æ¬¡æ•°ã€‚è¾“å‡ºæ—¶ï¼ŒéåŽ†ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ï¼Œåªè¾“å‡ºå­—å…¸åºæœ€å°çš„å­—æ¯å³å¯ã€‚ Code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 1000 + 5;int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); int times[27] = &#123;0&#125;, maxtimes = -1; for(int i = 0; str[i] != '\0'; i++) &#123; char c1 = str[i]; if(isalpha(c1)) &#123; if(isupper(c1)) c1 = tolower(c1); times[c1 - 'a']++; if(times[c1 - 'a'] &gt; maxtimes) &#123; maxtimes = times[c1 - 'a']; &#125; &#125; &#125; for(int i = 0; i &lt; 27; i++) &#123; if(maxtimes == times[i]) &#123; printf("%c %d\n", i + 'a', times[i]); break; &#125; &#125; return 0;&#125; 1043 è¾“å‡ºPATestAnalysiså…ˆç»Ÿè®¡å­—ç¬¦ä¸²ä¸­PATestè¿™å…­ä¸ªå­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼Œç„¶åŽä¾æ¬¡è¾“å‡ºPATestï¼Œæ³¨æ„å½“å…¶ä¸­æŸä¸ªå­—ç¬¦è¾“å‡ºå®ŒåŽï¼Œä»ç„¶è¦ä¿æŒPATestè¿™ä¸ªé¡ºåºæ¥è¾“å‡ºå­—ç¬¦ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int MAXN = 10000 + 5;char PATest[10] = "PATest";int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['P'] || times['A'] || times['T'] || times['e'] || times['s'] || times['t']) &#123; for(p = PATest; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1044 ç«æ˜Ÿæ•°å­—Analysisé¢˜ç›®ç»™å‡ºäº†ç«æ˜Ÿä¸Šçš„æ•°ä½è§„åˆ™ï¼Œè¦æ±‚å°†åè¿›åˆ¶æ•°è½¬æ¢ä¸ºç«æ˜Ÿæ•°å­—å¹¶è¾“å‡ºã€‚å°½ç®¡ç«æ˜Ÿä¸Šæ¯ä¸€ä½æ•°è¾“å‡ºçš„å½¢å¼ä¸ä¸€æ ·ï¼Œä½†å…¶æœ¬è´¨æ˜¯13è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æŒ‰ç…§è¿™ä¸ªè§„åˆ™è¿›è¡Œå³å¯ã€‚ ç”±äºŽæ•´ä¸ªèŒƒå›´çš„æ•°å­—æœ‰169ä¸ªï¼Œæ‰€ä»¥æå‰å°†æ‰€æœ‰éœ€è¦è¾“å‡ºçš„æ•°å­—å…¨éƒ¨æ‰“å°å¥½ï¼Œä¹‹åŽç›´æŽ¥è¾“å‡ºæ¯”è¾ƒå¥½ã€‚ä¸ºæ­¤ï¼Œéœ€è¦å€ŸåŠ© C++ çš„stringå’Œmapï¼Œæ¥åˆ†åˆ«å»ºç«‹æ•°å­—å¯¹åº”å­—ç¬¦ä¸²ã€å­—ç¬¦ä¸²å¯¹åº”æ•°å­—çš„æ˜ å°„æ•°ç»„ã€‚ æ³¨æ„ï¼šè¾“å…¥13æ—¶ï¼Œéœ€è¦è¾“å‡ºtamï¼Œè€Œä¸æ˜¯tam tretã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const *argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); //get the extra ' ' from stdin while(n--) &#123; string s; getline(cin, s); if('0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; s.length(); i++) &#123; num = num * 10 + s[i] - '0'; &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[s] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; //string concatenation string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1045 å¿«é€ŸæŽ’åºAnalysisé¢˜ç›®çš„èƒŒæ™¯æ˜¯å¿«é€ŸæŽ’åºç®—æ³•å†…çš„ä¸€äº›æ¦‚å¿µï¼Œå·²ç»ç»™å‡ºäº†æè¿°ï¼Œæ‰€ä»¥ä½†ä¸å½±å“è¯»é¢˜ã€‚ä¾æ®é¢˜ç›®çš„ä¾‹å­ï¼Œå¯ä»¥å¾—åˆ°ä¸»å…ƒçš„ç‰¹ç‚¹ï¼š ä¸»å…ƒå·¦è¾¹çš„æ•°å­—å…¨éƒ¨æ¯”å®ƒå°ï¼Œå³æœ€å¤§å€¼å°äºŽå®ƒ ä¸»å…ƒå³è¾¹çš„æ•°å­—å…¨éƒ¨æ¯”å®ƒå¤§ï¼Œå³æœ€å°å€¼å¤§äºŽå®ƒ æŒ‰ç…§ä¸Šè¿°åˆ†æžï¼Œä¾æ¬¡æžšä¸¾æ•°ç»„å†…æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æžœæ¯æ¬¡éƒ½åŽ»æŸ¥æ‰¾å½“å‰å…ƒç´ çš„æœ€å€¼ï¼Œä¼šå¾ˆè€—æ—¶é—´ã€‚æ‰€ä»¥ï¼Œè¦æ¢ä¸€ä¸ªè§’åº¦åŽ»æ€è€ƒé—®é¢˜ã€‚ å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼Œä¸€æ¬¡æ€§å°†æ‰€æœ‰æ•°å­—å·¦è¾¹çš„æœ€å°å€¼å…¨éƒ¨è®¡ç®—å‡ºæ¥ï¼Œæ¯æ¬¡æžšä¸¾æ—¶ï¼Œå°±åªç”¨å’Œå‰ä¸€ä¸ªæ•°å­—æœ€å·¦è¾¹çš„æœ€å°å€¼è¿›è¡Œæ¯”è¾ƒï¼Œæ‰¾æœ€å¤§å€¼æ—¶åŒç†ã€‚ æœ€åŽåœ¨éåŽ†ä¸€æ¬¡æ•°ç»„ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æ•°åŽç›´æŽ¥è¾“å‡ºå³å¯ã€‚ Codeversion 1è¿™ç§è®°å½•â€œçŠ¶æ€â€çš„å†™æ³•ï¼Œå¾ˆæœ‰ç”¨ã€‚1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;const int INF = 0x3fffffff;int array[MAXN], leftMax[MAXN], rightMin[MAXN];int ans[MAXN], num = 0;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftMax[0] = 0; for(int i = 1; i &lt; N; i++) &#123; leftMax[i] = max(leftMax[i - 1], array[i - 1]); &#125; rightMin[N - 1] = INF; for(int i = N - 2; i &gt;= 0; i--) &#123; rightMin[i] = min(rightMin[i + 1], array[i + 1]); &#125; for(int i = 0; i &lt; N; i++) &#123; if(leftMax[i] &lt; array[i] &amp;&amp; rightMin[i] &gt; array[i]) &#123; ans[num++] = array[i]; &#125; &#125; printf("%d\n", num); for(int i = 0; i &lt; num; i++) &#123; printf("%d", ans[i]); if(i &lt; num - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; version 2ä¸€èˆ¬è€Œè¨€ï¼Œè¿™ä¸ªé¢˜æœ€å®¹æ˜“æƒ³åˆ°çš„æ€è·¯åº”è¯¥å°±æ˜¯æŽ’åºï¼ŒæŽ’åºä¹‹åŽï¼Œå¦‚æžœå…ƒç´ ä½ç½®æ²¡æœ‰æ”¹å˜å°±å¯ä»¥ç¡®å®šè¿™ä¸ªå…ƒç´ æ˜¯ä¸»å…ƒã€‚ä½†å®žé™…ä¸Šï¼Œè¿™ç§æ€è·¯å…¶å®žåªç¡®å®šäº†ä¸€ä¸ªæ¡ä»¶ï¼Œé‚£å°±æ˜¯è¿™ä¸ªå…ƒç´ å³è¾¹å¿…ç„¶æ²¡æœ‰å…ƒç´ å°äºŽå®ƒï¼Œæ¢å¥è¯è®²ï¼Œå°±æ˜¯è¿™ä¸ªå…ƒç´ å³è¾¹æœ€å°å€¼å¤§äºŽå®ƒï¼Œè¿™å¯ä»¥ä»Žåè¯æ³•çš„è§’åº¦æ¥è¯æ˜Žã€‚é‚£ä¹ˆï¼Œå‰©ä¸‹è¦è§£å†³çš„é—®é¢˜å°±æ˜¯ï¼Œè¿™ä¸ªå…ƒç´ çš„å·¦è¾¹çš„æœ€å¤§å€¼æ˜¯å¦å°äºŽå®ƒï¼Œè¿™ä¸ªåˆ¤æ–­ä¹Ÿå¾ˆç®€å•ã€‚å…·ä½“å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, arr[maxn] = &#123;0&#125;, tmp[maxn], ans[maxn] = &#123;0&#125;;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; arr[i]; tmp[i] = arr[i]; &#125; sort(tmp, tmp + n); int cnt = 0, max = 0; for(int i = 1; i &lt;= n; i++) &#123; if(arr[i] == tmp[i] &amp;&amp; max &lt; arr[i]) ans[cnt++] = arr[i]; if(arr[i] &gt; max) max = arr[i]; &#125; cout &lt;&lt; cnt &lt;&lt; endl; if(cnt) &#123; for(int i = 0; i &lt; cnt; i++) &#123; cout &lt;&lt; ans[i]; if(i != cnt - 1) cout &lt;&lt; ' '; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 1046 åˆ’æ‹³Analysisæ³¨æ„è¯»é¢˜ï¼Œç†è§£é¢˜ç›®æ„æ€åŽå°±å¥½åŠžäº†ã€‚å¦å¤–æ³¨æ„ï¼Œè¾“å®¶ç½šä¸€æ¯é…’ï¼Œç”²è‹¥è¾“äº†ï¼Œç”²å–ä¸€æ¯ï¼Œä¹™ä¸å–ï¼›åŒèµ¢æˆ–åŒè¾“éƒ½ä¸å–ã€‚ Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a, b, c, d, countA = 0, countB = 0; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if(a + c == b &amp;&amp; a + c == d) continue; // all win else if(a + c != b &amp;&amp; a + c != d) continue; // all lose else if(a + c == b) countB++; // A win else countA++; // B win &#125; cout &lt;&lt; countA &lt;&lt; ' ' &lt;&lt; countB; return 0;&#125; 1047 ç¼–ç¨‹å›¢ä½“èµ›Analysisç»Ÿè®¡æ¯æ”¯é˜Ÿä¼çš„æ€»åˆ†ï¼Œç„¶åŽæ‰¾å‡ºæ€»åˆ†çš„æœ€å¤§å€¼ï¼Œå³å¯å¾—åˆ°å† å†›é˜Ÿçš„ç¼–å·ã€‚ç„¶åŽï¼Œè¾“å‡ºå† å†›é˜Ÿçš„ç¼–å·å’Œæ€»æˆç»©ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int N, team, score[1010] = &#123;0&#125;, eachScore, maxteam = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%d-%*d %d", &amp;team, &amp;eachScore); score[team] += eachScore; if(team &gt; maxteam) &#123; maxteam = team; &#125; &#125; int maxscore = -1, index = 0; for(int i = 1; i &lt;= maxteam; i++) &#123; if(score[i] &gt; maxscore) &#123; maxscore = score[i]; index = i; &#125; &#125; printf("%d %d", index, maxscore); return 0;&#125; 1048 æ•°å­—åŠ å¯†Analysisé¢˜ç›®æ„æ€ç®€å•ï¼Œåšæ³•ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯æœ‰é™·é˜±ðŸ¤©ï¼Œå³ï¼šè‹¥æ˜¯Bçš„ä½æ•°å°‘äºŽåŠ å¯†å¯†é’¥çš„ä½æ•°ï¼Œéœ€è¦å‡è®¾Bçš„å½“å‰ä½ä¸Šçš„æ•°å­—æ˜¯0ç„¶åŽå‚ä¸Žè®¡ç®—ï¼ˆæ³¨æ„å¥‡å¶ä½ä¸åŒï¼‰å³å¯ã€‚ ä¸€å¼€å§‹å·æ‡’ï¼Œä»¥ä¸ºçŸ­å°±çŸ­å§ï¼ŒåªåŠ å¯†åˆ°éœ€è¦åŠ å¯†çš„ä½æ•°å°±è¡Œäº†ï¼Œç»“æžœæœ‰ä¸¤ä¸ªæµ‹è¯•ç‚¹æ— æ³•é€šè¿‡ï¼Œçœ‹æ¥è¿˜æ˜¯é¢˜æ„ç†è§£çš„ä¸å¤Ÿæ·±å…¥ã€‚ å¦å¤–ï¼Œç”±äºŽè¾“å…¥åŽï¼Œæ•°å­—çš„ä¸ªä½åœ¨å­—ç¬¦ä¸²æœ€åŽä¸€ä½ï¼Œæ‰€ä»¥éœ€è¦é€†ç½®ä¸€ä¸‹ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100 + 5;char change[14] = "0123456789JQK";void Reverse(char *s);int main(int argc, char const *argv[]) &#123; char A[MAXN], B[MAXN], Result[MAXN]; scanf("%s %s", A, B); Reverse(A); Reverse(B); int i, lenA = strlen(A), lenB = strlen(B), len; len = lenA &gt; lenB ? lenA : lenB; for(i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? A[i] - '0' : 0; int numB = i &lt; lenB ? B[i] - '0' : 0; if(i % 2 == 0) &#123; int sum = numA + numB; Result[i] = change[sum % 13]; &#125; else &#123; int diff = numB - numA; if(diff &lt; 0) &#123; diff += 10; &#125; Result[i] = change[diff]; &#125; &#125; Result[i] = '\0'; Reverse(Result); puts(Result); return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1049 æ•°åˆ—çš„ç‰‡æ®µå’ŒAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•°åˆ—ï¼Œè®¡ç®—å…¶æ‰€æœ‰æŒ‰åºæŽ’åˆ—çš„å­åˆ—å’Œï¼Œç›´æŽ¥åšä¼šè¶…æ—¶ï¼Œéœ€è¦æ‰¾è§„å¾‹ã€‚åˆ—ä¸¾å‡º$N$åˆ†åˆ«å–3ã€4ã€5æ—¶ï¼Œå…¶å’Œï¼ˆ$Sum$ï¼‰æƒ…å†µå¦‚ä¸‹ï¼š $N$ $Sum$ 3 $3 \times a_1 + 4 \times a_2 + 3 \times a_3$ 4 $4 \times a_1 + 6 \times a_2 + 6 \times a_3 + 4 \times a_4$ 5 $5 \times a_1 + 8 \times a_2 + 9 \times a_3 + 8 \times a_4 + 5 \times a_5$ äºŽæ˜¯å¯ä»¥æŽ¨å‡ºè§„å¾‹ä¸ºï¼šé¦–é¡¹å’Œå°¾é¡¹ä¹˜ä»¥é¡¹æ•°ç›¸åŠ ï¼Œä¸­é—´æ¯é¡¹å…¶å·¦ã€å³ä¸¤è¾¹é¡¹æ•°ä¹‹ç§¯ï¼ˆåŒ…å«å®ƒè‡ªèº«ï¼‰ã€‚ ä¿®æ­£æµ‹è¯•æ•°æ®åŽï¼Œåœ¨ç³»æ•°ç›¸ä¹˜çš„è¿‡ç¨‹ä¸­ï¼Œä¼šå‡ºçŽ°æº¢å‡ºçš„æƒ…å†µï¼Œè§£å†³åŠžæ³•æ˜¯ç”¨long longæ¥ä»£æ›¿doubleï¼Œå†é™¤ä»¥ 1000 æ¥å¾—åˆ°æœ€åŽçš„ç»“æžœã€‚ Codeversion 1.0123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(int i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; version 2.0123456789101112131415#include &lt;cstdio&gt;const int maxn = 100000 + 5;int n; int main() &#123; scanf("%d", &amp;n); double tmp; long long ans = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%lf", &amp;tmp); ans += (long long)(tmp * 1000) * (long long)i * (long long)(n - i + 1); &#125; printf("%.2lf\n", ans/1000.0); return 0;&#125; 1050 èžºæ—‹çŸ©é˜µAnalysisè¿™ä¸ªé¢˜æ˜¯ä¸ªæ¯”è¾ƒä¸­ç­‰çš„æ¨¡æ‹Ÿé¢˜ï¼Œç±»ä¼¼çš„é¢˜ç›®å…¶å®žæœ‰å¾ˆå¤šï¼Œéš¾ç‚¹åœ¨äºŽè¾“å‡ºé¡ºåºçš„ç¡®å®šï¼Œä¹Ÿå°±æ˜¯æ•°ç»„çš„ä¸‹æ ‡å¯¹åº”å…³ç³»ã€‚å…ˆå°†ç»™å®šçš„æ•°å­—é™åºæŽ’åˆ—ï¼Œç„¶åŽä¸€ä¸ªä¸€ä¸ªè¯»åˆ°çŸ©é˜µä¸­ã€‚æ­¤æ—¶ï¼Œè®¾ç½® 4 ä¸ªå˜é‡ï¼Œåˆ†åˆ«ä»£è¡¨ä¸Šè¾¹ç•Œã€ä¸‹è¾¹ç•Œã€å·¦è¾¹ç•Œå’Œå³è¾¹ç•Œï¼Œè¿™æ ·å°±å¯ä»¥ç”¨ 4 ä¸ªå¾ªçŽ¯æŒ‰ç…§é¢˜ç›®è¦æ±‚çš„é¡ºåºæ”¾å…¥å¯¹åº”çš„æ•°å­—äº†ã€‚æ³¨æ„ï¼Œæœ€åŽä¸€ä¸ªæ•°å­—è¦å•ç‹¬å¤„ç†ã€‚å•ç‹¬å¤„ç†å¹¶ä¸æ˜¯è¯´æ¯ç§æƒ…å†µæœ€åŽä¸€ä¸ªæ•°å­—éƒ½æ˜¯è¿™æ ·å¤„ç†ï¼Œè€Œæ˜¯ä¸ºäº†é¿å…æŸäº›æƒ…å†µä¼šé™·å…¥æ­»å¾ªçŽ¯ä¸­ã€‚æ¯”å¦‚å½“ n å– 9 æ—¶ï¼Œæœ€åŽä¸€ä¸ªæ•°å­—å¦‚æžœä¸å•ç‹¬å¤„ç†å°±ä¼šæ­»å¾ªçŽ¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;int N, num[MAXN], m, n, matrix[MAXN][MAXN];bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;num[i]); &#125; if(N == 1) &#123; printf("%d", num[0]); return 0; &#125; sort(num, num + N, cmp); m = (int)ceil(sqrt(N * 1.0)); while(N % m != 0) m++; n = N / m; int i = 1, j = 1, now = 0; int U = 1, D = m, L = 1, R = n; while(now &lt; N) &#123; while(now &lt; N &amp;&amp; j &lt; R) &#123; matrix[i][j] = num[now++]; j++; &#125; while(now &lt; N &amp;&amp; i &lt; D) &#123; matrix[i][j] = num[now++]; i++; &#125; while(now &lt; N &amp;&amp; j &gt; L) &#123; matrix[i][j] = num[now++]; j--; &#125; while(now &lt; N &amp;&amp; i &gt; U) &#123; matrix[i][j] = num[now++]; i--; &#125; U++, D--, L++, R--; i++, j++; if(now == N - 1) &#123; matrix[i][j] = num[now++]; &#125; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; printf("%d", matrix[i][j]); if(j &lt; n) printf(" "); else printf("\n"); &#125; &#125; return 0;&#125; 1051 å¤æ•°ä¹˜æ³•Analysisæ­¤é¢˜ä¸éš¾ï¼Œå±žäºŽâ€œçº¸è€è™Žâ€ï¼Œä¸è¿‡æ‰¾ç‰¹æ®Šæƒ…å†µå¾ˆæ˜¯çƒ¦äººçš„ðŸ˜…~æ³¨æ„è®¡ç®—å¾—åˆ°çš„å°äºŽ -0.01 çš„ä¼šè¢«ä¿ç•™ 2 ä½æœ‰æ•ˆæ•°å­—çš„printfè¾“å‡ºæˆ-0.00ã€‚ Code12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(int argc, char const *argv[]) &#123; double R1, P1, R2, P2, R, P; scanf("%lf %lf %lf %lf", &amp;R1, &amp;P1, &amp;R2, &amp;P2); R = R1 * R2 * (cos(P1) * cos(P2) - sin(P1) * sin(P2)); P = R1 * R2 * (cos(P1) * sin(P2) + sin(P1) * cos(P2)); //prevent to print "-0.00" if(-0.01 &lt; R &amp;&amp; R &lt; 0) R = 0.0; if(-0.01 &lt; P &amp;&amp; P &lt; 0) P = 0.0; printf("%.2lf", R); if(P &gt;= 0) &#123; printf("+%.2lfi\n", P); &#125; else &#123; printf("-%.2lfi\n", fabs(P)); &#125; return 0;&#125; 1052 å–ä¸ªèŒAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹å‘çˆ¹ï¼Œé¢˜æ„ä¹Ÿä¸ç®—éš¾ç†è§£ï¼Œå°±æ˜¯æŒ‰ç…§ç»™å®šçš„è¾“å…¥æ ·ä¾‹ï¼Œå¯èƒ½æ— æ³•å¾—åˆ°ç»™å®šçš„è¾“å‡ºæ ·ä¾‹ï¼Œæ€»æ˜¯ç»™äººæ„Ÿè§‰å¥½åƒåšé”™äº†ã€‚å®žé™…ä¸Šï¼Œæ ·ä¾‹å†…æœ‰äº›å­—ç¬¦çš„ä¸æ˜¯ ASCII ç¼–ç ï¼Œæ‰€ä»¥æ²¡æ³•æ­£å¸¸çš„è¾“å‡ºã€‚æ‰€ä»¥ï¼ŒçœŸè¦æ˜¯åœ¨è€ƒè¯•çš„æ—¶å€™é‡åˆ°è¿™æ ·çš„æƒ…å†µï¼Œåªèƒ½é€šè¿‡å­—ç¬¦çš„ä¸ªæ•°æ¥çŒœï¼Œæœ‰æ²¡æœ‰èŽ·å¾—éœ€è¦çš„å­—ç¬¦ã€‚ æ˜Žç™½äº†ä»¥ä¸Šæƒ…å†µåŽï¼Œå†å›žåˆ°è¿™é“é¢˜ä¸Šï¼Œå¯ä»¥å‘çŽ°ï¼Œé¢˜ç›®æƒ³è®©æˆ‘ä»¬åšçš„äº‹æƒ…ï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å°†å­—ç¬¦æ‹¼åœ¨ä¸€èµ·ï¼Œç„¶åŽè¾“å‡ºå°±è¡Œäº†ã€‚è¦è¾“å‡ºçš„å­—ç¬¦æ˜¯é¢˜ç›®ç»™å®šçš„ï¼Œå¯èƒ½ä¼šç»™ä¸å­˜åœ¨çš„å­—ç¬¦ï¼Œè¿™æ—¶è¾“å‡ºAre you kidding me? @\/@å³å¯ã€‚å¦å¤–ï¼Œè¿˜æœ‰å‡ ä¸ªæ³¨æ„ç‚¹ï¼š è¦è¾“å‡º\å¿…é¡»ä½¿ç”¨&quot;\\&quot;ï¼Œä¹Ÿå°±æ˜¯è½¬ä¹‰ã€‚ ä¸å­˜åœ¨æŸç§å­—ç¬¦æ—¶ï¼Œç›´æŽ¥è¾“å‡ºAre you kidding me? @\/@ã€‚ ç”±äºŽç»™å®šçš„å­—ç¬¦ä¸²æœ‰ç©ºæ ¼çš„å­˜åœ¨ï¼Œæ‰€ä»¥ä½¿ç”¨getlineæ¥ç›´æŽ¥è¯»å–ä¸€è¡Œå­—ç¬¦ä¸²ã€‚ åˆ«å¿˜è®°äº†è¿˜è¦ç»™æœ€ç»ˆç»“æžœåŠ æ‹¬å·ï¼š(å’Œ)ã€‚ Codeversion 1è¿™ä¸ªç‰ˆæœ¬æ˜¯è‡ªå·±å†™çš„ï¼Œåˆ©ç”¨vector&lt;char&gt;æ¥å‚¨å­˜å¤„ç†å­—ç¬¦ï¼Œä»£ç å†™çš„æ¯”è¾ƒç¹çï¼Œå¾ˆå¤šå…¶å®žéƒ½æ˜¯é‡å¤çš„éƒ¨åˆ†ã€‚å†™çš„æ—¶å€™ï¼Œæƒ³çš„æ˜¯èƒ½ AC å°±è¡Œäº†ï¼Œä¹‹åŽå†æ”¹ï¼Œç»“æžœçŽ°åœ¨ä¹Ÿæ‡’å¾—æ”¹äº†ï¼Œå¥è¿™æ ·å§ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;char&gt; hands[11], eyes[11], mouth[11], emo;string temp;int arr[6];int main() &#123; for(int i = 1; i &lt;= 3; i++) &#123; getline(cin, temp); int j, k, cnt = 1; if(i == 1) &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; hands[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; else if(i == 2) &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; eyes[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; else &#123; for(j = 0; j &lt; temp.length(); j++) &#123; if(temp[j] == '[') &#123; for(k = j + 1; temp[k] != ']'; k++) &#123; mouth[cnt].push_back(temp[k]); &#125; cnt++; j = k; &#125; &#125; &#125; &#125; int k, tmp; cin &gt;&gt; k; while(k--) &#123; bool flag = true; emo.clear(); for(int i = 0; i &lt; 5; i++) &#123; cin &gt;&gt; arr[i]; &#125; if(hands[arr[0]].size() == 0 || eyes[arr[1]].size() == 0 || mouth[arr[2]].size() == 0 \ || eyes[arr[3]].size() == 0 || hands[arr[4]].size() == 0) &#123; printf("Are you kidding me? @\\/@\n"); continue; &#125; for(vector&lt;char&gt;::iterator it = hands[arr[0]].begin(); it != hands[arr[0]].end(); it++) &#123; emo.push_back(*it); &#125; emo.push_back('('); for(vector&lt;char&gt;::iterator it = eyes[arr[1]].begin(); it != eyes[arr[1]].end(); it++) &#123; emo.push_back(*it); &#125; for(vector&lt;char&gt;::iterator it = mouth[arr[2]].begin(); it != mouth[arr[2]].end(); it++) &#123; emo.push_back(*it); &#125; for(vector&lt;char&gt;::iterator it = eyes[arr[3]].begin(); it != eyes[arr[3]].end(); it++) &#123; emo.push_back(*it); &#125; emo.push_back(')'); for(vector&lt;char&gt;::iterator it = hands[arr[4]].begin(); it != hands[arr[4]].end(); it++) &#123; emo.push_back(*it); &#125; for(int i = 0; i &lt; emo.size(); i++) &#123; cout &lt;&lt; emo[i]; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; version 2è¿™ä¸ªç‰ˆæœ¬æ¥è‡ªï¼š1052. å–ä¸ªèŒ (20)-PATä¹™çº§çœŸé¢˜ï¼Œç”¨çš„æ˜¯vector&lt;string&gt;ï¼Œæœ¬è´¨ä¸Šä¸Žè‡ªå·±çš„æ€è·¯æ˜¯ä¸€æ ·çš„ï¼Œä¸è¿‡ä»£ç æ¸…çˆ½äº†è®¸å¤šã€‚123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main() &#123; vector&lt;vector&lt;string&gt; &gt; v; for(int i = 0; i &lt; 3; i++) &#123; string s; getline(cin, s); vector&lt;string&gt; row; int j = 0, k = 0; while(j &lt; s.length()) &#123; if(s[j] == '[') &#123; while(k++ &lt; s.length()) &#123; if(s[k] == ']') &#123; row.push_back(s.substr(j+1, k-j-1)); break; &#125; &#125; &#125; j++; &#125; v.push_back(row); &#125; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; int a, b, c, d, e; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; e; if(a &gt; v[0].size() || b &gt; v[1].size() || c &gt; v[2].size() || d &gt; v[1].size() || e &gt; v[0].size() || a &lt; 1 || b &lt; 1 || c &lt; 1 || d &lt; 1 || e &lt; 1) &#123; cout &lt;&lt; "Are you kidding me? @\\/@" &lt;&lt; endl; continue; &#125; cout &lt;&lt; v[0][a-1] &lt;&lt; "(" &lt;&lt; v[1][b-1] &lt;&lt; v[2][c-1] &lt;&lt; v[1][d-1] &lt;&lt; ")" &lt;&lt; v[0][e-1] &lt;&lt; endl; &#125; return 0;&#125; version 3è¿™ä¸ªç‰ˆæœ¬æ¥è‡ªï¼šPAT Basic 1052. å–ä¸ªèŒ (20)ï¼ˆCè¯­è¨€å®žçŽ°ï¼‰ï¼Œåˆ©ç”¨scanfçš„ç‰¹æ€§æ¥ç›´æŽ¥å¾—åˆ°æƒ³è¦çš„ä¸œè¥¿ï¼Œè¿™ä¸ªæ“ä½œå¾ˆç²¾å½©ï¼Œè¿˜æœ‰ 3 ç»´æ•°ç»„çš„ä½¿ç”¨ï¼Œä¹Ÿéœ€è¦å­¦ä¹ ä¸€ä¸‹ã€‚å°±æ ¹æœ¬æ¥è®²ï¼Œç”¨ 3 ç»´çš„vector&lt;char&gt;åº”è¯¥ä¹Ÿå¯ä»¥å¾—åˆ°è¿™æ ·çš„æ•ˆæžœã€‚1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() &#123; int N, m[5]; char c, symbols[3][10][5] = &#123;0&#125;; for(int symbol = 0; symbol &lt; 3; symbol++) for(int index = 0; (c = getchar()) != '\n'; ) if(c == '[') scanf("%[^]]", symbols[symbol][index++]); scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; for(int i = 0; i &lt; 5; i++) scanf("%d", m + i); if(m[0] &gt; 0 &amp;&amp; m[0] &lt;= 10 &amp;&amp; *symbols[0][--m[0]] &amp;&amp; m[1] &gt; 0 &amp;&amp; m[1] &lt;= 10 &amp;&amp; *symbols[1][--m[1]] &amp;&amp; m[2] &gt; 0 &amp;&amp; m[2] &lt;= 10 &amp;&amp; *symbols[2][--m[2]] &amp;&amp; m[3] &gt; 0 &amp;&amp; m[3] &lt;= 10 &amp;&amp; *symbols[1][--m[3]] &amp;&amp; m[4] &gt; 0 &amp;&amp; m[4] &lt;= 10 &amp;&amp; *symbols[0][--m[4]]) printf("%s(%s%s%s)%s\n", symbols[0][m[0]], symbols[1][m[1]], symbols[2][m[2]], symbols[1][m[3]], symbols[0][m[4]]); else puts("Are you kidding me? @\\/@"); &#125; return 0;&#125; 1053 ä½æˆ¿ç©ºç½®çŽ‡AnalysisæŒ‰ç…§é¢˜ç›®ç»™å®šçš„æ¡ä»¶è¿›è¡Œè®¡ç®—å³å¯ï¼Œä½†è¦æ³¨æ„ç¬¬äºŒä¸ªæ¡ä»¶éœ€è¦è§‚å¯ŸæœŸ K å¤§äºŽç»™å®šé˜ˆå€¼ Dã€‚å¦å¤–ï¼Œè¿˜éœ€æ³¨æ„æµ®ç‚¹æ•°çš„è®¡ç®—å’Œç™¾åˆ†å·çš„è¾“å‡ºã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;int N, D;double e;int main() &#123; scanf("%d %lf %d", &amp;N, &amp;e, &amp;D); int empty = 0, possible = 0, tmp = N; while(tmp--) &#123; int k, half = 0; scanf("%d", &amp;k); double days[k]; for(int i = 0; i &lt; k; i++) &#123; scanf("%lf", &amp;days[i]); if(days[i] &lt; e) half++; &#125; if(half &gt; k / 2) &#123; if(k &gt; D) empty++; else possible++; &#125; &#125; printf("%.1lf%% %.1lf%%\n", possible * 100.0 / N, empty * 100.0 / N); return 0;&#125; /*in:5 0.5 106 0.3 0.4 0.5 0.2 0.8 0.610 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.111 2 2 2 1 1 0.1 1 0.1 0.1 0.1 0.1out:40.0% 20.0%in:3 0.5 1010 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.711 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1out:66.7% 33.3%in:1 0.5 1011 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1 0.1out:0.0% 100.0%in:1 0.5 106 0.3 0.4 0.5 0.2 0.8 0.6out:0.0% 0.0%in:2 0.5 1010 0.0 0.1 0.2 0.3 0.0 0.8 0.6 0.7 0.0 0.55 0.4 0.3 0.5 0.1 0.7out:100.0% 0.0%*/ 1054 æ±‚å¹³å‡å€¼Analysisè¿™æ˜¯ä¸€é“å­—ç¬¦ä¸²å¤„ç†é¢˜ï¼Œé¦–å…ˆæ˜¯å¯¹æ•°å­—åˆæ³•çš„åˆ¤æ–­ï¼Œéžæ³•çš„è¾“å…¥åŒ…å«ä¸‹é¢å‡ ç‚¹ï¼š æ•°å€¼èŒƒå›´è¶…è¿‡äº†$[-1000, 1000]$ã€‚ è¾“å…¥ä¸­å«æœ‰éžæ•°å­—æˆ–å°æ•°ç‚¹å­—ç¬¦ã€‚ è¾“å…¥ä¸­å«æœ‰å¤šä¸ªå°æ•°ç‚¹å­—ç¬¦ã€‚ æœ‰æ•ˆæ•°å­—è¶…è¿‡äº† 2 ä½ã€‚ æŒ‰ç…§ä¸Šé¢çš„æ ‡å‡†åˆ¤æ–­æ˜¯å¦åˆæ³•å³å¯ï¼Œæå–å‡ºæ•°å€¼ä¹Ÿæ¯”è¾ƒå®¹æ˜“ï¼Œè´Ÿå·ä¸€å®šå‡ºçŽ°åœ¨str[0]ï¼›è®¡ç®—å°æ•°ï¼Œåªéœ€è®°å½•å¥½å°æ•°ç‚¹åŽæ•°å­—çš„ä¸ªæ•°ï¼Œæœ€ç»ˆç»“æžœåœ¨é™¤ä»¥pow(10, dec)å³å¯ã€‚å¦å¤–è¿˜éœ€è¦æ³¨æ„ä¸€ä¸‹é¢˜ç›®ä¸­çš„é™·é˜±ï¼Œå¦‚æžœåªæœ‰ä¸€ä¸ªæœ‰æ•ˆæ•°å­—ï¼Œå¾—è¾“å‡ºThe average of 1 number is Yï¼Œé‡Œé¢çš„numberæ²¡æœ‰sã€‚ Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;char str[100];double num;bool getnum(char *str) &#123; num = 0.0; bool flag = false; int i = 0, dec = 0, pnum = 0; if(str[i] == '-') &#123; for(i++; str[i] != '\0'; i++) &#123; if(flag) dec++; if(str[i] == '.') &#123; pnum++; flag = true; &#125; else if(pnum &gt; 1 || '9' &lt; str[i] || str[i] &lt; '0' || dec &gt; 2) return false; if('0' &lt;= str[i] &amp;&amp; str[i] &lt;= '9') num = num * 10 + str[i] - '0'; &#125; num = num / pow(10, dec) * -1; &#125; else &#123; for(; str[i] != '\0'; i++) &#123; if(flag) dec++; if(str[i] == '.') &#123; pnum++; flag = true; &#125; else if(pnum &gt; 1 || '9' &lt; str[i] || str[i] &lt; '0' || dec &gt; 2) return false; if('0' &lt;= str[i] &amp;&amp; str[i] &lt;= '9') num = num * 10 + str[i] - '0'; &#125; num = num / pow(10, dec); &#125; if(-1000.0 &lt;= num &amp;&amp; num &lt;= 1000.0) return true; else return false;&#125;int main() &#123; int n, valid = 0; double sum = 0.0; scanf("%d", &amp;n); while(n--) &#123; scanf("%s", str); if(getnum(str)) &#123; sum += num; valid++; &#125; else &#123; printf("ERROR: %s is not a legal number\n", str); &#125; &#125; if(valid &gt; 1) printf("The average of %d numbers is %.2lf\n", valid, sum / valid); else if(valid == 1) printf("The average of %d number is %.2lf\n", valid, sum / valid); else printf("The average of 0 numbers is Undefined\n"); return 0;&#125; /*in:75 -3.2 aaa 9999 2.3.4 7.123 2.35out:ERROR: aaa is not a legal numberERROR: 9999 is not a legal numberERROR: 2.3.4 is not a legal numberERROR: 7.123 is not a legal numberThe average of 3 numbers is 1.38in:2aaa -9999out:ERROR: aaa is not a legal numberERROR: -9999 is not a legal numberThe average of 0 numbers is Undefinedin:11000out:The average of 2 number is 1000.00*/ version 2è¿™ä¸ªé¢˜ä¸€æ—¦ç”¨ sscanf å’Œ sprintf æ¥å¤„ç†è¾“å‡ºçš„å­—ç¬¦ä¸²ï¼Œå°±ä¼šéžå¸¸ç®€å•ï¼Œsscanf æ˜¯ä»Žå­—ç¬¦ä¸²ä¸­è¯»å…¥æŒ‡å®šæ ¼å¼çš„æ•°æ®æ”¾åˆ°å˜é‡ä¸­ï¼Œsprintf æ˜¯å°†å˜é‡ä¸­çš„æ•°æ®æŒ‰ç…§æŒ‡å®šçš„æ ¼å¼æ”¾åˆ°å­—ç¬¦ä¸²ä¸­ï¼Œå¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;int main() &#123; int n, valid = 0; double sum = 0.0, tmp = 0.0; scanf("%d", &amp;n); char a[50], b[50]; while(n--) &#123; scanf("%s", a); sscanf(a, "%lf", &amp;tmp); sprintf(b, "%.2lf", tmp); int flag = 0; for(int j = 0; j &lt; strlen(a); j++) &#123; if(a[j] != b[j]) flag = 1; &#125; if(flag || tmp &lt; -1000 || tmp &gt; 1000) &#123; printf("ERROR: %s is not a legal number\n", a); continue; &#125; else &#123; sum += tmp; valid++; &#125; &#125; if(valid == 1) printf("The average of 1 number is %.2lf\n", sum); else if(valid &gt; 1) printf("The average of %d numbers is %.2lf\n", valid, sum / valid); else printf("The average of 0 numbers is Undefined\n"); return 0;&#125; 1055 é›†ä½“ç…§Analysisè¿™ä¸ªé¢˜å‚è€ƒäº†1055. é›†ä½“ç…§ (25)-PATä¹™çº§çœŸé¢˜çš„æ€è·¯ã€‚ä¸»è¦æœ‰ä¸¤ä¸ªéš¾ç‚¹ï¼š é¢˜æ„çš„ç†è§£ æŽ’é˜Ÿè¿‡ç¨‹çš„æ¨¡æ‹Ÿ åˆ†å¼€æ¥çœ‹ï¼š é¦–å…ˆè¦æ˜Žç¡®é¢˜ç›®æ˜¯ç«™åœ¨æ‹ç…§è€…ï¼ˆå°±æ˜¯æŽ’é˜Ÿçš„äººï¼‰çš„è§’åº¦æ¥æè¿°çš„ï¼ŒæŽ’å¤šå°‘æŽ’ï¼Œæ¯æŽ’å¤šå°‘äººæ•°ï¼Œè¿™äº›é¢˜ç›®éƒ½äº¤ä»£çš„å¾ˆæ¸…æ™°ï¼Œå¤šå‡ºæ¥çš„äººå…¨éƒ¨æŽ’åœ¨æœ€åŽä¸€æŽ’ã€‚æ˜¾ç„¶ï¼Œå¦‚æžœæ¯æŽ’$N/K$ä¸ªäººï¼Œé‚£ä¹ˆï¼Œæœ€åŽä¸€æŽ’çš„äººæ•°å°±æ˜¯$N/K + N\%K$ï¼Œè¿™æ ·å°±å¯ä»¥æŠŠå¤šå‡ºæ¥çš„äººå…¨éƒ¨æŽ’ä¸‹ã€‚å¦‚æžœä¸‹æ ‡ä»Ž 1 å¼€å§‹ï¼Œé‚£ä¹ˆä¸­é—´ä½ç½®ï¼ˆæœ€é«˜çš„äººï¼‰å°±æ˜¯$m/2 + 1$ï¼Œä¸‹æ ‡ä»Ž 0 å¼€å§‹ï¼Œå°±æ˜¯$m/2$ã€‚ä¸­é—´äººé€‰å¥½åŽï¼ŒæŽ¥ç€ä»¥å…¶ä¸ºè½´å¼€å§‹äº¤æ›¿æŽ’å…¶ä»–äººã€‚å°±æè¿°ä¸­çš„ä¾‹å­è€Œè¨€ï¼Œ5äººèº«é«˜ä¸º 190ã€188ã€186ã€175ã€170ï¼Œé¦–å…ˆå¾—åˆ°çš„åºåˆ—æ˜¯x x 190 x xï¼ŒæŒ‰ç…§èº«é«˜éžå¢žåºï¼ˆé™åºï¼‰å…ˆå³è¾¹ï¼ˆå‡è®¾ä½ æ˜¯æœ€é«˜çš„äººï¼‰æŽ’ä¸€ä¸ªå¯ä»¥å¾—åˆ°x 188 190 x xï¼Œå†æŒ‰ç…§èº«é«˜é¡ºåºå·¦è¾¹æŽ’ä¸€ä¸ªå¯ä»¥å¾—åˆ°x 188 190 186 xï¼Œç„¶åŽå†æŽ’å³è¾¹ï¼Œå°±æ˜¯175 188 190 186 xï¼Œæœ€åŽå†æŽ’å·¦è¾¹å°±å¯ä»¥å¾—åˆ°175 188 190 186 170äº†ã€‚ æŒ‰ç…§ä¸Šé¢çš„åˆ†æžè¦æ¨¡æ‹ŸæŽ’é˜Ÿçš„è¿‡ç¨‹ï¼Œé¦–å…ˆå°±éœ€è¦å°†èº«é«˜ä¸Žäººåï¼ˆå­—å…¸åºå‡åºï¼‰è¿›è¡ŒæŽ’åºï¼Œè¿™ä¸ªé—®é¢˜å¾ˆå®¹æ˜“è§£å†³ï¼Œæž„é€ ç»“æž„ä½“ï¼Œç„¶åŽæŽ’åºå³å¯ã€‚ç„¶åŽå†æ¥æŽ’é˜Ÿï¼Œé¦–å…ˆä»Žè¾“å‡ºæ ·ä¾‹å¯ä»¥çœ‹å‡ºï¼Œè¾“å‡ºçš„ç¬¬ä¸€æŽ’å®žé™…ä¸Šæ˜¯æ•´ä¸ªé˜Ÿä¼çš„æœ€åŽä¸€æŽ’ã€‚æ¢å¥è¯è¯´ï¼Œç¬¬ä¸€è¡Œè¾“å‡ºçš„æ˜¯äººæ•°æœ€å¤šï¼Œèº«é«˜æœ€é«˜çš„ä¸€æŽ’ï¼Œé‚£ä¹ˆè¿™ä¸€æŽ’çš„äººæ•°å°±æ˜¯$N/K + N\%K$ï¼Œå…¶ä»–æŽ’çš„äººæ•°å°±æ˜¯$N/K$ã€‚people æ•°ç»„å’Œ queue æ•°ç»„çš„ä¸‹æ ‡éƒ½æ˜¯ä»Ž 0 å¼€å§‹çš„ï¼Œèº«é«˜æœ€é«˜çš„äººå°±æŽ’åœ¨m/2ã€‚æŽ¥ç€ç«™åœ¨æ‹¿ç›¸æœºçš„äººçš„è§†è§’ï¼Œå†æ¥æŽ’ä¸­é—´äººçš„å·¦è¾¹ï¼Œqueue è¿™ä¸ªæ•°ç»„å°±å¾—ä»Žj = m/2 - 1å¼€å§‹ï¼Œpeople æ•°ç»„çš„ä¸‹æ ‡å°±è¦ä»Ži = t + 1ï¼Œå› ä¸ºè¦è¿˜è¦æŽ’å³è¾¹æ‰€ä»¥ä¸è¦æ”¹åŠ¨tçš„å€¼ï¼Œå†æŽ’ä¸‹ä¸€ä¸ªäººï¼Œqueue æ•°ç»„çš„ä¸‹æ ‡å°±æ˜¯j--ï¼Œpeople æ•°ç»„çš„ä¸‹æ ‡å°±æ˜¯i = i + 2ï¼Œå› ä¸ºå¦ä¸€ä¸ªäººè¦æŽ’åœ¨å³è¾¹ï¼Œæ‰€ä»¥è¦è·³ä¸€ä¸ªäººã€‚åŒç†ï¼ŒæŽ’å³è¾¹çš„æ—¶å€™ï¼Œqueue æ•°ç»„ä»Žj = m/2 + 1å¼€å§‹ï¼Œpeople æ•°ç»„çš„ä¸‹æ ‡ä»Ži = t + 2å¼€å§‹ï¼Œå†æŽ’ä¸‹ä¸€ä¸ªäººæ—¶ï¼Œqueue æ•°ç»„ä¸‹æ ‡å°±å˜ä¸ºj++ï¼Œpeople æ•°ç»„ä¸‹æ ‡å°±å˜ä¸ºi = i + 2ã€‚æ¯æ¬¡å¾ªçŽ¯ï¼ŒåªæŽ’äº†å½“å‰æŽ’çš„äººçš„æ•°ç›®ã€‚Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 10;struct human&#123; char name[10]; int height;&#125; people[maxn], queue[maxn];int n, k, m;bool cmp(human a, human b)&#123; if(a.height != b.height) return a.height &gt; b.height; else return strcmp(a.name, b.name) &lt; 0;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; people[i].name &gt;&gt; people[i].height; &#125; sort(people, people + n, cmp); int t = 0, row = k; while(row) &#123; if(row == k) m = n / k + n % k; else m = n / k; queue[m / 2] = people[t]; // left int j = m / 2 - 1; for(int i = t + 1; i &lt; t + m; i = i + 2) &#123; queue[j--] = people[i]; &#125; // right j = m / 2 + 1; for(int i = t + 2; i &lt; t + m; i = i + 2) &#123; queue[j++] = people[i]; &#125; // print cout &lt;&lt; queue[0].name; for(int i = 1; i &lt; m; i++) &#123; cout &lt;&lt; ' ' &lt;&lt; queue[i].name; &#125; cout &lt;&lt; endl; t = t + m; row--; &#125; return 0;&#125; 1056 ç»„åˆæ•°çš„å’ŒAnalysisé¢˜ç›®ä¸éš¾ï¼Œè¯»æ‡‚é¢˜ç›®ä¹‹åŽç›´æŽ¥åšå°±å¯ä»¥äº†ï¼Œä¹Ÿæ²¡æœ‰è®¾ç½®è¶…æ—¶æ•°æ®ã€‚ä¸è¿‡ï¼Œä»”ç»†è§‚å¯Ÿä¸€ä¸‹å¯ä»¥å‘çŽ°ï¼Œæ¯ä¸ªæ•°éƒ½è¢«å½“åšn-1æ¬¡åä½ï¼Œè¿™æ ·å¾—è¯ï¼Œå°±å¯ä»¥ç›´æŽ¥è®¡ç®—äº†ã€‚ Codeversion 11234567891011121314151617#include &lt;cstdio&gt;int main() &#123; int n, arr[15], sum = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; sum = sum + (arr[i] * 10 * (n - 1)); for(int j = 0; j &lt; n; j++) &#123; if(j != i) sum += arr[i]; &#125; &#125; printf("%d", sum); return 0; &#125; version 2å†æ·±å…¥æ€è€ƒä¸€ä¸‹ï¼Œå‡è®¾ä¸€å…± 3 é¡¹ä¸º aã€bã€å’Œ cï¼Œå°±æœ‰ï¼š$(a + b + c) \times 10 \times (3 - 1) + (b + c + a + c + a + b) = (a + b + c) \times (3 - 1) \times 11$ï¼ŒæŠŠå…¶ä¸­çš„é¡¹æ•°æ¢æˆ n å°±å¯ä»¥å¾—åˆ°ä¸€èˆ¬åŒ–å…¬å¼ï¼š$sum = 11(N - 1)\sum_{i=1}^Na_i$ã€‚é‚£ä¹ˆï¼Œå°±å¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š123456789101112#include &lt;cstdio&gt;int main() &#123; int n, arr, sum = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr); sum += arr; &#125; printf("%d", sum * (n - 1) * 11); return 0; &#125; 1057 æ•°é›¶å£¹Analysiså…ˆå¾—åˆ°æ•´æ•° Nï¼Œç„¶åŽå†åšè¿›åˆ¶è½¬æ¢ï¼Œåˆ†åˆ«è®°å½•ä¸‹ 0 å’Œ 1 çš„ä¸ªæ•°ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int maxn = 100000 + 5;char str[maxn];long long sum = 0;int main() &#123; fgets(str, maxn, stdin); for(int i = 0; str[i] != '\0'; i++) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') sum = sum + str[i] - 'A' + 1; if('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'z') sum = sum + str[i] - 'a' + 1; &#125; long long tmp = sum; int one = 0, zero = 0; while(tmp != 0)&#123; int i = tmp % 2; if(i) one++; else zero++; tmp /= 2; &#125; printf("%d %d", zero, one); return 0;&#125; è¿™ä¸ªé¢˜å¦‚æžœå¯¹æ•°åœ¨è®¡ç®—æœºå†…çš„å­˜å‚¨å½¢å¼æ¯”è¾ƒäº†è§£çš„è¯ï¼Œå®Œå…¨å¯ä»¥ä¸ç”¨å–ä½™æ¥åšï¼Œç›´æŽ¥åˆ©ç”¨ä½è¿ç®—å¾—åˆ°ç»“æžœï¼Œå¦‚ä¸‹ï¼š1234for(; tmp; tmp &gt;&gt;= 1) &#123; if(tmp &amp; 1) one++; else zero++;&#125; 1058 é€‰æ‹©é¢˜Analysisé¢˜ç›®æ„æ€æ¯”è¾ƒç›´è§‚ï¼Œæ ¹æ®é¢˜ç›®çš„æè¿°å¯ä»¥åˆ¤æ–­å‡ºè¿™æ˜¯ä¸€é“å­—ç¬¦ä¸²å¤„ç†ç›¸å…³çš„é¢˜ç›®ã€‚é¢˜ç›®æè¿°çš„å†…å®¹æ¯”è¾ƒå¤šï¼Œä¸ºäº†å‚¨å­˜æ•°æ®æ–¹ä¾¿ï¼Œæž„é€ ä¸€ä¸ªæ–°çš„ç»“æž„ä½“æ¯”è¾ƒå¥½ã€‚å¦å¤–ï¼Œstrcmpè¿™ä¸ªå‡½æ•°åªæœ‰å­—ç¬¦ä¸²ç›¸åŒçš„æ—¶å€™æ‰ä¼šè¾“å‡º 0ï¼›åˆ©ç”¨scanfè¾“å…¥æ—¶ï¼Œéœ€è¦ç”¨getcharæ¥æŽ¥å—æœ«å°¾çš„å›žè½¦ç¬¦æˆ–è€…æ˜¯ç©ºæ ¼ï¼Œå½“ç„¶ï¼Œscanfçš„æ ¼å¼åŒ–ä¸²%*cä¹Ÿå¯ä»¥ç›´æŽ¥åžæŽ‰åŽé¢çš„ä¸€ä¸ªå­—ç¬¦ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1000 + 5;const int maxm = 100 + 5;struct question &#123; char answer[6]; int score, c1, c2;&#125; que[maxm];char str[1005];int n, m, times[maxm] = &#123;0&#125;;int main() &#123; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d %d %d", &amp;que[i].score, &amp;que[i].c1, &amp;que[i].c2); char c; getchar(); int j; for(j = 0; j &lt; que[i].c2; j++) &#123; scanf("%c%*c", &amp;que[i].answer[j]); &#125; que[i].answer[j] = '\0'; &#125; for(int i = 1; i &lt;= n; i++) &#123; fgets(str, 1005, stdin); char ans[6]; int score = 0, ti, qnum = 1; for(int j = 0; str[j] != '\0'; j++) &#123; if(str[j] == '(') &#123; int k, tmp = 0; for(k = j + 1; str[k] != ')'; k++) &#123; if('0' &lt;= str[k] &amp;&amp; str[k] &lt;= '9') &#123; ti = str[k] - '0'; &#125; if('a' &lt;= str[k] &amp;&amp; str[k] &lt;= 'z') &#123; ans[tmp++] = str[k]; &#125; &#125; ans[tmp] = '\0'; j = k + 1; if(ti != que[qnum].c2 || strcmp(que[qnum].answer, ans) != 0) times[qnum]++; else score += que[qnum].score; qnum++; &#125; &#125; printf("%d\n", score); &#125; int max = times[0]; for(int i = 1; i &lt;= m; i++) &#123; if(max &lt; times[i]) max = times[i]; &#125; if(max) &#123; printf("%d", max); for(int i = 1; i &lt;= m; i++) &#123; if(max == times[i]) printf(" %d", i); &#125; &#125; else printf("Too simple"); return 0;&#125; 1059 Cè¯­è¨€ç«žèµ›Analysiså‚èµ›è€…çš„ ID è·ŸæŽ’åæ˜¯ä¸€æ¬¡æ€§ç»™å‡ºçš„ï¼Œå¯ä»¥ç›´æŽ¥ç”¨æŽ’åå½“ä½œä¸‹æ ‡æ¥ä¿å­˜ IDã€‚è¦åŒºåˆ†æ˜¯å¦æŸ¥è¯¢è¿‡äº†ï¼Œå¯ä»¥è®¾ç½®ä¸€ä¸ª bool æ•°ç»„ï¼ŒæŸ¥è¯¢è¿‡çš„å…ƒç´ å°±æ ‡è®°ä¸ºtrueã€‚è¿™ä¸ªé¢˜æœ‰ 2 ä¸ªæµ‹è¯•ç‚¹æ˜¯å¡æ—¶é—´çš„ï¼ŒC è¯­è¨€çš„strcmpå’Œ C++ çš„stringå¯èƒ½æ— æ³•é€šè¿‡ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨ map å°±è¡Œäº†ã€‚ Codeuse char[]123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;const int maxn = 10000 + 5;char stu[maxn][6];int n, k;bool check[maxn] = &#123;false&#125;;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%s", stu[i]); &#125; scanf("%d", &amp;k); char str[6]; while(k--) &#123; scanf("%s", str); int rank = 1; bool flag1 = false; for(; rank &lt;= n; rank++) &#123; if(strcmp(str, stu[rank]) == 0) &#123; flag1 = true; break; &#125; &#125; printf("%s: ", str); if(flag1) &#123; if(!check[rank]) &#123; if(rank == 1) printf("Mystery Award\n"); else if(isprime(rank)) printf("Minion\n"); else printf("Chocolate\n"); check[rank] = true; &#125; else printf("Checked\n"); &#125; else printf("Are you kidding?\n"); &#125; return 0;&#125; use string1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;bool check[maxn] = &#123;false&#125;;int n, k;string str[maxn];bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; str[i]; &#125; cin &gt;&gt; k; string s; while(k--)&#123; cin &gt;&gt; s; int rank = 1; bool flag = false; for(; rank &lt;= n; rank++) &#123; if(s == str[rank]) &#123; flag = true; break; &#125; &#125; cout &lt;&lt; s &lt;&lt; ": "; if(flag) &#123; if(!check[rank]) &#123; if(rank == 1) cout &lt;&lt; "Mystery Award"; else if(isprime(rank)) cout &lt;&lt; "Minion"; else cout &lt;&lt; "Chocolate"; check[rank] = true; &#125; else cout &lt;&lt; "Checked"; &#125; else cout &lt;&lt; "Are you kidding?"; cout &lt;&lt; endl; &#125; return 0;&#125; use map123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;map&lt;string, int&gt; stu;int n, k;bool check[maxn] = &#123;false&#125;;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; cin &gt;&gt; n; string str; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; str; stu[str] = i; &#125; cin &gt;&gt; k; while(k--) &#123; cin &gt;&gt; str; cout &lt;&lt; str &lt;&lt; ": "; map&lt;string, int&gt;::iterator it = stu.find(str); if(it == stu.end()) cout &lt;&lt; "Are you kidding?"; else &#123; if(!check[it-&gt;second]) &#123; if(it-&gt;second == 1) cout &lt;&lt; "Mystery Award"; else if(isprime(it-&gt;second)) cout&lt;&lt; "Minion"; else cout&lt;&lt; "Chocolate"; check[it-&gt;second] = true; &#125; else cout &lt;&lt; "Checked"; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 1060 çˆ±ä¸é¡¿æ•°Analysisè¿™é“é¢˜å‚è€ƒäº†1060. çˆ±ä¸é¡¿æ•°(25)-PATä¹™çº§çœŸé¢˜ã€‚æ€»æ„Ÿè§‰è¿™ä¸ªé¢˜æœ‰ç‚¹åƒè„‘ç­‹æ€¥è½¬å¼¯ðŸ˜“...é¦–å…ˆè¦æ˜Žç¡®çš„æ˜¯ï¼ŒE å¯èƒ½å¹¶ä¸æ˜¯ç»™å‡ºæ¥çš„æ•°ï¼Œèƒ½ç¡®å®šçš„å°±æ˜¯ E è‚¯å®šè¦å°äºŽå¤©æ•°ã€‚ä»¥6 7 6 9 3è¿™ç»„æ•°æ®ä¸ºä¾‹ï¼Œè¿™ç»„æ•°æ®çš„ E åº”è¯¥ç­‰äºŽ 4ï¼Œä¹Ÿå³è¿žç»­ 4 å¤©éª‘è½¦è¶…è¿‡ 4 è‹±é‡Œï¼ˆ6ã€7ã€6ã€9ï¼‰ã€‚ç†è§£è¿™ä¸ªç‚¹äº†åŽï¼Œè®¾ç½®æ•°ç»„ä¸‹æ ‡ä»Ž 1 å¼€å§‹ï¼ˆå‡è®¾æ˜¯ç¬¬ä¸€å¤©ï¼‰ã€‚å…ˆå°†æ‰€ç»™åºåˆ—é™åºæŽ’åºï¼Œç„¶åŽè®©ans = 0ï¼ŒéåŽ†æ•°ç»„ï¼Œæ¯å­˜åœ¨ä¸€ä¸ªnum[p] &gt; pçš„æ•°ï¼ˆå°±æ˜¯éª‘è½¦çš„å…¬é‡Œæ•°å¤§äºŽå¤©æ•°çš„è¿™ç±»æ•°ï¼‰ï¼Œå°±è®©ans++ï¼Œæœ€åŽç»“æžœå°±æ˜¯æ‰€æ±‚ Eã€‚PSï¼šè‡ªå·±åšçš„æ—¶å€™ï¼ŒæŽ’å®Œåºï¼Œæ‹¿åˆ° 13 åˆ†ï¼Œå°±æ²¡æ€è·¯äº†ï¼Œä¸»è¦æ˜¯ä¸æ˜Žç™½ E å¯èƒ½å¹¶ä¸æ˜¯æ•°ç»„ä¸­çš„æ•°ï¼Œåº”è¯¥å¤šæ€è€ƒä¸€ä¸‹ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;int n, num[maxn] = &#123;0&#125;;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;num[i]); &#125; sort(num + 1, num + n + 1, cmp); int ans = 0, p = 1; while(ans &lt;= n &amp;&amp; num[p] &gt; p) &#123; ans++; p++; &#125; printf("%d", ans); return 0;&#125; 1061 åˆ¤æ–­é¢˜Analysisé¢˜ç›®ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå¤§è‡´æ„æ€å°±åƒè€å¸ˆæ”¹å·ä¸€æ ·ï¼Œæ­£ç¡®æ‰“å‹¾ï¼Œé”™è¯¯æ‰“å‰ï¼Œç„¶åŽæŠŠå¯¹çš„é¢˜ç›®çš„åˆ†æ•°åŠ åˆ°ä¸€èµ·ï¼Œä»Žè€Œå¾—åˆ°æ¯ä½å­¦ç”Ÿçš„æ€»åˆ†ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int maxn = 100 + 5;const int maxm = 100 + 5;int scores[maxm] = &#123;0&#125;, ans[maxm] = &#123;0&#125;;int main() &#123; int n, m; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;scores[i]); &#125; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;ans[i]); &#125; while(n--) &#123; int gre = 0, tmp; for(int i = 1; i &lt;= m; i++) &#123; scanf("%d", &amp;tmp); if(tmp == ans[i]) gre += scores[i]; &#125; printf("%d\n", gre); &#125; return 0;&#125; 1062 æœ€ç®€åˆ†æ•°Analysisè¿™ä¸ªé¢˜æœ‰ä¸¤ä¸ªæ€è·¯ï¼Œä¸€ç§æ˜¯ç›´æŽ¥ä»Žåˆ†æ•°çš„è§’åº¦æ€è€ƒï¼Œå¦å¤–ä¸€ç§æ˜¯ä»Žå°æ•°çš„è§’åº¦æ€è€ƒï¼Œåˆ†å¼€æ¥çœ‹ï¼š ä»Žåˆ†æ•°çš„è§’åº¦æ€è€ƒï¼Œé‚£ä¹ˆå°±è¦æ±‚å‡ºä¸¤ä¸ªåˆ†æ¯å’Œé¢˜ç›®ç»™å®šçš„åˆ†æ¯ï¼Œè¿™ 3 ä¸ªæ•°çš„æœ€å°å…¬å€æ•°ã€‚ä»¥è¿™ä¸ªæ•°ä½œä¸ºå…¬å…±åˆ†æ¯ï¼Œç„¶åŽå†ä»Žå°çš„åˆ†å­å¼€å§‹éåŽ†ï¼Œæ‰¾å‡ºåˆ†æ¯ä¸º k çš„æœ€ç®€åˆ†æ•°å³å¯ã€‚ä»Žåˆ†æ•°çš„è§’åº¦æ€è€ƒï¼Œä¸€å®šè¦æ˜Žç¡®æ€è·¯ï¼Œä¸ç„¶å®¹æ˜“è¢«ç»•ç³Šæ¶‚ã€‚ ä»Žå°æ•°çš„è§’åº¦æ€è€ƒå°±ç®€å•ä¸€ç‚¹äº†ï¼Œå…ˆå°†ç»™å®šçš„åˆ†æ•°è½¬åŒ–ä¸ºå°æ•°ï¼Œç„¶åŽä»Ž 1 åˆ° k éåŽ†æ‰€æœ‰åˆ†æ•°ï¼ˆé¢˜ç›®ç»™å®šçš„æ•°æ®è‚¯å®šæ²¡æœ‰å¤§äºŽ 1 çš„å‡åˆ†æ•°ï¼Œè¿™ä¸ªå…¶å®žå¾ˆå®¹æ˜“çŒœåˆ°ï¼‰ï¼Œæ»¡è¶³ä¸èƒ½ä¸Ž k çº¦åˆ†ï¼ˆå³æ²¡æœ‰æœ€å°å…¬çº¦æ•°ï¼‰å¹¶åœ¨ç»™å®šèŒƒå›´å†…çš„æ•°å³ä¸ºæ‰€æ±‚çš„è§£ã€‚ Codeuse fraction12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;int lcm(int a, int b) &#123; int tmp = gcd(a, b); return a * b / tmp;&#125;int main() &#123; int n1, m1, n2, m2, k; scanf("%d/%d %d/%d %d", &amp;n1, &amp;m1, &amp;n2, &amp;m2, &amp;k); int t1 = lcm(m1, m2); int t2 = lcm(t1, k); if(n1 &gt; n2) &#123; int tmp = n1; n1 = n2; n2 = tmp; &#125; int left = n1 * t2 / m1, right = n2 * t2 / m2, tmp = t2 / k; bool flag = true; for(int i = left + 1; i &lt; right; i++) &#123; if(i % tmp == 0 &amp;&amp; gcd(i / tmp, k) == 1) &#123; if(flag) &#123; printf("%d/%d", i / tmp, k); flag = false; &#125; else &#123; printf(" %d/%d", i / tmp, k); &#125; &#125; &#125; return 0;&#125;/*in:7/18 13/20 12out:5/12 7/12in:7/18 19/20 12out:5/12 7/12 11/12in:1/8 7/8 8out:3/8 5/8in:1/8 7/8 2out:1/2in:1/18 13/20 12out:1/12 5/12 7/12in:1/2 3/4 8out:5/8in:1/10 1/2 5out:1/5 2/5*/ use decimalså‚è€ƒï¼šPATä¹™çº§ç»ƒä¹ é¢˜ 1062 æœ€ç®€åˆ†æ•° (20 point(s))123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;int hasCommonDivisor(int i, int k) &#123; for (int j = 2; j &lt;= i; ++j) &#123; if (i % j == 0 &amp;&amp; k % j == 0) &#123; return 1; &#125; &#125; return 0;&#125;int main() &#123; int N1, M1, N2, M2, K; scanf("%d/%d %d/%d %d", &amp;N1, &amp;M1, &amp;N2, &amp;M2, &amp;K); double d1 = N1 * 1.0 / M1; double d2 = N2 * 1.0 / M2; if (d1 &gt; d2) &#123; double tmp = d1; d1 = d2; d2 = tmp; &#125; int isFirst = 1; for (int i = 1; i &lt;= K; i++) &#123; if (!hasCommonDivisor(i, K)) &#123; double di = i * 1.0 / K; if (di &gt; d1 &amp;&amp; di &lt; d2) &#123; if(isFirst)&#123; printf("%d/%d", i, K); isFirst = 0; &#125;else&#123; printf(" %d/%d", i, K); &#125; &#125; &#125; &#125; return 0;&#125; 1063 è®¡ç®—è°±åŠå¾„Analysisè¾“å‡ºç»“æžœæ˜¯æµ®ç‚¹æ•°ï¼Œé‚£ä¹ˆç›´æŽ¥ç”¨æµ®ç‚¹æ•°å°±å¥½äº†ï¼Œé¿å…å¯èƒ½ä¼šå‡ºçŽ°çš„è¯¯å·®ï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨powå‡½æ•°ï¼Œå°±å¯ä»¥çœåŽ»åˆ¤æ–­æ­£è´Ÿäº†ç›´æŽ¥ä¹˜å°±è¡Œã€‚ Code123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int n; scanf("%d", &amp;n); double rep, imp, pradius = 0.0, tmp; while(n--) &#123; scanf("%lf %lf", &amp;rep, &amp;imp); tmp = sqrt(rep * rep + imp * imp); if(tmp &gt; pradius) pradius = tmp; &#125; printf("%.2lf", pradius); return 0;&#125; 1064 æœ‹å‹æ•°Analysisè¿™ä¸ªé¢˜åªéœ€è¦ç»Ÿè®¡å¯èƒ½çš„â€œæœ‹å‹æ•°â€å³å¯ï¼Œåˆ©ç”¨æ•£åˆ—ï¼Œç»Ÿè®¡â€œæœ‹å‹æ•°â€å‡ºçŽ°çš„æ¬¡æ•°å³å¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;int times[40] = &#123;0&#125;;int main() &#123; int n; scanf("%d", &amp;n); char num[6]; while(n--) &#123; scanf("%s", num); int tmp = 0, digit = 0, len = strlen(num); for(int i = len - 1; i &gt;= 0; i--) &#123; if(isdigit(num[i])) tmp += num[i] - '0'; &#125; times[tmp]++; &#125; int cnt = 0; for(int i = 0; i &lt; 40; i++) &#123; if(times[i] &gt; 0) cnt++; &#125; printf("%d\n", cnt); bool flag = true; for(int i = 0; i &lt; 40; i++) &#123; if(times[i] &gt; 0) &#123; if(flag) &#123; printf("%d", i); flag = false; &#125; else printf(" %d", i); &#125; &#125; return 0;&#125; /*in:10123 899 51 998 27 33 36 12 0 0out:50 3 6 9 26*/ 1065 å•èº«ç‹—Analysisåˆ©ç”¨ map å»ºç«‹å¤«å¦»å…³ç³»çš„æ˜ å°„ï¼ŒåŒæ—¶åˆ©ç”¨ setï¼Œä¿å­˜è¿™äº›éžå•èº«ç‹—ï¼ˆèŽ«åæˆ³ä¸­ç¬‘ç‚¹ðŸ˜‚ï¼‰å’Œæ´¾å¯¹æ€»äººæ•°ã€‚ç„¶åŽåˆ©ç”¨å¤«å¦»å…³ç³»ï¼Œæ‰¾å‡ºæ´¾å¯¹ä¸­å¤«å¦»åŒæ–¹åªå‡ºå¸­äº†ä¸€æ–¹çš„å•èº«ç‹—ï¼›æŽ¥ç€å†åˆ©ç”¨ä¿å­˜çš„éžå•èº«ç‹—ä¿¡æ¯ï¼Œç¡®å®šå‰©ä¸‹æœ¬æ¥å°±æ˜¯å•èº«ç‹—çš„äººã€‚PSï¼šç›´æŽ¥ç”¨ map å’Œ set ä¹Ÿèƒ½è¿‡ Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, string&gt; couples;set&lt;string&gt; peo, sdog, notdog;int n, m;int main() &#123; cin &gt;&gt; n; string hs_tmp, wi_tmp, people; while(n--) &#123; cin &gt;&gt; hs_tmp &gt;&gt; wi_tmp; couples[hs_tmp] = wi_tmp; notdog.insert(hs_tmp), notdog.insert(wi_tmp); &#125; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; people; peo.insert(people); &#125; for(unordered_map&lt;string, string&gt;::iterator it = couples.begin(); it != couples.end(); it++) &#123; hs_tmp = it-&gt;first, wi_tmp = it-&gt;second; if(peo.find(hs_tmp) != peo.end() &amp;&amp; peo.find(wi_tmp) == peo.end()) sdog.insert(hs_tmp); else if(peo.find(hs_tmp) == peo.end() &amp;&amp; peo.find(wi_tmp) != peo.end()) sdog.insert(wi_tmp); &#125; for(set&lt;string&gt;::iterator it = peo.begin(); it != peo.end(); it++) &#123; if(notdog.find(*it) != notdog.end()) continue; else sdog.insert(*it); &#125; cout &lt;&lt; sdog.size() &lt;&lt; endl; set&lt;string&gt;::iterator it = sdog.begin(); for(int i = 0; i &lt; sdog.size(); i++) &#123; cout &lt;&lt; *it; if(i &lt; sdog.size() - 1) cout &lt;&lt; ' '; it++; &#125; return 0;&#125; 1066 å›¾åƒè¿‡æ»¤Analysisè¿™é“é¢˜çš„æ„æ€ï¼Œå…¶å®žå°±æ˜¯å›¾åƒçš„ç°åº¦åŒ–å¤„ç†ï¼ˆå½“ç„¶è¿™é‡Œçš„æ¯”è¾ƒç®€å•ï¼‰ã€‚Matlab å†…æœ‰ç›´æŽ¥è¿›è¡Œæ­¤ç§æ“ä½œçš„å›¾åƒå¤„ç†å‡½æ•°ï¼Œå¯ä»¥ç›´æŽ¥è°ƒç”¨ã€‚æ³¨æ„ N å’Œ M çš„æœ€å¤§å€¼ï¼Œæœ€åŽä¸€ä¸ªæµ‹è¯•ç‚¹æ˜¯æœ€å¤§å€¼æµ‹è¯•ã€‚ è¿™ä¸ªé¢˜å…¶å®žå¼€ä¸å¼€æ•°ç»„éƒ½å¯ä»¥ã€‚ Code12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define MAXN 500#define MAXM 500int main(int argc, char const *argv[]) &#123; int r, c, M, N, A, B, gray_value; scanf("%d %d %d %d %d", &amp;M, &amp;N, &amp;A, &amp;B, &amp;gray_value); int image_array[MAXM][MAXN]; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; scanf("%d", &amp;image_array[r][c]); if(A &lt;= image_array[r][c] &amp;&amp; image_array[r][c] &lt;= B) &#123; image_array[r][c] = gray_value; &#125; &#125; &#125; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; printf("%03d", image_array[r][c]); if(c == N-1) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125; 1067 è¯•å¯†ç Analysisè¿™ä¸ªé¢˜çœ‹ç€ç®€å•ï¼Œå…¶å®žæœ‰ä¸€ç‚¹ç»†èŠ‚ä¿¡æ¯ï¼š æ­£ç¡®çš„å¯†ç ä¸åŒ…å«ç©ºæ ¼ï¼Œé”™è¯¯çš„å¯†ç å°±ä¼šåŒ…å«äº†ï¼Œè¿™æ˜¯ AC è¿™é“é¢˜ç›®çš„å…³é”®ã€‚ #ä¸è¢«è®¤ä¸ºè¾“å…¥ï¼Œ#...#ä¹Ÿä¸è¢«è®¤ä¸ºæ˜¯è¾“å…¥ã€‚ Code12345678910111213141516171819202122232425262728#include &lt;iostream&gt;using namespace std;int main() &#123; string password, str; int N; cin &gt;&gt; password &gt;&gt; N; int attempt = 1; bool flag = false; getchar(); while(1) &#123; getline(cin, str); if(str == "#") break; if(str == password &amp;&amp; attempt &lt;= N) &#123; cout &lt;&lt; "Welcome in" &lt;&lt; endl; break; &#125; if(str != password &amp;&amp; attempt &lt;= N) &#123; cout &lt;&lt; "Wrong password: " &lt;&lt; str &lt;&lt; endl; if(attempt == N)&#123; cout &lt;&lt; "Account locked" &lt;&lt; endl; break; &#125; &#125; attempt++; &#125; return 0;&#125; 1068 ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢Analysisé¢˜æ„ä¸éš¾ç†è§£ï¼Œä½†æ˜¯æœ‰ç‚¹ç»†èŠ‚éœ€è¦æ³¨æ„ï¼š é€‰å‡ºæ¥çš„ç‚¹ä¸€å®šè¦æ˜¯å”¯ä¸€å­˜åœ¨çš„ã€‚ é€‰å‡ºæ¥çš„ç‚¹ä¸Žå…¶ç›¸é‚»çš„å…«ä¸ªç‚¹çš„è‰²å·®çš„ç»å¯¹å€¼ä¸€å®šè¦å¤§äºŽ TOLã€‚ è¾“å…¥æ˜¯åˆ—ã€è¡Œï¼Œè¾“å‡ºä¹Ÿæ˜¯ã€‚ Codeversion 1è¿™æ®µä»£ç æ˜¯è‡ªå·±å†™çš„ï¼Œä¸€å¼€å§‹æ²¡æƒ³åˆ°ç«Ÿç„¶èƒ½å¼€è¿™ä¹ˆå¤§çš„æ•°ç»„ï¼Œä¹‹æ‰€ä»¥ä¸‹æ ‡ä»Ž 1 å¼€å§‹æ˜¯ä¸ºäº†ä¸Žé¢˜ç›®ä¿æŒä¸€è‡´ï¼Œä¹Ÿå¯ä»¥é¿å…åˆ¤æ–­æ—¶è¶Šç•Œè®¿é—®ã€‚å®žé™…ä¸Šï¼Œæ•°ç»„ä¸‹æ ‡æ˜¯å¯ä»¥ä¸ºè´Ÿçš„ï¼Œä¸‹æ ‡ä»Ž 0 å¼€å§‹ä¹Ÿèƒ½ AC ï¼Œä½†è¿™æ®µä»£ç å°±ä¸é‚£ä¹ˆä¸¥è°¨äº†ï¼Œé¢˜ç›®çš„æµ‹è¯•æ•°æ®å¯èƒ½ä¹Ÿä¸æ˜¯é‚£ä¹ˆä¸¥è°¨ã€‚123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef long long LL;const int maxn = 1000 + 5;const int maxm = 1000 + 5;LL M, N, TOL, image[maxm][maxn] = &#123;0&#125;;int times[18000000] = &#123;0&#125;;int main() &#123; scanf("%lld %lld %lld", &amp;M, &amp;N, &amp;TOL); for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; scanf("%lld", &amp;image[i][j]); times[image[i][j]]++; &#125; &#125; LL x, y, cnt = 0; x = y = 1; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= M; j++) &#123; LL t = image[i][j]; if(times[image[i][j]] == 1 &amp;&amp; abs(t - image[i - 1][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i - 1][j]) &gt; TOL &amp;&amp; abs(t - image[i - 1][j + 1]) &gt; TOL &amp;&amp; abs(t - image[i][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i][j + 1]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j - 1]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j]) &gt; TOL &amp;&amp; abs(t - image[i + 1][j + 1]) &gt; TOL ) &#123; x = j, y = i; cnt++; &#125; &#125; &#125; if(cnt == 1) printf("(%lld, %lld): %lld", x, y, image[y][x]); else if(cnt &gt; 1) printf("Not Unique"); else printf("Not Exist"); return 0;&#125; version 2è¿™æ®µä»£ç å‚è€ƒï¼š1068 ä¸‡ç»¿ä¸›ä¸­ä¸€ç‚¹çº¢ ï¼ˆ20 åˆ†ï¼‰ï¼Œå…¶ä¸­åˆ¤æ–­æ˜¯å¦å”¯ä¸€çš„å‡½æ•°åšäº†é™å®šï¼Œè¿™æ ·è¿›è¡Œåˆ¤æ–­çš„ç‚¹ä¸€å®šæ˜¯æ•°ç»„å†…çš„ç‚¹ã€‚1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;int image[1005][1005];map&lt;int, int&gt; isappear; int dd[8][2] = &#123;&#123;-1, -1&#125;, &#123;-1, 0&#125;, &#123;-1, 1&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, -1&#125;, &#123;1, 0&#125;, &#123;1, 1&#125;&#125;;int m, n, tol;bool isonly(int x, int y) &#123; for(int i = 0; i &lt; 8; i++) &#123; int xx = x + dd[i][0]; int yy = y + dd[i][1]; if(xx &gt;= 0 &amp;&amp; xx &lt; n &amp;&amp; yy &gt;= 0 &amp;&amp; yy &lt; m &amp;&amp; image[x][y] - image[xx][yy] &gt;= -tol &amp;&amp; image[x][y] - image[xx][yy] &lt;= tol) return false; &#125; return true;&#125;int main() &#123; cin &gt;&gt; m &gt;&gt; n &gt;&gt; tol; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; image[i][j]; isappear[image[i][j]]++; &#125; &#125; int cnt = 0, x = 0, y = 0; for(int i = 0; i &lt; n; i++) &#123; for(int j = 0; j &lt; m; j++) &#123; if(isappear[image[i][j]] == 1 &amp;&amp; isonly(i, j)) &#123; cnt++; x = j + 1, y = i + 1; &#125; &#125; &#125; if(cnt == 1) cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; "): " &lt;&lt; image[y - 1][x - 1]; else if(cnt &gt; 1) cout &lt;&lt; "Not Unique"; else cout &lt;&lt; "Not Exist"; return 0;&#125; 1069 å¾®åšè½¬å‘æŠ½å¥–Analysisç”¨ map æ¥è¡¨ç¤ºæ˜¯å¦ä¸­è¿‡å¥–ï¼Œåªè¦æ²¡æœ‰äººä¸­å¥–å°±è¾“å‡ºKeep going...ï¼Œå¦‚æžœä¸ç”¨vector&lt;string&gt;ä¹Ÿå¯ä»¥ç”¨char str[][]ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;vector&lt;string&gt; acc;map&lt;string, int&gt; done;int main() &#123; int m, n, s; cin &gt;&gt; m &gt;&gt; n &gt;&gt; s; string str; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str; acc.push_back(str); &#125; vector&lt;string&gt;::iterator it = acc.begin(); if(s &gt; m) &#123; cout &lt;&lt; "Keep going..."; &#125; else &#123; for(int i = s - 1; i &lt; m; i += n) &#123; str = *(it + i); if(done[str] == 0) &#123; cout &lt;&lt; str &lt;&lt; endl; done[str]++; &#125; else &#123; for(i++; i &lt; m; i++) &#123; str = *(it + i); if(done[str] == 0) &#123; done[str]++; cout &lt;&lt; str &lt;&lt; endl; break; &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1070 ç»“ç»³Analysisè¿™æ˜¯é“è€ƒå¯Ÿè´ªå¿ƒçš„é¢˜ç›®ï¼Œæ˜Žç¡®äº†æ€æƒ³ä¹‹åŽå°±æ¯”è¾ƒç®€å•ï¼Œæ²¡æ˜Žç¡®å°±æœ‰ç‚¹æŠ˜ç£¨äººã€‚ä»Žé¢˜ç›®çš„æ¥çœ‹ï¼Œæ— æ³•çœ‹å‡ºéœ€è¦ä½¿ç”¨æ¯ä¸€æ ¹ç»³å­ï¼ŒæŒ‰ç…§æ ·ä¾‹ï¼Œå®¹æ˜“è®©äººæƒ³åˆ°çš„ç›´æŽ¥é€‰å–ä¸¤ä¸ªæœ€é•¿çš„ç»³å­ç»“æˆä¸€ä¸ªå°±å¥½äº†ã€‚å®žé™…ä¸Šï¼Œè¿™ä¹Ÿæ˜¯è‡ªå·±ä¸€å¼€å§‹æƒ³åˆ°çš„è´ªå¿ƒæ€æƒ³ï¼Œè®¤ä¸ºå¤´ä¸¤æ¬¡åˆ†åˆ«æ‰¾å½“å‰å¤‡é€‰ç»³æ®µä¸­çš„æœ€é•¿æ®µï¼Œç»“æˆä¸€æ®µå°±å®Œäº‹äº†ã€‚äº‹å®žä¸Šéœ€è¦å°†æ¯æ ¹ç»³æ®µéƒ½ç”¨ä¸Šï¼Œå¹¶ä¸”ç»“ç»³æ¬¡æ•°è¶Šå¤šï¼Œç»³æ®µå°±ä¼šè¢«å¯¹æŠ˜çš„è¶ŠçŸ­ã€‚æ¢å¥è¯è¯´ï¼Œéœ€è¦å…ˆå¯¹æŠ˜çŸ­ç»³æ®µï¼Œç„¶åŽå†å¯¹æŠ˜é•¿ç»³æ®µã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œè¦æ±‚æ¯æ¬¡æŒ‘é€‰çš„ç»³æ®µå°½å¯èƒ½çŸ­ï¼Œè¿™å°±æ˜¯è¿™ä¸ªé¢˜çš„è´ªå¿ƒæ€æƒ³ã€‚ Code12345678910111213141516171819#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 10000 + 5;int num[maxn] = &#123;0&#125;;int main() &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; num[i]; &#125; sort(num, num + n); int res = num[0]; for(int i = 1; i &lt; n; i++) &#123; res = (res + num[i]) / 2; &#125; cout &lt;&lt; res; return 0;&#125; 1071 å°èµŒæ€¡æƒ…Analysisè¿™é“é¢˜çš„é¢˜ç›®æ¯”è¾ƒé•¿ï¼Œè€å¿ƒä¸€ç‚¹ï¼Œä»”ç»†è¯»å®Œï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å››ç§æƒ…å†µçš„å¤„ç†æ–¹å¼æ¥å†™ä»£ç ï¼Œåº”è¯¥å°± OK äº†ï¼Œæ³¨æ„è¾“å…‰åŽï¼ˆç­¹ç x &lt;= 0ï¼‰ï¼Œå°±å¯ä»¥ç›´æŽ¥é€€å‡ºäº†ã€‚è¿˜æœ‰ä¸€ç‚¹ï¼Œé¢˜ç›®ç»™çš„è¾“å‡ºä¸­ total å‰è¦æœ‰ 1 ä¸ªç©ºæ ¼ï¼Œä½†æ˜¯æ ·ä¾‹æ˜¯ 2 ä¸ªç©ºæ ¼ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int T, K, n1, b, t, n2, remains; scanf("%d %d", &amp;T, &amp;K); remains = T; while(K--) &#123; scanf("%d %d %d %d", &amp;n1, &amp;b, &amp;t, &amp;n2); if(remains &lt;= 0) &#123; printf("Game Over.\n"); break; &#125; if(t &gt; remains) &#123; printf("Not enough tokens. Total = %d.\n", remains); continue; &#125; if((n1 &gt; n2 &amp;&amp; b == 0) || (n1 &lt; n2 &amp;&amp; b == 1)) &#123; remains += t; printf("Win %d! ", t); &#125; else &#123; remains -= t; printf("Lose %d. ", t); &#125; printf("Total = %d.\n", remains); &#125; return 0;&#125; 1072 å¼€å­¦å¯„è¯­Analysisç”¨setæ¥ä¿å­˜è¢«ç¼´ç‰©å“ä¿¡æ¯ï¼Œç”¨vector&lt;string&gt;æ¥ä¿å­˜å«æœ‰è¢«ç¼´ç‰©å“çš„å­¦ç”Ÿç‰©å“ä¿¡æ¯ï¼Œé‡å¤éåŽ†ä¸€æ¬¡å°±å¯ä»¥è¾“å‡ºè¢«ç¼´ç‰©å“ä¿¡æ¯äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;int n, m;const int maxn = 1000 + 5;vector&lt;string&gt; stu[maxn];set&lt;string&gt; ban;int main() &#123; cin &gt;&gt; n &gt;&gt; m; string str, name; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str; ban.insert(str); &#125; int snum = 0, bnum = 0, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; name &gt;&gt; tmp; for(int j = 0; j &lt; tmp; j++) &#123; cin &gt;&gt; str; if(ban.find(str) != ban.end()) &#123; stu[i].push_back(str); bnum++; &#125; &#125; if(stu[i].size() != 0) &#123; cout &lt;&lt; name &lt;&lt; ":"; snum++; for(vector&lt;string&gt;::iterator it = stu[i].begin(); it != stu[i].end(); it++) &#123; cout &lt;&lt; " " &lt;&lt; *it; &#125; cout &lt;&lt; endl; &#125; &#125; cout &lt;&lt; snum &lt;&lt; ' ' &lt;&lt; bnum &lt;&lt; endl; return 0;&#125; 1073 å¤šé€‰é¢˜å¸¸è§è®¡åˆ†æ³•Analysisè¿™ä¸ªé¢˜ç›¸å½“å‘ï¼Œå¾ˆè´¹æ—¶é—´ï¼Œæœ¬è´¨ä¸Šæ˜¯è·Ÿ 1058 ä¸€æ ·çš„é¢˜ç›®ï¼Œä½†æ˜¯å¤„ç†èµ·æ¥è¦éº»çƒ¦çš„å¤šã€‚å› ä¸ºæœ€ç»ˆè¦è¾“å‡ºé€‰é¡¹çš„é”™è¯¯æ¬¡æ•°ï¼Œå¾ˆç›´æŽ¥å°±ä¼šæƒ³åˆ°é€ä¸ªæ¯”è¾ƒï¼Œæ‰€ä»¥ç”¨ set æ¥ä¿å­˜æ­£ç¡®ç­”æ¡ˆã€‚è‡³äºŽé€‰é¡¹çš„é”™è¯¯æ¬¡æ•°ï¼Œå°±äº¤ç»™ä¸€ä¸ªäºŒç»´æ•°ç»„æ¥ä¿å­˜ã€‚é¢˜ç›®æ‰€ç»™çš„æ¯ä¸ªé€‰æ‹©é¢˜çš„é€‰é¡¹ä¸ªæ•°è¿™ä¸ªä¿¡æ¯ï¼ŒåŸºæœ¬ä¸Šæ— ç”¨ã€‚æŽ¥ç€å°±æ˜¯ä¸€äº›ç»†èŠ‚äº†ï¼š éžæ­£ç¡®é€‰é¡¹é€‰äº†ç®—é”™è¯¯ï¼Œæ¼é€‰çš„æ­£ç¡®é€‰é¡¹ä¹Ÿç®—åœ¨é”™è¯¯é€‰é¡¹å†… é¢˜ç›®æœ€åŽè¦æ±‚è¾“å‡ºçš„é”™è¯¯æ¬¡æ•°ï¼Œä¸æ˜¯é¢˜ç›®çš„é”™è¯¯æ¬¡æ•°ï¼Œè€Œæ˜¯è¿™ä¸ªé€‰é¡¹çš„é”™è¯¯æ¬¡æ•° ç”±äºŽæœ‰()ã€ç©ºæ ¼çš„å­˜åœ¨ï¼Œå­—ç¬¦ä¸²çš„ç©ºé—´æœ€å¥½å¼€å¤§ä¸€ç‚¹ è‡ªå·±åœ¨ç¬¬äºŒä¸ªç»†èŠ‚çš„åœ°æ–¹å¡äº†å¾ˆä¹…ï¼ŒåŽæ¥ç»ˆäºŽååº”è¿‡æ¥æ˜¯è‡ªå·±é¢˜æ„ç†è§£é”™äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int maxm = 100 + 5;set&lt;char&gt; answer[maxm];int que[maxm] = &#123;0&#125;, wrong_opt[maxm][6] = &#123;0&#125;;double scores[maxm] = &#123;0.0&#125;;char stu[10005];int main() &#123; int n, m, tmp; char ctmp; scanf("%d %d", &amp;n, &amp;m); for(int i = 1; i &lt;= m; i++) &#123; scanf("%lf %d %d%*c", &amp;scores[i], &amp;que[i], &amp;tmp); for(int j = 0; j &lt; tmp; j++) &#123; scanf("%c%*c", &amp;ctmp); answer[i].insert(ctmp); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int qnum = 1; double sum = 0.0; fgets(stu, 10005, stdin); for(int j = 0; stu[j] != '\0'; j++) &#123; if(stu[j] == '(') &#123; bool isappear[6] = &#123;false&#125;, flag = true; tmp = stu[++j] - '0'; if(tmp &gt; answer[qnum].size()) flag = false; for(j++; stu[j] != ')'; j++) &#123; if(stu[j] == ' ') continue; else &#123; ctmp = stu[j]; if(answer[qnum].find(ctmp) == answer[qnum].end()) &#123; flag = false; wrong_opt[qnum][ctmp - 'a']++; &#125; isappear[ctmp - 'a'] = true; &#125; &#125; set&lt;char&gt;::iterator it = answer[qnum].begin(); for(; it != answer[qnum].end(); it++) &#123; if(!isappear[*it - 'a']) wrong_opt[qnum][*it - 'a']++; &#125; if(flag &amp;&amp; tmp == answer[qnum].size()) sum += scores[qnum]; else if(flag &amp;&amp; tmp &lt; answer[qnum].size()) sum += (scores[qnum] / 2.0); qnum++; &#125; &#125; printf("%.1lf\n", sum); &#125; int max = wrong_opt[1][0]; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt; 5; j++) &#123; max = max &gt; wrong_opt[i][j] ? max : wrong_opt[i][j]; &#125; &#125; if(max == 0) &#123; printf("Too simple\n"); &#125; else &#123; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 0; j &lt; 5; j++) &#123; if(max == wrong_opt[i][j]) &#123; printf("%d %d-%c\n", max, i, j + 'a'); &#125; &#125; &#125; &#125; return 0;&#125; 1074 å®‡å®™æ— æ•ŒåŠ æ³•å™¨Analysisè¿™ä¸ªé¢˜ç›®ï¼Œè‡ªå·±çš„æ€è·¯æ¯”è¾ƒå¤æ‚ï¼Œéœ€è¦æ³¨æ„ä¸¤ä¸ªç‰¹æ®Šç‚¹ï¼š ç»“æžœæ˜¯ 0 æ—¶ï¼Œä¹Ÿè¦è¾“å‡º 0ã€‚ è¶…è¿‡ 20 ä½åŽçš„è®¡ç®—æŒ‰åè¿›åˆ¶è¿›è¡Œè®¡ç®—ï¼Œè¦åˆ¤æ–­ 20 ä½ä¹‹åŽçš„è®¡ç®—æ˜¯å¦å­˜åœ¨è¿›ä½ã€‚ Codeversion 1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 20 + 5;char tab[maxn], num1[maxn], num2[maxn];int ans[maxn] = &#123;0&#125;, digit[10] = &#123;10, 0, 2, 3, 4, 5, 6, 7, 8, 9&#125;;void sreverse(char *str) &#123; int len = strlen(str); for(int i = 0; i &lt; len / 2; i++) &#123; char tmp = str[i]; str[i] = str[len - i - 1]; str[len - i - 1] = tmp; &#125;&#125;int main() &#123; scanf("%s\n%s\n%s", tab, num1, num2); sreverse(num1), sreverse(num2), sreverse(tab); int tmp, carry = 0, i; for(i = 0; num1[i] != '\0' &amp;&amp; num2[i] != '\0'; i++) &#123; tmp = num1[i] + num2[i] - 2 * '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i] = tmp; &#125; while(num1[i] != '\0') &#123; tmp = num1[i] - '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i++] = tmp; &#125; while(num2[i] != '\0') &#123; tmp = num2[i] - '0' + carry; if(i &lt; 20 &amp;&amp; tmp &gt;= digit[tab[i] - '0']) &#123; tmp = tmp - digit[tab[i] - '0']; carry = 1; &#125; else if(i &gt;= 20 &amp;&amp; tmp &gt;= 10) &#123; tmp = tmp - 10; carry = 1; &#125; else carry = 0; ans[i++] = tmp; &#125; if(carry != 0) ans[i] = carry; while(ans[i] == 0) i--; if(i &lt; 0) printf("0"); else &#123; for(int j = i; j &gt;= 0; j--) &#123; printf("%d", ans[j]); &#125; &#125; return 0;&#125;/*in:3052706203415out:7201in:221111out:110in:087717out:96in:222222222222222222221111111111111111111100000000000000000001out:100000000000000000000in:222222222222222222221111111111111111111110000000000000000001out:110000000000000000000in:22222222222222222222211111111111111111111110000000000000000001out:410000000000000000000in:2222222222222222222288000000000000000000008800000000000000000000out:17600000000000000000000*/ version 2è¿™ä¸ªæ€è·¯å‚è€ƒï¼š1074. å®‡å®™æ— æ•ŒåŠ æ³•å™¨(20)-PATä¹™çº§çœŸé¢˜ä»Žè¿™ä¸ªæ€è·¯å¯ä»¥èŽ·å¾—ä¸€ç‚¹æ”¶èŽ·ï¼š è¿™ç±»é¢˜ç›®ï¼Œéƒ½å¯ä»¥å…ˆæ‰©å±•æˆæœ€é•¿çš„å­—ç¬¦ä¸²åŽå†è¿›è¡Œè®¡ç®— ä¸Žå…¶åˆ†æƒ…å†µåˆ¤æ–­ carry æ˜¯å¦ä¸º 0ï¼Œä¸å¦‚ç›´æŽ¥ç”¨é™¤æ³•æ¥èŽ·å¾— string ç±»çš„åˆå§‹åŒ–ç”¨æ³•ï¼Œä»¥åŠå…¶è¿ç®—ç¬¦çš„ç”¨æ³• 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int main() &#123; string s, s1, s2, ans; int carry = 0, flag = 0; cin &gt;&gt; s &gt;&gt; s1 &gt;&gt; s2; ans = s; string ss1(s.length() - s1.length(), '0'); s1 = ss1 + s1; string ss2(s.length() - s2.length(), '0'); s2 = ss2 + s2; for(int i = s.length() - 1; i &gt;= 0; i--) &#123; int mod = s[i] == '0' ? 10 : (s[i] - '0'); ans[i] = (s1[i] + s2[i] - 2 * '0' + carry) % mod + '0'; carry = (s1[i] + s2[i] - 2 * '0' + carry) / mod; &#125; if(carry != 0) ans = '1' + ans; for(int i = 0; i &lt; ans.size(); i++) &#123; if(ans[i] != '0' || flag == 1) &#123; flag = 1; cout &lt;&lt; ans[i]; &#125; &#125; if(flag == 0) cout &lt;&lt; 0; return 0;&#125; 1075 é“¾è¡¨å…ƒç´ åˆ†ç±»AnalysisæŒ‰ç…§é¢˜ç›®æ„æ€ï¼Œä»Žæœ€åŽè¾“å‡ºçš„ç»“æžœä¸Šæ¥çœ‹ï¼Œç‰¹å®šåŒºé—´å†…çš„ç»“ç‚¹çš„ç›¸å¯¹ä½ç½®å®žé™…ä¸Šå¹¶æ²¡æœ‰å‘ç”Ÿæ”¹å˜ï¼Œå°±æ˜¯ä¸€å¼€å§‹è¾“å…¥çš„é¡ºåºï¼Œæ‰€ä»¥ç»™æ¯ä¸ªç»“ç‚¹è®¾ç½®ä¸€ä¸ª order æ¥è®°å½•ä½ç½®ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œè¿™ä¸ª order è¿˜å¯ä»¥ç”¨æ¥åŽ»é™¤æ— æ•ˆç»“ç‚¹ã€‚ç„¶åŽï¼Œç”¨ sort æŽ’åºé™¤åŽ»æ— æ•ˆçš„ç»“ç‚¹ï¼Œå†æŒ‘å‡ºç¬¦åˆæ¡ä»¶çš„ç»“ç‚¹ï¼Œè¾“å‡ºå°±è¡Œäº†ï¼Œæ³¨æ„ä¸€ä¸‹æœ€åŽä¸€ä¸ªç»“ç‚¹çš„ next æ˜¯ -1ã€‚ è€å®žè¯´ï¼Œè¿™ä¸ªé¢˜ç”¨æŽ’åºåšï¼Œæ„Ÿè§‰æœ‰ç‚¹æŠ•æœºå–å·§ï¼Œå› ä¸ºåŽ‹æ ¹å°±æ²¡æœ‰åšé¢˜ç›®è¦æ±‚çš„äº‹æƒ…ï¼Œä½†ä¾ç„¶å¯ä»¥ AC ã€‚ å¦‚æžœä¸€æœ¬æ­£ç»çš„ä»Žé“¾è¡¨çš„è§’åº¦æ€è€ƒï¼Œé‚£ä¹ˆéœ€è¦éåŽ†é“¾è¡¨ï¼Œç„¶åŽæŒ‘å‡ºç¬¦åˆæ¡ä»¶çš„ç»“ç‚¹ï¼ŒåŒæ ·éœ€è¦ 3 ä¸ªå¾ªçŽ¯æ¥å®Œæˆã€‚æŒ‘å‡ºç»“ç‚¹çš„æ­¥éª¤ï¼Œå»ºè®®é‡æ–°å¼„ä¸€ä¸ªç»“æž„ä½“æ•°ç»„æ¥å®Œæˆï¼ŒåŒæ ·çš„ï¼Œä»…ä»…æŒ‘å‡ºç»“ç‚¹å°±è¡Œäº†ï¼Œä¸éœ€è¦å†ä¿®æ”¹nextå’Œaddressäº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct Node &#123; int address, data, next; int order;&#125; node[maxn], nod[maxn];bool cmp(Node a, Node b) &#123; return a.order &lt; b.order;&#125;int main() &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].order = maxn; &#125; int begin, n, k, address; scanf("%d %d %d", &amp;begin, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int p = begin, count = 0; while(p != -1) &#123; node[p].order = count++; p = node[p].next; &#125; sort(node, node + maxn, cmp); n = count; count = 0; for(int i = 0; i &lt; n; i++) &#123; if(node[i].data &lt; 0) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(0 &lt;= node[i].data &amp;&amp; node[i].data &lt;= k) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(node[i].data &gt; k) nod[count++] = node[i]; &#125; for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) printf("%05d %d %05d\n", nod[i].address, nod[i].data, nod[i + 1].address); else printf("%05d %d -1\n", nod[i].address, nod[i].data); &#125; return 0;&#125; 1076 Wifiå¯†ç Analysisä¸ºäº†ä¿ƒè¿›å­¦ç”Ÿå­¦ä¹ ï¼Œè¿™é¢˜ä¹ŸçœŸæ˜¯éš¾ä¸ºè€å¸ˆäº†ï¼Œå“ˆå“ˆ~æ­¤é¢˜ä¸éš¾ï¼Œä¸è¿‡éœ€è¦ç»†å¿ƒä¸€ç‚¹ï¼Œè¾“å…¥çš„æ ¼å¼æ˜¯ç¡®å®šå¥½äº†çš„ã€‚å¦‚æžœæ¯æ¬¡è¾“å…¥åˆ©ç”¨å­—ç¬¦æ¥åšå¤„ç†ï¼Œåˆ™éœ€è¦æ³¨æ„å›žè½¦ç¬¦\nä¸è¦è¢«è¾“å…¥å‡½æ•°èŽ·å–åˆ°äº†ï¼ˆæµ‹è¯•ç‚¹2å°±æ˜¯è¿™æ ·ï¼‰ã€‚å¯ä»¥æŒ‰ç…§å­—ç¬¦ä¸²çš„æ€è·¯åŽ»å¤„ç†ï¼Œå¹¶ä¸”å¾ªçŽ¯è¿›è¡Œçš„æ¬¡æ•°å¯èƒ½ä¼šå°‘ä¸€äº›ã€‚è¿™ä¸ªé¢˜å‘çŽ°äº†ä¸€ä¸ªæœ‰ç‚¹æ„æ€çš„æ€è·¯ï¼šPAT Basic 1076. Wifiå¯†ç  (15) (Cè¯­è¨€å®žçŽ°)ã€‚ Code1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 105int Wifi_Password[4] = &#123;1, 2, 3, 4&#125;;int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d%*c", &amp;N); char Answers[MAXN], temp, flag; for(i = 0; i &lt; 4 * N; i++) &#123; scanf("%c-%c%*c", &amp;temp, &amp;flag); if(flag == 'T') &#123; Answers[count++] = temp; &#125; &#125; for(i = 0; i &lt; count; i++) &#123; printf("%d", Wifi_Password[Answers[i] - 'A']); &#125; putchar('\n'); return 0;&#125; 1077 äº’è¯„æˆç»©è®¡ç®—Analysisé¢˜æ„å¾ˆæ˜Žç¡®ï¼Œå”¯ä¸€çš„å‘ç‚¹åœ¨å››èˆäº”å…¥ä¸Šã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main() &#123; int n, m, tea_score; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tea_score); int sum = 0, valid = 0, tmp, max = -1, min = m + 1; for(int j = 0; j &lt; n - 1; j++) &#123; scanf("%d", &amp;tmp); if(0 &lt;= tmp &amp;&amp; tmp &lt;= m) &#123; sum += tmp; valid++; if(tmp &gt; max) max = tmp; if(tmp &lt; min) min = tmp; &#125; &#125; double ans = (double)(sum - max - min) / (valid - 2); printf("%d\n", (int)((ans + tea_score) / 2 + 0.5)); &#125; return 0;&#125; 1078 å­—ç¬¦ä¸²åŽ‹ç¼©ä¸Žè§£åŽ‹AnalysisCã€D åˆ†åˆ«å¯¹åº”åŽ‹ç¼©ä¸Žè§£åŽ‹ä¸¤ç§æ¨¡å¼ï¼Œåˆ†å¼€è¿›è¡Œå°±å¯ä»¥äº†ï¼Œç©ºæ ¼ä¸Žå­—æ¯çš„å¤„ç†æ–¹å¼æ˜¯ä¸€æ ·çš„ã€‚ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;cctype&gt;char str[2005], mode;int main() &#123; scanf("%c%*c", &amp;mode); fgets(str, 2005, stdin); if(mode == 'C') &#123; for(int i = 0; str[i] != '\0'; i++) &#123; char tmp = str[i]; int count = 1, j; for(j = i + 1; str[j] == tmp; j++) &#123; count++; &#125; if(count == 1) printf("%c", tmp); else printf("%d%c", count, tmp); i = --j; &#125; &#125; else if(mode == 'D') &#123; for(int i = 0; str[i] != '\0'; i++) &#123; int count = 0, j; if(isdigit(str[i])) &#123; count = str[i] - '0'; for(j = i + 1; isdigit(str[j]); j++) &#123; count = count * 10 + str[j] - '0'; &#125; for(int k = 0; k &lt; count; k++) &#123; printf("%c", str[j]); &#125; i = j; &#125; else printf("%c", str[i]); &#125; &#125; return 0;&#125; 1079 å»¶è¿Ÿçš„å›žæ–‡æ•°Analysisè¿™ä¸ªé¢˜ä¸»è¦åœ¨è€ƒå¯Ÿå›žæ–‡æ•°çš„åˆ¤æ–­å’Œå¤§æ•°åŠ æ³•ï¼Œä»Žæ•°ç»„ä¸‹æ ‡ 0 å¼€å§‹ä¿å­˜æ•°çš„ä½Žä½ã€‚è¿™æ ·ä¼šå¥½ç®—ä¸€ç‚¹ã€‚å¦å¤–ï¼Œæ³¨æ„ä¸ªä½æ•°ä¹Ÿæ˜¯å›žæ–‡æ•°ã€‚ æ•°ç»„é€†ç½®çš„å‡½æ•°å¯ä»¥å€ŸåŠ© C++ çš„ reverse å‡½æ•°å®Œæˆã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cctype&gt;const int maxn = 1000 + 5;int num[maxn] = &#123;0&#125;, temp[maxn] = &#123;0&#125;;bool ispalindromic(int *a, int count) &#123; if(count == 1) return true; for(int i = 0; i &lt; count / 2; i++) &#123; if(a[i] != a[count - i - 1]) return false; &#125; return true;&#125;void shownum(int *a, int count) &#123; for(int i = count - 1; i &gt;= 0; i--) &#123; printf("%d", a[i]); &#125;&#125;void arr_reverse(int *a, int *b, int count) &#123; for(int i = 0; i &lt; count; i++) &#123; a[i] = b[count - i - 1]; &#125;&#125;int main() &#123; char c; int count = 0; while((c = getchar()) != '\n') &#123; temp[count++] = c - '0'; &#125; arr_reverse(num, temp, count); int times = 0; while(times++ &lt; 10) &#123; if(ispalindromic(num, count)) &#123; shownum(num, count); printf(" is a palindromic number.\n"); break; &#125; else &#123; shownum(num, count); printf(" + "); shownum(temp, count); int carry = 0, tmp; for(int i = 0; i &lt; count; i++) &#123; tmp = num[i]; num[i] = (tmp + temp[i] + carry) % 10; carry = (tmp + temp[i] + carry) / 10; &#125; if(carry) num[count++] = carry; printf(" = "); shownum(num, count); printf("\n"); arr_reverse(temp, num, count); &#125; &#125; if(times &gt;= 10) printf("Not found in 10 iterations.\n"); return 0;&#125; 1080 MOOCæœŸç»ˆæˆç»©Analysiséœ€è¦å¤„ç†çš„æ•°æ®å¤ªå¤šï¼Œç›´æŽ¥æž„é€ ä¸€ä¸ªæ–°çš„ç»“æž„ä½“ã€‚å¼€å§‹è¯»å…¥æ•°æ®ä¹‹å‰ï¼Œå…¨éƒ¨é»˜è®¤ä¸ºæ²¡æœ‰è€ƒè¯•çš„çŠ¶æ€ï¼ˆå…¨éƒ¨ç½®ä¸º -1ï¼Œè¾“å‡ºçš„æ—¶å€™å°±å¯ä»¥ç›´æŽ¥è¾“å‡ºäº†ï¼‰ï¼Œç„¶åŽè¯»å…¥æ•°æ®ï¼Œè®¡ç®—æœ€ç»ˆæˆç»©ï¼Œç¬¬ä¸€é¡ºåºæ˜¯æˆç»©é€’å‡ï¼Œç¬¬äºŒé¡ºåºæ˜¯å­¦å·é€’å¢žã€‚å› ä¸ºæ¯æ¬¡è€ƒè¯•çš„æˆç»©æ˜¯åˆ†åˆ«ç»™å‡ºçš„ï¼Œæ‰€ä»¥ä¸ºäº†åœ¨å¤„ç†ä¸‹ä¸€æ¬¡è€ƒè¯•çš„æ•°æ®æ—¶æ‰¾åˆ°å¯¹åº”çš„å­¦ç”Ÿï¼Œæ‰€ä»¥éœ€è¦ç”¨ map å»ºç«‹å­¦ç”Ÿå­¦å·ä¸Žä¸‹æ ‡çš„å¯¹åº”å…³ç³»ã€‚å¦å¤–ï¼Œè®¡ç®—æœ€ç»ˆæˆç»©éœ€è¦å››èˆäº”å…¥ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;const int maxn = 100000 + 5;struct student &#123; string name; int gp, gmt, gf, g;&#125; stu[maxn];map&lt;string, int&gt; name2num;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; stu[i].g = stu[i].gf = stu[i].gmt = stu[i].gp = -1; &#125;&#125;bool cmp(student a, student b) &#123; if(a.g != b.g) return a.g &gt; b.g; else return a.name &lt; b.name;&#125;int main() &#123; init(); int p, m, n, count = 0, tmp; cin &gt;&gt; p &gt;&gt; m &gt;&gt; n; string str; for(int i = 0; i &lt; p; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; stu[count].name = str; stu[count].gp = tmp; name2num[str] = count++; &#125; map&lt;string, int&gt;::iterator it; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; it = name2num.find(str); if(it == name2num.end()) &#123; stu[count].gmt = tmp; stu[count].name = str; name2num[str] = count++; &#125; else stu[it-&gt;second].gmt = tmp; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; tmp; it = name2num.find(str); if(it == name2num.end()) &#123; stu[count].gf = tmp; stu[count].name = str; name2num[str] = count++; &#125; else stu[it-&gt;second].gf = tmp; &#125; int a, b; for(int i = 0; i &lt; count; i++) &#123; if(stu[i].gp &lt; 200) continue; else &#123; a = stu[i].gmt, b = stu[i].gf; if(a &lt;= b) stu[i].g = b; else stu[i].g = (int)((a * 0.4 + b * 0.6) + 0.5); &#125; &#125; sort(stu, stu + count, cmp); for(int i = 0; i &lt; count; i++) &#123; if(stu[i].g &gt;= 60) &#123; cout &lt;&lt; stu[i].name &lt;&lt; ' ' &lt;&lt; stu[i].gp &lt;&lt; ' ' &lt;&lt; stu[i].gmt \ &lt;&lt; ' ' &lt;&lt; stu[i].gf &lt;&lt; ' ' &lt;&lt; stu[i].g &lt;&lt; endl; &#125; &#125; return 0;&#125; 1081 æ£€æŸ¥å¯†ç Analysisæ­¤é¢˜çš„éš¾ç‚¹åœ¨äºŽæƒ…å†µçš„åˆ†ç±»ï¼Œæ— è®ºè¾“å…¥çš„â€œå¯†ç â€æ˜¯å¦åˆæ³•ï¼Œé¦–å…ˆåˆ¤æ–­é•¿åº¦æ˜¯å¦ä¸å°äºŽ6ï¼Œç´§æŽ¥ç€ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰éžæ³•å­—ç¬¦ï¼Œç»§è€Œç¡®è®¤æœ‰æ— æ•°å­—ï¼Œæœ€åŽç¡®è®¤æœ‰æ— å­—æ¯ã€‚æ³¨æ„å¯èƒ½ä¼šè¾“å…¥å¸¦ç©ºæ ¼çš„å­—ç¬¦ä¸²ï¼ˆæµ‹è¯•ç‚¹2ï¼‰ã€‚å› ä¸ºgetså‡½æ•°æ— æ³•åœ¨ç”¨äº†ï¼Œå¯ä»¥ä½¿ç”¨fgetsæ¥è¯»å…¥ä¸€è¡Œï¼Œæˆ–è€… C++ çš„getlineã€‚å¦‚æžœç”¨fgetsï¼Œè¦æ³¨æ„å®ƒä¼šæŠŠæœ€åŽçš„å›žè½¦ä¹Ÿè¯»åˆ°å­—ç¬¦ä¸²å†…ï¼Œæ‰€ä»¥é•¿åº¦è¦å‡ä¸€ã€‚ Codeversion 1è¿™æ˜¯åŽŸæ¥å†™çš„ç‰ˆæœ¬ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define MaxLength 85int Validity_Check(char *password);char Result[5][100] = &#123; "Your password is tai duan le.", "Your password is tai luan le.", "Your password needs shu zi.", "Your password needs zi mu.", "Your password is wan mei.",&#125;;int main(int argc, char const *argv[]) &#123; int flag, N; char Password[MaxLength]; scanf("%d%*c", &amp;N); while(N--) &#123; gets(Password); //notice the space flag = Validity_Check(Password); puts(Result[flag]); &#125; return 0;&#125;int Validity_Check(char *password) &#123; int ret = 4, len = strlen(password), i; int num_flag, alpha_flag, invalid_flag; num_flag = alpha_flag = invalid_flag = 0; if(len &gt;= 6) &#123; for(i = 0; i &lt; len; i++) &#123; if( isdigit(password[i]) ) &#123; num_flag = 1; &#125; else if( isalpha(password[i]) ) &#123; alpha_flag = 1; &#125; else if(password[i] == '.') &#123; continue; &#125; else &#123; invalid_flag = 1; &#125; &#125; if(invalid_flag) &#123; ret = 1; &#125; else if(!num_flag) &#123; ret = 2; &#125; else if(!alpha_flag) &#123; ret = 3; &#125; &#125; else &#123; ret = 0; &#125; return ret;&#125; version 2è¿™æ˜¯åŽæ¥å†™çš„ç‰ˆæœ¬ã€‚1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char str[85];int n;int main() &#123; scanf("%d%*c", &amp;n); while(n--) &#123; fgets(str, 85, stdin); if(strlen(str) - 1 &lt; 6) &#123; printf("Your password is tai duan le.\n"); continue; &#125; bool flag1, flag2, flag3; flag1 = flag2 = flag3 = false; for(int i = 0; str[i] != '\0'; i++) &#123; if(isalpha(str[i])) flag2 = true; else if(isdigit(str[i])) flag3 = true; else if(str[i] == '.' || str[i] == '\n') continue; else flag1 = true; &#125; if(flag1) printf("Your password is tai luan le.\n"); else if(flag2 &amp;&amp; !flag3) printf("Your password needs shu zi.\n"); else if(!flag2 &amp;&amp; flag3) printf("Your password needs zi mu.\n"); else printf("Your password is wan mei.\n"); &#125; return 0;&#125; 1082 å°„å‡»æ¯”èµ›Analysiså› ä¸ºæœ€ç»ˆè¦è¾“å‡ºçš„æ˜¯ç¼–å·ï¼Œæ‰€ä»¥éœ€è¦ä¿å­˜ç¼–å·ä¿¡æ¯ï¼Œè¿™æ ·çš„è¯ï¼Œä¸å¦‚ç”¨ä¸€ä¸ªæ–°çš„ç»“æž„ä½“æ¥ä¿å­˜éœ€è¦çš„ä¿¡æ¯ã€‚å¦å¤–ï¼Œåœ¨è®¡ç®—ç¦»é¶å¿ƒçš„è·ç¦»çš„æ—¶å€™ï¼Œä¸éœ€è¦å››èˆäº”å…¥ã€‚ å…¶å®žè¿™ä¸ªé¢˜ï¼Œå³ä¾¿æ²¡æœ‰ç”¨ sqrt å°†çœŸæ­£çš„è·ç¦»ç®—å‡ºæ¥ï¼Œä¹Ÿæ˜¯å¯ä»¥ AC çš„ã€‚å¦‚æžœè®¾ç½®éžå¸¸ç›¸è¿‘çš„ä¸¤ç»„è§£ï¼ˆå¤§æ¦‚åªæœ‰å°æ•°éƒ¨åˆ†æœ‰å‡ ä½å·®ï¼‰ï¼Œå¯èƒ½å°±èƒ½å¡æŽ‰å¾ˆå¤šä»£ç äº†ã€‚ Code1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;struct athlete&#123; char id[5]; int x, y, dis; &#125; ath[maxn];bool cmp(athlete a, athlete b) &#123; return a.dis &lt; b.dis;&#125;int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", ath[i].id, &amp;ath[i].x, &amp;ath[i].y); ath[i].dis = sqrt(ath[i].x * ath[i].x + ath[i].y * ath[i].y); &#125; sort(ath, ath + n, cmp); printf("%s %s", ath[0].id, ath[n - 1].id); return 0;&#125; 1083 æ˜¯å¦å­˜åœ¨ç›¸ç­‰çš„å·®Analysisè¿™ä¸ªé¢˜æ¯”è¾ƒç®€å•ï¼Œå€Ÿç€è¿™ä¸ªé¢˜ï¼Œæƒ³äº†æƒ³ map èƒ½ä¸èƒ½ä»Žå¤§åˆ°å°æŽ’åˆ—ï¼ŒæŸ¥äº†ä¸‹èµ„æ–™è¿˜çœŸçš„å¯ä»¥ã€‚éœ€è¦æ³¨æ„çš„ç‚¹å°±æ˜¯ï¼Œåªæœ‰é‡å¤çš„æ•°æ‰è¾“å‡ºï¼Œæ¢å¥è¯è¯´ï¼Œå°±æ˜¯å‡ºçŽ°æ¬¡æ•°å¤§äºŽç­‰äºŽ 2ã€‚ä¸è¿‡ï¼Œè¿™ä¸ªé¢˜ï¼Œå…¶å®žç›´æŽ¥å¼€ä¸€ä¸ªå¾ˆå¤§çš„æ•°ç»„å°±å¯ä»¥äº†ã€‚ Codeuse map1234567891011121314151617181920212223#include &lt;cstdio&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct cmp &#123; bool operator()(const int k1, const int k2) &#123; return k1 &gt; k2; &#125;&#125;;map&lt;int, int, cmp&gt; mp;int main() &#123; int n, tmp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;tmp); mp[abs(tmp - i)]++; &#125; for(map&lt;int, int&gt;::iterator it = mp.begin(); it != mp.end(); it++) &#123; if(it-&gt;second &gt;= 2) printf("%d %d\n", it-&gt;first, it-&gt;second); &#125; return 0;&#125; use array1234567891011121314151617#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 10000 + 5;int n, appear[maxn] = &#123;0&#125;, tmp;int main() &#123; cin &gt;&gt; n; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; tmp; appear[abs(tmp - i)]++; &#125; for(int i = 9999; i &gt;= 0; i--) &#123; if(appear[i] &gt; 1) cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; appear[i] &lt;&lt; endl; &#125; return 0;&#125; 1084 å¤–è§‚æ•°åˆ—AnalysisæŒ‰ç…§é¢˜ç›®ç»™çš„è¿‡ç¨‹æ¨¡æ‹Ÿï¼Œå­—ç¬¦ä¸²æ•°ç»„ä¸€å®šè¦å¼€å¤§ä¸€ç‚¹ã€‚ Code1234567891011121314151617181920212223#include &lt;cstdio&gt;char str1[100005], str2[100005];int n;int main() &#123; scanf("%s %d", str1, &amp;n); for(int i = 1; i &lt; n; i++) &#123; int len = 0; for(int j = 0; str1[j] != '\0'; j++) &#123; str2[len++] = str1[j]; int count = 1, k; for(k = j + 1; str1[k] == str1[j]; k++) count++; str2[len++] = count + '0'; j = --k; &#125; str2[len] = '\0'; for(int j = 0; j &lt;= len; j++) &#123; str1[j] = str2[j]; &#125; &#125; printf("%s", str1); return 0;&#125; 1085 PATå•ä½æŽ’è¡ŒAnalysiså¾ˆå¸¸è§„çš„æŽ’åºé¢˜ï¼Œç”¨ map å»ºç«‹å­¦æ ¡åå­—ä¸Žæ•°ç»„ä¸‹æ ‡çš„å¯¹åº”å…³ç³»ï¼Œæ¯è¯»å…¥ä¸€ä¸ªåˆ†æ•°å°±ç»Ÿè®¡ä¸€ä¸ªè€ƒç”Ÿã€‚è®¡ç®—å­¦æ ¡æŽ’åæ—¶ï¼Œè¦æ³¨æ„å…ˆæŒ‰ç…§å­¦æ ¡æ€»åˆ†æŽ’åºåŽï¼Œå†è¿›è¡ŒæŽ’åã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cctype&gt;using namespace std;const int maxn = 100000 + 5;struct school&#123; string name; int sum_score, A, B, T, rank, men;&#125; sch[maxn];map&lt;string, int&gt; sch_name2num;bool cmp(school a, school b) &#123; if(a.sum_score != b.sum_score) return a.sum_score &gt; b.sum_score; else if(a.men != b.men) return a.men &lt; b.men; else return a.name &lt; b.name;&#125;void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; sch[i].sum_score = sch[i].A = sch[i].B = sch[i].T = sch[i].men = 0; sch[i].rank = maxn; &#125;&#125;int main() &#123; Init(); int n, score, count = 0; cin &gt;&gt; n; string stu_name, sch_name; while(n--) &#123; cin &gt;&gt; stu_name &gt;&gt; score &gt;&gt; sch_name; for(int i = 0; i &lt; sch_name.length(); i++) &#123; sch_name[i] = tolower(sch_name[i]); &#125; if(sch_name2num.find(sch_name) == sch_name2num.end()) &#123; sch[count].name = sch_name; sch_name2num[sch_name] = count++; &#125; if(stu_name[0] == 'B') &#123; sch[sch_name2num[sch_name]].B += score; &#125; else if(stu_name[0] == 'A') &#123; sch[sch_name2num[sch_name]].A += score; &#125; else if(stu_name[0] == 'T') &#123; sch[sch_name2num[sch_name]].T += score; &#125; sch[sch_name2num[sch_name]].men++; &#125; for(int i = 0; i &lt; count; i++) &#123; sch[i].sum_score = (int)(sch[i].B / 1.5 + sch[i].A + sch[i].T * 1.5); &#125; sort(sch, sch + count, cmp); sch[0].rank = 1; cout &lt;&lt; count &lt;&lt; endl; cout &lt;&lt; sch[0].rank &lt;&lt; ' ' &lt;&lt; sch[0].name &lt;&lt; ' ' &lt;&lt; sch[0].sum_score &lt;&lt; ' ' &lt;&lt; sch[0].men &lt;&lt; endl; for(int i = 1; i &lt; count; i++) &#123; if(sch[i].sum_score == sch[i - 1].sum_score) sch[i].rank = sch[i - 1].rank; else sch[i].rank = i + 1; cout &lt;&lt; sch[i].rank &lt;&lt; ' ' &lt;&lt; sch[i].name &lt;&lt; ' ' &lt;&lt; sch[i].sum_score &lt;&lt; ' ' &lt;&lt; sch[i].men &lt;&lt; endl; &#125; return 0;&#125; 1086 å°±ä¸å‘Šè¯‰ä½ Analysisæ°´é¢˜ä¸€é“ï¼Œæ³¨æ„$700$ï¼Œä¸è¦å€’ç€è¾“å‡ºä¸º$007$äº†ã€‚ Codeversion 1123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int A, B, Product, temp, digit, result = 0; scanf("%d %d", &amp;A, &amp;B); Product = A * B; temp = Product; while(temp) &#123; digit = temp % 10; temp /= 10; result = result * 10 + digit; &#125; printf("%d\n", result); return 0;&#125; version 21234567891011121314151617#include &lt;cstdio&gt;char ans[10];int main() &#123; int A, B, C, len = 0; scanf("%d %d", &amp;A, &amp;B); C = A * B; do&#123; ans[len++] = C % 10 + '0'; C /= 10; &#125; while(C != 0); ans[len] = '\0'; char *p = ans; while(*p == '0') p++; puts(p); return 0;&#125; 1087 æœ‰å¤šå°‘ä¸åŒçš„å€¼Analysiså‡ºçŽ°è¿‡çš„æ•°ï¼Œåªç»Ÿè®¡ä¸€æ¬¡ã€‚ Codeversion 1123456789101112131415#include &lt;cstdio&gt;const int maxn = 20000 + 5;int appear[maxn] = &#123;0&#125;;int main() &#123; int N, n, ans = 0; scanf("%d", &amp;N); for(n = 1; n &lt;= N; n++) &#123; appear[n / 2 + n / 3 + n / 5]++; &#125; for(n = 0; n &lt;= maxn; n++) &#123; if(appear[n]) ans++; &#125; printf("%d", ans); return 0;&#125; version 2å¦‚æžœä»Žæ•°å­¦çš„è§’åº¦æ€è€ƒï¼Œéšç€ N çš„å¢žå¤§ï¼Œè®¡ç®—ç»“æžœä¹Ÿä¼šä¾æ¬¡å¢žå¤§ï¼Œæ‰€ä»¥ä¸€å¼€å§‹çš„å€¼æ˜¯æœ€å°çš„ï¼Œè¿™æ ·å°±å¯ä»¥ä¸ç”¨æ•£åˆ—ï¼Œåªç”¨å˜é‡è®°å½•å½“å‰è®¡ç®—çš„å€¼ï¼Œå¦‚æžœæ¯”ä¹‹å‰çš„å°ï¼Œå°±ç®—æ˜¯ä¸åŒçš„å€¼äº†ï¼Œå¦‚ä¸‹ï¼š123456789101112#include &lt;cstdio&gt;int main() &#123; int N, n, ans = 0, m = -1; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; n = i / 2 + i / 3 + i / 5; if(n &gt; m) ans++; m = n; &#125; printf("%d", ans); return 0;&#125; 1088 ä¸‰äººè¡ŒAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹åƒé¸¡å…”åŒç¬¼çš„é—®é¢˜ï¼Œå®žé™…ä¸Šå°±æ˜¯å¤šå…ƒæ–¹ç¨‹æ±‚å¯èƒ½è§£ã€‚å”¯ä¸€çš„å‘ç‚¹åœ¨äºŽï¼Œä¸™çš„å€¼å¯èƒ½æ˜¯ä¸ªå°æ•°ã€‚å¦å¤–ï¼Œè¦ä»¥ç”²çš„æœ€å¤§è§£ä¸ºå‡†ï¼Œå¯ä»¥ä»Žå¤§åˆ°å°è¿›è¡Œæžšä¸¾ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cmath&gt;int m, x, y, a, b, tmp, i, j;double c, k;void print(double t) &#123; if(m &lt; t) printf(" Cong"); else if(m == t) printf(" Ping"); else printf(" Gai");&#125;int main() &#123; scanf("%d %d %d", &amp;m, &amp;x, &amp;y); bool flag = false; for(i = 10; i &lt;= 99; i++) &#123; tmp = i; j = tmp % 10 * 10 + tmp / 10; k = abs(i - j) * 1.0 / x; if(j == y * k) &#123; flag = true; a = i, b = j, c = k; &#125; &#125; if(flag) &#123; printf("%d", a); print(a), print(b), print(c); &#125; else printf("No Solution"); return 0;&#125; 1089 ç‹¼äººæ€-ç®€å•ç‰ˆAnalysisè¿™ä¸ªé¢˜æƒ³äº†å¾ˆä¹…ï¼Œæ²¡ä»€ä¹ˆæ€è·¯ï¼Œæ„Ÿè§‰å¾ˆæ€ªï¼ŒåŽæ¥çœ‹äº†ä¸€ä¸‹åˆ«äººçš„ä»£ç ï¼Œå‘çŽ°æ˜¯ä¸€é“æ¨¡æ‹Ÿé¢˜ï¼ˆå…¶å®žè·Ÿä¸Šä¸€é¢˜çš„æ¨¡æ‹Ÿæ€è·¯å¾ˆåƒï¼‰ã€‚åšæ³•å°±æ˜¯æŒ‰ç…§åºå·ä»Žå°åˆ°å¤§ä¸æ–­çš„å‡è®¾ 2 ä¸ªäººæ˜¯ç‹¼äººï¼Œåˆ¤æ–­æ˜¯å¦ç¬¦åˆæ¡ä»¶ã€‚å¦‚æžœç¬¦åˆï¼Œé‚£å°±è¾“å‡ºè¿™ä¸ªè§£åŽç›´æŽ¥é€€å‡ºç¨‹åºï¼›å¦‚æžœæ²¡æ‰¾åˆ°ï¼Œå°±è¾“å‡º No Solution ã€‚å‚è€ƒï¼š1089 ç‹¼äººæ€-ç®€å•ç‰ˆ (20 åˆ†)PAT 1089 ç‹¼äººæ€-ç®€å•ç‰ˆï¼ˆ20 åˆ†ï¼‰- ä¹™çº§ PSï¼šè¿™ä¸ªé¢˜çš„éš¾ç‚¹ä¸åœ¨äºŽé—®é¢˜çš„å¤æ‚æ€§ï¼Œåœ¨äºŽå¯¹å®žé™…é—®é¢˜çš„æŠ½è±¡èƒ½åŠ›ã€‚ Code123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100 + 5;int fact[maxn] = &#123;0&#125;, iswolf[maxn], lie[maxn];int main() &#123; int n; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;fact[i]); &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = i + 1; j &lt;= n; j++) &#123; for(int i = 1; i &lt;= n; i++) &#123; iswolf[i] = 1; &#125; iswolf[i] = iswolf[j] = -1; int index = 0; for(int k = 1; k &lt;= n; k++) &#123; if(fact[k] * iswolf[abs(fact[k])] &lt; 0) lie[index++] = k; &#125; if(index == 2 &amp;&amp; iswolf[lie[0]] + iswolf[lie[1]] == 0) &#123; printf("%d %d\n", i, j); return 0; &#125; &#125; &#125; printf("No Solution"); return 0;&#125; 1090 å±é™©å“è£…ç®±Analysisè¿™ä¸ªé¢˜å¦‚æžœä¸ç”¨ STL çš„è¯ï¼Œç¡®å®žæœ‰ç‚¹éº»çƒ¦ï¼Œä¸€æ—¦ç”¨äº† STL å°±å¾ˆç®€å•äº†ã€‚å…ˆå°†å±é™©å“ä¿¡æ¯ç»Ÿè®¡å¥½ï¼Œç„¶åŽåœ¨éåŽ†è´§ç‰©æ¸…å•ä¸Šçš„æ¯ä¸€ä»¶ç‰©å“ï¼Œåˆ¤æ–­è´§ç‰©æ¸…å•ä¸Šæ˜¯å¦æœ‰ä¸ç›¸å®¹çš„ç‰©å“å³å¯ã€‚è€ƒè™‘åˆ°é¢˜ç›®å¯èƒ½ä¼šç»™é‡å¤çš„æ•°æ®ï¼Œæ‰€ä»¥ç”¨ SET æ¥å¤„ç†æ•°æ®å°±å¯ä»¥è‡ªåŠ¨åŽ»é‡äº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;set&gt;using namespace std;const int maxn = 100000 + 5;set&lt;int&gt; pairs[maxn], stuff;int n, m, k;int main() &#123; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; int tmp_a, tmp_b; cin &gt;&gt; tmp_a &gt;&gt; tmp_b; pairs[tmp_a].insert(tmp_b), pairs[tmp_b].insert(tmp_a); &#125; while(m--) &#123; cin &gt;&gt; k; stuff.clear(); for(int i = 0; i &lt; k; i++) &#123; int tmp; cin &gt;&gt; tmp; stuff.insert(tmp); &#125; bool flag = false; for(set&lt;int&gt;::iterator it1 = stuff.begin(); it1 != stuff.end(); it1++) &#123; int tmp1 = *it1; if(pairs[tmp1].size() == 0) continue; else &#123; for(set&lt;int&gt;::iterator it2 = pairs[tmp1].begin(); it2 != pairs[tmp1].end(); it2++) &#123; int tmp2 = *it2; if(stuff.find(tmp2) != stuff.end()) &#123; flag = true; break; &#125; &#125; &#125; if(flag) break; &#125; if(flag) cout &lt;&lt; "No\n"; else cout &lt;&lt; "Yes\n"; &#125; return 0;&#125; 1091 N-è‡ªå®ˆæ•°Analysisæ³¨æ„è¯»é¢˜ï¼Œåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦è‡ªå®ˆï¼Œå°±æ˜¯ç”¨è¿™ä¸ªæ•°çš„æœ€åŽå‡ ä½æž„æˆçš„æ•°å­—ä¸ŽåŽŸæ•°å­—æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰å³å¯ï¼Œè€Œâ€œæœ€åŽå‡ ä½â€å°±æ˜¯åŽŸæ•°å­—çš„ä½æ•°äº†ï¼Œèƒ½å¾—åˆ°è¿™ä¸ªç»†èŠ‚ï¼ˆé¢˜ç›®ä¸­çš„è¿™äº›ç»†èŠ‚ï¼ŒçœŸæ˜¯å«äººåˆçˆ±åˆæ¨ï¼‰åŽï¼Œè¿™ä¸ªé¢˜ç›®å°±å¾ˆç®€å•äº†ã€‚è¦å¾—åˆ°æœ€åŽå‡ ä½æž„æˆçš„æ•°å­—ï¼Œç›´æŽ¥ç”¨è¿™ä¸ªæ•°å¯¹åº”çš„æ•´æ•°å–ä½™å³å¯ï¼ˆæ¯”å¦‚ï¼Œ8 å¯¹åº” 10ï¼Œ88 å¯¹åº” 100ï¼Œä¾æ¬¡ç±»æŽ¨ï¼‰ã€‚æœ¬æ¥ä»¥ä¸ºï¼Œä½¿ç”¨intå¯èƒ½ä¼šæœ‰æµ‹è¯•ç‚¹ä¸è¿‡ï¼Œç»“æžœæ²¡æœ‰ï¼Œæ²¡è®¾ç½®å¤§æ•°çš„æµ‹è¯•ç‚¹ä¹ˆï¼Ÿå˜¿å˜¿ï¼Œé€ƒè¿‡ä¸€åŠ«~ Codeversion 112345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool Judge_Automorphic(int test_number, int original_number);int main(int argc, char const *argv[]) &#123; int M, N, K, each_item; bool flag; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;K); flag = false; for(N = 1; N &lt; 10; N++) &#123; each_item = N * K * K; if( Judge_Automorphic(each_item, K) ) &#123; flag = true; break; &#125; &#125; if(flag) &#123; printf("%d %d\n", N, each_item); &#125; else &#123; puts("No"); &#125; &#125; return 0;&#125;bool Judge_Automorphic(int test_number, int original_number) &#123; bool flag = false; int mask = 1, temp; temp = original_number; while(temp) &#123; temp /= 10; mask *= 10; &#125; temp = test_number; temp %= mask; if(temp == original_number) &#123; flag = true; &#125; return flag;&#125; version 212345678910111213141516171819202122232425#include &lt;cstdio&gt;int main() &#123; int n, k, m, digit, tmp; scanf("%d", &amp;m); while(m--) &#123; scanf("%d", &amp;k); tmp = k, digit = 1; while(tmp != 0) &#123; tmp /= 10; digit *= 10; &#125; bool flag = false; for(n = 1; n &lt; 10; n++) &#123; tmp = n * k * k; if(tmp % digit == k) &#123; flag = true; break; &#125; &#125; if(flag) printf("%d %d\n", n, tmp); else printf("No\n"); &#125; return 0;&#125; 1092 æœ€å¥½åƒçš„æœˆé¥¼Analysisç»Ÿè®¡æ‰€æœ‰æœˆé¥¼çš„é”€é‡ï¼Œæ‰¾åˆ°æœ€å¤§å€¼è¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int maxn = 1000 + 5;int sales[maxn] = &#123;0&#125;;int main() &#123; int n, m, tmp; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;tmp); sales[j] += tmp; &#125; &#125; int max = sales[1]; for(int i = 2; i &lt;= n; i++) &#123; if(max &lt; sales[i]) max = sales[i]; &#125; printf("%d\n", max); bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; if(max == sales[i]) &#123; if(flag) &#123; printf("%d", i); flag = false; &#125; else printf(" %d", i); &#125; &#125; return 0;&#125; 1093 å­—ç¬¦ä¸²A+BAnalysisåˆ†åˆ«éåŽ†ä¸¤ä¸ªå­—ç¬¦ä¸²ï¼Œæ¯è¾“å‡ºä¸€ä¸ªå­—ç¬¦ï¼Œå°±å°†è¿™ä¸ªå­—ç¬¦æ ‡è®°ä¸ºå·²å‡ºçŽ°ï¼Œä¸‹æ¬¡å°±ä¸åœ¨è¾“å‡ºäº†ã€‚ Code123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;bool isappear[256] = &#123;false&#125;;int main() &#123; string a, b; getline(cin, a); getline(cin, b); for(int i = 0; i &lt; a.length(); i++) &#123; if(!isappear[a[i]]) &#123; cout &lt;&lt; a[i]; isappear[a[i]] = true; &#125; &#125; for(int i = 0; i &lt; b.length(); i++) &#123; if(!isappear[b[i]]) &#123; cout &lt;&lt; b[i]; isappear[b[i]] = true; &#125; &#125; return 0;&#125; 1094 è°·æ­Œçš„æ‹›è˜Analysiså”¯ä¸€è¦æ³¨æ„çš„ç‚¹å°±æ˜¯ï¼Œæœ€ç»ˆè¦è¾“å‡ºçš„ä¸æ˜¯æ•°ï¼Œè€Œæ˜¯å­—ç¬¦ä¸²ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;bool isprime(int a) &#123; if(a &lt;= 1) return false; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; return true;&#125;char num[1005];int main() &#123; int l, k; scanf("%d %d%*c", &amp;l, &amp;k); scanf("%s", num); bool flag = false; for(int i = 0; i + k &lt;= l; i++) &#123; int number = 0; for(int j = i; j &lt; i + k; j++) &#123; number = number * 10 + num[j] - '0'; &#125; if(isprime(number)) &#123; for(int j = i; j &lt; i + k; j++) &#123; printf("%c", num[j]); &#125; flag = true; break; &#125; &#125; if(!flag) printf("404"); return 0;&#125; 1095 è§£ç PATå‡†è€ƒè¯Analysisè¿™ä¸ªé¢˜ç»™çš„ä¿¡æ¯å¾ˆå¤šï¼ŒæŒ‰ç…§ä¸åŒçš„ç»Ÿè®¡è¦æ±‚ï¼Œåˆ†åˆ«åˆ©ç”¨å¯¹åº”çš„ä¿¡æ¯æ¥å¤„ç†ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯æŽ’åºé¢˜ï¼Œæ‰€ä»¥å¤„ç†çš„æ–¹æ³•åŸºæœ¬ä¸Šæ˜¯å·®ä¸å¤šçš„ï¼Œåªæ˜¯æœ‰äº›åœ°æ–¹è¦æ³¨æ„ä¸€ä¸‹ï¼š æµ‹è¯•ç‚¹ 3 æ˜¯å¡æ—¶é—´çš„ï¼Œè¦ç”¨ unordered_mapï¼Œå¹¶ä¸”æŽ’åºå‡½æ•°è¦ä½¿ç”¨å¼•ç”¨çš„å†™æ³•ï¼Œè¿™æ ·æ›´å¿«ã€‚ æŒ‡ä»¤ 3ï¼Œæ¯æ¬¡ä¸åŒè€ƒåœºçš„äººæ•°ç»Ÿè®¡å®ŒæˆåŽè¦é‡ç½®ä¸º 0ï¼Œä»¥å…åˆæœ‰æŒ‡ä»¤ 3 æŸ¥è¯¢å¯¼è‡´å åŠ ã€‚ æŒ‡ä»¤ 2 å­˜åœ¨æ€»åˆ†ä¸º 0 çš„æƒ…å†µï¼Œæ‰€ä»¥ä¸è¦ç”¨åˆ†æ•°æ¥å½“ä½œåˆ¤æ–­æ¡ä»¶ï¼Œè¿™ä¹Ÿæ˜¯è‡ªå·±çŠ¯çš„é”™è¯¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;unordered_map&gt;using namespace std;const int maxn = 10000 +5;struct student &#123; char level; string id, exam_room, exam_date; int score;&#125; stu[maxn];struct examroom &#123; string roomid; int men;&#125; examro[maxn];bool cmp1(student &amp;a, student &amp;b) &#123; if(a.level != b.level) return a.level &lt; b.level; else if(a.score != b.score) return a.score &gt; b.score; else return a.id &lt; b.id;&#125;bool cmp2(examroom &amp;a, examroom &amp;b) &#123; if(a.men != b.men) return a.men &gt; b.men; else return a.roomid &lt; b.roomid;&#125;void Init_examro() &#123; for(int i = 0; i &lt; maxn; i++) &#123; examro[i].roomid.resize(10); examro[i].men = 0; &#125;&#125;int main() &#123; int n, m, mode; string md, tmp; tmp.resize(15); scanf("%d %d%*c", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; scanf("%c%s %d%*c", &amp;stu[i].level, tmp.c_str(), &amp;stu[i].score); stu[i].exam_room = tmp.substr(0, 3); stu[i].exam_date = tmp.substr(3, 6); stu[i].id = tmp; &#125; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; mode &gt;&gt; md; bool flag = false; printf("Case %d: %d %s\n", i, mode, md.c_str()); if(mode == 1) &#123; sort(stu, stu + n, cmp1); for(int i = 0; i &lt; n; i++) &#123; if(md[0] == stu[i].level) &#123; printf("%c%s %d\n", stu[i].level, stu[i].id.c_str(), stu[i].score); flag = true; &#125; &#125; &#125; else if(mode == 2) &#123; int sum = 0, men = 0; for(int i = 0; i &lt; n; i++) &#123; if(md == stu[i].exam_room) &#123; sum += stu[i].score; men++; &#125; &#125; if(men) &#123; printf("%d %d\n", men, sum); flag = true; &#125; &#125; else if(mode == 3) &#123; int count = 0; unordered_map&lt;string, int&gt; room2num; Init_examro(); for(int i = 0; i &lt; n; i++) &#123; if(md == stu[i].exam_date) &#123; if(room2num.find(stu[i].exam_room) == room2num.end()) &#123; room2num[stu[i].exam_room] = count++; examro[room2num[stu[i].exam_room]].roomid = stu[i].exam_room; &#125; examro[room2num[stu[i].exam_room]].men++; &#125; &#125; sort(examro, examro + count, cmp2); for(int i = 0; i &lt; count; i++) &#123; printf("%s %d\n", examro[i].roomid.c_str(), examro[i].men); flag = true; &#125; &#125; if(!flag) cout &lt;&lt; "NA" &lt;&lt; endl; &#125; return 0;&#125; 1096 å¤§ç¾Žæ•°Analysisè¿™ä¸ªé¢˜åˆšå¼€å§‹è¯»çš„æ—¶å€™ï¼Œæ„Ÿè§‰æœ‰ç‚¹æ€ªï¼Œä»”ç»†ä¸€æƒ³ï¼Œ15 åˆ†çš„é¢˜ï¼Œåº”è¯¥ä¸ä¼šè®¾ç½®ä¸€äº›éš¾è¿‡çš„æµ‹è¯•ç‚¹ã€‚äº‹å®žä¹Ÿæ˜¯è¿™æ ·ï¼Œç›´æŽ¥ç”¨æš´åŠ›æžšä¸¾å°±å¯ä»¥äº†ã€‚æ³¨æ„ï¼š N æ˜¯é™¤æ•°ï¼Œ4 ä¸ªå› æ•°ä¹‹å’Œæ˜¯è¢«é™¤æ•°ã€‚ 1 ä¸Ž N æœ¬èº«ä¹Ÿæ˜¯å› æ•°ã€‚ Codeå¤šå†™åˆ¤æ–­è¯­å¥å’Œç¼©çŸ­å¾ªçŽ¯æ¡ä»¶æ˜¯ä¸ºäº†å‡å°‘æ‰§è¡Œæ¬¡æ•°ï¼ŒåŠ å¿«è¿è¡Œæ—¶é—´ï¼Œå°±æœ¬é¢˜è€Œè¨€ï¼Œå®žé™…æå‡äº† 1 msðŸ˜‚ã€‚1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;const int maxn = 10000 + 5;int factor[maxn] = &#123;1&#125;; int main() &#123; int k, n; scanf("%d", &amp;k); while(k--) &#123; int cnt = 1; scanf("%d", &amp;n); for(int i = 2; i &lt;= n; i++) &#123; if(n % i == 0) factor[cnt++] = i; &#125; if(cnt &lt; 4) printf("No\n"); else &#123; bool flag = false; for(int i = 0; i &lt; cnt - 3; i++) &#123; for(int j = i + 1; j &lt; cnt - 2; j++) &#123; for(int k = j + 1; k &lt; cnt - 1; k++) &#123; for(int l = k + 1; l &lt; cnt; l++) &#123; if((factor[i] + factor[j] + factor[k] + factor[l]) % n == 0) &#123; printf("Yes\n"); flag = true; goto out; &#125; &#125; &#125; &#125; &#125; out: if(!flag) printf("No\n"); &#125; &#125; return 0;&#125; 1097 çŸ©é˜µè¡Œå¹³ç§»Analysisè€ƒå¯ŸäºŒç»´æ•°ç»„çš„æ¦‚å¿µå’Œä¸€ç»´æ•°ç»„å…ƒç´ åŽç§»çš„æ“ä½œï¼Œæ³¨æ„è¦å…ˆåŽç§»åœ¨æ”¹å€¼ã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;int matrix[105][105] = &#123;0&#125;, n, k, x;;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;x); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; scanf("%d", &amp;matrix[i][j]); &#125; &#125; int s = 1; for(int i = 1; i &lt;= n; i+=2) &#123; for(int j = n - s; j &gt;= 1; j--) &#123; matrix[i][j + s] = matrix[i][j]; &#125; for(int j = 1; j &lt;= s; j++) &#123; matrix[i][j] = x; &#125; if(s == k) s = 1; else s++; &#125; for(int i = 1; i &lt;= n; i++) &#123; int sum = 0; for(int j = 1; j &lt;= n; j++) &#123; sum += matrix[j][i]; &#125; printf("%d", sum); if(i != n) printf(" "); &#125; return 0;&#125; 1098 å²©æ´žæ–½å·¥Analysisè¿™ä¸ªé¢˜è‡ªå·±ä¸€å¼€å§‹æƒ³æ­ªäº†ï¼Œæ€»æ˜¯æŠŠæ³¨æ„åŠ›é›†ä¸­åœ¨ç›¸åŒæ¨ªåæ ‡çš„ç‚¹çš„çºµåæ ‡ä¹‹å·®å¾—å¤§äºŽ 1ï¼Œæ‰èƒ½æ”¾å…¥ç®¡é“ã€‚ç„¶åŽåˆè€ƒè™‘ä¸åŒæ¨ªåæ ‡ä¸‹çš„ç‚¹çš„çºµåæ ‡ä¹‹å·®è¦è¾¾åˆ°å¤šå°‘æ‰åˆé€‚ã€‚å®žé™…ä¸Šï¼Œåªéœ€è¦è€ƒè™‘é¡¶éƒ¨ç‚¹çš„æœ€ä½Žç‚¹ä¸Žåº•éƒ¨ç‚¹çš„æœ€é«˜ç‚¹çš„çºµåæ ‡ä¹‹å·®å°±å¯ä»¥äº†ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;int main() &#123; int n, tmp, up_low = 1005, down_high = 0; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); if(up_low &gt; tmp) up_low = tmp; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); if(down_high &lt; tmp) down_high = tmp; &#125; tmp = up_low - down_high; if(tmp &gt; 0) printf("Yes %d", tmp); else printf("No %d", 1 - tmp); return 0;&#125;/*in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 2 3 3 2 1 2 3out:Yes 1in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 4 3 2 1 2 3out:No 1in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 5 3 2 1 2 3out:No 2in:117 6 5 5 6 5 4 5 5 4 43 2 2 2 3 6 3 2 1 2 3out:No 3*/ 1099 æ€§æ„Ÿç´ æ•°Analysisæ³¨æ„ï¼šæ€§æ„Ÿç´ æ•°æ˜¯ä¸€å¯¹ä¸€å¯¹å­˜åœ¨çš„ï¼Œæµ‹è¯•ç‚¹ 3 å°±ç»™çš„æ˜¯ä¸ç¬¦åˆæ¡ä»¶çš„ nï¼Œä½†æ˜¯ä¸Ž n-6 æž„æˆäº†ä¸€å¯¹æ€§æ„Ÿç´ æ•°ã€‚é‚£ä¹ˆï¼ŒæŒ‰ç…§è¦æ±‚è¾“å‡ºçš„å°±æ˜¯å¤§äºŽ n çš„æœ€å°æ€§æ„Ÿç´ æ•°ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int main() &#123; int n; scanf("%d", &amp;n); if(isprime(n) &amp;&amp; isprime(n - 6)) printf("Yes\n%d", n - 6); else if(isprime(n) &amp;&amp; isprime(n + 6)) printf("Yes\n%d", n); else &#123; while(n++) &#123; if(isprime(n) &amp;&amp; isprime(n - 6) || isprime(n) &amp;&amp; isprime(n + 6)) break; &#125; printf("No\n%d", n); &#125; return 0;&#125; 1100 æ ¡åº†Analysisåˆ©ç”¨ set å­˜å‚¨æ ¡å‹ä¿¡æ¯ï¼Œè¯»å…¥å‚åŠ æ ¡åº†çš„äººå‘˜ä¿¡æ¯åŽï¼Œåœ¨ set ä¸­æŸ¥æ‰¾ï¼Œæ˜¯å¦æ˜¯æ ¡å‹ï¼Œç»Ÿè®¡æ ¡å‹ä¸ªæ•°ã€‚å› ä¸ºæœ€ç»ˆè¦è¾“å‡ºçš„ç»“æžœæ˜¯æœ€å¹´é•¿çš„äººï¼Œæ‰€ä»¥éœ€è¦æŒ‰ç…§å‡ºç”Ÿæ—¥æœŸè¿›è¡Œåˆ†ç±»æŽ’åºï¼ˆæ ¡å‹ä¸Žéžæ ¡å‹ï¼‰ï¼Œé»˜è®¤å°†æ ¡å‹æ”¾åœ¨å‰é¢ï¼Œè¾“å‡ºä¼šæ–¹ä¾¿ä¸€äº›ã€‚ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;set&lt;string&gt; xiaoyou;struct guest&#123; string id, birth; int flag;&#125; g[maxn];bool cmp(guest a, guest b) &#123; if(a.flag != b.flag) return a.flag &gt; b.flag; else return a.birth &lt; b.birth;&#125;int main() &#123; string tmp; int n, m; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; xiaoyou.insert(tmp); &#125; int count = 0; cin &gt;&gt; m; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; g[i].id; g[i].birth = g[i].id.substr(6, 8); if(xiaoyou.find(g[i].id) != xiaoyou.end()) &#123; count++; g[i].flag = 1; &#125; &#125; sort(g, g + m, cmp); cout &lt;&lt; count &lt;&lt; endl &lt;&lt; g[0].id; return 0;&#125; 1101 Bæ˜¯Açš„å¤šå°‘å€Analysisè¿™ä¸ªé¢˜å·®ç‚¹æƒ³æ­ªäº†ä»Žå­—ç¬¦ä¸²çš„è§’åº¦åšï¼Œå®žé™…ä¸Šç›´æŽ¥ä»Žæ•°çš„è§’åº¦åšæ›´ç®€å•ï¼Œå› ä¸ºä½æ•° d æ˜¯ç»™å®šçš„ã€‚ Code123456789101112131415#include &lt;cstdio&gt;#include &lt;cmath&gt;int main() &#123; int a, d, tmp, digit = 0, b; scanf("%d %d", &amp;a, &amp;d); tmp = a; while(tmp != 0) &#123; tmp /= 10; digit++; &#125; tmp = a % (int)pow(10, d); b = tmp * pow(10, digit - d) + a / pow(10, d); printf("%.2lf", b * 1.0 / a);&#125; 1102 æ•™è¶…å† å†›å·Analysisç»“æž„ä½“å­˜å‚¨ä¿¡æ¯ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æœ€å¤§å€¼å³å¯ã€‚ Code12345678910111213141516171819202122232425262728#include &lt;cstdio&gt;const int maxn = 10000 + 5;struct test&#123; char id[9]; int price, amount, sum;&#125; te[maxn]; int main() &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d %d", te[i].id, &amp;te[i].price, &amp;te[i].amount); te[i].sum = te[i].price * te[i].amount; &#125; int max_amount = te[0].amount, max_sum = te[0].sum, index1 = 0, index2 = 0; for(int i = 1; i &lt; n; i++) &#123; if(max_amount &lt; te[i].amount) &#123; max_amount = te[i].amount; index1 = i; &#125; if(max_sum &lt; te[i].sum) &#123; max_sum = te[i].sum; index2 = i; &#125; &#125; printf("%s %d\n%s %d\n", te[index1].id, max_amount, te[index2].id, max_sum); return 0;&#125; 1103 ç¼˜åˆ†æ•°AnalysisæŒ‰ç…§é¢˜ç›®è¦æ±‚æ¨¡æ‹Ÿå³å¯ï¼Œæ³¨æ„ 2 ä¸ªåœ°æ–¹ï¼š å¤šæ•°ç›¸ä¹˜çš„è¿‡ç¨‹ä¸­å¯èƒ½ä¼šæº¢å‡ºï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨long longæ¯”è¾ƒå¥½ã€‚ sqrtçš„è¿”å›žå€¼å¼ºè½¬åŽä¼šä¸¢æŽ‰å°æ•°ï¼Œåªå–æ•´æ•°éƒ¨åˆ†ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­å¹³æ–¹ç›¸ç­‰æ˜¯å¦æˆç«‹ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cmath&gt;typedef long long LL;int main() &#123; LL m, n, a, b, c, tmp; scanf("%lld %lld", &amp;m, &amp;n); bool flag = false; for(; m &lt;= n; m++) &#123; a = m; tmp = a * a * a - (a - 1) * (a - 1) * (a - 1); c = sqrt(tmp); if(c * c != tmp) continue; else &#123; for(b = 1; b &lt; c; b++) &#123; if(c == b * b + (b - 1) * (b - 1)) &#123; flag = true; printf("%lld %lld\n", a, b); &#125; &#125; &#125; &#125; if(!flag) printf("No Solution\n"); return 0;&#125; 1104 å¤©é•¿åœ°ä¹…Analysisè¿™ä¸ªé¢˜éœ€è¦ä¸€å®šçš„æ•°å­¦èƒ½åŠ›ï¼Œä¸ç„¶æ‹¿ä¸åˆ°æ»¡åˆ†ï¼Œæ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š æœ€ç»ˆè¾“å‡ºçš„ç»“æžœéœ€è¦æŒ‰ç…§ n æˆ– A çš„é€’å¢žé¡ºåºè¾“å‡ºï¼Œæ‰€ä»¥éœ€è¦æŽ’åºï¼Œä½¿ç”¨ set æ˜¯æœ€æ–¹ä¾¿çš„ã€‚ ç›´æŽ¥æš´åŠ›æžšä¸¾ä¼šè¶…æ—¶ï¼Œéœ€è¦æŽ’é™¤æŽ‰ä¸€äº›ç‰¹æ®Šæƒ…å†µï¼Œåˆ† 3 ç§æƒ…å†µè€ƒè™‘ï¼š A çš„ä¸ªä½æ•°æ˜¯ 1-8ï¼Œæ­¤æ—¶ $gcd(m, n)$ å°±åªå¯èƒ½æ˜¯ 1ï¼Œä¸æ»¡è¶³æ¡ä»¶ã€‚ A çš„ä¸ªä½æ•°æ˜¯ 9ï¼Œä»¥ 1009 ä¸ºä¾‹ï¼Œå…¶å„ä½æ•°å­—ä¹‹å’Œä¸º 10ï¼ŒåŠ  1 åŽæ˜¯ 1010ï¼Œå„ä½æ•°å­—ä¹‹å’Œä¸º 2ï¼Œç›¸å·® 8ï¼Œè€Œ $gcd(11, 2$ å°±æ˜¯ 1 äº†ã€‚å®žé™…ä¸Šå¯ä»¥å‘çŽ°ï¼Œ$m = n + 9 - 1 = n + 8$ï¼Œä»Žè€Œå¯ä»¥å¾—åˆ°ï¼Œ$gcd(m, n) = gcd(n + 8, n) = gcd(n, (n + 8) \% n) = gcd(n, 8)$ï¼Œæ‰€ä»¥ï¼Œè¿™ç§æƒ…å†µä¸‹ï¼Œå…¬çº¦æ•°åªå¯èƒ½å– 1ã€2ã€4ã€8ï¼Œä¹Ÿä¸æ»¡è¶³æ¡ä»¶ã€‚ A çš„åä½æ•°å’Œä¸ªä½æ•°éƒ½æ˜¯ 9ï¼Œé‚£ä¹ˆæŒ‰ç…§ä¸Šé¢çš„æ€è·¯å°±æœ‰ $m = n + 9 + 9 - 1$ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥ç†è§£æˆ $n = m - 9 - 9 + 1$ï¼Œå› ä¸ºå†å¤šçš„ 9 ä¹Ÿåªæœ‰ 1 ä¸ªè¿›ä½ï¼Œè¿™æ ·è§£é‡Šå¯èƒ½æ›´æ˜“äºŽç†è§£ï¼‰ï¼Œä»Žè€Œ $gcd(m, n) = gcd(n, 17)$ï¼Œå…¬çº¦æ•°å¯èƒ½å– 1ã€17ï¼Œ17 æ˜¯æ»¡è¶³æ¡ä»¶çš„ã€‚çŽ°åœ¨å°±çŸ¥é“äº†ï¼ŒA çš„å°¾æ•°å¿…é¡»è‡³å°‘æœ‰ 2 ä½ 9 æ‰æ»¡è¶³æ¡ä»¶ï¼Œé‚£å°±ç›´æŽ¥ä»Žå°¾æ•°ä¸º 99 çš„æ•°å¼€å§‹éåŽ†ï¼Œæ¯æ¬¡åŠ  100 å³å¯ã€‚ è¿™ä¸ªé¢˜éœ€è¦åŠ¨ç‚¹è„‘ç­‹æ‰èƒ½æ‹¿æ»¡åˆ†ï¼Œç®—æ˜¯æœ‰ç‚¹éš¾ä½†åˆä¸æ˜¯å¤ªéš¾çš„é‚£ç§é¢˜ï¼Œæœ€ä¸»è¦çš„æ˜¯æ€Žä¹ˆæŠŠæ€è·¯å¾€æ•°å­¦ä¸Šæƒ³ã€‚å¦å¤–ï¼Œç´ æ•°çš„åˆ¤å®šï¼Œæ•°ä½æ±‚å’Œï¼Œå…¬çº¦æ•°æ±‚æ³•ï¼Œè¿™äº›å°è€ƒç‚¹ä¹Ÿè¦ä¼šæ‰è¡Œï¼Œè¿˜æœ‰ set å’Œ pair çš„ç”¨æ³•ä¹Ÿå¾—ä¼šï¼Œä¸ç„¶å†æ¥æŽ’åºçš„è¯ï¼Œå¯èƒ½åˆä¼šäº§ç”Ÿå…¶ä»–çš„é—®é¢˜ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;set&gt;using namespace std;set&lt;pair&lt;int, int&gt;&gt; res;bool isprime(int a) &#123; if(a &lt;= 1) return false; else &#123; for(int i = 2; i &lt;= sqrt(a); i++) &#123; if(a % i == 0) return false; &#125; &#125; return true;&#125;int gcd(int a, int b) &#123; return b == 0 ? a : gcd(b, a % b); &#125;int digitsum(int a) &#123; int res = 0; while(a != 0) &#123; res = res + a % 10; a /= 10; &#125; return res;&#125;int main() &#123; int N, n, k, m, tmp, g; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; printf("Case %d\n", i); scanf("%d %d", &amp;k, &amp;m); tmp = pow(10, k); bool flag = false; for(int j = 99 + pow(10, k - 1); j &lt; tmp; j += 100) &#123; if(digitsum(j) == m) &#123; n = digitsum(j + 1); g = gcd(m, n); if(g &gt; 2 &amp;&amp; isprime(g)) &#123; res.insert(make_pair(n, j)); flag = true; &#125; &#125; &#125; if(!flag) printf("No Solution\n"); else &#123; set&lt;pair&lt;int, int&gt;&gt;::iterator it = res.begin(); for(; it != res.end(); it++) &#123; printf("%d %d\n", it-&gt;first, it-&gt;second); &#125; res.clear(); &#125; &#125; return 0;&#125; 1105 é“¾è¡¨åˆå¹¶Analysisé¢˜ç›®ä¿è¯æ²¡æœ‰ç©ºé“¾è¡¨ï¼Œä½†æ˜¯æ²¡ä¿è¯ä¸€å®šæ²¡æœ‰æ— æ•ˆç»“ç‚¹ï¼Œæ‰€ä»¥ç›´æŽ¥å°†éœ€è¦å¤„ç†çš„é“¾è¡¨æ”¾åˆ°æ–°é“¾è¡¨é‡Œé¢ï¼Œå¹¶è®°å½•å¥½æœ‰æ•ˆç»“ç‚¹çš„ä¸ªæ•°ã€‚è™½ç„¶é¢˜ç›®è¦æ±‚çŸ­çš„é“¾è¡¨è¿›è¡Œé€†åºï¼Œä½†å®žé™…ä¸Šï¼Œä¹Ÿä¸æ˜¯éžå¾—é€†åºï¼Œç”¨æ ˆå­˜ä¸€ä¸‹ï¼Œå†è¾“å‡ºå°±è¡Œã€‚æŒ‰ç…§é•¿é“¾è¡¨è¾“å‡º 2 ä¸ªï¼ŒçŸ­é“¾è¡¨è¾“å‡º 1 ä¸ªçš„è¿‡ç¨‹äº¤æ›¿è¾“å‡ºï¼Œæ­¤æ—¶è¦è€ƒè™‘ 3 ç§æƒ…å†µï¼š è¾“å‡ºé•¿é“¾è¡¨è¦æ±‚è¾“å‡ºçš„ç¬¬ä¸€ä¸ªç»“ç‚¹ï¼Œè¿™ä¸ªç»“ç‚¹å¯èƒ½æ˜¯é•¿é“¾è¡¨çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œä¹Ÿå¯èƒ½ä¸æ˜¯ã€‚ è¾“å‡ºé•¿é“¾è¡¨è¦æ±‚è¾“å‡ºçš„ç¬¬äºŒä¸ªç»“ç‚¹ï¼Œè¿™ä¸ªç»“ç‚¹å¯èƒ½æ˜¯è¦è¾“å‡ºçš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œä¹Ÿå¯èƒ½ä¸æ˜¯ã€‚å¦‚æžœä¸æ˜¯ï¼Œé‚£ä¹ˆè¿™ä¸ªç»“ç‚¹çš„ next éœ€è¦è¾“å‡ºçŸ­é“¾è¡¨ä¸‹ä¸€ä¸ªè¦è¾“å‡ºçš„ç»“ç‚¹çš„åœ°å€ã€‚ è¾“å‡ºçŸ­é“¾è¡¨çš„ç»“ç‚¹ï¼Œè¿™ä¸ªç»“ç‚¹å¯èƒ½æ˜¯çŸ­é“¾è¡¨çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ä½†ä¸æ˜¯è¦è¾“å‡ºç»“ç‚¹çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ã€‚å¦‚æžœä¸æ˜¯ï¼Œé‚£å°±æ„å‘³ç€é•¿é“¾è¡¨è¿˜æœ‰ç»“ç‚¹æ²¡æœ‰è¾“å‡ºå®Œï¼Œi å°±è¦å‡ 1ã€‚ PSï¼šä¸‹é¢è¿™æ®µä»£ç çš„å¾ˆå¤šåœ°æ–¹çš„åˆ¤æ–­æ¡ä»¶å…¶å®žå¯ä»¥æ¢æˆå…¶ä»–çš„ï¼Œæ¯”å¦‚i != n - 1å¯ä»¥æ¢æˆlrev.size() != 0ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122#include &lt;cstdio&gt;#include &lt;stack&gt;using namespace std;const int maxn = 100000 + 5;struct node &#123; int address, data, next;&#125; L[maxn], L1[maxn], L2[maxn];stack&lt;node&gt; lrev;int newlist(int head, node *l) &#123; int p = head, count = 0; while(p != -1) &#123; l[p].address = p, l[p].data = L[p].data, l[p].next = L[p].next; p = L[p].next; count++; &#125; return count;&#125;void printlist(int head1, int head2, int n1, int n2, node *l1, node *l2) &#123; int p = head1, n = n1 + n2, count = 0; while(p != -1) &#123; lrev.push(l1[p]); p = l1[p].next; &#125; p = head2; node tmp; for(int i = 0; i &lt; n; i++) &#123; if(count == 0) &#123; if(l2[p].next != -1) printf("%05d %d %05d\n", l2[p].address, l2[p].data, l2[p].next); else printf("%05d %d -1\n", l2[p].address, l2[p].data); p = l2[p].next; count++; &#125; else if(count == 1) &#123; if(i == n - 1) printf("%05d %d -1\n", l2[p].address, l2[p].data); else &#123; if(!lrev.empty()) &#123; tmp = lrev.top(); printf("%05d %d %05d\n", l2[p].address, l2[p].data, tmp.address); &#125; else &#123; printf("%05d %d %05d\n", l2[p].address, l2[p].data, l2[p].next); &#125; &#125; p = l2[p].next; count++; &#125; else if(count == 2) &#123; if(!lrev.empty()) &#123; tmp = lrev.top(); lrev.pop(); if(i != n - 1) printf("%05d %d %05d\n", tmp.address, tmp.data, l2[p].address); else printf("%05d %d -1\n", tmp.address, tmp.data); &#125; else i--; count = 0; &#125; &#125;&#125;int main() &#123; int p, head1, head2, n, n1, n2; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;p); scanf("%d %d", &amp;L[p].data, &amp;L[p].next); L[p].address = p; &#125; n1 = newlist(head1, L1); n2 = newlist(head2, L2); if(n1 &lt; n2) printlist(head1, head2, n1, n2, L1, L2); else printlist(head2, head1, n2, n1, L2, L1); return 0;&#125;/*in:00100 01000 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1out:01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1in:01000 00100 702233 2 3489100100 6 0000134891 3 1008601000 1 0223300033 5 -110086 4 0003300001 7 -1out:01000 1 0223302233 2 0000100001 7 3489134891 3 1008610086 4 0010000100 6 0003300033 5 -1in:00100 01000 602233 2 3489100100 6 -134891 3 1008601000 1 0223300033 5 -110086 4 00033out:01000 1 0223302233 2 0010000100 6 3489134891 3 1008610086 4 0003300033 5 -1*/ 1106 2019æ•°åˆ—Analysisè¿™ä¸ªé¢˜æœ‰ç‚¹åƒæ–æ³¢é‚£å¥‘æ•°åˆ—ï¼Œä¸è¿‡æ¯”è¾ƒç®€å•ã€‚å¦å¤–ï¼Œå†™ä»£ç çš„æ—¶å€™æ²¡çœ‹åˆ°â€œé¢˜å¤–è¯â€ï¼ˆç¥žç»å¤ªå¤§æ¡äº†ï¼‰ï¼Œæ€»ç»“çš„æ—¶å€™çœ‹åˆ°äº†ï¼Œå‹¾èµ·äº†å¥½å¥‡å¿ƒï¼Œè¯•ç€ç”¨åè¯æ³•å°è¯•äº†ä¸€ä¸‹ï¼Œæœªå¾—è§£ã€‚ç™¾åº¦äº†ä¸€ä¸‹ï¼Œå‘çŽ°æ˜¯è¿™æ ·çš„è§„å¾‹ï¼šä»¥å‰ 20 é¡¹ä¸ºä¾‹ï¼Œæœ€ç»ˆå¾—åˆ°çš„æ•°åˆ—æ˜¯ï¼š 2 0 1 9 2 2 4 7 5 8 4 4 1 7 6 8 2 3 9 2ä»Žå¥‡å¶æ€§çš„è§’åº¦æ¥çœ‹å°±æ˜¯ï¼š å¶ å¶ å¥‡ å¥‡ å¶ å¶ å¶ å¥‡ å¥‡ å¶ å¶ å¶ å¥‡ å¥‡ å¶ å¶ å¶ å¥‡ å¥‡ å¶å°±å¯ä»¥å‘çŽ°ï¼Œå¥‡å¶æ€§çš„æŽ’åˆ—æ˜¯æŒ‰ç…§â€œå¶å¶å¶å¥‡å¥‡â€çš„é¡ºåºä¸æ–­é‡å¤çš„ï¼Œè€Œå¯¹æ¯” 2018ï¼Œ1 è¿™ä¸ªæ•°å­—çš„ä¸¤ä¾§éƒ½æ˜¯å¶æ•°ï¼Œæ‰€ä»¥å®ƒå°±ä¸å¯èƒ½å‡ºçŽ°åœ¨è¿™ä¸ªæ•°åˆ—ä¸­ï¼Œä½†è¿™å¥½åƒå¹¶ä¸æ˜¯åœ¨è¯æ˜Žï¼Œè€Œæ˜¯åœ¨éªŒè¯ðŸ˜‚ã€‚ Code123456789101112131415#include &lt;cstdio&gt;const int maxn = 1000 + 5;int arr[maxn] = &#123;0, 2, 0, 1, 9&#125;;int main() &#123; int n, tmp; scanf("%d", &amp;n); for(int i = 5; i &lt;= n;i++) &#123; tmp = arr[i - 1] + arr[i - 2] + arr[i - 3] + arr[i - 4]; arr[i] = tmp % 10; &#125; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", arr[i]); &#125; return 0;&#125; 1107 è€é¼ çˆ±å¤§ç±³Analysisè¿™ä¸ªé¢˜æ²¡ä»€ä¹ˆè¯´çš„ï¼Œå¯ä»¥è¯»å…¥æ‰€æœ‰æ•°æ®åŽåœ¨è¾“å‡ºï¼Œä¹Ÿå¯ä»¥è¾¹è¯»å…¥è¾¹è¾“å‡ºï¼Œåªè¦æµ‹è¯•çš„ç»“æžœä¸Žæ ·ä¾‹ä¸€è‡´å°±è¡Œï¼Œå¯ä»¥ä½¿ç”¨ PTA è‡ªå¸¦çš„è‡ªå®šä¹‰æµ‹è¯•åŠŸèƒ½è¿›è¡Œæµ‹è¯•ã€‚ Code123456789101112131415161718#include &lt;cstdio&gt;int main() &#123; int n, m, tmp, max2 = -1; scanf("%d %d", &amp;n, &amp;m); for(int i = 0; i &lt; n; i++) &#123; int max1 = -1; for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;tmp); if(max1 &lt; tmp) max1 = tmp; &#125; printf("%d", max1); if(i != n - 1) printf(" "); if(max1 &gt; max2) max2 = max1; &#125; printf("\n%d", max2); return 0;&#125; 1108 Stringå¤è¯»æœºAnalysisè¿™ä¸ªé¢˜ä¹Ÿæ¯”è¾ƒç›´è§‚ï¼Œæƒ³ç€æ˜¯ä¸æ˜¯èƒ½æŠŠä»£ç å†™çš„ç®€å•ä¸€ç‚¹ï¼Œç»“æžœå‘çŽ°ï¼Œå¥½åƒè¿™æ ·å°±å·²ç»å¾ˆç®€å•ã€ç›´è§‚ã€æ˜“äºŽç†è§£äº†ã€‚ å¥½å§ï¼Œç¡®å®žå¯ä»¥æ”¹çŸ­ä¸€ç‚¹ï¼Œä¸è¿‡ï¼Œversion 1 ç¡®å®žæ˜¯æœ€ç›´è§‚ä¸”æ˜“äºŽç†è§£çš„ã€‚ Codeversion 11234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;char str[10005];int times[6] = &#123;0&#125;;int main() &#123; scanf("%s", str); for(int i = 0; str[i] != '\0'; i++) &#123; if(str[i] == 'S') times[0]++; else if(str[i] == 't') times[1]++; else if(str[i] == 'r') times[2]++; else if(str[i] == 'i') times[3]++; else if(str[i] == 'n') times[4]++; else if(str[i] == 'g') times[5]++; &#125; while(times[0] || times[1] || times[2] || times[3] || times[4] || times[5]) &#123; if(times[0]) &#123; printf("S"); times[0]--; &#125; if(times[1]) &#123; printf("t"); times[1]--; &#125; if(times[2]) &#123; printf("r"); times[2]--; &#125; if(times[3]) &#123; printf("i"); times[3]--; &#125; if(times[4]) &#123; printf("n"); times[4]--; &#125; if(times[5]) &#123; printf("g"); times[5]--; &#125; &#125; return 0;&#125; version 2è¿™ä¸ªé¢˜å…¶å®žä¸Ž 1043 ä¸€æ ·ï¼Œæ‰€ä»¥å¯ä»¥æŒ‰ç…§åŒæ ·çš„æ€è·¯æ”¹å†™ä¸€ä¸‹ï¼Œå¦‚ä¸‹ï¼š1234567891011121314151617181920212223#include &lt;cstdio&gt;char str[10005];int times[128] = &#123;0&#125;;char String[10] = "String";int main() &#123; scanf("%s", str); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['S'] || times['t'] || times['r'] || times['i'] || times['n'] || times['g']) &#123; for(p = String; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1109 æ“…é•¿CAnalysisè¿™ä¸ªé¢˜æœ‰ç‚¹éº»çƒ¦ï¼Œå†™å®Œä¹‹åŽï¼Œæ„Ÿè§‰ç”¨ 3 ç»´æ•°ç»„å¥½åƒæ¯” 2 ç»´æ•°ç»„éº»çƒ¦ã€‚æ•´ä¸ªæ¨¡æ‹Ÿè¿‡ç¨‹ä¸æ˜¯å¾ˆéš¾ï¼Œéš¾çš„æ˜¯ä¿æŒé¢˜ç›®è¦æ±‚çš„æ ¼å¼ï¼Œè¦æ³¨æ„ä»¥ä¸‹å‡ ä¸ªåœ°æ–¹ï¼š é™¤äº†å¤§å†™è‹±æ–‡å­—ç¬¦å¤–ï¼Œå…¶ä»–çš„å­—ç¬¦éƒ½æ˜¯â€œåˆ†éš”ç¬¦â€ã€‚ å¤šä½™å­—ç¬¦å¯èƒ½å‡ºçŽ°åœ¨å¼€å¤´ï¼ˆæµ‹è¯•ç‚¹ 1ï¼‰ã€‚ å¤šä½™å­—ç¬¦å¯èƒ½å‡ºçŽ°åœ¨ç»“å°¾ã€‚ å¤šä½™å­—ç¬¦å¯èƒ½å‡ºçŽ°åœ¨ä¸­é—´ã€‚ å¤šä½™å­—ç¬¦å¯èƒ½ä¼šè¿žç»­å‡ºçŽ°å¤šä¸ªã€‚ PSï¼šè¿™ä¸ªé¢˜çš„è¾“å‡ºå¤ªé•¿äº†ï¼Œè‡ªå·±ç¼–æµ‹è¯•æ ·ä¾‹éƒ½ä¸æ˜¯å¾ˆå¥½ç¼–ï¼Œä¸å¾—ä¸åæ§½ä¸‹ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;cctype&gt;char words[26][7][7], str[10000];int word_index[10000] = &#123;0&#125;;int main() &#123; for(int i = 0; i &lt; 26; i++) &#123; for(int j = 0; j &lt; 7; j++) &#123; scanf("%s", words[i][j]); &#125; &#125; getchar(); fgets(str, 10000, stdin); int count = 0; for(int i = 0; str[i] != '\0'; i++) &#123; if(isupper(str[i])) &#123; word_index[count++] = str[i] - 'A'; &#125; else &#123; word_index[count++] = -1; while(!isupper(str[i]) &amp;&amp; str[i] != '\0') i++; i--; &#125; &#125; int i, j, k; while(word_index[i] == -1) i++; for(; i &lt; count; i++) &#123; for(j = 0; j &lt; 7; j++) &#123; printf("%s", words[word_index[i]][j]); for(k = i + 1; word_index[k] != -1; k++) &#123; printf(" %s", words[word_index[k]][j]); &#125; printf("\n"); &#125; i = k; if(i &lt; count - 1) printf("\n"); &#125; return 0;&#125; 1110 åŒºå—åè½¬Analysisè¿™ä¸ªé¢˜è·ŸB1025æ˜¯ä¸€æ ·çš„é¢˜ï¼Œå”¯ä¸€çš„å·®åˆ«å°±æ˜¯è¾“å‡ºè¦æ±‚ä¸å¤ªç›¸åŒï¼Œå¤§è‡´æ€è·¯åŸºæœ¬ä¸€è‡´ã€‚æ³¨æ„ä»¥ä¸‹å‡ ä¸ªåœ°æ–¹ï¼š å¯èƒ½ä¼šæœ‰æ— æ•ˆç»“ç‚¹ï¼Œè¯»å…¥æ•°æ®åŽï¼Œéœ€è¦å…ˆéåŽ†é“¾è¡¨ï¼ŒæŽ’åºå‰”é™¤æŽ‰æ— æ•ˆç»“ç‚¹ï¼Œå¹¶ä¿å­˜æœ‰æ•ˆç»“ç‚¹çš„ä¸ªæ•°ã€‚ è¾“å‡ºæœ«å°¾ç»“ç‚¹æ•°å°äºŽ k çš„å—æ—¶ï¼Œå¦‚æžœè¦è¾“å‡ºé“¾è¡¨æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œå…¶ next éœ€è¦è¾“å‡ºç¬¬ (i - 1) * k ä¸ªç»“ç‚¹çš„åœ°å€ï¼ˆä¹Ÿå°±æ˜¯ä¸‹ä¸€ä¸ªè¦è¾“å‡ºçš„å—çš„ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ï¼‰ã€‚ è¾“å‡ºç»“ç‚¹æ•°ç­‰äºŽ k ä¸”ä¸æ˜¯æœ€åŽä¸€å—æ—¶ï¼Œå¦‚æžœè¦è¾“å‡ºå½“å‰å—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œå…¶ next éœ€è¦è¾“å‡ºç¬¬ (i - 1) * k ä¸ªç»“ç‚¹çš„åœ°å€ï¼ˆä¹Ÿå°±æ˜¯ä¸‹ä¸€ä¸ªè¦è¾“å‡ºçš„å—çš„ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ï¼‰ã€‚ è¾“å‡ºç»“ç‚¹æ•°ç­‰äºŽ k ä¸”æ˜¯æœ€åŽä¸€å—æ—¶ï¼Œå¦‚æžœè¾“å‡ºçš„æ˜¯æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œå…¶ next éœ€è¦è¾“å‡º -1ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100000 + 5;struct node &#123; int addr, data, next; int order;&#125; L[maxn];void Init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; L[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main() &#123; Init(); int head, n, k, tmp; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tmp); scanf("%d %d", &amp;L[tmp].data, &amp;L[tmp].next); L[tmp].addr = tmp; &#125; int p = head, count = 0; while(p != -1) &#123; L[p].order = count++; p = L[p].next; &#125; sort(L, L + maxn, cmp); n = count; for(int i = n / k; i &gt;= 0; i--) &#123; int j = i * k; if(i == n / k) &#123; for(; j &lt; n; j++) &#123; if(j == n - 1) printf("%05d %d %05d\n", L[j].addr, L[j].data, L[(i - 1) * k].addr); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; else &#123; if(i != 0) &#123; for(; j &lt; (i + 1) * k; j++) &#123; if(j == (i + 1) * k - 1) printf("%05d %d %05d\n", L[j].addr, L[j].data, L[(i - 1) * k].addr); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; else &#123; for(; j &lt; k; j++) &#123; if(j == k - 1) printf("%05d %d -1\n", L[j].addr, L[j].data); else printf("%05d %d %05d\n", L[j].addr, L[j].data, L[j].next); &#125; &#125; &#125; &#125; return 0;&#125; Summaryç®—ä¸Šä»Šå¤©ï¼Œä¸€å…±å¤§æ¦‚èŠ±äº†å¤§çº¦ 80 ä¸ªå°æ—¶çš„æ—¶é—´ï¼ŒæŠŠåŽŸæ¥åšè¿‡çš„å’Œæ²¡åšè¿‡çš„é¢˜éƒ½åšäº†ä¸€éã€‚æ„Ÿè§‰ä¹™çº§çš„é¢˜ç›®è¿˜æ˜¯æ¯”è¾ƒåŸºç¡€çš„ï¼Œæœ‰äº›é¢˜ç›®è®¾ç½®çš„å¡ç‚¹ï¼Œå…¶å®žæ²¡æœ‰å¤ªå¤šçš„å¿…è¦ï¼Ÿä¸è¿‡ï¼Œå°½å¯èƒ½çš„å‡å°‘è‡ªå·±å†™çš„ç¨‹åºçš„ bug ä¹Ÿæ˜¯åº”è¯¥çš„ã€‚ æœ‰æ—¶å€™ä¸€é“é¢˜æœ‰æ€è·¯ï¼Œä½†å´æ²¡æ‹¿åˆ°æ»¡åˆ†æ˜¯ä»¶å¾ˆç—›è‹¦çš„äº‹æƒ…ã€‚ä¸è¿‡ï¼Œæ„Ÿè§‰èŠ±æ—¶é—´ debug å¸¦æ¥çš„æå‡ï¼Œå¯èƒ½ä¼šæ¯”èŠ±æ—¶é—´å­¦ä¹ åˆ«äººçš„æ€è·¯å¸¦æ¥çš„æå‡æ›´å¤§ã€‚å½“ç„¶ï¼Œæˆå°±æ„Ÿä¹Ÿä¼šæ›´å¤§ï¼Œè¿™å°±å¥½æ¯”çŽ©æ¸¸æˆåˆ·å‰¯æœ¬è¢«äººå¸¦å’Œè‡ªå·±å•åˆ·çš„æ„Ÿè§‰å§ã€‚ æŽ¥ä¸‹æ¥è¯¥åšçš„äº‹æƒ…ï¼Œå°±æ˜¯å†å›žè¿‡å¤´çœ‹çœ‹è¿™äº›é¢˜ç›®è•´å«çš„æ€æƒ³äº†ã€‚è¿˜æœ‰å°±æ˜¯ï¼Œæœ‰æ²¡æœ‰ä»€ä¹ˆæ›´å¿«æ·ã€æ–¹ä¾¿ã€ç®€å•ä¸”æ˜“äºŽç†è§£çš„å…¶ä»–è§£æ³•äº†ã€‚ æ€»ä¹‹ï¼Œè¦åšä¸”èƒ½åšäº‹æƒ…è¿˜æœ‰å¾ˆå¤š...]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†]]></title>
    <url>%2F2019%2F02%2F20%2FPTA%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Introæ­¤Blogç”¨æ¥è®°å½•è‡ªå·±çš„â€PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†ä¹‹æ—…(å—è™)â€ã€‚æ¯é“é¢˜ç›®åŒ…å«è¾“å…¥(è¾“å‡º)æ ·ä¾‹ã€è¾“å…¥(è¾“å‡º)è¯´æ˜Žã€æ€è·¯åˆ†æžåŠå¾—åˆ°ACçš„æºç ã€‚æ‰€æœ‰ACä»£ç å·²ä¸Šä¼ åˆ°GitHubä¸Šï¼Œç‚¹å‡»PTA-Basical-Programming-problem-setå³å¯èŽ·å–ã€‚ Programming7-1 åŽ˜ç±³æ¢ç®—è‹±å°ºè‹±å¯¸å¦‚æžœå·²çŸ¥è‹±åˆ¶é•¿åº¦çš„è‹±å°º$foot$å’Œè‹±å¯¸$inch$çš„å€¼ï¼Œé‚£ä¹ˆå¯¹åº”çš„ç±³æ˜¯$(foot+inch/12)Ã—0.3048$ã€‚çŽ°åœ¨ï¼Œå¦‚æžœç”¨æˆ·è¾“å…¥çš„æ˜¯åŽ˜ç±³æ•°ï¼Œé‚£ä¹ˆå¯¹åº”è‹±åˆ¶é•¿åº¦çš„è‹±å°ºå’Œè‹±å¯¸æ˜¯å¤šå°‘å‘¢ï¼Ÿåˆ«å¿˜äº†1è‹±å°ºç­‰äºŽ12è‹±å¯¸ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º1ä¸ªæ­£æ•´æ•°ï¼Œå•ä½æ˜¯åŽ˜ç±³ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªåŽ˜ç±³æ•°å¯¹åº”è‹±åˆ¶é•¿åº¦çš„è‹±å°ºå’Œè‹±å¯¸çš„æ•´æ•°å€¼ï¼Œä¸­é—´ç”¨ç©ºæ ¼åˆ†å¼€ã€‚ Sample Input &amp; Sample Output Input 1:170 Output 1:5 6 Analysisè¿™é“é¢˜ç›®ä¹ä¸€çœ‹æŒºç®€å•çš„ï¼Œå…¶å®žä¹Ÿæœ‰ç‚¹ç»•(é¢˜ç›®æœ‰ç‚¹è¿·ðŸ˜’)ã€‚é¦–å…ˆï¼Œè¦æ˜Žç¡®é¢˜ç›®éœ€è¦æˆ‘ä»¬å¾—åˆ°çš„ç»“æžœæ˜¯ï¼šç»™å‡ºçš„åŽ˜ç±³å¯¹åº”æ¢ç®—ä¸ºè‹±å°ºã€è‹±å¯¸çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨è¿™æ ·ä¸€ä¸ªå…³ç³»ï¼š$170CMâ‰ˆ5foot6inch$(é¢˜ç›®åªè¦æ±‚æ•´æ•°)ï¼Œå°±å¥½æ¯”æ˜¯$103=20Ã—5+3$ï¼Œè€Œæˆ‘ä»¬è¦çš„å€¼å°±æ˜¯è¿™ä¸ª5å’Œ3ã€‚æ˜Žç™½è¿™ä¸ªä¹‹åŽï¼Œå°±ä¼šå‘çŽ°ï¼Œå•çº¯çš„å°†$1foot=12inch$è¿™ä¸ªæ¡æŒ‰é¢˜ç›®ç»™çš„æ–¹ç¨‹å¸¦å…¥è®¡ç®—æ˜¯å¾—ä¸å‡ºç»“æžœçš„ï¼Œé‚£ä¹ˆå¯ä»¥å…ˆæ±‚å¤§çš„å•ä½($foot$)çš„å€¼ï¼Œé‚£ä¹ˆå°å•ä½($inch$)çš„å€¼å°±æ˜¯å‰©ä¸‹çš„å·®äº†ã€‚æŽ¥ä¸‹æ¥ï¼Œè¿˜å¾—æ‰¾$foot$å’Œ$CM$çš„æ•°å€¼å…³ç³»(è¿™é‡Œä¹Ÿå¯ä»¥ç›´æŽ¥ç™¾åº¦)ï¼Œä¾æ®$(foot+inch/12)Ã—0.3048$ï¼Œè¿™ä¸ªå¼å­è®¡ç®—ç»“æžœçš„å•ä½æ˜¯$M$ï¼Œè€Œå·¦è¾¹$(foot+inch/12)$çš„å•ä½æ˜¯$foot$ï¼Œæ‰€ä»¥å°±å¯ä»¥çŸ¥é“ï¼š$1foot=30.48CM$ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æŽ¥ç®—å‡ºæ­£ç¡®çš„$foot$å€¼äº†ã€‚ Code1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int foot,inch,centimeters; scanf("%d", &amp;centimeters); // centimeters = 170; foot = centimeters / 30.48; inch = centimeters / 2.54 - 12*foot; printf("%d %d\n", foot, inch); return 0;&#125; 7-2 ç„¶åŽæ˜¯å‡ ç‚¹æœ‰æ—¶å€™äººä»¬ç”¨å››ä½æ•°å­—è¡¨ç¤ºä¸€ä¸ªæ—¶é—´ï¼Œæ¯”å¦‚1106è¡¨ç¤º11ç‚¹é›¶6åˆ†ã€‚çŽ°åœ¨ï¼Œä½ çš„ç¨‹åºè¦æ ¹æ®èµ·å§‹æ—¶é—´å’Œæµé€çš„æ—¶é—´è®¡ç®—å‡ºç»ˆæ­¢æ—¶é—´ã€‚è¯»å…¥ä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªæ•°å­—ä»¥è¿™æ ·çš„å››ä½æ•°å­—è¡¨ç¤ºå½“å‰æ—¶é—´ï¼Œç¬¬äºŒä¸ªæ•°å­—è¡¨ç¤ºåˆ†é’Ÿæ•°ï¼Œè®¡ç®—å½“å‰æ—¶é—´ç»è¿‡é‚£ä¹ˆå¤šåˆ†é’ŸåŽæ˜¯å‡ ç‚¹ï¼Œç»“æžœä¹Ÿè¡¨ç¤ºä¸ºå››ä½æ•°å­—ã€‚å½“å°æ—¶ä¸ºä¸ªä½æ•°æ—¶ï¼Œæ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå³5ç‚¹30åˆ†è¡¨ç¤ºä¸º530ã€‚æ³¨æ„ï¼Œç¬¬äºŒä¸ªæ•°å­—è¡¨ç¤ºçš„åˆ†é’Ÿæ•°å¯èƒ½è¶…è¿‡60ï¼Œä¹Ÿå¯èƒ½æ˜¯è´Ÿæ•°ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«æ˜¯å››ä½æ•°å­—è¡¨ç¤ºçš„èµ·å§‹æ—¶é—´ã€ä»¥åŠæµé€çš„åˆ†é’Ÿæ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æ³¨æ„ï¼šåœ¨èµ·å§‹æ—¶é—´ä¸­ï¼Œå½“å°æ—¶ä¸ºä¸ªä½æ•°æ—¶ï¼Œæ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå³5ç‚¹30åˆ†è¡¨ç¤ºä¸º530ï¼›æµé€çš„åˆ†é’Ÿæ•°å¯èƒ½è¶…è¿‡60ï¼Œä¹Ÿå¯èƒ½æ˜¯è´Ÿæ•°ã€‚ Output Specificationè¾“å‡ºå››ä½æ•°å­—è¡¨ç¤ºçš„ç»ˆæ­¢æ—¶é—´ã€‚é¢˜ç›®ä¿è¯èµ·å§‹æ—¶é—´å’Œç»ˆæ­¢æ—¶é—´åœ¨åŒä¸€å¤©å†…ã€‚ Sample Input &amp; Sample Output Input 1:1120 110 Output 1:1310 Analysisç®€å•é¢˜ï¼Œæ±‚å‡ºæ€»çš„åˆ†é’Ÿå€¼ï¼Œç„¶åŽæ±‚å‡ºå°æ—¶çš„å€¼ï¼Œåœ¨æŒ‰ç…§é¢˜ç›®è¦æ±‚è¾“å‡ºå³å¯ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int start_time,waste_time; scanf("%d %d", &amp;start_time, &amp;waste_time); // start_time = 1120; waste_time = 110; int hours,minutes; minutes = start_time/100*60 + start_time%100 + waste_time; hours = minutes/60; minutes -= hours*60; printf("%d\n", hours*100+minutes); return 0;&#125; 7-3 é€†åºçš„ä¸‰ä½æ•°ç¨‹åºæ¯æ¬¡è¯»å…¥ä¸€ä¸ªæ­£3ä½æ•°ï¼Œç„¶åŽè¾“å‡ºæŒ‰ä½é€†åºçš„æ•°å­—ã€‚æ³¨æ„ï¼šå½“è¾“å…¥çš„æ•°å­—å«æœ‰ç»“å°¾çš„0æ—¶ï¼Œè¾“å‡ºä¸åº”å¸¦æœ‰å‰å¯¼çš„0ã€‚æ¯”å¦‚è¾“å…¥700ï¼Œè¾“å‡ºåº”è¯¥æ˜¯7ã€‚ Input Specificationæ¯ä¸ªæµ‹è¯•æ˜¯ä¸€ä¸ª3ä½çš„æ­£æ•´æ•°ã€‚ Output Specificationè¾“å‡ºæŒ‰ä½é€†åºçš„æ•°ã€‚ Sample Input &amp; Sample Output Input 1:123 Output 1:321 Analysisè¿™é“é¢˜ç›®å¾ˆç®€å•ï¼Œè€ƒå¯Ÿæ•°ä½æ‹†åˆ†ï¼Œåœ¨é¢˜ç›®å‘Šè¯‰å·²çŸ¥3ä½æ•°çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ç›´æŽ¥è¿›è¡Œæ•°ä½æ‹†åˆ†(ä¸€èˆ¬é¢˜ç›®éƒ½ä¸ä¼šç»™è¾“å…¥æ•°å­—çš„ä½æ•°ï¼Œè€Œåªç»™èŒƒå›´)ï¼›å¹¶ä¸”é¢˜ç›®ä¹Ÿå·²ç»ç»™å‡ºäº†è¦æ³¨æ„çš„åœ°æ–¹ï¼š700é€†åºåŽä¸èƒ½æ˜¯007ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; scanf("%d", &amp;n); // n=700; int units,tens,hundred; units=n%10; tens=n/10%10; hundred=n/100; printf("%d\n", units*100+tens*10+hundred); return 0;&#125; 7-4 BCDè§£å¯†BCDæ•°æ˜¯ç”¨ä¸€ä¸ªå­—èŠ‚æ¥è¡¨è¾¾ä¸¤ä½åè¿›åˆ¶çš„æ•°ï¼Œæ¯å››ä¸ªæ¯”ç‰¹è¡¨ç¤ºä¸€ä½ã€‚æ‰€ä»¥å¦‚æžœä¸€ä¸ªBCDæ•°çš„åå…­è¿›åˆ¶æ˜¯0x12ï¼Œå®ƒè¡¨è¾¾çš„å°±æ˜¯åè¿›åˆ¶çš„12ã€‚ä½†æ˜¯å°æ˜Žæ²¡å­¦è¿‡BCDï¼ŒæŠŠæ‰€æœ‰çš„BCDæ•°éƒ½å½“ä½œäºŒè¿›åˆ¶æ•°è½¬æ¢æˆåè¿›åˆ¶è¾“å‡ºäº†ã€‚äºŽæ˜¯BCDçš„0x12è¢«è¾“å‡ºæˆäº†åè¿›åˆ¶çš„18äº†ï¼çŽ°åœ¨ï¼Œä½ çš„ç¨‹åºè¦è¯»å…¥è¿™ä¸ªé”™è¯¯çš„åè¿›åˆ¶æ•°ï¼Œç„¶åŽè¾“å‡ºæ­£ç¡®çš„åè¿›åˆ¶æ•°ã€‚æç¤ºï¼šä½ å¯ä»¥æŠŠ18è½¬æ¢å›ž0x12ï¼Œç„¶åŽå†è½¬æ¢å›ž12ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ª$[0, 153]$èŒƒå›´å†…çš„æ­£æ•´æ•°ï¼Œä¿è¯èƒ½è½¬æ¢å›žæœ‰æ•ˆçš„BCDæ•°ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ•´æ•°è½¬æ¢æˆåå…­è¿›åˆ¶æ—¶ä¸ä¼šå‡ºçŽ°A-Fçš„æ•°å­—ã€‚ Output Specificationè¾“å‡ºå¯¹åº”çš„åè¿›åˆ¶æ•°ã€‚ Sample Input &amp; Sample Output Input 1:18 Output 1:12 Analysisç®€å•é¢˜ï¼Œé¢˜ç›®ç»™çš„æç¤ºå¾ˆæ˜Žæ˜¾ï¼Œå•ç‹¬å‡ºåŽ»åè¿›åˆ¶æ•°çš„ä¸ªä½å’Œåä½åŽï¼Œç›´æŽ¥ç»„åˆè®¡ç®—å³å¯å¾—åˆ°ã€‚ Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int BCD; scanf("%d", &amp;BCD); // BCD=18; int units,tens; units=BCD%16; tens=BCD/16; printf("%d\n", tens*10+units); return 0;&#125; 7-5 è¡¨æ ¼è¾“å‡ºæœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼ŒæŒ‰ç…§è§„å®šæ ¼å¼è¾“å‡ºè¡¨æ ¼ã€‚ Input Specificationæœ¬é¢˜ç›®æ²¡æœ‰è¾“å…¥ã€‚ Output Specificationè¦æ±‚ä¸¥æ ¼æŒ‰ç…§ç»™å‡ºçš„æ ¼å¼è¾“å‡ºä¸‹åˆ—è¡¨æ ¼ï¼š123456789------------------------------------Province Area(km2) Pop.(10K)------------------------------------Anhui 139600.00 6461.00Beijing 16410.54 1180.70Chongqing 82400.00 3144.23Shanghai 6340.50 1360.26Zhejiang 101800.00 4894.00------------------------------------ Analysisé€åˆ†é¢˜ï¼Œç›´æŽ¥åŽŸæ ·è¾“å‡ºå³å¯ã€‚ Code1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf("------------------------------------\n"); printf("Province Area(km2) Pop.(10K)\n"); printf("------------------------------------\n"); printf("Anhui 139600.00 6461.00\n"); printf("Beijing 16410.54 1180.70\n"); printf("Chongqing 82400.00 3144.23\n"); printf("Shanghai 6340.50 1360.26\n"); printf("Zhejiang 101800.00 4894.00\n"); printf("------------------------------------\n"); return 0;&#125; 7-6 æ··åˆç±»åž‹æ•°æ®æ ¼å¼åŒ–è¾“å…¥æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œé¡ºåºè¯»å…¥æµ®ç‚¹æ•°1ã€æ•´æ•°ã€å­—ç¬¦ã€æµ®ç‚¹æ•°2ï¼Œå†æŒ‰ç…§å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°1ã€æµ®ç‚¹æ•°2çš„é¡ºåºè¾“å‡ºã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­é¡ºåºç»™å‡ºæµ®ç‚¹æ•°1ã€æ•´æ•°ã€å­—ç¬¦ã€æµ®ç‚¹æ•°2ï¼Œå…¶é—´ä»¥1ä¸ªç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°1ã€æµ®ç‚¹æ•°2çš„é¡ºåºè¾“å‡ºï¼Œå…¶ä¸­æµ®ç‚¹æ•°ä¿ç•™å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input:2.12 88 c 4.7 Output:c 88 2.12 4.70 AnalysisæŒ‰é¢˜ç›®è¦æ±‚è¾“å…¥è¾“å‡ºå³å¯ã€‚ Code12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float a1,a2; int b; char c; scanf("%f %d %c %f", &amp;a1, &amp;b, &amp;c, &amp;a2); printf("%c %d %.2f %.2f\n", c, b, a1, a2); return 0;&#125; 7-7 12-24å°æ—¶åˆ¶ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥24å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œç„¶åŽæ˜¾ç¤º12å°æ—¶åˆ¶çš„æ—¶é—´ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå¸¦æœ‰ä¸­é—´çš„:ç¬¦å·ï¼ˆåŠè§’çš„å†’å·ï¼‰çš„24å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œå¦‚12:34è¡¨ç¤º12ç‚¹34åˆ†ã€‚å½“å°æ—¶æˆ–åˆ†é’Ÿæ•°å°äºŽ10æ—¶ï¼Œå‡æ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå¦‚5:6è¡¨ç¤º5ç‚¹é›¶6åˆ†ã€‚æç¤ºï¼šåœ¨scanfçš„æ ¼å¼å­—ç¬¦ä¸²ä¸­åŠ å…¥:ï¼Œè®©scanfæ¥å¤„ç†è¿™ä¸ªå†’å·ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªæ—¶é—´å¯¹åº”çš„12å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œæ•°å­—éƒ¨åˆ†æ ¼å¼ä¸Žè¾“å…¥çš„ç›¸åŒï¼Œç„¶åŽè·Ÿä¸Šç©ºæ ¼ï¼Œå†è·Ÿä¸Šè¡¨ç¤ºä¸Šåˆçš„å­—ç¬¦ä¸²AMæˆ–è¡¨ç¤ºä¸‹åˆçš„å­—ç¬¦ä¸²PMã€‚å¦‚5:6 PMè¡¨ç¤ºä¸‹åˆ5ç‚¹é›¶6åˆ†ã€‚æ³¨æ„ï¼Œåœ¨è‹±æ–‡çš„ä¹ æƒ¯ä¸­ï¼Œä¸­åˆ12ç‚¹è¢«è®¤ä¸ºæ˜¯ä¸‹åˆï¼Œæ‰€ä»¥24å°æ—¶åˆ¶çš„12:00å°±æ˜¯12å°æ—¶åˆ¶çš„12:0 PMï¼›è€Œ0ç‚¹è¢«è®¤ä¸ºæ˜¯ç¬¬äºŒå¤©çš„æ—¶é—´ï¼Œæ‰€ä»¥æ˜¯0:0 AMã€‚ Sample Input &amp; Sample Output Input:21:11 Output:9:11 PM Analysisæ ¹æ®è¾“å‡ºæ ¼å¼è¿›è¡Œè¾“å‡ºå³å¯ï¼Œæ³¨æ„ä¸­åˆ12ç‚¹è¢«è®¤ä¸ºæ˜¯PMï¼›è¾“å…¥åªéœ€æ³¨æ„:å³å¯ã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int hours,minutes; scanf("%d:%d", &amp;hours, &amp;minutes); // hours = 21, minutes = 11; if(hours == 12)&#123; printf("%d:%d PM\n", hours, minutes); &#125;else if(hours &lt; 12)&#123; printf("%d:%d AM\n", hours, minutes); &#125;else&#123; printf("%d:%d PM\n", hours-12, minutes); &#125; return 0;&#125; 7-8 è¶…é€Ÿåˆ¤æ–­æ¨¡æ‹Ÿäº¤é€šè­¦å¯Ÿçš„é›·è¾¾æµ‹é€Ÿä»ªã€‚è¾“å…¥æ±½è½¦é€Ÿåº¦ï¼Œå¦‚æžœé€Ÿåº¦è¶…å‡º60 mphï¼Œåˆ™æ˜¾ç¤ºSpeedingï¼Œå¦åˆ™æ˜¾ç¤ºOKã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º1ä¸ªä¸è¶…è¿‡500çš„éžè´Ÿæ•´æ•°ï¼Œå³é›·è¾¾æµ‹åˆ°çš„è½¦é€Ÿã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæµ‹é€Ÿä»ªæ˜¾ç¤ºç»“æžœï¼Œæ ¼å¼ä¸ºï¼šSpeed: V - Sï¼Œå…¶ä¸­Væ˜¯è½¦é€Ÿï¼ŒSæ˜¯Speedingã€æˆ–è€…æ˜¯OKã€‚ Sample Input &amp; Sample Output Input 1:40 Output 1:Speed: 40 - OK Input 2:75 Output 2:Speed: 75 - Speeding Analysisæ ¹æ®é¢˜ç›®è¦æ±‚ç›´æŽ¥è¾“å‡ºå³å¯ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int speed; scanf("%d", &amp;speed); // speed=75; if(speed &gt; 60)&#123; printf("Speed: %d - Speeding\n", speed); &#125;else&#123; printf("Speed: %d - OK\n", speed); &#125; return 0;&#125; 7-9 ç”¨å¤©å¹³æ‰¾å°çƒä¸‰ä¸ªçƒAã€Bã€Cï¼Œå¤§å°å½¢çŠ¶ç›¸åŒä¸”å…¶ä¸­æœ‰ä¸€ä¸ªçƒä¸Žå…¶ä»–çƒé‡é‡ä¸åŒã€‚è¦æ±‚æ‰¾å‡ºè¿™ä¸ªä¸ä¸€æ ·çš„çƒã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º3ä¸ªæ­£æ•´æ•°ï¼Œé¡ºåºå¯¹åº”çƒAã€Bã€Cçš„é‡é‡ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå”¯ä¸€çš„é‚£ä¸ªä¸ä¸€æ ·çš„çƒã€‚ Sample Input &amp; Sample Output Input:1 1 2 Output:C Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œå¦‚æžœè¦è¾“å‡ºå”¯ä¸€çš„é‚£ä¸ªä¸ä¸€æ ·çš„çƒï¼Œå…¶å®žå°±åªæœ‰ä¸‰ç§æƒ…å†µï¼Œç›´æŽ¥è¾“å‡ºå°±å¥½ã€‚ Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,C; scanf("%d %d %d", &amp;A, &amp;B, &amp;C); // A=1, B=1, C=2; if(A != B &amp;&amp; A != C) printf("A\n"); if(B != A &amp;&amp; B != C) printf("B\n"); if(C != A &amp;&amp; C != B) printf("C\n"); return 0;&#125; 7-10 è®¡ç®—å·¥èµ„æŸå…¬å¸å‘˜å·¥çš„å·¥èµ„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼šä¸€å‘¨å†…å·¥ä½œæ—¶é—´ä¸è¶…è¿‡40å°æ—¶ï¼ŒæŒ‰æ­£å¸¸å·¥ä½œæ—¶é—´è®¡é…¬ï¼›è¶…å‡º40å°æ—¶çš„å·¥ä½œæ—¶é—´éƒ¨åˆ†ï¼ŒæŒ‰æ­£å¸¸å·¥ä½œæ—¶é—´æŠ¥é…¬çš„1.5å€è®¡é…¬ã€‚å‘˜å·¥æŒ‰è¿›å…¬å¸æ—¶é—´åˆ†ä¸ºæ–°èŒå·¥å’Œè€èŒå·¥ï¼Œè¿›å…¬å¸ä¸å°‘äºŽ5å¹´çš„å‘˜å·¥ä¸ºè€èŒå·¥ï¼Œ5å¹´ä»¥ä¸‹çš„ä¸ºæ–°èŒå·¥ã€‚æ–°èŒå·¥çš„æ­£å¸¸å·¥èµ„ä¸º30å…ƒ/å°æ—¶ï¼Œè€èŒå·¥çš„æ­£å¸¸å·¥èµ„ä¸º50å…ƒ/å°æ—¶ã€‚è¯·æŒ‰è¯¥è®¡é…¬æ–¹å¼è®¡ç®—å‘˜å·¥çš„å·¥èµ„ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«ä¸ºæŸå‘˜å·¥å…¥èŒå¹´æ•°å’Œå‘¨å·¥ä½œæ—¶é—´ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œè¾“å‡ºè¯¥å‘˜å·¥çš„å‘¨è–ªï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input 1:5 40 Output 1:2000.00 Input 2:3 50 Output 2:1650.00 Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œé’ˆå¯¹ä¸åŒæƒ…å†µè®¡ç®—å·¥èµ„å³å¯ï¼Œå®žè´¨ä¸ºåˆ†æ®µå‡½æ•°æ±‚å€¼ã€‚ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int years,hours; float wage; scanf("%d %d", &amp;years, &amp;hours); // years=3, hours=50; if(years &gt;= 5)&#123; if(hours &gt; 40)&#123; wage = 50*40 + 1.5*50*(hours - 40); &#125;else&#123; wage = 50*hours; &#125; &#125;else&#123; if(hours &gt; 40)&#123; wage = 30*40 + 1.5*30*(hours - 40); &#125;else&#123; wage = 30*hours; &#125; &#125; printf("%.2f\n", wage); return 0;&#125; 7-11 åˆ†æ®µè®¡ç®—å±…æ°‘æ°´è´¹ä¸ºé¼“åŠ±å±…æ°‘èŠ‚çº¦ç”¨æ°´ï¼Œè‡ªæ¥æ°´å…¬å¸é‡‡å–æŒ‰ç”¨æ°´é‡é˜¶æ¢¯å¼è®¡ä»·çš„åŠžæ³•ï¼Œå±…æ°‘åº”äº¤æ°´è´¹$y$ï¼ˆå…ƒï¼‰ä¸Žæœˆç”¨æ°´é‡$x$ï¼ˆå¨ï¼‰ç›¸å…³ï¼šå½“$x$ä¸è¶…è¿‡15å¨æ—¶ï¼Œ$y=4x/3$ï¼›è¶…è¿‡åŽï¼Œ$y=2.5xâˆ’17.5$ã€‚è¯·ç¼–å†™ç¨‹åºå®žçŽ°æ°´è´¹çš„è®¡ç®—ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºéžè´Ÿå®žæ•°$x$ã€‚ Output Specificationåœ¨ä¸€è¡Œè¾“å‡ºåº”äº¤çš„æ°´è´¹ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input 1:12 Output 1:16.00 Input 2:16 Output 2:22.50 Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œé’ˆå¯¹ä¸åŒæƒ…å†µè®¡ç®—æ°´è´¹å³å¯ï¼Œå®žè´¨ä¸ºåˆ†æ®µå‡½æ•°æ±‚å€¼ã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int x; scanf("%d", &amp;x); // x=16; float water_fee; if(x &lt;= 15)&#123; water_fee = 4.0*x/3; &#125;else&#123; water_fee = 2.5*x - 17.5; &#125; printf("%.2f\n", water_fee); return 0;&#125; 7-12 ä¸¤ä¸ªæ•°çš„ç®€å•è®¡ç®—å™¨æœ¬é¢˜è¦æ±‚ç¼–å†™ä¸€ä¸ªç®€å•è®¡ç®—å™¨ç¨‹åºï¼Œå¯æ ¹æ®è¾“å…¥çš„è¿ç®—ç¬¦ï¼Œå¯¹2ä¸ªæ•´æ•°è¿›è¡ŒåŠ ã€å‡ã€ä¹˜ã€é™¤æˆ–æ±‚ä½™è¿ç®—ã€‚é¢˜ç›®ä¿è¯è¾“å…¥å’Œè¾“å‡ºå‡ä¸è¶…è¿‡æ•´åž‹èŒƒå›´ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡è¾“å…¥æ“ä½œæ•°1ã€è¿ç®—ç¬¦ã€æ“ä½œæ•°2ï¼Œå…¶é—´ä»¥1ä¸ªç©ºæ ¼åˆ†éš”ã€‚æ“ä½œæ•°çš„æ•°æ®ç±»åž‹ä¸ºæ•´åž‹ï¼Œä¸”ä¿è¯é™¤æ³•å’Œæ±‚ä½™çš„åˆ†æ¯éžé›¶ã€‚ Output Specificationå½“è¿ç®—ç¬¦ä¸º+ã€-ã€*ã€/ã€%æ—¶ï¼Œåœ¨ä¸€è¡Œè¾“å‡ºç›¸åº”çš„è¿ç®—ç»“æžœã€‚è‹¥è¾“å…¥æ˜¯éžæ³•ç¬¦å·ï¼ˆå³é™¤äº†åŠ ã€å‡ã€ä¹˜ã€é™¤å’Œæ±‚ä½™äº”ç§è¿ç®—ç¬¦ä»¥å¤–çš„å…¶ä»–ç¬¦å·ï¼‰åˆ™è¾“å‡ºERRORã€‚ Sample Input &amp; Sample output Input 1:-7 / 2 Output 1:-3 Input 2:3 &amp; 6 Output 2:ERROR Analysisé’ˆå¯¹ä¸åŒçš„æƒ…å†µä½¿ç”¨switchè¯­å¥åˆ†åˆ«å¤„ç†å³å¯ã€‚ Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int a, b; char c; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); switch(c)&#123; case '+': printf("%d\n", a + b);break; case '-': printf("%d\n", a - b);break; case '*': printf("%d\n", a * b);break; case '/': printf("%d\n", a / b);break; case '%': printf("%d\n", a % b);break; default : printf("ERROR\n"); &#125; return 0;&#125; 7-13 æ—¥Kèœ¡çƒ›å›¾è‚¡ç¥¨ä»·æ ¼æ¶¨è·Œè¶‹åŠ¿ï¼Œå¸¸ç”¨èœ¡çƒ›å›¾æŠ€æœ¯ä¸­çš„Kçº¿å›¾æ¥è¡¨ç¤ºï¼Œåˆ†ä¸ºæŒ‰æ—¥çš„æ—¥Kçº¿ã€æŒ‰å‘¨çš„å‘¨Kçº¿ã€æŒ‰æœˆçš„æœˆKçº¿ç­‰ã€‚ä»¥æ—¥Kçº¿ä¸ºä¾‹ï¼Œæ¯å¤©è‚¡ç¥¨ä»·æ ¼ä»Žå¼€ç›˜åˆ°æ”¶ç›˜èµ°å®Œä¸€å¤©ï¼Œå¯¹åº”ä¸€æ ¹èœ¡çƒ›å°å›¾ï¼Œè¦è¡¨ç¤ºå››ä¸ªä»·æ ¼ï¼šå¼€ç›˜ä»·æ ¼Openï¼ˆæ—©ä¸Šåˆšåˆšå¼€å§‹å¼€ç›˜ä¹°å–æˆäº¤çš„ç¬¬1ç¬”ä»·æ ¼ï¼‰ã€æ”¶ç›˜ä»·æ ¼Closeï¼ˆä¸‹åˆæ”¶ç›˜æ—¶æœ€åŽä¸€ç¬”æˆäº¤çš„ä»·æ ¼ï¼‰ã€ä¸­é—´çš„æœ€é«˜ä»·Highå’Œæœ€ä½Žä»·Lowã€‚ å¦‚æžœClose&lt;Openï¼Œè¡¨ç¤ºä¸ºBW-Solidï¼ˆå³â€œå®žå¿ƒè“ç™½èœ¡çƒ›â€ï¼‰ï¼›å¦‚æžœClose&gt;Openï¼Œè¡¨ç¤ºä¸ºR-Hollowï¼ˆå³â€œç©ºå¿ƒçº¢èœ¡çƒ›â€ï¼‰ï¼›å¦‚æžœOpenç­‰äºŽCloseï¼Œåˆ™ä¸ºR-Crossï¼ˆå³â€œåå­—çº¢èœ¡çƒ›â€ï¼‰ã€‚å¦‚æžœLowæ¯”Openå’ŒCloseä½Žï¼Œç§°ä¸ºLower Shadowï¼ˆå³â€œæœ‰ä¸‹å½±çº¿â€ï¼‰ï¼Œå¦‚æžœHighæ¯”Openå’ŒCloseé«˜ï¼Œç§°ä¸ºUpper Shadowï¼ˆå³â€œæœ‰ä¸Šå½±çº¿â€ï¼‰ã€‚è¯·ç¼–ç¨‹åºï¼Œæ ¹æ®ç»™å®šçš„å››ä¸ªä»·æ ¼ç»„åˆï¼Œåˆ¤æ–­å½“æ—¥çš„èœ¡çƒ›æ˜¯ä¸€æ ¹ä»€ä¹ˆæ ·çš„èœ¡çƒ›ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º4ä¸ªæ­£å®žæ•°ï¼Œåˆ†åˆ«å¯¹åº”Openã€Highã€Lowã€Closeï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ—¥Kèœ¡çƒ›çš„ç±»åž‹ã€‚å¦‚æžœæœ‰ä¸Šã€ä¸‹å½±çº¿ï¼Œåˆ™åœ¨ç±»åž‹åŽåŠ ä¸Šwith å½±çº¿ç±»åž‹ã€‚å¦‚æžœä¸¤ç§å½±çº¿éƒ½æœ‰ï¼Œåˆ™è¾“å‡ºwith Lower Shadow and Upper Shadowã€‚ Sample Input &amp; Sample output Input 1:5.110 5.250 5.100 5.105 Output 1:BW-Solid with Lower Shadow and Upper Shadow Input 2:5.110 5.110 5.110 5.110 Output 2:R-Cross Input 3:5.110 5.125 5.112 5.126 Output 3:R-Hollow Analysiså…ˆåˆ¤æ–­å›¾å½¢ç±»åž‹ï¼Œåœ¨åˆ¤æ–­æ˜¯å¦åŒ…å«å½±çº¿ï¼›æŒ‰ç…§ä¸‹é¢çš„ä»£ç çš„æ€è·¯ï¼Œéœ€è¦å°†æ—¢æœ‰ä¸‹å½±çº¿åˆæœ‰ä¸Šå½±çº¿çš„æƒ…å†µæ”¾åœ¨ç¬¬ä¸€ä½è¿›è¡Œåˆ¤æ–­ã€‚ Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float open,high,low,close; scanf("%f %f %f %f", &amp;open, &amp;high, &amp;low, &amp;close); if(close &lt; open)&#123; printf("BW-Solid"); &#125;else if(close == open)&#123; printf("R-Cross"); &#125;else&#123; printf("R-Hollow"); &#125; if(low &lt; open &amp;&amp; low &lt; close &amp;&amp; high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Lower Shadow and Upper Shadow\n"); &#125;else if(high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Upper Shadow\n"); &#125;else if(low &lt; open &amp;&amp; low &lt; close)&#123; printf(" with Lower Shadow\n"); &#125;else&#123; printf("\n"); &#125; return 0;&#125; 7-14 æ±‚æ•´æ•°æ®µå’Œç»™å®šä¸¤ä¸ªæ•´æ•°Aå’ŒBï¼Œè¾“å‡ºä»ŽAåˆ°Bçš„æ‰€æœ‰æ•´æ•°ä»¥åŠè¿™äº›æ•°çš„å’Œã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ•´æ•°Aå’ŒBï¼Œå…¶ä¸­$âˆ’100â‰¤Aâ‰¤Bâ‰¤100$ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationé¦–å…ˆé¡ºåºè¾“å‡ºä»ŽAåˆ°Bçš„æ‰€æœ‰æ•´æ•°ï¼Œæ¯5ä¸ªæ•°å­—å ä¸€è¡Œï¼Œæ¯ä¸ªæ•°å­—å 5ä¸ªå­—ç¬¦å®½åº¦ï¼Œå‘å³å¯¹é½ã€‚æœ€åŽåœ¨ä¸€è¡Œä¸­æŒ‰Sum=Xçš„æ ¼å¼è¾“å‡ºå…¨éƒ¨æ•°å­—çš„å’ŒXã€‚ Sample Input &amp; Sample output Input:-3 8 Output: -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 Analysisè€ƒå¯Ÿæ ¼å¼è¾“å‡ºå’Œæ±‚å’Œï¼Œè¾“å‡ºæ—¶æ³¨æ„æ ¼å¼å³å¯ï¼Œæœ€å¥½å°†æ•°å­—å’Œæ¢è¡Œåˆ†å¼€è¾“å‡ºã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,i,sum; scanf("%d %d", &amp;A, &amp;B); // A=1, B=5; for(i=0, sum=0; A&lt;=B; A++, i++) &#123; if(i%5 == 0 &amp;&amp; i != 0) printf("\n"); printf("%5d", A); sum+=A; &#125; printf("\nSum = %d\n", sum); return 0;&#125; 7-15 è®¡ç®—åœ†å‘¨çŽ‡æ ¹æ®ä¸‹é¢å…³ç³»å¼ï¼Œæ±‚åœ†å‘¨çŽ‡çš„å€¼ï¼Œç›´åˆ°æœ€åŽä¸€é¡¹çš„å€¼å°äºŽç»™å®šé˜ˆå€¼ã€‚${\pi\over2}=1+{1\over3}+{2!\over{3Ã—5}}+{3!\over{3Ã—5Ã—7}}+{\cdots}+{n!\over{3Ã—5Ã—7Ã—{\cdots}Ã—(2Ã—n+1)}}$ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå°äºŽ1çš„é˜ˆå€¼ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ»¡è¶³é˜ˆå€¼æ¡ä»¶çš„è¿‘ä¼¼åœ†å‘¨çŽ‡ï¼Œè¾“å‡ºåˆ°å°æ•°ç‚¹åŽ6ä½ã€‚ Sample Input &amp; Sample output Input:0.01 Output:3.132157 Analysisæœ¬é¢˜æ¯”è¾ƒç›´è§‚ï¼Œä½†éœ€è¦ç»†å¿ƒä¸€ç‚¹ã€‚å…ˆåˆ†æžä¸€ä¸‹ç»™å‡ºçš„å…³ç³»å¼çš„è§„å¾‹ï¼Œå·¦è¾¹å¸¸é‡ï¼Œæˆ‘ä»¬åªçœ‹å³è¾¹å°±è¡Œï¼›å‡è®¾å³è¾¹é¡¹æ•°æ˜¯ä»Ž1å¼€å§‹çš„ï¼Œé‚£ä¹ˆ$a_1=1$ï¼Œ$a_2={1\over3}$ï¼Œ$a_3={2!\over3Ã—5}$ï¼Œâ€¦ï¼ŒæŠŠ$a_1$å’Œ$a_2$æ¢ä¸ªå†™æ³•å°±æ˜¯$a_1={0!\over1}$ã€$a_2={1!\over{1Ã—3}}$ï¼Œè¿™ä¸‹å°±å¯ä»¥çœ‹å‡ºè§„å¾‹äº†ï¼Œä¸ŽåŽé¢çš„é€šé¡¹å…¬å¼æ˜¯ä¸€è‡´çš„ã€‚å¦‚æžœé¦–é¡¹çš„åˆ†å­ä»Ž0å¼€å§‹ï¼Œé‚£ä¹ˆå°±æ— æ³•é€šè¿‡å¾ªçŽ¯è‡ªåŠ¨å®Œæˆé˜¶ä¹˜çš„è®¡ç®—äº†ï¼ˆæˆ–è€…å•ç‹¬å†™ä¸€ä¸ªé˜¶ä¹˜å‡½æ•°ï¼Œè¿™æ ·å°±èƒ½ä»Ž0å¼€å§‹å–å€¼äº†ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ä»Ž$a_1$å¼€å§‹è®¡ç®—ï¼Œè®©$\pi$çš„åˆå§‹å€¼å°±ä¸º1.0ï¼›è¾“å‡ºç»“æžœæ—¶ï¼Œåˆ«å¿˜è®°äº†è¦ä¹˜ä¸Š2å€ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float pi=1.0,denominator=3.0,member=1.0,each_item=0.0,i=2.0; float threshold; scanf("%f", &amp;threshold); // threshold=0.01; do&#123; each_item = member/denominator; pi+=each_item; member*=i; denominator*=(2*i+1); i++; &#125;while(each_item &gt; threshold); printf("%.6f\n", 2*pi); return 0;&#125; 7-16 æ±‚ç¬¦åˆç»™å®šæ¡ä»¶çš„æ•´æ•°é›†ç»™å®šä¸è¶…è¿‡6çš„æ­£æ•´æ•°Aï¼Œè€ƒè™‘ä»ŽAå¼€å§‹çš„è¿žç»­4ä¸ªæ•°å­—ã€‚è¯·è¾“å‡ºæ‰€æœ‰ç”±å®ƒä»¬ç»„æˆçš„æ— é‡å¤æ•°å­—çš„3ä½æ•°ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºAã€‚ Output Specificationè¾“å‡ºæ»¡è¶³æ¡ä»¶çš„çš„3ä½æ•°ï¼Œè¦æ±‚ä»Žå°åˆ°å¤§ï¼Œæ¯è¡Œ6ä¸ªæ•´æ•°ã€‚æ•´æ•°é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†è¡Œæœ«ä¸èƒ½æœ‰å¤šä½™ç©ºæ ¼ã€‚ Sample Input &amp; Sample output Input:2 Output:234 235 243 245 253 254324 325 342 345 352 354423 425 432 435 452 453523 524 532 534 542 543 AnalysisæŒ‰ç…§é¢˜ç›®çš„æ„æ€ï¼Œå°†éœ€è¦è¾“å‡ºçš„ä¸‰ä½æ•°ï¼Œåˆ†åˆ«è¾“å‡ºå³å¯ï¼›ä¹Ÿå¯ä»¥ç›´æŽ¥è¾“å‡ºä¸€ä¸ªç™¾ä½æ•°ï¼Œä½†æ˜¯é‚£æ ·éœ€è¦è®¡ç®—ï¼Œä¼šç¨å¾®éº»çƒ¦ä¸€ç‚¹ã€‚æŒ‰ç…§ä¸‹é¢çš„ä»£ç ï¼Œå½“ä¸åŒä½çš„æ•°å­—å­˜åœ¨ç›¸åŒçš„æ—¶å€™ï¼Œå°±ç”¨continue;è¯­å¥è·³å‡ºæœ¬æ¬¡å¾ªçŽ¯ï¼Œi==jçš„åˆ¤æ–­ä¹Ÿå¯ä»¥åœ¨ç¬¬ä¸‰å±‚å¾ªçŽ¯å†…åšï¼Œå³ï¼šæ”¹ä¸ºk==j || k==i || i==jï¼Œä½†å½“i==jçš„æ—¶å€™å°±ä¼šè¿è¡Œå¤šæ¬¡åˆ¤æ–­äº†ã€‚ Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,i,j,k,count; scanf("%d", &amp;A);// A=2; count=0; for(i=A; i&lt;A+4; i++) &#123; for(j=A; j&lt;A+4; j++)&#123; if(i == j) continue; else&#123; for(k=A; k&lt;A+4; k++) &#123; if(k==j || k==i) continue; else&#123; printf("%d%d%d", i, j, k); count++; if(count%6 == 0) printf("\n"); else printf(" "); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 7-17 çˆ¬åŠ¨çš„è •è™«ä¸€æ¡è •è™«é•¿1å¯¸ï¼Œåœ¨ä¸€å£æ·±ä¸ºNå¯¸çš„äº•çš„åº•éƒ¨ã€‚å·²çŸ¥è •è™«æ¯1åˆ†é’Ÿå¯ä»¥å‘ä¸Šçˆ¬Uå¯¸ï¼Œä½†å¿…é¡»ä¼‘æ¯1åˆ†é’Ÿæ‰èƒ½æŽ¥ç€å¾€ä¸Šçˆ¬ã€‚åœ¨ä¼‘æ¯çš„è¿‡ç¨‹ä¸­ï¼Œè •è™«åˆä¸‹æ»‘äº†Då¯¸ã€‚å°±è¿™æ ·ï¼Œä¸Šçˆ¬å’Œä¸‹æ»‘é‡å¤è¿›è¡Œã€‚è¯·é—®ï¼Œè •è™«éœ€è¦å¤šé•¿æ—¶é—´æ‰èƒ½çˆ¬å‡ºäº•ï¼Ÿè¿™é‡Œè¦æ±‚ä¸è¶³1åˆ†é’ŸæŒ‰1åˆ†é’Ÿè®¡ï¼Œå¹¶ä¸”å‡å®šåªè¦åœ¨æŸæ¬¡ä¸Šçˆ¬è¿‡ç¨‹ä¸­è •è™«çš„å¤´éƒ¨åˆ°è¾¾äº†äº•çš„é¡¶éƒ¨ï¼Œé‚£ä¹ˆè •è™«å°±å®Œæˆä»»åŠ¡äº†ã€‚åˆå§‹æ—¶ï¼Œè •è™«æ˜¯è¶´åœ¨äº•åº•çš„ï¼ˆå³é«˜åº¦ä¸º0ï¼‰ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­é¡ºåºç»™å‡º3ä¸ªæ­£æ•´æ•°Nã€Uã€Dï¼Œå…¶ä¸­D&lt;Uï¼ŒNä¸è¶…è¿‡100ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè •è™«çˆ¬å‡ºäº•çš„æ—¶é—´ï¼Œä»¥åˆ†é’Ÿä¸ºå•ä½ã€‚ Sample Input &amp; Sample output Input:12 3 1 Output:11 Analysisæ‰¾è§„å¾‹ï¼Œå…ˆè¦æ˜Žç¡®â€èš¯èš“â€æ•´ä¸ªçˆ¬è¡Œçš„è¿‡ç¨‹ï¼Œåœ¨ç¬¬ä¸€åˆ†é’Ÿä¼šçˆ¬è¡ŒUå¯¸ï¼Œç¬¬äºŒåˆ†é’Ÿä¼šä¸‹æ»‘Då¯¸ï¼Œç¬¬äºŒåˆ†é’Ÿå®ŒåŽï¼Œèš¯èš“ä¸€å…±çš„çˆ¬è¡Œè·ç¦»å°±æ˜¯U-Dï¼Œç¬¬ä¸‰åˆ†é’Ÿçš„æ—¶å€™ï¼Œèš¯èš“çˆ¬è¡ŒUå¯¸ï¼Œæ€»è·ç¦»æ˜¯2*U-Dï¼Œç¬¬å››åˆ†é’Ÿå°±æ˜¯2*U-2*Dâ€¦ã€‚å¯ä»¥å‘çŽ°ï¼ŒUå’ŒDçš„ç³»æ•°ä¹‹å’Œå°±æ˜¯å½“å‰çš„æ—¶åˆ»ï¼Œæ‰¾åˆ°è¿™ä¸ªè§„å¾‹ä¹‹åŽå°±å¥½åŠžäº†ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,U,D; scanf("%d%d%d", &amp;N, &amp;U, &amp;D); // N=12, U=3, D=1; int i,j,times; for(i=1, j=0; N&lt;=100; i++, j++) &#123; if(i*U - j*D &gt;= N)&#123; times = i+j; break; &#125; &#125; printf("%d\n", times); return 0;&#125; 7-18 äºŒåˆ†æ³•æ±‚å¤šé¡¹å¼å•æ ¹äºŒåˆ†æ³•æ±‚å‡½æ•°æ ¹çš„åŽŸç†ä¸ºï¼šå¦‚æžœè¿žç»­å‡½æ•°$f(x)$åœ¨åŒºé—´$[a,b]$çš„ä¸¤ä¸ªç«¯ç‚¹å–å€¼å¼‚å·ï¼Œå³$f(a)f(b)&lt;0$ï¼Œåˆ™å®ƒåœ¨è¿™ä¸ªåŒºé—´å†…è‡³å°‘å­˜åœ¨1ä¸ªæ ¹$r$ï¼Œå³$f(r)=0$ã€‚äºŒåˆ†æ³•çš„æ­¥éª¤ä¸ºï¼šæ£€æŸ¥åŒºé—´é•¿åº¦ï¼Œå¦‚æžœå°äºŽç»™å®šé˜ˆå€¼ï¼Œåˆ™åœæ­¢ï¼Œè¾“å‡ºåŒºé—´ä¸­ç‚¹$(a+b)/2$ï¼›å¦åˆ™å¦‚æžœ$f(a)f(b)&lt;0$ï¼Œåˆ™è®¡ç®—ä¸­ç‚¹çš„å€¼$f((a+b)/2)$ï¼›å¦‚æžœ$f((a+b)/2)$æ­£å¥½ä¸º0ï¼Œåˆ™$(a+b)/2$å°±æ˜¯è¦æ±‚çš„æ ¹ï¼›å¦åˆ™å¦‚æžœ$f((a+b)/2)$ä¸Ž$f(a)$åŒå·ï¼Œåˆ™è¯´æ˜Žæ ¹åœ¨åŒºé—´$[(a+b)/2,b]$ï¼Œä»¤$a=(a+b)/2$ï¼Œé‡å¤å¾ªçŽ¯ï¼›å¦‚æžœ$f((a+b)/2)$ä¸Ž$f(b)$åŒå·ï¼Œåˆ™è¯´æ˜Žæ ¹åœ¨åŒºé—´$[a,(a+b)/2]$ï¼Œä»¤$b=(a+b)/2$ï¼Œé‡å¤å¾ªçŽ¯ã€‚æœ¬é¢˜ç›®è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—ç»™å®š3é˜¶å¤šé¡¹å¼$f(x)=a_3x^3+a_2x^2+a_1x+a_0$åœ¨ç»™å®šåŒºé—´$[a,b]$å†…çš„æ ¹ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­é¡ºåºç»™å‡ºå¤šé¡¹å¼çš„4ä¸ªç³»æ•°$a_3$ã€$a_2$ã€$a_1$ã€$a_0$ï¼Œåœ¨ç¬¬2è¡Œä¸­é¡ºåºç»™å‡ºåŒºé—´ç«¯ç‚¹$a$å’Œ$b$ã€‚é¢˜ç›®ä¿è¯å¤šé¡¹å¼åœ¨ç»™å®šåŒºé—´å†…å­˜åœ¨å”¯ä¸€å•æ ¹ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¯¥å¤šé¡¹å¼åœ¨è¯¥åŒºé—´å†…çš„æ ¹ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input:3 -1 -3 1-0.5 0.5 Output:0.33 AnalysisäºŒåˆ†æ³•æ±‚å¤šé¡¹å¼å•æ ¹ï¼Œæ‰€ä¾æ®çš„åŽŸç†å…¶å®žæ˜¯å‡½æ•°çš„é›¶ç‚¹æ€§è´¨ï¼šå‡½æ•°é›¶ç‚¹ä¸¤è¾¹çš„å‡½æ•°å€¼æ˜¯å¼‚å·çš„ï¼Œæ‰€ä»¥é›¶ç‚¹ä¸¤è¾¹å‡½æ•°å€¼çš„ä¹˜ç§¯å°äºŽ0ã€‚æ˜Žç™½è¿™ä¸ªåŽŸç†ä¹‹åŽï¼Œæˆ‘ä»¬æŒ‰ç…§é¢˜ç›®ç»™çš„ç®—æ³•è¿›è¡Œè®¡ç®—å³å¯ï¼›æ—¢ç„¶é¢˜ç›®å·²ç»ç»™å‡ºäº†å‡½æ•°å¼ï¼Œå¯ä»¥ç›´æŽ¥å°è£…æˆä¸€ä¸ªä¸“é—¨æ±‚å€¼çš„å‡½æ•°ï¼Œå‡½æ•°çš„ç³»æ•°å°±ç”¨å…¨å±€å˜é‡æ¥ä¿å­˜å³å¯ï¼Œè¿™æ ·ä»£ç çš„ä¸»ä½“å°±å¾ˆæ¸…æ™°ï¼›f(left)å’Œf(right)è¿™ä¸¤ä¸ªå‡½æ•°å€¼ä¸º0çš„æƒ…å†µæ˜¯å•ç‹¬çš„ï¼Œå¹¶ä¸èƒ½ç”¨if-elseç»„æˆå¯¹ç«‹å…³ç³»ï¼Œæ³¨æ„é¢˜ç›®å¯¹ç²¾åº¦çš„è¦æ±‚æ˜¯å°æ•°ç‚¹åŽ2ä½ï¼Œæ‰€ä»¥å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹çš„å·®å€¼è¦å¤§äºŽ0.01ï¼Œè‹¥æ²¡æœ‰è¿™ä¸ªæ¡ä»¶ï¼Œæäº¤æ—¶ä¼šè¶…æ—¶ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;float a3,a2,a1,a0;float Cal_polynomial(float n);int main(int argc, char const *argv[])&#123; float left,right,mid; scanf("%f %f %f %f %f %f", &amp;a3, &amp;a2, &amp;a1, &amp;a0, &amp;left, &amp;right); while(Cal_polynomial(left) * Cal_polynomial(right) &lt;= 0 &amp;&amp; (right-left) &gt; 0.01) &#123; if(Cal_polynomial(left) == 0)&#123; printf("%.2f\n", left); return 0; &#125; if(Cal_polynomial(right) == 0)&#123; printf("%.2f\n", right); return 0; &#125; mid=(left+right)/2; if(Cal_polynomial(left) * Cal_polynomial(mid) &gt; 0)&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; printf("%.2f\n", (right+left)/2); return 0;&#125;float Cal_polynomial(float n)&#123; float ret=0.0; ret = a3*n*n*n + a2*n*n + a1*n + a0; return ret;&#125; 7-19 æ”¯ç¥¨é¢é¢ä¸€ä¸ªé‡‡è´­å‘˜åŽ»é“¶è¡Œå…‘æ¢ä¸€å¼ yå…ƒfåˆ†çš„æ”¯ç¥¨ï¼Œç»“æžœå‡ºçº³å‘˜é”™ç»™äº†få…ƒyåˆ†ã€‚é‡‡è´­å‘˜ç”¨åŽ»äº†nåˆ†ä¹‹åŽæ‰å‘è§‰æœ‰é”™ï¼ŒäºŽæ˜¯æ¸…ç‚¹äº†ä½™é¢å°šæœ‰2yå…ƒ2fåˆ†ï¼Œé—®è¯¥æ”¯ç¥¨é¢é¢æ˜¯å¤šå°‘ï¼Ÿ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå°äºŽ100çš„æ­£æ•´æ•°nã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰æ ¼å¼y.fè¾“å‡ºè¯¥æ”¯ç¥¨çš„åŽŸå§‹é¢é¢ã€‚å¦‚æžœæ— è§£ï¼Œåˆ™è¾“å‡ºNo Solutionã€‚ Sample Input &amp; Sample Output Input 1:23 Output 1:25.51 Input 2:22 Output 2:No Solution Analysisæœ¬é¢˜ä¹ä¸€çœ‹æŒºæ‡µé€¼çš„ðŸ˜“ï¼Œå…¶å®žæ˜¯é“æ•°å­¦é¢˜ã€‚å¤šè¯»å‡ éé¢˜ç›®ï¼Œå¯ä»¥åˆ—å‡ºæ–¹ç¨‹ï¼š100*f+y-n=200*y+2*f(è¿™é‡Œçš„å…ƒã€åˆ†åº”è¯¥å°±æ˜¯RMBä¸­çš„å•ä½äº†)ï¼ŒåŒ–ç®€å¾—ï¼š98*f-199*y=nï¼Œä¾é¢˜æ„ï¼Œn&lt;100ä¸”n&gt;0ï¼Œè¯´æ˜Ž98*f-199*y&gt;0ï¼Œè¿™é‡Œéœ€è¦æ”¾ç¼©ä¸€ä¸‹ï¼Œå³ï¼š98*f-199*y â‰ˆ 100*f-200*y = f-2*y &gt; 0ï¼Œå°±æ˜¯f&gt;2*yäº†ï¼Œè€Œfåœ¨æœ¬é¢˜ä¸­çš„å•ä½æ˜¯åˆ†ï¼Œæ‰€ä»¥0&lt;f&lt;100(èƒ½æƒ³åˆ°çš„å”¯ä¸€è§£é‡Šâ€¦)ï¼Œæ‰€ä»¥å°±å¾—åˆ°ï¼š0&lt;f&lt;100, 0&lt;y&lt;50ï¼Œè¿™å°±æ˜¯å¾ªçŽ¯çš„æ¡ä»¶ã€‚æœ‰ç‚¹å‘çˆ¹~ Code12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int y,f,n,flag=0; scanf("%d", &amp;n); // n=23; for(y=0; y&lt;50; y++) &#123; for(f=0; f&lt;100; f++) &#123; if(98*f - 199*y == n)&#123; printf("%d.%d\n", y, f); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-20 æ‰“å°ä¹ä¹å£è¯€è¡¨ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸‹ä¸‰è§’ä¹ä¹å£è¯€è¡¨ï¼š1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„ä¸€ä½æ­£æ•´æ•°Nï¼Œè¾“å‡ºä»Ž11åˆ°NNçš„éƒ¨åˆ†å£è¯€è¡¨ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°Nï¼ˆ1â‰¤Nâ‰¤9ï¼‰ã€‚ Output Specificationè¾“å‡ºä¸‹ä¸‰è§’N*Néƒ¨åˆ†å£è¯€è¡¨ï¼Œå…¶ä¸­ç­‰å·å³è¾¹æ•°å­—å 4ä½ã€å·¦å¯¹é½ã€‚ Sample Input &amp; Sample output Input:4 Output:12341*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 Analysisåˆ†æžä¸€ä¸‹ï¼Œä¹ä¹ä¹˜æ³•è¡¨çš„ç»„æˆï¼Œä¸¤ä¸ªå€¼å’Œè¿™ä¸¤ä¸ªå€¼çš„ä¹˜ç§¯ï¼Œä»Žè¿™é‡Œï¼Œåº”è¯¥å¯ä»¥æƒ³åˆ°åŒé‡å¾ªçŽ¯ï¼›åœ¨ä»”ç»†è§‚å¯Ÿä¸€ä¸‹æ ·ä¾‹ï¼Œç»„åŽçš„é¡¹ä¸­çš„å› å­ç­‰äºŽè¾“å…¥æ ·ä¾‹çš„Nå€¼çš„ï¼Œæ‰€ä»¥å¯ä»¥æŽ¨æ–­ï¼Œå› å­çš„å€¼æ˜¯å°äºŽç­‰äºŽNçš„ï¼›å¦å¤–ï¼Œè¿˜å¯ä»¥å‘çŽ°ï¼Œç¬¬äºŒä¸ªå› å­çš„å€¼æ˜¯å°äºŽç­‰äºŽç¬¬ä¸€ä¸ªå› å­çš„å€¼çš„ï¼›æŒ‰ç…§ä»¥ä¸Šçš„æ€è·¯ï¼Œåœ¨æ³¨æ„ä¸€ä¸‹è¾“å‡ºæ ¼å¼ï¼Œå°±å¯ä»¥æ‹¿ä¸‹è¿™é“é¢˜äº†ï¼Œæ³¨æ„è¾“å‡ºçš„æ ¼å¼ï¼Œæ¢è¡Œå¯ä»¥æ”¾åœ¨ç¬¬äºŒå±‚å¾ªçŽ¯å†…æ‰§è¡Œï¼Œæ¡ä»¶æ”¹ä¸ºj == iå³å¯ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,i,j; scanf("%d", &amp;N); // N=4; for(i=1; i&lt;=N; i++) &#123; for(j=1; j&lt;=i; j++)&#123; printf("%d*%d=%-4d", j, i, i*j); &#125; if(j-1 == i)&#123; printf("\n"); &#125; &#125; return 0;&#125; 7-21 æ±‚ç‰¹æ®Šæ–¹ç¨‹çš„æ­£æ•´æ•°è§£æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„æ­£æ•´æ•°Nï¼Œæ±‚æ–¹ç¨‹$X^2â€‹+Y^2=N$çš„å…¨éƒ¨æ­£æ•´æ•°è§£ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤10000ï¼‰ Output Specificationè¾“å‡ºæ–¹ç¨‹$X^2+Y^2=N$çš„å…¨éƒ¨æ­£æ•´æ•°è§£ï¼Œå…¶ä¸­Xâ‰¤Yã€‚æ¯ç»„è§£å 1è¡Œï¼Œä¸¤æ•°å­—é—´ä»¥1ç©ºæ ¼åˆ†éš”ï¼ŒæŒ‰Xçš„é€’å¢žé¡ºåºè¾“å‡ºã€‚å¦‚æžœæ²¡æœ‰è§£ï¼Œåˆ™è¾“å‡ºNo Solutionã€‚ Sample Input &amp; Sample Output Input 1:884 Output 1:10 2820 22 Input 2:11 Output 2:No Solution Analysisæ­¤é¢˜ä¸éš¾ï¼Œçœ‹é¢˜ç›®å½¢å¼ä¹Ÿæ˜¯é“æ•°å­¦é¢˜ï¼Œå¤§è‡´åˆ†æžä¸€ä¸‹ï¼ŒN = X^2+Y^2 &gt;= 2*x*yï¼Œæ—¢æœ‰2*x*y &lt;= N &lt;= 10000ï¼ŒåŒ–ç®€å¾—xy &lt;= 5000ï¼ŒåˆçŸ¥Nçš„æœ€å¤§å€¼æ˜¯10000ï¼Œå¼€æ–¹æ˜¯100ï¼Œè€ŒXå’ŒYçš„å¹³æ–¹ä¹‹å’Œå°äºŽç­‰äºŽNï¼Œæ‰€ä»¥Xå’ŒYéƒ½ä¸å¤§äºŽ100ï¼›ä¾æ®é¢˜ç›®çš„è¦æ±‚ï¼Œéœ€è¦æŒ‰ç…§Xé€’å¢žçš„é¡ºåºè¿›è¡Œè¾“å‡ºï¼Œæ‰€ä»¥ç›´æŽ¥ä»¥Yä¸ºæœ€å¤§å€¼ï¼ŒXä»Žæœ€å°å¼€å§‹å–å€¼å°±å¯ä»¥äº†ï¼ˆä¹Ÿæœ‰å…¶ä»–åšæ³•ï¼‰ã€‚ä¹‹æ‰€ä»¥å†™break;çš„åŽŸå› æ˜¯ï¼šåœ¨è¿™é“é¢˜ç›®ä¸­ï¼Œå½“Xå’ŒNç¡®å®šåŽï¼ŒYä¹Ÿæ˜¯ç¡®å®šçš„ï¼ŒåŒç†Yå’ŒNç¡®å®šåŽï¼ŒXä¹Ÿæ˜¯ç¡®å®šçš„äº†ã€‚ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N; scanf("%d", &amp;N);// N=884; int X,Y,flag=0; for(Y=100; Y&gt;0; Y--) &#123; for(X=1; X&lt;=Y; X++) &#123; if(X*X + Y*Y == N &amp;&amp; (X*Y) &lt;= 5000)&#123; printf("%d %d\n", X, Y); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-22 é¾Ÿå…”èµ›è·‘ä¹Œé¾Ÿä¸Žå…”å­è¿›è¡Œèµ›è·‘ï¼Œè·‘åœºæ˜¯ä¸€ä¸ªçŸ©åž‹è·‘é“ï¼Œè·‘é“è¾¹å¯ä»¥éšåœ°è¿›è¡Œä¼‘æ¯ã€‚ä¹Œé¾Ÿæ¯åˆ†é’Ÿå¯ä»¥å‰è¿›3ç±³ï¼Œå…”å­æ¯åˆ†é’Ÿå‰è¿›9ç±³ï¼›å…”å­å«Œä¹Œé¾Ÿè·‘å¾—æ…¢ï¼Œè§‰å¾—è‚¯å®šèƒ½è·‘èµ¢ä¹Œé¾Ÿï¼ŒäºŽæ˜¯ï¼Œæ¯è·‘10åˆ†é’Ÿå›žå¤´çœ‹ä¸€ä¸‹ä¹Œé¾Ÿï¼Œè‹¥å‘çŽ°è‡ªå·±è¶…è¿‡ä¹Œé¾Ÿï¼Œå°±åœ¨è·¯è¾¹ä¼‘æ¯ï¼Œæ¯æ¬¡ä¼‘æ¯30åˆ†é’Ÿï¼Œå¦åˆ™ç»§ç»­è·‘10åˆ†é’Ÿï¼›è€Œä¹Œé¾Ÿéžå¸¸åŠªåŠ›ï¼Œä¸€ç›´è·‘ï¼Œä¸ä¼‘æ¯ã€‚å‡å®šä¹Œé¾Ÿä¸Žå…”å­åœ¨åŒä¸€èµ·ç‚¹åŒä¸€æ—¶åˆ»å¼€å§‹èµ·è·‘ï¼Œè¯·é—®Tåˆ†é’ŸåŽä¹Œé¾Ÿå’Œå…”å­è°è·‘å¾—å¿«ï¼Ÿ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ¯”èµ›æ—¶é—´Tï¼ˆåˆ†é’Ÿï¼‰ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ¯”èµ›çš„ç»“æžœï¼šä¹Œé¾Ÿèµ¢è¾“å‡º@_@ï¼Œå…”å­èµ¢è¾“å‡º^_^ï¼Œå¹³å±€åˆ™è¾“å‡º-_-ï¼›åŽè·Ÿ1ç©ºæ ¼ï¼Œå†è¾“å‡ºèƒœåˆ©è€…è·‘å®Œçš„è·ç¦»ã€‚ Sample Input &amp; Sample output Input:242 Output:@_@ 726 Analysisè¿™é“é¢˜çš„éš¾ç‚¹åœ¨å¦‚ä½•è®¡ç®—å…”å­åœ¨Tæ—¶é—´å†…è·‘è¿‡çš„è·ç¦»ã€‚å…ˆçœ‹ä¹Œé¾Ÿï¼Œä¹Œé¾Ÿåœ¨Tæ—¶é—´å†…è·‘è¿‡çš„è·ç¦»æ¯”è¾ƒç®€å•ï¼Œå› ä¸ºä¹Œé¾Ÿæ˜¯ä¸ä¼šä¼‘æ¯çš„ï¼Œæ‰€ä»¥å…¶è·ç¦»å°±æ˜¯å…¶é€Ÿåº¦å’ŒTçš„ä¹˜ç§¯ï¼›è€Œå…”å­ä¼šä¼‘æ¯ï¼Œå¹¶ä¸”æ˜¯æ¯éš”10åˆ†é’Ÿç¡®è®¤æ¯”ä¹Œé¾Ÿå¿«åŽä¼‘æ¯ï¼Œæ‰€ä»¥ï¼Œéœ€è¦åœ¨æ¯ä¸ªä»¥10åˆ†é’Ÿä¸ºæ—¶é—´é—´éš”çš„æ—¶é—´ç‚¹è¿›è¡Œåˆ¤æ–­ï¼Œä¸Žä¹‹è€Œæ¥çš„å¦å¤–ä¸€ä¸ªé—®é¢˜å°±æ˜¯å…”å­ä¸æ˜¯ä¼‘æ¯10åˆ†é’Ÿï¼Œè€Œæ˜¯ä¼‘æ¯30åˆ†é’Ÿï¼Œæ‰€ä»¥ï¼Œè¿˜éœ€è¦ä¸€ä¸ªè¡¨ç¤ºå…”å­ä»ç„¶åœ¨ä¼‘æ¯çš„æ ‡å¿—ä½ï¼Œè¿™ä¸ªæ ‡å¿—ä½ä¼šåœ¨ä¹Œé¾Ÿå‰è¿›ï¼Œå…”å­ä¼‘æ¯æ—¶ï¼Œè‡ªåŠ¨å‡å°‘ã€‚å½“å‡å°‘åˆ°0æ—¶ï¼Œå…”å­ä¼šå†æ¬¡ç¡®è®¤æ˜¯å¦è¶…è¿‡ä¹Œé¾Ÿã€‚è¾“å‡ºç»“æžœæ—¶ï¼Œæ³¨æ„å¹³å±€çš„æ—¶å€™ä¹Ÿè¦è¾“å‡ºè·‘å®Œçš„è·ç¦»ï¼›å¹¶ä¸”æ—¶é—´è¦ä»Ž0æ—¶åˆ»å¼€å§‹ï¼Œå³æ—¶é—´åŒºé—´ä¸º$[0,T-1]$ï¼Œè‹¥åŒºé—´ä¸º$[1,T]$ï¼Œå°½ç®¡åŒºé—´é•¿åº¦æ—¶ä¸€è‡´çš„ï¼Œåœ¨30åˆ†é’Ÿæ—¶ï¼Œå…”å­çš„è·ç¦»å°±æ˜¯81ï¼Œä¹Œé¾Ÿçš„è·ç¦»å°±æ˜¯90äº†ï¼Œä½†å®žé™…ä¸Šåº”è¯¥æ˜¯ç›¸ç­‰çš„ï¼Œå³å¹³å±€ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int rabbit_dis=0,turtle_dis=0,rabbit_spd=9,turtle_spd=3,T; scanf("%d", &amp;T); // T=30; int i,rabbit_on=1,break_times=0; for(i=0; i&lt;T; i++) &#123; if(i%10 == 0)&#123; if(rabbit_dis &gt; turtle_dis &amp;&amp; break_times == 0)&#123; rabbit_on=0; break_times=30; &#125;else&#123; rabbit_on=1; &#125; &#125; if(rabbit_on &amp;&amp; break_times == 0)&#123; rabbit_dis+=rabbit_spd; &#125; turtle_dis+=turtle_spd; if(break_times)&#123; break_times--; &#125; &#125; if(turtle_dis &gt; rabbit_dis)&#123; printf("@_@ %d\n", turtle_dis); &#125;else if(turtle_dis == rabbit_dis)&#123; printf("-_- %d\n", turtle_dis); &#125;else&#123; printf("^_^ %d\n", rabbit_dis); &#125; return 0;&#125; 7-23 å¸å€¼è½¬æ¢è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼ˆä½æ•°ä¸è¶…è¿‡9ä½ï¼‰ä»£è¡¨ä¸€ä¸ªäººæ°‘å¸å€¼ï¼ˆå•ä½ä¸ºå…ƒï¼‰ï¼Œè¯·è½¬æ¢æˆè´¢åŠ¡è¦æ±‚çš„å¤§å†™ä¸­æ–‡æ ¼å¼ã€‚å¦‚23108å…ƒï¼Œè½¬æ¢åŽå˜æˆâ€œè´°ä¸‡åä»Ÿå£¹ç™¾é›¶æŒâ€å…ƒã€‚ä¸ºäº†ç®€åŒ–è¾“å‡ºï¼Œç”¨å°å†™è‹±æ–‡å­—æ¯a-jé¡ºåºä»£è¡¨å¤§å†™æ•°å­—0-9ï¼Œç”¨Sã€Bã€Qã€Wã€Yåˆ†åˆ«ä»£è¡¨æ‹¾ã€ç™¾ã€ä»Ÿã€ä¸‡ã€äº¿ã€‚äºŽæ˜¯23108å…ƒåº”è¢«è½¬æ¢è¾“å‡ºä¸ºâ€œcWdQbBaiâ€å…ƒã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡9ä½çš„éžè´Ÿæ•´æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè½¬æ¢åŽçš„ç»“æžœã€‚æ³¨æ„â€œé›¶â€çš„ç”¨æ³•å¿…é¡»ç¬¦åˆä¸­æ–‡ä¹ æƒ¯ã€‚ Sample Input &amp; Sample output Input 1:813227345 Output 1:iYbQdBcScWhQdBeSf Input 2:6900 Output 2:gQjB Analysisè¿™é“é¢˜æœ‰ç‚¹éš¾ðŸ˜‘ï¼Œå€Ÿé‰´äº†ä¸€ä¸‹ccDLIyyçš„æ€è·¯ï¼Œå¹¶ä¿®æ”¹äº†å…¶ä¸­ä¸€äº›ä»£ç ã€‚å¦‚æžœæœ¬é¢˜åªæ˜¯å°†è¾“å…¥çš„æ•°å­—çš„æ¯ä¸€ä½æ‹†åˆ†å‡ºæ¥çš„è¯ï¼Œå°±ååˆ†ç®€å•ï¼Œä½†æ˜¯è¿˜éœ€è¦æŒ‰ç…§ä¸­æ–‡ä¹ æƒ¯è¾“å‡ºè¿™äº›æ•°å­—çš„è¯»æ³•ï¼Œå°±æ¯”è¾ƒéº»çƒ¦äº†ã€‚é¦–å…ˆï¼Œéœ€è¦ä¸€ä¸ªæ•°ç»„æ¥å•ç‹¬å­˜æ”¾æ¯ä¸€ä½æ•°ï¼Œå› ä¸ºï¼Œå¦‚æžœä¸è¿™æ ·ï¼Œå°±æ— æ³•å¯¹ä¸­æ–‡ä¹ æƒ¯è¿›è¡Œåˆ¤æ–­äº†(å³å½“å‰ä½ä¸Šçš„æ•°å­—éž0ï¼Œå‰ä¸€ä½æˆ–è€…åŽä¸€ä½ä¸º0çš„æƒ…å†µä¸‹ï¼Œæ­¤æ—¶çš„è¯»æ³•)ï¼›æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œä¸å¦¨ç›´æŽ¥ç”¨æ•°ç»„å»ºç«‹èµ·æ•°å­—å’Œå­—æ¯çš„æ˜ å°„å…³ç³»ï¼Œè¿™æ ·åŽé¢è°ƒç”¨ä¹Ÿæ–¹ä¾¿ä¸€äº›(ä¸å¾—ä¸è¯´ï¼Œè¿™ä¸ªæƒ³æ³•å¾ˆé«˜æ˜Žä¹Ÿå¾ˆçœäº‹)ï¼›å¦å¤–ï¼Œåœ¨å†™ä»£ç ä¹‹å‰ï¼Œå…ˆå¤§æ¦‚åˆ†æžä¸€ä¸‹å¹³å¸¸æˆ‘ä»¬éƒ½è¿™äº›æ•°å­—çš„è¯»æ³•ï¼š23108æ˜¯è¯»ä½œäºŒä¸‡ä¸‰åƒä¸€ç™¾é›¶å…«ï¼Œ813227345æ˜¯è¯»ä½œå…«äº¿ä¸€åƒä¸‰ç™¾äºŒåäºŒä¸‡ä¸ƒåƒä¸‰ç™¾å››åäº”ï¼Œä»Žè¿™é‡Œï¼Œå¯ä»¥çœ‹å‡ºï¼Œä¸‡æ˜¯åœ¨æ•°å­—ä½æ•°å¤§äºŽç­‰äºŽ5çš„æ—¶å€™æ‰ä¼šè¾“å‡ºï¼Œè€Œäº¿æ˜¯åœ¨æ•°å­—ä½æ•°å¤§äºŽç­‰äºŽ9çš„æ—¶å€™æ‰ä¼šè¾“å‡ºï¼Œåœ¨æ¯å››ä½å†…ï¼Œè¿›è¡Œè¾“å‡ºçš„æ ¼å¼å­—ç¬¦éƒ½æ˜¯åã€ç™¾å’Œåƒï¼Œæ‰€ä»¥ï¼Œéœ€è¦æ ¹æ®ä½æ•°è¿›è¡Œä¸åŒæƒ…å†µçš„åˆ¤æ–­ã€‚å¦å¤–ï¼Œåœ¨ä¸‹é¢çš„ä»£ç ä¸­å¯¹äºŽ100000001è¿™ç§æƒ…å†µè¾“å‡ºçš„ç»“æžœæ˜¯ä¸€äº¿é›¶é›¶é›¶ä¸€ï¼Œå¯¹äºŽ10è¿™ç§æƒ…å†µè¾“å‡ºçš„ç»“æžœæ˜¯ä¸€åã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;char num2letter[11]="abcdefghij";char units[4]="QBS";void exchange(int num[], int n);int main(int argc, char const *argv[])&#123; char number[10]; scanf("%s", number); int i,len=strlen(number); int num[9]=&#123;0&#125;; for(i=0; i&lt;len; i++)&#123; num[i]=number[i] - '0'; &#125; if(len &lt;= 4)&#123; exchange(num, len-1); &#125;else if(len &lt;= 8)&#123; exchange(num, len-5); printf("W"); exchange(num+len-4, 3); &#125;else&#123; printf("%cY", num2letter[num[0]]); exchange(num+1, 3); if(num[1]!=0 &amp;&amp; num[2]!=0 &amp;&amp; num[3]!=0 &amp;&amp; num[4]!=0)&#123; printf("W"); &#125; if(num[len-4] == 0)&#123; printf("%c", num2letter[0]); &#125; exchange(num+5, 3); &#125; return 0;&#125;void exchange(int num[], int n)&#123; int index = 0; while(num[index] == 0)&#123; index++; &#125; if(num[index-1] == 0 &amp;&amp; index != 0)&#123; printf("%c", num2letter[0]); &#125; while(index &lt;= n) &#123; if(num[index] != 0 &amp;&amp; index &lt;= n)&#123; if(index != n)&#123; printf("%c%c", num2letter[num[index]], units[4-n-1+index]); &#125;else&#123; printf("%c", num2letter[num[index]]); &#125; &#125;else if(num[index] == 0 &amp;&amp; num[index+1] != 0 &amp;&amp; index &lt;= n-1)&#123; printf("%c", num2letter[0]); &#125; index++; &#125;&#125; 7-24 çº¦åˆ†æœ€ç®€åˆ†å¼åˆ†æ•°å¯ä»¥è¡¨ç¤ºä¸ºåˆ†å­/åˆ†æ¯çš„å½¢å¼ã€‚ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥ä¸€ä¸ªåˆ†æ•°ï¼Œç„¶åŽå°†å…¶çº¦åˆ†ä¸ºæœ€ç®€åˆ†å¼ã€‚æœ€ç®€åˆ†å¼æ˜¯æŒ‡åˆ†å­å’Œåˆ†æ¯ä¸å…·æœ‰å¯ä»¥çº¦åˆ†çš„æˆåˆ†äº†ã€‚å¦‚6/12å¯ä»¥è¢«çº¦åˆ†ä¸º1/2ã€‚å½“åˆ†å­å¤§äºŽåˆ†æ¯æ—¶ï¼Œä¸éœ€è¦è¡¨è¾¾ä¸ºæ•´æ•°åˆåˆ†æ•°çš„å½¢å¼ï¼Œå³11/8è¿˜æ˜¯11/8ï¼›è€Œå½“åˆ†å­åˆ†æ¯ç›¸ç­‰æ—¶ï¼Œä»ç„¶è¡¨è¾¾ä¸º1/1çš„åˆ†æ•°å½¢å¼ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªåˆ†æ•°ï¼Œåˆ†å­å’Œåˆ†æ¯ä¸­é—´ä»¥æ–œæ /åˆ†éš”ï¼Œå¦‚ï¼š12/34è¡¨ç¤º34åˆ†ä¹‹12ã€‚åˆ†å­å’Œåˆ†æ¯éƒ½æ˜¯æ­£æ•´æ•°ï¼ˆä¸åŒ…å«0ï¼Œå¦‚æžœä¸æ¸…æ¥šæ­£æ•´æ•°çš„å®šä¹‰çš„è¯ï¼‰ã€‚æç¤ºï¼šåœ¨scanfçš„æ ¼å¼å­—ç¬¦ä¸²ä¸­åŠ å…¥/ï¼Œè®©scanfæ¥å¤„ç†è¿™ä¸ªæ–œæ ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªåˆ†æ•°å¯¹åº”çš„æœ€ç®€åˆ†å¼ï¼Œæ ¼å¼ä¸Žè¾“å…¥çš„ç›¸åŒï¼Œå³é‡‡ç”¨åˆ†å­/åˆ†æ¯çš„å½¢å¼è¡¨ç¤ºåˆ†æ•°ã€‚å¦‚5/6è¡¨ç¤º6åˆ†ä¹‹5ã€‚ Sample Input &amp; Sample output Input:66/120 Output:11/20 Analysisè¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œåªè¦çŸ¥é“åˆ†å­/åˆ†æ¯çº¦åˆ†åˆ°æœ€ç®€å½¢å¼ç›´æŽ¥é™¤ä»¥äºŒè€…çš„æœ€å¤§å…¬çº¦æ•°å³å¯ã€‚æ‰€ä»¥ï¼Œç›´æŽ¥æ±‚æœ€å¤§å…¬çº¦æ•°å³å¯ï¼Œä½¿ç”¨è¾—è½¬ç›¸é™¤æ³•æˆ–æ›´ç›¸å‡æŸæ³•çš†å¯ï¼Œé€’å½’ä¸Žå¦ä¹Ÿçš†å¯ã€‚ Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int gcd(int a, int b);int main(int argc, char const *argv[])&#123; int member,denominator; scanf("%d/%d", &amp;member, &amp;denominator); // member=66, denominator=120; printf("%d/%d\n", member/gcd(member, denominator), denominator/gcd(member, denominator)); return 0;&#125;int gcd(int a, int b)&#123; if(a &gt; b) return gcd(b, a); int temp; while(a) &#123; temp=b%a; b=a; a=temp; &#125; return b; /* other method: use recursion. return a==0?b:gcd(b%a, a); */&#125; 7-25 å¿µæ•°å­—è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œè¾“å‡ºæ¯ä¸ªæ•°å­—å¯¹åº”çš„æ‹¼éŸ³ã€‚å½“æ•´æ•°ä¸ºè´Ÿæ•°æ—¶ï¼Œå…ˆè¾“å‡ºfuå­—ã€‚åä¸ªæ•°å­—å¯¹åº”çš„æ‹¼éŸ³å¦‚ä¸‹ï¼š123456789100: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ•´æ•°ï¼Œå¦‚ï¼š1234ã€‚æç¤ºï¼šæ•´æ•°åŒ…æ‹¬è´Ÿæ•°ã€é›¶å’Œæ­£æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªæ•´æ•°å¯¹åº”çš„æ‹¼éŸ³ï¼Œæ¯ä¸ªæ•°å­—çš„æ‹¼éŸ³ä¹‹é—´ç”¨ç©ºæ ¼åˆ†å¼€ï¼Œè¡Œæœ«æ²¡æœ‰æœ€åŽçš„ç©ºæ ¼ã€‚å¦‚yi er san siã€‚ Sample Input &amp; Sample output Input:-600 Output:fu liu ling ling Analysisæ­¤é¢˜ä¸éš¾ï¼Œåªéœ€å¯¹æ³¨æ„è´Ÿæ•°å’Œè¾“å‡ºçš„æ ¼å¼å³å¯ï¼›å¯ä»¥ç›´æŽ¥å½“ä½œå­—ç¬¦å¤„ç†ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ä½æ‹†åˆ†çš„æ€è·¯æ¥åšï¼Œå¯èƒ½ç¨å¾®ä¼šéº»çƒ¦ä¸€ç‚¹ï¼›å¯ä»¥ä½¿ç”¨æŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥ä¸ä½¿ç”¨æŒ‡é’ˆã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char num[100]; scanf("%s", num); char *p = num; if(*p == '-')&#123; printf("fu "); p++; &#125; for(; *p != '\0'; p++) &#123; switch(*p) &#123; case '0': printf("ling");break; case '1': printf("yi");break; case '2': printf("er");break; case '3': printf("san");break; case '4': printf("si");break; case '5': printf("wu");break; case '6': printf("liu");break; case '7': printf("qi");break; case '8': printf("ba");break; case '9': printf("jiu");break; default: continue; &#125; if(*(p+1) == '\0') printf("\n"); else printf(" "); &#125; return 0;&#125; 7-26 å•è¯é•¿åº¦ä½ çš„ç¨‹åºè¦è¯»å…¥ä¸€è¡Œæ–‡æœ¬ï¼Œå…¶ä¸­ä»¥ç©ºæ ¼åˆ†éš”ä¸ºè‹¥å¹²ä¸ªå•è¯ï¼Œä»¥.ç»“æŸã€‚ä½ è¦è¾“å‡ºæ¯ä¸ªå•è¯çš„é•¿åº¦ã€‚è¿™é‡Œçš„å•è¯ä¸Žè¯­è¨€æ— å…³ï¼Œå¯ä»¥åŒ…æ‹¬å„ç§ç¬¦å·ï¼Œæ¯”å¦‚it&#39;sç®—ä¸€ä¸ªå•è¯ï¼Œé•¿åº¦ä¸º4ã€‚æ³¨æ„ï¼Œè¡Œä¸­å¯èƒ½å‡ºçŽ°è¿žç»­çš„ç©ºæ ¼ï¼›æœ€åŽçš„.ä¸è®¡ç®—åœ¨å†…ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€è¡Œæ–‡æœ¬ï¼Œä»¥.ç»“æŸæç¤ºï¼šç”¨scanf(&quot;%c&quot;,...);æ¥è¯»å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œç›´åˆ°è¯»åˆ°.ä¸ºæ­¢ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™è¡Œæ–‡æœ¬å¯¹åº”çš„å•è¯çš„é•¿åº¦ï¼Œæ¯ä¸ªé•¿åº¦ä¹‹é—´ä»¥ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«æ²¡æœ‰æœ€åŽçš„ç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:Itâ€™s great to see you here. Output:4 5 2 3 3 4 Analysisæœ¬é¢˜ä¸éš¾ï¼Œå¯¹æ¯ä¸€ä¸ªå•è¯çš„å­—ç¬¦è¿›è¡ŒéåŽ†å³å¯ï¼Œæ¯æ¬¡æ‰«æåˆ°ç©ºæ ¼ï¼Œå°±è·³è¿‡ï¼Œä¸€æ—¦æ‰«æåˆ°ä¸‹ä¸€ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œå°±è¾“å‡ºä¸Šä¸€ä¸ªå•è¯çš„é•¿åº¦ã€‚æ³¨æ„æ ¼å¼ï¼Œç©ºå¥å­ä¸éœ€è¦è¾“å‡º0ï¼Œç›´æŽ¥è¾“å‡º\nå³å¯ã€‚ Code123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int length=0,flag=0; char ch; while((ch=getchar()) != '.') &#123; if(ch != ' ')&#123; if(length &gt; 0 &amp;&amp; flag &gt; 0)&#123; printf("%d ", length); length=0; &#125; length++; flag=0; &#125; if(ch == ' ') flag++; &#125; if(length &gt; 0) printf("%d\n", length); else printf("0\n"); return 0;&#125; 7-27 å†’æ³¡æ³•æŽ’åºå°†Nä¸ªæ•´æ•°æŒ‰ä»Žå°åˆ°å¤§æŽ’åºçš„å†’æ³¡æŽ’åºæ³•æ˜¯è¿™æ ·å·¥ä½œçš„ï¼šä»Žå¤´åˆ°å°¾æ¯”è¾ƒç›¸é‚»ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æžœå‰é¢çš„å…ƒç´ å¤§äºŽå…¶ç´§éšçš„åŽé¢å…ƒç´ ï¼Œåˆ™äº¤æ¢å®ƒä»¬ã€‚é€šè¿‡ä¸€éæ‰«æï¼Œåˆ™æœ€åŽä¸€ä¸ªå…ƒç´ å¿…å®šæ˜¯æœ€å¤§çš„å…ƒç´ ã€‚ç„¶åŽç”¨åŒæ ·çš„æ–¹æ³•å¯¹å‰Nâˆ’1ä¸ªå…ƒç´ è¿›è¡Œç¬¬äºŒéæ‰«æã€‚ä¾æ­¤ç±»æŽ¨ï¼Œæœ€åŽåªéœ€å¤„ç†ä¸¤ä¸ªå…ƒç´ ï¼Œå°±å®Œæˆäº†å¯¹Nä¸ªæ•°çš„æŽ’åºã€‚æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„Kï¼ˆ&lt;Nï¼‰ï¼Œè¾“å‡ºæ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœæ•°åˆ—ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºNå’ŒKï¼ˆ1â‰¤K&lt;Nâ‰¤100ï¼‰ï¼Œåœ¨ç¬¬2è¡Œä¸­ç»™å‡ºNä¸ªå¾…æŽ’åºçš„æ•´æ•°ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå†’æ³¡æŽ’åºæ³•æ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœæ•°åˆ—ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†æœ«å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:6 22 3 5 1 6 4 Output:2 1 3 4 5 6 Analysisæ­¤é¢˜ä¸éš¾ï¼Œç®—æ˜¯å¸®åŠ©ç†Ÿæ‚‰å†’æ³¡æŽ’åºç®—æ³•çš„é¢˜å§ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„ç®—æ³•ï¼Œä½¿ç”¨ä¸¤å±‚å¾ªçŽ¯ï¼Œç›´æŽ¥è¿›è¡Œå¤„ç†å³å¯ã€‚æ³¨æ„ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œåœ¨äº¤æ¢ä¸¤ä¸ªç›¸é‚»çš„å…ƒç´ çš„æ—¶å€™ï¼Œåªèƒ½äº¤æ¢æ•´ä¸ªæ•°ç»„å†…çš„å…ƒç´ ã€‚å¦å¤–ï¼ŒæŒ‰ç…§ä¸‹é¢çš„ä»£ç ï¼Œå¦‚æžœä¸åŠ æ¡ä»¶j+1 &lt; Nï¼Œå°†6æŽ’åˆ°æœ€åŽé¢åŽï¼Œæ•°å­—6ä»ç„¶ä¼šå’Œå…¶ä¸‹ä¸€ä½è¿›è¡Œäº¤æ¢ã€‚æˆ–è€…ä¸åŠ æ¡ä»¶j+1 &lt; Nï¼Œå°±éœ€è¦å°†ç¬¬äºŒå±‚å¾ªçŽ¯çš„æ¡ä»¶æ”¹ä¸ºj&lt;N-i Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); int array[105]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%d", &amp;array[i]); &#125; for(i=0; i&lt;K; i++) &#123; int temp=0; for(j=0; j&lt;N; j++) /*j&lt;N -&gt; j&lt;N-i-1*/ &#123; if(array[j] &gt; array[j+1] &amp;&amp; j+1 &lt; N)&#123; /*delete the "&amp;&amp; j+1 &lt; N"*/ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; if(i == N-1) printf("%d\n", array[i]); else printf("%d ", array[i]); &#125; return 0;&#125; 7-28 çŒ´å­é€‰å¤§çŽ‹ä¸€ç¾¤çŒ´å­è¦é€‰æ–°çŒ´çŽ‹ã€‚æ–°çŒ´çŽ‹çš„é€‰æ‹©æ–¹æ³•æ˜¯ï¼šè®©Nåªå€™é€‰çŒ´å­å›´æˆä¸€åœˆï¼Œä»ŽæŸä½ç½®èµ·é¡ºåºç¼–å·ä¸º1~Nå·ã€‚ä»Žç¬¬1å·å¼€å§‹æŠ¥æ•°ï¼Œæ¯è½®ä»Ž1æŠ¥åˆ°3ï¼Œå‡¡æŠ¥åˆ°3çš„çŒ´å­å³é€€å‡ºåœˆå­ï¼ŒæŽ¥ç€åˆä»Žç´§é‚»çš„ä¸‹ä¸€åªçŒ´å­å¼€å§‹åŒæ ·çš„æŠ¥æ•°ã€‚å¦‚æ­¤ä¸æ–­å¾ªçŽ¯ï¼Œæœ€åŽå‰©ä¸‹çš„ä¸€åªçŒ´å­å°±é€‰ä¸ºçŒ´çŽ‹ã€‚è¯·é—®æ˜¯åŽŸæ¥ç¬¬å‡ å·çŒ´å­å½“é€‰çŒ´çŽ‹ï¼Ÿ Input Specificationè¾“å‡ºåœ¨ä¸€è¡Œä¸­ç»™ä¸€ä¸ªæ­£æ•´æ•°N(â‰¤1000)ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå½“é€‰çŒ´çŽ‹çš„ç¼–å·ã€‚ Sample Input &amp; Sample Output Input:11 Output:7 Analysisè¿™é“é¢˜ï¼Œå±žäºŽâ€œå¥—è·¯é¢˜â€ï¼Œå®žè´¨æ˜¯â€œçº¦ç‘Ÿå¤«çŽ¯â€é—®é¢˜ï¼›ä»¥ä¸‹çš„ä»£ç ä»‹ç»äº†ä¸‰ç§æ–¹æ³•ï¼šå›žæº¯æ³•(ä¸¥æ ¼æ„ä¹‰ä¸Šä¹Ÿè®¸ä¸æ˜¯)ã€é€’å½’å’Œè¿­ä»£ï¼Œåˆ†åˆ«å‚è€ƒäº†liuxuquan_ã€Little_Swordå’Œd4shmançš„ä»£ç ã€‚æ„Ÿè§‰ä½¿ç”¨å›žæº¯æ³•æ˜¯æœ€å®¹æ˜“ç†è§£çš„ï¼Œå¯¹äºŽä½¿ç”¨é€’å½’å’Œè¿­ä»£çš„æ–¹æ³•ï¼ŒåŽŸç†æ˜¯ä¸€æ ·çš„ï¼Œç†è§£ä¸€ç§äº†ï¼Œå¦å¤–ä¸€ç§ä¹Ÿå°±æ²¡é—®é¢˜äº†ï¼›å¥½åƒè¿˜å¯ä»¥é€šè¿‡å…¶ä»–çš„æ–¹å¼æ¥åšï¼Œè¿™é‡Œæš‚æ—¶å…ˆä¸æ·±ç©¶ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define maxn 1005int josephus_recursion(int n, int m);int main(int argc, char const *argv[])&#123; /* method 1: use backtracking int N; scanf("%d", &amp;N); // N=11; int i,monkey_array[maxn]=&#123;0&#125;; for(i=1; i&lt;=N; i++)&#123; monkey_array[i]=i; &#125; int j,k,temp; for(i=N; i&gt;=1; i--) &#123; for(j=1; j&lt;=3; j++)&#123; temp=monkey_array[1]; for(k=1; k&lt;=i; k++)&#123; monkey_array[k]=monkey_array[k+1]; &#125; monkey_array[i]=temp; &#125; &#125; printf("%d\n", monkey_array[1]); */ /* method 2: use recursion int N; N=11; if(!N) return 0; int result = josephus_recursion(N,3); printf("%d\n", result+1); */ /* method 3: use iteration*/ int i,N,result=0; scanf("%d", &amp;N); for(i=2; i&lt;=N; i++) &#123; result=(result + 3)%i; &#125; printf("%d\n", result+1); return 0;&#125;int josephus_recursion(int n, int m)&#123; if(n == 1) return 0; else return (josephus_recursion(n-1, m)+m)%n;&#125; 7-29 åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„å­ä¸²è¾“å…¥2ä¸ªå­—ç¬¦ä¸²S1å’ŒS2ï¼Œè¦æ±‚åˆ é™¤å­—ç¬¦ä¸²S1ä¸­å‡ºçŽ°çš„æ‰€æœ‰å­ä¸²S2ï¼Œå³ç»“æžœå­—ç¬¦ä¸²ä¸­ä¸èƒ½åŒ…å«S2ã€‚ Input Specificationè¾“å…¥åœ¨2è¡Œä¸­åˆ†åˆ«ç»™å‡ºä¸è¶…è¿‡80ä¸ªå­—ç¬¦é•¿åº¦çš„ã€ä»¥å›žè½¦ç»“æŸçš„2ä¸ªéžç©ºå­—ç¬¦ä¸²ï¼Œå¯¹åº”S1å’ŒS2ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºåˆ é™¤å­—ç¬¦ä¸²S1ä¸­å‡ºçŽ°çš„æ‰€æœ‰å­ä¸²S2åŽçš„ç»“æžœå­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:Tomcat is a male ccatatcat Output:Tom is a male Analysisæœ¬é¢˜ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä¸è¿‡è¿˜æ˜¯è¦ä»”ç»†æƒ³ä¸€æƒ³ã€‚å¯¹éœ€è¦åˆ é™¤çš„å­—ç¬¦ä¸²è¿›è¡ŒéåŽ†ï¼Œæ¯”å¯¹å­—ç¬¦ä¸²åºåˆ—ï¼Œå¦‚æžœä¸æ˜¯å­ä¸²ï¼Œå°±è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªçŽ¯ï¼Œè‹¥æ˜¯å­ä¸²ï¼Œå°±å°†å­ä¸²åŽçš„å­—ç¬¦åºåˆ—å‰ç§»ï¼Œç„¶åŽä¿®æ”¹å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¹¶è®©å­—ç¬¦ä¸²æœ€åŽä¸€ä½ä¸º\0ï¼Œè¿™æ ·å°±åˆ é™¤æŽ‰äº†å­ä¸²ï¼›é‡å¤éåŽ†å³å¯åˆ é™¤æ‰€æœ‰å­ä¸²ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s1[85],s2[85]; gets(s1); gets(s2); int len1=strlen(s1),len2=strlen(s2); int i,k; for(k=0; k&lt;len1; k++) &#123; for(i=0; i&lt;len1; i++) &#123; if(s1[i] == s2[0])&#123; int temp=i,flag=1,j; for(i+=1,j=1; j&lt;len2; i++,j++) &#123; if(s1[i] != s2[j])&#123; flag=0; break; &#125; &#125; if(!flag)&#123; i=temp; &#125;else&#123; for(j=temp; i&lt;len1; j++,i++) &#123; s1[j]=s1[i]; &#125; len1=len1-len2; s1[len1]='\0'; &#125; i=temp; &#125; &#125; &#125; printf("%s\n", s1); return 0;&#125; 7-30 å­—ç¬¦ä¸²çš„å†’æ³¡æŽ’åºæˆ‘ä»¬å·²ç»çŸ¥é“äº†å°†Nä¸ªæ•´æ•°æŒ‰ä»Žå°åˆ°å¤§æŽ’åºçš„å†’æ³¡æŽ’åºæ³•ã€‚æœ¬é¢˜è¦æ±‚å°†æ­¤æ–¹æ³•ç”¨äºŽå­—ç¬¦ä¸²åºåˆ—ï¼Œå¹¶å¯¹ä»»æ„ç»™å®šçš„Kï¼ˆ&lt;Nï¼‰ï¼Œè¾“å‡ºæ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœåºåˆ—ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºNå’ŒKï¼ˆ1â‰¤K&lt;Nâ‰¤100ï¼‰ï¼Œæ­¤åŽNè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡10çš„ã€ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„éžç©ºå­—ç¬¦ä¸²ã€‚ Output Specificationè¾“å‡ºå†’æ³¡æŽ’åºæ³•æ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœåºåˆ—ï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:6 2bestcateastafreeday Output:bestacatdayeastfree Analysisæœ¬é¢˜ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä½†ä¹Ÿéœ€è¦ç»†ç»†æƒ³ä¸€æƒ³ï¼Œå¦å¤–æ„Ÿè§‰é¢˜å¹²ä¸€å¼€å§‹æ²¡è¯´æ¸…æ¥šæ€Žæ ·è®¤ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²â€œå¤§â€æˆ–â€œå°â€ï¼Œå…¶å®žå°±æ˜¯é¦–å­—æ¯åœ¨å­—æ¯è¡¨é¡ºåºæ¥å†³å®šå¤§å°ï¼Œè‹¥é¦–å­—æ¯ç›¸åŒåˆ™æ¯”è¾ƒé¦–å­—æ¯åŽçš„å­—æ¯çš„é¡ºåºï¼Œä¾æ¬¡ç±»æŽ¨ï¼›äº†è§£äº†è¿™äº›åŽï¼Œå¯ä»¥å‘çŽ°ï¼Œè¾“å…¥æ ·ä¾‹ä¸­çš„å­—ç¬¦ä¸²æž„æˆçš„åºåˆ—å°±æ˜¯2 3 5 1 6 4ï¼Œè€Œè¾“å‡ºæ ·ä¾‹çš„åºåˆ—å°±æ˜¯2 1 3 4 5 6ï¼Œè¿™ä¸ªä¸Ž7-27 å†’æ³¡æ³•æŽ’åºæ˜¯ä¸€è‡´çš„ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸»è¦æ€è·¯å…¶å®žæ˜¯åˆ©ç”¨äºŒç»´æ•°ç»„å­˜å‚¨æ¯ä¸€ä¸ªå­å­—ç¬¦ä¸²ï¼Œè¿›è¡Œæ¯”è¾ƒåŽæŽ’åºå³å¯ã€‚ä¸»è¦è¯¥æ³¨æ„çš„ç‚¹ï¼šabcdå’Œacbdè¿™ç§å‰ä¸€ä¸ªæˆ–å‡ ä¸ªå­—æ¯æ˜¯ç›¸åŒçš„å­å­—ç¬¦ä¸²çš„æ¯”è¾ƒï¼Œå·§åˆçš„æ˜¯ï¼Œstrcmpå‡½æ•°æ­£å¥½å¯ä»¥å¤„ç†è¿™æ ·çš„æƒ…å†µðŸ‘ï¼Œæ‰€ä»¥ï¼Œç›´æŽ¥ä½¿ç”¨strcmpå‡½æ•°æ¯”è¾ƒåŽï¼Œåœ¨ç”¨strcpyå‡½æ•°äº’æ¢å­—ç¬¦ä¸²å³å¯ï¼ˆç±»ä¼¼æ•´åž‹å˜é‡çš„æ¢å€¼ï¼‰ï¼›strcmpå’Œstrcpyè¿™ä¸¤ä¸ªå‡½æ•°å¯ä»¥è‡ªå·±å†™ï¼›C++å¥½åƒè‡ªå¸¦äº†åº”å¯¹è¿™ç§å­—ç¬¦ä¸²æŽ’åºéœ€æ±‚çš„å¤„ç†å‡½æ•°ï¼Œç›´æŽ¥è°ƒç”¨å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;string.h&gt;char* mycpy(char* dst, char* src);int mycmp(char const *s1, char const *s2);int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); char str[N][11]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%s", str[i]); &#125; char temp[11]; char *p=temp; for(i=1; i&lt;=K; i++) &#123; for(j=0; j&lt;N-i; j++) &#123; if(mycmp(str[j], str[j+1]) &gt; 0)&#123; mycpy(p, str[j]); mycpy(str[j], str[j+1]); mycpy(str[j+1], temp); &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; printf("%s\n", str[i]); &#125; return 0;&#125;char* mycpy(char *dst, char *src)&#123; char* ret = dst; while(*src) &#123; *dst++ = *src++; &#125; *dst = '\0'; return ret;&#125;int mycmp(char const *s1, char const *s2)&#123; while(*s1 == *s2 &amp;&amp; *s1 != '\0') &#123; s1++; s2++; &#125; return *s1-*s2;&#125; 7-31 å­—ç¬¦ä¸²å¾ªçŽ¯å·¦ç§»è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ä¸ªéžè´Ÿæ•´æ•°Nï¼Œè¦æ±‚å°†å­—ç¬¦ä¸²å¾ªçŽ¯å·¦ç§»Næ¬¡ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡100ä¸ªå­—ç¬¦é•¿åº¦çš„ã€ä»¥å›žè½¦ç»“æŸçš„éžç©ºå­—ç¬¦ä¸²ï¼›ç¬¬2è¡Œç»™å‡ºéžè´Ÿæ•´æ•°Nã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå¾ªçŽ¯å·¦ç§»Næ¬¡åŽçš„å­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:Hello World!2 Output:llo World!He Analysisæœ¬é¢˜ä¸éš¾ï¼Œç†Ÿæ‚‰å­—ç¬¦æ•°ç»„çš„å­˜å‚¨æ–¹å¼çš„è¯åšèµ·æ¥ä¼šæ„Ÿè§‰æ¯”è¾ƒå®¹æ˜“ã€‚ä¸»è¦æ€è·¯æ˜¯æŒ‰ç…§é¢˜ç›®ç»™çš„ç§»åŠ¨æ¬¡æ•°ï¼Œå°†éœ€è¦ç§»åŠ¨çš„å­—ç¬¦æŒ‰ç§»åŠ¨é¡ºåºæ”¾åˆ°ä¸€ä¸ªæ–°çš„å­—ç¬¦æ•°ç»„å†…ï¼Œå°†åŽŸæ¥çš„å­—ç¬¦æ•°ç»„çš„å‰©ä½™å­—ç¬¦å‰ç§»ï¼Œç„¶åŽå†å°†æ–°çš„å­—ç¬¦æ•°ç»„å†…çš„å­—ç¬¦å¤åˆ¶å›žè€çš„å­—ç¬¦æ•°ç»„å†…å³å¯ã€‚æ³¨æ„å½“ç§»åŠ¨çš„æ¬¡æ•°å¤§äºŽå­—ç¬¦ä¸²çš„é•¿åº¦æ—¶ï¼Œè¦å–ä½™å¤„ç†ï¼Œæ¯”å¦‚ï¼Œå­—ç¬¦ä¸²é•¿åº¦ä¸º5ï¼Œè¦ç§»åŠ¨9æ¬¡ï¼Œå®žé™…ä¸Šç§»åŠ¨çš„æ¬¡æ•°å°±æ˜¯9%5=4ã€‚ä¹Ÿå¯ä»¥åªä½¿ç”¨ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œå…ˆè¾“å‡ºç§»åŠ¨åŽçš„åŽåŠæ®µå­—ç¬¦ï¼Œåœ¨è¾“å‡ºå‰åŠæ®µå­—ç¬¦ï¼Œæœ€åŽæ¢è¡Œå³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int mylen(char const *s1);int main(int argc, char const *argv[])&#123; char str1[105]; char str2[105]; gets(str1); int N,i=1; scanf("%d", &amp;N); char* p=str1; char* q=str2; int len=mylen(p); for(p+=(N%len); *p != '\0'; p++, q++) &#123; *q=*p; &#125; p=str1; for(i=1; i&lt;=(N%len); i++, p++, q++) &#123; *q=*p; &#125; *q='\0'; printf("%s\n", str2); /* method 2: use one char_array int i=0,len=mylen(str); char* p=str; printf("%s", p+(N%len); p=str; for(; i&lt;(N%len); i++,p++) &#123; printf("%c", *p); &#125; printf("\n"); */ return 0;&#125;int mylen(char const *s1)&#123; int len=0; while(*s1) &#123; s1++; len++; &#125; return len;&#125; 7-32 è¯´åè¯-åŠ å¼ºç‰ˆç»™å®šä¸€å¥è‹±è¯­ï¼Œè¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œå°†å¥ä¸­æ‰€æœ‰å•è¯çš„é¡ºåºé¢ å€’è¾“å‡ºã€‚ Input Specificationæµ‹è¯•è¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œå†…ç»™å‡ºæ€»é•¿åº¦ä¸è¶…è¿‡500000çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²ç”±è‹¥å¹²å•è¯å’Œè‹¥å¹²ç©ºæ ¼ç»„æˆï¼Œå…¶ä¸­å•è¯æ˜¯ç”±è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å†™æœ‰åŒºåˆ†ï¼‰ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå•è¯ä¹‹é—´ç”¨è‹¥å¹²ä¸ªç©ºæ ¼åˆ†å¼€ã€‚ Output Specificationæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼Œè¾“å‡ºå€’åºåŽçš„å¥å­ï¼Œå¹¶ä¸”ä¿è¯å•è¯é—´åªæœ‰1ä¸ªç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:Hello World Here I Come Output:Come I Here World Hello Analysisæœ¬é¢˜æœ¬è´¨ä¸Šè€Œè¨€ï¼Œä¸æ˜¯ç‰¹åˆ«çš„å¤æ‚ï¼Œä½†ä¹Ÿéœ€è¦ä»”ç»†åŽ»ç¢ç£¨ä¸€äº›ç»†èŠ‚ï¼Œä»¥ä¸‹çš„ä»£ç å‚è€ƒäº†qq_37729102çš„ä»£ç ï¼Œä¸”æ–‡ç« ä¹‹å†…åšäº†å¾ˆå¤šç»†èŠ‚è¯´æ˜Žï¼›å¤§è‡´çš„æ€è·¯ï¼Œå°±æ˜¯ä»ŽåŽå¾€å‰éåŽ†å­—ç¬¦ä¸²ï¼Œç©ºæ ¼è·³è¿‡ï¼Œæ‰«æåˆ°éžå­—ç¬¦æ—¶ï¼Œè®°å½•å­—ç¬¦çš„ä¸ªæ•°(å…¶å®žå°±æ˜¯å•è¯çš„é•¿åº¦äº†)ï¼Œæ¯æ‰«æåˆ°ä¸‹ä¸€ä¸ªç©ºæ ¼çš„æ—¶å€™ï¼Œå°±è¾“å‡ºå‰ä¸€ä¸ªå•è¯å³å¯ã€‚ç”±äºŽç¬¬ä¸€ä¸ªå•è¯æ¯”è¾ƒç‰¹æ®Šï¼Œå¦‚æžœä¾ç„¶é‡‡å–ä»ŽåŽéåŽ†çš„æ–¹æ³•åŽ»è¾“å‡ºç¬¬ä¸€ä¸ªå•è¯ï¼Œè¿™æ ·å°±æ— æ³•ä¿è¯ä¸Žé¢˜ç›®æ ¼å¼çš„ä¸€è‡´(æ¢è¡Œç¬¦)ï¼Œæ‰€ä»¥éœ€è¦å…ˆè®°å½•ç¬¬ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯åœ¨å­—ç¬¦æ•°ç»„ä¸­çš„ä¸‹æ ‡ï¼Œæ­¤æ—¶ï¼Œè‹¥ç¬¬ä¸€ä¸ªå•è¯çš„å‰é¢å­˜åœ¨ç©ºæ ¼ï¼Œè·³è¿‡ï¼Œè‹¥æ²¡æœ‰ç©ºæ ¼ï¼Œé‚£ä¹ˆå¾ªçŽ¯å˜é‡ä¸º0åŽå°±è‡ªåŠ¨è·³å‡ºå¾ªçŽ¯äº†ï¼Œç´§æŽ¥ç€ï¼Œå†è¾“å‡ºç¬¬ä¸€ä¸ªå•è¯å°±å¯ä»¥äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 500005int main(int argc, char const *argv[])&#123; char str[maxn]; gets(str); int len=strlen(str); int i,j=0,char_cnt=0,next_flag=1,last_flag=1; for(i=0; i&lt;len; i++) &#123; if(str[i] != ' ')&#123; last_flag=i; break; &#125; &#125; for(i=len-1; i&gt;=0; i--) &#123; if(str[i] != ' ')&#123; next_flag=0; char_cnt++; &#125;else if(!next_flag)&#123; next_flag=1; for(j=i+1; j&lt;i+1+char_cnt; j++) &#123; printf("%c", str[j]); &#125; if(i+1 != last_flag) printf(" "); char_cnt=0; &#125; &#125; for(i=last_flag; i&lt;last_flag+char_cnt; i++) &#123; printf("%c", str[i]); &#125; printf("\n"); return 0;&#125; 7-33 æœ‰ç†æ•°åŠ æ³•æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—ä¸¤ä¸ªæœ‰ç†æ•°çš„å’Œã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§a1/b1å’Œa2/b2çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å½¢èŒƒå›´å†…çš„æ­£æ•´æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§a/bçš„æ ¼å¼è¾“å‡ºä¸¤ä¸ªæœ‰ç†æ•°çš„å’Œã€‚æ³¨æ„å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€åˆ†æ•°å½¢å¼ï¼Œè‹¥åˆ†æ¯ä¸º1ï¼Œåˆ™åªè¾“å‡ºåˆ†å­ã€‚ Sample Input &amp; Sample Output Input 1:1/3 1/6 Output 2:1/2 Input 3:4/3 2/3 Output 4:2 Analysisæœ¬é¢˜ç®—æ˜¯7-24 çº¦åˆ†æœ€ç®€åˆ†å¼çš„å‡çº§ç‰ˆäº†ï¼Œé¢˜ç›®ä¸éš¾ï¼ŒæŒ‰ç…§åŸºæœ¬è®¡ç®—è§„åˆ™è¿›è¡Œçº¦åˆ†å³å¯ï¼Œå®žè´¨ä¸Šæ˜¯å¯¹æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°çš„ç†è§£ã€åº”ç”¨å’Œè®¡ç®—å§ã€‚ Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int a1,b1,a2,b2; scanf("%d/%d %d/%d", &amp;a1, &amp;b1, &amp;a2, &amp;b2); int member,denominator,LCM,GCD; LCM=lcm(b1, b2); member=a1*LCM/b1 + a2*LCM/b2; denominator=LCM; GCD=gcd(member, denominator); if(denominator/GCD == 1)&#123; printf("%d\n", member/GCD); &#125;else&#123; printf("%d/%d\n", member/GCD, denominator/GCD); &#125; return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a);&#125;int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-34 é€šè®¯å½•çš„å½•å…¥ä¸Žæ˜¾ç¤ºé€šè®¯å½•ä¸­çš„ä¸€æ¡è®°å½•åŒ…å«ä¸‹è¿°åŸºæœ¬ä¿¡æ¯ï¼šæœ‹å‹çš„å§“åã€å‡ºç”Ÿæ—¥æœŸã€æ€§åˆ«ã€å›ºå®šç”µè¯å·ç ã€ç§»åŠ¨ç”µè¯å·ç ã€‚ æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œå½•å…¥Næ¡è®°å½•ï¼Œå¹¶ä¸”æ ¹æ®è¦æ±‚æ˜¾ç¤ºä»»æ„æŸæ¡è®°å½•ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤10ï¼‰ï¼›éšåŽNè¡Œï¼Œæ¯è¡ŒæŒ‰ç…§æ ¼å¼å§“å ç”Ÿæ—¥ æ€§åˆ« å›ºè¯ æ‰‹æœºç»™å‡ºä¸€æ¡è®°å½•ã€‚å…¶ä¸­å§“åæ˜¯ä¸è¶…è¿‡10ä¸ªå­—ç¬¦ã€ä¸åŒ…å«ç©ºæ ¼çš„éžç©ºå­—ç¬¦ä¸²ï¼›ç”Ÿæ—¥æŒ‰yyyy/mm/ddçš„æ ¼å¼ç»™å‡ºå¹´æœˆæ—¥ï¼›æ€§åˆ«ç”¨Mè¡¨ç¤ºâ€œç”·â€ã€Fè¡¨ç¤ºâ€œå¥³â€ï¼›å›ºè¯å’Œæ‰‹æœºå‡ä¸ºä¸è¶…è¿‡15ä½çš„è¿žç»­æ•°å­—ï¼Œå‰é¢æœ‰å¯èƒ½å‡ºçŽ°+ã€‚åœ¨é€šè®¯å½•è®°å½•è¾“å…¥å®ŒæˆåŽï¼Œæœ€åŽä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Kï¼Œå¹¶ä¸”éšåŽç»™å‡ºKä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¦æŸ¥è¯¢çš„è®°å½•ç¼–å·ï¼ˆä»Ž0åˆ°Nâˆ’1é¡ºåºç¼–å·ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationå¯¹æ¯ä¸€æ¡è¦æŸ¥è¯¢çš„è®°å½•ç¼–å·ï¼Œåœ¨ä¸€è¡Œä¸­æŒ‰ç…§å§“å å›ºè¯ æ‰‹æœº æ€§åˆ« ç”Ÿæ—¥çš„æ ¼å¼è¾“å‡ºè¯¥è®°å½•ã€‚è‹¥è¦æŸ¥è¯¢çš„è®°å½•ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡ºNot Foundã€‚ Sample Input &amp; Sample Output Input:3Chris 1984/03/10 F +86181779452 13707010007LaoLao 1967/11/30 F 057187951100 +8618618623333QiaoLin 1980/01/01 M 84172333 100862 1 7 Output:LaoLao 057187951100 +8618618623333 F 1967/11/30Not Found Analysisæœ¬é¢˜ä¸éš¾ï¼Œæ¯”è¾ƒç›´æŽ¥ï¼›ç›´æŽ¥ç”¨ç»“æž„ä½“æž„é€ å‡ºæ¥ä¿å­˜é€šè®¯å½•çš„æ•°æ®ç»“æž„å³å¯ï¼Œç„¶åŽå†ä»Žè¿™ä»½é€šè®¯å½•å†…åˆ†åˆ«æŒ‰é¡ºåºè¾“å‡ºéœ€è¦çš„ä¿¡æ¯å³å¯ã€‚å…¶å®žç”¨äºŒç»´æ•°ç»„åº”è¯¥ä¹Ÿå¯ä»¥è¾¾åˆ°è¿™æ ·çš„æ•ˆæžœï¼Œå¦å¤–ï¼Œå¯¹äºŽç”Ÿæ—¥è¿™æ¡è®°å½•ï¼Œç›´æŽ¥ç”¨å­—ç¬¦ä¸²å­˜å‚¨æ¯”è¾ƒæ–¹ä¾¿ã€‚ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;typedef struct address_list&#123; char name[12]; char brith[12]; char gender; char landline[18]; char phone[18];&#125;address_list;int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); address_list list[N]; for(i=0; i&lt;N; i++) &#123; scanf("%s %s %c %s %s", list[i].name, list[i].brith, &amp;list[i].gender, list[i].landline, list[i].phone); getchar(); &#125; int K,j; scanf("%d", &amp;K); for(i=1; i&lt;=K; i++) &#123; int j,check_num=0,flag=0; scanf("%d", &amp;check_num); for(j=0; j&lt;N; j++) &#123; if(j == check_num)&#123; printf("%s %s %s %c %s\n", list[j].name, list[j].landline, list[j].phone, list[j].gender, list[j].brith); flag=1; &#125; &#125; if(!flag) printf("Not Found\n"); &#125; return 0;&#125; 7-35 æœ‰ç†æ•°å‡å€¼æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—Nä¸ªæœ‰ç†æ•°çš„å¹³å‡å€¼ã€‚ Input Specificationè¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤100ï¼‰ï¼›ç¬¬äºŒè¡Œä¸­æŒ‰ç…§a1/b1 a2/b2 â€¦çš„æ ¼å¼ç»™å‡ºNä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å½¢èŒƒå›´å†…çš„æ•´æ•°ï¼›å¦‚æžœæ˜¯è´Ÿæ•°ï¼Œåˆ™è´Ÿå·ä¸€å®šå‡ºçŽ°åœ¨æœ€å‰é¢ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§a/bçš„æ ¼å¼è¾“å‡ºNä¸ªæœ‰ç†æ•°çš„å¹³å‡å€¼ã€‚æ³¨æ„å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€åˆ†æ•°å½¢å¼ï¼Œè‹¥åˆ†æ¯ä¸º1ï¼Œåˆ™åªè¾“å‡ºåˆ†å­ã€‚ Sample Input &amp; Sample Output Input 1:41/2 1/6 3/6 -5/10 Output 1:1/6 Input 2:24/3 2/3 Output 2:1 Analysisæœ¬é¢˜ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œä¸è¿‡å¤§è‡´æ€è·¯è¿˜ç®—ç®€å•ï¼›ä¸»è¦çš„æ€è·¯å°±æ˜¯ä¾æ¬¡å°†è¾“å…¥çš„åˆ†å¼ç›¸åŠ ï¼Œç„¶åŽé™¤ä»¥æ•°é‡å³å¯å¾—åˆ°å‡å€¼äº†ã€‚ç”±äºŽé¢˜ç›®ä¼šç»™è¾“å…¥çš„åˆ†å¼çš„æ•°ç›®ï¼Œæ‰€ä»¥å¯ä»¥æå‰å®šä¹‰å¥½å­˜å‚¨ç»“æž„ï¼Œç„¶åŽåœ¨è¿›è¡Œè¿ç®—ï¼›æ³¨æ„æ¯æ¬¡è¿ç®—å®Œä¹‹åŽéœ€è¦å¯¹åˆ†å­åˆ†æ¯è¿›è¡ŒåŒ–ç®€ï¼Œæ¯æ¬¡è®¡ç®—å¾—åˆ°çš„åˆ†å­memberå’Œåˆ†æ¯denominatoréœ€è¦ä½¿ç”¨long longçš„ç±»åž‹æ¥å®šä¹‰ï¼Œå¦åˆ™ä¼šè¶…å‡ºèŒƒå›´ã€‚åˆ†å¼çš„åŒ–ç®€å’Œç›¸åŠ ä¸»è¦ä¾æ®æœ€å°å…¬å€æ•°å’Œæœ€å¤§å…¬çº¦æ•°æ¥å®Œæˆï¼Œæœ€å¤§å…¬çº¦æ•°å¯ä»¥ä½¿ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œæœ€å°å…¬å€æ•°å³ä¸ºä¸¤ä¸ªæ•°çš„ä¹˜ç§¯é™¤ä»¥ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;typedef struct Fraction&#123; int a; int b;&#125;fraction;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); fraction fra[N]; for(i=0; i&lt;N; i++) &#123; scanf("%d/%d", &amp;fra[i].a, &amp;fra[i].b); &#125; int GCD=0, LCM=0; long long member=fra[0].a, denominator=fra[0].b; for(i=1; i&lt;N; i++) &#123; GCD=gcd(denominator, fra[i].b); LCM=denominator*fra[i].b/GCD; member=member*LCM/denominator + fra[i].a*LCM/fra[i].b; denominator=LCM; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; &#125; denominator*=N; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; if(denominator == 1) printf("%ld\n", member); else printf("%ld/%ld\n", member, denominator); return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a); &#125; int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-36 å¤æ•°å››åˆ™è¿ç®—æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—2ä¸ªå¤æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§a1ã€b1ã€a2ã€b2çš„æ ¼å¼ç»™å‡º2ä¸ªå¤æ•°C1=a1+b1iå’ŒC2=a2+b2içš„å®žéƒ¨å’Œè™šéƒ¨ã€‚é¢˜ç›®ä¿è¯C2ä¸ä¸º0ã€‚ Output Specificationåˆ†åˆ«åœ¨4è¡Œä¸­æŒ‰ç…§(a1+b1i) è¿ç®—ç¬¦ (a2+b2i) = ç»“æžœçš„æ ¼å¼é¡ºåºè¾“å‡º2ä¸ªå¤æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ï¼Œæ•°å­—ç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ1ä½ã€‚å¦‚æžœç»“æžœçš„å®žéƒ¨æˆ–è€…è™šéƒ¨ä¸º0ï¼Œåˆ™ä¸è¾“å‡ºã€‚å¦‚æžœç»“æžœä¸º0ï¼Œåˆ™è¾“å‡º0.0ã€‚ Sample Input &amp; Sample Output Input 1:2 3.08 -2.04 5.06 Output 1:(2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i Input 2:1 1 -1 -1.01 Output 2:(1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 Analysisæœ¬é¢˜çš„è®¡ç®—æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œæ³¨æ„å¤æ•°çš„*å’Œ/è¿ç®—å³å¯ï¼›æ­¤é¢˜æ¯”è¾ƒéº»çƒ¦çš„åœ°æ–¹åœ¨äºŽæŽ§åˆ¶è¾“å‡ºçš„æ ¼å¼ï¼Œç”±äºŽå­˜åœ¨å®žéƒ¨å’Œè™šéƒ¨ï¼Œæ‰€ä»¥éœ€è¦åˆ†å¤šç§æƒ…å†µï¼Œè¿™ä¸ªå°±éœ€è¦æ³¨æ„ç»†èŠ‚äº†ã€‚è‹¥ç”¨realä»£è¡¨å®žéƒ¨ï¼Œç”¨imaginaryä»£è¡¨è™šéƒ¨ï¼Œå°±å¯ä»¥å¾—åˆ°ä»¥ä¸‹å‡ ç§æƒ…å†µï¼šreal==0, imaginary==0ã€real==0, imaginary&gt;0ã€real==0, imaginary &lt; 0ã€real!=0, imaginary&gt;0ã€real!=0, imaginary&lt;0å’Œreal!=0, imaginary==0ï¼Œæ ¹æ®è¿™å…­ç§æƒ…å†µè¦åˆ†åˆ«è¾“å‡ºç»“æžœä¸­è™šéƒ¨å‰çš„+å’Œ-å·ï¼›ç”±äºŽè¾“å…¥çš„æ•°æ®æ˜¯å°æ•°ï¼Œåœ¨åšåˆ¤æ–­æ—¶ï¼Œå¾—è€ƒè™‘å››èˆäº”å…¥çš„æƒ…å†µï¼Œè€Œåœ¨è¾“å‡ºæ—¶ï¼Œ%lfä¼šè‡ªåŠ¨å››èˆäº”å…¥ï¼›ä¸è¦ç”¨flaotï¼Œå› ä¸ºæ•°å€¼å¯èƒ½ä¼šæœ‰æŸå¤±ï¼Œæœ€å¥½ç›´æŽ¥ç”¨doubleã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;math.h&gt;double a1,b1,a2,b2;void print_complex_number(double a, char c, double b);int main(int argc, char const *argv[])&#123; double real_part=0.0,imaginary_part=0.0; scanf("%lf %lf %lf %lf", &amp;a1, &amp;b1, &amp;a2, &amp;b2); real_part=a1 + a2; imaginary_part=b1 + b2; print_complex_number(real_part, '+', imaginary_part); real_part=a1 - a2; imaginary_part=b1 - b2; print_complex_number(real_part, '-', imaginary_part); real_part=a1*a2 - b1*b2; imaginary_part=a2*b1 + a1*b2; print_complex_number(real_part, '*', imaginary_part); real_part=(a1*a2 + b1*b2) / (a2*a2 + b2*b2); imaginary_part=(a2*b1 - a1*b2) / (a2*a2 + b2*b2); print_complex_number(real_part, '/', imaginary_part); return 0;&#125;void print_complex_number(double a, char c, double b)&#123; if(b1 &gt;= 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &gt;= 0 &amp;&amp; b2 &lt; 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &lt; 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else&#123; printf("(%.1lf%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125; if(fabs(a) &lt; 0.1 &amp;&amp; fabs(b) &lt; 0.1)&#123; printf("0.0\n"); return; &#125; int flag=0; if(fabs(a) &gt;= 0.1)&#123; printf("%.1lf", a); flag++; &#125; if(fabs(b) &gt;= 0.1)&#123; if(flag &amp;&amp; b &gt; 0.0)&#123; printf("+%.1lfi", b); &#125;else&#123; printf("%.1lfi", b); &#125; &#125; printf("\n");&#125; 7-37 æ•´æ•°åˆ†è§£ä¸ºè‹¥å¹²é¡¹ä¹‹å’Œå°†ä¸€ä¸ªæ­£æ•´æ•°Nåˆ†è§£æˆå‡ ä¸ªæ­£æ•´æ•°ç›¸åŠ ï¼Œå¯ä»¥æœ‰å¤šç§åˆ†è§£æ–¹æ³•ï¼Œä¾‹å¦‚7=6+1ï¼Œ7=5+2ï¼Œ7=5+1+1ï¼Œâ€¦ã€‚ç¼–ç¨‹æ±‚å‡ºæ­£æ•´æ•°Nçš„æ‰€æœ‰æ•´æ•°åˆ†è§£å¼å­ã€‚ Input Specificationæ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³æ­£æ•´æ•°N (0&lt;Nâ‰¤30)ã€‚ Output SpecificationæŒ‰é€’å¢žé¡ºåºè¾“å‡º$N$çš„æ‰€æœ‰æ•´æ•°åˆ†è§£å¼å­ã€‚é€’å¢žé¡ºåºæ˜¯æŒ‡ï¼šå¯¹äºŽä¸¤ä¸ªåˆ†è§£åºåˆ—$N_1={n_1,n_2,â‹¯}$å’Œ$N_2={m_1,m_2,â‹¯}$ï¼Œè‹¥å­˜åœ¨$i$ä½¿å¾—$n_1=m_1,â‹¯,n_i=m_i$ï¼Œä½†æ˜¯$n_{i+1} &lt; m_{i+1}$,åˆ™$N_1$åºåˆ—å¿…å®šåœ¨$N_2$åºåˆ—ä¹‹å‰è¾“å‡ºã€‚æ¯ä¸ªå¼å­ç”±å°åˆ°å¤§ç›¸åŠ ï¼Œå¼å­é—´ç”¨åˆ†å·éš”å¼€ï¼Œä¸”æ¯è¾“å‡º4ä¸ªå¼å­åŽæ¢è¡Œã€‚ Sample Input &amp; Sample Output Input:7 Output:7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 Analysisä»¥ä¸‹ä»£ç å‚è€ƒäº†æ–‡ä¹‹çš„ä»£ç ï¼›é¢˜ç›®å…¶å®žä¸éš¾ï¼Œä¹Ÿç®—æ˜¯â€œå¥—è·¯é¢˜â€çš„ä¸€ç§ï¼Œé‡‡ç”¨äº†æ·±åº¦ä¼˜å…ˆå’Œé€’å½’çš„æ€æƒ³ï¼›æ–‡ä¹‹åšæ–‡å†…ç»†èŠ‚è¯´çš„å¾ˆæ¸…æ¥šï¼Œè¿™é‡Œæš‚æ—¶å…ˆä¸è®¨è®ºï¼ˆå…¶å®žæ˜¯è‡ªå·±çœ‹çš„ä¼¼æ‡‚éžæ‡‚ðŸ˜ï¼‰ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;void division(int i);int N;int s[31];int top=-1;int cnt=0;int sum=0;int main(int argc, char const *argv[])&#123; scanf("%d", &amp;N); division(1); return 0;&#125;void division(int i)&#123; if(sum == N)&#123; cnt++; printf("%d=", N); int k; for(k=0; k&lt;top; k++) &#123; printf("%d+", s[k]); &#125; if(cnt%4 == 0 || s[top] == N)&#123; printf("%d\n", s[top]); &#125;else&#123; printf("%d;", s[top]); &#125; return ; &#125; if(sum &gt; N)&#123; return ; &#125; int j; for(j=i; j&lt;=N; j++) &#123; s[++top]=j; sum+=j; division(j); sum-=j; top--; &#125;&#125; 7-38 æ•°åˆ—æ±‚å’Œ-åŠ å¼ºç‰ˆç»™å®šæŸæ•°å­—$Aï¼ˆ1â‰¤Aâ‰¤9ï¼‰$ä»¥åŠéžè´Ÿæ•´æ•°$Nï¼ˆ0â‰¤Nâ‰¤100000ï¼‰$ï¼Œæ±‚æ•°åˆ—ä¹‹å’Œ$S=A+AA+AAA+â‹¯+AAâ‹¯Aï¼ˆNä¸ªAï¼‰$ã€‚ä¾‹å¦‚$A=1, N=3$æ—¶ï¼Œ$S=1+11+111=123$ã€‚ Input Specificationè¾“å…¥æ•°å­—$A$ä¸Žéžè´Ÿæ•´æ•°$N$ã€‚ Output Specificationè¾“å‡ºå…¶$N$é¡¹æ•°åˆ—ä¹‹å’Œ$S$çš„å€¼ã€‚ Sample Input &amp; Sample Output Input:1 3 Output:123 Analysisè¿™é“é¢˜ï¼Œä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œå…¶å®žè¿™ç§ç±»åž‹çš„é¢˜ç›®å¤§ä½“ä¸Šç®—ï¼Œå¤§æ¦‚åˆä¸¤ç§æ–¹æ³•åŽ»è§£å†³ï¼›é¦–å…ˆæ˜¯æ¯”è¾ƒç›´æŽ¥çš„å°±æ˜¯åˆ©ç”¨æ•°ç»„åŽ»æ¨¡æ‹Ÿæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ï¼Œå…¶å®žè´¨æ˜¯ç”¨æ•°ç»„è¿›è¡ŒåŸºæœ¬å››åˆ™è¿ç®—ï¼›å¦å¤–ä¸€ç§æ–¹æ³•å°±æ˜¯æ•°å­¦ï¼Œæ¯ä¸€æ¬¡æ•°ä½çš„ç›¸åŠ ï¼Œå…¶å®žæ˜¯(A*(N-i) + carryï¼Œå…¶ä¸­Aæ˜¯æ•°ä½å€¼ï¼Œ(N-i)æ˜¯æ•°ä½ä¸Šçš„åŠ çš„æ¬¡æ•°ï¼Œcarryæ˜¯è¿›ä½å€¼ï¼Œæ‰€ä»¥(A*(N-i) + carryçš„ç»“æžœå–ä½™åŽæ‰æ˜¯è¿™ä¸ªæ•°ä½çœŸæ­£çš„å€¼ã€‚ä¸‹é¢çš„ä»£ç ä¸­åˆ†åˆ«ç»™å‡ºäº†ç”¨æ•°ç»„æ¨¡æ‹Ÿçš„æ–¹æ³•å’Œæ•°å­¦æ–¹æ³•ï¼Œä¸”æ•°å­¦æ–¹æ³•ç†è§£èµ·æ¥ä¸éš¾ï¼Œè¦èƒ½æƒ³åˆ°è¿™æ ·åŽ»è§£å†³çš„è¯ï¼Œè¿˜éœ€è¦ç§¯ç´¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#define maxn 100002int main(int argc, char const *argv[])&#123; /* method 1: use the array do analog computation, but Time Limit Exceeded int A,N,sum[maxn],num[maxn]; // scanf("%d %d", &amp;A, &amp;N); A=1, N=3; if(N == 0)&#123; printf("0\n"); &#125;else if(N == 1)&#123; printf("%d\n", A); &#125;else&#123; int i,j,temp,len,flag=0,carry=0; for(i=1; i&lt;=N; i++) &#123; num[i]=A; &#125; while(N) &#123; carry=0; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=A; &#125; for(i=1; i&lt;=N-1; i++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; for(j=i; j&lt;=N; j++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; while(carry) &#123; num[j++] = carry%10; carry/=10; len = j; flag = 1; &#125; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=0; &#125; N--; if(N == 1) break; &#125; if(flag)&#123; for(i=len; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=j; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; return 0; */ /* method 2: use the '%' */ int num[maxn]=&#123;0&#125;,i,j,carry,flag,A,N; scanf("%d%d", &amp;A, &amp;N); // A=9, N=4; if(N == 0) printf("0\n"); else if(N == 1) printf("%d\n", A); else&#123; carry=0, flag=0; for(i=0; i&lt;N; i++) &#123; num[i] = (A*(N-i) + carry)%10; carry = (A*(N-i) + carry)/10; &#125; while(carry) &#123; num[i++] = carry%10; carry = carry/10; flag = 1; &#125; if(flag == 1)&#123; for(i=N; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=N-1; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; &#125; Code-Completion6-1 ç®€å•è¾“å‡ºæ•´æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œå¯¹ç»™å®šçš„æ­£æ•´æ•°Nï¼Œæ‰“å°ä»Ž1åˆ°Nçš„å…¨éƒ¨æ­£æ•´æ•°ã€‚ Function interface definitionvoid PrintN ( int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚è¯¥å‡½æ•°å¿…é¡»å°†ä»Ž1åˆ°Nçš„å…¨éƒ¨æ­£æ•´æ•°é¡ºåºæ‰“å°å‡ºæ¥ï¼Œæ¯ä¸ªæ•°å­—å 1è¡Œã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;void PrintN ( int N );int main ()&#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:3 Output:123 Analysisçƒ­èº«é¢˜ðŸ§ã€‚ Code123456void PrintN(int N)&#123; int i; for(i=1;i&lt;=N;i++)&#123; printf("%d\n",i); &#125;&#125; 6-2 å¤šé¡¹å¼æ±‚å€¼æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—é˜¶æ•°ä¸ºnï¼Œç³»æ•°ä¸ºa[0]â€¦a[n]çš„å¤šé¡¹å¼$f(x)=\sum_{i=0}^n(a[i]Ã—xi)$åœ¨xç‚¹çš„å€¼ã€‚ Function interface definitiondouble f( int n, double a[], double x );å…¶ä¸­næ˜¯å¤šé¡¹å¼çš„é˜¶æ•°ï¼Œa[]ä¸­å­˜å‚¨ç³»æ•°ï¼Œxæ˜¯ç»™å®šç‚¹ã€‚å‡½æ•°é¡»è¿”å›žå¤šé¡¹å¼f(x)çš„å€¼ã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main()&#123; int n, i; double a[MAXN], x; scanf("%d %lf", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(â€œ%lfâ€, &amp;a[i]); printf("%.1f\n", f(n, a, x)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:2 1.11 2.5 -38.7 Output:-43.1 Analysisç›´æŽ¥æŒ‰ç…§å…¬å¼æ±‚å€¼å³å¯ï¼Œæ³¨æ„ç›´æŽ¥ç®—æœ‰æµ‹è¯•ç‚¹ä¼šè¶…æ—¶ï¼Œå¯ç”¨æå–å…¬å› å¼çš„åŠžæ³•æ¥è§£å†³ã€‚ Code123456789101112double f( int n, double a[], double x ) &#123; int i; double sum=0,X=x; if(n == 0) &#123; sum=a[0]*1.0; &#125; else &#123; sum=a[n]*X + a[n-1]; for(i=n-2; i&gt;=0; i--) &#123; sum=sum*X + a[i]; &#125; &#125; return sum; 6-3 ç®€å•æ±‚å’Œæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚ç»™å®šçš„Nä¸ªæ•´æ•°çš„å’Œã€‚ Function interface definitionint Sum ( int List[], int N );å…¶ä¸­ç»™å®šæ•´æ•°å­˜æ”¾åœ¨æ•°ç»„List[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªList[]å…ƒç´ çš„å’Œã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main ()&#123; int List[MAXN], N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%d", &amp;List[i]); printf("%d\n", Sum(List, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312 34 -5 Output:41 AnalysisåŸºç¡€æ±‚å’Œï¼Œå¾ˆç®€å•ã€‚ Code123456789int Sum ( int List[], int N )&#123; int i,ret=0; for(i=0; i&lt;N; i++) &#123; ret+=list[i]; &#125; return ret;&#125; 6-4 æ±‚è‡ªå®šç±»åž‹å…ƒç´ çš„å¹³å‡æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ S[]çš„å¹³å‡å€¼ï¼Œå…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Average( ElementType S[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„S[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªS[]å…ƒç´ çš„å¹³å‡å€¼ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Average(S, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:13.77 AnalysisåŸºç¡€æ±‚å¹³å‡å€¼ï¼Œå¾ˆç®€å•ã€‚ Code12345678910ElementType Average( ElementType S[], int N )&#123; ElementType sum=0; int i=0; for(; i&lt;N; i++) &#123; sum+=S[i]; &#125; return sum/N;&#125; 6-5 æ±‚è‡ªå®šç±»åž‹å…ƒç´ çš„æœ€å¤§å€¼æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ S[]ä¸­çš„æœ€å¤§å€¼ï¼Œå…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Max( ElementType S[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„S[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªS[]å…ƒç´ ä¸­çš„æœ€å¤§å€¼ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case1234567891011121314151617#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Max(S, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:34.00 AnalysisåŸºç¡€æ±‚æœ€å¤§å€¼ï¼Œä¹Ÿå¾ˆç®€å•ã€‚ Code12345678910ElementType Max( ElementType S[], int N )&#123; int i=0; ElementType max=S[i]; for(; i&lt;N; i++) &#123; if(max &lt; S[i]) max = S[i]; &#125; return max;&#125; 6-6 æ±‚å•é“¾è¡¨ç»“ç‚¹çš„é˜¶ä¹˜å’Œæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚å•é“¾è¡¨Lç»“ç‚¹çš„é˜¶ä¹˜å’Œã€‚è¿™é‡Œé»˜è®¤æ‰€æœ‰ç»“ç‚¹çš„å€¼éžè´Ÿï¼Œä¸”é¢˜ç›®ä¿è¯ç»“æžœåœ¨intèŒƒå›´å†…ã€‚ Function interface definitionint FactorialSum( List L );å…¶ä¸­å•é“¾è¡¨Listçš„å®šä¹‰å¦‚ä¸‹ï¼š123456typedef struct Node *PtrToNode;struct Node &#123; int Data; /* å­˜å‚¨ç»“ç‚¹æ•°æ® */ PtrToNode Next; /* æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆ */&#125;;typedef PtrToNode List; /* å®šä¹‰å•é“¾è¡¨ç±»åž‹ */ Test procedure case1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* å­˜å‚¨ç»“ç‚¹æ•°æ® */ PtrToNode Next; /* æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆ */&#125;;typedef PtrToNode List; /* å®šä¹‰å•é“¾è¡¨ç±»åž‹ */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf("%d", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf("%d", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf("%d\n", FactorialSum(L)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:35 3 6 Output:846 Analysisé“¾è¡¨æ±‚é˜¶ä¹˜ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹é“¾è¡¨çš„éåŽ†æ“ä½œï¼Œå¯¹é“¾è¡¨è€Œè¨€ï¼Œæ³¨æ„åˆ¤ç©ºæ¡ä»¶å¯ä»¥å†™æˆLæˆ–è€…L-&gt;Nextã€‚ Code123456789101112131415int FactorialSum( List L )&#123; int fac_sum=0,i,fac; while(L) &#123; fac=1; for(i=1; i &lt;=L-&gt;Data ; i++) &#123; fac*=i; &#125; fac_sum+=fac; L=L-&gt;Next; &#125; return fac_sum;&#125; 6-7 ç»Ÿè®¡æŸç±»å®Œå…¨å¹³æ–¹æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä»»ä¸€ç»™å®šæ•´æ•°Næ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼šå®ƒæ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œåˆè‡³å°‘æœ‰ä¸¤ä½æ•°å­—ç›¸åŒï¼Œå¦‚144ã€676ç­‰ã€‚ Function interface definitionint IsTheNumber ( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚å¦‚æžœNæ»¡è¶³æ¡ä»¶ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0ã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf("%d %d", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf("cnt = %d\n", cnt); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:105 500 Output:cnt = 6 Analysisè¿™ä¸ªé¢˜çœ‹ç€æœ‰ç‚¹çƒ¦ï¼Œå…¶å®žä¹Ÿå¾ˆç®€å•ï¼Œå“ˆå“ˆï¼Œå‡ºé¢˜è€…ç»™å‡ºäº†#define &lt;math.h&gt;ï¼ˆæ„Ÿè°¢ï¼‰è¿™ä¸ªæ¡ä»¶åŽï¼Œå¯¹æ•°å­—çš„æ“ä½œå°±å¾ˆç®€å•äº†ï¼ˆä¸è¿‡è‡ªå·±å†™sqrtï¼Œåº”è¯¥ä¹Ÿèƒ½æžå®šðŸ˜‰ï¼‰ï¼Œæ³¨æ„sqrtè¿™ä¸ªå‡½æ•°çš„è¿”å›žç±»åž‹æ˜¯doubleï¼Œæ‰€ä»¥éœ€è¦å¼ºåˆ¶ç±»åž‹è½¬æ¢(int)sqrt(n)ï¼›çŽ°åœ¨å°±åªç”¨åŽ»åˆ¤æ–­è¿™ä¸ªæ•°ä¸­å„æ•°ä½æ•°å­—å‡ºçŽ°æ¬¡æ•°è‡³å°‘å‡ºçŽ°2æ¬¡å³å¯ã€‚æµ‹è¯•ç¨‹åºä¸­ä¼ å…¥å‡½æ•°çš„å‚é‡æ˜¯intï¼Œæ‰€ä»¥ï¼Œæ•°ç»„é•¿åº¦ç”¨11å°±å¥½äº†ã€‚ Code123456789101112131415161718int IsTheNumber ( const int N )&#123; int ret=0,digit[11]=&#123;0&#125;; if( ((int)sqrt(N)) * ((int)sqrt(N) ) == N)&#123; int i,j,temp=N; for(i=0; temp; temp/=10, i++) &#123; digit[temp%10]++; &#125; for(j=0; j&lt;10; j++)&#123; if(digit[j] &gt;= 2)&#123; ret=1; break; &#125; &#125; &#125; return ret;&#125; 6-8 ç®€å•é˜¶ä¹˜è®¡ç®—æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªè®¡ç®—éžè´Ÿæ•´æ•°é˜¶ä¹˜çš„ç®€å•å‡½æ•°ã€‚ Function interface definitionint Factorial( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ï¼Œå…¶å€¼ä¸è¶…è¿‡12ã€‚å¦‚æžœNæ˜¯éžè´Ÿæ•´æ•°ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»è¿”å›žNçš„é˜¶ä¹˜ï¼Œå¦åˆ™è¿”å›ž0ã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;int Factorial( const int N );int main()&#123; int N, NF; scanf("%d", &amp;N); NF = Factorial(N); if (NF) printf("%d! = %d\n", N, NF); else printf("Invalid input\n"); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:5 Output:5! = 120 AnalysisåŸºæœ¬é˜¶ä¹˜è®¡ç®—ï¼Œæ³¨æ„$0!=1$å³å¯ã€‚ Code12345678910111213int Factorial( const int N )&#123; int i,ret=1; if(N &lt; 0) return 0; else if(N == 0) return ret; else&#123; for(i=1; i&lt;=N; i++) &#123; ret*=i; &#125; &#125; return ret;&#125; 6-9 ç»Ÿè®¡ä¸ªä½æ•°å­—æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œå¯ç»Ÿè®¡ä»»ä¸€æ•´æ•°ä¸­æŸä¸ªä½æ•°å‡ºçŽ°çš„æ¬¡æ•°ã€‚ä¾‹å¦‚-21252ä¸­ï¼Œ2å‡ºçŽ°äº†3æ¬¡ï¼Œåˆ™è¯¥å‡½æ•°åº”è¯¥è¿”å›ž3ã€‚ Function interface definitionint Count_Digit ( const int N, const int D );å…¶ä¸­Nå’ŒDéƒ½æ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚Nçš„å€¼ä¸è¶…è¿‡intçš„èŒƒå›´ï¼›Dæ˜¯$[0, 9]$åŒºé—´å†…çš„ä¸ªä½æ•°ã€‚å‡½æ•°é¡»è¿”å›žNä¸­Då‡ºçŽ°çš„æ¬¡æ•°ã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf("%d %d", &amp;N, &amp;D); printf("%d\n", Count_Digit(N, D)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:-21252 2 Output:3 Analysisè€ƒå¯Ÿæ•°ä½æ‹†åˆ†ï¼Œæ³¨æ„å¦‚æžœæ˜¯å¤æ•°ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸ºå…¶ç»å¯¹å€¼å³å¯ã€‚ Code12345678910111213141516171819202122232425int Count_Digit ( const int N, const int D )&#123; int times=0,n; if(N &lt; 0) n = -N; else&#123; n=N; if(n == 0 &amp;&amp; D == 0)&#123; return 1; &#125; &#125; int mask=1,temp=n; do&#123; temp/=10; mask*=10; &#125;while(temp &gt; 9); temp = n; int digit; do&#123; digit = temp/mask; temp%=mask; mask/=10; if(digit == D) times++; &#125;while(mask &gt; 0); return times;&#125; 6-10 é˜¶ä¹˜è®¡ç®—å‡çº§ç‰ˆæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªæ‰“å°éžè´Ÿæ•´æ•°é˜¶ä¹˜çš„å‡½æ•°ã€‚ Function interface definitionvoid Print_Factorial ( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ï¼Œå…¶å€¼ä¸è¶…è¿‡1000ã€‚å¦‚æžœNæ˜¯éžè´Ÿæ•´æ•°ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»åœ¨ä¸€è¡Œä¸­æ‰“å°å‡º$N!$çš„å€¼ï¼Œå¦åˆ™æ‰“å°â€œInvalid inputâ€ã€‚ Test procedure case1234567891011#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main()&#123; int N; scanf("%d", &amp;N); Print_Factorial(N); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:15 Output:1307674368000 Analysiså¾ˆæ˜Žæ˜¾æ˜¯ä¸ªå¤§æ•°é—®é¢˜ï¼Œåˆ©ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿä¹˜æ³•è®¡ç®—å³å¯ï¼Œæ³¨æ„æ¯ä¸€æ¬¡è¿›ä½çš„å¤„ç†ï¼Œæ„Ÿè§‰æ•°ç»„æ¨¡æ‹Ÿä¹˜æ³•è¦æ¯”åŠ æ³•å®¹æ˜“ä¸€äº›ðŸ˜§ã€‚ Code12345678910111213141516171819202122232425262728293031void Print_Factorial ( const int N )&#123; if(N &lt; 0)&#123; printf("Invalid input\n"); &#125;else if(N == 0)&#123; printf("1\n"); &#125;else&#123; int carry=0,i,j,k=1,temp,num[3000]=&#123;0&#125;; num[0]=1; for(i=2; i&lt;=N; i++) &#123; for(j=0; j&lt;k; j++) &#123; temp = num[j]*i + carry; num[j] = temp%10; carry = temp/10; &#125; while(carry) &#123; num[k]=carry%10; carry/=10; k++; &#125; &#125; for(i=k-1; i&gt;0 ;i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;&#125; 6-11 æ±‚è‡ªå®šç±»åž‹å…ƒç´ åºåˆ—çš„ä¸­ä½æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ A[]çš„ä¸­ä½æ•°ï¼Œå³åºåˆ—ä¸­ç¬¬$âŒŠN/2+1âŒ‹$å¤§çš„å…ƒç´ ã€‚å…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Median( ElementType A[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„A[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªA[]å…ƒç´ çš„ä¸­ä½æ•°ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main ()&#123; ElementType A[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;A[i]); printf("%.2f\n", Median(A, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:12.30 Analysisæ³¨æ„é¢˜ç›®çš„æè¿°ï¼Œæ±‚çš„æ˜¯ä¸­ä½æ•°ï¼Œè€Œ$âŒŠN/2+1âŒ‹$è¿™é‡Œæ˜¯å‘ä¸‹å–æ•´å“¦ã€‚ä¹Ÿå³æ˜¯è¯´ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œè¦å…ˆç»™ä¼ å…¥å‡½æ•°çš„æ•°ç»„è¿›è¡ŒæŽ’åºï¼Œç„¶åŽå†è¾“å‡ºå…¶ä¸­ç¬¬$âŒŠN/2+1âŒ‹$å¤§çš„æ•°ï¼Œè€Œæ­¤æ—¶å¯¹äºŽæ•°ç»„ï¼ˆä»Ž0å¼€å§‹ï¼‰è€Œè¨€ä¸‹æ ‡å°±æ˜¯N/2ï¼›æ˜Žç™½è¿™ä¸ªä¹‹åŽï¼Œè¿˜æœ‰æŽ’åºçš„é—®é¢˜è¦è§£å†³ï¼Œå¦‚ä½•æŽ’åºå‘¢ï¼ŸæŽ’åºç®—æ³•å¾ˆå¤šï¼Œå†’æ³¡æŽ’åºå’Œæ’å…¥æŽ’åºéƒ½æœ‰ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹æ— æ³•é€šè¿‡ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨å¸Œå°”æŽ’åºã€‚ä¸¾ä¸ªå¸Œå°”æŽ’åºçš„ç®€å•ä¾‹å­ï¼Œå¯¹äºŽa[3]={3, 1, 2}è¿™ä¸ªåºåˆ—è€Œè¨€ï¼Œå¸Œå°”æŽ’åºä¼šæœ‰ä¸€ä¸ªå¢žé‡dï¼Œå¹¶æŒ‰ç…§è¿™ä¸ªå¢žé‡dæ¥è¿›è¡ŒæŽ’åºï¼Œdåˆå§‹åŒ–ä¸º3(ä¸ªæ•°)/2=1ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡å¸Œå°”æŽ’åºï¼Œå°±ä¼šå¯¹a[0]=3å’Œa[0+d]=2è¿™ä¸¤ä¸ªæ•°å­—è¿›è¡ŒæŽ’åºï¼Œç”±äºŽä¸å­˜åœ¨a[2]ï¼Œæ‰€ä»¥a[1]ä¸ä¼šå‚ä¸ŽæŽ’åˆ—ï¼›ç¬¬äºŒæ¬¡å¾ªçŽ¯æ—¶ï¼Œæ£€æŸ¥å·²ç»æœ‰åºå°±ä¼šè·³å‡ºå¾ªçŽ¯äº†ã€‚ Code123456789101112131415161718192021ElementType Median( ElementType A[], int N )&#123; int i,j; ElementType temp; int d; for(d=N/2; d&gt;0; d/=2) &#123; for(i=d; i&lt;N; i++) &#123; temp=A[i]; for(j=i; j&gt;=d; j-=d) &#123; if(temp &lt; A[j-d])&#123; A[j] = A[j-d]; &#125;else break; &#125; A[j]=temp; &#125; &#125; return A[N/2]; &#125; 6-12 åˆ¤æ–­å¥‡å¶æ€§æœ¬é¢˜è¦æ±‚å®žçŽ°åˆ¤æ–­ç»™å®šæ•´æ•°å¥‡å¶æ€§çš„å‡½æ•°ã€‚ Function interface definitionint even( int n );å…¶ä¸­næ˜¯ç”¨æˆ·ä¼ å…¥çš„æ•´åž‹å‚æ•°ã€‚å½“nä¸ºå¶æ•°æ—¶ï¼Œå‡½æ•°è¿”å›ž1ï¼›nä¸ºå¥‡æ•°æ—¶è¿”å›ž0ã€‚æ³¨æ„ï¼š0æ˜¯å¶æ•°ã€‚ Test procedure case123456789101112131415#include &lt;stdio.h&gt;int even( int n );int main()&#123; int n; scanf("%d", &amp;n); if (even(n)) printf("%d is even.\n", n); else printf("%d is odd.\n", n); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input 1:-6 Output 1:-6 is even. Input 2:5 Output 2:5 is odd. Analysisåˆ¤æ–­å¥‡å¶æ€§ç›´æŽ¥å¯¹2å–ä½™å°±å¥½ï¼Œå¹¶ä¸”0æ˜¯å¶æ•°ï¼Œå¦‚æžœä¸ç¡®å®šçš„è¯å¯ä»¥æ‰‹ç®—ä¸€ä¸‹ã€‚ Code1234int even(int n)&#123; if(n%2==0) return 1; else return 0;&#125; 6-13 æŠ˜åŠæŸ¥æ‰¾ç»™ä¸€ä¸ªä¸¥æ ¼é€’å¢žæ•°åˆ—ï¼Œå‡½æ•°int Search_Bin(SSTable T, KeyType k)ç”¨æ¥äºŒåˆ†åœ°æŸ¥æ‰¾kåœ¨æ•°åˆ—ä¸­çš„ä½ç½®ã€‚ Function interface definitionint Search_Bin(SSTable T, KeyType k)å…¶ä¸­Tæ˜¯æœ‰åºè¡¨ï¼Œkæ˜¯æŸ¥æ‰¾çš„å€¼ã€‚ Test procedure case123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct &#123; KeyType key; &#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable; void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) cin&gt;&gt;T.R[i].key; &#125;int Search_Bin(SSTable T, KeyType k);int main () &#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;"NOT FOUND"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125;/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */ Sample Input &amp; Sample Output Input 1:51 3 5 7 97 Output 1:4 Input 2:51 3 5 7 910 Output 2:NOT FOUND Analysisé¢˜ç›®ç»™å‡ºçš„æµ‹è¯•ç¨‹åºæ˜¯C++çš„è¯­æ³•ï¼Œä½†æ˜¯ä¹Ÿæ²¡äº‹ï¼Œæœ‰Cçš„åŠŸåº•çœ‹æ‡‚æ˜¯æ²¡æœ‰å¤ªå¤§é—®é¢˜çš„ï¼Œä¸è¿‡å®žé™…ä¸Šï¼Œå› ä¸ºï¼Œè¦å†™çš„åªæ˜¯å‡½æ•°ï¼Œå¥½åƒè·Ÿå…¶ä»–çš„å¥½åƒä¹Ÿæ²¡å•¥å…³ç³»ï¼Œä¸»è¦çœ‹æ‡‚æœ‰åºè¡¨Lçš„ç»“æž„å°±å¥½äº†ã€‚å¦ä¸€ä¸ªï¼Œå°±æ˜¯æŠ˜åŠæŸ¥æ‰¾çš„ç®—æ³•äº†ï¼Œå¤§è‡´æ€è·¯å°±æ˜¯åˆ©ç”¨å·¦æ ‡è®°å’Œå³æ ‡è®°æ¥éåŽ†æœ‰åºè¡¨ï¼Œå¦‚æžœæœ‰ç¬¦åˆæ¡ä»¶çš„å€¼å°±å¼¹å‡ºå³å¯ã€‚ Code1234567891011121314151617181920int Search_Bin(SSTable T, KeyType k)&#123; int serial_num=0,left,right=T.length,mid=1,j=1; while(j &lt;= T.length)&#123; mid=(left + right)/2; if(T.R[mid].key == k)&#123; serial_num = mid; break; &#125;else&#123; if(T.R[mid].key &lt; k)&#123; left = mid; &#125; if(T.R[mid].key &gt; k)&#123; right = mid; &#125; &#125; j++; &#125; return serial_num; &#125; Summaryè™½è¯´æ˜¯åŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†ï¼Œä½†æ˜¯æ„Ÿè§‰é‡Œé¢æœ‰äº›é¢˜ç›®è¿˜çœŸä¸æ˜¯ç‰¹åˆ«å¥½æƒ³ï¼Œå¯èƒ½æ˜¯æˆ‘æ¯”è¾ƒèœðŸ˜‚ã€‚å°½ç®¡æ¯é“é¢˜ç›®éƒ½ç»™å‡ºäº†é¢˜ç›®ã€è¾“å…¥ï¼ˆè¾“å‡ºï¼‰æ ·ä¾‹ã€è¯´æ˜Žç­‰ï¼Œå­—æ•°çœŸæ˜¯å¤šå•Šï¼Œå“ˆå“ˆï¼Œæœ‰ç‚¹æ°´æ–‡çš„å«Œç–‘ã€‚å¦å¤–ï¼Œå…³äºŽæ¯é“é¢˜ç›®çš„ACä»£ç ï¼Œå·²ç»å…¨éƒ¨è¢«ä¸Šä¼ åˆ°GitHubä¸Šäº†ï¼Œå¯ä»¥ç‚¹å‡»PTA-Basical-Programming-problem-setæ¥èŽ·å–æºæ–‡ä»¶ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¦‚ä½•ä½¿ç”¨Hexoæ­å»ºä¸ªæ€§åŒ–åšå®¢]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Introå¶ç„¶çœ‹åˆ°åˆ«äººç”¨Hexoå»ºç«‹çš„ä¸ªäººBlogï¼Œè§‰å¾—æŒºä¸é”™çš„ï¼Œç„¶åŽå°±å¼€å§‹åŠ¨æ‰‹æŠ˜è…¾äº†ã€‚è€Œæ­¤ç¯‡Blogå°±ç”¨æ¥è®°å½•è‡ªå·±å»ºç«‹è¿™ä¸ªBlogçš„æ•´ä¸ªè¿‡ç¨‹å’Œä¸€äº›ç»†èŠ‚å§ï¼Œè¿™æ ·åœ¨å‡ºçŽ°é—®é¢˜çš„æ—¶å€™å¯ä»¥åŠæ—¶æ‰¾åˆ°é—®é¢˜æ‰€åœ¨ï¼Œä¹Ÿå¯ä»¥ç»™å…¶ä»–äººä½œä¸ºå‚è€ƒï¼ŒæŒç»­æ›´æ–°ing(å·æ‡’ðŸ˜´)ã€‚ Preparationåœ¨å¼€å§‹å»ºç«‹Blogä¹‹å‰ï¼Œéœ€è¦å…ˆå®‰è£…ä¸‰æ ·ä¸œè¥¿ï¼šNode.jsã€Gitå’ŒHexoã€‚ä»¥ä¸‹è¿‡ç¨‹å‡å·²Win10ç³»ç»Ÿï¼ˆLinuxç³»ç»Ÿç±»ä¼¼ï¼‰ä¸ºå‡†ã€‚ Windowsç³»ç»Ÿçš„æ–‡ä»¶ç›®å½•åˆ†éš”ç¬¦æ˜¯\ï¼Œè€Œä¸æ˜¯Linuxé‡‡ç”¨çš„/ Node.jsNode.js æ˜¯ä¸€ä¸ªåŸºäºŽ Chrome V8 å¼•æ“Žçš„ JavaScript è¿è¡ŒçŽ¯å¢ƒã€‚Node.js ä½¿ç”¨äº†ä¸€ä¸ªäº‹ä»¶é©±åŠ¨ã€éžé˜»å¡žå¼ I/O çš„æ¨¡åž‹ï¼Œä½¿å…¶è½»é‡åˆé«˜æ•ˆã€‚ ç›´æŽ¥ç™¾åº¦æœç´¢Nodejså³å¯æ‰¾åˆ°å…¶å®˜æ–¹ä¸‹è½½é¡µé¢ï¼Œæˆ–è€…ç‚¹å‡»Node.jsï¼Œç›´æŽ¥ä¸‹è½½64ä½å®‰è£…windowså®‰è£…ç¨‹åºå³å¯ã€‚ä¸‹è½½å¥½ä¹‹åŽï¼Œç›´æŽ¥å®‰è£…å³å¯ï¼Œå¯ä»¥ä¿®æ”¹é»˜è®¤çš„å®‰è£…è·¯å¾„åˆ°ä½ è®¾å®šçš„ç£ç›˜æ–‡ä»¶å¤¹ä¸‹ã€‚ GitGit æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œå¯ä»¥æœ‰æ•ˆã€é«˜é€Ÿåœ°å¤„ç†ä»Žå¾ˆå°åˆ°éžå¸¸å¤§çš„é¡¹ç›®ç‰ˆæœ¬ç®¡ç†ã€‚ ä¸ŽNode.jsåŒæ ·ï¼Œæˆ‘ä»¬ç›´æŽ¥ç™¾åº¦æœç´¢Gitå³å¯æ‰¾åˆ°å…¶å®˜æ–¹ä¸‹è½½é¡µé¢ï¼Œä½†æ˜¯å®˜æ–¹åœ°å€çš„ä¸‹è½½é€Ÿåº¦å¾ˆæ…¢ï¼Œä¸è¿‡å¥½åœ¨Gitå¹¶ä¸å¤§ï¼Œä¸éœ€è¦å¤ªé•¿æ—¶é—´å°±å¯ä»¥ä¸‹è½½å¥½ï¼Œæˆ–è€…ç‚¹å‡»ä¸‹é¢çš„é“¾æŽ¥ï¼Œç›´æŽ¥ä¸‹è½½ã€‚64-bit Git for Windows Setup64-bit Git for Windows Portable HexoHexo æ˜¯ä¸€ä¸ªå¿«é€Ÿã€ç®€æ´ä¸”é«˜æ•ˆçš„åšå®¢æ¡†æž¶ã€‚Hexo ä½¿ç”¨ Markdownï¼ˆæˆ–å…¶ä»–æ¸²æŸ“å¼•æ“Žï¼‰è§£æžæ–‡ç« ï¼Œåœ¨å‡ ç§’å†…ï¼Œå³å¯åˆ©ç”¨é“ä¸½çš„ä¸»é¢˜ç”Ÿæˆé™æ€ç½‘é¡µã€‚ å®‰è£…Hexoæ¯”è¾ƒç®€å•ï¼Œåœ¨CMDæˆ–è€…PowerShellé”®å…¥npm install -g hexo-cliåŽè¿è¡Œå³å¯ã€‚ä»Žè¿™é‡Œå¯ä»¥çœ‹å‡ºï¼ŒHexoçš„å®‰è£…å…¶å®žæ˜¯ä¾èµ–Node.jsçš„npmæ¥è¿›è¡Œçš„ã€‚ Checkoutå®‰è£…å¥½äº†ä¹‹åŽï¼Œéœ€è¦æ£€æŸ¥æ˜¯å¦èƒ½æ­£å¸¸ä½¿ç”¨ï¼Œåœ¨CMDæˆ–PowerShellå†…è¿è¡Œä»¥ä¸‹å‘½ä»¤å³å¯ã€‚~\hexo12345678910111213141516171819202122232425node -vgit versionhexo version#å›žæ˜¾ä¿¡æ¯ä¾æ¬¡å¦‚ä¸‹ï¼šv10.15.1git version 2.20.1.windows.1hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.1v8: 6.8.275.32-node.12uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e å¦‚æžœå¾—åˆ°ç±»ä¼¼ä»¥ä¸Šçš„ç»“æžœï¼Œé‚£ä¹ˆè¯´æ˜ŽNodeã€Gitå’ŒHexoèƒ½å¤Ÿæ­£å¸¸ä½¿ç”¨ã€‚ Setupå®‰è£…å®ŒæˆHexoåŽï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å»ºç«™äº†ã€‚ Init - åˆå§‹åŒ–æ³¨ï¼šæ ¹æ®ä½ é€‰æ‹©å­˜å‚¨çš„ä½ç½®ï¼Œå¯ä»¥åœ¨ä»»æ„ç›˜ç¬¦å’Œæ–‡ä»¶å¤¹ä¸‹è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œä¸”å‡å¯åœ¨CMDæˆ–PowerShellå†…æ‰§è¡Œã€‚ Hexoåˆå§‹åŒ–çš„å‘½ä»¤ä¸ºï¼šC:\Users\test&gt; hexo init &lt;folder name&gt;ï¼Œä»¥C:\Users\testä¸ºä¾‹ï¼Œå¦‚æžœåœ¨è¿™ä¸ªè·¯å¾„æ‰§è¡Œä¸Šè¿°å‘½ä»¤åŽï¼Œä¼šåœ¨testæ–‡ä»¶å¤¹å†…ç”Ÿæˆä¸€ä¸ªåä¸ºfolder nameçš„æ–‡ä»¶å¤¹ï¼Œä¸”è¿™ä¸ªæ–‡ä»¶å¤¹å†…å­˜å‚¨ç€ä¸ŽHexoå³å°†ç”Ÿæˆçš„é™æ€é¡µé¢ç›¸å…³çš„é…ç½®æ–‡ä»¶ç­‰ã€‚ ç„¶åŽï¼Œè¿›å…¥åˆ°è¿™ä¸ªæ–‡ä»¶å¤¹cd &lt;folder name&gt;ï¼Œåœ¨æ‰§è¡Œnpm installã€‚ åˆå§‹åŒ–å®ŒæˆåŽï¼Œä¸€èˆ¬ä¼šå¼¹å‡ºæ–‡ä»¶å¤¹ä¿¡æ¯ï¼Œå¦‚ï¼š~\hexo1234567â”œâ”€â”€ _config.ymlâ”œâ”€â”€ package.jsonâ”œâ”€â”€ scaffoldsâ”œâ”€â”€ source| â”œâ”€â”€ _drafts| â””â”€â”€ _postsâ””â”€â”€ themes è¿™äº›ä¿¡æ¯å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿç†Ÿæ‚‰Hexoçš„æ–‡ä»¶ç³»ç»Ÿã€‚ åˆ°è¿™é‡Œï¼Œå¦‚æžœæ²¡æœ‰é”™è¯¯ä¿¡æ¯äº§ç”Ÿï¼ŒHexoçš„åˆå§‹åŒ–å°±ç®—å®Œæˆäº†ã€‚ Generating - ç”Ÿæˆ ä¸‹é¢æ‰€æœ‰å†…å®¹ä¸­ä»£ç å—å†…è¿è¡Œçš„å‘½ä»¤å‡æ˜¯åœ¨ä¸Šè¿°Hexoåˆå§‹åŒ–çš„æ–‡ä»¶å¤¹ä¸‹è¿è¡Œçš„ã€‚ æŽ¥ç€ä¸Šé¢çš„æ­¥éª¤ï¼Œæ‰§è¡Œå‘½ä»¤C:\Users\test\folder name&gt; hexo generateï¼Œæ­¤å‘½ä»¤å¯ä»¥ç®€å†™ä¸ºhexo gï¼Œæ‰§è¡Œå®Œè¿™æ¡å‘½ä»¤åŽï¼ŒHexoä¼šé»˜è®¤å°†source\_postæ–‡ä»¶å¤¹ä¸‹çš„.mdæ–‡ä»¶ç”Ÿæˆä¸ºé™æ€çš„.htmlæ–‡ä»¶ï¼Œå¹¶åœ¨C:\Users\test\folder nameä¸‹åˆ›å»ºä¸€ä¸ªpublicæ–‡ä»¶å¤¹ï¼Œç”¨æ¥å­˜æ”¾ç”Ÿæˆçš„é™æ€é¡µé¢æ–‡ä»¶ã€‚ Hexo èƒ½å¤Ÿç›‘è§†æ–‡ä»¶å˜åŠ¨å¹¶ç«‹å³é‡æ–°ç”Ÿæˆé™æ€æ–‡ä»¶ï¼Œåœ¨ç”Ÿæˆæ—¶ä¼šæ¯”å¯¹æ–‡ä»¶çš„ SHA1 checksumï¼Œåªæœ‰å˜åŠ¨çš„æ–‡ä»¶æ‰ä¼šå†™å…¥ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨hexo generate --watchå‘½ä»¤æ¥ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚ å½“ç„¶ï¼Œè¿˜å¯ä»¥ä¸Žéƒ¨ç½²å‘½ä»¤é…åˆä½¿ç”¨ï¼Œå¦‚ï¼š~\hexo1234567hexo generate --deployhexo deploy --generate#ä¸Šé¢çš„ä¸¤æ¡å‘½ä»¤æ˜¯ç­‰ä»·çš„#ç®€å†™hexo g -dhexo d -g Server - æœåŠ¡å™¨å½“æœåŠ¡å™¨è¿è¡Œæˆ‘ä»¬çš„ç½‘ç«™è¿›ç¨‹åŽï¼Œè¿œç¨‹çš„å®¢æˆ·ç«¯æ‰å¯ä»¥æ‰“å¼€ç½‘ç«™ã€‚ä¸‹é¢ï¼Œåœ¨ä»‹ç»Hexoä¸‹æœåŠ¡å™¨çš„ç›¸å…³å‘½ä»¤å’Œè®¾ç½®ã€‚ æŽ¥ç€ä¸Šé¢çš„æ­¥éª¤ï¼Œæ‰§è¡Œå‘½ä»¤C:\Users\test\folder name&gt; hexo serverï¼Œæ­¤å‘½ä»¤å¯ä»¥ç®€å†™ä¸ºhexo sï¼Œæ‰§è¡Œå®Œè¿™æ¡å‘½ä»¤åŽï¼ŒHexoçš„Blogé¡µé¢ä¼šè¿è¡Œåœ¨http://Localhost:4000/ï¼Œè¿™ä¸ªé¡µé¢ä¸‹ï¼Œå¯ä»¥ç›´æŽ¥åœ¨æµè§ˆå™¨å†…æ‰“å¼€ï¼Œæ‰“å¼€åŽå³å¯çœ‹åˆ°Hexoç”Ÿæˆçš„Blogä¸»é¡µé¢äº†ã€‚ æ ¹æ®Hexoå®˜ç½‘çš„è¯´æ˜Žï¼Œåœ¨ä¹‹å‰çš„Hexo 3.0ä¸­ï¼ŒHexoå°†æœåŠ¡å™¨ç‹¬ç«‹æˆäº†ä¸ªåˆ«æ¨¡å—ï¼Œéœ€è¦å…ˆå®‰è£…hexo-serveræ‰èƒ½ä½¿ç”¨ã€‚æ‰§è¡Œnpm install hexo-server --saveï¼Œç­‰å¾…å®‰è£…å®ŒæˆåŽï¼Œæ‰§è¡Œhexo så³å¯ã€‚ åœ¨æœåŠ¡å™¨å¯åŠ¨æœŸé—´ï¼ŒHexoä¼šç›‘è§†æ–‡ä»¶å˜åŠ¨å¹¶è‡ªåŠ¨æ›´æ–°ï¼Œæ— é¡»é‡å¯æœåŠ¡å™¨ã€‚æ‰€ä»¥ï¼Œåœ¨å†™Blogçš„æ—¶å€™ï¼Œå¯ä»¥ç›´æŽ¥åœ¨çº¿æŸ¥çœ‹ã€‚ æ‰§è¡Œhexo s -p &lt;port number&gt;ï¼Œå¯ä»¥å°†é¡µé¢è¿è¡Œåœ¨æŒ‡å®šçš„æœ¬åœ°ç«¯å£ã€‚è‹¥æ‰§è¡Œhexo server -i x.x.x.xï¼Œå¯ä»¥å°†é¡µé¢è¿è¡Œåœ¨æŒ‡å®šçš„IPåœ°å€ä¸Šï¼Œå°±åªèƒ½é€šè¿‡æŒ‡å®šçš„è¿™ä¸ªIPæ¥è®¿é—®ç«™ç‚¹äº†ã€‚ä¾‹å¦‚ï¼Œå¯¹äºŽä¸€å°ä½¿ç”¨æ— çº¿ç½‘ç»œçš„ç¬”è®°æœ¬ç”µè„‘ï¼Œé™¤äº†æŒ‡å‘æœ¬æœºçš„127.0.0.1å¤–ï¼Œé€šå¸¸è¿˜æœ‰ä¸€ä¸ª192.168.*.*çš„å±€åŸŸç½‘IPï¼Œå¦‚æžœåƒä¸Šé¢é‚£æ ·ä½¿ç”¨-i 192.168.*.*ä½œä¸ºå‚æ•°ï¼Œå¯èƒ½å°±ä¸èƒ½ç”¨127.0.0.1æ¥è®¿é—®ç«™ç‚¹äº†ã€‚å¯¹äºŽæœ‰å…¬ç½‘IPçš„ä¸»æœºï¼Œå¦‚æžœæ‚¨æŒ‡å®šä¸€ä¸ªå±€åŸŸç½‘IPä½œä¸º-iå‚æ•°çš„å€¼ï¼Œé‚£ä¹ˆä¹Ÿå°±æ— æ³•é€šè¿‡å…¬ç½‘æ¥è®¿é—®ç«™ç‚¹ã€‚ å¦å¤–ï¼Œåœ¨é™æ€æ¨¡å¼ä¸‹ï¼ŒæœåŠ¡å™¨åªå¤„ç†publicæ–‡ä»¶å¤¹å†…çš„æ–‡ä»¶ï¼Œè€Œä¸ä¼šå¤„ç†æ–‡ä»¶å˜åŠ¨ï¼Œåœ¨æ‰§è¡Œæ—¶ï¼Œåº”è¯¥å…ˆè‡ªè¡Œæ‰§è¡Œhexo generateï¼Œæ­¤æ¨¡å¼é€šå¸¸ç”¨äºŽç”Ÿäº§çŽ¯å¢ƒï¼ˆProduction modeï¼‰ä¸‹ã€‚ Deploymentéƒ¨ç½²éœ€è¦æŒ‡å®šgit repositoryï¼ˆä»“åº“ï¼‰ï¼Œä¸”éœ€è¦å¯¹æœ¬æœºçš„Gitè¿›è¡Œé…ç½®ã€‚ æˆ–è€…ç›´æŽ¥ä½¿ç”¨æœåŠ¡å™¨ï¼Œå¦‚æžœæœåŠ¡å™¨å­˜åœ¨å…¬ç½‘IPï¼Œé‚£ä¹ˆæ‰§è¡Œhexo såŽï¼Œå°±å¯ä»¥ç”¨æœåŠ¡å™¨çš„å…¬ç½‘IPåŽ»è®¿é—®è¿™ä¸ªç«™ç‚¹äº†ã€‚ä½†æ˜¯è¿™æ ·ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå½“å…³é—­æœåŠ¡å™¨çš„è¿œç¨‹è¿žæŽ¥ä¹‹åŽï¼Œç”¨hexo så‘½ä»¤äº§ç”Ÿçš„è¿›ç¨‹ä¼šå…³é—­ï¼Œè¿™æ ·å°±å¯¼è‡´æ— æ³•å†è®¿é—®äº†ï¼Œå¯ä»¥ä½¿ç”¨hexo s &amp;å‘½ä»¤æ¥ä½¿è¿›ç¨‹åœ¨åŽå°æŒç»­è¿è¡Œã€‚ å½“éœ€è¦å…³é—­è¿™ä¸ªè¿›ç¨‹çš„æ—¶å€™ï¼Œç»“æŸæŽ‰è¿™ä¸ªè¿™ä¸ªè¿›ç¨‹å³å¯ã€‚ Git Setting - Git é…ç½®è¿™éƒ¨åˆ†æ¶‰åŠGitçš„ç”¨æ³•ï¼Œå»ºè®®åŽ»Baiduæˆ–GoogleæŸ¥è¯¢ä¸€ä¸‹Gitçš„ç›¸å…³ä½¿ç”¨æ–¹æ³•ï¼Œè¿™é‡Œæ”¾ä¸€ä¸ªGitæ•™ç¨‹é“¾æŽ¥ï¼Œå·ç§°å²ä¸Šæœ€æµ…æ˜¾æ˜“æ‡‚çš„Gitæ•™ç¨‹ï¼Œéžå¹¿å‘Šã€‚ Sign Up - åˆ›å»ºè´¦å·è‹¥æ²¡æœ‰Githubè´¦å·ï¼Œè¯·åŽ»Githubå®˜ç½‘æ³¨å†Œä¸€ä¸ªï¼Œå¡«å†™å¥½é‚®ç®±ã€ç”¨æˆ·åå’Œå¯†ç ï¼Œé‚®ç®±éœ€è¦éªŒè¯ã€‚ Creat Repositories - åˆ›å»ºä»“åº“åˆšåˆ›å»ºå¥½çš„Githubè´¦å·ï¼Œç³»ç»Ÿä¼šé»˜è®¤å¸¦ä½ åˆ›å»ºä¸€ä¸ªrepo(repositories)ï¼Œå¯ä»¥ç›´æŽ¥åˆ›å»ºä¸€ä¸ªç»™Hexoç”¨çš„ä»“åº“ï¼Œä¹Ÿå¯ä»¥å…ˆåˆ›å»ºä¸€ä¸ªæµ‹è¯•repoæ¥ç†Ÿæ‚‰ä¸€ä¸‹åˆ›å»ºçš„æµç¨‹ã€‚ æ³¨æ„ï¼š æ–°å»ºçš„ä»“åº“åä¸ºusername.github.ioï¼Œè¿™é‡Œçš„usernameæ˜¯ä½ çš„githubè´¦å·åç§°ï¼Œè¿™æ ·Hexoéƒ¨ç½²åˆ°Githubä¸Šçš„é™æ€é¡µé¢ï¼Œå°±å¯ä»¥é€šè¿‡http://username.github.ioæ¥è¿›è¡Œè®¿é—®äº†ã€‚ githubåˆ›å»ºçš„ä»“åº“å¯èƒ½ä¸ä¼šç«‹å³ç”Ÿæ•ˆï¼Œå¯èƒ½éœ€è¦ç­‰å¾…10-30åˆ†é’Ÿã€‚ åˆ›å»ºæˆåŠŸåŽï¼Œé€šè¿‡Hexoéƒ¨ç½²çš„é™æ€é¡µé¢æ–‡ä»¶å°±æ”¾åˆ°è¿™é‡Œäº†ã€‚ SSH key - é…ç½®SSHå¯†é’¥SSHä¸ºSecure Shellçš„ç¼©å†™ï¼ŒSSHæ˜¯å»ºç«‹åœ¨åº”ç”¨å±‚åŸºç¡€ä¸Šçš„å®‰å…¨åè®®ï¼Œæ˜¯å¯é çš„ä¸“ä¸ºè¿œç¨‹ç™»å½•ä¼šè¯å’Œå…¶ä»–ç½‘ç»œæœåŠ¡æä¾›å®‰å…¨æ€§çš„åè®®ã€‚åœ¨ä½¿ç”¨githubæäº¤ä»£ç æ—¶ï¼Œéœ€è¦è´¦æˆ·æƒé™ï¼Œç›´æŽ¥ä½¿ç”¨ç”¨æˆ·åå’Œå¯†ç ä¸æ˜¯ä¸€ä¸ªå®‰å…¨çš„é€‰æ‹©ï¼Œæ­£å¥½Githubä¸Šæä¾›äº†ssh keyç›¸å…³çš„æœåŠ¡ã€‚ æ‰“å¼€Git Bashï¼Œæ‰§è¡Œ$ cd ~/.sshï¼Œè‹¥æç¤ºNo such file or directoryï¼Œè¯´æ˜Žä½ æœªä½¿ç”¨è¿‡sshã€‚è‹¥å¯ä»¥è¿›å…¥æ­¤ç›®å½•(è¿™é‡Œç”¨ç›®å½•æ˜¯å› ä¸ºä¸ŽWindowsçš„æ–‡ä»¶å¤¹æ¦‚å¿µåŒºåˆ†å¼€ï¼Œå› ä¸ºGit Bashæ˜¯Linux Shell)ï¼Œåˆ™æ‰§è¡Œlsï¼ŒæŸ¥çœ‹å½“å‰ç›®å½•ä¸‹çš„æ–‡ä»¶ï¼Œä¸€èˆ¬åªæœ‰ä¸€ä¸ªå«åšknown_hostsçš„æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶æ˜¯ä½ ç”¨sshç™»å½•è®¾å¤‡åŽç”Ÿæˆçš„ä¸€äº›å¯†é’¥ä¿¡æ¯ã€‚ ç»§ç»­åœ¨Git Bashä¸­æ‰§è¡Œssh-keygen -t rsa -C &quot;your email&quot;ï¼Œè¿™é‡Œçš„your emailæ˜¯ä½ æ³¨å†ŒGithubæ‰€ä½¿ç”¨çš„é‚®ç®±ã€‚ç„¶åŽè¿žç»­3æ¬¡å›žè½¦ï¼Œæœ€ç»ˆä¼šç”Ÿæˆä¸€ä¸ªåä¸ºid_rsa.pubçš„æ–‡ä»¶ï¼Œç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€é‡Œé¢çš„å†…å®¹åŽï¼Œå¤åˆ¶å¥½ã€‚ç„¶åŽï¼Œæ‰“å¼€ä½ çš„Githubä¸»é¡µï¼Œè¿›å…¥ä¸ªäººè®¾ç½®ï¼Œæ‰¾åˆ°SSH and GPG keysï¼Œç‚¹å‡»New SSH keyï¼Œå°†å¤åˆ¶çš„å†…å®¹ç²˜è´´åˆ°keyæ ä¸‹ï¼Œè®¾ç½®titleåŽï¼Œç‚¹å‡»Add SSH keyå³å®ŒæˆSSH keyçš„é…ç½®ã€‚ åˆ«æ€¥ï¼Œè¿˜æ²¡å®Œï¼ŒæŽ¥ç€åœ¨Git Bashä¸­è¿è¡Œssh -T git@github.comï¼Œè¿™é‡Œä¸éœ€è¦ä¿®æ”¹é‚®ç®±ï¼Œè‹¥æç¤ºä¿¡æ¯ä¸ºAre you sure you want to continue connecting (yes/no)?ï¼Œè¾“å…¥yesåŽï¼Œå°†ä¼šæç¤ºHi &#39;your github-id&#39;! You&#39;ve successfully authenticated, but Github does not provides shell access.ï¼Œæ­¤æ—¶è¯´æ˜ŽGitçš„SSH keyå·²é…ç½®æˆåŠŸï¼ ç´§æŽ¥ç€ï¼Œè¿˜éœ€è¦é…ç½®ï¼š12$ git config --global user.name "username" # your github-id$ git config --global user.email "xxx@xx.com"# your email with github ä»¥ä¸Šä¸¤æ¡å‘½ä»¤çš„ä½œç”¨æ˜¯ï¼Œå°†ä½ ä¹‹åŽçš„æ¯æ¬¡åœ¨githubä¸Šå‘èµ·çš„æäº¤éƒ½å†™å…¥è¿™äº›ä¿¡æ¯ã€‚å¯¹äºŽgitè€Œè¨€ï¼Œä½¿ç”¨äº†--globalé€‰é¡¹çš„å‘½ä»¤ï¼Œåªéœ€è¿è¡Œä¸€æ¬¡ã€‚å¦å¤–ï¼ŒGitè‡ªå¸¦çš„git configè¿˜å¯ä»¥å¸®åŠ©æˆ‘ä»¬è®¾ç½®Gitçš„å¤–è§‚å’Œè¡Œä¸ºçš„é…ç½®å˜é‡ï¼Œè¿›ä¸€æ­¥çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒGitå®˜æ–¹æ–‡æ¡£å†…å«ä¸­æ–‡ç¿»è¯‘ã€‚ Hexo Config - Hexo è®¾ç½®Hexo çš„é…ç½®æ¯”è¾ƒç®€å•ã€‚ æ‰“å¼€ç”± Hexo åˆå§‹åŒ–çš„åšå®¢æ–‡ä»¶å¤¹ï¼Œæ‰¾åˆ°_config.ymlæ–‡ä»¶ï¼Œç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€ï¼Œä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼š ~\hexo\_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: + type: git+ repo: git@github.com:username/username.github.io.git+ branch: master ä¿®æ”¹å¥½åŽï¼Œä¿å­˜å³å¯ã€‚è‹¥ä¸çŸ¥é“repoå¦‚ä½•è®¾ç½®ï¼Œè¯·å‚ç…§ä¸‹å›¾ã€‚ æŽ¥ç€ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å®‰è£…ä¸€ä¸ªæ’ä»¶æ¥ä¸ºHexoæä¾›éƒ¨ç½²åŠŸèƒ½ã€‚æ‰“å¼€ CMD ï¼Œæ‰§è¡Œnpm install hexo-deployer-git --saveï¼Œè‹¥æç¤ºPermisson denied (publickey).ï¼Œåˆ™æ‰“å¼€Git Bashå†æ¬¡æ‰§è¡Œæ­¤å‘½ä»¤å³å¯ã€‚æ³¨æ„è¿™ä¸ªæ­¥éª¤éœ€è¦åœ¨åšå®¢æœ¬åœ°çš„æ ¹ç›®å½•ä¸‹è¿›è¡Œã€‚ åœ¨éƒ¨ç½²åˆ°Github Pagesçš„è¿‡ç¨‹ä¸­ï¼Œå¿…é¡»å…ˆæ‰§è¡Œhexo gç”Ÿæˆé™æ€é¡µé¢ä¹‹åŽï¼Œæ‰å¯ä»¥æ‰§è¡Œhexo dåŽï¼Œä¼šåŒæ—¶å…ˆé»˜è®¤æ‰§è¡ŒHexo gå‘½ä»¤ï¼Œå› ä¸ºHexoéƒ¨ç½²åˆ°Github Pagesä¸Šçš„æ–‡ä»¶éœ€è¦Hexoå…ˆæœ¬åœ°ç”Ÿæˆï¼Œè€ŒHexoæœ¬åœ°ç”Ÿæˆé™æ€é¡µé¢æ—¶ï¼Œä¼šåœ¨åšå®¢æ ¹ç›®å½•ä¸‹ç”Ÿæˆåä¸ºpublicçš„æ–‡ä»¶å¤¹ï¼Œå¹¶å°†ç”Ÿæˆå¥½çš„é™æ€é¡µé¢æ–‡ä»¶å…¨éƒ¨æ”¾åˆ°è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹ï¼Œç»§è€Œå†å°†è¿™ä¸ªæ–‡ä»¶å¤¹å†…çš„æ–‡ä»¶å…¨éƒ¨éƒ¨ç½²åˆ°githubä¸Šã€‚ å»ºè®®æ¯æ¬¡åœ¨è¿è¡Œhexo dä¹‹å‰ï¼Œåšå¥½å¤‡ä»½ Personalized Customizationä¸‹é¢ä»‹ç»æœ‰å…³Hexoçš„ä¸€äº›åŸºç¡€é…ç½®ã€‚ Change Themes - ä¿®æ”¹ä¸»é¢˜Hexoé»˜è®¤çš„ä¸»é¢˜å«åšlandscapeï¼Œå¤–å½¢ä¸­è§„ä¸­çŸ©ï¼Œä½†è‚¯å®šæ»¡è¶³ä¸äº†å¤§å®¶çš„ä¸ªæ€§åŒ–éœ€æ±‚ï¼Œæ‰€ä»¥è¿˜éœ€è¦æ›´åŠ ä¸ªæ€§åŒ–çš„ä¸»é¢˜æ‰å¯ä»¥ã€‚ æ­¤Blogåº”ç”¨çš„ä¸»é¢˜ä¸ºNexTï¼Œè¿™æ¬¾ä¸»é¢˜é£Žæ ¼ç®€çº¦ï¼Œè®¾è®¡ç²¾ç¾Žï¼Œæ„Ÿè°¢ä½œè€…IIssNanã€‚ Download Themes - ä¸‹è½½ä¸»é¢˜ä¸‹è½½NexTä¸»é¢˜çš„æ–¹æ³•å¾ˆå¤šï¼ŒèŽ·å–èµ„æºçš„é€”å¾„ä¹Ÿå¾ˆå¤šï¼ŒæŽ¨èä½¿ç”¨gitæ¥å®‰è£…ã€‚- ~\hexo123&lt;!-- folder nameä¸ºä¹‹å‰Hexoç”Ÿæˆçš„æ–‡ä»¶å¤¹ --&gt;$ cd &lt;folder name&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next git clone xxxè¿™æ¡å‘½ä»¤å±žäºŽgitçš„åº”ç”¨èŒƒç•´ï¼Œæ˜¯gitçš„åŸºæœ¬æ“ä½œã€‚å¦å¤–ï¼Œtheme-nextè¿™æ¡é“¾æŽ¥å¯ä»¥ç›´æŽ¥æ‰“å¼€ï¼Œæ˜¯NexTå®˜æ–¹çš„github repoï¼Œå…¶ä¸Šä¹Ÿä»‹ç»äº†å¦‚ä½•å®‰è£…å’Œå‡çº§NexTã€‚ Enable NexT - å¯ç”¨ä¸»é¢˜å¯¹äºŽHexoè€Œè¨€ï¼Œæ‰€æœ‰çš„ä¸»é¢˜å¯ç”¨æ¨¡å¼éƒ½æ˜¯ä¸€æ ·çš„ã€‚å½“å…‹éš†/ä¸‹è½½å®ŒæˆåŽï¼Œæ‰“å¼€Hexoç”Ÿæˆç›®å½•ä¸‹çš„_config.ymlæ–‡ä»¶ï¼Œæ‰¾åˆ°themeå­—æ®µï¼Œå°†å…¶å€¼ä¿®æ”¹ä¸ºnextåŽï¼Œä¿å­˜å³å¯ã€‚~\hexo\_config.yml1theme: next ä¸€èˆ¬è€Œè¨€ï¼Œåœ¨å¯ç”¨ next ä¸»é¢˜åŽï¼Œé¡µé¢ä¼šç›´æŽ¥ä½¿ç”¨è¯¥ä¸»é¢˜ï¼Œä½†ä¸æŽ’é™¤æ„å¤–çš„æƒ…å†µï¼Œè¿™æ—¶ï¼Œå¯ä»¥ä½¿ç”¨hexo cleanæ¸…æ¥šç¼“å­˜ï¼Œå¹¶ç”¨hexo gé‡æ–°ç”Ÿæˆæ–°çš„é¡µé¢ã€‚ Checkout - éªŒè¯åœ¨CMDä¸‹ï¼Œæ‰§è¡Œhexo sï¼Œæ˜¾ç¤ºINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.åŽï¼Œæ‰“å¼€é“¾æŽ¥http://localhost:4000/ï¼Œå³å¯çœ‹åˆ°æ•ˆæžœã€‚æˆ–è€…ï¼Œå¯ä»¥æ‰§è¡Œhexo s --debugï¼Œè¿™æ ·åœ¨æœåŠ¡å¯åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æžœç”±é”™è¯¯äº§ç”Ÿï¼Œå‘½ä»¤è¡Œä¼šè‡ªåŠ¨è¾“å‡ºè¿™äº›å¼‚å¸¸ä¿¡æ¯ï¼Œæ°å·§ä½ ç¢°åˆ°é—®é¢˜çš„è¯ï¼Œè¿™äº›ä¿¡æ¯å¯ä»¥å¸®åŠ©ä»–äººæ›´å¥½çš„å®šä½é”™è¯¯ã€‚ å½“ä½ çœ‹åˆ°ä¸Žä¸‹å›¾ç±»ä¼¼çš„æ•ˆæžœæ—¶ï¼Œè¯´æ˜Žå·²ç»æˆåŠŸå®‰è£…NexTä¸»é¢˜ã€‚ NexT Basic Setting - NexT åŸºæœ¬è®¾ç½®ä¸‹é¢ä»‹ç»ä¸Žæœ‰å…³NexTçš„åŸºæœ¬è®¾ç½®ã€‚ ä¸ºæ–¹ä¾¿èµ·è§ï¼Œå°†Hexoç”Ÿæˆçš„ç›®å½•ä¸‹çš„_config_ymlç§°ä¸ºç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå°†nextä¸»é¢˜æ–‡ä»¶ç›®å½•ä¸‹çš„_config.ymlç§°ä¸ºä¸»é¢˜é…ç½®æ–‡ä»¶ Scheme - ä¸»é¢˜æ ·å¼Scheme æ˜¯ NexT æä¾›çš„ä¸€ç§ç‰¹æ€§ï¼Œå€ŸåŠ©äºŽSchemeï¼ŒNexTä¸ºä½ æä¾›å¤šç§ä¸åŒçš„å¤–è§‚ã€‚åŒæ—¶ï¼Œå‡ ä¹Žæ‰€æœ‰çš„é…ç½®éƒ½å¯ä»¥åœ¨ Scheme ä¹‹é—´å…±ç”¨ã€‚é€šè¿‡æ›´æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œå¯ä»¥è¾¾åˆ°åˆ‡æ¢Schemeçš„æ•ˆæžœã€‚åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼Œå¯ä»¥æ‰¾åˆ°å¦‚ä¸‹å†…å®¹ï¼Œå°†éœ€è¦å¯ç”¨çš„Schemeå‰çš„æ³¨é‡Š#åˆ é™¤å³å¯ã€‚~\hexo\themes\next\_config.yml12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini å…·ä½“æ•ˆæžœå¯è‡ªè¡Œå°è¯•ã€‚ Language - è¯­è¨€ç›®å‰NexTæ”¯æŒçš„è¯­è¨€æœ‰å¤šç§ï¼Œå¯åœ¨å…¶languagesæ–‡ä»¶å¤¹ä¸‹æŸ¥çœ‹ï¼Œè¿™é‡Œçš„è¯­è¨€ä¸Žé¡µé¢ä¸Šæ˜¾ç¤ºçš„é¡¹ç›®çš„è¯­è¨€ä¸€è‡´ï¼Œè®¾ç½®ä¸ºå“ªä¸€ç§è¯­è¨€ï¼Œå°±æ˜¾ç¤ºä¸ºå“ªä¸€ç§è¯­è¨€ã€‚è¯­è¨€è®¾å®šéœ€è¦åœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­è®¾ç½®ï¼Œåœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¦‚ä¸‹å†…å®¹ï¼Œå°†å…¶å€¼ä¿®æ”¹ä¸ºNexTä¸»é¢˜å¯¹åº”è¯­è¨€åç§°æ–‡ä»¶å³å¯ã€‚~\hexo folder\_config.yml1language: zh-CN language:åŽçš„å€¼å¿…é¡»è¦ä¸ŽNexTçš„è¯­è¨€æ–‡ä»¶åç§°ä¸€è‡´ï¼Œæ‰èƒ½åœ¨é¡µé¢ä¸Šç”Ÿæ•ˆ Avatar Setting - å¤´åƒè®¾ç½®ç¼–è¾‘ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°avatarè®¾ç½®éƒ¨åˆ†ï¼Œå¦‚ï¼š~\hexo\themes\next\_config.yml1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /uploads/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true å…¶ä¸­ï¼Œurlä¸ºå¤´åƒçš„å­˜æ”¾è·¯å¾„ï¼Œroundedå’Œopacityä»¥åŠrotatedä¸ºNexTä¸»é¢˜ä¸‹ä¸Žå¤´åƒç›¸å…³çš„ä¸‰ä¸ªä¸ªæ€§åŒ–åŠŸèƒ½é€‰é¡¹ï¼Œæ³¨é‡Šå†…å®¹ä¸ºè¯´æ˜Žã€‚ ä»¥ä¸Šå†…å®¹å±žäºŽNexTè‡ªå¸¦åŸºç¡€è®¾ç½®ï¼Œæ›´åŠ ä¸ªæ€§åŒ–çš„è®¾ç½®éœ€è¦ä»Žå…¶ä»–ä½ç½®è¿›è¡Œè®¾ç½® Site Information - ç«™ç‚¹ä¿¡æ¯ç«™ç‚¹ä¿¡æ¯åŒ…å«çš„å†…å®¹ä¸»è¦æœ‰æ ‡é¢˜ã€ä½œè€…ã€ä»‹ç»ç­‰ï¼Œå¯ä»¥åœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­è¿›è¡Œè®¾ç½®ã€‚ç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°å¦‚ä¸‹éƒ¨åˆ†ï¼š~\hexo\_config.yml123456title: examplesubtitle:description: author: examplelanguage: zh-CNtimezone: ä»¥ä¸Šå†…å®¹åˆ†åˆ«å¯¹åº”ï¼šæ ‡é¢˜ã€å‰¯æ ‡é¢˜ã€ä»‹ç»ã€ä½œè€…ã€è¯­è¨€ã€æ—¶åŒºï¼Œä¿®æ”¹å„ä¸ªå­—æ®µçš„å€¼ï¼Œå³å¯å®Œæˆä¿®æ”¹ã€‚ languageä¸Žä¸Šæ–‡ä¸­çš„è¯­è¨€è®¾ç½®æ˜¯ç›¸åŒçš„descriptionå­—æ®µåŽé¢çš„å€¼ä¼šè¢«æ”¾åœ¨å¤´åƒçš„ä¸‹é¢timezoneé»˜è®¤ä¸ºæœ¬æœºæ‰€åœ¨æ—¶åŒºï¼Œå¯è®¾ç½®ä¸ºå…¶ä»–æ—¶åŒº Menu Setting - èœå•è®¾ç½®èœå•é…ç½®åŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼Œç¬¬ä¸€æ˜¯èœå•é¡¹çš„æ˜¾ç¤ºæ–‡æœ¬ï¼Œç¬¬äºŒæ˜¯èœå•é¡¹çš„é“¾æŽ¥ï¼Œç¬¬ä¸‰æ˜¯èœå•é¡¹å¯¹åº”çš„å›¾æ ‡ã€‚ NexTä½¿ç”¨çš„æ˜¯Font Awesomeæä¾›çš„å›¾æ ‡ï¼ŒFont Awesomeæä¾›äº†600+çš„å›¾æ ‡ï¼Œå¯ä»¥æ»¡è¶³ç»å¤§çš„å¤šæ•°çš„åœºæ™¯ï¼ŒåŒæ—¶æ— é¡»æ‹…å¿ƒåœ¨Retinaå±å¹•ä¸‹å›¾æ ‡æ¨¡ç³Šçš„é—®é¢˜ã€‚ ç¼–è¾‘ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°å¦‚ä¸‹éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat å°†éœ€è¦å¯ç”¨çš„èœå•é¡¹å‰çš„æ³¨é‡Š#åˆ é™¤å³å¯ï¼Œ||ä¹‹å‰ä¸ºç›®æ ‡é¡µé¢çš„é“¾æŽ¥ï¼Œ||ä¹‹åŽä¸ºå¯¹åº”çš„é¡¹ç›®å›¾æ ‡ã€‚åœ¨èœå•å›¾æ ‡å¼€å¯çš„æƒ…å†µä¸‹ï¼Œå¦‚æžœèœå•é¡¹ä¸Žèœå•æœªåŒ¹é…ï¼ˆæ²¡æœ‰è®¾ç½®æˆ–è€…æ— æ•ˆçš„Font Awesomeå›¾æ ‡åå­—ï¼‰çš„æƒ…å†µä¸‹ï¼ŒNexTä¼šä½¿ç”¨question iconä½œä¸ºå›¾æ ‡ã€‚æ‰€ä»¥ï¼Œå€¼å¿…é¡»è¦ä¸Žå›¾æ ‡åç§°ä¸¥æ ¼ä¸€è‡´ã€‚ è‹¥æ­¤æ—¶æ²¡æœ‰ä¸ºæ–°å¼€å¯çš„èœå•é¡¹è®¾ç½®é¡µé¢ï¼Œç‚¹å‡»æ‰“å¼€æ—¶ä¼šå‡ºçŽ°Cannot GET /xxx/çš„é”™è¯¯ Sidebar Setting - ä¾§æ è®¾ç½®é»˜è®¤æƒ…å†µä¸‹ï¼Œä¾§æ ä»…åœ¨æ–‡ç« é¡µé¢ï¼ˆæ‹¥æœ‰ç›®å½•åˆ—è¡¨ï¼‰æ—¶æ‰æ˜¾ç¤ºï¼Œå¹¶æ”¾ç½®äºŽå³ä¾§ä½ç½®ã€‚å¯ä»¥é€šè¿‡ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„sidebarå­—æ®µæ¥æŽ§åˆ¶ä¾§æ çš„è¡Œä¸ºã€‚ä¾§æ çš„è®¾ç½®ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå…¶ä¸€æ˜¯ä¾§æ çš„ä½ç½®ï¼Œå…¶äºŒæ˜¯ä¾§æ æ˜¾ç¤ºçš„æ—¶æœºã€‚å½“ç„¶äº†ï¼Œè¿˜åŒ…å«ä¸€éƒ¨åˆ†ä¸ªæ€§åŒ–è®¾ç½®ã€‚ è®¾ç½®ä¾§æ çš„ä½ç½®ï¼Œä¿®æ”¹sideba.positionçš„å€¼ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml1234sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right è®¾ç½®ä¾§æ æ˜¾ç¤ºçš„æ—¶æœºï¼Œä¿®æ”¹sidebar.displayçš„å€¼ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml12345sidebar: display: post #display: always #display: hide #display: remove é¢å¤–çš„ä¸ªæ€§åŒ–è®¾ç½®ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml12345678# Sidebar offset from top menubar in pixels (only for Pisces | Gemini).offset: 12# Back to top in sidebar.b2t: false# Scroll percent label in b2t button.scrollpercent: true# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true Summary - å°ç»“åˆ°è¿™é‡Œï¼ŒNexTåŸºæœ¬è®¾ç½®å°±å®Œæˆäº†ã€‚å¯ä»¥å‘çŽ°ï¼Œå¯¹äºŽHexoè€Œè¨€ï¼Œä¸Žé¡µé¢æ ·å¼ç›´æŽ¥ç›¸å…³çš„å†…å®¹éƒ½æ˜¯å­˜äºŽä¸»é¢˜æ–‡ä»¶ä¸­çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ç›´æŽ¥ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶å°±å¥½äº†ï¼Œä½†è‹¥æŸäº›ä¸»é¢˜ç¼ºå°‘éƒ¨åˆ†åŠŸèƒ½çš„è®¾ç½®ï¼Œé‚£ä¹ˆå¯èƒ½å°±éœ€è¦ç¬¬ä¸‰æ–¹æ’ä»¶æ¥å®Œæˆäº†ã€‚ Custom with NexT - NexT è‡ªå®šä¹‰ æ„Ÿè°¢ä»¥ä¸‹åšæ–‡ï¼šæ‰“é€ ä¸ªæ€§è¶…èµžåšå®¢Hexo+NexT+GitHubPagesçš„è¶…æ·±åº¦ä¼˜åŒ–Git Pages ä½¿ç”¨æŒ‡å— hexoçš„nextä¸»é¢˜ä¸ªæ€§åŒ–æ•™ç¨‹:æ‰“é€ ç‚«é…·ç½‘ç«™ éšç€NexTç‰ˆæœ¬çš„ä¸æ–­æ›´æ–°ï¼ŒåŽŸå…ˆéœ€è¦ç”¨æˆ·è‡ªå·±å®žçŽ°çš„ç‰¹æ•ˆï¼ˆå¾€æºç æ–‡ä»¶ä¸­æ·»åŠ ä»£ç ï¼‰ï¼Œæœ‰ä¸€éƒ¨åˆ†å·²ç»è¢«å¤§ä½¬ä»¬å†…åµŒåˆ°NexTä¸»é¢˜å†…äº†ï¼Œæ„Ÿè°¢ä»–ä»¬ã€‚ ç½‘ç«™é¡µè„šçš„çº¢å¿ƒåŠå…¶åŠ¨ç”»æ•ˆæžœä¿®æ”¹å¦‚ä¸‹ä»£ç éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml12345678910footer: # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" å½“ç„¶äº†ï¼Œä¾ç„¶å¯ä»¥åœ¨Font Awesomeæ‰¾åˆ°ä½ è‡ªå·±æƒ³è¦çš„å›¾æ ‡è¿›è¡Œæ›¿æ¢ã€‚ å¼€å¯RSSæ ¹æ®å®˜æ–¹çš„è¯´æ˜Žï¼ŒNexTä¸­RSSæœ‰ä¸‰ä¸ªè®¾ç½®é€‰é¡¹ï¼Œå­˜æ”¾åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼š falseï¼šç¦ç”¨RSSï¼Œä¸åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºRSSè¿žæŽ¥ ç•™ç©ºï¼šä½¿ç”¨Hexoç”Ÿæˆçš„Feedé“¾æŽ¥ï¼Œéœ€è¦å…ˆå®‰è£…hexo-generator-feedæ’ä»¶ å…·ä½“çš„é“¾æŽ¥åœ°å€ï¼šé€‚ç”¨äºŽå·²ç»çƒ§åˆ¶è¿‡Feedçš„æƒ…å½¢ ä»¥ç•™ç©ºä¸ºä¾‹ï¼Œå…ˆå®‰è£…hexo-generator-feedæ’ä»¶ã€‚~\hexo1npm install hexo-generator-feed --save å®‰è£…å®ŒæˆåŽï¼Œè®¾ç½®ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\_config.yml12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png ç„¶åŽé‡æ–°å¼€å¯é¡µé¢å³å¯åœ¨ä¾§æ çœ‹åˆ°RSSè¿žæŽ¥ã€‚ å¼€å¯æ‰“èµæ‰“èµåŠŸèƒ½å·²ç»è¢«é›†æˆåœ¨NexTä¸»é¢˜ä¸­äº†ï¼Œé‚£ä¹ˆåªéœ€è¦æ”¾å…¥æˆ‘ä»¬çš„äºŒç»´ç ï¼Œå¹¶å¼€å¯ç›¸åº”çš„åŠŸèƒ½å³å¯ã€‚ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼š~\hexo\theme\next\_config.yml12345reward: enable: true comment: If it helps, would you?:P wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg æ­¤æ—¶ï¼Œåˆ·æ–°é¡µé¢å³å¯çœ‹åˆ°çº¢è‰²çš„æ‰“èµæŒ‰é’®ï¼Œç‚¹å‡»æ‰“å¼€å°±èƒ½çœ‹åˆ°æ”¯ä»˜çš„äºŒç»´ç äº†ã€‚ å…³é—­æ‰“èµæ–‡å­—çš„åŠ¨ç”»æ•ˆæžœå°†é¼ æ ‡æŒ‡é’ˆæ”¾åˆ°äºŒç»´ç ä¸Šé¢æ—¶ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸‹é¢çš„å­—ä½“ä¼šä¸æ–­çš„æŠ–åŠ¨ï¼Œè‹¥ä¸å–œæ¬¢å¯ä»¥å°†è¿™ä¸ªåŠ¨ç”»æ•ˆæžœå…³é—­ã€‚æ³¨é‡ŠæŽ‰å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_common\components\post\post-reward.styl1234567/* close the roll of reward font#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ ä¿å­˜ä¿®æ”¹åŽå³å¯ç”Ÿæ•ˆã€‚ å¯ç”¨æœ¬åœ°æœç´¢æœ¬åœ°æœç´¢åŠŸèƒ½ä¾èµ–æ’ä»¶hexo-generator-searchdbï¼Œå…ˆå®‰è£…æ’ä»¶ï¼š~\hexo1npm install hexo-generator-searchdb --save ç„¶åŽç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo fold\_config.yml12345search: path: search.xml field: post format: html limit: 10000 æŽ¥ç€åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯ç”¨æœ¬åœ°æœç´¢åŠŸèƒ½ï¼š~\hexo\theme\next\_config.yml12local_search: enable: true é…ç½®å®ŒæˆåŽï¼Œéœ€è¦é‡æ–°ç”Ÿæˆé™æ€é¡µé¢ã€‚ ä¿®æ”¹æ–‡ç« å†…é“¾æŽ¥æ–‡æœ¬æ ·å¼æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml1234567891011// change the style of inner link.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; ä¹Ÿå¯åœ¨~\hexo\themes\next\source\css\_common\components\post\post.stylè¿™ä¸ªæ–‡ä»¶å†…æ·»åŠ ä»¥ä¸Šä»£ç ã€‚ å¢žåŠ ä»£ç å—å¤åˆ¶åŠŸèƒ½æ­¤åŠŸèƒ½ä¹Ÿè¢«é›†æˆåœ¨NexTä¸»é¢˜ä¸­äº†ï¼Œä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼Œå³å¯ç›´æŽ¥å¼€å¯ã€‚~\hexo\themes\next\_config.yml123456codeblock: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true æ·»åŠ ä»£ç å—åœ†è§’å¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml123// codeblocks with rounded rectangle.highlight &#123; border-radius: 18px;&#125;pre &#123; border-radius: 8px;&#125; å…·ä½“æ•°å€¼å¯è‡ªè¡Œè®¾ç½®ï¼Œä¹Ÿå¯ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¦‚ä¸‹ä»£ç ï¼š12345codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1- border_radius:+ border_radius: 8 ä¿®æ”¹å•è¡Œä»£ç é¢œè‰²å¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml12// the colour of single line codecode &#123; color: #ec7f00; &#125; å…·ä½“é¢œè‰²å¯è‡ªè¡Œè®¾ç½®ã€‚ æ·»åŠ åšæ–‡å­—æ•°ç»Ÿè®¡åŠŸèƒ½å­—æ•°ç»Ÿè®¡åŠŸèƒ½ä¾èµ–æ’ä»¶hexo-symbols-count-timeï¼Œå…ˆå®‰è£…æ’ä»¶ï¼š ~\hexo1npm install hexo-symbols-count-time --save ç„¶åŽç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\_config.yml12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true æŽ¥ç€åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯ç”¨å­—æ•°ç»Ÿè®¡åŠŸèƒ½ï¼š~\hexo\theme\next\_config.yml123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275 awlwpmsuffixAverage Word Length(chars count in word). Default: 4 CN â‰ˆ 2 EN â‰ˆ 5 RU â‰ˆ 6 Words Per Minute. Default: 275. Slow â‰ˆ 200 Normal â‰ˆ 275 Fast â‰ˆ 350 If time to read less then 60 minutes, added suffix as string parameter. Default: mins. è®¾ç½®é¡µé¢æ˜¾ç¤ºçš„æ–‡ç« ç¯‡æ•°NexTé»˜è®¤ä¼šå¯¹æ­¤è¿›è¡Œé…ç½®ï¼Œä½†å¦‚æžœéœ€è¦æ›´å¤šä¸ªæ€§åŒ–è®¾ç½®éœ€è¦å®‰è£…æ’ä»¶ï¼š~\hexo123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag ç„¶åŽåœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­ï¼Œæ·»åŠ å¦‚ä¸‹ä»£ç ï¼Œæ³¨æ„Hexo 3ä»¥ä¸Šçš„ç‰ˆæœ¬ä¸å…è®¸é…ç½®æ–‡ä»¶å­˜åœ¨é‡å¤çš„é€‰é¡¹è®¾ç½®ã€‚å› æ­¤æœ€å¥½å…ˆæ£€æŸ¥ä¸‹ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­æ˜¯å¦æœ‰å­˜åœ¨ä¸Šè¿°åŒåçš„é…ç½®ã€‚å¦‚æžœå­˜åœ¨ï¼Œè¯·å°†ä¸¤è€…é…ç½®åœ¨ä¸€èµ·ã€‚~\hexo\_config.yml12345678910111213141516# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# å…¨å±€åˆ†é¡µï¼Œæ¯é¡µ8ç¯‡æ–‡ç« index_generator: # ä¸»é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 5archive_generator: # å½’æ¡£é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 20 yearly: true monthly: truetag_generator: # æ ‡ç­¾é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 10category_generator: per_page: 12 æ˜¾ç¤ºèœå•æ çš„æ–‡ç« æ•°é‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š- ~\hexo\themes\next\_config.yml12menu_settings: badges: true å¼€å¯è¯„è®ºå’Œé˜…è¯»ç»Ÿè®¡åŠŸèƒ½NexTæ”¯æŒçš„é˜…è¯»ç»Ÿè®¡å’Œè¯„è®ºåŠŸèƒ½è¾ƒå¤šï¼Œé’ˆå¯¹ä¸åŒçš„æ’ä»¶ï¼Œéƒ½è¿›è¡Œäº†é›†æˆï¼Œç”¨æˆ·éœ€è¦åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯ç”¨æˆ·è‡ªå·±æŒ‡å®šçš„æŸä¸€ç±»åŠŸèƒ½ï¼›åŒæ—¶å¯èƒ½éƒ¨åˆ†åŠŸèƒ½éœ€è¦å€ŸåŠ©åˆ°å…¶ä»–ç¬¬ä¸‰æ–¹åº”ç”¨ï¼Œæ‰€ä»¥ç”¨æˆ·è¿˜éœ€è¦è‡ªå·±æ³¨å†Œç¬¬ä¸‰æ–¹åº”ç”¨å¹¶é…ç½®å¥½è¿™äº›ç¬¬ä¸‰æ–¹åº”ç”¨çš„åŠŸèƒ½ã€‚ä»¥åŸºäºŽleancloudçš„ç»Ÿè®¡åŠŸèƒ½ä¸ºä¾‹ï¼Œéœ€è¦ç”¨æˆ·è‡ªèº«æ³¨å†Œleancloudçš„è´¦å·ï¼Œå¹¶è¿›è¡Œé…ç½®ï¼Œè¿™é‡Œç»™å‡ºå®˜æ–¹é“¾æŽ¥â€”â€”ä½¿ç”¨leancloudä¸ºnextä¸»é¢˜æ·»åŠ é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½ã€‚ æ·»åŠ è¯„è®ºç³»ç»ŸNexTå†…åµŒæ”¯æŒçš„è¯„è®ºç³»ç»Ÿä¹Ÿæœ‰å¤šç§ï¼ˆè¿™å¾—æ„Ÿè°¢å„ä½å¤§å¤§çš„å¥‰çŒ®ï¼‰ï¼Œä¸Žå¼€å¯ç»Ÿè®¡åŠŸèƒ½çš„æ–¹æ³•ä¸€è‡´ã€‚åŸºäºŽleancloudçš„é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½é…ç½®å®ŒæˆåŽï¼Œleancloudå†…çš„èµ„æºä¾ç„¶å¯ä»¥ç”¨æ¥ç»Ÿè®¡è¯„è®ºè®°å½•ï¼Œä¸è¿‡è¦é…åˆValineä¸€èµ·ä½¿ç”¨ï¼›Valineçš„åŸºæœ¬é…ç½®æ–¹æ³•å¯ä»¥å‚è€ƒé“¾æŽ¥â€”â€”å¿«é€Ÿå¼€å§‹ | Valineã€‚ä¸è¿‡å¯¹äºŽNexTè€Œè¨€ï¼Œåªéœ€è¦åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯ValineåŠŸèƒ½ï¼Œå¹¶åœ¨Leancloudé…ç½®å¥½é’ˆå¯¹è¯„è®ºçš„åº”ç”¨å³å¯ï¼Œè€Œè¿™éƒ¨åˆ†å†…å®¹å¯ä»¥ä»Žå®˜æ–¹é“¾æŽ¥å†…æ‰¾åˆ°ç­”æ¡ˆã€‚å¦å¤–ï¼Œéœ€è¦æ³¨æ„ä¸€ä¸‹çš„æ˜¯ï¼ŒValineçš„å¤´åƒæ˜¯åŸºäºŽGravatarçš„ï¼Œç”¨æˆ·éœ€è¦è‡ªå·±åŽ»Gravataræ³¨å†Œè´¦å·ï¼Œå¹¶è®¾ç½®å¤´åƒã€‚ ä¿®æ”¹åº•éƒ¨æ ‡ç­¾æ ·å¼ä¿®æ”¹åº•éƒ¨æ ‡ç­¾æ ·å¼éœ€è¦å¯¹æ•´ä¸ªé¡µé¢çš„ä¸€äº›å…ƒç´ è¿›è¡Œä¿®æ”¹ã€‚ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\layout\_marco\post.swig1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; å³å°†rel=&quot;tag&quot;&gt;#åŽçš„#æ›¿æ¢ä¸º&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;å³å¯ã€‚æ›¿æ¢å®ŒåŽï¼Œéœ€è¦é‡æ–°ç”Ÿæˆé¡µé¢ã€‚ æ·»åŠ ä¾§æ é“¾æŽ¥ä¾§æ é“¾æŽ¥çš„åŠŸèƒ½åœ¨NexTå†…å¯ç›´æŽ¥æ‰¾åˆ°ã€‚ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\_config.yml123456links_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com æ·»åŠ ä¾§æ ç¤¾äº¤å›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml123456789101112social: GitHub: https://github.com/Bachzart || github E-Mail: mailto:whistlesilp@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype å¯è‡ªè¡Œæ·»åŠ è‡ªå·±éœ€è¦çš„ç¤¾äº¤å›¾æ ‡å’Œé“¾æŽ¥ã€‚ ä¿®æ”¹ç½‘ç«™çš„å›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml12345favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png+ small: /uploads/example_16px.png+ medium: /uploads/example_32px.png å¼€å¯å³ä¸Šè§’Githubå›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml123456 # Follow me on GitHub banner in right-top corner. # Usage: `permalink || title` # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the title and aria-label name.- # github_banner: https://github.com/bachzart || Follow me on GitHub :)+ # github_banner: https://github.com/bachzart || Follow me on GitHub :) ä¿®æ”¹åšå®¢å†…å­—ä½“ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml123456789font:- enable: false+ enable: true+ host: //fonts.loli.net global: external: true+ family:+ family: Noto Serif SC size:å…¶ä¸­Noto Serif SCæ˜¯æ€æºå®‹ä½“ï¼Œå¦å¤–åœ¨æ•´ä¸ªfontè®¾ç½®é¡¹ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„é€‰é¡¹å¯ä»¥è¿›è¡Œè®¾ç½®ï¼Œä¸å¦¨å°è¯•ä¸€ä¸‹ã€‚ æ·»åŠ é¡¶éƒ¨åŠ è½½æ¡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\layout\_partials\head\head.swig12345678910111213141516171819 &lt;meta charset="UTF-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/&gt;+ &lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;+ &lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;+ &lt;style&gt;+ .pace .pace-progress &#123;+ background: #1E92FB; /*the color of strip*/+ height: 3px;+ &#125;+ .pace .pace-progress-inner &#123;+ box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*the color of shadow*/+ &#125;+ .pace .pace-activity &#123;+ border-top-color: #1E92FB; /*border-top-color*/+ border-left-color: #1E92FB; /*border-left-color*/+ &#125;+ &lt;/style&gt; &lt;meta name="theme-color" content=""/&gt; å¼€å¯æ–‡ç« åº•éƒ¨ç‰ˆæƒå£°æ˜Žä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml1234creative_commons: license: by-nc-sa sidebar: false+ post: trueå¦‚è‹¥è§£æžå®ŒæˆåŽï¼Œæ˜¾ç¤ºhttp://yoursite.com/xxx.htmlï¼Œè¯·ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\_config.yml1234+ url: http://bachzart.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults:ä¿å­˜å¥½åŽï¼Œé‡æ–°ç”Ÿæˆå³å¯ã€‚ æ·»åŠ  fancybox æ’ä»¶fancybox2/3çš†éœ€è¦å…ˆå®‰è£…æ‰èƒ½ä½¿ç”¨ï¼Œå®‰è£…ååˆ†ç®€å•ï¼Œå¯ä»¥å‚è€ƒfancybox3ï¼Œå…ˆä¸‹è½½fancybox3æ–‡ä»¶ï¼š~\Hexo\themes\next1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox ç„¶åŽåœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯åŠŸèƒ½ï¼š~\Hexo\themes\next_config.yml1+ fancybox: trueæ•ˆæžœå¦‚ä¸‹å›¾ï¼š Writing Skillsä¸‹é¢å†…å®¹å°†å¼€å§‹ä»‹ç»ä¸€äº›å†™ä½œæŠ€å·§ã€‚ Writing with NexTNexTä¸»é¢˜è‡ªèº«æ‰©å±•äº†å¾ˆå¤šæ–¹ä¾¿å†™ä½œçš„åŠŸèƒ½ï¼Œæ—¢æé«˜äº†æ–‡ç« çš„ç¾Žæ„Ÿï¼Œåˆè®©ä½œè€…æ›´åŠ å®¹æ˜“çš„è¡¨è¾¾è§‚ç‚¹ã€‚ é™¤äº†ä»£ç å—å¤–ï¼Œå…¶ä»–å¼•ç”¨æ–¹å¼å†…éƒ½å¯ä»¥å°è¯•ä¸Ž Markdown è¯­æ³•çš„åŠ ç²—ã€å€¾æ–œã€åˆ é™¤çº¿ç­‰åŠŸèƒ½è¿›è¡ŒåµŒå¥—ä½¿ç”¨ï¼Œæ•ˆæžœæ›´ä½³ æ–‡æœ¬å±…ä¸­å¼•ç”¨æ­¤æ ‡ç­¾å°†ç”Ÿæˆä¸€ä¸ªå¸¦ä¸Šä¸‹åˆ†å‰²çº¿å’ŒåŒå¼•å·çš„å¼•ç”¨ï¼ŒåŒæ—¶å†™åœ¨å…¶å†…éƒ¨çš„åº”ç”¨æ–‡æœ¬å°†è‡ªåŠ¨å±…ä¸­ã€‚æ–‡æœ¬å±…ä¸­æ—¶ï¼Œå¤šè¡Œæ–‡æœ¬è‹¥é•¿åº¦ä¸ç­‰ï¼Œè§†è§‰ä¸Šä¼šæ˜¾å¾—ä¸å¯¹ç§°ï¼Œå› æ­¤å»ºè®®åœ¨å¼•ç”¨å•è¡Œæ–‡æœ¬çš„åœºæ™¯ä¸‹ä½¿ç”¨ã€‚ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š12345678&lt;!-- HTMLæ–¹å¼ï¼šç›´æŽ¥åœ¨ Markdown æ–‡ä»¶ä¸­ç¼–å†™ HTMLæ¥è°ƒç”¨&gt;&lt;!-- å…¶ä¸­ class=&quot;block-quote-center&quot; æ˜¯å¿…é¡»çš„ --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;bla bla bla&lt;/blockquote&gt;&lt;!-- swigè¯­æ³• --&gt;&#123;% centerquote %&#125;bla bla bla&#123;% endcenterquote %&#125;&lt;!-- ç®€å†™ --&gt;&#123;% cq %&#125;bla bla bla&#123;% endcq %&#125; æ•ˆæžœå¦‚ä¸‹å›¾ï¼šå¦å¤–è¿˜æœ‰ä¸€ç§æ–‡æœ¬å±…ä¸­å¼•ç”¨æ–¹æ³•ï¼š12&lt;!-- HTMLæ–¹å¼ --&gt;&lt;center&gt;**bla bla bla**&lt;/center&gt; æ•ˆæžœå¦‚ä¸‹ï¼š bla bla bla ä»£ç å—çš„ä¹¦å†™æ–¹æ³•codeblockä»£ç å—ç”¨æ³•å¦‚ä¸‹ï¼š1234&lt;!-- swigè¯­æ³• --&gt;&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; å¦ä¸€ç§å½¢å¼çš„ä»£ç å—ä½¿ç”¨å…­ä¸ªåå¼•å·ï¼ˆæ­£å¥½ä¸€å¯¹ï¼‰æ¥åŒ…è£¹ä»£ç å—ï¼Œ[language] [title] [url] [link text]è¿™å››ä¸ªå‚æ•°ä¹Ÿå†™åœ¨é¦–è¡Œï¼Œè¿™ä¸¤ç§æ–¹å¼ä¹¦å†™æ—¶éƒ½æ²¡æœ‰[]ã€‚languagetitleurllink textlanguageæ˜¯ä»£ç è¯­è¨€çš„åç§°ï¼Œç”¨æ¥è®¾ç½®ä»£ç å—é¢œè‰²é«˜äº®ï¼Œéžå¿…é¡»titleæ˜¯é¡¶éƒ¨å·¦è¾¹çš„è¯´æ˜Žï¼Œéžå¿…é¡»urlæ˜¯é¡¶éƒ¨å³è¾¹çš„è¶…é“¾æŽ¥åœ°å€ï¼Œéžå¿…é¡»link textæ˜¯è¶…é“¾æŽ¥çš„åç§°ï¼Œéžå¿…é¡»å¦‚æžœéœ€è¦å¯¹æ¯”åŠŸèƒ½ï¼Œéœ€è¦å†™langï¼šdiffï¼Œå¹¶åœ¨ç›¸åº”çš„ä»£ç è¡Œé¦–åŠ ä¸Š-å’Œ+å³å¯ï¼Œå¯¹åº”çš„é¢œè‰²ä¹Ÿæ˜¯å¯ä»¥è‡ªå®šä¹‰çš„ï¼Œä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.syl1234567// the diff style of codeblockpre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125; Note PluginNexTä¸»é¢˜æ‰©å±•äº†ä¸€ç§noteæ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å•ç‹¬å±•ç¤ºé‡ç‚¹æ€§æˆ–ç»“è®ºæ€§å†…å®¹ï¼Œå…¶é…ç½®ä¿¡æ¯ä¿å­˜åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 åœ¨ä¹¦å†™æ—¶ï¼Œåœ¨.mdæ–‡ä»¶å†…ç›´æŽ¥æ’å…¥ä»¥ä¸‹ä»£ç å³å¯ï¼š1234567&lt;!-- swig --&gt;&#123;% note %&#125;bla bla bla&#123;% endnote %&#125;&lt;!-- HTML --&gt;&lt;div class=&quot;note&quot;&gt;&lt;p&gt;bla bla bla&lt;/p&gt;&lt;/div&gt; æ•ˆæžœå¦‚ä¸‹ï¼š bla bla bla å¦å¤–ï¼ŒnoteåŽæ·»åŠ default/primary/info/success/warning/dangerï¼Œå¯ä»¥å±•ç¤ºä¸åŒçš„æ ‡ç­¾æ ï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla è®¾ç½®note xx no-iconå¯ä»¥ä¸æ˜¾ç¤ºå›¾æ ‡ï¼Œæ•ˆæžœå¦‚ä¸‹ï¼š æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Note-Docsã€‚ Button PluginButtonæ’ä»¶çš„ä½¿ç”¨ä¹Ÿå¾ˆç®€å•ï¼Œåœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯å¼€å¯ï¼ŒåŒæ ·ç›´æŽ¥åœ¨.mdæ–‡ä»¶å†…æ’å…¥ä»¥ä¸‹ä»£ç ï¼š123&#123;% button url, text, icon [class], [title] %&#125;&lt;!-- Tag Alias --&gt;&#123;% btn url, text, icon [class], [title] %&#125; 1å¦‚ï¼š&#123;% btn #, Text %&#125; æ•ˆæžœå¦‚ä¸‹ï¼š Text æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Button-Docsã€‚ Tabs PluginTabsæ’ä»¶åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„é…ç½®å¦‚ä¸‹ï¼š1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 5 ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š1234567891011&#123;% tabs First unique name %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; æ•ˆæžœå¦‚ä¸‹ï¼šFirst unique name 1First unique name 2First unique name 3This is Tab 1.This is Tab 2.This is Tab 3. æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Tabs-Docsã€‚ Label PluginLabelæ’ä»¶åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„é…ç½®å¦‚ä¸‹ï¼š12# Label taglabel: true ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š12345&#123;% label primary@Text %&#125;&#123;% label success@Text %&#125;&#123;% label info@Text %&#125;&#123;% label warning@Text %&#125;&#123;% label danger@Text %&#125; æ•ˆæžœå¦‚ä¸‹ï¼šTextTextTextTextTextæ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Label-Docsã€‚ å›¾ç‰‡çš„å¼•ç”¨æ–¹æ³•å›¾ç‰‡çš„å¼•ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š123&#123;% fullimage /url [@lazy], [alt], [title], [size] %&#125;&lt;!-- Tag Alias --&gt;&#123;% fi /url [@lazy], [alt], [title], [size] %&#125; ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š1&#123;% fi /my_photo_gallery/test_github.png, test text, test text %&#125; æ•ˆæžœå¦‚ä¸‹å›¾ï¼š æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Full Image-Docsã€‚ Markdown Grammarå‚è§ Markdown è¯­æ³•å¿«é€ŸæŒ‡å— Mathjax Grammarå‚è§ Mathjax è¯­æ³•å¿«é€ŸæŒ‡å—]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
