<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ çš„ä¸€äº›æ¦‚å¿µ]]></title>
    <url>%2F2021%2F11%2F17%2FC%2B%2B-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[æ­¤æ–‡ç”¨äºŽè®°å½•å­¦ä¹  C++ è¿‡ç¨‹ä¸­é‡åˆ°çš„ä¸€äº›çŸ¥è¯†ç‚¹ã€‚ å‘½åç©ºé—´å‘½åç©ºé—´é‡Œé¢åŒ…å«äº†é€»è¾‘ç»“æž„ä¸Šç›¸äº’å…³è”çš„ä¸€ç»„ç±»ã€å‡½æ•°ã€æ¨¡æ¿ç­‰ã€‚å‘½åç©ºé—´åƒæ˜¯ä¸€ä¸ªå®¹å™¨ï¼ŒæŠŠæŸäº›åœ¨é€»è¾‘ç»“æž„ä¸Šç›¸å…³çš„â€œå¯¹è±¡â€æ”¾åœ¨ä¸€èµ·å¹¶ä¸Žå¤–ç•ŒåŒºåˆ†ã€‚ç‰¹åˆ«çš„ï¼Œå‘½åç©ºé—´é‡Œé¢çš„å˜é‡åæˆ–ç±»åå¯ä»¥å’Œå‘½åç©ºé—´å¤–çš„å˜é‡åå’Œç±»åé‡åã€‚ ä¿®é¥°ç¬¦signedã€unsignedã€shortã€long æ˜¯ C++ ä¸­çš„ä¿®é¥°ç¬¦ï¼Œå½“ short å’Œ long ç”¨æ¥ä¿®é¥° int æ—¶ï¼Œint å¯çœç•¥ä¸å†™ï¼Œè¡¨ç¤ºçŸ­æ•´åž‹æ•°æ®æˆ–é•¿æ•´åž‹æ•°æ®ï¼ˆä¹Ÿå°±æ˜¯è¯´ï¼Œæ²¡æœ‰ short å’Œ long è¿™ç§æ•°æ®ç±»åž‹ï¼‰ã€‚ å†…å­˜åˆ†é…C++ ç¨‹åºåœ¨è¿è¡Œæ—¶ï¼Œè®¡ç®—æœºå†…å­˜è¢«åˆ†ä¸ºç¨‹åºä»£ç åŒºã€å…¨å±€æ•°æ®åŒºã€å †åŒºã€æ ˆåŒºå››ä¸ªéƒ¨åˆ†ã€‚ é™æ€å­˜å‚¨åŒºåˆ†é…é™æ€åˆ†é…æ–¹å¼ä¸‹çš„å†…å­˜åœ¨ç¨‹åºç¼–è¯‘çš„æ—¶å€™å°±å·²ç»åˆ†é…å¥½äº†ä¸”å­˜åœ¨äºŽç¨‹åºçš„æ•´ä¸ªè¿è¡Œè¿‡ç¨‹ã€‚ä¾‹å¦‚ static å˜é‡ï¼Œå…¶ç”Ÿå‘½å‘¨æœŸéšç¨‹åºçš„ç»“æŸè€Œç»“æŸï¼Œè€Œé£žåƒä¸€èˆ¬å˜é‡éšå‡½æ•°æˆ–ä½œç”¨åŸŸçš„ç»“æŸè€Œç»“æŸã€‚ å½“ç„¶ï¼Œé™¤äº† static å˜é‡ï¼Œè¿˜æœ‰ä¸€ç§å…¨å±€å¯¹è±¡ static objectï¼Œä¹Ÿå¯ä»¥å­˜æ”¾åœ¨é™æ€å­˜å‚¨åŒºã€‚ æ ˆå†…å­˜åˆ†é…æ ˆå†…å­˜åˆ†é…æ–¹å¼ä¸‹çš„å†…å­˜æ˜¯å­˜åœ¨äºŽæŸä½œç”¨åŸŸçš„ä¸€å—ç©ºé—´ã€‚ä¾‹å¦‚è°ƒç”¨æŸä¸ªå‡½æ•°æ—¶ï¼Œå‡½æ•°å†…å±€éƒ¨å˜é‡çš„å­˜å‚¨å•å…ƒå¯ä»¥åœ¨æ ˆä¸Šåˆ›å»ºï¼Œå‡½æ•°æ‰§è¡Œç»“æŸæ—¶ï¼Œè¿™äº›å†…å­˜å•å…ƒä¼šè¢«è‡ªåŠ¨é‡Šæ”¾ã€‚ å †å†…å­˜åˆ†é…å †å†…å­˜åˆ†é…ï¼Œä¹Ÿç§°åŠ¨æ€å†…å­˜åˆ†é…ï¼Œé€šå¸¸ä½¿ç”¨ new å’Œ delete å…³é”®å­—è¿›è¡Œç®¡ç†ã€‚å †å†…å­˜ç©ºé—´å¯ç”±ç”¨äºŽæ‰‹åŠ¨åˆ†é…å’Œé‡Šæ”¾ï¼Œæ‰€ä»¥å…¶ç”Ÿå­˜å‘¨æœŸç”±ç”¨æˆ·æŒ‡å®šï¼Œè¾ƒä¸ºçµæ´»ã€‚ä½†é¢‘ç¹çš„åˆ†é…ã€é‡Šæ”¾å¤§å°ä¸åŒçš„å †ç©ºé—´ä¼šäº§ç”Ÿå†…å­˜ç¢Žç‰‡ã€‚ å‡½æ•°é‡è½½å‡½æ•°é‡è½½æŒ‡å®šä¹‰ä¸€ä¸ªå‡½æ•°å‚æ•°ç±»åž‹æˆ–å‚æ•°ä¸ªæ•°ä¸åŒçš„é‡åå‡½æ•°ã€‚å½“ç¨‹åºæ‰§è¡Œæ—¶ï¼Œç¼–è¯‘å™¨å°†è°ƒç”¨å‚æ•°ç±»åž‹ä¸Žå‡½æ•°å½¢å‚ç±»åž‹ä¸€è‡´çš„å‡½æ•°ã€‚ é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡çš„ç‰¹ç‚¹è¿™éƒ¨åˆ†å†…å®¹éƒ½æ˜¯æ¦‚å¿µæ€§å†…å®¹ï¼Œåº”è¯¥ç®—æ˜¯æ‰€æœ‰é¢å‘å¯¹è±¡çš„ç¨‹åºè¯­è¨€çš„åŸºæœ¬ç‰¹æ€§ã€‚ æŠ½è±¡æŠ½è±¡æ˜¯æŒ‡å¯¹å…·ä½“é—®é¢˜æˆ–å¯¹è±¡è¿›è¡Œæ¦‚æ‹¬ï¼ŒæŠ½å‡ºå…¶å…¬å…±æ€§è´¨å¹¶åŠ ä»¥æè¿°çš„è¿‡ç¨‹ã€‚ä¸€èˆ¬æƒ…å†µæŠ½è±¡åˆ†ä¸ºæ•°æ®æŠ½è±¡å’Œè¡Œä¸ºæŠ½è±¡ï¼Œå…¶ä¸­æ•°æ®æŠ½è±¡æ˜¯æŒ‡ä¸€ä¸ªå¯¹è±¡åŒºåˆ«äºŽå¦ä¸€ä¸ªå¯¹è±¡çš„ç‰¹å¾ï¼Œè¡Œä¸ºæŠ½è±¡æ˜¯æŒ‡æŸç±»å¯¹è±¡çš„å…±åŒç‰¹å¾ã€‚ å°è£…å°è£…æ˜¯æŒ‡å°†æŠ½è±¡å¾—åˆ°çš„æ•°æ®å’Œè¡Œä¸ºç›¸ç»“åˆï¼Œéšè—å¯¹è±¡å±žæ€§å’Œå®žçŽ°ç»†èŠ‚ä¸”ä»…å¯¹å¤–æä¾›å…¬å…±è®¿é—®æ–¹å¼çš„è¿‡ç¨‹ã€‚ ç»§æ‰¿ç»§æ‰¿æ˜¯æŒ‡é€šè¿‡ä»£ç å¤ç”¨åœ¨ä¿æŒåŽŸæœ‰ç±»ç‰¹æ€§çš„åŸºç¡€ä¸Šå¯¹å­ç±»è¿›è¡Œå…·ä½“è¯´æ˜Žçš„è¿‡ç¨‹ï¼Œé€šä¿—æ¥è¯´ç»§æ‰¿å°±æ˜¯ç²¾ç®€é‡å¤ä»£ç çš„æ‰‹æ®µã€‚ å¤šæ€å¤šæ€æ˜¯æŒ‡ä¸€æ®µç¨‹åºèƒ½å¤Ÿå¤„ç†å¤šç§ç±»åž‹å¯¹è±¡çš„èƒ½åŠ›ï¼Œå‡½æ•°é‡è½½å°±æ˜¯å®žçŽ°å¤šæ€çš„ä¸€ç§æ‰‹æ®µã€‚åœ¨ C++ ä¸­ï¼Œå¤šæ€å¯åˆ†ä¸ºå¼ºåˆ¶å¤šæ€ã€é‡è½½å¤šæ€ã€ç±»åž‹å‚æ•°åŒ–å¤šæ€å’ŒåŒ…å«å¤šæ€ã€‚ ç±»ç±»ä¸€èˆ¬æ˜¯ç”±ç±»åã€æ•°æ®æˆå‘˜ã€å‡½æ•°æˆå‘˜ä¸‰éƒ¨åˆ†ç»„æˆã€‚å®šä¹‰ç±»çš„åŸºæœ¬å½¢å¼ä¸ºï¼š12345678class name &#123; public: å¤–éƒ¨æŽ¥å£ protected: ä¿æŠ¤æ€§æˆå‘˜ private: ç§æœ‰æˆå‘˜&#125; å…¶ä¸­ publicã€protectedã€private è¡¨ç¤ºè®¿é—®æŽ§åˆ¶å±žæ€§ï¼Œç”¨äºŽæŽ§åˆ¶ç±»æˆå‘˜çš„è®¿é—®æƒé™ã€‚ç‰¹åˆ«çš„ï¼Œæ²¡æœ‰åˆ†é…æŽ§åˆ¶å±žæ€§çš„é»˜è®¤ä¸º private ç§æœ‰æˆå‘˜ã€‚public æˆå‘˜å¯ä»¥åœ¨ç±»å¤–ç›´æŽ¥è®¿é—®ï¼›protected æˆå‘˜å¯ä»¥åœ¨å­ç±»ä¸­è®¿é—®ï¼›private æˆå‘˜åªèƒ½è¢«æœ¬ç±»çš„æˆå‘˜å‡½æ•°è®¿é—®ã€‚ ç±»çš„æˆå‘˜å‡½æ•°æˆå‘˜å‡½æ•°æè¿°äº†ç±»çš„è¡Œä¸ºã€‚æˆå‘˜å‡½æ•°åœ¨ç±»ä¸­åªç”¨è¯´æ˜Žå…¶å‡½æ•°çš„è¿”å›žç±»åž‹ã€åå­—å’Œå‚æ•°è¡¨ï¼Œè€Œå‡½æ•°çš„å…·ä½“å®žçŽ°åœ¨ç±»å¤–è¯´æ˜Žï¼Œå…¶åŸºæœ¬å½¢å¼ä¸ºï¼š1234567class name &#123; å‡½æ•°çš„è¿”å›žç±»åž‹ å‡½æ•°å(å‚æ•°åˆ—è¡¨)&#125;;è¿”å›žå€¼ç±»åž‹ ç±»å::å‡½æ•°å(å‚æ•°åˆ—è¡¨) &#123; å‡½æ•°ä½“&#125; å¯¹è±¡åœ¨ C++ ä¸­ï¼Œå¯¹è±¡æ˜¯æŸç±»äº‹ç‰©çš„å®žä¾‹ï¼Œå…¶å£°æ˜Žå½¢å¼ä¸ºï¼š1ç±»å å¯¹è±¡å;]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[è½®æ»‘åˆæŽ¢]]></title>
    <url>%2F2021%2F11%2F13%2F%E8%BD%AE%E6%BB%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[é¬¼ä½¿ç¥žå·®çš„ä¹°äº†ä¸€åŒç›´æŽ’è½®æ»‘éž‹å­ï¼ðŸ˜‘ è¯ºï¼å°±æ˜¯ä¸‹é¢è¿™ä¸ªä¸œè¥¿ï¼š äº‹æƒ…èµ·å› æ˜¯è¿™æ ·çš„ï¼šä¸´è¿‘åŒåä¸€äº†ï¼Œæƒ³ç€æ˜¯ä¸æ˜¯ä¹°ç‚¹ä»€ä¹ˆä¸œè¥¿ï¼Œå¤©å¤©åœ¨å®¶é—²ç€ï¼Œå¶å°”å‡ºé—¨å‘çŽ°èµ°è·¯æŒºè¿œçš„ï¼Œæœ€è¿‘ä¹Ÿæ²¡æœ‰éª‘è½¦äº†ï¼Œæ˜¯ä¸æ˜¯æ•´ä¸ªä»£æ­¥å·¥å…·ï¼Ÿä»¥æ¥å¯ä»¥æé«˜ä¸‹â€œæ•ˆçŽ‡â€ï¼ŒäºŒæ¥é¡ºä¾¿é”»ç‚¼èº«ä½“ã€‚ ç»“æžœå°±è¿™æ ·é¬¼ä½¿ç¥žå·®çš„æƒ³åˆ°äº†è½®æ»‘è·Ÿæ»‘æ¿ï¼Œæ»‘æ¿å…¶å®žæ˜¯åŽ»å¹´å°±å¼€å§‹æƒ³å°è¯•çŽ©çŽ©çš„ä¸œè¥¿äº†ï¼Œè¿™æ¬¡è¿˜æ˜¯å¿ä½äº†ã€‚è€ƒè™‘åˆ°äºŒè€…éƒ½æ˜¯éœ€è¦èº«ä½“å¹³è¡¡æ€§çš„ä½“è‚²æ´»åŠ¨ï¼Œç´¢æ€§å°±ä¹°è½®æ»‘éž‹å­äº†ã€‚ä¸»è¦è¿˜æ˜¯æ»‘æ¿å™ªéŸ³æœ‰ç‚¹å¤§ï¼Œè¿™çŽ©æ„å¥½åƒä¸æ€Žä¹ˆåµï¼Ÿ å…·ä½“æ„Ÿå—å¦‚ä½•ï¼Œè¦ç­‰çŽ©ä¸€çŽ©ä¹‹åŽæ‰èƒ½åˆ†æžã€‚ ä¸è¿‡ï¼Œæ‹¿è¿™ä¸œè¥¿å½“ä»£æ­¥å·¥å…·çš„æˆ‘ï¼Œæ˜¯ä¸æ˜¯åˆè½ä¼äº†ï¼Ÿäººå®¶çš„ä»£æ­¥å·¥å…·å¯æ˜¯å››ä¸ªè½®å­çš„è½¦å•Šï¼è¯¶ï¼Ÿçªç„¶å‘çŽ°ï¼Œè¿™çŽ©æ„å¥½åƒå•è„šå››è½®ï¼ŒåŒè„šå…«è½®ï¼Œå¾—ï¼Œå½“æˆ‘æ²¡è¯´ã€‚ ä¸ç®¡å¦‚ä½•ï¼Œè½®æ»‘æœ¬è´¨æ˜¯ä¸€ç§ä½“è‚²æ´»åŠ¨ã€‚å½“ç„¶äº†ï¼Œè‡³å°‘ç›®å‰è€Œè¨€ï¼Œç¡®å®žå¯ä»¥æ»¡è¶³æˆ‘çš„éœ€æ±‚ï¼š ä»£æ­¥ é”»ç‚¼ å¥½å§ï¼ŒçŽ°åœ¨æ˜¯ 2021 å¹´ 11 æœˆ 13 æ—¥ï¼Œä»Šå¤©æ˜¯ç¬¬ä¸€å¤©è§åˆ°è¿™ä½å…„å¼Ÿï¼Œå¸Œæœ›å®ƒå¥½å¥½å¾…æˆ‘ï¼Œå°‘è®©ç»™æˆ‘æ‘”å‡ è·¤ã€‚\ æ—¥æœŸï¼š2021-11-14ä¸‹åˆè¶ç€é˜³å…‰æ˜Žåªšçš„æ—¶å€™ï¼ŒæŠ˜è…¾äº† 2 ä¸ªå°æ—¶ï¼Œæ‘”äº†å¥½å‡ æ¬¡ã€‚ç‰¹åˆ«æœ‰ä¸€æ¬¡æ˜¯å®Œå…¨å¤±åŽ»å¹³è¡¡ï¼Œå±è‚¡ï¼ˆå‡†ç¡®è¯´æ˜¯å°¾æ¤Žéª¨ï¼‰å¤§é¢ç§¯ç€åœ°ï¼Œå½“ä¸‹è§‰å¾—å±è‚¡å¼€èŠ±äº†ï¼Œé‚£å«ä¸€ä¸ªç–¼ï¼Œå…‰æ˜¯é‡æ–°å†ç«™èµ·æ¥å°±èŠ±äº†å‡ åˆ†é’Ÿã€‚ ç»ƒä¹ æ—¶é—´æ˜¯ 2 å°æ—¶æ²¡é”™ï¼Œä½†æ˜¯è‡ªæˆ‘æ„Ÿè§‰æ”¶æ•ˆç”šå¾®ã€‚ä»”ç»†ç¢ç£¨äº†ä¸€ä¸‹ï¼Œæ²¡æƒ³å‡ºä¸ªæ‰€ä»¥ç„¶ï¼Œç»“æžœåˆåŽ»æ‰¾äº†ç‚¹è§†é¢‘çœ‹ï¼Œå‘çŽ°å¥½åƒæ˜¯è‡ªå·±å¤ªç€æ€¥äº†ã€‚å¤§æ¦‚æ„æ€å°±æ˜¯ç›®å‰è¿žèµ°éƒ½æ²¡å­¦ä¼šå°±æƒ³è·‘äº†ï¼Œæ²¡åŠžæ³•ï¼Œæ™šä¸Šåˆç»ƒä¹ äº†å‡ ç™¾æ¬¡åŽŸåœ°è¸æ­¥ï¼Œè¹²ä¸‹ç«™èµ·ï¼ŒåŽæ¥åˆå°è¯•äº†ä¸€ä¸‹æ»‘è¡Œï¼Œå¥½åƒæ‰¾åˆ°äº†ç‚¹æ„Ÿè§‰ï¼Ÿä½†é—æ†¾çš„æ˜¯ï¼Œä¸ä¼šæ‹å¼¯ :(ã€‚ æ—¥æœŸï¼š2021-11-15å‚æ™šç»ƒä¹ äº†å¤§æ¦‚ä¸€ä¸ªå¤šå°æ—¶ï¼Œåªæ˜¯ç»ƒä¹ è¿‘è·ç¦»çš„æŽ¨æ­¥æ»‘è¡Œå’Œå¹³è¡¡å‰æ»‘ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼ŒåŸºæœ¬ä¸Šæ„Ÿè§‰å¤§æ¦‚æœ‰äº†å§ã€‚ç„¶åŽåˆå°è¯•äº†ä¸‹åˆ¹è½¦è·Ÿè½¬å¼¯ï¼Œæ„Ÿè§‰åˆ¹è½¦ä¼šå®¹æ˜“ä¸€ç‚¹ï¼Œä½†æ˜¯è½¬å¼¯ä¸€ç‚¹æ„Ÿè§‰éƒ½æ²¡æŠ“ä½ï¼Œå¯èƒ½è¿˜éœ€è¦åœ¨å¤šæ‘”å‡ æ¬¡æ‰èƒ½æœ‰æ„Ÿè§‰å§ã€‚æ˜¯çš„ï¼Œæˆ‘çŽ°åœ¨æœ‰ç‚¹åŽæ‚”æ²¡ä¹°æŠ¤å…·äº†ï¼Œè¿™æ ·æˆ‘æ´»åŠ¨çš„æ—¶å€™ä¹Ÿæ”¾å¾—å¼€ä¸€ç‚¹ï¼Œä¸è‡³äºŽçŽ°åœ¨æœ‰ç‚¹ç•æ‰‹ç•è„šçš„ï¼ˆæ¯•ç«Ÿæ˜¨å¤©çš„å±è‚¡è¿˜åŽ†åŽ†åœ¨ç›®ï¼Œä¸è¿‡å·²ç»å¥½å¤šäº†ï¼‰ã€‚ ç»ƒä¹ çš„æ—¶å€™çªç„¶æƒ³èµ·æ¥å°æ—¶å€™å­¦éª‘è‡ªè¡Œè½¦çš„æ—¶å€™äº†ï¼Œé•¿è¾ˆåœ¨åŽé¢æ‰¶ç€åº§æ¤…ï¼Œæˆ‘åœ¨å‰é¢éª‘ï¼Œä»–ä»¬çªç„¶æ¾å¼€æ‰‹ï¼Œéª—æˆ‘è¿˜æ²¡æœ‰ï¼Œç„¶åŽæˆ‘æŽ¥ç€éª‘ï¼Œéª‘ç€éª‘ç€å°±ä¼šäº†ã€‚å…¶å®žï¼Œè½®æ»‘åº”è¯¥ä¹Ÿæ˜¯ä¸€æ ·ï¼Œå…³é”®å°±æ˜¯è¦æ‰¾åˆ°èº«ä½“çš„æ‰€é€‚åº”çš„å¹³è¡¡æ„Ÿã€‚å¦‚ä½•åŽ»æ‰¾å‘¢ï¼Ÿåªæœ‰å¤§èƒ†å°è¯•ï¼Œå¤šæ‘”å‡ æ¬¡ï¼Œåº”è¯¥å°±èƒ½æ‰¾åˆ°äº†ã€‚é—æ†¾çš„æ˜¯ï¼Œæˆ‘å¹¶æ²¡æœ‰æŠ¤å…·æ¥æ”¯æ’‘æˆ‘åšè¿™æ ·çš„äº‹æƒ…ï¼Œä½†ä¸ç®¡å¦‚ä½•è¿˜æ˜¯è¦ç»§ç»­ç»ƒä¹ ä¸‹åŽ»ã€‚ æ—¥æœŸï¼š2021-11-16å“ˆï¼Œä»Šå¤©æ„Ÿè§‰è¿˜è¡Œï¼Œç»ƒä¹ æ—¶é—´åœ¨ä¸€ä¸ªåŠå°æ—¶å·¦å³ï¼Œæ‘”äº†å››æ¬¡ï¼Œä¸è¿‡å¥½åœ¨æ²¡æœ‰å—å¤§ä¼¤ï¼Œå°±æ˜¯å³æ‰‹æ‰‹æŽŒä¸å°å¿ƒæŒ‚äº†ä¸ªå½©ï¼Œä¸€ä¸ªå°ä¼¤å£ï¼Œå†æ¬¡è¯´æ˜Žäº†æŠ¤å…·å¯¹åˆå­¦è€…çš„é‡è¦æ€§ã€‚ä¸è¿‡ï¼Œæˆ‘å¥½åƒæœ‰ä¸€ä¸ªå¯ä»¥ä¿æŠ¤æ‰‹æŽŒçš„â€œæŠ¤å…·â€ï¼Œæ˜Žå¤©å¯ä»¥è¯•ä¸€è¯•ã€‚ è¯è¯´ï¼Œä»Šå¤©å·®ç‚¹åˆ·äº†ä¸ªå˜´å•ƒæ³¥ï¼Œå¥½åœ¨æ‰‹æ”¯æ’‘ä½äº†ã€‚è¿˜æœ‰ä¸€æ¬¡ï¼Œå·®ç‚¹æ ½åˆ°äººå®¶é¸¡ç¬¼é‡Œé¢äº† XDã€‚æ€»ä¹‹ï¼Œæ²¡å—å¤§ä¼¤å°±å¥½ã€‚ ä»Šå¤©ä¸»è¦çš„ç»ƒä¹ å†…å®¹æ˜¯æŽ¨æ­¥æ»‘è¡Œå’Œå¹³è¡¡å‰æ»‘ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼Œå°±æ˜¯åŠ¨ä½œå§¿åŠ¿è¿˜æ˜¯æœ‰äº›ä¸åˆ°ä½ã€‚ æ—¥æœŸï¼š2021-11-17å³è…¿è†ç›–å¢žåŠ ä¸€å¤„æ“¦ä¼¤ï¼Œè¿˜å¥½åªæ˜¯è½»å¾®ã€‚è¯è¯´ï¼Œä»Šå¤©ç»•ç€å®¶æ»‘äº†ä¸€åœˆï¼Œä¸å¾—ä¸åæ§½ä¸‹å†œæ‘çš„æ°´æ³¥è·¯ï¼Œæœ‰äº›è·¯æ®µæ¨ªæ¡çº¹å¤ªå¤šäº†ï¼Œè„šåœ¨ä¸Šæ»‘è¿‡æ—¶ï¼Œé¢ çš„æˆ‘è„šéƒ½éº»äº†ï¼Œç«™éƒ½ç«™ä¸ç¨³äº†ï¼Œç‰¹åˆ«å®¹æ˜“æ‘”ï¼ˆä¸è¿‡ï¼Œåè¿‡æ¥æƒ³å¥½åƒä¹Ÿèƒ½é”»ç‚¼ä¸€ä¸‹å¹³è¡¡æ„Ÿï¼ŸðŸ¤”ï¼‰ã€‚æ²¡æœ‰æ¨ªæ¡çº¹çš„è·¯æ®µï¼Œé‚£æ»‘çš„å°±å¾ˆèˆ’æœäº†ï¼Œè„šä¸Šæ²¡æœ‰é¢ ç°¸æ„Ÿï¼Œå¾ˆç¨³å½“ï¼Œç´¯äº†å°±å¹³è¡¡å‰æ»‘æºœä¸€ä¸‹ï¼Œç„¶åŽå†æ»‘ï¼Œå½“ç„¶æ»‘çš„æ—¶é—´å¤ªé•¿äº†ï¼Œä¹Ÿè¿˜æ˜¯è¦ä¼‘æ¯ä¸‹çš„ã€‚ å‰å‡ å¤©ç»ƒä¹ è½¬å¼¯ä¸€ç‚¹æ„Ÿè§‰æ²¡æœ‰ï¼Œä»Šå¤©å°è¯•äº†ä¸‹ï¼Œå¥½åƒæœ‰ç‚¹æ„Ÿè§‰ï¼Œå°±è·Ÿäººèµ°è·¯è½¬å¼¯ä¸€æ ·ï¼Œä¸ç”¨éžå¾—ä¸åŠ¨ï¼Œå¯ä»¥è¿ˆå°æ­¥æ»‘è¿‡å¼¯ã€‚ è¿˜æœ‰ä¸€ç‚¹æ—¶è§‰å¾—è‡ªå·±ä½“åŠ›ä¸å¤ªå¤Ÿï¼Œæ»‘ä¸äº†å¤ªè¿œå°±è§‰å¾—è…°é…¸ï¼Œè¿™æ˜¯ä»€ä¹ˆâ€œæ¯›ç—…â€ï¼Ÿè¿˜æ˜¯æˆ‘çš„å§¿åŠ¿æœ‰äº›ä¸åˆ°ä½ï¼Œä½¿å¾—æˆ‘çš„è…°è‚Œè´Ÿè·è¿‡å¤§ï¼Œæ‰€ä»¥å¾ˆå¿«å°±è§‰å¾—ç´¯äº†ï¼Ÿ æ—¥æœŸï¼š2021-11-18ä»Šå¤©æ»‘çš„å¾ˆç´¯ï¼Œä½†æ˜¯æ„Ÿè§‰å¾ˆå¥½ï¼ŒçŽ°åœ¨å¤§æ¦‚èƒ½æŒç»­æ»‘è¡Œæ¯”è¾ƒä¹…äº†ï¼Œå¯¹äºŽä¹‹å‰çš„é—®é¢˜ï¼Œä»Šå¤©å¯ä»¥ç¨å¾®å›žç­”ä¸€ä¸‹äº†ï¼š æ»‘ä¸äº†å¤ªè¿œå°±è§‰å¾—ç´¯ï¼Œæ˜¯ä¸æ˜¯å§¿åŠ¿ä¸å¯¹ï¼Ÿå‡†ç¡®æ¥è®²ï¼Œä¸æ˜¯å§¿åŠ¿ä¸å¯¹ï¼Œè€Œæ˜¯å§¿åŠ¿ç»´æŒçš„å¤ªä¹…äº†ã€‚æ»‘è¡Œçš„æ—¶å€™ï¼Œä¸ºäº†ä¿æŒèº«ä½“çš„å¹³è¡¡æ„Ÿï¼Œä¸€èˆ¬ä¼šç•¥å¾®å±ˆè†ï¼Œèº«ä½“å‰å€¾ã€‚å¾ˆæ˜¾ç„¶ï¼Œå³ä¾¿æ²¡æœ‰ç©¿è½®æ»‘éž‹ï¼Œå°±åœ¨å¹³åœ°ä¸Šç»´æŒè¿™ä¸ªå§¿åŠ¿ä¹Ÿå¾ˆç´¯ï¼Œæ›´ä½•å†µæ˜¯ç©¿äº†è½®æ»‘éž‹ã€‚æ‰€ä»¥ï¼Œåº”è¯¥åœ¨æ»‘è¡Œçš„æ—¶å€™åº”è¯¥è¦ç›´ç«‹èµ·æ¥ï¼Œå½“ç„¶äº†ï¼Œç›´ç«‹å¿…é¡»è¦å»ºç«‹åœ¨ç»´æŒäº†å¹³è¡¡çš„åŸºç¡€ä¸Šï¼Œä¸ç„¶å°±æ‘”è·¤äº†ã€‚è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯ï¼Œèº«ä½“å°½å¯èƒ½çš„è¦æ”¾æ¾ï¼Œä¸è¦å¤ªåƒµç¡¬äº†ï¼Œè‚Œè‚‰å¤ªç´§å¼ äº†ï¼Œä¹Ÿä¼šå®¹æ˜“äº§ç”Ÿç–²åŠ³ã€‚ å¦‚ä½•è½¬å¼¯ï¼Ÿè½¬å¼¯å…¶å®žå¯ä»¥è¾¹æ»‘è¾¹è½¬ï¼ˆåªè¦æ­¥å­è¿ˆå°ç‚¹ï¼‰ï¼Œä¹Ÿå¯ä»¥æ»‘ç€è½¬ã€‚æ»‘ç€è½¬å…¶å®žå°±æ˜¯ A å­—è½¬å¼¯ï¼Œè¿™ä¸ªåŠ¨ä½œçš„é‡ç‚¹åœ¨äºŽè¦ä½¿ç”¨éž‹å­çš„å†…åˆƒï¼Œè‡³äºŽè…¿ç»·ç´§å…¶å®žåªæ˜¯è¾…åŠ©çš„ä½œç”¨ã€‚å¾€é‚£è¾¹è½¬ï¼Œå°±ç”¨é‚£åªè„šçš„éŸ§ã€‚ è¯è¯´ï¼Œä»Šå¤©å°è¯•äº†ä¸‹å†²å¡ï¼Œæžœç„¶ï¼Œä¸¤æ¬¡éƒ½æ‘”äº†ã€‚è¿˜æœ‰ä¸€æ¬¡ï¼Œæ»‘äº†å¤ªä¹…ï¼Œå¾ˆç´¯ï¼Œè„šçªç„¶ä¸€ä¸‹æ²¡åŠ²äº†ï¼Œç›´æŽ¥æ ½è‰ä¸›é‡Œäº†ï¼Œ2333ã€‚å¯¹äº†ï¼Œä»Šå¤©æœ‰å¥½å‡ æ¬¡å·®ç‚¹è¦æ‘”è·¤ï¼Œç»“æžœéƒ½å¥‡æ€ªçš„ç¨³ä½äº†ï¼Œå¾ˆè¯§å¼‚ï¼Œåº”è¯¥æ˜¯èº«ä½“å¯¹è¿™ç§å¤±åŽ»å¹³è¡¡çš„æ„Ÿè§‰é€‚åº”äº†ä¸€äº›å§ã€‚ ä»Šå¤©åŸºæœ¬æ²¡åœè¿‡ï¼Œä¸€ç›´åœ¨æ»‘ï¼Œæ»‘äº†å¤§æ¦‚ 3 ä¸ªå°æ—¶ï¼Œæœ€åŽä¸€ä¸ªå°æ—¶åŽ»è¡—ä¸ŠçŽ©äº†ä¸€ä¸‹ï¼Œæ„Ÿè§‰è¿˜è¡Œï¼Œä¹Ÿä¸æ˜¯å¾ˆéš¾ã€‚æœ€åŽï¼Œè„±ä¸‹éž‹å­çš„é‚£ä¸€åˆ»æ˜¯çœŸçš„æ„Ÿè§‰å…¨èº«æœ‰ç‚¹é…¸äº†ï¼Œå‡ºæ±—çš„æ„Ÿè§‰è¿˜æ˜¯å¥½å•Šã€‚ æ—¥æœŸï¼š2021-11-19å°è¯•äº†ä¸€ä¸‹â€œé•¿é€”â€æ»‘è¡Œï¼Œä¸€åŽ»ä¸€æ¥ï¼Œä¸€èµ·æ˜¯ 10 å…¬é‡Œï¼ŒèŠ±äº†å¤§æ¦‚ 1 ä¸ªå°æ—¶ï¼Œçœ‹æ¥çŽ°åœ¨è‡ªå·±çš„æ»‘è¡Œé€Ÿåº¦å¤§æ¦‚ä¹Ÿå°± 8 - 10 km/h äº†å§ï¼Œè¿™ä¸ªé€Ÿåº¦å…·ä½“æ˜¯ä»€ä¹ˆæ ·å­çš„å‘¢ï¼Ÿå°±è·Ÿæ…¢æ…¢éª‘è‡ªè¡Œè½¦ä¸€æ ·ã€‚ æ•´ä¸ªæ»‘è¡Œè¿‡ç¨‹æ˜¯åœ¨å›½é“å…¬è·¯ä¸Šè¿›è¡Œçš„ï¼Œè™½ç„¶æ˜¯åœ¨åœ¨å…¬è·¯è¾¹ä¸Šæ»‘è¡Œï¼Œä½†ä¹Ÿè¦æ³¨æ„åŽæ–¹çš„è½¦è¾†ï¼Œæ³¨æ„ä¸è¦åå‘æ»‘è¡Œï¼Œè¦éµå®ˆåŸºæœ¬çš„äº¤é€šè§„åˆ™ï¼Œè¦æˆ´å¥½æŠ¤å…·ã€‚å…¬è·¯æ»‘è¡Œçš„æ—¶å€™ï¼Œè¦å°å¿ƒè·¯ä¸Šçš„å°çŸ³å¤´ï¼Œå½“é€Ÿåº¦è¿‡å¿«çš„æ—¶å€™ï¼Œè½®å­ä¸€æ—¦ç¢°åˆ°è¿™äº›çŸ³å¤´å°±ä¼šçªç„¶åƒå‰å†²ä¸€ä¸‹ï¼Œå®¹æ˜“æ‘”è·¤ï¼Œæ‰€ä»¥è¦å°å¿ƒã€æ…¢é€Ÿã€‚æ¯å½“è¿™ä¸ªæ—¶å€™ï¼Œæˆ‘å°±åŽæ‚”ä¸ºä»€ä¹ˆæ²¡æœ‰ä¹°æŠ¤å…·ã€‚è¯´å®žåœ¨çš„ï¼Œå¦‚æžœæ˜¯é«˜é€Ÿå…¬è·¯çš„è¯ï¼ŒåŸºæœ¬ä¸ä¼šæœ‰è¿™ç§é—®é¢˜ï¼Œç›¸æ¯”å›½é“è€Œè¨€ï¼Œé«˜é€Ÿå…¬è·¯äº§ç”Ÿçš„æ‘©æ“¦åŠ›ä¹Ÿä¼šå°å¾ˆå¤šï¼Œä¹Ÿä¼šæ›´åŠ çœåŠ›ã€‚ä½†é—æ†¾çš„æ˜¯ï¼Œé‚£æ˜¯é«˜é€Ÿå…¬è·¯ï¼Œä¸æ˜¯é«˜é€Ÿâ€œæ»‘é“â€ï¼Œè¿™è·¯æ˜¯ç»™è½¦è·‘çš„ã€‚ ä»Žæ‹¿åˆ°è½®æ»‘éž‹åˆ°ä»Šå¤©ä¸ºæ­¢ï¼Œå·®ä¸å¤šä¸€å‘¨äº†å§ï¼ŒåŸºæœ¬çš„æ»‘è¡Œä¸Žä¸œè¥¿å¥½åƒæŽŒæ¡äº†ï¼Œä½†è¿˜ä¸æ˜¯å¾ˆç‰¢å›ºã€‚è¿™ä¸¤å¤©åœ¨è¡—ä¸Šæ»‘è¡Œçš„åŠ¨ä½œå…¶å®žå·²ç»ä¸æ˜¯åˆšå¼€å§‹å­¦çš„æŽ¨æ­¥æ»‘è¡Œäº†ï¼Œä¹‹å‰ä¸€ç›´è§‰å¾—è‡ªå·±æ€»æ˜¯å–œæ¬¢ç”¨å†…åˆƒï¼ŒçŽ°åœ¨å‘çŽ°ï¼Œåœ¨è¡—ä¸Šæ»‘è¡Œçš„æ—¶å€™ï¼Œè„šå…¶å®žæ˜¯æœ‰ä¸€ä¸ªä¸Šå‰è¹¬çš„åŠ¨ä½œçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œä¸¤è„šäº¤æ›¿æ»‘è¡Œçš„æ—¶å€™ï¼Œå…¶å®žæ˜¯åœ¨äº¤æ›¿å‘å‰è¹¬ï¼Œè¿™æ—¶ä¹Ÿå°±å¿…ç„¶ä¼šæœ‰ä¸€åªè„šåœ¨å‰æ–¹ï¼Œä¸€åªè„šåœ¨åŽæ–¹ï¼Œå¾ˆæ˜¾ç„¶ï¼Œåœ¨åŽé¢çš„é‚£åªè„šè¹¬åœ°çš„æ—¶å€™ï¼Œå°±ä¼šç”¨åˆ°å†…åˆƒã€‚ æ€»ä½“è€Œè¨€ï¼Œæ»‘è¡Œæ—¶é—´ä¸é•¿ï¼Œä½†æˆ‘æ€»è§‰å¾—è½®æ»‘è¿™ä¸ªä¸œè¥¿ç†è®ºå  40%ï¼Œå®žé™…å  60%ï¼Œæ›´å¤šè¿˜æ˜¯è¦é èº«ä½“åŽ»æ„Ÿå—ï¼Œè¦é èº«ä½“åŽ»ç†Ÿæ‚‰è¸©åœ¨è½®å­ä¸Šçš„å¹³è¡¡æ„Ÿï¼Œæ„Ÿè§‰è‡ªå·±å…¶å®žç®—æ˜¯æ»‘ç€æ»‘ç€å°±ä¼šäº†ï¼Œä¹Ÿæ²¡æœ‰è¿‡åˆ†çš„åŽ»è¿½æ±‚åŠ¨ä½œå§¿åŠ¿ï¼Œæ›´å¤šçš„è¿˜æ˜¯é èº«ä½“æ„Ÿå—å¹³è¡¡ã€‚ä¸è¿‡ï¼Œåœ¨æ»‘è¡Œè¿‡ç¨‹ä¸­ï¼Œå§¿åŠ¿ä¹Ÿè¿˜æ˜¯è¦å°½é‡ä¿æŒæ­£ç¡®çš„ï¼Œå› ä¸ºè¿™æ ·å¯ä»¥æ»‘çš„æ›´å¿«ã€æ›´çœåŠ›ã€‚å¦å¤–è¿˜æœ‰ä¸€ç‚¹å°±æ˜¯ï¼ŒæŠ¤å…·æ˜¯éœ€è¦çš„ï¼Œæˆ‘å‘è§‰æˆ‘æ²¡æˆ´æŠ¤å…·å°±æ•¢åŽ»è¡—ä¸Šæµªï¼Œå®žåœ¨æ˜¯å¤ªèŽ½äº†ï¼ŒçœŸçš„æ˜¯â€œè‰ºé«˜äººèƒ†å¤§â€ã€‚å› ä¸ºæ²¡æœ‰æŠ¤å…·ï¼Œä¹Ÿæœ‰ç‚¹æ€•åšå‡ åå…¬é‡Œçš„é•¿é€”æ»‘è¡Œï¼Œæ¯•ç«Ÿè¿˜æ˜¯å®‰å…¨ä¸ºé‡ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Sport</category>
      </categories>
      <tags>
        <tag>Skating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS è¯¾ç¨‹ä¸‹çš„æ±‡ç¼–ç¬”è®°]]></title>
    <url>%2F2021%2F11%2F11%2FHIT-OS-%E8%AF%BE%E7%A8%8B%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æ­¤æ–‡ç”¨æ¥è®°å½•åœ¨è¿›è¡Œ HIT_OS è¯¾ç¨‹æ—¶ï¼Œé‡åˆ°çš„ä¸€äº›è·Ÿæ±‡ç¼–è¯­è¨€ç›¸å…³çš„é—®é¢˜ï¼ˆçº¯æ±‡ç¼–å°ç™½è§’åº¦ï¼‰ã€‚ æ³¨æ„ï¼šä»¥ä¸‹å†…å®¹éƒ½æ˜¯ x86 æœºå™¨ä¸‹çš„æ±‡ç¼–çŸ¥è¯†ã€‚ entryentryæ˜¯æ±‡ç¼–è¯­è¨€ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œå‘Šè¯‰ cpu è¿™æ®µæ±‡ç¼–ç¨‹åºçš„å…¥å£æ˜¯ä»€ä¹ˆï¼Œä¸€èˆ¬è€Œè¨€ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯æ±‡ç¼–ç¨‹åºå…¥å£ã€‚ movmovæ˜¯æ•°æ®ä¼ é€æŒ‡ä»¤ï¼Œä¹Ÿæ˜¯æœ€åŸºæœ¬çš„æ±‡ç¼–ç¼–ç¨‹æŒ‡ä»¤ï¼Œç”¨äºŽå°†ä¸€ä¸ªæ•°æ®ä»Žæºåœ°å€ä¼ é€åˆ°ç›®æ ‡åœ°å€ï¼ˆå¯„å­˜å™¨ä¹‹é—´çš„æ•°æ®ä¼ é€æœ¬è´¨ä¸Šä¹Ÿæ˜¯ä¸€æ ·ï¼‰ï¼Œå…¶ç‰¹ç‚¹æ˜¯ä¸ç ´åæºåœ°å€å•å…ƒçš„å†…å®¹ï¼ˆå±žäºŽå¤åˆ¶æ€§è´¨ï¼Œä¸å±žäºŽæ¬å®¶æ€§è´¨ï¼‰ï¼ŒåŸºæœ¬ç”¨æ³•ï¼š123! mov dst,src mov EAX,#050aH ;å°†åå…­è¿›åˆ¶æ•° 050a ä¼ é€åˆ°é€šç”¨å¯„å­˜å™¨ EAX ä¸­ mov DI,BX ;å¯„å­˜å™¨ä¹‹é—´ä¼ æ•° æ³¨æ„ mov çš„ä¸¤ä¸ªæ“ä½œæ•°ä¸èƒ½åŒæ—¶ä¸ºæ®µå¯„å­˜å™¨ï¼Œå…¶ä»–æ³¨æ„äº‹é¡¹ç­‰å†…å®¹å‚è€ƒç™¾åº¦ç™¾ç§‘ï¼šMOVã€‚ xorè¿™ä¸ªæ²¡å•¥è¯´çš„ï¼Œå¼‚æˆ–æ“ä½œï¼ŒC è¯­è¨€ä¸­å‡ºçŽ°è¿‡çš„ä¸œè¥¿ã€‚ä¸è¿‡åœ¨æ±‡ç¼–è¿™é‡Œå¥½åƒç”¨çš„å¾ˆå¤šï¼Ÿ ax ah alax æ˜¯ cpu å†…éƒ¨ä¸€ä¸ªå¯„å­˜å™¨åŠ©è®°ç¬¦ï¼Œé€šå¸¸ç§°ä¹‹ä¸ºç´¯åŠ å™¨ã€‚ä»¥è¿™é—¨è¯¾ä¸Šçš„ 16 ä½ cpu ä¸ºä¾‹ï¼Œahï¼ˆa highï¼‰ å°±æ˜¯ ax çš„é«˜å…«ä½ï¼Œalï¼ˆa lowï¼‰ å°±æ˜¯ ax çš„ä½Žå…«ä½ã€‚é€šä¿—æ¥è®²ï¼Œè‹¥ ax=1234hï¼Œé‚£ä¹ˆ ah=12hï¼Œal=34hã€‚å¯¹åº”çš„ï¼Œå…¶ä»–å¯„å­˜å™¨ä¸€æ ·ä¹Ÿæœ‰ä¸Žå…¶å¯¹åº”çš„ h å’Œ lã€‚ intint åº”è¯¥æ˜¯æ±‡ç¼–ä¸­ä¸“é—¨ç”¨æ¥è°ƒç”¨ä¸­æ–­çš„ä¸€ä¸ªæŒ‡ä»¤ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯å„ç§å„æ ·çš„â€œä¸­æ–­ç â€ï¼Œä¸åŒçš„â€œä¸­æ–­ç â€å®žçŽ°çš„åŠŸèƒ½ä¸ä¸€æ ·ã€‚ åŸºåœ°å€ä¸Žæ®µåœ°å€å¯¹ä¸€ä¸ªç¨‹åºè€Œè¨€ï¼ŒåŸºåœ°å€å°±æ˜¯è¿™ä¸ªç¨‹åºè¢«æœºå™¨æ‰§è¡Œæ—¶æœºå™¨æ‰€éœ€è¦çš„â€œä¸œè¥¿â€ï¼ˆå¯ä»¥æ˜¯æ•°æ®ä¹Ÿå¯ä»¥ä»£ç æ®µç­‰?ï¼‰çš„åœ°å€ï¼ŒåŸºåœ°å€å°±æ˜¯è¿™ä¸ªè¿™ä¸ªç¨‹åºçš„â€œæ®µâ€çš„èµ·å§‹åœ°å€ï¼Œè€Œæœºå™¨è¦æ‹¿åˆ°è¿™äº›â€œä¸œè¥¿â€å°±éœ€è¦æ®µåœ°å€ã€‚æ¢å¥è¯è¯´ï¼ŒåŸºåœ°å€å…¶å®žè·Ÿæ®µåœ°å€æ˜¯ç±»ä¼¼çš„ä¸œè¥¿ã€‚å…·ä½“çš„ç†è§£å‚è€ƒç™¾ç§‘è¿™ä¸ªå›žç­”ï¼šä»€ä¹ˆæ˜¯åŸºåœ°å€å’Œæ®µåœ°å€ï¼Ÿä¸»è¦ç”¨é€”æ˜¯ï¼Ÿ æ±‡ç¼–ä¸­çš„ ## åœ¨æ±‡ç¼–ä¸­è¡¨ç¤ºç«‹å³å¯»å€ï¼Œä¸¾ä¸ªç®€å•çš„ä¾‹å­ï¼š1mov A,#21H è¯¥æŒ‡ä»¤çš„æ„æ€æ˜¯å°†å€¼ 21H é€ç»™å¯„å­˜å™¨ A ä¸­æš‚å­˜ï¼Œå¦‚æžœæŠŠ#åŽ»æŽ‰ï¼Œé‚£ä¹ˆæ„æ€å°±æ˜¯å°†åœ°å€ 21H é‡Œé¢çš„å†…å®¹é€ç»™å¯„å­˜å™¨ A äº†ã€‚ æ±‡ç¼–ä¸­çš„ .å‚è€ƒé“¾æŽ¥ï¼šARMä¸­çš„æ±‡ç¼–æŒ‡ä»¤ã€‚ å§‘ä¸”è®¤ä¸º.byteã€.textè¿™ç±»æŒ‡ä»¤æ˜¯ GNU çš„ä¼ªæ±‡ç¼–æŒ‡ä»¤ã€‚å¦å¤–ï¼Œä¸Šè¿°æ–‡ç« ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–æŒ‡ä»¤çš„ä»‹ç»ï¼Œä¹Ÿå¯ä»¥ç®—ä½œå‚è€ƒèµ„æ–™ã€‚ x86 ä¸‹çš„å¯„å­˜å™¨å‚è€ƒæ–‡ç« é‡Œé¢å†™çš„å·²ç»å¾ˆæ¸…æ¥šäº†ï¼Œä½†æˆ‘ä»¬ç›®å‰éœ€è¦äº†è§£çš„ä¸œè¥¿æ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æœ‰å¤šå°‘ä¸ªå¯„å­˜å™¨ï¼Œåå­—å«ä»€ä¹ˆã€‚8086çš„ç¼–ç¨‹æ¨¡åž‹åŒ…æ‹¬ 8ã€16 å’Œ 32 ä½çš„å¯„å­˜å™¨,æŒ‰ç…§ä½åˆ†ç±»ï¼š 8 ä½çš„å¯„å­˜å™¨åŒ…æ‹¬ AHï¼ŒALï¼ŒBHï¼ŒBLï¼ŒCHï¼ŒCLï¼ŒDH å’Œ DLã€‚ 16 ä½å¯„å­˜å™¨åŒ…æ‹¬ AXï¼ŒBXï¼ŒCXï¼ŒDXï¼ŒSPï¼ŒBPï¼ŒDIï¼ŒSIï¼ŒIPï¼ŒFLAGSï¼ŒCSï¼ŒDSï¼ŒESï¼ŒSSï¼ŒFSï¼Œå’Œ GSã€‚ æ‰©å±•çš„ 32 ä½çš„æŒ‡ä»¤åŒ…æ‹¬ EAXï¼ŒEBXï¼ŒECXï¼ŒEDXï¼ŒESPï¼ŒEBPï¼ŒEDIï¼ŒESIï¼ŒEIP å’Œ EFLAGSã€‚ æ‰€æœ‰çš„ 32 ä½å¯„å­˜å™¨å’Œ 16 ä½å¯„å­˜å™¨ä¸­çš„ FS æˆ–è€… GS éƒ½ä»…ä»…èƒ½å¤Ÿåœ¨ 80386 ä»¥ä¸Šä½¿ç”¨ã€‚ å‚è€ƒæ–‡ç« ï¼šIntel 80X86å¯„å­˜å™¨åˆ†ç±»ä»‹ç» CFCF æ˜¯æ±‡ç¼–ä¸­çš„è¿›ä½æ ‡å¿—ä½ï¼Œä¸»è¦ç”¨æ¥åæ˜ è¿ç®—æ˜¯å¦äº§ç”Ÿè¿›ä½æˆ–é”™ä½ã€‚å¦‚æžœè¿ç®—ç»“æžœçš„æœ€é«˜ä½äº§ç”Ÿäº†ä¸€ä¸ªè¿›ä½æˆ–é”™ä½ï¼Œå…¶å€¼å°±ä¸º 1ã€‚ä¸Žä¹‹å¯¹åº”çš„æ˜¯ä¸¤ä¸ªè·³è½¬æŒ‡ä»¤ï¼š jc å’Œ jncï¼Œå‰è€…å½“ CF=1 æ—¶ï¼Œè·³è½¬ï¼ŒåŽè€…åä¹‹ã€‚ jncè¿™æ¡è¯­å¥çš„åŠŸèƒ½æœ‰ç‚¹ç±»ä¼¼ C è¯­è¨€ä¸­çš„ gotoï¼Œä½†å®ƒä¸Ž goto ä¸åŒçš„åœ°æ–¹åœ¨äºŽï¼Œå®ƒéœ€è¦æœ‰ä¸€ä¸ªè¿›ä½ã€‚æ¢å¥è¯è¯´ï¼Œjnc xxxè¿™æ¡è¯­å¥ä¹‹å‰ä¼šæœ‰è¿ç®—ï¼Œè¿ç®—çš„ç»“æžœä¼šå½±å“ CF çš„å€¼ã€‚å½“ CF=0 æ—¶ï¼Œå®ƒå°±ä¼šäº§ç”Ÿä¸Ž goto ä¸€æ ·çš„åŠŸèƒ½ï¼Œåä¹‹ï¼Œå°±è·³è¿‡è¿™æ¡è¯­å¥ï¼Œå°±æ˜¯ continue çš„åŠŸèƒ½äº†ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS_Basic]]></title>
    <url>%2F2021%2F11%2F10%2FHIT-OS-Basic%2F</url>
    <content type="text"><![CDATA[æ­¤ç³»åˆ—åšæ–‡ç”¨æ¥è®°å½• MOOC ä¸Šè‡ªå­¦å“ˆå·¥å¤§æ“ä½œç³»ç»Ÿè¯¾ç¨‹ï¼ˆç”±æŽæ²»å†›è€å¸ˆæŽˆè¯¾ï¼‰æ—¶çš„ç¬”è®°ã€‚ L1è¿™ä¸€èŠ‚è¯¾ä¸»è¦æ˜¯è€å¸ˆè¯´æ˜Žå­¦ä¹ è¯¾ç¨‹çš„ç›®çš„å’Œæœ¬è¯¾ç¨‹çš„è¦æ±‚ã€‚å¦å¤–ï¼Œå°±æ˜¯åœ¨å®žéªŒæ¥¼ç†Ÿæ‚‰ä¸‹å®žéªŒçŽ¯å¢ƒã€‚ L2è¿™ä¸€è®²è€å¸ˆä¸»è¦æ˜¯åœ¨è¯´æ˜Žç”µè„‘æŽ¥é€šç”µæºåŽåœ¨åšäº›ä»€ä¹ˆäº‹æƒ…ã€‚ å…³äºŽç»„æˆè®¡ç®—æœºçš„äº”å¤§éƒ¨ä»¶ï¼ˆè¿™åˆæ˜¯è€ç”Ÿå¸¸è°ˆäº†ï¼‰ï¼šè¾“å…¥è®¾å¤‡ã€è¾“å‡ºè®¾å¤‡ã€å­˜å‚¨å™¨ã€è¿ç®—å™¨ã€æŽ§åˆ¶å™¨ã€‚è®¡ç®—æœºçš„å·¥ä½œæ–¹å¼ï¼šå–æŒ‡æ‰§è¡Œï¼Œâ€œæŒ‡â€å®žé™…ä¸ŠæŒ‡çš„æ˜¯æŒ‡é’ˆï¼Œè¿™ä¸ªæŒ‡é’ˆæŒ‡å‘çš„æ˜¯ä½äºŽå†…å­˜ä¸­çš„å‘½ä»¤ã€‚è¿™ä¸ªæ¦‚å¿µåº”è¯¥è´¯ç©¿äº†æ•´ä¸ªæ“ä½œç³»ç»Ÿçš„è®¾è®¡ã€‚ ç†Ÿæ‚‰ä¸€ä¸‹å®žéªŒæ¥¼çš„åŸºæœ¬æ“ä½œï¼š12345678910111213141516171819202122232425262728293031323334353637383940# è§£åŽ‹æ–‡ä»¶$ cd oslab$ tar -zxvf hit-oslab-linux-20110823.tar.gz -C /home/shiyanlou/# ç¼–è¯‘å†…æ ¸$ cd linux-0.11$ make all # all å¯çœç•¥ï¼Œæœ‰æ—¶éœ€è¦å…ˆ make clean # è¿è¡Œå†…æ ¸$ cd ~/oslab # éœ€è¦å† run è¿™ä¸ªè„šæœ¬æ–‡ä»¶æ‰€åœ¨çš„ç›®å½•ä¸‹$ ./run # æ‰§è¡Œè¿™æ¡å‘½ä»¤åŽä¼šå‡ºçŽ° Bochs çš„çª—å£# æ±‡ç¼–è°ƒè¯•$ cd ~/oslab # åŒæ ·éœ€è¦åœ¨è¿™ä¸ªç›®å½•ä¸‹$ ./dbg-asm # å¯ä»¥ä½¿ç”¨ help æ¥æŸ¥çœ‹è°ƒè¯•ç³»ç»Ÿçš„å‘½ä»¤# C è¯­è¨€è°ƒè¯•ï¼Œéœ€è¦ä½¿ç”¨ä¸¤ä¸ªçª—å£ã€‚# ç¬¬ä¸€ä¸ªçª—å£$ cd \~/oslab$ ./dbg-c# ç¬¬äºŒä¸ªçª—å£$ cd \~/oslab$ ./rungdb# æ–‡ä»¶äº¤æ¢$ cd ~/oslab$ sudo ./mount-hdc # å…ˆæŒ‚è½½$ cd hdc$ ls -l# æ­¤æ—¶çœ‹åˆ°çš„æ–‡ä»¶å°±æ˜¯ hdc-0.11.img è¿™ä¸ªé•œåƒæ–‡ä»¶å†…çš„æ–‡ä»¶$ cd ~/oslab$ sudo umount hdc # è¯»å†™å®Œæ¯•åŽè¦å¸è½½# 1. æ³¨æ„ä¸è¦åœ¨è¯»å†™å†…æ ¸æ–‡ä»¶æ—¶è¿è¡Œå†…æ ¸ï¼Œä¹Ÿä¸è¦åœ¨è¿è¡Œå†…æ ¸æ—¶è¯»å†™å†…æ ¸å†…çš„æ–‡ä»¶# 2. å…³é—­ Bochs ä¹‹å‰ï¼Œè¦å…ˆæ‰§è¡Œä¸€ä¸‹ `sync` ä¿å­˜ä¸€ä¸‹ L3è¿™ä¸€è®²è€å¸ˆä¸»è¦è®²äº†æ“ä½œç³»ç»Ÿå¯åŠ¨æ—¶åšçš„ä¸¤ä»¶äº‹ï¼š è¯»å…¥ç³»ç»Ÿ å®Œæˆåˆå§‹åŒ– å…·ä½“å¦‚ä½•è¿›è¡Œéœ€è¦å€ŸåŠ©ä»£ç åˆ†æžã€‚ Experiment 1å®žéªŒé¡¹ç›® 1 çš„ä¸»é¢˜æ˜¯æŽ§åˆ¶ç³»ç»Ÿçš„å¯åŠ¨ï¼Œä¸»è¦åŒ…å«çš„å†…å®¹ï¼š é˜…è¯»ã€ŠLinux å†…æ ¸å®Œå…¨æ³¨é‡Šã€‹çš„ç¬¬ 6 ç« ï¼Œå¯¹è®¡ç®—æœºå’Œ Linux 0.11 çš„å¼•å¯¼è¿‡ç¨‹è¿›è¡Œåˆæ­¥çš„äº†è§£ï¼› æŒ‰ç…§ä¸‹é¢çš„è¦æ±‚æ”¹å†™ 0.11 çš„å¼•å¯¼ç¨‹åº bootsect.s æœ‰å…´è¶£åŒå­¦å¯ä»¥åšåšè¿›å…¥ä¿æŠ¤æ¨¡å¼å‰çš„è®¾ç½®ç¨‹åº setup.sã€‚ æ”¹å†™ bootsect.s ä¸»è¦å®Œæˆå¦‚ä¸‹åŠŸèƒ½ï¼šbootsect.s èƒ½åœ¨å±å¹•ä¸Šæ‰“å°ä¸€æ®µæç¤ºä¿¡æ¯â€œXXX is bootingâ€¦â€ï¼Œå…¶ä¸­ XXX æ˜¯ä½ ç»™è‡ªå·±çš„æ“ä½œç³»ç»Ÿèµ·çš„åå­—ï¼Œä¾‹å¦‚ LZJosã€Sunix ç­‰ï¼ˆå¯ä»¥ä¸Šè®ºå›ä¸Šç§€ç§€è°çš„ OS åå­—æœ€å¸…ï¼Œä¹Ÿå¯ä»¥æ˜¾ç¤ºä¸€ä¸ªç‰¹è‰² logoï¼Œä»¥è¡¨ç¤ºè‡ªå·±æ“ä½œç³»ç»Ÿçš„ä¸Žä¼—ä¸åŒã€‚ï¼‰ æ”¹å†™ setup.s ä¸»è¦å®Œæˆå¦‚ä¸‹åŠŸèƒ½ï¼š bootsect.s èƒ½å®Œæˆ setup.s çš„è½½å…¥ï¼Œå¹¶è·³è½¬åˆ° setup.s å¼€å§‹åœ°å€æ‰§è¡Œã€‚è€Œ setup.s å‘å±å¹•è¾“å‡ºä¸€è¡Œâ€Now we are in SETUPâ€ã€‚ setup.s èƒ½èŽ·å–è‡³å°‘ä¸€ä¸ªåŸºæœ¬çš„ç¡¬ä»¶å‚æ•°ï¼ˆå¦‚å†…å­˜å‚æ•°ã€æ˜¾å¡å‚æ•°ã€ç¡¬ç›˜å‚æ•°ç­‰ï¼‰ï¼Œå°†å…¶å­˜æ”¾åœ¨å†…å­˜çš„ç‰¹å®šåœ°å€ï¼Œå¹¶è¾“å‡ºåˆ°å±å¹•ä¸Šã€‚ setup.s ä¸å†åŠ è½½ Linux å†…æ ¸ï¼Œä¿æŒä¸Šè¿°ä¿¡æ¯æ˜¾ç¤ºåœ¨å±å¹•ä¸Šå³å¯ã€‚ æ”¹å†™ bootsect.sè¿™ä¸ªä»»åŠ¡æ¯”è¾ƒå®¹æ˜“ï¼Œå› ä¸ºè€å¸ˆä¸Šè¯¾çš„æ—¶å€™å¤§è‡´ä¸Šè®²è¿‡äº†ï¼Œæ‰€ä»¥åªéœ€è¦æŒ‰ç…§è€å¸ˆç»™çš„æç¤ºæ¥å®Œæˆå°±è¡Œäº†ã€‚å…ˆæŠŠå®žéªŒçŽ¯å¢ƒæŒ‰ç…§ä¸Šä¸ªå®žéªŒçš„æ­¥éª¤å¼„å¥½ï¼Œè§£åŽ‹æ–‡ä»¶ã€‚ å…ˆæ‰¾åˆ° bootsect.s123$ cd linux-0.11/boot/$ ls$ vim bootsect.s è¿›å…¥ bootsect.s çš„ç¼–è¾‘é¡µé¢åŽèƒ½çœ‹åˆ° Linus 91å¹´å†™ä¸‹çš„è¯´æ˜Žï¼Œå……æ»¡äº†å¹´ä»£æ„Ÿã€‚æ˜ å…¥çœ¼ä¸­çš„å…¨æ˜¯æ±‡ç¼–ä»£ç ï¼Œå¯¹äºŽä¸æ‡‚æ±‡ç¼–çš„äººæ¥è¯´æœ‰ç‚¹éš¾å—ã€‚ä¸è¿‡æ²¡å…³ç³»ï¼Œæ‰¾åˆ°æŒ‡å®šä½ç½®ç„¶åŽä¿®æ”¹å°±è¡Œã€‚ é¦–å…ˆï¼Œè¦ä¿®æ”¹çš„æ–‡æœ¬çš„ä½ç½®æ˜¯åœ¨ bootsect.s æ–‡ä»¶å†…çš„ 244 - 247 è¡Œå¤„ï¼ˆç›´æŽ¥æ‰¾å°±è¡Œäº†ï¼‰ï¼š1234msg1: .byte 13,10 .ascii &quot;Loading system ...&quot; .byte 13,10,13,10 æ”¹ä¸ºè‡ªå·±å–œæ¬¢çš„å³å¯ï¼Œè¿™é‡Œæˆ‘ä»¬æ”¹ä¸ºï¼šcolor_os is booting ...ã€‚æŽ¥ç€æˆ‘ä»¬è¿˜éœ€è¦åœ¨ä¿®æ”¹ä¸€ä¸‹è¦æ˜¾ç¤ºçš„å­—ç¬¦ä¸ªæ•°ï¼Œé‚£ä¹ˆè¯¥å¦‚ä½•æ‰¾åˆ°ä»£ç ä½ç½®å‘¢ï¼Ÿå¯æƒ³è€ŒçŸ¥ï¼Œè¿™æ®µå­—ç¬¦ä¸²æ˜¯è¦åœ¨å¼€æœºçš„æ—¶å€™æ˜¾ç¤ºçš„ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå¼€æœºåŽçš„å…‰æ ‡å¹²çš„ç¬¬ä¸€ä»¶äº‹æƒ…å°±æ˜¯æ˜¾ç¤ºè¿™ä¸²å­—ç¬¦ï¼Œé‚£åªè¦æ‰¾åˆ°è¯»å…¥å…‰æ ‡çš„ä½ç½®å°±è¡Œäº†ï¼ˆå…¶å®žä¹Ÿå¯ä»¥ç›´æŽ¥ç”¨ vim çš„æœç´¢åŠŸèƒ½æ‰¾åˆ°ä¸Ž msg1 ç›¸å…³çš„åœ°æ–¹å°±å¯ä»¥äº†ï¼‰ã€‚ æŽ¥ä¸‹æ¥è¦ä¿®æ”¹çš„ä½ç½®æ˜¯åœ¨ 98 è¡Œå¤„ï¼š1mov cx,#24 ä¸Šé¢çš„è¿™ä¸ª24å®žé™…ä¸Šå°±æ˜¯ä¹‹å‰Loading system ...åŠ ä¸Š 3 ä¸ªæ¢è¡Œç¬¦ã€3 ä¸ªå›žè½¦ç¬¦çš„å’Œã€‚è¿™é‡Œï¼Œæ•°ä¸€ä¸‹ä¿®æ”¹åŽçš„å­—ç¬¦ä¸ªæ•°ï¼Œåº”è¯¥æ”¹ä¸º 29ã€‚ è¿™æ ·å°±å·®ä¸å¤šäº†ï¼Œæ¥å°è¯•ç¼–è¯‘è¿è¡Œä¸€ä¸‹:12$ cd linux-0.11$ make all æ²¡æœ‰é”™è¯¯æç¤ºå°±å¯ä»¥å°è¯•è¿è¡Œäº†ã€‚12$ cd ~/oslab$ ./run è§‚å¯Ÿç»“æžœå¯ä»¥å‘çŽ°å·²ç»æ”¹æˆæƒ³è¦çš„ç»“æžœäº†ã€‚ Reviewè¿™é‡Œæˆ‘ä»¬æŒ‰ç…§è€å¸ˆç»™çš„æç¤ºåœ¨å®Œæˆä¸€ä¸‹è¿™ä¸ªå®žéªŒã€‚æ ¹æ®è€å¸ˆçš„æç¤ºï¼Œå¯ä»¥å†™å‡º bootsect.s æœ€ç»ˆçš„æºç ï¼š1234567891011121314151617181920212223242526272829entry _start_start:! read cursor pos mov ah,#0x03 ï¼ ah need to be set as 03, so the bios interruption can check it xor bh,bh int 0x10! print the message we set mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ! es need to be set mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 è¿™é‡Œå†æ¥ç®€å•è§£é‡Šä¸€ä¸‹è¿™æ®µæ±‡ç¼–ä»£ç ï¼ˆæ¯•ç«Ÿæ²¡å­¦è¿‡æ±‡ç¼–ï¼Œå°±å½“å­¦æ±‡ç¼–äº†ï¼‰ï¼Œentryæ˜¯æ±‡ç¼–ä»£ç ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œç”¨æ¥æŒ‡ç¤ºæ±‡ç¼–ç¨‹åºçš„å…¥å£ï¼Œæ˜¾ç„¶ï¼Œåœ¨ä¸Šè¿°ä»£ç ä¸­ï¼Œå®ƒå‘Šè¯‰ cpu ç¨‹åºçš„å…¥å£æ˜¯ _startã€‚!åŽé¢çš„å†…å®¹å°±æ˜¯æ³¨é‡Šï¼Œmovã€xorè¿™æ ·çš„â€œæ ‡è¯†ç¬¦â€åœ¨æ±‡ç¼–é‡Œé¢å«åšæ“ä½œç ï¼ŒåŽé¢ç´§è·Ÿçš„å°±æ˜¯æ“ä½œæ•°ï¼ŒäºŒè€…ä¹‹é—´ç”¨ç©ºæ ¼éš”å¼€ï¼Œæ“ä½œæ•°ä¹‹é—´ç”¨,éš”å¼€ã€‚ bios 0x10 ä¸­æ–­æ ¹æ® ah çš„ä¸åŒçš„å€¼æ¥å‘æŒ¥ä¸åŒçš„åŠŸèƒ½ï¼ˆå…¶ä»– bios ä¸­æ–­å¯èƒ½ä¹Ÿæœ‰ï¼‰ã€‚ä¸åŒåŠŸèƒ½éœ€è¦çš„è¾“å…¥ä¸Žè¿”å›žéƒ½æ˜¯ä¸æƒ³åŒçš„ï¼Œè¿™éƒ¨åˆ†çš„å†…å®¹çš„ç–‘é—®å¯ä»¥æŸ¥è¯¢è€å¸ˆç»™çš„æ‰‹å†Œä¸Šçš„æ³¨é‡Šï¼Œä¹Ÿå¯ä»¥ç›´æŽ¥æŸ¥ bios ä¸­æ–­çš„æ‰‹å†Œã€‚ ä¹‹æ‰€ä»¥è¦æ”¹åŠ¨å¯„å­˜å™¨ es çš„å€¼ï¼Œæ˜¯å› ä¸º 0x10 ä¸­æ–­è§„å®šäº† es:bp æ˜¯å­—ç¬¦ä¸²çš„é¦–åœ°å€ï¼ˆä¹Ÿå°±æ˜¯èµ·å§‹ä½ç½®ï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œåªæœ‰ bp çš„å€¼æ˜¯æ— æ³•è®©æœºå™¨æ˜¾ç¤ºå­—ç¬¦ä¸²çš„ã€‚ info_loopæ˜¯åˆ©ç”¨ jmp æŒ‡ä»¤è®¾ç½®çš„ä¸€ä¸ªå¾ªçŽ¯ï¼Œè¿™æ¡æŒ‡ä»¤ä¼šè®©æœºå™¨ä¸€ç›´æ‰§è¡Œè¿™ä¸ªå¾ªçŽ¯ã€‚å¦‚æžœæ²¡æœ‰è¿™æ¡æŒ‡ä»¤ï¼Œæœºå™¨å°±ä¼šåŽ»å¯»æ‰¾ä¸‹ä¸€ä¸ªèƒ½å¯åŠ¨çš„è®¾å¤‡ã€‚ .orgä¹Ÿæ˜¯æ±‡ç¼–ä¸­çš„ä¼ªæŒ‡ä»¤ï¼Œå®ƒå‘Šè¯‰ cpu ä¸‹é¢çš„è¯­å¥ä»Žåœ°å€ 510 å¤„å¼€å§‹æ‰§è¡Œï¼Œç›¸æ¯”åŽŸæœ¬çš„å†…æ ¸ä»£ç ï¼Œè¿™é‡Œèˆå¼ƒæŽ‰äº†root_devï¼Œæ‰€ä»¥éœ€è¦å°†åœ°å€è®¾ç½®ä¸º 510ï¼Œè¿™æ ·å½“æˆ‘ä»¬å°†ç£ç›˜å¼•å¯¼æ‰‡åŒºï¼ˆå…± 512 å­—èŠ‚ï¼‰çš„æœ€åŽä¸¤ä¸ªå­—èŠ‚è®¾ç½®ä¸º 0xAA55 æ—¶ï¼Œæœºå™¨è¯»å–åˆ°è¿™é‡Œå°±ä¼šçŸ¥é“è¿™ä¸ªæ‰‡åŒºæ˜¯å¼•å¯¼æ‰‡åŒºäº†ï¼ˆæ˜¯å¦‚ä½•è¯»çš„ï¼Œè¿™é‡Œå°±ä¸è§£é‡Šäº†ï¼‰ã€‚æœ€åŽçš„ boot_flagå°±æ˜¯å¯åŠ¨æ ‡å¿—çš„å­—é¢æ„æ€äº†ï¼Œå¯æƒ³è€ŒçŸ¥ï¼ŒåŽé¢è·Ÿçš„å°±æ˜¯ 0xAA55ã€‚å¯ä»¥çŒœæµ‹ä¸€ä¸‹ï¼Œè¿™å‡ è¡Œä»£ç åº”è¯¥æ˜¯åŽç»­å·¥ä½œåšçš„å‡†å¤‡ã€‚ æžå®šæºç åŽï¼Œå°±å¯ä»¥å¼€å§‹ç¼–è¯‘å†…æ ¸è¿è¡Œæ£€æŸ¥ä¸€ä¸‹è¿è¡Œç»“æžœäº†ã€‚ä»¥ Linux ä¸ºä¾‹ï¼Œè¿›å…¥linux-0.11/bootç›®å½•ä¸‹è¦ç¼–è¯‘å’Œé“¾æŽ¥ bootsect.s å°±è¦æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼š12as86 -0 -a -o bootsect.o bootsect.sld86 -0 -s -o bootsect bootsect.o åˆ«æ€¥ç€åŽ»è¿è¡Œå†…æ ¸ï¼Œå…ˆç”¨ls -lå‘½ä»¤æ£€æŸ¥ä¸‹ç¼–è¯‘å¥½çš„æ–‡ä»¶çš„å¤§å°ã€‚å¯ä»¥å‘çŽ°ï¼Œbootsect çš„æ–‡ä»¶å¤§å°æ˜¯ 544 å­—èŠ‚ï¼Œä½†æ˜¯å¼•å¯¼ç¨‹åºå¿…é¡»è¦æ­£å¥½å ç”¨ä¸€ä¸ªç£ç›˜æ‰‡åŒºï¼Œå³ 512 å­—èŠ‚ã€‚é€ æˆå¤šäº† 32 ä¸ªå­—èŠ‚çš„åŽŸå› æ˜¯ ld86 äº§ç”Ÿçš„æ˜¯ Minix å¯æ‰§è¡Œæ–‡ä»¶æ ¼å¼ï¼Œè¿™æ ·çš„å¯æ‰§è¡Œæ–‡ä»¶é™¤äº†æ–‡æœ¬æ®µã€æ•°æ®æ®µç­‰éƒ¨åˆ†ä»¥å¤–ï¼Œè¿˜åŒ…æ‹¬ä¸€ä¸ª Minix å¯æ‰§è¡Œæ–‡ä»¶å¤´éƒ¨ï¼Œè€Œè¿™ä¸ªæ–‡ä»¶çš„å¤´éƒ¨æ­£å¥½å¤šäº† 32 ä¸ªå­—èŠ‚ã€‚ åœ¨ linux ä¸‹éœ€è¦å°†æ–‡ä»¶å¤§å°æ”¹ä¸º 512 å­—èŠ‚ï¼Œä¹Ÿå°±æ˜¯åˆ æŽ‰å¤´éƒ¨ï¼Œæ‰€ä»¥éœ€è¦å€ŸåŠ©å‘½ä»¤ï¼š12dd bs=1 if=bootsect of=Image skip=32cp ./Image ../Image ä¹‹åŽåœ¨ oslab ç›®å½•ä¸‹ï¼Œè¿è¡Œ run è„šæœ¬ï¼š1$ ./run å°±å¯ä»¥å¾—åˆ°è¿™æ ·çš„ç»“æžœï¼š æ”¹å†™ setup.så…ˆåˆ†æžä¸€ä¸‹è¦æ±‚ï¼š åˆ©ç”¨ setup.s å‘å±å¹•è¾“å‡ºä¸€è¡Œâ€œNow we are in SETUPâ€ åˆ©ç”¨ setup.s èŽ·å–åŸºæœ¬ç¡¬ä»¶å‚æ•°ï¼Œè¿™ä¸ªå†…æ ¸æœ¬èº«å°±å·²ç»è¯»äº†å†…å­˜æ•° setup.s ä¸å†åŠ è½½ linux å†…æ ¸ï¼Œä¿æŒä¸Šè¿°ä¿¡æ¯æ˜¾ç¤ºåœ¨å±å¹•ä¸Šå³å¯ï¼Œè¿™é‡Œå¯èƒ½ä¼šç”¨åˆ°ä¸­æ–­ å…ˆçœ‹ç¬¬ä¸€æ¡è¦æ±‚ï¼Œè¿™ä¸ªè·Ÿå‰ä¸€ä¸ªä»»åŠ¡å®Œæˆå¾—äº‹æƒ…æ˜¯ç±»ä¼¼çš„ï¼Œéœ€è¦æ‰¾åˆ°å…‰æ ‡ä½ç½®ï¼Œç„¶åŽæ‰“å°å³å¯ã€‚ å°è¯•äº†ä¸€ä¸‹ï¼Œå°† bootsect.s å†…ä¸Žå…‰æ ‡å’Œæ‰“å°æ–‡å­—ç›¸å…³çš„ä»£ç æŠ„åˆ°äº† setup.s è¿™ä¸ªæ–‡ä»¶å¯¹åº”è¯»å…‰æ ‡çš„ä½ç½®ï¼Œç»“æžœå¹¶ä¸é¡¶ç”¨ã€‚çªç„¶æƒ³åˆ°ï¼Œæ˜¯ä¸æ˜¯æ‰“å°å®Œä¸€è¡Œå­—ç¬¦åŽå†å°†å…‰æ ‡ä½ç½®ç§»åŠ¨åˆ°è¡Œé¦–å‘¢ï¼ŸäºŽæ˜¯åˆåœ¨æŠ„è¿‡æ¥çš„ä»£ç ä¸‹é¢è¡¥ä¸Šäº†è¯»å…‰æ ‡ä½ç½®çš„ä»£ç ï¼Œç»“æžœè¿˜æ˜¯ä¸è¡Œï¼Œæžœç„¶ï¼Œä¸æ‡‚æ±‡ç¼–ï¼Œå•çº¯çš„é  Ctrl + C/Vï¼Œè¿˜æ˜¯ä¸è¡Œï¼Œç´¢æ€§çœ‹ä¸‹è€å¸ˆç»™çš„æç¤ºã€‚ çœ‹äº†è€å¸ˆçš„æç¤ºï¼Œæ‰å‘çŽ°è€å¸ˆè®²çš„â€œæ”¹å†™â€è·Ÿæˆ‘ç†è§£çš„â€œæ”¹å†™â€å«ä¹‰ä¸æ˜¯ä¸€æ ·çš„ã€‚è€å¸ˆæ˜¯ç›´æŽ¥ä»Žæ–°å†™ä¸€ä¸ªèƒ½å®Œæˆä»»åŠ¡çš„ bootsect.s å’Œ setup.s æ–‡ä»¶ï¼Œè€Œæˆ‘æ˜¯ç›´æŽ¥æ”¹çŽ°æˆæ–‡ä»¶ï¼Œæ°´å¹³è¿‡ä½Žï¼Œè¿‡ä½Žï¼Œ2333ã€‚ä¸è¿‡å›žè¿‡å¤´æ¥æƒ³ä¸€ä¸‹ï¼Œå¦‚æžœåªæ˜¯å•çº¯å®Œæˆå®žéªŒï¼Œé‚£ä¹ˆç¡®å®žä¸éœ€è¦è¯»å–é‚£ä¹ˆå¤šç³»ç»Ÿä¿¡æ¯ï¼Œä¹Ÿä¸éœ€è¦ç³»ç»Ÿå®Œå…¨å¯åŠ¨ï¼Œåªè¦æ˜¾ç¤ºäº†éœ€è¦çš„ä¸œè¥¿å³å¯ã€‚æ—¢è¦æ˜¾ç¤ºæ–‡æœ¬ï¼Œåˆè¦å†…æ ¸å®Œå¥½çš„å¯åŠ¨ï¼Œåè€Œéœ€è¦çš„çŸ¥è¯†é‡æ›´å¤šï¼Œè¿™å¯¹åˆå­¦è€…è€Œè¨€åè€Œæ˜¯ä¸åˆ©çš„ã€‚å¥½å§ï¼Œç†ç›´æ°”å£®çš„å®‰æ…°äº†è‡ªå·±ï¼Œä¸‹é¢åœ¨æŒ‰ç…§è€å¸ˆç»™çš„æ€è·¯æ¥åšä¸€ä¸‹ã€‚ æ ¹æ®è€å¸ˆç»™å‡ºçš„æ€è·¯ï¼Œå¯ä»¥å¾ˆå®¹æ˜“çš„å®Œæˆè¿™ä¸ªå®žéªŒçš„ç¬¬ä¸€ä¸ªä»»åŠ¡ï¼Œå…·ä½“è¯·çœ‹ä¸Šæ–‡ Reviewã€‚ ä¸‹é¢æˆ‘ä»¬é¦–å…ˆè®© setup.s å®Œæˆç¬¬ä¸€ä¸ªå­ä»»åŠ¡ï¼šå‘å±å¹•è¾“å‡ºâ€œNow we are in SETUPâ€ã€‚è¿™ä¸ªä»»åŠ¡ä¸Ž bootsect.s å¹²çš„äº‹æƒ…å¾ˆç±»ä¼¼ï¼Œäº‹å®žä¸Šï¼Œæˆ‘ä»¬è¿˜çœŸçš„å°±åªéœ€è¦å°†å‰é¢ä¸‹å¥½çš„ bootsect.s æŠ„è¿‡æ¥å†ä¿®æ”¹ä¸€ä¸‹å°±å¥½äº†ï¼Œæ”¹å¥½åŽï¼š123456789101112131415161718192021entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg2: .byte 13,10 .ascii &quot;Now we are in SETUP&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 å› ä¸º es çš„å€¼åœ¨ bootsect.s å·²ç»æ”¹è¿‡äº†ï¼Œæ‰€ä»¥è¿™é‡Œè¦æ”¹å›žæ¥ï¼Œç›´æŽ¥å€ŸåŠ© cs è¿™ä¸ªæ®µå¯„å­˜å™¨ã€‚è‡³äºŽä¸ºä»€ä¹ˆèƒ½å€ŸåŠ© cs æ®µå¯„å­˜å™¨è¾¾åˆ°æˆ‘ä»¬çš„ç›®çš„ï¼Œæ˜¯å› ä¸º cs æ˜¯ä¿å­˜å¾®å¤„ç†å™¨æ‰§è¡Œä»£ç çš„å†…å­˜æ®µï¼Œcsï¼ˆä»£ç æ®µå¯„å­˜å™¨ï¼‰æŒæœ‰æ®µçš„èµ·å§‹ä½ç½®ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬éœ€è¦çš„ 0x07c0ã€‚è¿™é‡Œï¼Œä¹Ÿä¸å¾—ä¸è¯´ï¼Œæ€ªä¸å¾— cpu é‡Œé¢è¦æžè¿™ä¹ˆå¤šå¯„å­˜å™¨çš„ï¼Œå…¶å®žéƒ½æ˜¯ç”¨çš„ç€çš„ï¼Œå°±æ˜¯ç€å®žéš¾è®°ðŸ˜“ã€‚è¿˜æœ‰ä¸€ä¸ªéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œå°±æ˜¯ bootsect.s å·²ç»ç”¨è¿‡ msg1 è¿™ä¸ªæ ‡è¯†ç¬¦äº†ï¼Œè¿™é‡Œéœ€è¦ç”¨ msg2 äº†ã€‚ åœ¨ç¼–è¯‘ setup.s ä¹‹å‰ï¼Œè¿˜éœ€è¦åšä¸€ä»¶äº‹æƒ…ï¼Œé‚£å°±æ˜¯è®© bootsect.s è¯»å…¥ setup.sã€‚é‚£ä¹ˆå¦‚ä½•è¯»å…¥ setup.s å‘¢ï¼Ÿå…¶å®žå°±æ˜¯ä½¿ç”¨ 0x13 ä¸­æ–­ï¼Œå¯ä»¥å‘çŽ°åˆ°ç›®å‰ä½ç½®æˆ‘ä»¬éƒ½æ˜¯é€šè¿‡ bios ä¸­æ–­åœ¨è¾¾åˆ°æˆ‘ä»¬æƒ³è¦çš„ç»“æžœã€‚çŽ°åœ¨çœ‹æ¥ï¼Œbios ä¸­æ–­å°±åƒæ˜¯å¯ä¾›ä½¿ç”¨çš„ä¸€ä¸ªå·¥å…·ä¸€æ ·ï¼ˆäº‹å®žä¸Šï¼Œå®ƒæœ¬èº«å°±æ˜¯å¦‚æ­¤ï¼‰ã€‚ é‚£ä¹ˆè·Ÿç€è€å¸ˆçš„æ€è·¯ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°ä¿®æ”¹åŽçš„ bootsect.s çš„æºç ï¼š12345678910111213141516171819202122232425262728293031323334SETUPLEN=2SETUPSEG=0x07e0entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup mov dx,#0x0000 mov ax,#0x0000 int 0x13 jmp load_setupok_load_setup: jmpi 0,SETUPSEGmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 å†æ¥ç®€å•è§£é‡Šä¸€ä¸‹è¿™æ®µä»£ç ï¼Œ0x13 ä¸­æ–­å¯¹ ahã€alã€bhã€blã€ch å’Œ cl çš„å€¼æœ‰è¦æ±‚ï¼Œæ‰€ä»¥åœ¨è°ƒç”¨å®ƒä¹‹å‰ï¼Œè¦å…ˆå¾—åˆ°æˆ‘ä»¬æƒ³è¦çš„å€¼ã€‚åœ¨ linux-0.11 çš„ bootsect.s æ–‡ä»¶ä¸­ï¼ŒSETUPLEN çš„å€¼ä¸º 4ï¼Œä»£è¡¨äº† 4 ä¸ªæ‰‡åŒºï¼Œè¿™é‡Œæˆ‘ä»¬åªè¯» 2 ä¸ªï¼Œæ‰€ä»¥ SETUPLEN çš„å€¼åœ¨å¼€å¤´è®¾ç½®ä¸º 2ã€‚jmp load_setupæ˜¯åœ¨æœ«å°¾è®¾ç½®çš„å¾ªçŽ¯ï¼Œå¦‚æžœè½½å…¥å¤±è´¥å°±ä¼šä»Žå¤´å¼€å§‹ã€‚ è½½å…¥æˆåŠŸåŽï¼Œä¼šè·³è½¬æ‰§è¡Œ setup.sã€‚æ­¤æ—¶ï¼Œéœ€è¦å…ˆæžæ¸…æ¥š setup.s åœ¨å“ªé‡Œï¼Œé€šè¿‡å‰é¢è°ƒç”¨ 0x13 ä¸­æ–­å¯çŸ¥æˆ‘ä»¬å°† setup.s æ”¾åœ¨äº† 0x07c0 çš„åŽ 2 ä¸ªæ‰‡åŒºã€‚è€Œ bootsect.s æœ¬èº«å  1 ä¸ªæ‰‡åŒºï¼Œæ‰€ä»¥ SETUPSEG éœ€è¦è®¾ç½®ä¸º 0x07e0ï¼Œå°±æ˜¯ 0x07c0 åŠ äº† 512 å­—èŠ‚ï¼ˆ1 ä¸ªæ‰‡åŒºï¼‰åŽçš„åœ°å€ï¼Œè¿™æ ·å°±å®Œæˆäº†ä»Ž bootsect.s åˆ° setup.s çš„è·³è½¬ã€‚ æºç å®ŒæˆåŽå°±å¯ä»¥ç¼–è¯‘è¿è¡Œæ£€æŸ¥ç»“æžœäº†ã€‚ä½†çŽ°åœ¨æœ‰ 2 ä¸ªæ–‡ä»¶éœ€è¦ç¼–è¯‘ã€é“¾æŽ¥ã€‚å¦‚æžœéƒ½æ‰‹åŠ¨ç¼–è¯‘ï¼Œå°±å¤ªæ…¢äº†ï¼Œæ‰€ä»¥å€ŸåŠ© Makefile æ˜¯æœ€ä½³æ–¹å¼ã€‚ è¿›å…¥linux-0.11ç›®å½•åŽï¼Œä½¿ç”¨ä¸‹é¢å‘½ä»¤ï¼š1make BootImage æ­¤æ—¶ä¼šçœ‹åˆ°ä¸‹é¢çš„é”™è¯¯ï¼š12Unable to open &apos;system&apos;make: *** [BootImage] Error 1 æœ‰ Errorï¼è¿™æ˜¯å› ä¸º make æ ¹æ® Makefile çš„æŒ‡å¼•æ‰§è¡Œäº†tools/build.cï¼Œbuild.c æ˜¯ä¸ºç”Ÿæˆæ•´ä¸ªå†…æ ¸çš„é•œåƒæ–‡ä»¶è€Œè®¾è®¡çš„ï¼Œè€Œæˆ‘ä»¬å´åªéœ€è¦ç¼–è¯‘ bootsect.s å’Œ setup.s ã€‚å®ƒåœ¨å‘æˆ‘ä»¬è¦ â€œç³»ç»Ÿâ€ çš„æ ¸å¿ƒä»£ç ã€‚ä¸ºå®Œæˆå®žéªŒï¼Œéœ€è¦ç»™å®ƒæ‰“ä¸ªå°è¡¥ä¸ã€‚ build.c çš„å·¥ä½œåŽŸç†ä»Žå‘½ä»¤è¡Œå‚æ•°å¾—åˆ° bootsectã€setup å’Œ system å†…æ ¸çš„æ–‡ä»¶åï¼Œå°†ä¸‰è€…åšç®€å•çš„æ•´ç†åŽä¸€èµ·å†™å…¥ Imageã€‚å…¶ä¸­ system æ˜¯ç¬¬ä¸‰ä¸ªå‚æ•°ï¼ˆargv[3]ï¼Ÿï¼‰ã€‚å½“make allæˆ–è€…makeallçš„æ—¶å€™ï¼Œè¿™ä¸ªå‚æ•°ä¼ è¿‡æ¥çš„æ˜¯æ­£ç¡®çš„æ–‡ä»¶åï¼Œbuild.c ä¼šæ‰“å¼€å®ƒï¼Œå°†å†…å®¹å†™å…¥ Imageã€‚è€Œmake BootImageæ—¶ï¼Œä¼ è¿‡æ¥çš„æ˜¯å­—ç¬¦ä¸² noneã€‚æ‰€ä»¥ï¼Œæ”¹é€  build.c çš„æ€è·¯å°±æ˜¯å½“ argv[3] æ˜¯ none çš„æ—¶å€™ï¼Œåªå†™ bootsect å’Œ setupï¼Œå¿½ç•¥æ‰€æœ‰ä¸Ž system æœ‰å…³çš„å·¥ä½œï¼Œæˆ–è€…åœ¨è¯¥å†™ system çš„ä½ç½®éƒ½å†™ä¸Š â€œ0â€ã€‚ è¦è¾¾åˆ°ä¸Šè¿°æ•ˆæžœï¼Œæˆ‘ä»¬åªéœ€è¦å°† build.c ä¸­ç¬¬ 178 - 190 è¡Œæ³¨é‡ŠæŽ‰å³å¯ã€‚ ç„¶åŽå†è¿›å…¥åˆ°~/oslab/linux-0.11ç›®å½•ä¸‹ï¼Œæ‰§è¡Œä¸‹é¢çš„å‘½ä»¤ï¼š12make BootImage../run å°±å¯ä»¥å¾—åˆ°ä¸‹é¢çš„ç»“æžœï¼š å¯ä»¥å‘çŽ°è¿™ä¸ªç»“æžœè·Ÿä¹‹å‰ bootsect.s äº§ç”Ÿçš„ç»“æžœæ˜¯ç±»ä¼¼çš„ï¼ŒåŽŸå› å°±æ˜¯å› ä¸ºè¿™é‡Œçš„ setup.s å®Œå…¨å°±æ˜¯å¤åˆ¶çš„ bootsect.sã€‚ çŽ°åœ¨ï¼Œå†æ¥è§£å†³æœ€åŽä¸€ä¸ªä»»åŠ¡ï¼šåˆ©ç”¨ setup.s èŽ·å–ç¡¬ä»¶å‚æ•°ï¼Œä¿å­˜å¹¶è¾“å‡ºåˆ°å±å¹•ä¸Šï¼Œä¸”ä¸å†åŠ è½½å†…æ ¸ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>HIT_OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux é›¶æ•£çŸ¥è¯†]]></title>
    <url>%2F2021%2F10%2F19%2FLinux-%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[è®°å½•ä¸€äº›å®¹æ˜“å¿˜è®°ä¸”ä¸Ž Linux ç›¸å…³çš„ä¸€äº›å®žç”¨çŸ¥è¯†ï¼Œæ–¹ä¾¿è‡ªå·±æŸ¥è¯¢ã€‚ zsh çš„ä¸€äº›å¿«æ·é”® æŒ‰é”® ä½œç”¨ Ctrl + d é”®ç›˜è¾“å…¥ç»“æŸæˆ–é€€å‡ºç»ˆç«¯ Ctrl + s æš‚åœå½“å‰ç¨‹åºï¼Œæš‚åœåŽæŒ‰ä¸‹ä»»æ„é”®æ¢å¤è¿è¡Œ Ctrl + z å°†å½“å‰ç¨‹åºæ”¾åˆ°åŽå°è¿è¡Œï¼Œæ¢å¤åˆ°å‰å°ä¸ºå‘½ä»¤fg Ctrl + a å°†å…‰æ ‡ç§»è‡³è¾“å…¥è¡Œå¤´ï¼Œç›¸å½“äºŽHomeé”® Ctrl + e å°†å…‰æ ‡ç§»è‡³è¾“å…¥è¡Œæœ«ï¼Œç›¸å½“äºŽEndé”® Ctrl + k åˆ é™¤ä»Žå…‰æ ‡æ‰€åœ¨ä½ç½®åˆ°è¡Œæœ« Alt + Backspace å‘å‰åˆ é™¤ä¸€ä¸ªå•è¯ Shift + PgUp å°†ç»ˆç«¯æ˜¾ç¤ºå‘ä¸Šæ»šåŠ¨ Shift + PgDn å°†ç»ˆç«¯æ˜¾ç¤ºå‘ä¸‹æ»šåŠ¨ Shell å¸¸ç”¨çš„é€šé…ç¬¦ å­—ç¬¦ å«ä¹‰ * åŒ¹é… 0 æˆ–å¤šä¸ªå­—ç¬¦ ? åŒ¹é…ä»»æ„ä¸€ä¸ªå­—ç¬¦ [list] åŒ¹é… list ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ [^list] åŒ¹é…é™¤ list ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ä»¥å¤–çš„å­—ç¬¦ [c1-c2] åŒ¹é… c1 - c2 ä¸­çš„ä»»æ„å•ä¸€å­—ç¬¦ï¼Œå¦‚ï¼š[0-9][a-z] {string1, string2, â€¦} åŒ¹é… string1 æˆ– string2 ï¼ˆæˆ–æ›´å¤šï¼‰å…¶ä¸€å­—ç¬¦ä¸² {c1..c2} åŒ¹é… c1 - c2 ä¸­å…¨éƒ¨å­—ç¬¦ï¼Œå¦‚ï¼š{1..10} ç³»ç»Ÿæ—¥å¿—æ–‡ä»¶ æ—¥å¿—åç§° è®°å½•ä¿¡æ¯ alternatives.log ç³»ç»Ÿçš„ä¸€äº›æ›´æ–°æ›¿ä»£ä¿¡æ¯ apport.log åº”ç”¨ç¨‹åºå´©æºƒä¿¡æ¯ apt/history.log ä½¿ç”¨ apt-get å®‰è£…å¸è½½è½¯ä»¶çš„ä¿¡æ¯è®°å½• apt/term.log ä½¿ç”¨ apt-get æ—¶çš„å…·ä½“æ“ä½œï¼Œå¦‚ package çš„ä¸‹è½½ã€æ‰“å¼€ç­‰ auth.log ç™»å½•è®¤è¯çš„ä¿¡æ¯è®°å½• boot.log ç³»ç»Ÿå¯åŠ¨æ—¶çš„ç¨‹åºæœåŠ¡çš„æ—¥å¿—ä¿¡æ¯ btmp é”™è¯¯çš„ä¿¡æ¯è®°å½• Consolekit/history æŽ§åˆ¶å°çš„ä¿¡æ¯è®°å½• dis-upgrade dis-upgrade è¿™ç§æ›´æ–°æ–¹å¼çš„ä¿¡æ¯è®°å½• dmesg å¯åŠ¨æ—¶ï¼Œæ˜¾ç¤ºå±å¹•ä¸Šå†…æ ¸ç¼“å†²ä¿¡æ¯ï¼Œä¸Žç¡¬ä»¶æœ‰å…³çš„ä¿¡æ¯ dpkg.log dpkg å‘½ä»¤ç®¡ç†åŒ…çš„æ—¥å¿— faillog ç”¨æˆ·ç™»å½•å¤±è´¥è¯¦ç»†ä¿¡æ¯è®°å½• fontconfig.log ä¸Žå­—ä½“é…ç½®æœ‰å…³çš„ä¿¡æ¯è®°å½• kern.log å†…æ ¸äº§ç”Ÿçš„ä¿¡æ¯è®°å½•ï¼Œåœ¨è‡ªå·±ä¿®æ”¹å†…æ ¸æ—¶æœ‰å¾ˆå¤§å¸®åŠ© lastlog ç”¨æˆ·çš„æœ€è¿‘ä¿¡æ¯è®°å½• wtmp ç™»å½•ä¿¡æ¯çš„è®°å½•ï¼Œwtmp å¯ä»¥æ‰¾å‡ºè°æ­£åœ¨è¿›å…¥ç³»ç»Ÿï¼Œè°ä½¿ç”¨å‘½ä»¤æ˜¾ç¤ºè¿™ä¸ªæ–‡ä»¶æˆ–ä¿¡æ¯ç­‰ syslog ç³»ç»Ÿä¿¡æ¯è®°å½•]]></content>
  </entry>
  <entry>
    <title><![CDATA[æ–™ç†éšè®°]]></title>
    <url>%2F2021%2F09%2F07%2F%E6%96%99%E7%90%86%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[æƒ³ä¸åˆ°è‡ªå·±æŽ¥è¿‘ä¸€å¹´æ²¡æœ‰æ›´åšåŽï¼Œå†æ¬¡æ›´åšçš„ç¬¬ä¸€ç¯‡æ–‡ç« ä¼šæ˜¯è¿™ä¸ªä¸»é¢˜ã€‚ä¸è¿‡åæ­£ä¹Ÿæ²¡æœ‰äººçœ‹ï¼Œæƒå½“æ˜¯è‡ªå·±è®°å½•ç”¨çš„ä¹Ÿå¯ã€‚ ç›®å‰æŽŒæ¡çš„æ–™ç†æ²¡æœ‰é‚£ä¹ˆå¤šï¼Œå¯¹çƒ¹é¥ªçš„ç ”ç©¶ä¹Ÿä¸å¤ªæ·±ï¼Œç´¢æ€§å°±ä¸åˆ†çš„å¤ªæ¸…æ¥šäº†ï¼Œç›´æŽ¥è®°å½•ä¸‹éœ€è¦çš„å¤§æ¦‚ä¿¡æ¯å³å¯ã€‚ é…¸è¾£åœŸè±†ä¸è¿™é“èœä¼°è®¡æ˜¯å¾ˆå¤šäººå­¦ä¼šçš„ç¬¬ä¸€é“èœäº†ï¼Œä¸è¿‡æˆ‘å¥½åƒå·²ç»å¿˜è®°äº†ç¬¬ä¸€ä¸ªä¼šåšçš„èœäº†ã€‚ é…¸è¾£åœŸè±†ä¸è¦æƒ³ç‚’å¥½ï¼ŒåœŸè±†ä¸ä¸€å®šè¦åˆ‡æˆâ€œä¸â€ã€‚å½“ç„¶äº†ï¼Œä¹Ÿä¸æ˜¯è¯´ä¸€å®šè¦è·Ÿç±³ç²‰ä¸€æ ·ç»†ï¼Œç²—ç»†é€‚ä¸­ï¼Œåƒç«æŸ´æ¢—é‚£ä¸ªå¤§å°å³å¯ï¼Œç•¥å¤§ä¹Ÿè¡Œï¼Œæ‰€ä»¥è¦ç†Ÿç»ƒçš„ä½¿ç”¨èœåˆ€ï¼Œåˆ‡è®°å°å¿ƒä¸è¦åˆ‡åˆ°æ‰‹æŒ‡äº†ã€‚åˆ‡å¥½åŽçš„åœŸè±†ä¸ï¼Œä¸è¦ç›´æŽ¥æš´éœ²åœ¨ç©ºæ°”ä¸­ï¼Œå¦åˆ™åœŸè±†ä¸çš„é¢œè‰²ä¼šå˜ç°ï¼Œæ‰€ä»¥è¦æ”¾ç½®åœ¨æœ‰æ°´çš„ç¢—ä¸­æ³¡ç€ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œæœ‰äº›åœ°æ–¹è¿™é“èœæ˜¯ä¸æ”¾é’æ¤’çš„ã€‚è€Œä¸ºäº†æœ‰è¾£å‘³ï¼Œä¸€å¼€å§‹èµ·é”…å°‘çƒ§å¥½æ²¹åŽï¼Œè’œå’Œå¹²è¾£æ¤’çˆ†é¦™åŽï¼Œå°±ç›´æŽ¥ä¸‹åœŸè±†ä¸äº†ã€‚å¦å¤–ï¼Œä¸ºäº†ç»´æŒåœŸè±†ä¸çš„ç™½è‰²ï¼ˆæˆ–è€…ç±³é»„è‰²ï¼‰ï¼Œå¤šç”¨ç™½é†‹è°ƒå‘³ï¼Œè€Œä¸æ˜¯é™ˆé†‹ã€‚ ï¼ˆä¾ç¨€è®°å¾—ï¼Œæ¯äº²ç‚’åœŸè±†ä¸æ—¶ï¼Œè¾£å‘³æ˜¯åŠ äº†è±†ç“£é…±æ¥çš„ï¼Œå¹¶æ²¡æœ‰æ”¾å¹²è¾£æ¤’ï¼Œè¿™å¯èƒ½æ˜¯æˆ‘å®¶çš„åƒæ³•ã€‚ï¼‰ æ¸…ç‚’è¥¿å…°èŠ±è¿™é“èœåœ¨çœŸæ­£å¼€å§‹ç‚’ä¹‹å‰å‡†å¤‡å·¥ä½œæ¯”è¾ƒå¤šã€‚å…ˆæ˜¯è¥¿å…°èŠ±çš„å¤„ç†ï¼Œç”¨åˆ€åŽ»é™¤è€æ ¹ï¼Œå¹¶å°†å¤§æœµè¥¿å…°èŠ±æ”¹æˆå°æœµï¼Œæ´—å‡€ã€‚ç„¶åŽï¼Œå¾€é”…å†…åŠ æ°´ï¼Œæ°´é¢ç¨ä¸ºå¯ä»¥å®½ä¸€ç‚¹ï¼Œå¾…é”…ä¸­æ°´çƒ§å¼€åŽï¼Œå°†è¥¿å…°èŠ±å€’å…¥é”…ä¸­ã€‚æ³¨æ„ç„¯æ°´æ—¶é—´ä¸è¦è¿‡ä¹…ï¼Œå¦åˆ™ä¸€æ¥ä¼šä½¿è¥¿å…°èŠ±çš„å£æ„Ÿå˜è€ã€å˜è½¯ï¼ŒäºŒæ¥ä¼šä½¿è¥¿å…°èŠ±ä¸­çš„è¥å…»ç‰©è´¨æµå¤±ã€‚ æŽ¥ç€ï¼Œèµ·é”…çƒ§æ²¹ï¼Œä¸‹è’œçˆ†é¦™ï¼Œå†å€’å…¥è¥¿å…°èŠ±ç¿»ç‚’ï¼ŒåŠ å…¥ç›ã€é¸¡ç²¾ã€ç™½é†‹ç­‰è°ƒå‘³æ–™ã€‚ç”±äºŽä¹‹å‰è¿›è¡Œäº†ç„¯æ°´è¿™ä¸ªæ­¥éª¤ï¼Œæ‰€ä»¥è¿™æ—¶ï¼Œä¸è¦ç‚’å¤ªä¹…ï¼Œé—»åˆ°é¦™å‘³ï¼Œå·®ä¸å¤šå°±å¯ä»¥å‡ºé”…äº†ã€‚ å½“ç„¶äº†ï¼Œè¯´æ˜¯æ¸…ç‚’ï¼Œå¹¶ä¸æ˜¯å®Œå…¨ä¸åŠ å…¶ä»–é…èœäº†ã€‚ä¸ºäº†èœè‰²ï¼Œå¯ä»¥åŠ å…¥é€‚é‡çš„æœ¨è€³å’Œçº¢æ¤’ä¸æ¥ç‚¹ç¼€ï¼ˆäºŒè€…å¯ä»¥ä¸Žè¥¿å…°èŠ±ä¸€åŒç„¯æ°´ï¼‰ï¼Œä¸ºäº†å¢žé²œï¼Œä¹Ÿå¯ä»¥åœ¨å‡ºé”…å‰åŠ å…¥å°‘è®¸èšæ²¹ï¼Œç¿»ç‚’å‡åŒ€åŽå†å‡ºé”…ã€‚ æ¸…ç‚’ä¸Šæµ·é’è¿™é“èœçš„åšæ³•è·Ÿæ¸…ç‚’è¥¿å…°èŠ±ç±»ä¼¼ï¼ˆæ¸…ç‚’é’èœåŸºæœ¬éƒ½æ˜¯è¿™æ ·ï¼‰ï¼Œå¯ä»¥æå‰ç„¯æ°´ä¹Ÿå¯ä»¥ä¸æå‰ç„¯æ°´ã€‚ä¸Šæµ·é’çš„èœæ ¹å°½é‡åŽ»é™¤çš„å½»åº•ä¸€ç‚¹ï¼Œè¿™æ ·åƒèµ·æ¥ä¼šæ„Ÿè§‰å«©ä¸€äº›ã€‚ä¸ºäº†é¿å…æ²¹çƒ§çƒ­åŽï¼Œç›´æŽ¥ä¸‹è’œçˆ†é¦™è¿‡åº¦å¯¼è‡´çš„è’œå˜é»‘ã€å˜ç³Šï¼Œå¯ä»¥å…ˆæ”¾å…¥ä¸Šæµ·é’ï¼Œç¨å¾®ç¿»ç‚’ä¸€ä¼šåŽï¼Œå†ä¸‹è’œï¼Œç­‰åˆ°æœ‰è’œé¦™äº†åŽï¼Œå†å‡ºé”…ã€‚ çº¢çƒ§é¸¡ç¿…å…ˆå°†é¸¡ç¿…æ”¹èŠ±åˆ€ï¼Œç„¶åŽå†·æ°´ä¸‹é”…ç„¯æ°´ï¼Œå¯ä»¥åŠ å…¥å°‘è®¸å§œç‰‡ä¸Žç›ï¼Œå¾…é¸¡ç¿…å·®ä¸å¤šç†Ÿäº†åŽï¼Œæžå‡ºå¤‡ç”¨ã€‚ç„¶åŽå€’å‡ºé”…å†…çš„æ°´ï¼Œå°†é”…å†…çš„è‚‰æ²«æ¸…æ´—å¹²å‡€åŽï¼Œå€’å…¥é€‚é‡çš„æ²¹ã€‚å¾…æ²¹çƒ§çƒ­åŽï¼Œä¸‹å…¥è’œã€å§œçˆ†é¦™ï¼Œæ­¤æ—¶å¯ä»¥å°ç«æ…¢çƒ§ï¼Œç…¸å‡ºé¦™å‘³åŽï¼Œå¼€å§‹åŠ å…¥é…±æ²¹ã€é†‹ã€ç›ç­‰å…¶ä»–è°ƒæ–™ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬ä½¿ç”¨è±†ç“£é…±æ¥ä½¿èœè‰²å˜çº¢ã€‚ å¾…å›½å†…æ±¤æ±å¼€å§‹æ”¶æ±åŽï¼ŒåŠ å…¥ä¹‹å‰å¤‡å¥½çš„é¸¡ç¿…ï¼Œå°ç«æ…¢ç‚–ã€‚å‡ºé”…å‰ï¼Œå¯ä»¥å†åŠ å…¥å°‘è®¸é’æ¤’ç‚¹ç¼€èœè‰²ã€‚ ç™½ç¼åŸºå›´è™¾è¿™é“èœåˆ†ä¸¤ä¸ªéƒ¨åˆ†ï¼Œä¸€ä¸ªæ˜¯å¯¹è™¾çš„å¤„ç†ï¼Œå¦ä¸€ä¸ªæ˜¯å¦‚ä½•è°ƒç†è˜¸æ±ã€‚ è™¾çš„å¤„ç†åŒæ ·åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼Œç¬¬ä¸€ä¸ªæ˜¯æ´»è™¾çš„æ¸…æ´—ï¼ŒåŽ»æŽ‰è™¾å¤´ã€è™¾è„‘ã€è™¾çº¿ç­‰ã€‚ç¬¬äºŒä¸ªå°±æ˜¯å°†è™¾ç…®ç†Ÿï¼Œå…ˆçƒ§å¼€æ°´ï¼Œç„¶åŽå†å°†è™¾ä¸‹é”…ã€‚ä¹‹æ‰€ä»¥è¦çƒ§å¼€æ°´å†ä¸‹é”…ï¼Œæ˜¯ä¸ºäº†å‡å°‘ç…®è™¾çš„æ—¶é—´ï¼Œä»¥å…è™¾è‚‰å£æ„Ÿå˜è€ï¼›åŒæ—¶ï¼Œå¼€æ°´ä¸­å¯ä»¥åŠ å…¥é€‚é‡çš„ç›ã€ç”Ÿå§œã€æ–™é…’ç”¨æ¥åŽ»é™¤è™¾çš„è…¥å‘³ã€‚å¤§æ¦‚ç…® 5 - 10 åˆ†é’Ÿå·¦å³ï¼Œè™¾èº«å˜çº¢åŽå°±å¯ä»¥æžå‡ºäº†ã€‚ è˜¸æ±çš„å¤„ç†ä¸ä½œç»†è¯´ï¼Œè™½è¯´è¿™é“èœæ˜¯é“ç²¤èœï¼Œä½†æˆ‘ä»¬æ˜¯å®¶å¸¸åšæ³•ï¼Œæ‰€ä»¥æŒ‰ç…§è‡ªå·±çš„å£å‘³æ¥è°ƒå³å¯ï¼Œå»ºè®®å°‘è®¸é…±æ²¹ã€é™ˆé†‹ã€è’œè“‰ã€ç³–ã€ç›å³å¯ï¼Œç³–ã€ç›ä¹Ÿå¯å•ç‹¬åªåŠ ä¸€ç§ã€‚è‹¥æ˜¯å–œæ¬¢åƒå…¶ä»–çš„è°ƒå‘³æ–™ï¼ˆèŠ¥æœ«ï¼Ÿï¼‰ï¼Œä¹Ÿå¯ä»¥è‡ªå·±åŠ ã€‚ åœŸè±†ç‚–é¸¡å—è¿™é“èœä¸­çš„â€œé¸¡å—â€ä¸€å®šè¦é€‰è‚‰å¤šçš„éƒ¨ä½ï¼ŒæŽ¨èé¸¡å¤§è…¿èƒ¯å­ï¼Œæ”¹æˆå°åˆ€ï¼ŒåŠ ç›è…Œåˆ¶ä¸€å®šæ—¶é—´ï¼Œä¹Ÿå¯ä»¥åŠ å…¥å®šé‡çš„ç”Ÿç²‰ï¼Œä½¿è‚‰è´¨æ›´åŠ é²œå«©ï¼Œé¿å…é¸¡è‚‰å£æ„Ÿè¾ƒâ€œé¢â€ã€‚ å€’å…¥é€‚é‡çš„æ²¹ï¼Œå…ˆå°†é¸¡å—ç‚¸ç†Ÿï¼Œç„¶åŽå†åŠ å…¥è€æŠ½ä¸Šè‰²ï¼Œç»§è€ŒåŠ å…¥è’œã€å§œã€é…±æ²¹ã€è±†ç“£é…±ã€èŠ±æ¤’ç­‰å…¶ä»–è°ƒæ–™ï¼Œç­‰åˆ°èœè‰²ã€èœé¦™éƒ½å‡ºæ¥åŽï¼ŒåŠ å…¥é€‚é‡çš„æ¸…æ°´ï¼Œç›–ä¸Šé”…ç›–ã€‚ç¨å¾®ç…®ä¸€ä¼šåŽï¼Œå€’å…¥åœŸè±†ï¼Œå…ˆå¤§ç«ç…®ã€‚è§‚å¯ŸåœŸè±†æˆè‰²ï¼Œå·®ä¸å¤šç†Ÿäº†åŽï¼Œæ”¹å°ç«ç…®ï¼Œæ­¤æ—¶æ±¤æ±å¼€å§‹æ”¶æ±ï¼Œå¯ä»¥å†åŠ å…¥åˆ‡å¥½çš„é’è¾£æ¤’ï¼Œç”¨ä»¥è°ƒé…èœè‰²ã€‚å°†é’è¾£æ¤’ç¿»ç‚’å‡ºå‘³åŽï¼Œå³å¯å‡ºé”…ã€‚ é’æ¤’è‚‰ä¸å…ˆå°†çŒªè‚‰æ´—å‡€ï¼Œç„¶åŽåˆ‡æˆä¸ã€‚çŒªè‚‰è¦æƒ³åˆ‡çš„ä¸å¤Ÿç»†ï¼Œå¤§è‡´æ³¨æ„ 2 ä¸ªç‚¹ï¼š æ¨ªåˆ‡ç‰›ç¾Šç«–åˆ‡çŒªï¼Œè¦é¡ºç€çŒªè‚‰çš„çº¹ç†åˆ‡ï¼Œå³åˆ€å’Œè‚‰çš„çº¹ç†å‘ˆæ°´å¹³çº¿ è¦æƒ³åˆ‡ä¸ï¼Œå…ˆè¦åˆ‡ç‰‡ï¼Œç‰‡æ‰“çš„çˆ†ï¼Œä¸å°±å¤Ÿä¸ï¼ˆè¿™è·Ÿåˆ‡åœŸè±†ä¸æ˜¯ä¸€æ ·çš„ï¼‰ åˆ‡å¥½çš„çŒªè‚‰åŠ å…¥é£Ÿç›ã€ç”Ÿç²‰ï¼ˆä¹Ÿå¯åŠ å…¥å…¶ä»–çš„è°ƒæ–™ï¼Œåªè¦å¥½åƒçš†å¯ï¼‰è…Œåˆ¶ 10 - 20 åˆ†é’Ÿå·¦å³ï¼ŒæœŸé—´å¯ä»¥å‡†å¤‡å¥½è’œã€å§œã€å¹²è¾£æ¤’ã€é’æ¤’ä¸ç­‰ã€‚ç„¶åŽçƒ§æ²¹ï¼Œæ²¹æ¸©å¤§æ¦‚åˆ°å…«æˆï¼Œè‚‰ä¸å³å¯ä¸‹é”…ï¼Œä¸ƒå…«æˆç†ŸåŽï¼ŒåŠ å…¥è’œã€å§œã€å¹²è¾£æ¤’ã€‚ç‚’å‡ºé¦™å‘³åŽï¼Œå†åŠ å…¥è±†ç“£é…±ã€é…±æ²¹ã€ç›ç­‰è°ƒæ–™ï¼Œè®©èœè‰²æ›´äº®ï¼Œå‘³é“æ›´é²œã€‚æ­¤æ—¶ï¼Œå¯ä»¥åŠ å…¥å°‘è®¸æ¸…æ°´ï¼Œä»¥å…ç«å¤§ç³Šé”…ã€‚æœ€åŽåŠ å…¥é’æ¤’ä¸ï¼Œå¿«é€Ÿç‚’å‡ºå‘³åŽï¼Œå³å¯å‡ºé”…ã€‚ ç³–æ‹Œè¥¿çº¢æŸ¿æŒ‘å‡ ä¸ªæˆç†Ÿçš„è¥¿çº¢æŸ¿ï¼Œæ´—å‡€ã€‚å¦‚æžœä¸å–œæ¬¢åƒçš®ï¼Œå¯ä»¥å…ˆåœ¨è¥¿çº¢æŸ¿è¡¨é¢æ”¹ä¸€ä¸ªå¤§çš„åå­—èŠ±åˆ€ï¼Œç„¶åŽç”¨å¼€æ°´æ³¡ä¸ª 3 - 5 åˆ†é’Ÿå·¦å³ï¼Œç„¶åŽå°±å¯ä»¥è½»æ˜“çš„æ’•æŽ‰è¡¨çš®äº†ã€‚ç„¶åŽåœ¨å°†å¤„ç†å¥½çš„è¥¿çº¢æŸ¿æ”¹æˆä¸€é¡µä¸€é¡µçš„å½¢çŠ¶ï¼Œæ‘†æ”¾åœ¨ç›˜ä¸­åŽï¼Œæ’’ä¸Šç™½ç³–å³å¯ã€‚å¦‚æžœä¸æ˜¯é‚£ä¹ˆå–œæ¬¢åƒé…¸çš„ï¼Œå¯ä»¥å…ˆå°†æ”¹å¥½çš„åˆ€çš„è¥¿çº¢æŸ¿ç”¨å°‘é‡ç›è…Œåˆ¶å‡ åˆ†é’Ÿï¼Œç„¶åŽå†æ‘†ç›˜æ’’ä¸Šç™½ç³–ã€‚ å°è‘±æ‹Œè±†è…æŒ‘ä¸€å—å®Œå¥½çš„å«©è±†è…å—ï¼Œåˆ‡æˆä¸€ä¸ªä¸ªå°æ­£æ–¹ä½“å½¢çŠ¶ï¼Œå¾…é”…é‡Œæ°´çƒ§å¼€åŽï¼Œå†å°†è±†è…ä¸‹å…¥è¿‡é”…ä¸­ç„¯æ°´ï¼Œé”…ä¸­å¯ä»¥åŠ å…¥é€‚é‡çš„ç›ï¼Œå¯èƒ½ä¼šä½¿è±†è…çš„å£æ„Ÿæ›´åŠ ç´§è‡´ã€‚ç†ŸåŽï¼Œç››å…¥ç›˜å­ä¸­ã€‚æ­¤æ—¶ï¼Œå¯ä»¥å‘ç›˜å­ä¸­åŠ å…¥è°ƒå‘³æ–™ï¼Œé”…é‡Œå¼€å§‹çƒ§æ²¹ã€‚è¿™é“èœæœ‰äººè°æ˜¯ä¸œåŒ—èœï¼Œæœ‰äººè¯´æ˜¯é²èœï¼Œä¸ªäººè§‰å¾—åƒæ˜¯é²èœã€‚è€Œåœ¨é²èœä¸­ï¼Œè¿™é“èœè²Œä¼¼å‘³ä¸æ˜¯å¾ˆé‡ï¼Œæ‰€ä»¥ä¸€èˆ¬ä¸åŠ é…±æ²¹ï¼Œå¤§æ¦‚åªæ”¾ç›ã€é¸¡ç²¾ã€ç™½é†‹ã€é¦™æ²¹ã€‚è°ƒå‘³æ–™åŠ æ²¹åŽï¼Œæ’’ä¸Šè‘±èŠ±ï¼Œå°†é”…é‡Œçƒ§å¥½çš„æ²¹æ·‹åˆ°è‘±èŠ±ä¸Šï¼Œåœ¨æ»´ä¸Šå‡ æ»´é¦™æ²¹ï¼Œå¾ˆé¦™ã€‚ é…¸è¾£å¤§ç™½èœé€‰å–æ–°é²œç™½èœï¼Œèœå¶å¤ªå¤§çš„è¯å¯ä»¥ç”¨åˆ€æ”¹å°ä¸€ç‚¹ï¼Œæ´—å‡€ï¼Œæ”¾ç½®ä¸€æ—å¤‡ç”¨ã€‚å‡†å¤‡ä¸€å®šé‡çš„è’œæœ«ï¼Œè¿™é“èœçš„è¾£å‘³å¯ä»¥ç”¨å¹²è¾£æ¤’æ¥è°ƒï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å°ç±³æ¤’ã€‚å…ˆä¸‹è¾£æ¤’è·Ÿè’œæœ«ç‚é”…ï¼Œç„¶åŽä¸‹ç™½èœç¿»ç‚’ï¼ŒæœŸé—´å¯ä»¥åŠ å…¥ä¸€ç‚¹æ¸…æ°´ã€‚å¾…ç™½èœå·®ä¸å¤šç†Ÿäº†åŽï¼Œå¿«é€ŸåŠ å…¥é¸¡ç²¾ã€ç›ã€é†‹ç­‰è°ƒå‘³æ–™ï¼Œç¿»ç‚’å‡åŒ€åŽï¼Œå³å¯å‡ºé”…ã€‚ è‚‰æ²«èŒ„å­è‚‰æ²«èŒ„å­çš„è‚‰æ²«å¯ä»¥ç”¨çº¯ç˜¦è‚‰ï¼Œä¹Ÿå¯ä»¥ç”¨äº”èŠ±è‚‰çš„è‚‰æ²«ï¼Œä¸€èˆ¬è‚‰åº—ä¼šç›´æŽ¥å–è‚‰æ²«ï¼Œä¹Ÿå¯ä»¥ä¹°è‚‰å›žæ¥åŽè‡ªå·±å‰ï¼Œå¤šå‡ºæ¥çš„è‚‰æ²«ä¹Ÿå¯ä»¥ç”¨æ¥åŒ…é¥ºå­ã€‚èŒ„å­å¯ä»¥é€‰ç”¨ç´«çš®èŒ„å­ï¼Œä¸€èˆ¬ä¸åŽ»çš®ï¼Œä¹Ÿå¯ä»¥é€‰ç”¨é’çš®èŒ„å­ï¼Œä¸€èˆ¬è¦åŽ»çš®ã€‚å…ˆå°†èŒ„å­ä¸‹é”…ç‚’è½¯ç‚’ï¼Œç››å‡ºå¤‡ç”¨ã€‚ç„¶åŽå°†è‚‰æ²«ç‚’æ•£ï¼ŒæœŸé—´å¯ä»¥æ”¾å…¥è’œæœ«ã€ç”ŸæŠ½ç­‰è°ƒæ–™ï¼Œå¾…è‚‰æ²«ç‚’å¥½åŽå†åŠ å…¥èŒ„å­ï¼Œå†åŠ å…¥ç›ã€é†‹ç­‰è°ƒå‘³æ–™ï¼Œç¿»ç‚’å‡åŒ€å³å¯å‡ºé”…ã€‚ æ‰‹æ’•åŒ…èœè¿™é“èœè·Ÿç‚’é…¸è¾£å¤§ç™½èœç´¯æ­»ï¼Œå¦‚æžœä¸æƒ³åƒè¾£ï¼Œå¯ä»¥ä¸æ”¾è¾£æ¤’ï¼ŒåŠ å…¥è’œæœ«å³å¯ã€‚åœ¨å¿«è¦å‡ºé”…çš„æ—¶å€™ï¼Œå¯ä»¥åŠ å…¥é€‚é‡ç™½ç³–ï¼Œä½¿åŒ…èœåƒèµ·æ¥æ›´åŠ é²œã€‚ è¾£å­é¸¡ä¸é¸¡ä¸çš„é€‰ææœ‰ä¸¤ç§ï¼š é¸¡è„¯è‚‰ é¸¡å¤§è…¿è‚‰ å»ºè®®é€‰æ‹©é¸¡å¤§è…¿è‚‰æ¥åšã€‚å¦‚æžœé€‰ç”¨é¸¡å¤§è…¿è‚‰æ¥åšï¼Œé‚£ä¹ˆå°±éœ€è¦å¯¹é¸¡å¤§è…¿åŽ»éª¨ï¼Œç„¶åŽå†å°†è‚‰åˆ‡ä¸ï¼Œæ³¨æ„è‚‰ä¸è¦åˆ‡å°ä¸€ç‚¹ï¼ˆä¸è¦åƒä¸‹å›¾ä¸­è¿™ä¹ˆå¤§ï¼‰ã€‚åˆ‡å¥½åŽï¼Œç”¨ç”Ÿç²‰ã€é¸¡è›‹æ¸…ã€ç›è…Œåˆ¶ä¸€å°ä¼šã€‚åœ¨æ­¤æœŸé—´ï¼Œå¯ä»¥å‡†å¤‡å§œã€è’œã€èŠ±æ¤’ã€å¹²è¾£æ¤’ã€é’æ¤’ç­‰ã€‚èµ·é”…çƒ§å¥½æ²¹åŽï¼Œä¸‹å…¥é¸¡ä¸ï¼Œæ³¨æ„ä¸è¦è®©é¸¡ä¸ç²˜è¿žå†ä¸€èµ·ã€‚ç„¶åŽåŠ å…¥è’œã€å§œã€èŠ±æ¤’ã€å¹²è¾£æ¤’ï¼Œç‚’å‡ºå‘³ï¼ŒæŽ¥ç€ï¼ŒåŠ ä¸€å°å‹ºè±†ç“£é…±ç‚’å‡ºçº¢æ²¹ï¼ŒåŠ ä¸€ç‚¹æ¸…æ°´ç”¨ä½œæ±¤æ±ï¼Œå†åŠ å…¥é€‚é‡ç”ŸæŠ½ã€‚æœ€åŽä¸‹å…¥åˆ‡æˆå—çŠ¶çš„é’æ¤’ï¼Œå°†é’æ¤’ç‚’å‡ºå‘³å³å¯å‡ºé”…ã€‚ ç´«èœè›‹èŠ±æ±¤å…ˆå°†ç´«èœæ´—å‡€ï¼Œç„¶åŽæ”¾ç½®ä¸€æ—å¤‡ç”¨ã€‚åˆ‡å¥½è’œæœ«ï¼Œèµ·é”…çƒ§æ²¹ï¼Œå…ˆä¸‹è’œæœ«ç‚é”…ï¼Œç„¶åŽåŠ å…¥æ¸…æ°´ï¼Œæ­¤æ—¶å¯ä»¥åŠ å…¥ä¸€å®šé‡çš„è°ƒå‘³æ–™ã€‚å†å°†é¸¡è›‹æ‰“å…¥ç¢—ä¸­ï¼Œæ…æ‹Œå‡åŒ€ã€‚ç­‰é”…é‡Œçš„æ°´å·®ä¸å¤šçƒ§å¼€åŽï¼ŒåŠ å…¥ç´«èœï¼Œæ…æ‹Œæ•£å¼€ï¼Œç„¶åŽå†å€’å…¥è›‹æ¶²ï¼Œæ³¨æ„ä¸ºäº†é¿å…è›‹å‡ç»“æˆå—ï¼Œè¦å°†è›‹æ¶²è¿‚å›žå€’å…¥é”…ä¸­ï¼Œå¹¶ç”¨é”…é“²ä¸æ–­æ…æ‹Œã€‚å¤§æ¦‚é”…è¿‡ 1 - 2 åˆ†é’Ÿï¼Œè›‹ç†Ÿäº†ï¼ŒåŠ å…¥é€‚é‡è°ƒå‘³æ–™åŽå³å¯å‡ºé”…ã€‚ è¿™é“èœå¯ä»¥æ”¾é€‚é‡çš„è™¾çš®ï¼Œä¼šä½¿å¾—æ±¤å‘³æ›´åŠ é²œç¾Žï¼Œå½“ç„¶ä¸å–œæ¬¢åƒè™¾çš®çš„ä¹Ÿå¯ä»¥ä¸æ”¾ã€‚ å›žé”…è‚‰æŒ‘ä¸€å—ä¸Šå¥½çš„äº”èŠ±è‚‰ï¼Œæœ€å¥½è‚¥ç˜¦ç›¸é—´ã€‚ä¹°è‚‰çš„æ—¶å€™è®°å¾—è®©å¸ˆå‚…åŽ»æŽ‰çŒªçš®ä¸Šçš„æ¯›ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œäº”èŠ±è‚‰æ˜¯ä¸ç”¨åŽ»çš®çš„ï¼Œä½†çŒªæ¯›è¿˜æ˜¯è¦åŽ»é™¤å¹²å‡€ã€‚å°†äº”èŠ±è‚‰æ´—å‡€åŽï¼Œæ”¾å…¥é”…ä¸­ç„¯æ°´ï¼Œå†·æ°´ä¸‹é”…ï¼Œå¯ä»¥åŠ å…¥å§œç‰‡ã€è‘±ã€æ–™é…’ã€ç›ç­‰æ¥åŽ»è…¥ï¼Œå¹¶ä½¿è‚‰çš„å£æ„Ÿç´§å®žï¼ŒæœŸé—´è¦æžå‡ºé”…ä¸­æ°´ä¸Šçš„æµ®æ²«ã€‚ç”¨ä¸€æ ¹ç­·å­ï¼Œèƒ½æ’åˆ°äº”èŠ±è‚‰ä¸­æ—¶ï¼Œå°±å¯ä»¥æžå‡ºé”…äº†ã€‚å¿«é€Ÿç”¨å†·æ°´å†²ä¸€è¾¹ï¼Œè¶å¤–å†·å†…çƒ­ï¼Œå°†äº”èŠ±è‚‰åˆ‡æˆè–„ç‰‡ï¼Œä¸å–œæ¬¢åƒå¤ªå¤šè‚¥è‚‰è¯ï¼Œä¸€å®šè¦å°½é‡çš„åˆ‡è–„ç‚¹ã€‚åˆ‡å¥½åŽï¼Œæ”¾åœ¨ç›˜å­ä¸­å¤‡ç”¨ã€‚å‡†å¤‡å¥½è’œè‹—ã€é’æ¤’ã€å§œã€è’œæœ«ï¼Œèµ·é”…çƒ§æ²¹ï¼Œä¸‹å…¥è’œæœ«ã€å§œç…¸é¦™ï¼Œå†ä¸‹å…¥è‚‰ç‰‡ç…¸ç‚’è‡³è‚‰ç‰‡é¢œè‰²å˜é€æ˜Žï¼Œè¾¹ç¼˜ç•¥å¾®å·èµ·ã€‚ç„¶åŽå†åŠ å…¥è±†ç“£é…±ï¼Œç‚’å‡ºçº¢æ²¹ï¼Œå†åŠ å…¥å°‘è®¸é…±æ²¹è°ƒè‰²ï¼Œä¸Žè‚‰ç‰‡ä¸€èµ·ç¿»ç‚’å‡åŒ€ã€‚æœ€åŽå†ä¸‹å…¥è’œè‹—ã€é’æ¤’ï¼Œå¿«é€Ÿç¿»ç‚’ï¼ŒåŠ å…¥ç›ã€é†‹ç­‰è°ƒå‘³æ–™å³å¯å‡ºé”…ã€‚ å–œæ¬¢åƒè¾£ã€éº»çš„è¯ï¼Œå¯ä»¥å¹²è¾£æ¤’ã€èŠ±æ¤’ä¸Žè’œæœ«ã€å§œä¸€åŒä¸‹é”…ç…¸é¦™ï¼Œç„¶åŽå†ç‚’è‚‰ã€‚ èåœçƒ§é¸¡å—è¿™åˆæ˜¯ä¸€é“å®¶å¸¸èœï¼Œåšæ³•å…¶å®žä¸ŽåœŸè±†é’é¸¡å—å·®ä¸å¤šï¼Œä½†è¦æ³¨æ„èåœè¦æ¯”åœŸè±†æ˜“ç†Ÿï¼Œæ‰€ä»¥ç„–çš„æ—¶é—´ä¸èƒ½å¤ªé•¿ï¼Œä¸ç„¶èåœçƒ‚äº†å°±ä¸å¥½åƒäº†ã€‚å¦å¤–ï¼Œä¹‹æ‰€ä»¥è¦ç”¨èåœå½“é…èœï¼Œå…¶å®žæ˜¯å› ä¸ºå†¬å¤©åˆ°äº†ï¼Œå¤šåƒèåœï¼Œå¯ä»¥è¡¥å……èº«ä½“çš„æ°´åˆ†ï¼Œè¡¥æ°”é€šè‚ºã€‚PSï¼šä¸‹é¢çš„å›¾ç‰‡ç”¨çš„æ±¤ç¢—è£…çš„ï¼Œçœ‹åƒç€å®žä¸å¥½ï¼Œè¿˜æ˜¯ç”¨ç›˜å­å¥½ã€‚ é»„ç“œç‚’è›‹è¿™ä¹Ÿæ˜¯ä¸€é“å¾ˆå¸¸è§çš„å®¶å¸¸èœï¼Œå¤‡æ–™è¿‡ç¨‹å°±ä¸ç»†è¯´äº†ã€‚å…ˆå°†æ…æ‹Œå‡åŒ€çš„è›‹æ¶²å€’å…¥å·²çƒ§åˆ°ä¸ƒã€å…«æˆçƒ­çš„æ²¹é”…ä¸­ï¼Œä½¿è›‹æˆå—å˜ç†Ÿï¼ˆè¿™ä¸ªè¡¨è¾¾æœ‰ç‚¹æ€ªï¼ŒçŸ¥é“æ˜¯ä»€ä¹ˆæ„æ€å°±è¡Œï¼‰ï¼Œç„¶åŽåœ¨å€’å…¥é»„ç“œï¼Œå¤§ç«ç¿»ç‚’ï¼Œæ³¨æ„é”…ä¸­éœ€è¦æœ‰ç‚¹æ°´åˆ†ï¼Œå¯ä»¥é€‚å½“åŠ ç‚¹æ°´ï¼Œè¾¹ç‚’è¾¹åŠ å…¥è°ƒæ–™ï¼Œä¸ä¸€ä¼šä¾¿å¯å‡ºé”…äº†ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œè¿™é“èœé‡Œé¢è¿˜å¯ä»¥åŠ å…¥é»‘æœ¨è€³æ¥ç‚¹ç¼€èœè‰²ï¼Œå¥½åƒä¹Ÿå¯ä»¥ç•¥å¾®å‡å°‘ä¸€ç‚¹é¸¡è›‹çš„è…¥å‘³ï¼ŸåŒæ—¶ï¼Œè¿˜å¯ä»¥åŠ å…¥ä¸€ç‚¹èšæ²¹ï¼Œä½¿èœçš„å‘³é“æ›´åŠ é²œç¾Žï¼Œæˆ–è€…å•çº¯åŠ ç‚¹ç³–ä¹Ÿå¯ä»¥ï¼Œå¦‚æžœä¸å–œæ¬¢åŠ å¤ªå¤šè°ƒå‘³å“ï¼Œä¹Ÿå¯ä»¥ä¸åŠ ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Cooking</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_03]]></title>
    <url>%2F2020%2F09%2F28%2FNand2Tetris-Part1-03%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨çš„ä¸»é¢˜æ˜¯ Memoryï¼Œå…ˆæŠŠåšå¥½çš„ ALU æ”¾ä¸€è¾¹ï¼Œæˆ‘ä»¬æ¥ç ”ç©¶ä¸€ä¸‹å’Œå†…å­˜ï¼ˆRAMï¼‰æœ‰å…³çš„é—®é¢˜ã€‚ Unit 3.1 Sequential Logicæœ¬å°èŠ‚ä¸»è¦åœ¨å¼•å‡ºæ–°çš„æ¦‚å¿µï¼šé¡ºåºé€»è¾‘ï¼ˆSequential Logicï¼‰ã€æ—¶é—´ç­‰ï¼Œå¦å¤–ä¹ŸæŒ‡å‡ºäº†é¡ºåºé€»è¾‘ä¸Žå‰ä¸¤å‘¨æ‰€å­¦çš„ç»„åˆç½—æ°ï¼ˆCombinational Logicï¼‰çš„ä¸åŒã€‚æ¢å¥è¯æ¥è®²ï¼Œè¿™å‘¨è€ƒè™‘çš„é—®é¢˜ä¼šæ›´åŠ è´´è¿‘çŽ°å®žç”Ÿæ´»ä¸€ç‚¹ã€‚ Unit 3.2 Filp Flopsæœ¬å°èŠ‚ä»‹ç»äº†æœ¬å‘¨å†…å®¹æ‰€ä½¿ç”¨çš„æœ€åŸºæœ¬å•å…ƒï¼šData Flip Flopsï¼ˆDFFï¼‰ï¼Œå¹¶è¯´æ˜Žäº†å®ƒçš„åŠŸèƒ½ï¼›æŽ¥ç€ç»§ç»­è®²è§£äº†å†…å­˜çš„åŸºæœ¬å•å…ƒ 1-Bit Registersï¼Œç€é‡åœ¨è¯´æ˜Žå®ƒçš„è¿è¡Œè¿‡ç¨‹ã€‚ Unit 3.3 Memory UnitsUnit 3.4 CountersUnit 3.5 Project 3 Overviewæœ¬å‘¨ä½œä¸šéœ€è¦å®žçŽ° 7 ä¸ªä¸Žå†…å­˜ç›¸å…³çš„èŠ¯ç‰‡å’Œ 1 ä¸ªè®¡æ•°å™¨ï¼Œé’ˆå¯¹å„ä¸ªèŠ¯ç‰‡çš„å®žçŽ°ï¼Œè€å¸ˆç»™å‡ºäº†è‹¥å¹²æç¤ºï¼Œè€Œæˆ‘ä»¬å°†ä¼šä»¥ DFF ä¸º primitive chip æ¥æž„å»ºå¦å¤– 8 ä¸ªèŠ¯ç‰‡ã€‚ Bitè¿™ä¸ªè€å¸ˆå·²ç»è®²è¿‡äº†ï¼Œç›´æŽ¥ç”¨ 1 ä¸ª Mux å’Œ 1 ä¸ª DFF å°±å¯ä»¥å®žçŽ°ï¼Œä½†æ˜¯è¿˜é¢å¤–éœ€è¦ä¸€ä¸ª Mux æ¥å¸®åŠ©è¾“å‡ºï¼ˆä¸ç”¨ Muxï¼Œç”¨å…¶ä»–çš„ä¹Ÿå¯ä»¥ï¼‰ã€‚123456789CHIP Bit &#123; IN in, load; OUT out; PARTS: Mux(a=t2, b=in, sel=load, out=t1); DFF(in=t1, out=t2); Mux(a=t2, b=true, sel=false, out=out);&#125; RegisteræŒ‰ç…§æç¤ºï¼Œç›´æŽ¥ç”¨ 16 ä¸ª Bit å åŠ åœ¨ä¸€èµ·å°±å¯ä»¥äº†ã€‚ä½†æ˜¯è¦æ³¨æ„ä¸€ä¸‹æ—¶é—´çš„æ¦‚å¿µï¼Œä¹Ÿå³è¿™ 16 ä¸ª Bit æ˜¯éƒ½å¤„äºŽå·¥ä½œçŠ¶æ€çš„ï¼Œå°½ç®¡æœ‰äº› Bit çš„å€¼å¯èƒ½å¹¶æ²¡æœ‰æ”¹å˜ã€‚12345678910111213141516171819202122CHIP Register &#123; IN in[16], load; OUT out[16]; PARTS: Bit(in=in[0], load=load, out=out[0]); Bit(in=in[1], load=load, out=out[1]); Bit(in=in[2], load=load, out=out[2]); Bit(in=in[3], load=load, out=out[3]); Bit(in=in[4], load=load, out=out[4]); Bit(in=in[5], load=load, out=out[5]); Bit(in=in[6], load=load, out=out[6]); Bit(in=in[7], load=load, out=out[7]); Bit(in=in[8], load=load, out=out[8]); Bit(in=in[9], load=load, out=out[9]); Bit(in=in[10], load=load, out=out[10]); Bit(in=in[11], load=load, out=out[11]); Bit(in=in[12], load=load, out=out[12]); Bit(in=in[13], load=load, out=out[13]); Bit(in=in[14], load=load, out=out[14]); Bit(in=in[15], load=load, out=out[15]);&#125; RAM812]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‰’è°±è®°å½• - Homesteaders]]></title>
    <url>%2F2020%2F09%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-Homesteaders%2F</url>
    <content type="text"><![CDATA[ã€ŠHomesteadersã€‹æ˜¯ç”± Joanie Madden ç”¨å“¨ç¬›æ¼”å¥çš„ä¸€é¦–å‡¯å°”ç‰¹é£Žæ ¼çš„æ›²å­ï¼Œæ˜¯ä¸€é¦–ååˆ†çº¯å‡€çš„è½»éŸ³ä¹ã€‚ Homesteaders - Joanie MaddenYour browser does not support the audio tag. æ™šä¸Šå¼¹ç´çš„æ—¶å€™ï¼Œè„‘æµ·é‡Œçªç„¶å“èµ·äº†è¿™é¦–æ›²å­çš„æ—‹å¾‹ï¼Œä¼´éšç€è„‘æµ·å†…çš„æ—‹å¾‹ï¼Œçœ¼å‰çš„æ™¯è‰²å¥½åƒåˆå›žåˆ°äº†é«˜ä¸­æ—¶ä»£ã€‚æƒ³åˆ°é‚£æ—¶çš„è‡ªå·±ï¼Œé¬¼ä½¿ç¥žå·®çš„æ‰¾äº†ä¸€æœ¬è¨€æƒ…å°è¯´è¯»ï¼ˆå¯èƒ½æ˜¯è€ä¸ä½æž¯ç‡¥çš„å­¦ä¹ ç”Ÿæ´»å§ï¼Œä¸ºä»€ä¹ˆä¸è¯»ç§‘å¹»å°è¯´å‘¢ï¼Ÿï¼Ÿï¼Ÿï¼‰ã€‚ä¸€è¾¹è¯»ï¼Œä¸€è¾¹å¬ç€è¿™é¦–æ›²å­ã€‚æœ€åŽï¼Œå°è¯´è¯»å®Œäº†ï¼Œè¿™é¦–æ›²å­ä¹Ÿå¬äº†ä¸€éåˆä¸€éã€‚å°è¯´çš„æƒ…èŠ‚çŽ°å·²éš¾ä»¥å›žæƒ³èµ·æ¥äº†ï¼Œä½†é‚£æ—¶çš„è‡ªå·±æµéœ²å‡ºçš„äº›è®¸æ„Ÿæƒ…å´éšç€è¿™é¦–æ›²å­çš„æ—‹å¾‹ä¸€éåˆä¸€éçš„åˆ»è¿›äº†è‡ªå·±çš„è„‘æµ·ã€‚ å…¶å®žï¼Œé«˜ä¸­æ—¶ä»£ç»“æŸåŽï¼Œè„‘æµ·å°±å·²ç»å¤šæ¬¡å“èµ·äº†è¿™æ®µç†Ÿæ‚‰æ—‹å¾‹ï¼Œå¯è‡ªå·±è®©å®ƒåœç•™åœ¨è„‘ä¸­çš„æ—¶é—´ä¸ä¼šè¶…è¿‡ 10 ç§’ï¼Œç´¢æ€§è¿™æ¬¡è®©å®ƒåœç•™çš„ä¹…ä¸€ç‚¹ã€‚ç„¶åŽï¼Œç”¨å‰ä»–è¯•ç€å¼¹äº†ä¸€ä¸‹ï¼Œè¿˜æŒºåƒçš„ã€‚éšåŽæ‰¾åˆ°åŽŸæ›²ï¼Œå¬äº†å‡ éï¼Œä¸ä¸€ä¼šä¸»æ—‹å¾‹å°±æ‰’å‡ºæ¥äº†ï¼Œè®°å½•ä¸‹æ¥ï¼Œå…å¾—è‡ªå·±å¿˜äº†ã€‚ è¿™æ ·çš„è¯ï¼Œå†è¿‡å‡ å¹´åŽçš„è‡ªå·±å¶å°”çœ‹åˆ°è¿™äº›ä¸œè¥¿çš„æ—¶å€™ï¼Œä¹Ÿè®¸å¿ƒä¸­è¿˜èƒ½ç•™æœ‰ä¸€ä¸æ„ŸåŠ¨å§ï¼ è‡ªæ‰’è°±ï¼š[5]1231[5] [6]123155(1)76 54345112316532123[6]123211[6] [5][5][6]12123211[6] [5][5][6]11(1)767(1)6 5452431236335321232(1)767(1)6 54524312363321[6] [7][]ï¼šé™å…«åº¦ ()ï¼šå‡å…«åº¦]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_02]]></title>
    <url>%2F2020%2F09%2F21%2FNand2Tetris-Part1-02%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨çš„ä¸»é¢˜æ˜¯ Boolean Arithmetic and the ALU Roadmapï¼Œæ—¨åœ¨ä»‹ç»å¦‚ä½•æž„å»ºåŠ æ³•å™¨ï¼ˆadderï¼‰å’Œç®—æœ¯é€»è¾‘å•å…ƒï¼ˆArithmetic Logic Unitï¼ŒALUï¼‰ï¼Œå­¦ä¹ è·¯çº¿ä¾ç„¶è¿˜æ˜¯ä»Žç®€å•åˆ°å¤æ‚ã€‚ Unit 2.1 Binary Numbersæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜ŽäºŒè¿›åˆ¶ä¸Žåè¿›åˆ¶çš„ä¸€äº›è”ç³»ï¼Œç²—ç•¥ä»‹ç»äº†ä¸€ä¸‹è¿›åˆ¶è½¬æ¢çš„è¿‡ç¨‹ï¼Œä½†æ²¡æœ‰è¯´æ˜Žå…·ä½“çš„æ–¹æ³•ã€‚å­¦è¿‡ä¸€é—¨ç¼–ç¨‹è¯­è¨€è¯¾çš„åŒå­¦ï¼Œè‚¯å®šå¯¹è¿™äº›éƒ½å·²ç»å¾ˆç†Ÿæ‚‰ï¼›æ²¡å­¦è¿‡çš„ï¼Œè€å¸ˆè®²çš„ä¹Ÿå¾ˆæ¸…æ™°ã€‚ Unit 2.2 Binary Additionæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»äºŒè¿›åˆ¶åŠ æ³•è§„åˆ™ï¼Œæœ¬è´¨ä¸Šä¸Žåè¿›åˆ¶æ˜¯ä¸€æ ·çš„ã€‚ä½†ç”±äºŽäºŒè¿›åˆ¶ç®—æœ¯å­˜åœ¨ä½æ•°ï¼ˆbitsï¼‰çš„é™åˆ¶ï¼Œæ‰€ä»¥ä¼šäº§ç”Ÿæº¢å‡ºï¼ˆoverflowï¼‰çš„é—®é¢˜ï¼Œè€å¸ˆæš‚æ—¶æ²¡æœ‰è®²å…·ä½“çš„è§£å†³åŠžæ³•ï¼Œåªè¯´æ˜Žäº†ï¼Œåœ¨è®¡ç®—æœºå†…æ˜¯ä¼šç›´æŽ¥å¿½ç•¥æŽ‰çš„ï¼Œä½†æ˜¯ä½¿ç”¨è€…å¿…é¡»çŸ¥é“æº¢å‡ºäº†ã€‚æŽ¥ç€ï¼Œåˆç”±æ˜“åˆ°éš¾çš„ä»‹ç»äº†ä¸‰ç§åŠ æ³•å™¨ï¼Œå¹¶å¤§è‡´è¯´æ˜Žäº†ä¸€ä¸‹æž„é€ çš„æ–¹æ³•ï¼Œè¿™ä¹Ÿæ˜¯æœ¬å‘¨çš„ä½œä¸šä¹‹ä¸€ã€‚ Unit 2.3 Negative Numberså‰é¢ä»‹ç»çš„è§„åˆ™éƒ½æ˜¯ä¸Žæ­£æ•°ç›¸å…³çš„ï¼Œè€Œæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»åœ¨è®¡ç®—æœºä¸­å¦‚ä½•è¡¨ç¤ºè´Ÿæ•°ï¼Œè€å¸ˆä¸»è¦ä»‹ç»äº†ä¸¤ç§è¡¨ç¤ºæ–¹æ³•ï¼š ç”¨æœ€å‰é¢çš„ 1 ä½ï¼ˆ1 bitï¼‰ä»£è¡¨ç¬¦å·ï¼Œä¸º 0ï¼Œåˆ™ä¸ºæ­£æ•°ï¼Œä¸º 1ï¼Œåˆ™ä¸ºè´Ÿæ•°ï¼ŒäºŒè€…ç»å¯¹å€¼ç›¸ç­‰ã€‚è¿™æ ·è¡¨ç¤ºä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯ä¼šäº§ç”Ÿæ­£ 0 å’Œ è´Ÿ 0ï¼Œè¿™æ ·åœ¨åšåŠ ã€å‡æ³•æ—¶ä¼šäº§ç”Ÿé—®é¢˜ï¼Œæ‰€ä»¥èˆå¼ƒäº†è¿™ç§æ–¹æ³• ç”¨ $2^N + (-x) = 2^N - x$ æ¥è¡¨ç¤ºè´Ÿæ•°ï¼Œå…¶ä¸­ -x å°±æ˜¯è¦è¡¨ç¤ºçš„è´Ÿæ•°ï¼Œè¿™æ ·è¡¨ç¤ºåŽå°±æ²¡æœ‰è´Ÿ 0 äº†ï¼Œä¸”åœ¨åšåŠ ã€å‡æ³•æ—¶ä¹Ÿæ˜¯å®Œå…¨æ­£ç¡®çš„ã€‚ è¯´ç‚¹é¢˜å¤–è¯ï¼Œä¸Šé¢çš„å‡ å°èŠ‚å†…å®¹å¯¹åº”äº†ç»„æˆåŽŸç†ä¸­æœ‰å…³æ•°çš„è¡¨ç¤ºéƒ¨åˆ†ï¼Œæåˆ°çš„ä¸€äº›æ–¹æ³•ï¼Œå…¶å®žå°±æ˜¯åŽŸç ã€è¡¥ç ï¼ˆradix complementï¼‰å’Œåç çš„æ¦‚å¿µï¼Œå¯èƒ½æ˜¯è€å¸ˆä¸ºäº†ç…§é¡¾éžè®¡ç®—æœºä¸“ä¸šçš„å­¦ç”Ÿï¼Œä¸€ç‚¹æ²¡æè¿™äº›ä¸œè¥¿ï¼Œä¹Ÿæœ‰å¯èƒ½æ˜¯å›½å¤–è®²è¯¾çš„é£Žæ ¼å¯¼è‡´äº†è€å¸ˆä¸ä¼šç¡¬è®²è¿™äº›æ¦‚å¿µæ€§çš„ä¸œè¥¿å§ã€‚ Unit 2.4 Arithmetic Logic Unitæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»åŽé¢è¦æž„å»ºçš„è®¡ç®—æœº Hack çš„ ALU æ˜¯å¦‚ä½•æž„å»ºçš„ã€‚é¦–å…ˆæ˜¯å¯¹æ­¤ ALU çš„åŸºæœ¬ä»‹ç»ï¼ŒåŒ…æ‹¬å…¶è¾“å…¥ã€è¾“å‡ºã€æŽ§åˆ¶ä½ï¼ˆcontrol bitsï¼‰ï¼Œæ³¨æ„å…¶æŽ§åˆ¶ä½æœ‰ä¸¤ç±»ï¼Œæœ‰ 6 ä¸ªç®—æ˜¯åŠŸèƒ½æŽ§åˆ¶ä½ï¼Œå‰©ä¸‹ä¸¤ä¸ªæ˜¯è¾“å‡ºæŽ§åˆ¶ä½ï¼Œä¸”å¹¶æ²¡æœ‰è¯´æ˜Žè¾“å‡ºæŽ§åˆ¶ä½å­˜åœ¨çš„æ„ä¹‰ã€‚æŽ¥ç€ï¼Œè¯´æ˜Žäº†å¦‚ä½•ä½¿ç”¨ç¡¬ä»¶æ¨¡æ‹Ÿå™¨æ¥ä½¿ç”¨æ¨¡æ‹Ÿ ALU çš„ä¸€äº›åŠŸèƒ½ï¼Œåœ¨è¿™ä¸€å—ï¼Œå¦‚æžœå¯¹ ALU çš„è¿ç®—è¿‡ç¨‹ä¸æ¸…æ¥šå¯ä»¥ä½¿ç”¨å†…ç½®çš„ï¼ˆbuilt-inï¼‰ALU æ¥ç†Ÿæ‚‰ä¸€ä¸‹è¿‡ç¨‹ã€‚æœ€åŽï¼Œä¸¾ä¾‹éªŒè¯äº† ALU èƒ½é€ä¸€å®žçŽ°æ‰€è¦æ±‚åŠŸèƒ½çš„å¯é æ€§ï¼Œä½†è€å¸ˆæ²¡æœ‰ä»‹ç»å…·ä½“çš„åŽŸç†ï¼Œæƒ³äº†è§£å°±å¾—è‡ªå·±çœ‹èµ„æ–™äº†ã€‚è¿˜å‰©ä¸‹çš„æœ€åŽä¸€ç‚¹æ˜¯åœ¨è¯´æ˜Ž Hack ALU çš„ä¼˜ç‚¹ï¼Œé€šä¿—æ¥è®²å…¶å®žå°±æ˜¯ä¸€ç‚¹ï¼šæ˜“äºŽå­¦ä¹ ã€‚ Unit 2.5 Project 2 Overviewæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»è¿™å‘¨çš„ä½œä¸šï¼Œå¹¶ç»™å‡ºäº†ä¸€äº›æç¤ºä¿¡æ¯ã€‚å°½ç®¡åœ¨ç¬¬ä¸€å‘¨å·²ç»å®žçŽ°äº†å¾ˆå¤š chipsï¼Œä½†æ˜¯è€å¸ˆå»ºè®®ä¸è¦ä½¿ç”¨è‡ªå·±å®žçŽ°çš„ chipsï¼Œç›´æŽ¥ä½¿ç”¨è½¯ä»¶è‡ªå¸¦ï¼ˆbuilt-inï¼‰çš„ chipsï¼ŒåŽŸå› æ˜¯ä¸ºäº†é¿å…è½¯ä»¶å¯èƒ½ä¼šäº§ç”Ÿçš„å¡é¡¿ç­‰æƒ…å†µã€‚ä¸‹é¢æˆ‘ä»¬å°±æ¥å¼€å§‹å®Œæˆè¿™å‘¨çš„ä½œä¸šã€‚ HalfAdderæŒ‰ç…§è€å¸ˆç»™çš„æç¤ºï¼Œç›´æŽ¥ç”¨ Xor å’Œ And æ¥å®žçŽ°å°±å®Œäº‹äº†ã€‚123456789CHIP HalfAdder &#123; IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry);&#125; FullAdder12345678910CHIP FullAdder &#123; IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, sum=s1, carry=v1); HalfAdder(a=s1, b=c, sum=sum, carry=v2); Or(a=v1, b=v2, out=carry);&#125; Add1612345678910111213141516171819202122CHIP Add16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: HalfAdder(a=a[0], b=b[0], sum=out[0], carry=c1); FullAdder(a=a[1], b=b[1], c=c1, sum=out[1], carry=c2); FullAdder(a=a[2], b=b[2], c=c2, sum=out[2], carry=c3); FullAdder(a=a[3], b=b[3], c=c3, sum=out[3], carry=c4); FullAdder(a=a[4], b=b[4], c=c4, sum=out[4], carry=c5); FullAdder(a=a[5], b=b[5], c=c5, sum=out[5], carry=c6); FullAdder(a=a[6], b=b[6], c=c6, sum=out[6], carry=c7); FullAdder(a=a[7], b=b[7], c=c7, sum=out[7], carry=c8); FullAdder(a=a[8], b=b[8], c=c8, sum=out[8], carry=c9); FullAdder(a=a[9], b=b[9], c=c9, sum=out[9], carry=c10); FullAdder(a=a[10], b=b[10], c=c10, sum=out[10], carry=c11); FullAdder(a=a[11], b=b[11], c=c11, sum=out[11], carry=c12); FullAdder(a=a[12], b=b[12], c=c12, sum=out[12], carry=c13); FullAdder(a=a[13], b=b[13], c=c13, sum=out[13], carry=c14); FullAdder(a=a[14], b=b[14], c=c14, sum=out[14], carry=c15); FullAdder(a=a[15], b=b[15], c=c15, sum=out[15], carry=c16);&#125; Inc161234567CHIP Inc16 &#123; IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, out=out);&#125; ALU_nostatæŒ‰ç…§è€å¸ˆæ‰€ç»™èµ„æ–™ä¸Šçš„æç¤ºï¼Œæˆ‘ä»¬å…ˆä¸åŽ»è€ƒè™‘ ng å’Œ zr è¿™ä¸¤ä¸ªè¾“å‡ºæŽ§åˆ¶ä½ï¼Œç›´æŽ¥è€ƒè™‘è¾“å‡ºå³å¯ã€‚é‚£æˆ‘ä»¬å…ˆå¾—æž„é€ å‡ºèƒ½æ ¹æ® zx å’Œ nx è¿™ä¸¤ä¸ªæŽ§åˆ¶ä½æ¥é€‰æ‹©æ€§è¾“å‡ºçš„é€»è¾‘ç”µè·¯ï¼Œå½“ç„¶ï¼Œè¿™ä¸ªé€»è¾‘ç”µè·¯æ€»çº¿å®½åº¦æ˜¯ 16 ä½çš„ã€‚ç»“æžœç¡¬æƒ³äº†å¥½ä¸€ä¼šå„¿ï¼Œæ²¡æƒ³å‡ºæ¥ã€‚åŽæ¥æ„è¯†åˆ°ï¼Œè¿™ä¸ªé—®é¢˜æœ¬è´¨ä¸Šå…¶å®žå°±æ˜¯åœ¨æ€è€ƒå¦‚ä½•åœ¨æ²¡æœ‰æ¡ä»¶ç¼–ç¨‹è¯­å¥çš„æƒ…å†µä¸‹æž„é€ å‡ºæ¡ä»¶é€»è¾‘ã€‚èƒ¡ä¹±çš„å†™äº†äº›ä»£ç ï¼Œå‘çŽ°è¯­æ³•éƒ½ä¸é€šï¼Œä½†è„‘å­é‡Œå§‹ç»ˆæƒ³çš„éƒ½æ˜¯ï¼šåœ¨çŽ°æœ‰çš„å¯ä½¿ç”¨çš„é€»è¾‘ç”µè·¯é‡Œï¼Œå¥½åƒæ²¡æœ‰å¯ä»¥ç”¨äºŽæ¡ä»¶é€‰æ‹©çš„å•Šï¼Ÿè¿‡äº†ä¸¤å¤©ï¼Œåˆå›žæ¥æ€è€ƒè¿™ä¸ªé—®é¢˜ï¼Œçªç„¶å‘çŽ°ï¼ŒMux è¿™ç§ä¸œè¥¿ä¸æ˜¯æ ¹æ® sel bit æ¥é€‰æ‹©æ€§è¾“å‡ºçš„å—ï¼Ÿçªç„¶æƒ³åˆ°è‡ªå·±ä¹‹å‰çš„æƒ³æ³•ï¼šè¿™ä¸œè¥¿åº”è¯¥æ˜¯é€šä¿¡ä¸“ä¸šåŒå­¦ç ”ç©¶çš„ä¸œè¥¿å§...å¥½å§ï¼Œè‡ªå·±ä¸€å¼€å§‹å°±æŠŠæ­£ç¡®çš„æ€è€ƒæ–¹å‘ç»™æŠ›åˆ°ä¹éœ„äº‘å¤–åŽ»äº†ï¼ŒçœŸæ˜¯æ¬èµ·çŸ³å¤´ç ¸è‡ªå·±çš„è„šï¼Œæƒ³çš„æˆ‘çœŸæ˜¯è¾›è‹¦...æ‰¯è¿œäº†ï¼Œæœ‰äº†ä¸Šé¢çš„æ€è·¯åŽï¼Œè¿™ä¸ªé—®é¢˜å…¶å®žå°±å¾ˆå®¹æ˜“äº†ï¼Œç›´æŽ¥çœ‹ä¸‹é¢ä»£ç ï¼š1234567891011121314151617181920212223242526272829303132CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=out);&#125; ALUå®Œæˆä¸Šé¢çš„ä»»åŠ¡åŽï¼ŒæŽ¥ä¸‹æ¥æˆ‘ä»¬éœ€è¦è€ƒè™‘çš„é—®é¢˜å°±æ˜¯å¦‚ä½•å¾—åˆ° zr å’Œ ng çš„æ­£ç¡®ç»“æžœã€‚æŒ‰ç…§å‰é¢çš„è¯¾ç¨‹å†…å®¹ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“è´Ÿæ•°çš„æœ€é«˜ä½ bit æ˜¯ 1ï¼Œæ‰€ä»¥ ng å°±å¾ˆå®¹æ˜“å¾—åˆ°äº†ã€‚ä½†æ˜¯ zr å°±ä¸æ˜¯é‚£ä¹ˆæ˜“å¾—äº†ï¼ŒåŽŸå› åœ¨äºŽ 0 çš„äºŒè¿›åˆ¶æœ€é«˜ä½ä¸Žæ™®é€šæ­£æ•°çš„äºŒè¿›åˆ¶æœ€é«˜ä½ä¸€æ ·ï¼Œéƒ½æ˜¯ 0 ï¼Œæ‰€ä»¥æ— æ³•è½»æ˜“çš„åŒºåˆ†ã€‚è¿™é‡Œå¥½åƒåˆå›žåˆ°äº†æˆ‘ä»¬åœ¨ä¹‹å‰ç¢°åˆ°çš„é—®é¢˜ï¼šå¦‚ä½•åœ¨æ²¡æœ‰åˆ¤æ–­ç¼–ç¨‹è¯­å¥çš„æƒ…å†µä¸‹æž„é€ å‡ºåˆ¤æ–­é€»è¾‘å‘¢ï¼Ÿæ³¨æ„åˆ° 0 å…ˆåŽ»å–åå†è‡ªå¢žåŠ  1 åŽï¼Œå¾—åˆ°çš„äºŒè¿›åˆ¶åºåˆ—æœ€é«˜ä½ä¸ŽåŽŸåºåˆ—æœ€é«˜ä½ä¸€è‡´ï¼ˆæº¢å‡ºçš„ bit èˆå¼ƒï¼‰ï¼Œè€Œå…¶ä»–çš„æ•°ç”±æ­¤è¿‡ç¨‹å¾—åˆ°çš„ä¸¤ä¸ªåºåˆ—çš„æœ€é«˜ä½å¿…ç„¶ä¸€ä¸ªæ˜¯ 1ï¼Œå¦ä¸€ä¸ªæ˜¯ 0ã€‚å¦‚æ­¤ä¸€æ¥ï¼Œé—®é¢˜å°±è§£å†³äº†ã€‚å½“ç„¶äº†ï¼Œè¦æƒ³å¾—åˆ° zrï¼Œæœ€å¿«çš„åŠžæ³•å…¶å®žå°±æ˜¯è®©æœ€åŽçš„ç»“æžœåºåˆ—æŒ‰ä½å–æˆ–ï¼ˆOrï¼‰è¿ç®—ï¼Œé‡‡ç”¨ä¹‹å‰æž„é€ çš„ Or8Way è¿™ä¸ªé€»è¾‘ç”µè·¯ï¼Œè¯•äº†ä¸‹ï¼Œå¥½åƒæ€»æ˜¯è¯­æ³•æœ‰é—®é¢˜...12345678910111213141516171819202122232425262728293031323334353637383940CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no zr ng Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=z5); Not16(in=z5, out=z6); Inc16(in=z6, out=z7); Or16(a=z5, b=z7, out[15]=z8); Not(in=z8, out=zr); And16(a=z5, b=true, out[15]=ng); Mux16(a=z3, b=z4, sel=no, out=out);&#125; Unit 2.6 Perspectivesè¿™å‘¨çš„é—®é¢˜ä¸»è¦æœ‰ 4 ä¸ªï¼š ç›®å‰æ‰€æž„å»ºçš„å¤§çº¦ 20 ç§é€»è¾‘ç”µè·¯ï¼Œæ˜¯å¦éƒ½æ˜¯æ ‡å‡†çš„ï¼Ÿ é—®è¿™ä¸ªé—®é¢˜çš„äººå£ä¸­çš„æ ‡å‡†åº”è¯¥æ˜¯ç›¸å¯¹äºŽå·¥ä¸šç•Œè€Œè¨€çš„ï¼Œè€å¸ˆçš„å›žç­”å¾ˆç›´æŽ¥ï¼Œé™¤äº†ç”¨äºŽå­¦ä¹ çš„ ALUï¼Œå…¶ä»–éƒ½æ˜¯æ ‡å‡†çš„ã€‚å…¶å®žä»”ç»†ä¸€æƒ³ï¼Œå¤ªåº•å±‚çš„ä¸œè¥¿ï¼Œåè€Œæ²¡æœ‰å¤šç§æž„å»ºæ–¹æ³•ï¼Œå¤§å®¶ç”¨çš„å…¶å®žéƒ½æ˜¯é‚£ä¸€å¥—ã€‚ ç›®å‰å®žçŽ°çš„ ALU ä¸ºä½•ä¸èƒ½æä¾›ä¹˜æ³•æˆ–é™¤æ³•ï¼Ÿ å› ä¸ºè¯¾ç¨‹ä¸­å®žçŽ°çš„ ALU è¿‡äºŽç®€å•ï¼Œåªæ˜¯ä¸ºäº†å­¦ä¹ ä½¿ç”¨ã€‚ä½†ä½ ä¾ç„¶å¯ä»¥è‡ªå·±åŽ»å®žçŽ°ä¹˜æ³•æˆ–é™¤æ³•ï¼Œè¿™å–å†³äºŽå¼€å‘è€…æ˜¯å¦éœ€è¦ç»™å®ƒæ·»åŠ è¿™ä¸ªåŠŸèƒ½ã€‚ è¯¾ç¨‹ä¸­çš„ ALU æ˜¯å¦é«˜æ•ˆï¼Ÿ è¯¾ç¨‹ä¸­è®¾è®¡çš„å¤§å¤šæ•°é€»è¾‘ç”µè·¯éƒ½æ˜¯é«˜æ•ˆçš„ï¼Œä½†æœ‰ä¸€ç§ä»ç„¶å¯ä»¥æ”¹è¿›çš„æ›´é«˜æ•ˆï¼Œé‚£å°±æ˜¯â€”â€”Adderã€‚ç›®å‰å®ƒâ€œä½Žæ•ˆâ€çš„åŽŸå› åœ¨äºŽï¼Œå…¶å†…éƒ¨å®žçŽ°æ˜¯ç”±å¤šä¸ªå…¨åŠ å™¨â€œä¸²â€èµ·æ¥çš„ï¼Œæ‰€ä»¥äºŒè¿›åˆ¶æ¯”ç‰¹æµçš„æµåŠ¨å­˜åœ¨ä¸€å®šçš„å»¶è¿Ÿã€‚ ä¸ºä½•å»ºè®®å­¦ç”Ÿä½¿ç”¨ built-in chipsï¼Ÿ ç¬¬ä¸€ï¼Œä½¿ç”¨ built-in chips ä¼šæ›´åŠ é«˜æ•ˆï¼›ç¬¬äºŒæ˜¯å› ä¸ºå¯ä»¥é¿å…ä¸€äº›æœªçŸ¥çš„é”™è¯¯ï¼Œè€Œè¿™äº›é”™è¯¯å¯èƒ½æ˜¯ç”±æ¨¡æ‹Ÿå™¨çš„ bug å¯¼è‡´çš„ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™å¹¶ä¸æ˜¯ä½ çš„ä»£ç æœ‰é—®é¢˜ï¼›ç¬¬ä¸‰ï¼Œæ¨¡æ‹Ÿå™¨å¹¶ä¸é«˜æ•ˆï¼Œä½¿ç”¨è‡ªå·±æž„å»ºçš„ chips å¯èƒ½ä¼šè¿›ä¸€æ­¥é™ä½Žæ•ˆçŽ‡ã€‚ è¿™å‘¨å†…å®¹çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•æž„å»º ALUï¼Œå¯è§åœ¨æ²¡æœ‰é«˜çº§è¯­è¨€çš„å¸®åŠ©ä¸‹ï¼Œå¦‚æžœæƒ³è¦åœ¨åº•å±‚å®žçŽ°ä¸€äº›å¤æ‚é€»è¾‘ï¼Œè¿˜æ˜¯æŒºè´¹è„‘å­çš„ã€‚å¦å¤–ï¼Œè¿˜æœ‰ä¸€å—çŸ¥è¯†è€å¸ˆæ²¡æœ‰å¼ºè°ƒï¼Œå°±æ˜¯æ ¹æ®é€»è¾‘è¿ç®—æ¥æž„é€ å®žé™…è¿ç®—ï¼Œä¹Ÿå°±æ˜¯ ALU è¿™æ ·è®¾è®¡çš„èƒŒåŽåŽŸç†ï¼Œè¿™éƒ¨åˆ†å†…å®¹å¯èƒ½åˆè·Ÿç”µå­¦æœ‰ç‚¹å…³ç³»å§...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetri_Part1_01]]></title>
    <url>%2F2020%2F09%2F20%2FNand2Tetris-Part1-01%2F</url>
    <content type="text"><![CDATA[Nand2Tetris æ˜¯ç”±å¸Œä¼¯æ¥å¤§å­¦çš„ä¸¤ä½æ•™æŽˆ Noam Nisan å’Œ Shimon Schocken åœ¨ Coursera ä¸Šå¼€è®¾çš„åœ¨çº¿è¯¾ç¨‹ï¼ˆç½‘ç»œè¯¾ç¨‹ï¼‰ã€‚è¯¾ç¨‹å…¨ç§°å«åšï¼šä¾æ®åŸºæœ¬åŽŸç†æž„å»ºçŽ°ä»£è®¡ç®—æœºï¼šä»Žä¸Žéžé—¨åˆ°ä¿„ç½—æ–¯æ–¹å—ï¼ˆåŸºäºŽé¡¹ç›®çš„è¯¾ç¨‹ï¼‰ï¼Œå…¶ä¸»è¦å†…å®¹ä¸Žè®¡ç®—æœºç»„æˆåŽŸç†ã€æ“ä½œç³»ç»Ÿç­‰ç§‘ç›®çš„å…³è”æ€§è¾ƒå¤§ï¼Œä½†è¯¾ç¨‹çš„å—ä¼—ç¾¤ä½“ä¹Ÿä¸æ­¢å±€é™äºŽä¸“ä¸šäººå£«ï¼Œä¸”è¯¾ç¨‹çš„å®žè·µæ€§å¾ˆå¼ºï¼Œå¯¹æ·±å…¥ç†è§£ç†è®ºçŸ¥è¯†å¾ˆæœ‰å¸®åŠ©ã€‚ Introductionç¬¬ä¸€å‘¨åŒ…å«ä¸¤ä¸ªç« èŠ‚ï¼ˆä¸€èˆ¬æƒ…å†µä¸‹ï¼Œä¸€å‘¨ä¸€ä¸ªï¼‰ï¼šIntroduction å’Œ Boolean Functions and Gate Logicã€‚é¡¾åæ€ä¹‰ï¼ŒIntroduction æ˜¯å¯¹æœ¬è¯¾ç¨‹çš„è¯´æ˜Žï¼ŒBoolean Functions and Gate Logic æ‰æ˜¯ç¬¬ä¸€å‘¨çš„çœŸæ­£çš„å­¦ä¹ å†…å®¹ã€‚é€šè¿‡ Introduction å¯ä»¥çŸ¥é“å¤§ä½“çš„å­¦ä¹ è·¯çº¿æ˜¯ä»ŽåŸºæœ¬çš„é€»è¾‘é—¨å•å…ƒå¼€å§‹ï¼Œè‡ªä¸‹è€Œä¸Šçš„å­¦ä¹ å¦‚ä½•æž„å»ºè®¡ç®—æœºï¼Œç»§è€Œæž„å»ºå‡ºèƒ½åœ¨è¿™å°è®¡ç®—æœºä¸Šè¿è¡Œçš„ç¨‹åºï¼Œä¹Ÿå³ï¼šNand -&gt; Hack -&gt; Tetrisã€‚å¦å¤–ï¼Œå¯¹äºŽè´­ä¹°äº†è¯¾ç¨‹çš„åŒå­¦è€Œè¨€ï¼Œè¿™ç« èŠ‚ä¼šæœ‰ä¸€ä¸ªç¼–ç¨‹ä½œä¸šï¼Œç”¨æ¥ç»ƒä¹ å¦‚ä½•åœ¨ Coursera ä¸Šæäº¤ä½œä¸šã€‚ä½†å¦‚æžœä½ æ˜¯æ—å¬ç”Ÿï¼ˆauditorï¼‰ï¼Œé‚£ä¹ˆå¯ä»¥å¿½ç•¥æŽ‰ã€‚ Boolean Functions and Gate Logicè¿™éƒ¨åˆ†å†…å®¹å±žäºŽè®¡ç®—æœºç³»ç»Ÿç»“æž„åº•å±‚ä¸­çš„åº•å±‚ï¼Œè¯¾ç¨‹ä»Žä¸€ä¸ªå°å°é—¨é€»è¾‘ç”µè·¯å¼€å§‹è®²èµ·ï¼ˆå½“ç„¶ä¸ä¼šè®²ä¸Žç‰©ç†ç›¸å…³çš„å†…å®¹ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆè®©å¤§å®¶ä¸è¦è¿‡åˆ†åœ¨æ„çš„åœ°æ–¹ï¼‰ï¼Œé€æ­¥ä»‹ç»å„ç§ä¸åŒçš„é€»è¾‘ç”µè·¯ï¼Œå¹¶è‡ªè¡Œæž„é€ å…·æœ‰ä¸€å®šå¤æ‚æ€§çš„å¤åˆé€»è¾‘é—¨ç”µè·¯ã€‚ Unit 1.1 Boolean Logicæœ¬å°èŠ‚ä¸»è¦ä»‹ç»äº†ä¸‰ç§åŸºæœ¬çš„é€»è¾‘é—¨ï¼ˆLogic gateï¼‰ï¼šä¸Žï¼ˆAndï¼‰ã€æˆ–ï¼ˆOrï¼‰å’Œéžï¼ˆNotï¼‰ï¼Œå¹¶ä¸¾ä¾‹è¯´æ˜Žäº†ä¸Žä¹‹å¯¹åº”çš„åŸºæœ¬è¿ç®—æ–¹æ³•å’Œè§„å¾‹ã€‚ ä¸‰ç§é€»è¾‘é—¨çš„çœŸå€¼è¡¨ï¼ˆTruth tableï¼‰å¦‚ä¸‹ï¼šAndï¼š$$\begin{array}{cc|c}x &amp; y &amp; And \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Orï¼š$$\begin{array}{cc|c}x &amp; y &amp; Or \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Notï¼š$$\begin{array}{c|c}x &amp; Not \\\hline0 &amp; 0 \\1 &amp; 0 \\\end{array}$$ è¿ç®—è§„å¾‹ï¼š äº¤æ¢å¾‹ï¼ˆCommutative Lawï¼‰ x and y = y and x x or y = y or x ç»“åˆå¾‹ï¼ˆAssociative Lawï¼‰ x and (y and z) = (x and y) and z x or (y or z) = (x or y) or z åˆ†é…å¾‹ï¼ˆDistributive Lawï¼‰ x and (y or z) = (x and y) or (x and z) x or (y and z) = (x or y) and (x or z) å¾·æ‘©æ ¹å¾‹ï¼ˆDe Morgan Lawï¼‰ not (x and y) = (not x) or (not y) not (x or y) = (not x) and (not y) ä»¥ä¸ŠåŸºæœ¬å†…å®¹è¯´ä¸å®šå°±ä¼šç”¨åˆ°ï¼Œè®°å½•ä¸‹ã€‚ Unit 1.2 Boolean Functions Synthesisæœ¬å°èŠ‚ä¸»è¦è®²äº†ä¸‰ç‚¹ï¼š å¦‚ä½•æ ¹æ®çœŸå€¼è¡¨æ¥åå‘æž„é€ å¸ƒå°”å‡½æ•° ä»‹ç»äº†ä¸€ä¸ªç»“è®ºï¼šä»»æ„å¸ƒå°”å‡½æ•°éƒ½èƒ½è¢«ä¸Žæˆ–éžä¸‰ç§è¿ç®—è¡¨ç¤ºï¼ˆAny Boolean function can be represented using an expression containing AND, OR and NOT operations.ï¼‰ æŽ¥ä¸‹æ¥ä¼šç”¨ä¸Žéžé—¨ï¼ˆNandï¼‰æ¥æž„å»ºå…¶ä»–é€»è¾‘é—¨ Unit 1.3 Logic gatesæœ¬å°èŠ‚ç€é‡åœ¨è¯´æ˜Žä¸€ä¸ªé—®é¢˜ï¼Œå³ï¼šè¿™é—¨è¯¾ç¨‹ä¸ä¼šä»Žç‰©ç†å±‚é¢æ·±ç©¶è¿™ç§é€»è¾‘é—¨æ˜¯æ€Žæ ·å®žçŽ°çš„ï¼Œä½†æ˜¯ä¼šæŽ¢è®¨å¦‚ä½•åˆ©ç”¨åŸºç¡€é€»è¾‘é—¨æ¥æž„å»ºå¤åˆé€»è¾‘é—¨ã€‚å¦å¤–ï¼Œè¿˜ä»‹ç»äº†åœ¨è¿™ä¸ªè¯¾ç¨‹ä¸­ä¼šè§åˆ°çš„ä¸€äº›æè¿°ç”¨è¯­ã€‚PSï¼šGod bless their souls. æ„Ÿè§‰åƒæ˜¯åœ¨å˜²è®½å‘¢ï¼ˆç¬‘ï¼‰ã€‚ Unit 1.4 Hardware Description Languageæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜Žç¡¬ä»¶æè¿°è¯­è¨€ï¼ˆåŽé¢ä¼šç®€ç§° HDLï¼‰çš„è¯­æ³•è§„åˆ™ï¼Œä¸å¤šï¼Œå»ºè®®ç›´æŽ¥è‡ªå·±çœ‹è€å¸ˆæä¾›çš„æ‰‹å†Œï¼Œå¹¶è¯•ç€å†™ä¸‹ä»£ç ï¼Œæœ‰äº†ä¸€å®šçš„æ„Ÿæ€§è®¤è¯†åŽï¼Œå†æ¥å¬ï¼Œå¯èƒ½ä¼šæ”¶èŽ·å¤šä¸€ç‚¹ã€‚ Unit 1.5 Hardware Simulationæœ¬å°èŠ‚ä¸»è¦åœ¨è®²å¦‚ä½•ä½¿ç”¨è¯¾ç¨‹æä¾›çš„ç¡¬ä»¶æ¨¡æ‹Ÿå™¨å’Œä¸€äº›æ³¨æ„äº‹é¡¹ã€‚ Unit 1.6 Multi Bit Busesæœ¬å°èŠ‚ä¸»è¦åœ¨è¯´æ˜Žå¤šä½ï¼ˆbitï¼‰é€»è¾‘é—¨åœ¨æœ¬è¯¾ç¨‹æ‰€ç”¨çš„ HDL ä¸­çš„ç”¨æ³•ï¼Œå¹¶é¡ºä¾¿å¤§è‡´çš„è¯´æ˜Žäº†ä¸€ä¸‹æ€»çº¿çš„å«ä¹‰ï¼Œå¯¹åŽé¢æž„é€ ä½é€»è¾‘å•å…ƒæœ‰ä¸€å®šå¸®åŠ©ï¼Œç‰¹åˆ«æ˜¯æœ‰ HDL ä»£ç çš„åœ°æ–¹ï¼Œå¯¹åŽé¢çš„ä½œä¸šå¾ˆæœ‰å¸®åŠ©ã€‚ Unit 1.7 Project 1 Overviewæœ¬å°èŠ‚ä¸»è¦åœ¨ä»‹ç»ç¬¬ä¸€å‘¨çš„ä½œä¸šä»¥åŠè¿™å‘¨ä½œä¸šå¯¹äºŽåŽç»­è¯¾ç¨‹çš„æ„ä¹‰ã€‚ä¸å¾—ä¸è¯´ï¼Œå›½å†…è€å¸ˆä»Žæ¥ä¸ä¼šè·Ÿä½ è®²ä½œä¸šçš„æ„ä¹‰ï¼Œæœ€å¤šç»™ä½ è®²è®²é”™é¢˜ã€‚ æ‰¯è¿œäº†ï¼Œæ¯å‘¨ä½œä¸šåŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼šä»£ç æºæ–‡ä»¶ï¼ˆ.hdlï¼‰ã€æµ‹è¯•è„šæœ¬ï¼ˆ.tstï¼‰å’Œæ¯”å¯¹æ–‡ä»¶ï¼ˆ.cmpï¼‰ï¼ˆå…¶å®žå°±æ˜¯ç¨‹åºæ­£ç¡®çš„è¿è¡Œç»“æžœï¼‰ï¼Œæ¯ä¸€ä¸ªå°ä½œä¸šï¼ˆå°±æ˜¯ä½ è¦å®žçŽ°çš„æ¯ä¸€ä¸ªå°èŠ¯ç‰‡ï¼‰éƒ½åŒ…å«è¿™ä¸‰ä¸ªæ–‡ä»¶ã€‚å¥½æ¶ˆæ¯æ˜¯æµ‹è¯•è„šæœ¬è·Ÿæ­£ç¡®ç­”æ¡ˆè€å¸ˆéƒ½å‡†å¤‡å¥½äº†ï¼Œåæ¶ˆæ¯æ˜¯ä»£ç å¾—è‡ªå·±å†™ï¼ˆå…¶å®žä¹Ÿä¸ç®—åæ¶ˆæ¯ï¼Œæœ¬å°±æ˜¯åˆ†å†…ä¹‹äº‹ï¼Œç¬‘ï¼‰ï¼Œä¸‹é¢æˆ‘ä»¬æ¥å®Œæˆè¿™å‘¨çš„ä½œä¸šã€‚ PSï¼šæœ‰ä¸€ç‚¹è¦æ³¨æ„ï¼Œä¸‹é¢è¿™äº›é€»è¾‘é—¨å®žçŽ°çš„æ–¹å¼ä¸å”¯ä¸€ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆä¸€å†å¼ºè°ƒçš„ä¸œè¥¿ã€‚ NotNand æ˜¯æˆ‘ä»¬åœ¨è¿™ä¸ªè¯¾ç¨‹ä¸­å¯ä»¥ç›´æŽ¥ä½¿ç”¨çš„åŸºæœ¬é€»è¾‘é—¨ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨ï¼ŒNot æ˜¯æˆ‘ä»¬è¦å®Œæˆçš„ç¬¬ä¸€ä¸ªèŠ¯ç‰‡ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ä½¿ç”¨ä¸€ä¸ªäºŒå…ƒçš„ä¸Žéžé—¨æ¥å®žçŽ°ä¸€ä¸ªä¸€å…ƒçš„éžé—¨ï¼ˆThe implementation of a unary Not gate from a binary Nand gate is simple.ï¼‰ã€‚ ä¸€å…ƒéžé—¨åªæœ‰ä¸¤ç§æƒ…å†µï¼ŒäºŒå…ƒä¸Žéžé—¨æœ‰å››ç§æƒ…å†µï¼Œé‚£ä¹ˆæˆ‘ä»¬ç›´æŽ¥ç”¨ä¸Žéžé—¨çš„å…¶ä¸­ä¸¤ç§æƒ…å†µæ¥è¡¨ç¤ºéžé—¨å³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567CHIP Not &#123; IN in; OUT out; PARTS: Nand(a=in, b=true, out=out);&#125; Andä¸€å¼€å§‹æ€è€ƒå¦‚ä½•å®žçŽ° And æ—¶ï¼Œæœ‰ç‚¹æ— ä»Žä¸‹æ‰‹çš„æ„Ÿè§‰åŽæ¥ï¼Œæƒ³äº†ä¸€ä¼šï¼Œæƒ³åˆ°äº†ä¸¤ç§æ–¹æ³•ï¼š ä½¿ç”¨ 2 ä¸ª Nand ä½¿ç”¨ 1 ä¸ª Nandï¼Œåœ¨ä½¿ç”¨ 1 ä¸ª Not 12345678910111213CHIP And &#123; IN a, b; OUT out; PARTS: /* method 1: use 2 Nand Nand(a=a, b=b, out=c); Nand(a=c, b=true, out=out); */ /* method 2: use Nand and Not */ Nand(a=a, b=b, out=c); Not(in=c, out=out);&#125; Orå®žçŽ° And ä¹‹åŽï¼Œæ­¤æ—¶æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸Šé¢å®žçŽ°å¥½äº†çš„é€»è¾‘é—¨æ¥å¸®åŠ©å®žçŽ° Orã€‚ 12345678910CHIP Or &#123; IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=nota, b=notb, out=e); Not(in=e, out=out);&#125; Xorå¼‚æˆ–è¿ç®—æœ‰ç‚¹ç‰¹æ®Šï¼ŒåŒæ ·è¿˜æ˜¯ç”¨å·²ç»å®žçŽ°è¿‡çš„é€»è¾‘é—¨æ¥å®žçŽ°ã€‚123456789CHIP Xor &#123; IN a, b; OUT out; PARTS: Or(a=a, b=b, out=c); Nand(a=a, b=b, out=d); And(a=c, b=d, out=out);&#125; MuxMux å…¨ç§° Multiplexorï¼Œå³å¤šè·¯å¤ç”¨å™¨ï¼ˆå¤§æ¦‚æ˜¯è¿™ä¸ªæ„æ€å§ï¼‰ï¼Œè¿™ä¸ªä¸œè¥¿åº”è¯¥æ˜¯é€šä¿¡ä¸“ä¸šåŒå­¦ç ”ç©¶çš„ä¸œè¥¿ï¼Œæœ‰ä¸‰ä¸ªè¾“å…¥ï¼šaï¼Œb å’Œ selã€‚è§„åˆ™å°±æ˜¯æ ¹æ® sel çš„å€¼æ¥ç¡®å®šè¾“å‡º a è¿˜æ˜¯ bï¼Œsel æœ‰ç‚¹åƒæ˜¯æ ¡éªŒç ä¹‹ç±»çš„ä¸œè¥¿å§ã€‚ ç²—ç•¥åˆ†æžä¸€ä¸‹ï¼ŒMux æœ‰å…«ç§æƒ…å†µï¼Œæˆ‘ä»¬å…ˆè§‚å¯Ÿä¸€ä¸‹å®ƒçš„çœŸå€¼è¡¨ã€‚$$\begin{array}{ccc|c}a &amp; b &amp; sel &amp; Mux \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 \\\end{array}$$Mux çš„ç»“æžœä¸­æœ‰ 4 ä¸ªå€¼ä¸ºçœŸï¼Œä»”ç»†å›žæƒ³ä¸€ä¸‹è€å¸ˆåœ¨ 1.2 è®²çš„æœ‰å…³åå‘æž„é€ å¸ƒå°”å‡½æ•°çš„çŸ¥è¯†ï¼Œé¦–å…ˆå…ˆåˆ—å‡ºæ‰€æœ‰çœŸå€¼çš„è¡¨è¾¾å¼ï¼Œä¹Ÿå°±æ˜¯ä¸Šè¡¨ä¸­çš„ç¬¬ 3ã€4ã€6ã€8 è¡Œï¼Œå¯å¾—ï¼š ç¬¬ 3 è¡Œï¼ša and (not b) and (not sel) ç¬¬ 4 è¡Œï¼ša and b and (not sel) ç¬¬ 6 è¡Œï¼šnot a and b and sel ç¬¬ 8 è¡Œï¼ša and b and sel ç»§è€Œæˆ‘ä»¬å¯ä»¥å¾—åˆ° Mux çš„å¸ƒå°”å‡½æ•°å¼å­ï¼š(a and (not b) and (not sel)) or (a and b and (not sel)) or ((not a) and b and sel) or (a and b and sel)ã€‚æ±—ï¼ŒçœŸé•¿ï¼Œä¸è¿‡å…ˆä¸ç®¡ï¼Œæˆ‘ä»¬ç›´æŽ¥æŒ‰ç…§è¿™ä¸ªå‡½æ•°æ¥å†™ä»£ç ï¼Œå¯ä»¥å¾—åˆ°ä»¥ä¸‹ä»£ç ï¼š12345678910111213141516171819202122232425CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=b, out=notb); Not(in=sel, out=notsel); Not(in=a, out=nota); And(a=a, b=notb, out=u1); And(a=u1, b=notsel, out=u2); And(a=a, b=b, out=v1); And(a=v1, b=notsel, out=v2); And(a=nota, b=b, out=w1); And(a=w1, b=sel, out=w2); And(a=a, b=b, out=x1); And(a=x1, b=sel, out=x2); Or(a=u2, b=v2, out=y1); Or(a=y1, b=w2, out=y2); Or(a=y2, b=x2, out=out);&#125; æµ‹è¯•åŽç»“æžœæ˜¯æ­£ç¡®çš„ï¼Œä¸è¿‡è¿™æ˜¾ç„¶ä¸å¤Ÿè€å¸ˆè¯´çš„ elegantï¼ˆç¬‘ï¼‰ï¼Œæˆ‘ä»¬æ¥æŠŠå¸ƒå°”å‡½æ•°å¼æ ¹æ®è¿ç®—è§„åˆ™åŒ–ç®€ä¸€ä¸‹ï¼Œå¯å¾—ï¼š(a and (not sel)) or (b and sel)ï¼Œä»Žè€Œå¯å¾—ï¼š12345678910CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=sel, out=notsel); And(a=a, b=notsel, out=u); And(a=b, b=sel, out=v); Or(a=u, b=v, out=out);&#125; æµ‹è¯•åŽç»“æžœä¾ç„¶æ­£ç¡®ï¼Œè¯´æ˜ŽåŒ–ç®€æ˜¯æ­£ç¡®çš„ã€‚ ä¸ºä»€ä¹ˆè¦ä½¿ç”¨ä¸Šé¢çš„æ–¹æ³•æ¥æž„é€ å¸ƒå°”å‡½æ•°ï¼Ÿå› ä¸ºæ­¤æ—¶æˆ‘ä»¬èƒ½ç”¨çš„é€»è¾‘é—¨å·²ç»ä¸ä»…ä»…åªæœ‰ Nandï¼Œè¿˜æœ‰å…ˆå‰å·²ç»æž„é€ å¥½äº†çš„ Andã€Notã€Orã€Xorï¼Œè¿™äº›éƒ½å¯ä»¥ç›´æŽ¥æ‹¿æ¥ç”¨äº†ï¼Œé‚£è¿˜è´¹è„‘å­æ­»æƒ³å¹²å˜›å‘¢ã€‚å½“ç„¶äº†ï¼Œè¿™ä¹Ÿæ˜¯è€å¸ˆå¼ºè°ƒè¿‡çš„æ€æƒ³ã€‚ å¦å¤–ï¼Œé€šè¿‡ä¸Šé¢çš„è®¡ç®—è¿‡ç¨‹å’Œè€å¸ˆçš„è®²è§£ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°åå‘æž„é€ å¸ƒå°”å‡½æ•°æ—¶çš„å‡ ä¸ªè¦ç‚¹ï¼š é€‰å–ç»“æžœåºåˆ—ä¸­çœŸå€¼æˆ–å‡å€¼è¾ƒå°‘çš„ä¸€æ–¹ï¼Œä¸Šé¢çš„ Mux ä¸­çœŸå‡å€¼éƒ½æ˜¯ 4 ä¸ªï¼Œä»»å–å³å¯ ç”¨æ¯ä¸€ä¸ªå€¼å†™å‡ºçš„å¼å­å¿…é¡»ä¿è¯å…¶ä¸­çš„æ¯ä¸€å­é¡¹çš†ä¸ºçœŸæˆ–å‡ï¼Œæ¯”å¦‚ä»¥ä¸Šé¢ç¬¬ 3 è¡Œä¸ºä¾‹ï¼Œaã€not b å’Œ not sel çš„å€¼éƒ½æ˜¯ 1 å•ä¸ªå¼å­çš„æ¯ä¸€å­é¡¹è¦è¿›è¡Œ and è¿ç®—ï¼Œè€Œæ¯ä¸ªå¼å­ä¹‹é—´åˆ™ç”¨ or è¿ç®— PSï¼šæœ‰å…³é€»è¾‘å¼å­åŒ–ç®€çš„é—®é¢˜ï¼Œåº”è¯¥å±žäºŽç¦»æ•£æ•°å­¦çš„çŸ¥è¯†ã€‚ DMuxDMuxï¼ŒDemultiplexorï¼Œå³è§£å¤ç”¨å™¨ï¼Œä¸Ž Mux æ˜¯ä¸€å¯¹ï¼ŒäºŒè€…çš„åŠŸèƒ½ä¹Ÿæ­£å¥½ç›¸åï¼Œä½† DMux çš„ç‰¹æ®Šæ€§åœ¨äºŽå®ƒæœ‰ä¸¤ä¸ªè¾“å‡ºã€‚æˆ‘ä»¬è¿˜æ˜¯æŒ‰ç…§ä¸Šé¢çš„æ€è·¯æ¥æž„å»ºï¼Œå…ˆçœ‹ä¸€ä¸‹ DMux çš„çœŸå€¼è¡¨$$\begin{array}{c|cc}sel &amp; a &amp; b \\\hline0 &amp; in &amp; 0 \\1 &amp; 0 &amp; in \\\end{array}$$è¿™æ˜¯è€å¸ˆæä¾›çš„èµ„æ–™ä¸Šçš„çœŸå€¼è¡¨ï¼Œå¥½åƒä¸æ˜¯å¾ˆæ˜“äºŽåˆ†æžé—®é¢˜ï¼Œé‚£æˆ‘ä»¬æŠŠè¯¦ç»†çš„çœŸå€¼è¡¨æ•´ç†å‡ºæ¥ï¼š$$\begin{array}{cc|cc}sel &amp; in &amp; a &amp; b \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 \\\end{array}$$è¿™æ ·ï¼Œæˆ‘ä»¬åœ¨åˆ†æžè¿™ä¸ªé—®é¢˜æ—¶ï¼Œå°±å¯ä»¥å•ç‹¬è€ƒè™‘å¦‚ä½•åˆ©ç”¨ sel å’Œ in åˆ†åˆ«å¾—åˆ° aã€b è¿™ä¸¤åˆ—å€¼ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011CHIP DMux &#123; IN in, sel; OUT a, b; PARTS: Not(in=in, out=notin); Or(a=sel, b=notin, out=v1); Not(in=v1, out=a); And(a=sel, b=in, out=b);&#125; Not16å¤šä½é€»è¾‘é—¨æ˜¯è€å¸ˆåœ¨ 1.6 è®²è¿‡çš„å†…å®¹ï¼Œæž„é€ çš„åŸºæœ¬æ€æƒ³å°±æ˜¯æ¯ä¸€ä½éƒ½ç”¨ä¸€ä¸ªé€»è¾‘é—¨æ¥è®¡ç®—ï¼Œç»„åˆåœ¨ä¸€èµ·å°±å¯ä»¥äº†ã€‚12345678910111213141516171819202122CHIP Not16 &#123; IN in[16]; OUT out[16]; PARTS: Not(in=in[0], out=out[0]); Not(in=in[1], out=out[1]); Not(in=in[2], out=out[2]); Not(in=in[3], out=out[3]); Not(in=in[4], out=out[4]); Not(in=in[5], out=out[5]); Not(in=in[6], out=out[6]); Not(in=in[7], out=out[7]); Not(in=in[8], out=out[8]); Not(in=in[9], out=out[9]); Not(in=in[10], out=out[10]); Not(in=in[11], out=out[11]); Not(in=in[12], out=out[12]); Not(in=in[13], out=out[13]); Not(in=in[14], out=out[14]); Not(in=in[15], out=out[15]);&#125; And1612345678910111213141516171819202122CHIP And16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]);&#125; Or1612345678910111213141516171819202122CHIP Or16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: Or(a=a[0], b=b[0], out=out[0]); Or(a=a[1], b=b[1], out=out[1]); Or(a=a[2], b=b[2], out=out[2]); Or(a=a[3], b=b[3], out=out[3]); Or(a=a[4], b=b[4], out=out[4]); Or(a=a[5], b=b[5], out=out[5]); Or(a=a[6], b=b[6], out=out[6]); Or(a=a[7], b=b[7], out=out[7]); Or(a=a[8], b=b[8], out=out[8]); Or(a=a[9], b=b[9], out=out[9]); Or(a=a[10], b=b[10], out=out[10]); Or(a=a[11], b=b[11], out=out[11]); Or(a=a[12], b=b[12], out=out[12]); Or(a=a[13], b=b[13], out=out[13]); Or(a=a[14], b=b[14], out=out[14]); Or(a=a[15], b=b[15], out=out[15]);&#125; Mux1612345678910111213141516171819202122CHIP Mux16 &#123; IN a[16], b[16], sel; OUT out[16]; PARTS: Mux(a=a[0], b=b[0], sel=sel, out=out[0]); Mux(a=a[1], b=b[1], sel=sel, out=out[1]); Mux(a=a[2], b=b[2], sel=sel, out=out[2]); Mux(a=a[3], b=b[3], sel=sel, out=out[3]); Mux(a=a[4], b=b[4], sel=sel, out=out[4]); Mux(a=a[5], b=b[5], sel=sel, out=out[5]); Mux(a=a[6], b=b[6], sel=sel, out=out[6]); Mux(a=a[7], b=b[7], sel=sel, out=out[7]); Mux(a=a[8], b=b[8], sel=sel, out=out[8]); Mux(a=a[9], b=b[9], sel=sel, out=out[9]); Mux(a=a[10], b=b[10], sel=sel, out=out[10]); Mux(a=a[11], b=b[11], sel=sel, out=out[11]); Mux(a=a[12], b=b[12], sel=sel, out=out[12]); Mux(a=a[13], b=b[13], sel=sel, out=out[13]); Mux(a=a[14], b=b[14], sel=sel, out=out[14]); Mux(a=a[15], b=b[15], sel=sel, out=out[15]);&#125; Or8Way12345678910111213CHIP Or8Way &#123; IN in[8]; OUT out; PARTS: Or(a=in[0], b=in[1], out=v1); Or(a=v1, b=in[2], out=v2); Or(a=v2, b=in[3], out=v3); Or(a=v3, b=in[4], out=v4); Or(a=v4, b=in[5], out=v5); Or(a=v5, b=in[6], out=v6); Or(a=v6, b=in[7], out=out);&#125; Mux4Way164 è·¯ Mux16 ä½¿ç”¨ä¸‰ä¸ª Mux16 å³å¯å®Œæˆï¼Œå¯èƒ½ä¼šæœ‰äººé—®ä¸ºä»€ä¹ˆè¦å…ˆè®© a å’Œ c å…ˆé€šè¿‡ä¸€æ¬¡ Mux16ã€‚å› ä¸º sel bits æ˜¯ä»Žå³å¾€å·¦è¯»çš„ï¼Œè‹¥ a å’Œ b å…ˆé€šè¿‡ä¸€æ¬¡ Mux16ï¼Œå½“ sel[1]=0 æ—¶ï¼Œå°±æ— æ³•å¾—åˆ°æ­£ç¡®çš„è¾“å‡ºç»“æžœäº†ï¼ˆsel[0]=0ï¼Œå°±è¾“å‡º aï¼Œsel[0]=1ï¼Œå°±è¾“å‡º bï¼Œä½†ç¬¬ä¸€æ¬¡é€šè¿‡ Mux16 åŽå·²ç»è¿‡æ»¤æŽ‰ a æˆ– b äº†ï¼‰ã€‚123456789CHIP Mux4Way16 &#123; IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=c, sel=sel[1], out=v1); Mux16(a=b, b=d, sel=sel[1], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; Mux8Way16åœ¨ Mux4Way16 çš„åŸºç¡€ä¸Šæž„é€ å°±è¡Œäº†ï¼Œæ³¨æ„ä¸€ä¸‹è¿™é‡Œçš„è¯­æ³•ã€‚1234567891011CHIP Mux8Way16 &#123; IN a[16], b[16], c[16], d[16], e[16], f[16], g[16], h[16], sel[3]; OUT out[16]; PARTS: Mux4Way16(a=a, b=c, c=e, d=g, sel=sel[1..2], out=v1); Mux4Way16(a=b, b=d, c=f, d=h, sel=sel[1..2], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; DMux4Wayå…ˆç”¨ sel[1] æ¥åŒºåˆ† aã€b å’Œ cã€d ä¸¤ç»„ï¼Œåœ¨ç”¨ sel[0] åœ¨ç»„å†…åˆ†åˆ«åŒºåˆ† aã€b å’Œ cã€dã€‚123456789CHIP DMux4Way &#123; IN in, sel[2]; OUT a, b, c, d; PARTS: DMux(in=in, sel=sel[1], a=u1, b=u2); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d);&#125; DMux8Wayåœ¨ DMux4Way çš„åŸºç¡€ä¸Šæž„å»ºå°±è¡Œï¼Œæ€è·¯æ˜¯å®Œå…¨ä¸€è‡´çš„ã€‚1234567891011CHIP DMux8Way &#123; IN in, sel[3]; OUT a, b, c, d, e, f, g, h; PARTS: DMux4Way(in=in, sel=sel[1..2], a=u1, b=u2, c=u3, d=u4); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d); DMux(in=u3, sel=sel[0], a=e, b=f); DMux(in=u4, sel=sel[0], a=g, b=h);&#125; Unit 1.8 Perspectivesæœ¬å°èŠ‚ä¸»è¦è€å¸ˆä»¬å›žç­”å­¦ç”Ÿåœ¨è®ºå›åŒºæå‡ºçš„ä¸€äº›å…¸åž‹é—®é¢˜ï¼Œè¿™æ¬¡ä¸»è¦å›žç­”äº† 3 ä¸ªé—®é¢˜ï¼š èƒ½å¦ä¸ç”¨ Nand è€Œæ˜¯ç”¨å…¶ä»–çš„åŸºæœ¬é€»è¾‘é—¨æ¥æž„å»ºä¸€ä¸ªè®¡ç®—æœºï¼Ÿ ç­”æ¡ˆæ˜¯ yesï¼Œè¿™é‡Œæˆ‘ä»¬ä¸æ·±ç©¶å…·ä½“åŽŸå› ã€‚ Nand gate çš„å…·ä½“å·¥ä½œåŽŸç† è€å¸ˆç”¨ç”µè·¯å›¾è®²äº†ä¸€ä¸‹ï¼Œå½“ç„¶ï¼Œè¿™æ˜¯ç”µæ°”å·¥ç¨‹å¸ˆè¯¥å¹²çš„æ´»ï¼Œå°±ä¸å…·ä½“è®¨è®ºäº† å·¥ä¸šåå¢ƒä¸‹ä½¿ç”¨çš„ HDL è¯­è¨€ä¸Žè¯¾ç¨‹ä½¿ç”¨çš„ HDL è¯­è¨€æœ‰ä½•å·®åˆ« å·¥ä¸šçŽ¯å¢ƒç”¨çš„è‚¯å®šåŠŸèƒ½æ›´åŠ å¼ºå¤§ï¼Œæ•ˆçŽ‡æ›´é«˜ï¼Œå­¦ä¹ çš„æ—¶é—´è¾ƒé•¿ï¼›è€Œæœ¬è¯¾ç¨‹çš„ HDL è¯­è¨€åªæ˜¯ä¸ºäº†æ»¡è¶³æ•™å­¦ä½¿ç”¨ï¼Œæ‰€ä»¥åŠŸèƒ½æ€§ä¼šå¼±å¾ˆå¤šï¼Œä½†æ˜“äºŽå­¦ä¹ ï¼Œä¸”è¶³å¤Ÿæ»¡è¶³æœ¬è¯¾ç¨‹çš„æ‰€æœ‰éœ€è¦ æœ¬å‘¨å†…å®¹è¿‡äºŽåº•å±‚ï¼Œä¼°è®¡ä¸å°‘äººè§‰å¾—æ— èŠï¼Œä¸è¿‡è¿˜å¥½ä¸æ˜¯å¤ªéš¾ã€‚å½“ç„¶ï¼Œå¯èƒ½ä¼šæœ‰ç¬¬ä¸€æ¬¡ä½¿ç”¨è¿™æ ·çš„ HDL è¯­è¨€å’Œç¡¬ä»¶æ¨¡æ‹Ÿå™¨è€Œä¸ç†Ÿæ‚‰çš„é—®é¢˜ï¼Œä¸è¿‡è€å¸ˆæä¾›çš„æ‰‹å†Œå’Œè§†é¢‘çš„è®²è§£å¸®åŠ©è¿˜æ˜¯å¾ˆå¤§çš„ã€‚ä¸ªäººæ„Ÿè§‰è€å¸ˆç»™çš„æ‰‹å†Œå¦‚æžœèƒ½æ›´è¯¦ç»†ä¸€ç‚¹ï¼Œç”¨ä¾‹å†å¤šä¸€ç‚¹å°±æ›´å¥½äº†ï¼ˆä¸»è¦è¿˜æ˜¯è‡ªå·±å¤ªæ‡’ï¼Œç¬‘ï¼‰ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax è¯­æ³•å¿«é€ŸæŒ‡å—]]></title>
    <url>%2F2020%2F09%2F17%2FMathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MathJax æ˜¯ä¸€ä¸ª JavaScript åº“ï¼Œå¯ä»¥è®©ä½ ç›´æŽ¥ç”¨ Latex è¯­æ³•æ¥ä¹¦å†™æ•°å­¦å…¬å¼ï¼Œååˆ†æ–¹ä¾¿ã€‚æƒ³æ·±å…¥äº†è§£ MathJaxï¼Œç‚¹å‡»é“¾æŽ¥ï¼šMathJaxï¼Œæœ¬æ–‡æ—¨åœ¨æ•´ç†ä¸€äº›å¹³æ—¶å†™æ–‡æ¡£æ—¶å¸¸ç”¨çš„ä¸€äº›è¯­æ³•ï¼Œä¾¿äºŽå¤æŸ¥ã€‚ ä¹¦å†™ä½ç½®å¹³æ—¶å†™æ–‡æ¡£æ—¶ï¼Œå…¬å¼çš„æ”¾ç½®ä½ç½®æœ‰ä¸¤ä¸ªåœ°æ–¹ï¼šæ–‡å­—ä¸­é—´å’Œå•ç‹¬æˆå—ï¼Œè¿™å°±è·Ÿå•è¡Œä»£ç ä¸Žä»£ç å—ä¸€æ ·ã€‚ æ”¾åœ¨æ–‡å­—ä¸­é—´çš„å…¬å¼è¦ç”¨ä¸€å¯¹ç¾Žå…ƒç¬¦å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ å•ç‹¬æˆå—çš„å…¬å¼è¦ç”¨ä¸¤å¯¹ç¾Žå…ƒç¬¦å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ï¼Œæ˜¾ç¤ºä¸ºï¼š$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ å¸Œè…Šå­—æ¯ æ˜¾ç¤º è¯­æ³• æ˜¾ç¤º è¯­æ³• $\gamma$ \gamma $\delta$ \delta $\epsilon$ \epsilon $\zeta$ \zeta $\eta$ \eta $\theta$ \theta $\iota$ \iota $\kappa$ \kappa $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\pi$ \pi $\rho$ \rho $\sigma$ \sigma $\tau$ \tau $\upsilon$ \upsilon $\phi$ \phi $\chi$ \chi $\psi$ \psi $\omega$ \omega å¦‚æžœè¦å¤§å†™å¸Œè…Šå­—æ¯ï¼Œå°†è¯­æ³•çš„é¦–å­—æ¯å¤§å†™å³å¯ï¼Œå¦‚ï¼š\Sigmaï¼Œæ˜¾ç¤ºä¸ºï¼š$\Sigma$ï¼›å¦‚æžœè¦æ–œä½“å¸Œè…Šå­—æ¯ï¼Œåœ¨è¯­æ³•å‰åŠ ä¸Švarå³å¯ï¼Œå¦‚ï¼š\varsigmaï¼Œæ˜¾ç¤ºä¸ºï¼š$\varSigma$ ä¸Šä¸‹æ ‡ä¸Šæ ‡ä½¿ç”¨^ï¼Œä¸‹æ ‡ä½¿ç”¨_ï¼ŒäºŒè€…åŽé¢å†æŽ¥å­—ç¬¦ï¼Œå¦‚æžœå­—ç¬¦æ•°å¤§äºŽä¸€ä¸ªéœ€è¦ä½¿ç”¨ä¸€å¯¹èŠ±æ‹¬å·åŒ…æ‹¬èµ·æ¥ï¼Œå¦‚ï¼š$\sum_{i=0}^N$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^N$ çŸ¢é‡$\vec a$æ˜¾ç¤ºä¸ºï¼š$\vec a$ï¼›å¦‚æžœæƒ³æ”¹å˜å­—æ¯ä¸Šæ–¹çš„ç¬¦å·ï¼Œå¯ä»¥è¿™æ ·å†™$$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \overrightarrow{xy} \quad $$ï¼Œæ˜¾ç¤ºä¸ºï¼š$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \ \ \ \overrightarrow{xy} \quad $ æ‹¬å·å°æ‹¬å·ï¼š$()$ï¼Œæ˜¾ç¤ºä¸ºï¼š$()$ä¸­æ‹¬å·ï¼š$[]$ï¼Œæ˜¾ç¤ºä¸ºï¼š$[]$å°–æ‹¬å·ï¼š$&lt;&gt; \langle\rangle$ï¼Œæ˜¾ç¤ºä¸ºï¼š$&lt;&gt; \langle\rangle$\leftå’Œ\rightå¯ä»¥ä½¿ç¬¦å·å¤§å°ä¸Žä¸´è¿‘çš„å…¬å¼ç›¸é€‚åº”ï¼Œå¦‚ï¼š$(\frac{x}{y})$ï¼Œæ˜¾ç¤ºä¸ºï¼š$(\frac{x}{y})$ï¼›è€Œ$\left(\frac{x}{y})\right$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\left(\frac{x}{y}\right)$ æ±‚å’Œã€æžé™å’Œç§¯åˆ† æ±‚å’Œä½¿ç”¨\sumï¼Œå¦‚ï¼š$\sum_{i=0}^n{a_i}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sum_{i=0}^n{a_i}$ æžé™ä½¿ç”¨\limï¼Œå¦‚:$\lim_{n \to 0}e^n $ï¼Œæ˜¾ç¤ºä¸ºï¼š$\lim_{n \to 0}e^n $ ç§¯åˆ†ä½¿ç”¨\intï¼Œå¦‚ï¼š$\int_0^1 2x dx$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\int_0^1 2x dx$ åˆ†å¼ä¸Žæ ¹å¼ åˆ†å¼ä½¿ç”¨\fracï¼Œç”¨æ³•ä¸ºï¼š$\frac{å¼1}{å¼2}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\frac{å¼1}{å¼2}$ æ ¹å¼ä½¿ç”¨\sqrtï¼Œå¦‚ï¼š$\sqrt{x}{y}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sqrt{x}{y}$ ç‰¹æ®Šå‡½æ•°å¦‚ï¼š$\sin x \quad \ln x \quad \max(A, B, C)$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\sin x \quad \ln x \quad \max(A, B, C)$ ç‰¹æ®Šç¬¦å· æ˜¾ç¤º è¯­æ³• æ˜¾ç¤º è¯­æ³• $\infty$ \infty $\cup$ \cup $\cap$ \cap $\subset$ \subset $\subseteq$ \subseteq $\supset$ \supset $\in$ \in $\notin$ \notin $\varnothing$ \varnothing $\forall$ \forall $\exists$ \exists $\lnot$ \lnot $\nabla$ \nabla $\partial$ \partial ç‰¹æ®Šç¬¦å·è¿˜æœ‰å¾ˆå¤šè¿™é‡Œä¸ä¸€ä¸€åˆ—ä¸¾äº†ã€‚ ç©ºæ ¼LaTex è¯­æ³•æœ¬èº«ä¼šå¿½ç•¥ç©ºæ ¼çš„å­˜åœ¨éœ€è¦ç”¨\æ¥è½¬è¯‘ï¼Œå¦‚ï¼š$a b\ a\ b$ï¼Œæ˜¾ç¤ºä¸ºï¼š$a b\ a\ b$ï¼›ä¸€æ¬¡æ€§ç”Ÿæˆ 4 ä¸ªç©ºæ ¼ï¼Œéœ€è¦ä½¿ç”¨\quadï¼Œå¦‚ï¼š$a \quad b$ï¼Œæ˜¾ç¤ºä¸ºï¼š$a \quad b$ çŸ©é˜µåŸºæœ¬è¯­æ³• èµ·å§‹æ ‡è®°ï¼š\begin{matrix}ï¼Œ ç»“æŸæ ‡è®°ï¼š\end{matrix} æ¯ä¸€è¡Œæœ«å°¾æ ‡è®°ï¼š\\ è¡Œé—´å…ƒç´ ä¹‹é—´ç”¨&amp;åˆ†å‰² å¦‚ï¼š12345$$\begin&#123;matrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;matrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}$$ çŸ©é˜µè¾¹æ¡†ç”¨ä»¥ä¸‹å…³é”®è¯æ›¿æ¢æŽ‰èµ·å§‹ã€ç»“æŸæ ‡è®°ä¸­çš„matrixï¼Œå¦‚ï¼š pmatrixï¼šå°æ‹¬å·è¾¹æ¡† bmatrixï¼šä¸­æ‹¬å·è¾¹æ¡† Bmatrixï¼šå¤§æ‹¬å·è¾¹æ¡† vmatrixï¼šå•ç«–çº¿è¾¹æ¡† Vmatrixï¼šåŒç«–çº¿è¾¹æ¡† å¦‚ï¼š1234567891011121314151617181920212223242526272829$$\begin&#123;pmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;pmatrix&#125;$$$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$$$\begin&#123;Bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Bmatrix&#125;$$$$\begin&#123;vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;vmatrix&#125;$$$$\begin&#123;Vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Vatrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{pmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{pmatrix}$$ $$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}$$ $$\begin{Bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Bmatrix}$$ $$\begin{vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{vmatrix}$$ $$\begin{Vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Vmatrix}$$ çœç•¥å· çœç•¥å·ï¼š\dotsï¼Œå¦‚ï¼š$1 \dots 5$ï¼Œæ˜¾ç¤ºä¸ºï¼š$1 \dots 5$ æ¨ªçœç•¥å·ï¼š\cdots ç«–çœç•¥å·ï¼š\vdots æ–œçœç•¥å·ï¼š\ddots å¦‚ï¼š123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;m1&#125; &amp; a_&#123;m2&#125; &amp; \cdots &amp; a_&#123;mn&#125; \\\end&#123;bmatrix&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\\end{bmatrix}$$ è¡Œä¸­çŸ©é˜µå¦‚ï¼š$\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$( \begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix} )$ é˜µåˆ—ä½¿ç”¨arrayå…³é”®å­—ï¼ŒåŸºæœ¬è¯­æ³•ï¼š1234$$\begin&#123;array&#125;&#123;æ ¼å¼ä¸²&#125;......\end&#123;array&#125;$$ å…¶ä¸­ï¼Œâ€œæ ¼å¼ä¸²â€ç”±å››ç§å­—ç¬¦æž„æˆï¼Œåˆ†åˆ«ä¸ºï¼š lï¼Œå·¦å¯¹é½ cï¼Œå±…ä¸­ rï¼Œå³å¯¹é½ |ï¼Œå»ºç«‹ç«–ç›´çº¿ ä½¿ç”¨\hlineå¯æ’å…¥æ°´å¹³çº¿ã€‚ å¦‚ï¼š123456$$\begin&#123;array&#125;&#123;c|lll&#125;- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end&#123;array&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{array}{c|lll}- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end{array}$$ æ–¹ç¨‹ç»„ä½¿ç”¨caseså…³é”®å­—ï¼ŒåŸºæœ¬è¯­æ³•ï¼š1234$$\begin&#123;cases&#125;&#123;æ ¼å¼ä¸²&#125;......\end&#123;cases&#125;$$ å¦‚ï¼š123456$$\begin&#123;cases&#125;a_1x + b_1y + c_1z = d_1\\a_2x + b_2y + c_2z = d_2\\a_3x + b_3y + c_3z = d_3\\\end&#123;cases&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$\begin{cases}a_1x + b_1y + c_1z = d_1 \\a_2x + b_2y + c_2z = d_2 \\a_3x + b_3y + c_3z = d_3 \\\end{cases}$$æ‰€ä»¥ï¼Œåˆ†æ®µå‡½æ•°å¯ä»¥å†™æˆï¼š123456$$f(x) = \begin&#123;cases&#125;0 &amp; xä¸ºæ— ç†æ•° \\x &amp; xä¸ºæœ‰ç†æ•° \\\end&#123;cases&#125;$$ æ˜¾ç¤ºä¸ºï¼š$$f(x) =\begin{cases}0 &amp; xä¸ºæ— ç†æ•° \\x &amp; xä¸ºæœ‰ç†æ•° \\\end{cases}$$ å­—ä½“è½¬æ¢è¦å¯¹å…¬å¼çš„æŸä¸€éƒ¨åˆ†å­—ç¬¦è¿›è¡Œå­—ä½“è½¬æ¢ï¼Œä½¿ç”¨\[å­—ä½“æ ¼å¼] xxxå³å¯ï¼Œé»˜è®¤ä¸ºæ„å¤§åˆ©ä½“ï¼Œå­—ä½“æ ¼å¼ä»…åˆ—ä¸¾ä»¥ä¸‹å‡ ç§ï¼š å­—ä½“ è¯­æ³• å­—ä½“ è¯­æ³• ç½—é©¬ä½“ \rm æ„å¤§åˆ©ä½“ \it é»‘ä½“ \bf èŠ±ä½“ \cal å€¾æ–œä½“ \sl ç­‰çº¿ä½“ \sf æ•°å­¦æ–œä½“ \mit æ‰“å­—æœºå­—ä½“ \tt å°ä½“å¤§å†™å­—æ¯ \sc å¦‚ï¼š1234567$$a\ b\ c \\\rm &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\\bf &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\$$ æ˜¾ç¤ºä¸ºï¼š$$a\ b\ c \\\rm {a\ b\ c} \\\it {a\ b\ c} \\\bf {a\ b\ c} \\\it {a\ b\ c} \\$$å¦å¤–ï¼Œä¸€èˆ¬ä¼šç”¨textå…³é”®å­æ¥ä¹¦å†™æ–‡æœ¬ï¼Œå¦‚ï¼š$\text{æ— ç©·å¤§}$ï¼Œæ˜¾ç¤ºä¸ºï¼š$\text{æ— ç©·å¤§}$ã€‚ å‚è€ƒæ–‡ç« ï¼šMathJax è¯­æ³•å‚è€ƒåŸºæœ¬æ•°å­¦å…¬å¼è¯­æ³•(of MathJax)Markdown æ•°å­¦å…¬å¼è¯­æ³•]]></content>
      <categories>
        <category>Tools</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown è¯­æ³•å¿«é€ŸæŒ‡å—]]></title>
    <url>%2F2020%2F09%2F16%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[æœ‰å…³ Markdown çš„æ¦‚å¿µæ€§é—®é¢˜ï¼Œè¯·ç‚¹å‡»é“¾æŽ¥è‡ªè¡ŒæŸ¥çœ‹ã€‚æœ¬æ–‡æ—¨åœ¨æ•´ç†ä¸€äº›å¹³æ—¶å†™æ–‡æ¡£æ—¶å¸¸ç”¨çš„ä¸€äº›è¯­æ³•ï¼Œè¿™æ ·æ—¢æ–¹ä¾¿ä»–äººæŸ¥çœ‹ï¼Œä¹Ÿä»¥å…è‡ªå·±å¿˜è®°ã€‚ æ ‡é¢˜Markdown æ”¯æŒä¸¤ç§å½¢å¼çš„æ ‡é¢˜ï¼ŒSetext å’Œ atxï¼Œå¸¸ç”¨çš„æ˜¯ atx è¯­æ³•çš„æ ‡é¢˜ï¼Œæœ¬æ–‡ä»¥æ­¤ä¸ºä¸»ã€‚Atx æ ·å¼çš„æ ‡é¢˜æ¯è¡Œå¼€å¤´ä½¿ç”¨ 1-6 ä¸ªäº•å·ï¼Œäº•å·çš„ä¸ªæ•°å¯¹åº” 1-6 çº§æ ‡é¢˜ï¼ˆæœ€å¤šä¹Ÿå°± 6 çº§ï¼‰ï¼Œä¾‹å¦‚ï¼š12345# ä¸€çº§æ ‡é¢˜## äºŒçº§æ ‡é¢˜#### å››çº§æ ‡é¢˜ æ•ˆæžœå¦‚ä¸‹ï¼š å—å¼•ç”¨å—å¼•ç”¨çš„æ–¹å¼å¾ˆç®€å•ï¼Œä¾‹å¦‚ï¼š1&gt; xxxx æ•ˆæžœå¦‚ä¸‹ï¼š xxxx å¼•ç”¨å†…è¿˜å¯ä»¥åŒ…å« Markdown çš„å…¶ä»–å…ƒç´ ï¼Œå¦‚åˆ—è¡¨å’Œä»£ç å—ç­‰ï¼Œè¿™é‡Œä¸è¯¦ç»†ä»‹ç»äº†ã€‚ åˆ—è¡¨Markdown æ”¯æŒæœ‰åºåˆ—è¡¨å’Œæ— åºåˆ—è¡¨ã€‚ æ— åºåˆ—è¡¨æ— åºåˆ—è¡¨ä½¿ç”¨æ˜Ÿå·ã€åŠ å·å’Œè¿žå­—ç¬¦ï¼Œä½¿ç”¨ä»»ä¸€ç¬¦å·éƒ½å¯ä»¥å®žçŽ°ä¸€æ ·çš„æ•ˆæžœï¼Œä¾‹å¦‚ï¼š1234567891011* peach* apple* banana+ peach+ apple+ banana- peach- apple- banana æ•ˆæžœå¦‚ä¸‹ï¼š peach apple banana peach apple banana peach apple banana æœ‰åºåˆ—è¡¨æœ‰åºåˆ—è¡¨ä½¿ç”¨æ•°å­—åŠ ç‚¹å®Œæˆï¼ˆç‚¹åŽä¸Žå­—ç¬¦ä¹‹é—´æœ‰ç©ºæ ¼ï¼‰ï¼Œä¾‹å¦‚ï¼š1231. peach2. apple3. banana æ•ˆæžœå¦‚ä¸‹ï¼š peach apple banana åˆ—è¡¨ä¹‹é—´è¿˜å¯ä»¥è¿›è¡ŒåµŒå¥—ä½¿ç”¨ï¼Œå½¢æˆä¸€çº§è¡¨å¤´å’ŒäºŒçº§è¡¨å¤´è¿™æ ·çš„ä¸œè¥¿ï¼Œå¦‚ï¼š12345- xxx - xxx1. 111 2. 222 æ•ˆæžœå¦‚ä¸‹ï¼š xxx xxx 111 222 ä»£ç å—å¸¸è§ç”¨æ³•ä¸»è¦æœ‰å•è¡Œä»£ç å—å’Œå¤šè¡Œä»£ç å—ã€‚ å•è¡Œä»£ç å—å•è¡Œä»£ç å—ä½¿ç”¨ä¸€å¯¹é‡éŸ³ç¬¦``æ¥ä¹¦å†™ï¼Œç›´æŽ¥å°†ä»£ç æ”¾åˆ°é‡éŸ³ç¬¦ä¸­é—´å³å¯ï¼Œå¦‚ï¼š1`xxx` xxxxxxxxx å¤šè¡Œä»£ç å—å¤šè¡Œä»£ç å—ä½¿ç”¨ä¸‰å¯¹é‡éŸ³ç¬¦æ¥ä¹¦å†™ï¼ŒåŒæ ·å°†ä»£ç å—æ”¾åˆ°ä¸­é—´å³å¯ï¼Œå¦‚ï¼š12345(```)xxxbbbxxx(```)æ³¨æ„å®žé™…æ˜¯æ²¡æœ‰æ‹¬å·çš„ æ•ˆæžœå¦‚ä¸‹ï¼š1xxxbbbxxx æ°´å¹³çº¿å¦‚æžœä¸€è¡Œä¸­åªæœ‰ä¸‰ä¸ªä»¥ä¸Šçš„è¿žå­—ç¬¦ã€æ˜Ÿå·æˆ–ä¸‹åˆ’çº¿ï¼Œåˆ™ä¼šåœ¨è¯¥ä½ç½®sç”Ÿæˆä¸€ä¸ª&lt;hr&gt;æ ‡ç­¾ï¼Œè¿™æ¡çº¿å¯ä»¥å«æ°´å¹³çº¿ï¼Œä¹Ÿå¯ä»¥å«åˆ†å‰²çº¿ï¼Œæ•ˆæžœå¦‚ä¸‹ï¼š ä¸åŒçš„ Markdown ç¼–è¾‘å™¨æ¸²æŸ“å‡ºæ¥çš„æ•ˆæžœå¯èƒ½ä¸ä¸€æ ·ã€‚ è¡¨æ ¼Markdown å†…è¡¨æ ¼çš„ç”¨æ³•æœ‰ç‚¹éº»çƒ¦ï¼Œéœ€è¦ä½¿ç”¨å†’å·ã€ç«–çº¿å’Œè¿žå­—ç¬¦æ¥å®Œæˆï¼Œå¦‚ï¼š1234è¡¨å¤´ | è¡¨å¤´ | è¡¨å¤´-- | :--: | --:1 | 2 | 34 | 5 | 6 æ•ˆæžœå¦‚ä¸‹ï¼š è¡¨å¤´ è¡¨å¤´ è¡¨å¤´ 1 2 3 4 5 6 å¤§è‡´è¯´æ˜Žä¸€ä¸‹ï¼šç¬¬äºŒè¡Œæ˜¯æ ¼å¼æŽ§åˆ¶è¡Œï¼Œ-æœ‰ä¸€ä¸ªå°±å¯ä»¥äº†ï¼Œæœ‰æ—¶ä¸ºäº†å¯¹é½ä¼šå¤šåŠ å‡ ä¸ªï¼›é™¤äº†ç¬¬äºŒè¡Œå¤–çš„å…¶ä»–è¡Œä¸­çš„æ–‡å­—æ˜¯é»˜è®¤å±…å·¦çš„ï¼Œä¸¤è¾¹éƒ½åŠ :ï¼Œå°±å¯ä»¥å±…ä¸­ï¼Œå³è¾¹åŠ :å°±å¯ä»¥å±…å³ã€‚ è¡¨æ ¼ä¸­çš„æ–‡å­—ä¹Ÿèƒ½ä½¿ç”¨ Markdown ä¸­æ–‡å­—ç›¸å…³çš„è¯­æ³•ï¼›å¦‚æžœæƒ³è¦æ”¹å˜è¡¨æ ¼ä¸­æ–‡å­—çš„é¢œè‰²ï¼Œå¯ä»¥å€ŸåŠ©fontæ ‡ç­¾æ¥å®Œæˆã€‚ æ–‡å­—ä¸Žæ–‡å­—ç›¸å…³çš„è¯­æ³•ï¼Œå¦‚ï¼š1234**åŠ ç²—***æ–œä½“****æ–œä½“åŠ ç²—***~~åˆ é™¤~~ æ•ˆæžœå¦‚ä¸‹ï¼šåŠ ç²—æ–œä½“æ–œä½“åŠ ç²—åˆ é™¤ å›¾ç‰‡å¼•ç”¨åŸºæœ¬è¯­æ³•ï¼Œå¦‚ï¼š123![å›¾ç‰‡åç§°](å›¾ç‰‡åœ°å€ &quot;å›¾ç‰‡ä¸‹æ ‡é¢˜&quot;)å¦‚ï¼š![zzz](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600276810120&amp;di=ffb59bf5363570267ac8201139b33c94&amp;imgtype=0&amp;src=http%3A%2F%2Fa2.att.hudong.com%2F86%2F10%2F01300000184180121920108394217.jpg &quot;xxx&quot;) æ•ˆæžœå¦‚ä¸‹ï¼š é“¾æŽ¥åŸºæœ¬è¯­æ³•ï¼Œå¦‚ï¼š123[é“¾æŽ¥åç§°](é“¾æŽ¥åœ°å€)å¦‚ï¼š[Baidu](https://www.baidu.com) æ•ˆæžœå¦‚ä¸‹ï¼šBaidu å‚è€ƒæ–‡ç« ï¼šMarkdown ä¸­æ–‡æ–‡æ¡£MarkdownåŸºæœ¬è¯­æ³•]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_Summary]]></title>
    <url>%2F2020%2F09%2F16%2FZJU-DS-Summary%2F</url>
    <content type="text"><![CDATA[è¯¾å ‚ç¬”è®°å…¨éƒ¨å†™å®Œäº†ï¼Œæ€»ç»“ä¸€ä¸‹ã€‚ è¯¾å ‚è¯„ä»·è™½ç„¶è¿™æ˜¯é—¨åœ¨çº¿è¯¾ç¨‹ï¼Œä½†æ˜¯è¯¾å ‚çš„è´¨é‡å…¶å®žå¾ˆé«˜ï¼Œä¸»è¦å½’åŠŸäºŽä¸¤ä½è€å¸ˆæ·±å…¥æµ…å‡ºçš„è®²è§£ï¼Œä»¥åŠåœ¨åˆé€‚çš„æ—¶é—´æ’å…¥çš„è¯¾é—´ä¹ é¢˜ã€‚ç§è®¤ä¸ºå§¥å§¥è·Ÿä½•å¤´å·²ç»å°½é‡è®²çš„ç®€å•ä¸€ç‚¹äº†ï¼Œä½†æ˜¯ç”±äºŽè¿™é—¨è¯¾ç¨‹çš„ç‰¹æ®Šæ€§ï¼ˆæŠ½è±¡çš„ä¸œè¥¿å¤ªå¤šï¼‰ï¼Œå¯èƒ½è¿˜æ˜¯æœ‰äººå¬çš„äº‘é‡Œé›¾é‡Œï¼Œå»ºè®®å¤šå¬å‡ éã€‚ä½•å¤´è®²è¯¾æ¯”è¾ƒç›´æŽ¥ï¼Œå„ç§ç»†èŠ‚æ€§é—®é¢˜éƒ½ä¼šç»™ä½ è®²æ¸…æ¥šï¼Œå§¥å§¥è®²è¯¾å¶å°”ä¼šâ€œè°ƒçš®â€ä¸€ä¸‹ï¼ˆå¿ƒæ€çœŸæ˜¯å¹´è½»å•Š...ï¼‰ï¼Œæ›´æƒ³å¼•å‘ä½ è‡ªå·±çš„æ€è€ƒï¼›ä»–ä»¬çš„å…±åŒç‚¹å°±æ˜¯è¯¾ä¸Šè®²çš„è¯éƒ½ååˆ†çš„ç²¾ç»ƒï¼Œæ²¡ä»€ä¹ˆåºŸè¯ï¼Œæœ‰äº›åœ°æ–¹è¿˜å¾—éƒ½å¬å‡ éæ‰èƒ½æ‡‚ã€‚ å¦å¤–ï¼Œè¯¾é—´ç©¿æ’çš„ä¹ é¢˜å’Œè§†é¢‘åŽçš„è®¨è®ºå¯ä»¥å¼•å‘å­¦ç”Ÿçš„æ€è€ƒï¼Œå¯¹ç†è§£è¯¾ä¸Šçš„ä¸œè¥¿æœ‰ä¸€å®šçš„å¸®åŠ©ï¼Œè¿™ä¹Ÿæ˜¯å€¼å¾—ç§°èµžçš„åœ°æ–¹ï¼›ä¸“é—¨è®¾ç½®çš„â€œå°ç™½ä¸“åœºâ€ä¹Ÿæ˜¯ååˆ†è´´å¿ƒï¼Œå€¼å¾—å¥½è¯„ã€‚ è¯¾ç¨‹ç»ƒä¹ è¯¾ç¨‹ç»ƒä¹ ä¸»è¦æœ‰ä¸‰ç§ï¼šè¯¾é—´ä¹ é¢˜ã€è¯¾åŽä¹ é¢˜å’Œ PTA ä¸Šçš„ç¼–ç¨‹é¢˜ã€‚è¯¾é—´ä¹ é¢˜å¸®åŠ©ç†è§£è¯¾å ‚ä¸Šæ‰€è®²çš„å†…å®¹ï¼›è¯¾åŽä¹ é¢˜å¸®åŠ©å·©å›ºè¯¾å ‚ä¸Šæ‰€è®²çš„å†…å®¹ï¼›PTA ä¸Šçš„ä½œä¸šé¢˜ç®—æ˜¯å®žæ‰“å®žçš„â€œåº”ç”¨é¢˜â€ï¼ŒæŠŠè¯¾ä¸Šå­¦çš„ç†è®ºä¸€æ­¥æ­¥å®žçŽ°ï¼Œæ—¢èƒ½åŠ æ·±å¯¹ç†è®ºçš„ç†è§£ï¼Œåˆèƒ½å¢žå¼ºç¼–ç èƒ½åŠ›ï¼Œååˆ†ä¸é”™ã€‚ æœ‰ç‚¹ç¾Žä¸­ä¸è¶³çš„åœ°æ–¹å°±æ˜¯è¯¾åŽä¹ é¢˜å¤ªå°‘äº†ï¼Œè¿™ç±»ç¬”è¯•é¢˜ç›®å¦‚æžœèƒ½å¢žå¤šï¼Œå¯¹è¦è€ƒè¯•çš„å­¦ç”Ÿè€Œè¨€å¾ˆæœ‰å¸®åŠ©ã€‚ä¸è¿‡ï¼Œè€å¸ˆä»¬ç¼–çš„æ•™æä¸Šä¹Ÿæœ‰ä¸å°‘ä¹ é¢˜ï¼Œè¿™å¯èƒ½æ˜¯è¯¾åŽä¹ é¢˜æ¯”è¾ƒå°‘çš„åŽŸå› ã€‚ å…³äºŽ PTA ä¸Šçš„ç¼–ç¨‹é¢˜ï¼Œå»ºè®®å…¨éƒ¨åšå®Œï¼ˆè™½ç„¶è€å¸ˆè¯´äº†é‚£äº›å¿…åšï¼Œé‚£äº›é€‰åšï¼‰ï¼Œä¸€å®šè¦è‡ªå·±å…ˆåšï¼Œä¸èƒ½ä¸€æ¬¡ AC ä¸è¦ç´§ï¼Œå®žåœ¨ AC ä¸äº†ï¼Œå†çœ‹è€å¸ˆçš„è®²è§£ï¼ˆéš¾ä¸€ç‚¹çš„åŸºæœ¬éƒ½è®²äº†ï¼‰ã€‚æœ‰äº›é¢˜ç›®çš„è§£é¢˜æ€è·¯å…¶å®žæœ‰å¾ˆå¤šï¼Œå…‰æ˜¯ç›´æŽ¥ç™¾åº¦å°±æœ‰å¾ˆå¤šèµ„æ–™å¯æŸ¥ã€‚å¦å¤–ï¼Œé¢˜ç›®æ€»ä½“éš¾åº¦å¤§æ¦‚å°±æ˜¯ PAT ç”²çº§çš„éš¾åº¦äº†ï¼Œä½œä¸šé¢˜é‡Œé¢æœ‰äº›å°±æ˜¯å½“å¹´çš„ç”²çº§çœŸé¢˜ï¼Œæ‰€ä»¥ä¸€å®šè¦å¥½å¥½åšã€‚ è€ƒè¯•è€ƒè¯•çš„å½¢å¼æ¯”è¾ƒç®€å•ï¼Œä¹Ÿå¾ˆæ–¹ä¾¿ï¼Œæ¯å‘¨ä½œä¸šéƒ½æ˜¯ç¼–ç¨‹é¢˜ï¼Œè€ƒè¯•æœ‰åˆ¤æ–­ã€é€‰æ‹©ã€å¡«ç©ºã€ç¼–ç é¢˜ï¼Œæ²¡æœ‰åšè¿‡é’ˆå¯¹æ€§ç»ƒä¹ çš„åŒå­¦å¯èƒ½ä¼šå¾ˆä¸ä¹ æƒ¯ï¼Œæœ€å¥½è€ƒè¯•å‰åšç‚¹é’ˆå¯¹æ€§çš„ç»ƒä¹ ã€‚å¦å¤–ï¼Œå¦‚æžœè€ƒè¯•ç»“æŸåŽï¼Œèƒ½æä¾›é”™é¢˜çš„ç­”æ¡ˆå°±å®Œç¾Žäº†ã€‚ ä¸ªäººä½“ä¼šæ•°æ®ç»“æž„ä¸Žç®—æ³•è¿™é—¨è¯¾æ˜¯çœŸçš„å¾ˆæŠ½è±¡ï¼ŒåŸºæœ¬å…¨éƒ¨éƒ½æ˜¯ç†è®ºåŒ–çš„ä¸œè¥¿ï¼Œå­¦çš„åŸºæœ¬å°±æ˜¯å‡ åå¹´å‰çš„è®¡ç®—æœºç§‘å­¦å®¶è®ºæ–‡ä¸Šå†™çš„ä¸œè¥¿ï¼Œå¾—è€ä½æ€§å­ï¼Œä»”ç»†é’»ç ”ã€‚è¿™é—¨è¯¾å°±å¥½æ¯”ä¿®ç‚¼æ­¦ä¾ ç»æŠ€å‰ä¿®ç‚¼çš„â€œå†…åŠŸå¿ƒæ³•â€ä¸€èˆ¬ï¼Œæ˜¯æ ¹åŸºï¼Œç†è®ºåŸºç¡€æ‰Žå®žäº†ï¼Œå®žè·µèƒ½åŠ›æ‰èƒ½ç¨³æ­¥æé«˜ã€‚ä¸è¿‡ï¼Œä¸¤ä½è€å¸ˆè®²çš„å¾ˆæ£’ï¼Œç€å®žæ–¹ä¾¿äº†ä¸å°‘ã€‚ åœ¨æŠŠå›¾å­¦å®Œçš„æ—¶å€™ï¼Œæ„Ÿè§‰å°±åƒæ˜¯æœ‰äº†â€œå± é¾™å®åˆ€â€å´ä¸çŸ¥é“æ€Žä¹ˆç”¨ä¸€æ ·ã€‚ä¸è¿‡å®žé™…çš„ç”Ÿäº§åå¢ƒä¸­ï¼Œæ ¹æœ¬æ²¡æœºä¼šè®©ä½ åŽ»â€œå± é¾™â€... ä¸€èˆ¬è€Œè¨€ï¼Œè®¡ç®—æœºå­¦ç§‘çš„ç§‘ç›®è¦æƒ³å­¦åˆ°ä¸œè¥¿ï¼Œåˆ‡å¿Œä¸èƒ½ç©ºè°ˆç†è®ºï¼Œä¸€å®šå¾—åŠ¨æ‰‹ï¼ŒåŠ¨æ‰‹åŽ»å†™ï¼ŒåŠ¨è„‘å­åŽ»æƒ³é—®é¢˜ã€‚å°±è¿™é—¨è¯¾è€Œè¨€ï¼ŒPTA ä¸Šçš„ç¼–ç¨‹é¢˜éƒ½æ˜¯ååˆ†ä¸é”™çš„ä¹ é¢˜ï¼Œä¸€å®šå¾—åŠ¨è„‘å­åŽ»å†™ã€‚å°±ç®—ä¸èƒ½è§£å†³ï¼Œåªè¦åŠ¨è„‘å­æ€è€ƒäº†é—®é¢˜ï¼ŒåŸºæœ¬éƒ½ä¼šæœ‰æ”¶èŽ·ã€‚ è‡ªå·±ç®—æ˜¯æŠŠè¿™é—¨è¯¾åå¤å­¦äº†å¥½å‡ éæ‰ç®—æ˜¯èƒ½ç†è§£ä¸€äº›ä¸œè¥¿äº†ï¼Œå¯èƒ½æ˜¯è‡ªå·±è„‘å­å¤ªæ‹™äº†å§... ä¸ç®¡æ€Žä¹ˆè¯´ï¼ŒæŠŠæ‰€æœ‰çš„ç¬”è®°æ•´ç†å®Œä¹Ÿç®—æ˜¯å®Œæˆäº†ä¸€ä»¶äº‹ï¼Œç»§ç»­åŠªåŠ›å§ï¼Œéªšå¹´~ðŸ˜‰]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_12-KMP]]></title>
    <url>%2F2020%2F09%2F15%2FZJU-DS-12-KMP%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨ä¸»è¦è®²è§£å‡ é“é¢˜ç›®ï¼Œç„¶åŽå†ä»‹ç»ä¸€ä¸‹ KMP ç®—æ³•ã€‚ ä¸²åœ¨äº†è§£KMPç®—æ³•ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆäº†è§£ä¸€ä¸‹ä»€ä¹ˆæ˜¯ä¸²ã€‚ä¸²ï¼ˆStringï¼‰å…¶å®žä¹Ÿæ˜¯çº¿æ€§è¡¨çš„ä¸€ç§åº”ç”¨ï¼ŒæŒ‡çš„æ˜¯çº¿æ€§å­˜å‚¨çš„ä¸€ç»„æ•°æ®ï¼ˆå¸¸è§æ˜¯å­—ç¬¦ï¼Œæ­£æ‰€è°“â€œå­—ç¬¦ä¸²â€ï¼‰ï¼Œå½“ç„¶ï¼Œä¸²ä¸ä»…ä»…åŒ…å«å­—ç¬¦ï¼Œå®ƒæ˜¯é€šç”¨çš„æ•°æ®ç»“æž„ã€‚åŒæ—¶ï¼Œä¸Žä¸²ç›¸å…³çš„æ“ä½œé›†æœ‰å¾ˆå¤šï¼Œå¦‚ï¼šæ±‚ä¸²çš„é•¿åº¦ã€æ¯”è¾ƒä¸¤ä¸²æ˜¯å¦ç›¸ç­‰ã€ä¸¤ä¸²ç›¸æŽ¥ã€æ±‚å­ä¸²ã€æ’å…¥å­ä¸²ã€åŒ¹é…å­ä¸²ï¼ˆKMP å°±æ˜¯å¹²è¿™äº‹çš„ï¼‰ã€åˆ é™¤å­ä¸²ç­‰ã€‚ KMPåŒ¹é…å­ä¸²ä»€ä¹ˆæ˜¯â€œåŒ¹é…å­ä¸²â€å‘¢ï¼Ÿçœ‹åå­—ï¼Œå…¶å®žæœ‰ä¸¤ä¸ªç€é‡ç‚¹ï¼Œä¸€ä¸ªæ˜¯åŒ¹é…ï¼Œä¸€ä¸ªæ˜¯å­ä¸²ã€‚ä¸¾ä¸ªä¾‹å­ï¼Œç»™å®šä¸€æ®µæ–‡æœ¬ï¼Œä»Žä¸­æ‰¾å‡ºæŸä¸ªæŒ‡å®šçš„å…³é”®å­—ï¼Œä¾‹å¦‚ç»™å®šæ–‡æœ¬ï¼šThis is not a bug, itâ€™s destiny. ï¼Œéœ€è¦ä»Žä¸­æ‰¾å‡º bug è¿™ä¸ªå…³é”®å­—ï¼ˆå½“ç„¶è¿™å¹¶ä¸æ˜¯ä»¶å¤æ‚çš„äº‹æƒ…ï¼‰ï¼Œè¿™å®žé™…ä¸Šå°±æ˜¯â€œåŒ¹é…å­ä¸²â€ã€‚ é‚£ä¹ˆæˆ‘ä»¬é‡æ–°è§„èŒƒä¸€ä¸‹ï¼Œå°±æ˜¯ï¼šç»™å®šä¸€ä¸ªæ–‡æœ¬ï¼šstring = xxxxxxxï¼Œåœ¨ç»™å®šä¸€ä¸ªæ¨¡å¼ï¼špattern = xxxxï¼Œæ±‚ pattern åœ¨ string ä¸­å‡ºçŽ°çš„ä½ç½®ã€‚ åˆ†æžä¾æ®åŒ¹é…å­ä¸²çš„æ€è·¯ï¼Œå¦‚æžœè¦æ‰¾patternåœ¨stringä¸­å‡ºçŽ°çš„ä½ç½®ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼ŒæŽ¥ç€å¯¹stringè¿›è¡ŒéåŽ†ï¼ŒåŒæ—¶ä¸Žpatterné€ä¸ªå­—ç¬¦è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœå‡ºçŽ°ä¸ç›¸ç­‰çš„ï¼Œåˆ™stringçš„æŒ‡é’ˆå›žé€€åˆ°åˆè¯•æ¯”è¾ƒä½ç½®çš„åŽä¸€ä¸ªä½ç½®ï¼ˆè‹¥ä»Ž i å¼€å§‹æ¯”è¾ƒï¼Œåˆ™å›žé€€åˆ° i+1 å¼€å§‹æ¯”è¾ƒï¼‰ï¼Œpatternçš„æŒ‡é’ˆåˆ™å›žé€€åˆ°ç¬¬ä¸€ä½ï¼Œé‡å¤æ‰§è¡Œå³å¯ï¼Œè¿™å®žé™…ä¸Šæ˜¯ä¸€ç§æš´åŠ›è§£æ³•ã€‚ä½¿ç”¨æš´åŠ›è§£æ³•æ—¶ï¼Œä¸²ä¸­è‚¯å®šä¼šæœ‰ç›¸åŒçš„åºåˆ—å­˜åœ¨ï¼Œæ‰€ä»¥æŒ‡é’ˆå›žæº¯åŽå†æ¬¡éåŽ†æ¯”è¾ƒæ—¶ï¼Œå°±ä¼šè¿›è¡Œé‡å¤çš„æ¯”è¾ƒæ“ä½œäº†ï¼Œè¿™æ ·å°±åšäº†å¾ˆå¤šæ— ç”¨çš„æ“ä½œï¼Œè€Œ KMP ç®—æ³•å°±æ˜¯ç”¨æ¥è§£å†³è¿™ä¸ªé—®é¢˜çš„ã€‚ åŒ¹é…å‡½æ•°KMP ç®—æ³•åœ¨ç›´æŽ¥è¿›è¡ŒåŒ¹é…å‰ä¼šå¯¹æ¨¡å¼ä¸²ï¼ˆpatternï¼‰è¿›è¡Œåˆ†æžï¼Œå€ŸåŠ©ä¸€ä¸ªè¾…åŠ©æ•°ç»„match[]ï¼Œè¿™ä¸ªæ•°ç»„å†…ä¿å­˜ç€æ¨¡å¼ä¸²æŒ‰ç…§ä¸‹é¢çš„ $ match $ å‡½æ•°è®¡ç®—çš„â€œå€¼â€ï¼Œæ ¹æ®è¿™äº›â€œå€¼â€ï¼Œå†æž„é€ åˆé€‚çš„åˆ¤æ–­è§„åˆ™æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼›match[]æ•°ç»„çš„ä¸‹æ ‡å°±æ˜¯æ¨¡å¼ä¸²æ¯ä¸€ä¸ªå­—ç¬¦çš„ä¸‹æ ‡ã€‚å…ˆæ¥çœ‹ä¸€ä¸‹è¿™ä¸ª $ match $ å‡½æ•°: $$match(j) = \begin{cases}&amp;\text{æ»¡è¶³}p_0 \cdots p_i = p_{j-i} \cdots p_j \text{çš„æœ€å¤§}i(\lt j) \\&amp;-1\ \ \ \text{å¦‚æžœè¿™æ ·çš„} i \text{ä¸å­˜åœ¨}\end{cases}$$ å‡è®¾patternä¸ºabcabcacabè¿™ä¸ªåºåˆ—ï¼Œä¸‹é¢æ¥è®¡ç®—ä¸€ä¸‹å…¶ç”± $ match $ å‡½æ•°å¾—æ¥çš„æ•°ç»„ã€‚1â†’2â†’3â†’4â†’é‡å¤å…ˆä»Žaå¼€å§‹ï¼Œaä¸ºé¦–å­—ç¬¦ï¼Œæ ¹æ® $ match $ å‡½æ•°çš„è§„åˆ™ï¼Œmatch(0) = -1ç»§è€Œåˆ°bï¼Œbéœ€è¦å’Œå‰é¢çš„aè¿›è¡Œæ¯”è¾ƒï¼Œå‘çŽ°ä¸åŒ¹é…ï¼Œmatch(1) = -1å†çœ‹cï¼Œæ­¤æ—¶å¯¹äºŽmatchå‡½æ•°è€Œè¨€ï¼Œiå¯ä»¥å–ä¸¤ä¸ªå€¼ï¼Œåˆ†åˆ«æ˜¯0å’Œ1ï¼ˆæ­¤æ—¶j=2ï¼‰ï¼Œå–0æ—¶ï¼Œcç›´æŽ¥å’Œaæ¯”è¾ƒï¼Œä¸åŒ¹é…ï¼Œå–1æ—¶ï¼Œé‚£å°±æ˜¯abå’Œbcè¿›è¡Œæ¯”è¾ƒï¼Œè¿˜æ˜¯ä¸åŒ¹é…ï¼Œæ‰€ä»¥match(2) = -1å†çœ‹ä¸‹ä¸€ä¸ªaï¼Œæ­¤æ—¶iå¯ä»¥å–ä¸‰ä¸ªå€¼ï¼ˆ0ã€1ã€2ï¼Œæ³¨æ„matchå‡½æ•°çš„æ¡ä»¶æ˜¯ä¸å¤§äºŽjçš„æœ€å¤§iï¼‰ï¼Œå–0ï¼Œaå’Œaæ¯”è¾ƒï¼ŒåŒ¹é…æˆåŠŸï¼Œmatch(3) = 0ï¼Œå–1ï¼Œabå’Œcaä¸åŒ¹é…ï¼Œå–2ï¼Œabcå’Œbcaä¹Ÿä¸åŒ¹é…ï¼ˆè‹¥æ­¤æ—¶åŒ¹é…ï¼Œmatch(3)çš„å€¼éœ€è¦æ›´æ–°ï¼‰ï¼Œæ‰€ä»¥match(3) = 0æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œé‡å¤ç›´è‡³ç»“æŸã€‚é‡å¤è®¡ç®—åŽï¼Œå¯ä»¥å¾—åˆ°ä¸‹è¡¨ï¼š pattern a b c a b c a c a b j 0 1 2 3 4 5 6 7 8 9 match -1 -1 -1 0 1 2 3 -1 0 1 matchå‡½æ•°æœ‰å¤šç§å’Œä¸åŒçš„ç§°å‘¼ï¼Œæœ‰äº›ä¹¦ä¹Ÿå«nextã€‚å¦å¤–ï¼Œéœ€è¦æ˜Žç¡®çš„æ˜¯ï¼Œè¿™ä¸ªç‰¹å®šå‡½æ•°çš„é’ˆå¯¹å¯¹è±¡æ˜¯patternï¼Œä¹Ÿå³æ˜¯ç»™å®šçš„æ¨¡å¼ä¸²ï¼Œè€Œä¸æ˜¯åŽŸä¸²ã€‚å¦å¤–ï¼Œpatternæ¯”è¾ƒçŸ­ï¼Œstringæ¯”è¾ƒé•¿ï¼ŒKMPç®—æ³•åªç”¨åˆ†æžä¸€ä¸ªçŸ­çš„å­ä¸²è€Œä¸ç”¨åˆ†æžä¸€ä¸ªé•¿ä¸²ï¼Œè¿™å…¶å®žå·²ç»æå‡äº†æ•ˆçŽ‡ã€‚ ç®—æ³•å®žçŽ°ä½¿ç”¨ $ match $ å‡½æ•°èŽ·å¾—match[]æ•°ç»„åŽï¼Œå¦‚ä½•åŽ»ä½¿ç”¨match[]æ•°ç»„åˆæˆä¸ºæ–°é—®é¢˜ã€‚é¦–å…ˆæˆ‘ä»¬å·²ç»çŸ¥é“äº†ï¼Œæ ¹æ®match[]æ•°ç»„å¯ä»¥é¿å…åŽ»æ¯”è¾ƒé‡å¤çš„åºåˆ—ï¼Œå½“ä¸åŒ¹é…æ—¶ï¼ŒæŒ‡å‘patternçš„æŒ‡é’ˆpä¼šåŽ»æ‰¾p-1è¿™ä¸ªæŒ‡é’ˆæ‰€æŒ‡ä½ç½®çš„match[]å€¼ï¼Œè€Œè¿™ä¸ªmatch[]å€¼åŠ 1å°±æ˜¯æŒ‡é’ˆpé‡æ–°å¼€å§‹è¿›è¡ŒåŒ¹é…çš„ä½ç½®ï¼Œå³å¦‚ä¸‹å›¾æ‰€ç¤ºï¼šå°±æ˜¯è¿™æ ·åŽ»ä½¿ç”¨matchæ•°ç»„çš„ï¼Œæ˜Žç¡®è¿™ä¸ªé—®é¢˜åŽï¼ŒåŸºæœ¬å¯ä»¥å†™å‡º KMP ç®—æ³•çš„ä»£ç äº†ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š1234567891011121314151617Position KMP(char *string, char *pattern) &#123; int n = strlen(string); /* O(n) */ int m = strlen(pattern); /* O(m) */ int s, p, *match; if(n &lt; m) return NotFound; match = (int*)malloc(m*sizeof(int)); BuildMatch(pattern, match); /* T(B) */ s = p = 0; while(s&lt;n &amp;&amp; p&lt;m) &#123; /* O(n) */ if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p-1] + 1; else s++; &#125; return (p==m)?(s-m):NotFound;&#125; ä»Žä¸Šé¢çš„ä»£ç å¯ä»¥åˆ†æžå‡ºå…¶æ—¶é—´å¤æ‚åº¦åŸºæœ¬ä¸º$T = O(n+m) + T(B)$ï¼ŒBuildMatchå‡½æ•°çš„æ—¶é—´å¤æ‚åº¦å–å†³äºŽå…¶è‡ªèº«çš„å®žçŽ°æ–¹å¼ï¼Œåˆ«å¿˜è®°äº†ï¼ŒKMPæ˜¯ä»¥å®ƒä¸ºå‰æçš„ã€‚ æœ‰äº†å‰é¢å¯¹ $ match $ å‡½æ•°çš„åˆ†æžï¼ŒBuildMatchå‡½æ•°çš„æž„é€ å°±æ¯”è¾ƒç®€å•äº†ï¼Œä½†è‹¥åªæ˜¯ç®€å•ç”¨çº¿æ€§çš„æ–¹æ³•åŽ»æž„é€ matchæ•°ç»„çš„è¯ï¼Œä¼šä½¿å¾—æ—¶é—´å¤æ‚åº¦ä¸º$O(m^3)$ï¼Œè¿™å°±å¾ˆä¸å‹å¥½äº†ï¼Œé‚£æ€Žä¹ˆåŠžå‘¢ï¼Ÿ ç­”æ¡ˆæ˜¯åˆ©ç”¨match[]æ•°ç»„å†…çš„å€¼ï¼Œå¦‚æžœæ˜¯è®¡ç®—ç¬¬iä¸ªä½ç½®çš„matchå€¼ï¼Œé‚£ä¹ˆå¿…å®šå¾—åŽ»æ‰¾i-1çš„matchå€¼åŠ 1æ‰€æŒ‡ä½ç½®çš„å­—ç¬¦æ˜¯å¦ä¸Žiæ‰€æŒ‡ä½ç½®çš„å­—ç¬¦ç›¸åŒï¼Œå¦‚æžœç›¸åŒï¼Œçš†å¤§æ¬¢å–œï¼Œmatch[i] == match[i-1] + 1äº†ï¼Œå¦‚æžœä¸ç›¸ç­‰å‘¢ï¼Ÿ å°±å¾—åŽ»æ‰¾i-1çš„matchå€¼çš„matchå€¼åŠ 1æ‰€æŒ‡ä½ç½®çš„å­—ç¬¦æ˜¯å¦ä¸Žiæ‰€æŒ‡ä½ç½®çš„å­—ç¬¦ç›¸åŒäº†ï¼ˆå¥½ç»•...ðŸ˜“ï¼‰ï¼Œä¹Ÿå³match[match[i-1]]ï¼Œè‹¥ç›¸åŒï¼Œmatch[i] == match[match[i-1]] + 1ï¼Œå¦‚æžœè¿˜ä¸ç›¸ç­‰ï¼Œç»§ç»­æ‰¾å§...ï¼ˆè¿˜å¥½æ˜¯ç”µè„‘å¹²æ´»ðŸ˜“ï¼‰ã€‚å¯å‚è€ƒä¸‹å›¾ï¼šåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š1234567891011121314void BuildMatch(char *pattern, int *match) &#123; int i, j; int m = strlen(pattern); /* O(m) */ match[0] = -1; for(j=1; j&lt;m; j++) &#123; /* O(m) */ i = match[i-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) &#123; match[j] = i+1; &#125; else match[j] = -1; &#125;&#125; ç®€å•åˆ†æžä¸€ä¸‹ä¸Šè¿°ä»£ç çš„æ—¶é—´å¤æ‚åº¦ï¼Œå¯å¾— $T_m(N) = O(m)$ï¼Œç»¼åˆèµ·æ¥ KMP ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ $T(N) = O(n+m)$ï¼Œä»Žæš´åŠ›è§£æ³•çš„ $O(nÂ·m)$ ä¼˜åŒ–æˆ $O(n+m)$ï¼Œç¡®å®žåŽ‰å®³ï¼ Homeworkä¸²çš„æ¨¡å¼åŒ¹é…è¿™é“é¢˜ç›®æ˜¯ç”¨æ¥æµ‹è¯•å„å¼å„æ ·çš„ä¸²çš„æ¨¡å¼åŒ¹é…ç®—æ³•çš„ï¼ŒæŒ‰ç…§å§¥å§¥ç»™å‡ºçš„ä»£ç ï¼Œå¯ä»¥å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define NotFound -1typedef int Position;void Build_Match(char *pattern, int *match) &#123; Position i, j; int m = strlen(pattern); match[0] = -1; for(j=1; j&lt;m; j++) &#123; i = match[j-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) match[j] = i+1; else match[j] = -1; &#125;&#125;Position KMP(char *string, char *pattern) &#123; int n = strlen(string); int m = strlen(pattern); Position s, p, *match; if(n &lt; m) return NotFound; match = (Position*)malloc(m*sizeof(Position)); Build_Match(pattern, match); s = p =0; while(s&lt;n &amp;&amp; p&lt;m) &#123; if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p - 1]+1; else s++; &#125; return (p == m) ? (s - m) : NotFound;&#125;int main(int argc, char const *argv[]) &#123; char string[] = "This is a simple example."; char pattern[] = "simple"; Position p = KMP(string, pattern); if(p == NotFound) printf("Not Found.\n"); else printf("%s\n", string+p); return 0;&#125;/*samples:in:abcabcabcabcacabxy3abcabcacabcabcabcdabcabcabcabcacabxyzout:abcabcacabxyNot FoundNot Found */]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_11-æ•£åˆ—æŸ¥æ‰¾]]></title>
    <url>%2F2020%2F09%2F06%2FZJU-DS-11-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨å°†ä»‹ç»æ•£åˆ—æŸ¥æ‰¾ å¼•å­å…ˆæ¥å›žé¡¾ä¸€ä¸‹å…¶ä»–çš„æŸ¥æ‰¾æ–¹æ³•ï¼š åç§° æ—¶é—´å¤æ‚åº¦ é¡ºåºæŸ¥æ‰¾ $O(N)$ äºŒåˆ†æŸ¥æ‰¾ï¼ˆé™æ€æŸ¥æ‰¾ï¼‰ $O(log_2N)$ äºŒå‰æœç´¢æ ‘ $O(h), h$ä¸ºæ ‘é«˜ å¹³è¡¡äºŒå‰æ ‘ $O(log_2N)$ ä¸Šè¡¨ä¸­çš„æŸ¥æ‰¾æ–¹æ³•éƒ½æ˜¯å»ºç«‹åœ¨å®¹æ˜“æ¯”è¾ƒå…³é”®å­—çš„æƒ…å†µä¸‹ï¼Œå¦‚æžœå…³é”®å­—ä¸å®¹æ˜“æ¯”è¾ƒå‘¢ï¼Ÿ æ•£åˆ—æŸ¥æ‰¾æ•£åˆ—æŸ¥æ‰¾æ‰€è¦è§£å†³çš„é—®é¢˜å°±æ˜¯ï¼š è®¡ç®—ä½ç½®ï¼šæž„é€ æ•£åˆ—å‡½æ•°ç¡®å®šå…³é”®è¯å­˜å‚¨ä½ç½®è§£å†³å†²çªï¼šåº”ç”¨æŸç§ç­–ç•¥è§£å†³å¤šä¸ªå…³é”®è¯ä½ç½®ç›¸åŒçš„é—®é¢˜ æŒ‰ç…§æ•£åˆ—æŸ¥æ‰¾çš„åšæ³•ï¼Œæ¯æ¬¡æŸ¥æ‰¾åªè¿›è¡Œè®¡ç®—å°±å¤Ÿäº†ï¼Œæ—¶é—´å¤æ‚åº¦ä¸º$O(1)$ï¼Œä¹Ÿå°±æ˜¯è¯´æŸ¥æ‰¾æ—¶é—´ä¸Žé—®é¢˜è§„æ¨¡æ— å…³ï¼ æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šç¬¦å·é›†ï¼ˆSymbol Tableï¼‰æ•°æ®å¯¹è±¡é›†ï¼šç¬¦å·è¡¨æ˜¯â€œåå­—ï¼ˆNameï¼‰- å±žæ€§ï¼ˆAttributeï¼‰â€å¯¹çš„é›†åˆæ“ä½œé›†ï¼šTable âˆˆ Symbol Table, Name âˆˆ NameType, Attr âˆˆ AttributeType SymbolTable InitializeTable(int TableSize)ï¼Œåˆ›å»ºä¸€ä¸ªé•¿åº¦ä¸ºTableSizeçš„ç¬¦å·è¡¨ Boolean IsIn(SymbolTable Table, NameType Name)ï¼ŒæŸ¥æ‰¾ç‰¹å®šçš„åå­—Nameæ˜¯å¦åœ¨ç¬¦å·è¡¨Tableä¸­ AttributeType Find(SymbolTable Table, NameType Name)ï¼ŒèŽ·å–Tableä¸­æŒ‡å®šåå­—Nameå¯¹åº”çš„å±žæ€§ SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)ï¼Œå°†Tableä¸­æŒ‡å®šåå­—Nameçš„å±žæ€§ä¿®æ”¹ä¸ºAttr SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)ï¼Œå‘Tableä¸­æ’å…¥ä¸€ä¸ªæ–°åå­—NameåŠå…¶å±žæ€§Attr SymbolTable Delete(SymbolTable Table, NameType Name)ï¼Œä»ŽTableä¸­åˆ é™¤ä¸€ä¸ªåå­—NameåŠå…¶å±žæ€§ åŸºæœ¬æ€æƒ³æ•£åˆ—ï¼ˆHashingï¼‰çš„åŸºæœ¬æ€æƒ³å¦‚ä¸‹ï¼š ä»¥å…³é”®å­—$key$ä¸ºè‡ªå˜é‡ï¼Œé€šè¿‡æ•£åˆ—å‡½æ•°$h$ï¼Œè®¡ç®—å‡ºå¯¹åº”çš„å‡½æ•°å€¼$h(k)$ï¼Œä½œä¸ºæ•°æ®å¯¹è±¡çš„å­˜å‚¨åœ°å€ã€‚ å¯èƒ½ä¸åŒå…³é”®å­—ä¼šæ˜ å°„åˆ°åŒä¸€æ•£åˆ—åœ°å€ä¸Šï¼Œè¿™ç§æƒ…å†µç§°ä¸ºå†²çªï¼ˆCollisionï¼‰ï¼Œè¿™éœ€è¦æŸç§å†²çªè§£å†³ç­–ç•¥ã€‚ è¿™é‡Œå¼•å…¥è£…å¡«å› å­(Loading Factor)çš„æ¦‚å¿µï¼Œå³ï¼šæ•£åˆ—è¡¨å†…å…ƒç´ ä¸ªæ•°ï¼ˆ$n$ï¼‰ä¸Žæ•£åˆ—è¡¨ç©ºé—´ï¼ˆ$m$ï¼‰çš„æ¯”å€¼ï¼Œå³$\alpha = n / m$ã€‚ æ•£åˆ—å‡½æ•°æŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œåœ¨æž„é€ æ•£åˆ—å‡½æ•°æ—¶éœ€è¦æ³¨æ„ä¸¤ç‚¹ï¼š è®¡ç®—ç®€å•ï¼Œä»¥ä¾¿æé«˜åœ°å€è½¬æ¢é€Ÿåº¦ å…³é”®è¯å¯¹åº”çš„åœ°å€ç©ºé—´åˆ†å¸ƒå‡åŒ€ï¼Œä»¥å°½é‡å‡å°‘å†²çª æ ¹æ®æ•°æ®å…ƒç´ çš„ä¸åŒï¼Œå¯ä»¥åˆ†ä¸ºä»¥æ•°å­—å…³é”®è¯å’Œå­—ç¬¦å…³é”®è¯æž„é€ çš„æ•£åˆ—å‡½æ•°ã€‚ æ•°å­—å…³é”®è¯ä»¥æ•°å­—ä¸ºå…³é”®è¯çš„æ•£åˆ—å‡½æ•°æž„é€ æ–¹æ³•åˆæœ‰å¤šç§ï¼Œä¾æ¬¡å¦‚ä¸‹ï¼š åç§° æ•£åˆ—å‡½æ•° ç›´æŽ¥å®šå€æ³• $h(key) = a \times key + b, a, b$ä¸ºå¸¸æ•° é™¤ç•™ä½™æ•°æ³• $h(key) = key mod p, p$å–ç´ æ•° æ•°å­—åˆ†æžæ³• $h(key) = atoi(key + 7)$ æŠ˜å æ³• å…³é”®è¯åˆ†å‰²æˆä½æ•°ç›¸åŒçš„å‡ ä¸ªéƒ¨åˆ†å åŠ  å¹³æ–¹å–ä¸­æ³• å…³é”®å­—å¹³æ–¹åŽå–å…¶ä¸­å‡ ä½ å­—ç¬¦å…³é”®è¯ä»¥å­—ç¬¦ä¸ºå…³é”®è¯çš„æ•£åˆ—å‡½æ•°æž„é€ ä¹Ÿæœ‰å¤šç§ï¼Œä¾æ¬¡å¦‚ä¸‹ï¼šASCIIç åŠ å’Œæ³•å‰3ä¸ªå­—ç¬¦ç§»ä½æ³•ç§»ä½æ³•æ•£åˆ—å‡½æ•°ï¼š$h(key) = (\sum key[i])\ mod\ TableSize$ï¼Œæ­¤æ³•äº§ç”Ÿçš„å†²çªè¾ƒä¸ºä¸¥é‡æ•£åˆ—å‡½æ•°ï¼š$h(key) = (key[0] \times 27^2 + key[1] \times 27 + key[2])\ mod\ TableSize$ï¼Œè¿™é‡Œçœ‹ä½œ 27 è¿›åˆ¶æ•°ï¼Œä¾ç„¶å­˜åœ¨å†²çªï¼Œæ•£åˆ—å‡½æ•°ï¼š$h(key) = (\sum_{i=0}^{i-1} key[n-i-1] \times 32^i)\ mod\ TableSize$ï¼Œçœ‹ä½œ 32 è¿›åˆ¶æ•°æ¶‰åŠå…³é”®è¯ï¼Œæ‰€æœ‰nä¸ªå­—ç¬¦ï¼Œå¹¶ä¸”åˆ†å¸ƒæ¯”è¾ƒå‡åŒ€ 1234567Index Hash(const char *Key, int TableSize) &#123; unsigned int h = 0; while(*Key != â€˜\0â€™) &#123; h = (h &lt;&lt; 5) + *Key++; // h &lt;&lt; 5 &lt;==&gt; h*32 &#125; return h%TableSize;&#125; å†²çªå¤„ç†æ–¹æ³•å¯¹äºŽæ•£åˆ—æŸ¥æ‰¾è€Œè¨€ï¼Œäº§ç”Ÿå†²çªå¿…å®šä¼šå½±å“æ•ˆçŽ‡ï¼Œé‚£ä¹ˆå¦‚ä½•å¤„ç†å†²çªå‘¢ï¼Ÿ å¼€æ”¾å®šå€æ³•å¼€æ”¾å®šå€æ³•çš„æ€è·¯æ¯”è¾ƒç®€å•ï¼Œè¯´ç™½äº†ï¼Œå°±æ˜¯è¿™ä¸ªä¸è¡Œæ¢å¦å¤–ä¸€ä¸ªï¼Œä¸€æ—¦äº§ç”Ÿäº†å†²çªï¼ˆè¯¥åœ°å€å·²æœ‰å…¶å®ƒå…ƒç´ ï¼‰ï¼Œå°±æŒ‰ç…§æŸç§è§„åˆ™å¯»æ‰¾å¦ä¸€ä¸ªç©ºçš„åœ°å€ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå¯»æ‰¾ä¸‹ä¸€ç©ºåœ°å€çš„è¿‡ç¨‹ï¼Œç§°ä¸ºæŽ¢æµ‹ï¼Œè€Œå®ƒä¹Ÿæœ‰å¤šç§ä¸åŒçš„æŽ¢æµ‹æ–¹æ³•ã€‚ çº¿æ€§æŽ¢æµ‹é¡¾åæ€ä¹‰ï¼Œçº¿æ€§æŽ¢æµ‹æ³•å°±æ˜¯çº¿æ€§çš„æŽ¢æµ‹æ³•ï¼ˆè¯´äº†æ²¡è¯´ç³»åˆ—ï¼ŸðŸ˜ï¼‰ï¼Œä¹Ÿå³ä»¥å¢žé‡åºåˆ—${1, 2, \ldots}ï¼ˆTableSize - 1ï¼‰$å¾ªçŽ¯è¯•æŽ¢ä¸‹ä¸€ä¸ªåœ°å€ï¼Œä¹Ÿå°±æ˜¯æ£€æµ‹åˆ°å†²çªäº†ï¼Œä¸‹æ ‡åŠ ä¸€è¯•è¯•ä¸‹ä¸€ä¸ªåœ°å€ï¼Œæ³¨æ„å¾ªçŽ¯åˆ°æœ«å°¾åŽè‹¥è¿˜æ²¡æœ‰ç©ºä½ç½®ï¼Œåˆ™ç»§ç»­ä»Žå¤´éƒ¨å¼€å§‹å¾ªçŽ¯ï¼Œæ­¤æ³•å®¹æ˜“äº§ç”Ÿâ€œèšé›†â€çŽ°è±¡ã€‚ å¹³æ–¹æŽ¢æµ‹å¹³æ–¹æŽ¢æµ‹ä¹Ÿå«äºŒæ¬¡æŽ¢æµ‹ï¼Œä»¥å¢žé‡åºåˆ—${1^2, -1^2, 2^2, -2^2, \ldots, q*2, -q^2}, q \le \lfloor TableSize \rfloor$ï¼Œå¾ªçŽ¯è¯•æŽ¢ä¸‹ä¸€ä¸ªå­˜å‚¨åœ°å€ï¼Œæ­¤æ³•ä¸Žçº¿æ€§æŽ¢æµ‹å”¯ä¸€çš„åŒºåˆ«åªæ˜¯å¢žé‡åºåˆ—ä¸åŒè€Œå·²ã€‚ä½†å¹³æ–¹æŽ¢æµ‹å­˜åœ¨ä¸€ä¸ªå¾ˆä¸¥é‡çš„é—®é¢˜ï¼Œå°±æ˜¯â€œæŠ–åŠ¨â€çŽ°è±¡ï¼Œæ˜Žæ˜Žæœ‰ç©ºä½ç½®ï¼Œä½†æ˜¯å°±æ˜¯æ— æ³•æŽ¢æµ‹åˆ°æ•£åˆ—è¡¨çš„ç©ºä½ç½®ï¼Œä¸è¿‡å¥½åœ¨å¯ä»¥å€ŸåŠ©ä¸‹é¢è¿™ä¸ªå®šç†ï¼ˆæ„Ÿè°¢æ•°å­¦å®¶ðŸ™‡â€ï¼‰ã€‚ å®šç†ï¼šå¦‚æžœæ•£åˆ—è¡¨é•¿åº¦TableSizeæ˜¯æŸä¸ª$4k+3$ï¼ˆ$k$æ˜¯æ­£æ•´æ•°ï¼‰å½¢å¼çš„ç´ æ•°æ—¶ï¼Œå¹³æ–¹æŽ¢æµ‹å°±å¯ä»¥æŽ¢æŸ¥åˆ°æ•´ä¸ªæ•£åˆ—è¡¨ç©ºé—´ã€‚ åŒæ•£åˆ—é¡¾åæ€ä¹‰ï¼ŒåŒæ•£åˆ—ï¼Œå°±æ˜¯äº§ç”Ÿå†²çªäº†ï¼Œå†è¿›è¡Œä¸€æ¬¡æ•£åˆ—ï¼Œä¸¤æ¬¡æ•£åˆ—çš„æ•£åˆ—å‡½æ•°ä¸åŒï¼Œè€Œæ˜¯ç¬¬ä¸€æ¬¡æ•£åˆ—çš„ç»“æžœå°†ä½œä¸ºç¬¬äºŒæ¬¡æ•£åˆ—çš„keyï¼Œä¹Ÿå³$d_i$ä¸º$i \times h_2(key)$ï¼Œå…¶æŽ¢æµ‹åºåˆ—ä¸º$h_2(key),\ 2h_2(key),\ 3h_2(key), \ldots$ï¼Œå¾ˆæ˜Žæ˜¾ï¼Œå¯¹ä»»æ„çš„keyï¼Œ$h_2(key) \neq 0$ï¼Œä¸ºä¿è¯æ‰€æœ‰çš„æ•£åˆ—å­˜å‚¨å•å…ƒéƒ½å¯ä»¥è¢«æŽ¢æµ‹åˆ°ï¼Œ$h_2$é€‰ä¸º$h_2(key) = p - (key\ mod\ p)$ï¼Œ$p,\ TableSize$éƒ½æ˜¯ç´ æ•°ã€‚ å†æ•£åˆ—å½“æ•£åˆ—è¡¨å…ƒç´ å¤ªå¤šï¼ˆå³è£…å¡«å› å­$\alpha$å¤ªå¤§ï¼‰æ—¶ï¼ŒæŸ¥æ‰¾æ•ˆçŽ‡ä¼šä¸‹é™ï¼Œå®žé™…æœ€å¤§è£…å¡«å› å­ä¸€èˆ¬å–$0.5 \le \alpha \le 0.85 $ï¼Œå¯¹åº”çš„è§£å†³åŠžæ³•å°±æ˜¯åŠ å€æ‰©å¤§æ•£åˆ—è¡¨ï¼Œè¿™ä¸ªè¿‡ç¨‹å°±å«åšâ€œå†æ•£åˆ—ï¼ˆRehashingï¼‰â€ï¼Œæ³¨æ„ï¼Œå†æ•£åˆ—æ—¶ï¼ŒåŽŸå…ˆçš„æ•£åˆ—åºåˆ—ä¸æ˜¯ç®€å•çš„å¤åˆ¶ï¼Œè€Œæ˜¯è¦é‡æ–°è®¡ç®—ã€‚ åˆ†ç¦»é“¾æŽ¥æ³•åˆ†ç¦»é“¾æŽ¥æ³•æœ€ç»ˆäº§ç”Ÿçš„ç»“æž„æœ‰ç‚¹ç±»ä¼¼å›¾çš„é‚»æŽ¥è¡¨ï¼Œå…¶åŸºæœ¬æ€æƒ³å°±æ˜¯å°†ç›¸åº”ä½ç½®ä¸Šå†²çªçš„æ‰€æœ‰å…³é”®è¯å­˜å‚¨åœ¨åŒä¸€ä¸ªå•é“¾è¡¨ä¸­ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ç§ç»“æž„éœ€è¦ä¸€ä¸ªæ•°ç»„ï¼Œå¹¶ä¸”æ•°ç»„å†…æ¯ä¸ªå…ƒç´ é™¤äº†è¡¨ç¤ºå…³é”®å­—è¿˜å¾—æœ‰ä¸€ä¸ªæŒ‡é’ˆåŸŸï¼Œç”¨æ¥å°†é“¾è¡¨ä¸²èµ·æ¥ã€‚ æ€§èƒ½åˆ†æžå¯¹äºŽæŸ¥æ‰¾è€Œè¨€ï¼Œè¡¡é‡å…¶æ•ˆçŽ‡çš„æŒ‡æ ‡ï¼Œä¾ç„¶æ˜¯å¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼ˆASLï¼Œåˆ†æŸ¥æ‰¾æˆåŠŸå’Œä¸æˆåŠŸä¸¤ç§ï¼‰ï¼Œå¹³å‡æŸ¥æ‰¾é•¿åº¦çš„è®¡ç®—æ–¹æ³•è¦è§†å…·ä½“çš„æ•£åˆ—æ–¹æ³•è€Œå®šã€‚å¦å¤–ï¼Œå½±å“äº§ç”Ÿå†²çªå¤šå°‘æœ‰ä»¥ä¸‹ä¸‰ä¸ªå› ç´ ï¼š æ•£åˆ—å‡½æ•°æ˜¯å¦å†›è¿ å¤„ç†å†²çªçš„æ–¹æ³• æ•£åˆ—è¡¨çš„è£…å¡«å› å­$\alpha$ ä¸‹é¢ç›´æŽ¥ç»™å‡ºå…¶æœŸæœ›æŽ¢æµ‹æ¬¡æ•° pï¼Œä¸åšæ·±å…¥çš„æ•°å­¦æŽ¢è®¨ã€‚ çº¿æ€§æŽ¢æµ‹æ³•ï¼š$p =\begin{cases} \frac{1} {2} [1+\frac{1} {(1-\alpha)^2}],&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\\frac{1}{2}[1+\frac{1}{(1-\alpha)}],&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$å¹³æ–¹æŽ¢æµ‹æ³•ï¼š$p =\begin{cases} \frac{1} {(1-\alpha)},&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\\frac{-1} {\alpha} ln(1-\alpha),&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$åˆ†ç¦»é“¾æŽ¥æ³•ï¼š$p =\begin{cases} \alpha + e^{-\alpha},&amp; \text {å¯¹æ’å…¥å’Œä¸æˆåŠŸæŸ¥æ‰¾è€Œè¨€} \\1+ \frac{\alpha} {2},&amp; \text {å¯¹æˆåŠŸæŸ¥æ‰¾è€Œè¨€}\end{cases}$ æ ¹æ®ä¸Šé¢çš„å…¬å¼æˆ‘ä»¬å¯ä»¥å¾—å‡ºä¸‹é¢å‡ ç‚¹ç»“è®ºï¼š å½“è£…å¡«å› å­$\alpha &lt; 0.5$æ—¶ï¼Œå„ç§æŽ¢æµ‹æ³•çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°éƒ½ä¸å¤§éšç€$\alpha$çš„å¢žå¤§ï¼Œçº¿æ€§æŽ¢æµ‹æ³•çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°å¢žåŠ è¾ƒå¿«ï¼Œä¸æˆåŠŸæŸ¥æ‰¾å’Œæ’å…¥æ“ä½œçš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°æ¯”æˆåŠŸæŸ¥æ‰¾çš„æœŸæœ›æŽ¢æµ‹æ¬¡æ•°è¦å¤§åˆç†çš„æœ€å¤§è£…å¡«å› å­$\alpha$åº”è¯¥ä¸è¶…è¿‡0.85 æ€»ç»“æ•£åˆ—æŸ¥æ‰¾çš„ä¼˜ç‚¹å¾ˆæ˜Žæ˜¾ï¼Œé€‰æ‹©åˆé€‚çš„æ•£åˆ—å‡½æ•°ï¼Œæ•£åˆ—æŸ¥æ‰¾æ•ˆçŽ‡çš„æœŸæœ›æ˜¯å¸¸æ•°$O(1)$ï¼Œå®ƒå‡ ä¹Žä¸Žå…³é”®å­—çš„ç©ºé—´çš„å¤§å°$n$æ— å…³ï¼Œä¹Ÿé€‚åˆäºŽå…³é”®å­—ç›´æŽ¥æ¯”è¾ƒè®¡ç®—é‡è¿‡å¤§çš„é—®é¢˜ï¼›ä½†å®ƒæ˜¯ä»¥è¾ƒå°çš„$\alpha$ä¸ºå‰æï¼Œæ˜¯ä¸€ä¸ªä»¥ç©ºé—´æ¢æ—¶é—´çš„æŸ¥æ‰¾æ–¹æ³•ï¼›å¦å¤–ï¼Œå®ƒå¯¹å…³é”®å­—çš„å­˜å‚¨æ˜¯éšæœºçš„ï¼Œä¸ä¾¿äºŽé¡ºåºæŸ¥æ‰¾å…³é”®å­—ï¼Œä¹Ÿä¸é€‚åˆäºŽèŒƒå›´æŸ¥æ‰¾ï¼Œæˆ–æœ€å¤§ã€æœ€å°å€¼æŸ¥æ‰¾ã€‚ å¼€æ”¾å®šå€æ³•çš„å­˜å‚¨æ•ˆçŽ‡å¾ˆé«˜ï¼Œä½†æ˜¯å­˜åœ¨â€œèšé›†â€çŽ°è±¡ï¼›åˆ†ç¦»é“¾æŽ¥æ³•æ˜¯é¡ºåºå­˜å‚¨å’Œé“¾å¼å­˜å‚¨çš„ç»“åˆï¼Œé“¾è¡¨éƒ¨åˆ†çš„å­˜å‚¨æ•ˆçŽ‡å’ŒæŸ¥æ‰¾æ•ˆçŽ‡éƒ½æ¯”è¾ƒä½Žï¼Œå…³é”®å­—çš„åˆ é™¤ä¸éœ€è¦â€œæ‡’æƒ°åˆ é™¤ï¼ˆä¸æ–­é“¾ï¼Œåªæ ‡è®°ä¸ºç©ºï¼‰â€ï¼Œä»Žè€Œæ²¡æœ‰å­˜å‚¨â€œåžƒåœ¾â€ï¼Œä½†å¤ªå°çš„$\alpha$å¯èƒ½å¯¼è‡´ç©ºé—´æµªè´¹ï¼Œå¤§çš„$\alpha$åˆå°†ä»˜å‡ºæ›´å¤šçš„æ—¶é—´ä»£ä»·ï¼Œä¸”ä¸å‡åŒ€çš„é“¾è¡¨é•¿åº¦ä¼šå¯¼è‡´æ—¶é—´æ•ˆçŽ‡çš„ä¸¥é‡ä¸‹é™ã€‚ Homework11-1 ç”µè¯èŠå¤©ç‹‚äººè¿™ä¸ªé¢˜å§¥å§¥å·²ç»è®²è¿‡äº†ï¼Œç›´æŽ¥ç”¨å§¥å§¥çš„ä»£ç æœ‰ç‚¹éº»çƒ¦ï¼Œå€ŸåŠ© C++ çš„ MAP å’Œæ•£åˆ—çš„æ€æƒ³ï¼Œå¯ä»¥å¾ˆè½»æ¾çš„è§£å†³è¿™ä¸ªé—®é¢˜ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2000000 + 5;map&lt;string, int&gt; phonenum2num;map&lt;int, string&gt; num2phonenum;int times[maxn] = &#123; 0 &#125;, n, index = 1;int main() &#123; cin &gt;&gt; n; string num; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; num; int tmp = phonenum2num.find(num)-&gt;second; if (!tmp) &#123; phonenum2num[num] = index; num2phonenum[index] = num; times[index] = 1; index++; &#125; else &#123; times[tmp]++; &#125; &#125; int max = times[1], maxindex = 1, count = 1; string madman = num2phonenum.find(1)-&gt;second; for (int i = 2; i &lt; index; i++) &#123; if (times[i] &gt; max) &#123; max = times[i]; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; else if (times[i] == max) &#123; if (num2phonenum.find(i)-&gt;second &lt; num2phonenum.find(maxindex)-&gt;second) &#123; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; count++; &#125; &#125; if (count == 1) cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max; else cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max &lt;&lt; ' ' &lt;&lt; count; return 0;&#125;/*samples:in:413005711862 1358862583213505711862 1308862583213588625832 1808792583215005713862 13588625832out:13588625832 3*/ 11-2 Hashingæœ¬é¢˜è€ƒå¯Ÿæ•£åˆ—æŸ¥æ‰¾çš„å†²çªå¤„ç†æ–¹æ³•ï¼Œé¢˜ç›®å¾ˆç›´ç™½çš„å‘Šè¯‰äº†å¤„ç†å†²çªçš„æ–¹æ³•æ˜¯å¹³æ–¹æŽ¢æµ‹æ³•ï¼Œä½†é¢˜ç›®è¦æ±‚çš„å¹³æ–¹æŽ¢æµ‹åªä¼šç”¨æ­£æ•´æ•°æŽ¢æµ‹ã€‚è¿™æ–¹é¢çš„çŸ¥è¯†ï¼Œè¯¾ä¸Šä½•è€å¸ˆå·²ç»è®²çš„å¾ˆæ¸…æ¥šäº†ï¼Œä¸è¿‡è¿™ä¸ªé¢˜çš„éš¾ç‚¹åœ¨äºŽå¦‚ä½•å¤„ç†æ— æ³•è¿›è¡Œæ•£åˆ—çš„æ•°ã€‚ ç”±äºŽé¢˜ç›®å‘Šè¯‰äº†åªä¼šç”¨æ­£æ•´æ•°æŽ¢æµ‹ï¼Œå…¶å®žç®—æ˜¯å˜ç›¸çš„å‘Šè¯‰ä½ äº†ï¼Œåªè¦ç»è¿‡æ•£åˆ—å‡½æ•°å¾—åˆ°çš„ä¸‹æ ‡å€¼å¤§äºŽæ•£åˆ—è¡¨é•¿åº¦ï¼Œå°±è®¤ä¸ºæ— æ³•å­˜æ”¾äº†ï¼Œä¹Ÿå°±æ˜¯è¯´å¹¶ä¸ä¼šå¾ªçŽ¯è¯•æŽ¢ï¼Œæ˜Žç™½è¿™ç‚¹åŽå°±å¥½åŠžäº†ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 20000 + 10;bool hashTable[maxn] = &#123; 0 &#125;;bool isprime(int n) &#123; if (n &lt;= 1) return false; else &#123; int tmp = (int)sqrt(n); for (int i = 2; i &lt;= tmp; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125;int nextprime(int m) &#123; while (!isprime(m)) m++; return m;&#125;int hashfunc(int num, int hashkey) &#123; return num % hashkey;&#125;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; m = nextprime(m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; int index = hashfunc(tmp, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; &#125; else &#123; int step; for (step = 1; step &lt; m; step++) &#123; index = hashfunc(tmp + step * step, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; break; &#125; &#125; if (step &gt;= m) &#123; if (i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; '-'; &#125; &#125; &#125; return 0;&#125;/*samples:in:4 410 6 4 15out:0 1 4 -in:5 510 6 4 15 25out:0 1 4 - -in:5 55 10 6 4 15 out:0 1 2 4 -in:1 11out:1*/ 11-3 QQ è´¦æˆ·çš„ç”³è¯·ä¸Žç™»é™†è¿™é¢˜ç”¨ MAP ç®€ç›´å¤ªå®¹æ˜“äº†ï¼Œè¦æ˜¯å…¨éƒ¨è‡ªå·±å†™ï¼Œä»£ç é‡ç•¥å¤§ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; qqnum;int main() &#123; int n; char ope; cin &gt;&gt; n; string tmp_num, tmp_pass; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ope &gt;&gt; tmp_num &gt;&gt; tmp_pass; map&lt;string, string&gt;::iterator it; it = qqnum.find(tmp_num); switch (ope) &#123; case 'L': &#123; if (it == qqnum.end()) &#123; cout &lt;&lt; "ERROR: Not Exist" &lt;&lt; endl; &#125; else &#123; if (it-&gt;second == tmp_pass) &#123; cout &lt;&lt; "Login: OK" &lt;&lt; endl; &#125; else cout &lt;&lt; "ERROR: Wrong PW" &lt;&lt; endl; &#125; break; &#125; case 'N': &#123; if (it != qqnum.end()) &#123; cout &lt;&lt; "ERROR: Exist" &lt;&lt; endl; &#125; else &#123; qqnum[tmp_num] = tmp_pass; cout &lt;&lt; "New: OK" &lt;&lt; endl; &#125; break; &#125; default: break; &#125; &#125; return 0;&#125;/*samples:in:5L 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comL 1234567890 myQQ@qqL 1234567890 myQQ@qq.comout:ERROR: Not ExistNew: OKERROR: ExistERROR: Wrong PWLogin: OK*/ 11-4 Hashing - Hard Versionè¿™ä¸ªé¢˜çš„æ„æ€å¾ˆç›´è§‚ï¼Œå°±æ˜¯ç»™å®šä¸€ä¸ªç”¨çº¿æ€§æŽ¢æµ‹æ³•æž„å»ºçš„æ•£åˆ—è¡¨ï¼Œç„¶åŽè¦æ ¹æ®è¿™ä¸ªå¾—åˆ°æ•°å­—åºåˆ—çš„è¾“å…¥é¡ºåºã€‚ è¿™ä¸ªé¢˜çœ‹èµ·æ¥å¾ˆå®¹æ˜“ï¼Œå…¶å®žæœ‰ç‚¹éš¾æƒ³ã€‚å› ä¸ºå°±æ ·ä¾‹è€Œè¨€ï¼Œ33 å’Œ 1 éƒ½æœ‰å¯èƒ½æ˜¯ç¬¬ä¸€ä¸ªè¾“å…¥çš„ï¼Œè¯¥æ€Žä¹ˆç¡®å®šæ•°å­—çš„è¾“å…¥é¡ºåºå…¶å®žå°±æ˜¯éš¾ç‚¹ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œåšä¸€é“é¢˜æ—¶ï¼Œæƒ³åˆ°çš„éƒ½æ˜¯è·Ÿè¿™ä¸ªé¢˜ç›¸å…³çš„çŸ¥è¯†ã€‚ä½†æ˜¯è¿™ä¸ªé¢˜ï¼Œç¡®å®šè¾“å…¥é¡ºåºå…¶å®žéœ€è¦ç”¨åˆ°æ‹“æ‰‘æŽ’åºçš„çŸ¥è¯†ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000 + 3;vector&lt;int&gt; AdjL[maxn];int n, hashTable[maxn], elements = 0;bool isvis[maxn] = &#123;false&#125;;map&lt;int, int&gt; value2index;map&lt;int, int&gt; index2value;void toposort() &#123; int indegree[maxn] = &#123;0&#125;; for(int v = 0; v &lt; n; v++) &#123; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]++; &#125; &#125; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) &#123; if(indegree[i] == 0 &amp;&amp; hashTable[i] &gt;= 0) &#123; q.push(hashTable[i]); &#125; &#125; int count = 0; while(!q.empty()) &#123; int tmp = q.top(); q.pop(); cout &lt;&lt; tmp; if(count &lt; elements - 1) &#123; cout &lt;&lt; ' '; count++; &#125; int v = value2index[tmp]; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]--; if(indegree[AdjL[v][w]] == 0) q.push(hashTable[AdjL[v][w]]); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; hashTable[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(hashTable[i] &lt; 0) continue; value2index[hashTable[i]] = i; index2value[i] = hashTable[i]; elements++; int tmp = hashTable[i]; int index = tmp % n; if(hashTable[index] == hashTable[i] &amp;&amp; index == i) continue; else &#123; bool flag = true; queue&lt;int&gt; q; for(; index &lt; n || flag; index++) &#123; if(flag &amp;&amp; index &gt;= n) &#123; index %= n; flag = false; &#125; if(hashTable[index] == tmp) break; q.push(index); &#125; while(!q.empty()) &#123; int front = q.front(); q.pop(); AdjL[front].push_back(index); &#125; &#125; &#125; toposort(); return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_10-æŽ’åºï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F09%2F05%2FZJU-DS-10-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨ç»§ç»­ä»‹ç»æŽ’åºç®—æ³•ã€‚ å¿«é€ŸæŽ’åºå¿«é€ŸæŽ’åºä¸Žå½’å¹¶æŽ’åºçš„ç­–ç•¥æœ‰äº›ç±»ä¼¼ï¼ŒåŸºæœ¬æ€æƒ³ä¹Ÿæ˜¯åˆ†æ²»æ³•ï¼Œé¦–å…ˆä»Žå¾…æŽ’åºåˆ—ä¸­æ‰¾ä¸€ä¸ªä¸»å…ƒï¼Œæ ¹æ®è¿™ä¸ªä¸»å…ƒå°†å¾…æŽ’åºåˆ—çš„æ‰€æœ‰å…ƒç´ åˆ’åˆ†ä¸ºä¸¤éƒ¨åˆ†ï¼Œä¸€éƒ¨åˆ†æ¯”å®ƒå°ï¼Œå¦ä¸€éƒ¨åˆ†æ¯”å®ƒå¤§ï¼Œç„¶åŽå¯¹ä¸¤ä¸ªå­éƒ¨åˆ†åœ¨è¿›è¡Œåˆ’åˆ†å’ŒæŽ’åºï¼Œä¾æ¬¡é‡å¤æ“ä½œï¼Œæœ€åŽå†å°†è¿™äº›åˆå¹¶ä¸ºä¸€ä¸ªåºåˆ—ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678void Quick_Sort(ElementType A[], int N) &#123; if(N &lt; 2) return; pivot = ä»ŽA[]ä¸­é€‰ä¸€ä¸ªä¸»å…ƒ; å°†S = &#123;A[] / pivot&#125; åˆ†æˆ2ä¸ªç‹¬ç«‹å­é›†; A1 = &#123;a âˆˆ S | A &lt;= pivot&#125;; A2 = &#123;a âˆˆ S | A &gt;= pivot&#125;; A[] = Quick_Sort(A1, N1)âˆª(pivot)âˆªQuick_Sort(A2, N2);&#125; æŒ‰ç…§ä¸Šè¿°çš„ä¼ªç æè¿°ï¼Œå¿«æŽ’éœ€è¦è§£å†³çš„é—®é¢˜æœ‰ä¸¤ä¸ªï¼š 1. å¦‚ä½•åŽ»é€‰ä¸»å…ƒ2. å¦‚ä½•è¿›è¡Œå­é›†åˆ’åˆ† å¾ˆæ˜Žæ˜¾ï¼ŒæŒ‰ç…§æ€è·¯ï¼Œèƒ½æŠŠç¬¬ä¸€ä¸ªé—®é¢˜è§£å†³äº†ï¼Œç¬¬äºŒä¸ªé—®é¢˜ä¹Ÿå°±è¿Žåˆƒè€Œè§£äº†ã€‚ é€‰ä¸»å…ƒé‚£ä¹ˆä¸»å…ƒåº”è¯¥æ€Žä¹ˆåŽ»é€‰æ‹©å‘¢ï¼Ÿæ¯”è¾ƒç»å…¸çš„æ–¹æ³•å°±æ˜¯å–å¤´ã€ä¸­ã€å°¾ä¸‰ä¸ªæ•°ï¼ˆå½“ç„¶ä¹Ÿå¯ä»¥äº”ä¸ªæ•°ï¼‰çš„ä¸­ä½æ•°ï¼ˆä»¥åºåˆ—{8, 12, 3}ä¸ºä¾‹ï¼Œå®ƒçš„ä¸­ä½æ•°æ˜¯8ï¼‰ï¼Œé€‰ä¸»å…ƒæ—¶ï¼Œå¯ä»¥é¡ºä¾¿å°†å¾…é€‰çš„ä¸‰ä½æ•°è¿›è¡ŒæŽ’åºï¼Œè¿™æ ·å½“é€‰å‡ºä¸»å…ƒåŽï¼Œä¹Ÿå¯ä»¥å¾…æŽ’åºåˆ—æ•°æ®çš„æ€»ä¸ªæ•°å‡å°‘ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112ElementType Median3(ElementType A[], int Left, int Right)&#123; int Center = (Left + Right)/2; if(A[Left] &lt; A[Center]) Swap(&amp;A[Left], &amp;A[Center]); if(A[Left] &lt; A[Right]) Swap(&amp;A[Left], &amp;A[Right]); if(A[Center] &lt; A[Right]) Swap(&amp;A[Center], &amp;A[Right]); /*after finish swap, A[Left] &lt;= A[Center] &lt;= A[Right]*/ /*put the pivot to A[Right-1], then only consider the sequence from A[Left+1] to A[Right-2]*/ Swap(&amp;A[Center], &amp;A[Right-1]); return A[Right-1];&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œå› ä¸ºæœ€åŽå°†pivotæ”¾åˆ°äº†Right-1ä½ç½®ï¼Œæ‰€ä»¥ï¼Œå¦å¤–ä¸¤ä¸ªå…ƒç´ çš„ä½ç½®å°±å¯ä»¥ä¸ç”¨åœ¨è€ƒè™‘äº†ï¼Œåªè€ƒè™‘åŒºé—´$[Left+1, Right-1]$å†…çš„å…ƒç´ å³å¯ã€‚ å­é›†åˆ’åˆ†å­é›†åˆ’åˆ†æ—¶ï¼Œéœ€è¦ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªé¦–ï¼Œä¸€ä¸ªå°¾ï¼Œå½“å°¾æŒ‡é’ˆå°äºŽé¦–æŒ‡é’ˆï¼ˆä¸¤è€…å·²äº¤å‰ï¼‰æ—¶ï¼Œè¯´æ˜Žå­é›†çš„åˆ’åˆ†å·²å®Œæˆã€‚åœ¨è¿›è¡Œè¿™ä¸ªæ“ä½œæ—¶ï¼Œä¼šå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯é‡åˆ°ç›¸ç­‰çš„å…ƒç´ æ€Žä¹ˆåŠžï¼Ÿä»¥æœ€åçš„æƒ…å†µï¼ˆåºåˆ—å…ƒç´ å…¨éƒ¨ç›¸ç­‰ï¼‰ä¸ºä¾‹ï¼Œå¦‚æžœé‡‡å–ç›´æŽ¥äº¤æ¢å…ƒç´ çš„æ–¹æ³•ï¼Œé‚£ä¹ˆé¦–ã€å°¾æŒ‡é’ˆçš„æ¯ä¸€æ¬¡å˜åŒ–ï¼Œéƒ½éœ€è¦äº¤æ¢ä¸€æ¬¡å…ƒç´ ï¼Œç»“æŸåŽï¼Œä¸»å…ƒpivotä¼šè¢«æ”¾åœ¨ä¸­é—´çš„ä½ç½®ï¼Œè¿™æ ·ä¸‹ä¸€æ¬¡å¾ªçŽ¯çš„æ—¶å€™å°±ä¼šå°†å‰©ä¸‹çš„åºåˆ—åœ¨ç­‰åˆ†æˆä¸¤ä¸ªåºåˆ—ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±æ˜¯$O(NlogN)$äº†ï¼›é‚£å¦‚æžœè·³è¿‡ç›¸ç­‰çš„å…ƒç´ å‘¢ï¼Ÿåœ¨æœ€åçš„æƒ…å†µä¸‹ï¼Œä¼šæœ‰ä¸€ç«¯çš„æŒ‡é’ˆåœæ»žä¸å‰ï¼Œé‚£ä¹ˆæ¯æ¬¡å°±åªæœ‰ä¸€ä¸ªæŒ‡é’ˆåœ¨ç§»åŠ¨ï¼Œè¿™æ ·æ¯æ¬¡å¾—åˆ°çš„å­åºåˆ—å°±$N, N-1, N-2, \dots, 1$äº†ï¼Œé‚£æ ·æ—¶é—´å¤æ‚åº¦ä¾ç„¶æ˜¯$O(N^2)$ï¼Œæ‰€ä»¥è¿˜æ˜¯é‡‡å–äº¤æ¢å…ƒç´ çš„æ–¹æ³•ã€‚å¦å¤–ï¼Œå¦‚æžœæ•°æ®è§„æ¨¡è¾ƒå°çš„è¯ï¼Œï¼Œç‰¹åˆ«æ˜¯æ•°æ®æ€»æ•°è¿ž100éƒ½ä¸åˆ°çš„æ—¶å€™ï¼Œå¯¹äºŽä¾ç„¶ä½¿ç”¨é€’å½’çš„å¿«é€ŸæŽ’åºè€Œè¨€ï¼Œå°±ä¸æ˜¯é‚£ä¹ˆåˆ’ç®—äº†ï¼Œæ‰€ä»¥éœ€è¦åšä¸ªåˆ¤æ–­ï¼Œåœ¨æ•°æ®è§„æ¨¡è¾ƒå°çš„æ—¶å€™ï¼Œé‡‡å–å…¶ä»–çš„æŽ’åºæ–¹å¼ã€‚ ç®—æ³•å®žçŽ°é€‰å¥½ä¸»å…ƒï¼Œæ˜Žç¡®å­é›†çš„åˆ’åˆ†æ–¹æ³•ï¼Œå°±å¯ä»¥æ¥æž„é€ ç®—æ³•äº†ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void QuickSort(ElementType A[], int Left, int Right)&#123; if(Cutoff &lt;= Right-Left)&#123; Pivot = Median3(A, Left, Right); i = Left; J = Right - 1; for(; ; ) &#123; while(A[++i] &lt; pivot); while(A[++j] &lt; pivot); if(i &lt;= j) Swap(&amp;A[i], &amp;A[j]); else break; &#125; Swap(&amp;A[i], &amp;A[Right-1]); QuickSort(A, Left, i-1); QuickSort(A, i+1, Right); &#125;else Insertion_Sort(A+Left, Right-Left+1);&#125; ä¸Šè¿°ä»£ç çš„æ€è·¯æ¯”è¾ƒç›´è§‚ï¼Œå…ˆé€‰å¥½ä¸»å…ƒï¼Œåœ¨è¿›è¡Œå­é›†åˆ’åˆ†ï¼Œç„¶åŽå°†ä¸»å…ƒæ”¾åˆ°é è¿‘ä¸­é—´çš„ä½ç½®ï¼Œæ­¤æ—¶ä¸»å…ƒçš„ä½ç½®ä¸Žæœ€ç»ˆç»“æžœåºåˆ—çš„ä½ç½®æ˜¯ä¸€è‡´çš„ï¼Œè¿™ç‚¹ä¸Žå†’æ³¡æŽ’åºä¸€æ ·ï¼Œæ¯æ¬¡éƒ½ä¼šæœ‰ä¸€ä¸ªå…ƒç´ è¢«æŽ’åˆ°æœ€ç»ˆä½ç½®ã€‚å½“å¾…æŽ’å…ƒç´ å°äºŽé˜ˆå€¼Cutoffæ—¶ï¼Œç›´æŽ¥ä½¿ç”¨æ’å…¥æŽ’åºè§£å†³å‰©ä¸‹çš„å…ƒç´ åºåˆ—ã€‚ è¡¨æŽ’åºè¡¨æŽ’åºé€‚ç”¨äºŽå¾…æŽ’å…ƒç´ ä¸æ˜¯ç®€å•çš„æ•´æ•°ï¼Œè€Œæ˜¯å¤æ‚ã€åºžå¤§çš„å…ƒç´ çš„æ—¶å€™ï¼Œå› ä¸ºè¿™äº›å¤æ‚ã€åºžå¤§çš„å…ƒç´ çš„äº¤æ¢å’Œç§»åŠ¨ä¼šååˆ†è´¹æ—¶ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œè¡¨æŽ’åºåœ¨æŽ’åºè¿‡ç¨‹ä¸­ä¸éœ€è¦ç§»åŠ¨å…ƒç´ ï¼Œåªéœ€è¦ç§»åŠ¨æŒ‡é’ˆå³å¯ï¼Œè¿™ç§ä¸ç§»åŠ¨å…ƒç´ ï¼Œåªç§»åŠ¨æŒ‡é’ˆçš„æŽ’åºæ–¹æ³•ç§°ä¸ºé—´æŽ¥æŽ’åºã€‚å®šä¹‰ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ä½œä¸ºâ€œè¡¨â€ï¼ˆtableï¼‰ï¼Œè¡¨æŽ’åºç®—æ³•çš„æ“ä½œå¯¹è±¡å°±æ˜¯è¿™ä¸ªâ€œè¡¨â€äº†ã€‚ ç‰©ç†æŽ’åºå‡è‹¥ä»ç„¶éœ€è¦ç§»åŠ¨å®žé™…çš„å…ƒç´ æ¥å®ŒæˆæŽ’åºï¼Œé‚£ä¹ˆå¯ä»¥æ ¹æ®ä¸‹é¢è¿™ä¸ªç»“è®ºåœ¨çº¿æ€§çš„æ—¶é—´å¤æ‚åº¦å†…å®Œæˆè¿™ä¸ªæ“ä½œã€‚ å®šç†ï¼šNä¸ªæ•°å­—çš„æŽ’åˆ—ç”±è‹¥å¹²ä¸ªç‹¬ç«‹çš„çŽ¯ç»„æˆã€‚ è¿™é‡Œçš„â€œçŽ¯â€ï¼Œå…¶å®žæ˜¯ä¸€ä¸ªæ¯”è¾ƒæŠ½è±¡çš„æ¦‚å¿µï¼ŒæŒ‡çš„æ˜¯ç»è¿‡è¡¨æŽ’åºåŽç­‰åˆ°çš„tableå†…ï¼Œæœ‰äº›å…ƒç´ çš„é¡ºåºä¼šå½¢æˆä¸€ä¸ªåºåˆ—ï¼Œè€Œè¿™ä¸ªåºåˆ—å°±ç§°ä½œâ€œçŽ¯â€ã€‚ä¸‹é¢æ¥çœ‹ä¸ªä¾‹å­ï¼Œè¡¨æŽ’åºå‰ï¼š A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 è¡¨æŽ’åºåŽï¼š A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 ä¸Šè¡¨ä¸­ï¼Œç”±{3, 5, 1, 0}è¿™ä¸ªä¸‹æ ‡åºåˆ—å¯å¾—å¯¹åº”çš„æœ‰åºåºåˆ—ä¸º{a, b, d, f}ï¼Œè¿™ä¸ªåºåˆ—æ˜¯æœ‰åºçš„ï¼Œå…¶å¯¹åº”å…³ç³»å¦‚ä¸‹è¡¨ï¼š A [0] [1] [3] [5] table 3 5 1 0 ç”±ä¸Šè¡¨ä¸­æž„æˆçš„å…³ç³»ï¼Œå°±æ˜¯â€œçŽ¯â€ï¼Œå¯ä»¥æ ¹æ®â€œçŽ¯â€å¾—åˆ°æœ‰åºçš„åºåˆ—ã€‚ç´§æŽ¥ç€ï¼Œæ ¹æ®è¿™äº›æœ‰åºçš„åºåˆ—ï¼Œå€ŸåŠ©ä¸€ä¸ªä¸´æ—¶ç©ºé—´ï¼ŒéåŽ†ä¸€æ¬¡è¿™ä¸ªæœ‰åºåºåˆ—ï¼Œå°±å¯ä»¥å®Œæˆç‰©ç†åºåˆ—çš„æŽ’åºã€‚å¾ˆæ˜Žæ˜¾å¯ä»¥å¾—åˆ°ï¼Œå½“table[i] == iæ—¶ï¼ŒçŽ¯å°±ç»“æŸäº†ã€‚ æ—¶é—´å¤æ‚åº¦åˆ†æžå½“åˆå§‹åºåˆ—ä¸ºæœ‰åºæ—¶ï¼Œæ˜¯æœ€å¥½çš„æƒ…å†µï¼›å½“æœ‰$\lfloor N/2 \rfloor$ä¸ªçŽ¯æ—¶ï¼Œæ¯ä¸ªçŽ¯åŒ…å«2ä¸ªå…ƒç´ ï¼Œäº¤æ¢ä¸¤ä¸ªå…ƒç´ éœ€è¦ä¸‰æ­¥æ“ä½œï¼Œå°±éœ€è¦$\lfloor 3N/2 \rfloor$æ¬¡å…ƒç´ ç§»åŠ¨ï¼Œè€Œè¡¨æŽ’åºé’ˆå¯¹çš„å°±æ˜¯å…ƒç´ ç§»åŠ¨æ—¶é—´è¾ƒé•¿çš„å­˜å‚¨ç»“æž„ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T = O(m\ N)$ï¼Œ$m$ä¸ºæ¯ä¸ªå…ƒç´ çš„å¤åˆ¶æ—¶é—´ã€‚ åŸºæ•°æŽ’åºåŸºæ•°æŽ’åºä¸Žå…¶ä»–æŽ’åºç®—æ³•æœ‰ä¸€ä¸ªå¾ˆå¤§çš„å·®åˆ«ï¼Œé‚£å°±æ˜¯ä¸ä»…åªæ˜¯æ¯”å¤§å°äº†ï¼Œå› ä¸ºå•çº¯é æ¯”è¾ƒå¤§å°çš„æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦æœ€ä½Žåªèƒ½æ˜¯$T(NlogN)$è¿™ä¸ªçº§åˆ«ï¼Œæ‰€ä»¥å¾—åœ¨æ·»ç‚¹â€œæ–™â€æ¥ç»§ç»­æå‡é€Ÿåº¦ï¼Œä¸‹é¢å…ˆæ¥çœ‹çœ‹æ¡¶æŽ’åºã€‚ æ¡¶æŽ’åºå¯¹äºŽæ¡¶æŽ’åºè€Œè¨€ï¼Œå‡è®¾å¾…æŽ’åºåˆ—æœ‰$N$ä¸ªå…ƒç´ ï¼Œå…ˆç”³è¯·$N$ä¸ªæ¡¶ï¼ˆæœ‰åºï¼Œæ¡¶å†…ä¿å­˜æŒ‡é’ˆï¼‰ï¼Œç„¶åŽå°†æ¯ä¸€ä¸ªç¬¦åˆæ¡ä»¶çš„å€¼ï¼Œæ’åˆ°è¿™ä¸ªæœ‰åºçš„æ¡¶æŽ’åˆ—ä¸­ï¼Œè¿™æ ·å°±å¯ä»¥äº†ï¼Œå¤§è‡´ä»£ç å¦‚ä¸‹ï¼š1234567891011void Bucket_Sort(ElementType A[], int N) &#123; count[]åˆå§‹åŒ–; while(è¯»å…¥ä¸€ä¸ªæ•°æ®) &#123; å°†è¯¥æ•°æ®æ’å…¥count[æ¡¶å†…ä¿å­˜çš„æŒ‡é’ˆ++]; &#125; for(i=0; i&lt;M; i++) &#123; if(count[i])&#123; è¾“å‡ºcount[i]æ•´ä¸ªé“¾è¡¨; &#125; &#125;&#125; æŒ‰ç…§ä¸Šè¿°çš„ä¼ªç ï¼Œæœ‰$N$ä¸ªæ•°æ®éœ€è¦è¯»å…¥ï¼Œ$M$ä¸ªæ•°æ®éœ€è¦è¾“å‡ºï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T(N, M) = O(M + N)$ã€‚ä½†æ˜¯å½“$M &gt;&gt; N$çš„æƒ…å†µä¸‹ï¼Œä½¿ç”¨æ¡¶æŽ’åºå°±ä¸æ˜¯é‚£ä¹ˆåˆ’ç®—äº†ï¼Œè¿™å°±éœ€è¦ä½¿ç”¨åŸºæ•°æŽ’åºäº†ã€‚ æ¡¶æŽ’åºåŸºæœ¬æ€æƒ³äº†è§£äº†æ¡¶æŽ’åºä¹‹åŽï¼ŒåŸºæ•°æŽ’åºå°±å¥½ç†è§£äº†ï¼ŒåŸºæ•°æŽ’åºå»ºæ¡¶è§„åˆ™æ˜¯æŒ‰ç…§ç»™å®šæ•°æ®çš„è¿›åˆ¶æ•°å»ºæ¡¶ï¼Œä¾‹å¦‚{78, 123, 44, 678}ï¼Œ è¿™ä¸ªåºåˆ—çš„æ•°éƒ½æ˜¯åè¿›åˆ¶çš„ï¼Œæ‰€ä»¥åŸºæ•°ï¼ˆæ¡¶çš„å¤§å°ï¼‰ä¸º 10ã€‚ åŸºæ•°æŽ’åºç®—æ³•çš„ä¸»ä½“æ€æƒ³é‡‡ç”¨çš„æ˜¯æ¬¡ä½ä¼˜å…ˆï¼ˆLeast Significant Digitï¼‰çš„æ€æƒ³ï¼ˆä¹Ÿå¯ä»¥ä½¿ç”¨ä¸»ä½ä¼˜å…ˆ(Most Significant Digit)ï¼‰ï¼Œç®€å•æ¥è®²ï¼Œç¬¬ä¸€æ¬¡æŽ’åºä»¥ä¸ªä½æ•°å¤§å°ä¸ºåŸºå‡†æ¥æŽ’åºï¼Œç¬¬äºŒæ¬¡æŽ’åºä»¥åä½æ•°å¤§å°ä¸ºåŸºå‡†æ¥æŽ’åºï¼Œä½†éœ€è¦å°†ç¬¬ä¸€æ¬¡æŽ’åºä¸­çš„é«˜ä½æ•°æ‹¿å‡ºæ¥ï¼Œé‡å¤è‡³æœ€é«˜ä½æŽ’å®ŒåŽç»“æŸã€‚æ¯èººæŽ’åºè¿‡ç¨‹ä¸­ï¼Œéœ€è¦è®¿é—®$N$ä¸ªç»“ç‚¹ï¼Œä¹Ÿéœ€è¦è®¿é—®$B$ä¸ªæ¡¶ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦ä¸º$T=O(P(N+B))$ã€‚ å¤šå…³é”®å­—æŽ’åºæ‰‘å…‹ç‰Œçš„èŠ±è‰²å°±æ˜¯ä¸€ç§â€œå¤šå…³é”®å­—æŽ’åºâ€ï¼Œä¸åŒèŠ±è‰²åŒèŠ±é¡ºä¹Ÿæœ‰å¤§å°ä¹‹åˆ†ã€‚ ä»¥ä¸ºæ‰‘å…‹ç‰ŒæŽ’åºä¸ºä¾‹ï¼Œæ‰‘å…‹ç‰Œæœ‰ä¸¤ç§å±žæ€§ï¼Œåˆ†åˆ«æ˜¯èŠ±è‰²å’Œå¤§å°ï¼Œä¸€å‰¯æ•´é½çš„æ‰‘å…‹ç‰Œï¼ŒèŠ±è‰²å’Œå¤§å°å¿…å®šéƒ½æ˜¯æ•´é½çš„ï¼Œæ ¹æ®åŸºæ•°æŽ’åºçš„æ€æƒ³ï¼Œæˆ‘ä»¬å¯ä»¥å…ˆæŒ‰ç…§å¤§å°æ¥åšåŸºæ•°æŽ’åºï¼Œè¿™éœ€è¦13ä¸ªæ¡¶æ¥å®Œæˆï¼ŒæŽ’å¥½åºåŽï¼Œå„ä¸ªæ¡¶ä¸­çš„ç‰Œçš„å¤§å°éƒ½æ˜¯ç›¸ç­‰çš„ï¼Œæ­¤æ—¶æˆ‘ä»¬åœ¨ä»¥èŠ±è‰²ä¸ºåŸºæ•°å»ºæ¡¶ï¼Œä¾æ¬¡å–å‡ºèŠ±è‰²æŒ‰é¡ºåºå–å‡ºèŠ±è‰²ç›¸åŒçš„ç‰Œæ”¾åˆ°ä¸åŒèŠ±è‰²çš„æ¡¶å†…å³å¯ï¼Œå·²ç»ä¸éœ€è¦æ ¹æ®å¤§å°æŽ’åºäº†ã€‚ æŽ’åºç®—æ³•çš„æ¯”è¾ƒ æŽ’åºæ–¹æ³• å¹³å‡æ—¶é—´å¤æ‚åº¦ æœ€åæƒ…å†µæ—¶é—´å¤æ‚åº¦ é¢å¤–ç©ºé—´å¤æ‚åº¦ ç¨³å®šæ€§ ç®€å•é€‰æ‹©æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ä¸ç¨³å®š å†’æ³¡æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ç¨³å®š ç›´æŽ¥æ’å…¥æŽ’åº $O(N^2)$ $O(N^2)$ $O(1)$ ç¨³å®š å¸Œå°”æŽ’åº $O(N^d)$ $O(N^2)$ $O(1)$ ä¸ç¨³å®š å †æŽ’åº $O(NlogN)$ $O(NlogN)$ $O(1)$ ä¸ç¨³å®š å¿«é€ŸæŽ’åº $O(NlogN)$ $O(N^2)$ $O(logN)$ ä¸ç¨³å®š å½’å¹¶æŽ’åº $O(NlogN)$ $O(NlogN)$ $O(N)$ ç¨³å®š åŸºæ•°æŽ’åº $O(P(N+B))$ $O(P(N+B))$ $O(N+B)$ ç¨³å®š å°½ç®¡ä¸Šè¡¨ä¸­ç»™å‡ºäº†å„æŽ’åºç®—æ³•çš„å…·ä½“çš„æ—¶é—´å¤æ‚åº¦ï¼Œä½†æ˜¯å®žé™…åº”ç”¨æ—¶è¿˜æ˜¯éœ€è¦æ ¹æ®å®žé™…æƒ…å†µæ¥é€‰æ‹©åˆé€‚çš„æŽ’åºç®—æ³•ã€‚å¦å¤–ï¼Œä»Žè¡¨ä¸­çœ‹åˆ°å †æŽ’åºçš„æ€§èƒ½æ¯”è¾ƒå¥½ï¼Œä½†æ˜¯å®žé™…æ•ˆæžœä¸å¤ªç†æƒ³ã€‚é™¤äº†è¿™äº›åŸºç¡€æŽ’åºç®—æ³•å¤–ï¼Œè¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„æŽ’åºç®—æ³•ï¼Œé‚£äº›ä¹Ÿå€¼å¾—è¿›ä¸€æ­¥å­¦ä¹ ã€‚ Homework10-4 ç»Ÿè®¡å·¥é¾„è¿™ä¸ªé¢˜ç›®å¾ˆç®€å•ï¼Œå€ŸåŠ©ä¸€ä¸‹å§¥å§¥è¯¾ä¸Šè®²çš„æ¡¶æŽ’åºçš„æ€æƒ³å³å¯ï¼ŒC++ è¯­æ³•çš„ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;int main() &#123; int n; std::cin &gt;&gt; n; int staff[55] = &#123; 0 &#125;, tmp; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; tmp; staff[tmp]++; &#125; for (int i = 0; i &lt; 52; i++) &#123; if (staff[i]) std::cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; staff[i] &lt;&lt; std::endl; &#125; return 0;&#125;/*samples:in:810 2 0 5 7 2 5 2out:0:12:35:27:110:1in:1010 2 0 0 0 5 7 2 5 2out:0:32:35:27:110:1*/ 10-5 PAT Judgeè¿™é“é¢˜ç›®çš„å‡ºé¢˜èƒŒæ™¯åº”è¯¥å°±æ˜¯ PAT çš„æŽ’åç³»ç»Ÿäº†ï¼Œä½†å…¶å®žæ˜¯ç”²çº§é¢˜åº“çš„ä¸€é“æŽ’åºé¢˜ï¼Œéœ€è¦æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚æ¥è¿›è¡ŒæŽ’åºï¼Œç›´æŽ¥ä½¿ç”¨ C++ çš„åº“å‡½æ•°ä¼šæ–¹ä¾¿è®¸å¤šã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10000 + 5;struct user&#123; int id, scores[6], sum, perfect; bool flag;&#125; us[maxn];int n, k, m, p[6] = &#123;0&#125;;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void init() &#123; for(int i = 1; i &lt;= n; i++) &#123; us[i].id = i; us[i].sum = us[i].perfect = 0; us[i].flag = false; memset(us[i].scores, -1, sizeof(us[i].scores)); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", p + i); &#125; int id, proid, scoob; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;proid, &amp;scoob); if(scoob != -1) us[id].flag = true; if(scoob == -1 &amp;&amp; us[id].scores[proid] == -1) us[id].scores[proid] = 0; if(scoob == p[proid] &amp;&amp; us[id].scores[proid] &lt; p[proid]) us[id].perfect++; if(scoob &gt; us[id].scores[proid]) us[id].scores[proid] = scoob; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] &gt; 0) us[i].sum += us[i].scores[j]; &#125; &#125; sort(us + 1, us + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; us[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) rank = i; printf("%d %05d %d", rank, us[i].id, us[i].sum); for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] == -1) printf(" -"); else printf(" %d", us[i].scores[j]); &#125; putchar('\n'); &#125; return 0;&#125; /*samples:in:7 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0out:1 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 -in:3 4 920 25 25 3000001 3 3000002 3 3000003 3 3000001 3 3000002 3 2000003 3 2000001 3 3000002 3 1000003 3 30out:1 00001 30 - - 30 -1 00002 30 - - 30 -1 00003 30 - - 30 -in:2 2 620 2000001 1 -100002 1 -100001 1 -100002 1 -100001 1 -100002 1 0out:(blank)*/ 10-6 Sort with Swap(0, i)è¿™ä¸ªé¢˜ä¸å¤ªå¥½æƒ³ï¼Œä½†æ˜¯ä¸Žè¡¨æŽ’åºéžå¸¸ç±»ä¼¼ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int pos[maxn], n, ans = 0;int main() &#123; cin &gt;&gt; n; int remains = n - 1, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; pos[tmp] = i; if(tmp == i &amp;&amp; tmp != 0) remains--; &#125; int k = 1; while(remains &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; remains--; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;/*samples:in:103 5 7 2 6 4 9 0 8 1outÂ£Âº9in:54 0 2 1 3out:3in:30 2 1out:2in:54 3 2 1 0out:4*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_09_æŽ’åºï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F09%2F02%2FZJU-DS-09-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨å°†ä¼šä»‹ç»å‡ ç§å¸¸è§çš„æŽ’åºç®—æ³•ã€‚ ç®€å•æŽ’åºç®€å•æŽ’åºæ˜¯å‡ ä¸ªç®€å•çš„æŽ’åºç®—æ³•çš„ç»Ÿç§°ï¼Œä¸‹é¢æ¥ä¸€ä¸€ä»‹ç»ã€‚ å†’æ³¡æŽ’åºå†’æ³¡æŽ’åºçš„æ€æƒ³æ¯”è¾ƒç›´è§‚ï¼Œæ¯æ¬¡å¾ªçŽ¯æ—¶ï¼Œä¼šå°†æ•°ç»„ï¼ˆæˆ–é“¾è¡¨ï¼‰å†…ç›¸é‚»çš„ä¸¤ä¸ªå…ƒç´ è¿›è¡Œæ¯”è¾ƒï¼ŒæŒ‰ç…§è§„å®šçš„é€’å¢žï¼ˆæˆ–é€’å‡ï¼‰é¡ºåºå‘åŽç§»åŠ¨ï¼Œä¸€ç›´åˆ°é‡å¤åˆ°æœ«å°¾ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); &#125; &#125; &#125;&#125; ä»£ç æ¡†æž¶ååˆ†ç®€å•ï¼Œä½†æ˜¯è¿™æ ·ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯å¾…æŽ’åºåˆ—åœ¨å·²ç»æœ‰åºçš„æƒ…å†µä¸‹ï¼Œä¾ç„¶ä¼šè¿›è¡Œä¸¤æ¬¡å¾ªçŽ¯ï¼Œå°½ç®¡ä¸ä¼šäº¤æ¢ç›¸é‚»å…ƒç´ çš„å€¼ï¼Œä½†æ˜¯è¿˜æ˜¯ä¼šè¿›è¡Œåˆ¤æ–­ï¼Œä¼šç™½ç™½æµªè´¹æ—¶é—´ã€‚ä»”ç»†æƒ³ä¸€ä¸‹ï¼Œå¦‚æžœè¾“å…¥åºåˆ—æ˜¯æœ‰åºçš„ï¼Œé‚£ä¹ˆå…ƒç´ çš„å€¼ä¸€æ¬¡ä¹Ÿä¸ä¼šäº¤æ¢ï¼Œæ ¹æ®è¿™ä¸ªç‰¹ç‚¹ï¼Œå¯ä»¥å¯¹ä¸Šè¿°çš„ä»£ç è¿›è¡Œä¸€ç‚¹å°ä¼˜åŒ–ï¼Œæ·»åŠ ä¸€ä¸ªæ ‡å¿—ä½ï¼Œä¸€æ¬¡æœ‰åºåŽå°±å¯ä»¥ç›´æŽ¥è·³å‡ºå¾ªçŽ¯äº†ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; flag = 0; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); flag = 1; &#125; &#125; if(!flag) break; &#125;&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç çš„æ€è·¯ï¼Œå¯ä»¥è¾ƒä¸ºæ¸…æ™°çš„åˆ†æžå‡ºå†’æ³¡æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ï¼š æœ€å¥½çš„æƒ…å†µï¼Œåºåˆ—ä¸ºé¡ºåºåºåˆ—ï¼Œ$T = O(N)$ æœ€åçš„æƒ…å†µï¼Œåºåˆ—ä¸ºé€†åºåºåˆ—ï¼Œ$T = O(N^2)$ å¦å¤–ï¼Œå¯¹äºŽå†’æ³¡æŽ’åºè€Œè¨€ï¼Œæ¯ä¸€æ¬¡å†’æ³¡ç»“æŸï¼ˆå†…å±‚å¾ªçŽ¯ç»“æŸä¸€è½®ï¼‰åŽéƒ½ä¼šæœ‰ä¸€ä¸ªå…ƒç´ è¢«æ”¾åˆ°è¿™ä¸ªåºåˆ—æœ‰åºåŽçš„æœ€ç»ˆä½ç½®ä¸Šï¼Œè€Œä¸”ï¼Œå†’æ³¡æŽ’åºä¹Ÿä¸ä¼šäº¤æ¢ç›¸åŒå…ƒç´ çš„ä½ç½®ï¼ˆä½¿ç”¨$&gt;$è€Œä¸æ˜¯$\geq$ï¼‰ï¼Œæ‰€ä»¥å†’æ³¡æŽ’åºæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œå†è€…ï¼Œå†’æ³¡æŽ’åºè¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œå³æŽ’åºçš„æ–¹å‘æ˜¯ä¸€å®šçš„ï¼Œåªä¼šæŒ‰ç…§ä¸€ä¸ªæ–¹å‘éåŽ†å­˜å‚¨æ•°æ®çš„æ•°æ®ç»“æž„ï¼Œè¿™æ˜¯å…¶ä»–æŽ’åºç®—æ³•æ— æ³•è¾¾åˆ°çš„ã€‚ æ’å…¥æŽ’åºæ’å…¥æŽ’åºæœ‰ä¸ªå¾ˆå½¢è±¡çš„ä¾‹å­ï¼Œå°±æ˜¯æ‰“æ‰‘å…‹ç‰Œæ—¶â€œç†ç‰Œâ€çš„è¿‡ç¨‹ï¼Œä¸è¿‡å¯èƒ½æœ‰ç‚¹å·®åˆ«ã€‚åŒºåˆ«åœ¨äºŽï¼Œç†æ‰‘å…‹ç‰Œæ—¶ï¼Œæ‰‹ä¸Šæ˜¯æ²¡æœ‰ç‰Œçš„ï¼Œè€Œéœ€è¦ç†çš„ç‰Œåœ¨ç‰Œå †é‡Œé¢ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸¤ä¸ªç©ºé—´å¯ä»¥æ”¾ç‰Œï¼Œä½†æ’å…¥æŽ’åºå®žé™…ä¸Šåªä½¿ç”¨äº†ä¸€ä¸ªå†…å­˜ç©ºé—´ï¼Œè¿™æ ·çš„è¯ï¼Œæ¯ä¸€æ¬¡æ’å…¥æ—¶å°±éœ€è¦å…ˆæ‰¾åˆ°æ’å…¥çš„ä½ç½®äº†ã€‚æŒ‰ç…§â€œç†ç‰Œâ€çš„è¿‡ç¨‹æ¥æè¿°å°±æ˜¯ï¼šå…ˆæ‘¸ä¸€å¼ ç‰Œï¼Œä»ŽåŽå¾€å‰æ‰¾åˆ°åˆé€‚çš„æ’å…¥ä½ç½®ï¼Œå°†æ¯”è¿™å¼ ç‰Œå¤§çš„ç‰Œå‘åŽç§»ï¼ˆè…¾å‡ºä½ç½®ï¼‰ï¼Œå†å°†æ–°ç‰Œæ’å…¥åˆ°è¿™ä¸ªä½ç½®ä¸‹å³å¯ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Insertion_Sort(ElementType A[], int N) &#123; for(P=1; P&lt;N; p++) &#123; temp = A[P]; for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;temp; i--) &#123; A[i] = A[i-1]; &#125; A[i] = temp; &#125;&#125; æ’å…¥æŽ’åºå’Œå†’æ³¡æŽ’åºçš„æ—¶é—´å¤æ‚åº¦ç±»ä¼¼ï¼š æœ€å¥½çš„æƒ…å†µï¼Œåºåˆ—ä¸ºé¡ºåºåºåˆ—ï¼Œ$T = O(N)$ æœ€åçš„æƒ…å†µï¼Œåºåˆ—ä¸ºé€†åºåºåˆ—ï¼Œ$T = O(N^2)$ åŒæ—¶ï¼Œæ’å…¥æŽ’åºä¹Ÿæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ã€‚ æ—¶é—´å¤æ‚åº¦ä¸‹ç•Œ å¯¹äºŽä¸‹æ ‡$i &lt; j$ï¼Œå¦‚æžœ$A[i] &gt; A[j]$ï¼Œåˆ™ç§°$(i, j)$æ˜¯ä¸€å¯¹é€†åºå¯¹ï¼ˆInversionï¼‰å¦‚åºåˆ—${2, 3, 1}$ä¸­ï¼Œ$(2, 1)$å’Œ$(3, 1)$åˆ†åˆ«æ˜¯ä¸€å¯¹é€†åºå¯¹ï¼Œé€†åºå¯¹çš„ä¸ªæ•°ç§°ä¸ºé€†åºæ•°ï¼Œè¿™ä¸Žçº¿æ€§ä»£æ•°ä¸­çš„æ¦‚å¿µæ˜¯ä¸€è‡´çš„ã€‚ åœ¨å†’æ³¡æŽ’åºå’Œæ’å…¥æŽ’åºä¸­ï¼Œæ¯æ¬¡äº¤æ¢ä½ç½®çš„ä¸¤ä¸ªç›¸é‚»å…ƒç´ æ­£å¥½æ¶ˆåŽ» 1 ä¸ªé€†åºå¯¹ï¼Œé‚£ä¹ˆå®ƒä»¬çš„æ—¶é—´å¤æ‚åº¦å°±æ˜¯ï¼š$T(N, I) = O(N+I)$ï¼Œå…¶ä¸­$I$æ˜¯é€†åºå¯¹çš„å¯¹æ•°ã€‚å¾ˆæ˜Žæ˜¾ï¼Œå¦‚æžœåºåˆ—åŸºæœ¬æœ‰åºï¼Œåˆ™$I$å€¼å¯å¿½ç•¥ä¸è®¡ï¼Œæ—¶é—´å¤æ‚åº¦ä»…ä¸º$T(N)$ï¼Œæ­¤æ—¶ç®—æ³•æ—¢ç®€å•ï¼Œåˆé«˜æ•ˆã€‚ å®šç†ï¼šå¯¹äºŽä»»æ„Nä¸ªä¸åŒå…ƒç´ ç»„æˆçš„åºåˆ—å¹³å‡å…·æœ‰$N(N-1)/4$ä¸ªé€†åºå¯¹ã€‚ ç”±ä¸Šé¢çš„å®šç†ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼šä»»ä½•ä»…ä»¥äº¤æ¢ç›¸é‚»ä¸¤å…ƒç´ æ¥æŽ’åºçš„ç®—æ³•ï¼Œå…¶å¹³å‡æ—¶é—´å¤æ‚åº¦ä¸º$\Omega(N^2)$ã€‚è¿™æ„å‘³ç€ï¼Œå¦‚æžœæƒ³è¦æé«˜ç®—æ³•çš„æ•ˆçŽ‡ï¼Œå°±å¾—åœ¨æ¯æ¬¡äº¤æ¢å…ƒç´ æ—¶ï¼Œä¸æ­¢æ¶ˆåŽ» 1 ä¸ªé€†åºå¯¹ï¼Œè¿™å°±è¦æ±‚æ¯æ¬¡äº¤æ¢çš„ä¸¤ä¸ªå…ƒç´ è¦åœ¨åºåˆ—ä¸­ç›¸éš”çš„æ¯”è¾ƒè¿œã€‚ å¸Œå°”æŽ’åºå¸Œå°”æŽ’åºçš„ä¸»è¦ç›®çš„å°±æ˜¯æ¯æ¬¡äº¤æ¢å…ƒç´ æ—¶ï¼Œé€šè¿‡æ¶ˆåŽ»å¤šä¸ªé€†åºå¯¹æ¥è¾¾åˆ°æå‡ç®—æ³•æ•ˆçŽ‡ã€‚å…¶ä¸»è¦æ€æƒ³ï¼šå…ˆå®šä¹‰å¢žé‡åºåˆ—$D_M &gt; D_{M-1} &gt; \dots &gt; D_1 = 1$ï¼Œç„¶åŽå¯¹æ¯ä¸ª$D_k$è¿›è¡Œâ€œ$D_k$-é—´éš”â€æŽ’åºï¼ˆ$k=M, M-1, \dots,1$ï¼‰ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼ŒåŽé¢è¿›è¡Œçš„â€œé—´éš”â€æŽ’åºä¸ä¼šå½±å“å‰é¢â€œé—´éš”â€æŽ’åºçš„æœ‰åºæ€§ï¼Œä¹Ÿå³â€œ$D_k$-é—´éš”â€æœ‰åºçš„åºåˆ—ï¼Œåœ¨æ‰§è¡Œâ€œ$D_{k-1}$-é—´éš”â€æŽ’åºåŽï¼Œä»ç„¶æ˜¯â€œ$D_k$-é—´éš”â€æœ‰åºçš„ã€‚åŽŸå§‹å¸Œå°”æŽ’åºï¼Œå¢žé‡ä¾æ¬¡å‡åŠï¼Œ$D_M = \lfloor N/2 \rfloor, D_k = \lfloor D{k+1}/2 \rfloor$ï¼Œæ­¤æ—¶æœ€åæƒ…å†µä¸‹çš„æ—¶é—´å¤æ‚åº¦ä¸º$T = \Theta(N^2)$ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š1234567891011void Shell_Sort(ElementType A[], int N) &#123; for(D=N/2; D&gt;0; D/=2) &#123; for(P=D; P&lt;N; P++) &#123; temp = A[P]; for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;temp; i-=D) &#123; A[i] = A[i-D]; &#125; A[i] = temp; &#125; &#125;&#125; åœ¨æœ€åçš„æƒ…å†µï¼ˆæ¯æ¬¡è¿›è¡Œé—´éš”æŽ’åºçš„åºåˆ—éƒ½æ˜¯æœ‰åºçš„ï¼‰ä¸‹ï¼Œå¸Œå°”æŽ’åºä¼šé€€åŒ–æˆæ’å…¥æŽ’åºï¼ŒåŽŸå› åœ¨äºŽå¢žé‡å…ƒç´ ä¸äº’è´¨ï¼Œåˆ™å°å¢žé‡å¯èƒ½æ ¹æœ¬ä¸èµ·ä½œç”¨ã€‚ä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå¼•å…¥äº†æ›´å¤šçš„å¢žé‡åºåˆ—ï¼š Hibbardå¢žé‡åºåˆ—ï¼Œ$D_k = 2^k - 1$ï¼Œè¿™æ ·ä¿è¯äº†ç›¸é‚»å¢žé‡å…ƒç´ äº’è´¨ï¼Œæœ€åæƒ…å†µä¸‹$T = \Omega(N^{3/2})$ï¼ŒçŒœæƒ³$T_{avg} = O(N^{5/4})$ Sedgewickå¢žé‡åºåˆ—ï¼Œ${1, 5, 19, 41, 109, \dots}$ï¼Œä¹Ÿå³å¢žé‡åºåˆ—çš„æ¯ä¸€ä¸ªå…ƒç´ æ˜¯ç”±$9 \times 4^i + 1$æˆ–$4^i - 3 \times 2^i + 1$è®¡ç®—å¾—åˆ°ï¼ŒçŒœæƒ³$T_{avg} = O(N^{7/6}), T_{worst} = O(N^{4/3})$ ç”±äºŽå¸Œå°”æŽ’åºæ¯æ¬¡å¯¹å¢žé‡åºåˆ—è¿›è¡ŒæŽ’åºï¼Œç›¸é‚»çš„ç›¸ç­‰å…ƒç´ å±žäºŽä¸åŒå¢žé‡åºåˆ—ï¼Œåˆ™å¸Œå°”æŽ’åºå¯èƒ½ä¼šæ”¹å˜ç›¸ç­‰ä¸”ç›¸é‚»å…ƒç´ çš„ç›¸å¯¹ä½ç½®ï¼Œå±žäºŽä¸ç¨³å®šçš„æŽ’åºã€‚ é€‰æ‹©æŽ’åºé€‰æ‹©æŽ’åºæ˜¯ä¸€ç§ç®€å•ç›´è§‚çš„æŽ’åºç®—æ³•ï¼ŒåŸºæœ¬å·¥ä½œåŽŸç†æ˜¯æ¯ä¸€æ¬¡ä»Žå¾…æŽ’åºçš„æ•°æ®å…ƒç´ ä¸­é€‰å‡ºæœ€å°ï¼ˆå¤§ï¼‰çš„ä¸€ä¸ªå…ƒç´ ï¼Œå­˜æ”¾åœ¨åºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œç„¶åŽï¼Œå†ä»Žå‰©ä½™æœªæŽ’åºå…ƒç´ ä¸­ç»§ç»­å¯»æ‰¾æœ€å°ï¼ˆå¤§ï¼‰å…ƒç´ ï¼Œç„¶åŽæ”¾åˆ°å·²æŽ’åºåºåˆ—çš„æœ«å°¾ï¼Œé‡å¤æ­¤è¿‡ç¨‹ç›´åˆ°å…¨éƒ¨å¾…æŽ’åºçš„æ•°æ®å…ƒç´ æŽ’å®Œã€‚ ç®€å•é€‰æ‹©æŽ’åºç®€å•é€‰æ‹©æŽ’åºçš„æ€è·¯å¾ˆç®€å•ï¼Œä¸Žé€‰æ‹©æŽ’åºçš„åŸºæœ¬æ€æƒ³ä¸€è‡´ï¼ŒåŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678void Selection_Sort(ElementType A[], int N) &#123; for(i=0; i&lt;N; i++) &#123; //find the minimum from A[i] to A[n-1], and return to Position MinPosition = ScanForMin(A, i, N-1); //replace the minimum element to the last position of the ordered part Swap(A[i], A[MinPosition]); &#125;&#125; ç®€å•é€‰æ‹©æŽ’åºçš„æ—¶é—´å¤æ‚åº¦ä¸»è¦æœ‰ä¸¤ä¸ªå½±å“æ¡ä»¶ï¼Œç¬¬ä¸€ä¸ªæ˜¯æŸ¥æ‰¾æœ€å°å€¼ï¼Œç¬¬äºŒä¸ªæ˜¯äº¤æ¢ï¼Œæ‰€ä»¥å®ƒçš„æ—¶é—´å¤æ‚åº¦æ— è®ºæ€Žæ ·éƒ½æ˜¯$T=\Theta(N^2)$ã€‚ å †æŽ’åºåˆ†æžäº†ç®€å•é€‰æ‹©æŽ’åºç®—æ³•çš„æ—¶é—´å¤æ‚åº¦åŽï¼Œå‘çŽ°ç®€å•é€‰æ‹©æŽ’åºçš„æ—¶é—´éƒ½è€—è´¹åœ¨äº†æŸ¥æ‰¾æœ€å°å€¼ä¸Šï¼Œå¦‚æžœèƒ½æŠŠè¿™ä¸€æ“ä½œå˜å¿«ï¼Œé‚£ä¹ˆç®€å•é€‰æ‹©æŽ’åºçš„æ•ˆçŽ‡å°±èƒ½æé«˜ã€‚æ ¹æ®é€‰æ‹©æŽ’åºçš„ç‰¹ç‚¹ï¼Œæ¯æ¬¡æŸ¥æ‰¾çš„å€¼å¿…é¡»æ˜¯æœ€å°ï¼ˆå¤§ï¼‰å€¼ï¼Œè¿™ä¸Žå°ï¼ˆå¤§ï¼‰æ ¹å †çš„æ€§è´¨æ˜¯ä¸€è‡´çš„ï¼Œé‚£ä¹ˆä½¿ç”¨å †æ¥è¿›è¡Œå…ƒç´ çš„æŸ¥æ‰¾ï¼Œæ¯æ¬¡å¼¹å‡ºæœ€å°ï¼ˆå¤§ï¼‰å€¼ï¼Œå°±å¯ä»¥æå‡æŽ’åºæ•ˆçŽ‡ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void Heap_Sort(ElementType A[], int N) &#123; BuildHeap(A); for(i=0; i&lt;N; i++) &#123; tempA[i] = DeleteMin[A]; &#125; for(i=0; i&lt;N; i++) &#123; A[i] = tempA[i]; &#125;&#125; ä¸Šè¿°ä»£ç çš„è¿‡ç¨‹æ¯”è¾ƒç®€å•ï¼Œæ¯æ¬¡æ‰¾å‡ºæœ€å°ï¼ˆå¤§ï¼‰å…ƒç´ åŽï¼Œä¿å­˜åœ¨ä¸€ä¸ªä¸´æ—¶æ•°ç»„å†…ï¼Œç„¶åŽåœ¨å°†ä¸´æ—¶æ•°ç»„å†…çš„æŽ’åºç»“æžœå¤åˆ¶åˆ°åŽŸå§‹æ•°ç»„ä¸­ã€‚è¿™æ ·å³éœ€è¦é¢å¤–çš„ç©ºé—´ï¼ˆ$O(N)$ï¼‰åŽ»å­˜å‚¨è¿™éƒ¨åˆ†æ•°æ®ï¼Œåˆè¦é¢å¤–çš„æ—¶é—´åŽ»å¤åˆ¶å…ƒç´ ã€‚é‚£ä¹ˆå¦‚ä½•åŽ»é¿å…è¿™éƒ¨åˆ†å¼€é”€å‘¢ï¼Ÿè¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š 123456789void Heap_Sort(ElementType A[], int N) &#123; for(i=N/2; i&gt;=0; i--) &#123; PercDown(A, i, N); //Build heap &#125; for(i=N-1; i&gt;0; i--) &#123; Swap(&amp;A[0], &amp;A[i]); //delete max PercDown(A, 0, i); &#125;&#125; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œå»ºç«‹ä¸€ä¸ªå¤§æ ¹å †ï¼ŒæŽ’åºå¼€å§‹åŽï¼Œäº¤æ¢å¤§æ ¹å †æœ€å¤§å…ƒç´ ä¸Žæœ€æœ«å°¾å…ƒç´ çš„å€¼ï¼Œå®ŒæˆåŽï¼Œå°†è¿™ä¸ªæœ€å¤§å€¼å‰”é™¤å‡ºå †ï¼Œç´§æŽ¥ç€å†è°ƒæ•´ä¸ºå¤§æ ¹å †ï¼Œé‡å¤æ‰§è¡Œä¸Šè¿°æ“ä½œã€‚ å®šç†ï¼šå †æŽ’åºå¤„ç†Nä¸ªä¸åŒå…ƒç´ çš„éšæœºæŽ’åˆ—çš„å¹³å‡æ¯”è¾ƒæ¬¡æ•°æ˜¯$2NlogN - O(N log logN)$ è™½ç„¶å †æŽ’åºç»™å‡ºæœ€ä½³å¹³å‡æ—¶é—´å¤æ‚åº¦ï¼Œä½†å®žé™…æ•ˆæžœä¸å¦‚ç”¨Sedgewickå¢žé‡åºåˆ—çš„å¸Œå°”æŽ’åºã€‚ å½’å¹¶æŽ’åºå½’å¹¶æŽ’åºçš„æ ¸å¿ƒå°±æ˜¯æœ‰åºå­åˆ—çš„å½’å¹¶ï¼Œé¦–å…ˆï¼Œç”³è¯·ç©ºé—´ï¼Œä¿å­˜åˆå¹¶åŽçš„æœ‰åºåºåˆ—ï¼Œè®¾å®šä¸¤ä¸ªæŒ‡é’ˆï¼Œæœ€åˆä½ç½®åˆ†åˆ«ä¸ºä¸¤ä¸ªæœ‰åºåºåˆ—çš„èµ·å§‹ä½ç½®ï¼Œæ¯”è¾ƒä¸¤ä¸ªæŒ‡é’ˆæŒ‡å‘çš„å…ƒç´ ï¼Œé€‰æ‹©ç›¸å¯¹å°çš„å…ƒç´ æ”¾åˆ°ç”³è¯·çš„ç©ºé—´å†…ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆåˆ°ä¸‹ä¸€ä½ç½®ï¼Œé‡å¤ç›´è‡³æŸä¸€ä¸ªå­åºåˆ—è¶…å‡ºåºåˆ—å°¾ï¼ŒæŽ¥ç€å°†å¦ä¸€åºåˆ—å‰©ä¸‹çš„æ‰€æœ‰å…ƒç´ ç›´æŽ¥å¤åˆ¶åˆ°ç”³è¯·ç©ºé—´çš„å°¾éƒ¨ã€‚åˆå¹¶ä¸¤ä¸ªæœ‰åºå­åˆ—çš„åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516void Merge(ElementType A[], ElementType TempA[], int L, int R, int RightEnd) &#123; LeftEnd = R-1; //Suppose two subsequences are side-by-side Tmp = L; //initial position NumElements = RightEnd - L + 1; while(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd) &#123; if(A[L] &lt;= A[R]) TempA[Tmp++] = A[L++]; else TempA[Tmp++] = A[R++]; &#125; // copy the rest straightly while(L &lt;= LeftEnd) TempA[Tmp++] = A[L++]; while(R &lt;= RightEnd) TempA[Tmp++] = A[R++]; //copy the result to A[] from right to left for(i=0; i&lt;NumElements; i++, RightEnd--) &#123; A[RightEnd] = TempA[RightEnd] &#125;&#125; å½’å¹¶ç®—æ³•åœ¨å®žçŽ°çš„æ—¶å€™æœ‰ä¸¤ç§ä¸åŒçš„ç­–ç•¥ï¼Œä¸‹é¢å…ˆä»‹ç»é€’å½’ã€‚ é€’å½’å½’å¹¶æŽ’åºçš„é€’å½’ç®—æ³•çš„æ€æƒ³æ˜¯åŸºäºŽåˆ†æ²»æ³•çš„ï¼Œå…ˆå°†åˆ†å¼€çš„å­åºåˆ—æŽ’å¥½ï¼Œåœ¨åˆå¹¶æˆä¸€ä¸ªå¤§çš„åºåˆ—ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789void MSort(ElementType A[], ElementType TempA[], int L, int RightEnd) &#123; int Center; if(L &lt; RightEnd) &#123; Center = (L + RightEnd)/2; MSort(A, TempA, L, Center); MSort(A, TempA, Center+1, RightEnd); Merge(A, TempA, L, Center+1, RightEnd); &#125;&#125; åŸºäºŽåˆ†æ²»æ³•çš„å½’å¹¶æŽ’åºé€’å½’ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$T(NlogN)$ï¼ŒæŽ¨å¯¼è¿‡ç¨‹å¦‚ä¸‹ï¼š$$\begin{align} T(N)&amp; = 2 T(N/2)) + cN \\&amp; = 2\ (2T(N/2^2) + c N/2) + cN \\&amp; = \dots = 2^k * O(1) + ckN \\&amp; = O(NlogN)\end{align}$$å¯å¾—$T(N) = O(NlogN)$ï¼Œè¿™ä¸ªæ—¶é—´å¤æ‚åº¦æ˜¯å¾ˆâ€œå¼ºâ€çš„ðŸ˜†ï¼Œä¹Ÿå³æ˜¯è¯´åœ¨ä»»ä½•æƒ…å†µä¸‹ï¼ˆæ— è®ºå¥½åï¼‰éƒ½æ˜¯$NlogN$ï¼Œå¦å¤–ï¼Œå½’å¹¶æŽ’åºæ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ã€‚ä¸ºäº†ä½¿å®ƒä¸Žä¸Šè¿°å…¶ä»–æŽ’åºç®—æ³•çš„å‡½æ•°æŽ¥å£ç»Ÿä¸€ï¼Œå†æ•´ç†ä¸‹ä»£ç ï¼š12345678void Merge_Sort_Recursion(ElementType A[], int N) &#123; ElementType *TempA; TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; MSort(A, TempA, 0, N-1); free(TempA); &#125; else Error("Insufficient Space.");&#125; æ³¨æ„åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œä¸´æ—¶ä¼ é€’ä½¿ç”¨çš„æ•°ç»„æ˜¯å£°æ˜Žåœ¨Merge_Sortå‡½æ•°ä¸­çš„ï¼Œè¿™æ ·åšçš„å¥½å¤„å°±æ˜¯é¿å…äº†åœ¨MSortä¸­é‡å¤å£°æ˜Žå’Œé‡å¤é‡Šæ”¾å†…å­˜æ“ä½œã€‚ éžé€’å½’å½’å¹¶æŽ’åºçš„éžé€’å½’ç®—æ³•åŸºæœ¬æ€æƒ³ä¾ç„¶æ˜¯åˆ†æ²»æ³•çš„æ€æƒ³ï¼Œæ¯æ¬¡å¾ªçŽ¯å…ˆå½’å¹¶ç›¸é‚»çš„ä¸¤ä¸ªå­åˆ—ï¼Œå­åˆ—é•¿åº¦é€æ¸å¢žåŠ ï¼Œç›´è‡³æœ€åŽå·¦å³ä¸¤ä¸ªå­åˆ—ä¹‹å’Œå¤§äºŽåºåˆ—æ€»é•¿åº¦ã€‚åŸºæœ¬ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930void Merge_Sort_Non_Recursion(ElementType A[], int N) &#123; int length; ElementType *TempA; length = 1; //initialize the length of subsequence TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; while(length &lt; N) &#123; Merge_pass(A, TempA, N, length); //left length *= 2; Merge_pass(TempA, A, N, length); //right length *= 2; &#125; &#125; else printf("Insufficient Space.\n");&#125;/*Merge adjacent ordered subsequence in pairs accroding to the current length of subsequence*/void Merge_pass(ElementType A[], ElementType TempA[], int N, int length) &#123; int i, j; for(i=0; i&lt;=N-2*length; i+=length) &#123; Merge(A, TempA, i, i+length, i+2*length-1); &#125; if(i+length &lt; N) &#123; //Merge the last two subsequence Merge(A, TempA, i, i+length, N-1); &#125; else &#123; //only one subsequence last for(j=i; j&lt;N; j++) TempA[j] = A[j]; &#125;&#125; æ³¨æ„ä¸Šè¿°ä»£ç ä¸­çš„ç»†èŠ‚ï¼ŒMerge_passæ˜¯ä¸€ä¸ªæŒ‰ç…§åºåˆ—é•¿åº¦è¿›è¡Œä¸€æ¬¡å½’å¹¶çš„å‡½æ•°ï¼Œå½“åºåˆ—é•¿åº¦å‘ç”Ÿå˜åŒ–çš„æ—¶å€™ï¼Œå°†å†æ¬¡è°ƒç”¨æ­¤å‡½æ•°ï¼Œå¦å¤–ï¼Œåœ¨æ­¤å‡½æ•°å†…ï¼Œforå¾ªçŽ¯å†…å½’å¹¶çš„åºåˆ—æ˜¯å‰N/length - 1å¯¹ï¼Œè€Œä¸æ˜¯N/lengthå¯¹ï¼Œå¦‚æžœNæ˜¯å¥‡æ•°ï¼Œæœ€åŽä¸€ä¸ªå­åˆ—å°±è¢«å•ç‹¬å‡ºæ¥äº†ï¼Œå®ƒä¸Žå…¶ä»–å­åˆ—çš„é•¿åº¦ä¸ç­‰ï¼Œæ‰€ä»¥é’ˆå¯¹æœ€åŽä¸€ä¸ªå­åˆ—çš„å¤„ç†ï¼Œè¦ä¸Žå‰é¢åŒºåˆ†å¼€æ¥ã€‚å†è€…ï¼Œä¸Šè¿°ä»£ç ä¸­lengthå¢žé•¿çš„å€æ•°æ˜¯2ï¼Œç†è®ºä¸Šå³æ˜¯äºŒè·¯å½’å¹¶ã€‚ å°ç»“å½’å¹¶æŽ’åºç®—æ³•çš„ä¼˜ç‚¹å¾ˆæ˜Žæ˜¾ï¼Œé‚£å°±æ˜¯åœ¨ä»»ä½•æƒ…å†µï¼ˆæ— è®ºå¥½åï¼‰ä¸‹ï¼Œå…¶æ—¶é—´å¤æ‚åº¦éƒ½æ˜¯$T(NlogN)$ï¼ŒåŒæ—¶ï¼Œå®ƒè¿˜æ˜¯ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œä½†æ˜¯å®ƒæœ‰ä¸€ä¸ªå¾ˆæ˜Žæ˜¾çš„ç¼ºç‚¹ï¼Œå°±æ˜¯éœ€è¦å ç”¨$O(N)$å¤§å°çš„ç©ºé—´ï¼Œå¹¶ä¸”åœ¨å†…å­˜å†…è¦é¢‘ç¹çš„è¿›è¡Œå€’æ¢æ“ä½œï¼Œæ‰€ä»¥ï¼Œä¸€èˆ¬å†…éƒ¨æŽ’åºä¸­ä¸ä¼šä½¿ç”¨å½’å¹¶æŽ’åºï¼Œå¤–éƒ¨æŽ’åºä¼šä½¿ç”¨å½’å¹¶æŽ’åºã€‚ Homework09-1 æŽ’åºè¿™ä¸ªé¢˜ä¸“é—¨ç”¨æ¥æ£€æµ‹è‡ªå·±å®žçŽ°çš„æŽ’åºç®—æ³•ï¼Œæœ€å¥½æŠŠè€å¸ˆè®²äº†çš„éƒ½å®žçŽ°ä¸€ä¸‹ã€‚ å†’æ³¡æŽ’åº123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void bubble_sort(int *array, int n) &#123; for(int i = n - 1; i &gt; 0; i--) &#123; bool flag = true; for(int j = 0; j &lt; i; j++) &#123; if(array[j] &gt; array[j + 1])&#123; swap(&amp;array[j], &amp;array[j + 1]); flag = false; &#125; &#125; if(flag) break; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; bubble_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; ### æ’å…¥æŽ’åº123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å¸Œå°”æŽ’åº123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å †æŽ’åº12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; for(int i = n - 1; i &gt; 0; i--) &#123; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; heap_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; å½’å¹¶æŽ’åºéžé€’å½’123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; merge_pass(tmparr, array, n, length); length *= 2; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; é€’å½’12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void msort(int *array, int *tmparr, int left, int rightend) &#123; int center; if(left &lt; rightend) &#123; center = (left + rightend) / 2; msort(array, tmparr, left, center); msort(array, tmparr, center + 1, rightend); merge(array, tmparr, left, center + 1, rightend); &#125;&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; msort(array, tmparr, 0, n - 1); free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 09-2 Insert or Mergeè¿™ä¸ªé¢˜å½¢å¼ç®€å•ï¼Œä½†æ˜¯è¦æƒ³å¾—æ»¡åˆ†ï¼Œå¿…é¡»å¾—å¯¹æ’å…¥æŽ’åºè·Ÿå½’å¹¶æŽ’åºéƒ½å¾ˆäº†è§£æ‰è¡Œã€‚ é¢˜ç›®è¦æ±‚è¾“å‡ºä¸¤æ ·ä¸œè¥¿ï¼š åˆ¤æ–­å±žäºŽé‚£ä¸€ç§æŽ’åº ç„¶åŽè¾“å‡ºå†è¿›è¡Œä¸‹ä¸€æ¬¡è¿™ç§æŽ’åºåŽæ‰€å¾—çš„åºåˆ—123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; if(issame(tmparr)) &#123; merge_pass(tmparr, array, n, length); printarray(array, n); break; &#125; merge_pass(tmparr, array, n, length); length *= 2; if(issame(array)) &#123; merge_pass(array, tmparr, n, length); printarray(tmparr, n); break; &#125; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Merge Sort\n"); merge_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6out:Merge Sort1 2 3 8 4 5 7 9 0 6*/ 09-3 Insertion or Heap Sortè¿™ä¸ªé¢˜ä¸Žä¸Šé¢˜ç±»åž‹ä¸€è‡´ï¼Œåªä¸è¿‡æŠŠå½’å¹¶æŽ’åºæ¢æˆäº†å †æŽ’åºã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; int i; for(i = n - 1; i &gt; 0; i--) &#123; if(issame(array)) break; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); printarray(array, n);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Heap Sort\n"); heap_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9out:Heap Sort5 4 3 1 0 2 6 7 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_08-å›¾ï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F08%2F31%2FZJU-DS-08-%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[è¿™å‘¨è¯¾ç¨‹ä¸»è¦ä»‹ç»äº†å›¾çš„å¦å¤–ä¸¤ä¸ªåº”ç”¨ï¼šæœ€å°ç”Ÿæˆæ ‘å’Œæ‹“æ‰‘æŽ’åºï¼Œé¡ºå¸¦è®²äº†ä¸€ä¸‹å…³é”®è·¯å¾„ æœ€å°ç”Ÿæˆæ ‘ä»€ä¹ˆæ˜¯æœ€å°ç”Ÿæˆæ ‘ï¼ˆMinimum Spaning Treeï¼‰ï¼Ÿå®ƒé¦–å…ˆæ˜¯ä¸€æ£µæ ‘ï¼Œæ‰€ä»¥å®ƒæ²¡æœ‰å›žè·¯ï¼Œä¸” V ä¸ªé¡¶ç‚¹çš„æœ€å°ç”Ÿæˆæ ‘ä¸€å®šæœ‰ V-1 æ¡è¾¹ï¼ˆè¿™å°±æ˜¯æ ‘çš„æ€§å€¼ï¼‰ã€‚æ—¢ç„¶æ˜¯ç”Ÿæˆæ ‘ï¼Œæ‰€ä»¥è¿™æ£µæ ‘åŒ…å«äº†å›¾ä¸­æ‰€æœ‰é¡¶ç‚¹ï¼Œæ ‘ä¸­çš„ V-1 æ¡è¾¹ä¸€å®šä¹Ÿéƒ½åœ¨å›¾å†…ï¼›é‚£æœ€å°æ˜¯ä»€ä¹ˆï¼Ÿæœ€å°çš„å«ä¹‰æ˜¯æŒ‡è¾¹çš„æƒé‡å’Œæœ€å°ã€‚è¿™é‡Œè¦æ³¨æ„ï¼Œå¦‚æžœå›¾æ˜¯è¿žé€šçš„ï¼Œé‚£ä¹ˆè¿™ä¸ªå›¾ä¸€å®šå­˜åœ¨æœ€å°ç”Ÿæˆæ ‘ä¸”ä¸ä¸€å®šå”¯ä¸€ã€‚ ä¸‹é¢ä»‹ç»çš„ä¸¤ç§ç”Ÿæˆæœ€å°ç”Ÿæˆæ ‘çš„ç®—æ³•æœ¬è´¨æ€æƒ³éƒ½æ˜¯åŸºäºŽâ€œè´ªå¿ƒâ€ï¼Œè¿™ä¸Žå‰é¢çš„ Dijkstra ç®—æ³•æ˜¯ä¸€è‡´çš„ã€‚æ‰€è°“â€œè´ªå¿ƒâ€ï¼Œå³æ˜¯æŒ‡æ¯ä¸€æ­¥éƒ½è¦â€œæœ€å¥½â€çš„ï¼Œåœ¨æœ€å°ç”Ÿæˆæ ‘ä¸­ï¼Œæƒé‡æœ€å°çš„è¾¹ä¹Ÿå°±æ˜¯â€œæœ€å¥½â€çš„äº†ã€‚ Prim ç®—æ³•Prim ç®—æ³•çš„å¤§è‡´è¿‡ç¨‹ä»Žä¸€ä¸ªé¡¶ç‚¹å¼€å§‹ï¼Œæ…¢æ…¢çš„ç”Ÿé•¿æˆä¸€æ£µæ ‘ï¼Œå…ˆçœ‹ä¸‹å®ƒçš„ä¼ªç æè¿°ï¼š12345678910111213141516171819void Prim() &#123; MST = &#123;S&#125;; while(1) &#123; V = æœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…; if(V ä¸å­˜åœ¨) break; å°† V æ”¶å½•è¿› MST; dist[V] = 0; for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(dist[W] != 0) &#123; if( è¾¹æƒ(V,W) &lt; dist[W]) &#123; dist[W] = 0; parent[W] = V; &#125; &#125; &#125; &#125; if(MST ä¸­æ”¶å½•çš„é¡¶ç‚¹ä¸åˆ° |ï¼¶| ä¸ª) Error("ç”Ÿæˆæ ‘ä¸å­˜åœ¨");&#125; Prim ç®—æ³•ä¸Ž Dijkstra ç®—æ³•ååˆ†ç±»ä¼¼ï¼Œå°±æ˜¯å¾ªçŽ¯å†…çš„åˆ¤æ–­æ¡ä»¶ä¸ä¸€æ ·ï¼Œå…¶ä»–åŸºæœ¬ä¸€è‡´ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ Prim ç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ã€‚dist æ•°ç»„ç”¨æ¥ç­›é€‰è¾¹æƒæœ€å°çš„é¡¶ç‚¹ï¼›parent æ•°ç»„æ¥ä¿å­˜æ ‘ï¼Œä¸” parent æ•°ç»„éœ€è¦åˆå§‹åŒ–ä¸º -1ï¼Œè¿™é‡Œä¸Žå¹¶æŸ¥é›†çš„æ€è·¯æ˜¯ç±»ä¼¼çš„ã€‚ ä»¥$v_1$ä¸ºæºç‚¹ï¼Œdist æ•°ç»„åˆå§‹åŒ–ï¼š index 1 2 3 4 5 6 7 dist 0 âˆž âˆž âˆž âˆž âˆž âˆž parent -1 -1 -1 -1 -1 -1 -1 ç›´æŽ¥å°† dist[1] åˆå§‹åŒ–ä¸º 0ï¼Œç„¶åŽ$v_1$ä½œä¸ºæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…ï¼Œå°†å…¶æ”¶å½•è¿› MSTï¼Œå†è®¿é—®å…¶æ¯ä¸ªé‚»æŽ¥ç‚¹ï¼Œæ­¤æ—¶å¯ä»¥å°† dist æ•°ç»„çš„å€¼æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 2 4 1 âˆž âˆž âˆž parent -1 1 1 1 -1 -1 -1 æŽ¥ç€ï¼Œæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…å°±æ˜¯$v_4$ï¼Œæ”¶å½•è¿› MSTï¼Œæ­¤æ—¶ dist å’Œ parent æ•°ç»„æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 2 2 0 7 7 4 parent -1 1 4 1 4 4 4 å¯ä»¥çœ‹åˆ°ï¼Œå› ä¸º$(v_4, v_3) &lt; (v_1, v_3)$ï¼Œæ‰€ä»¥ dist[3] ä¸Ž parent[3] çš„å€¼å°†ä¼šå¾—åˆ°æ›´æ–°ã€‚ å†æ¥ï¼Œæœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…å°±æ˜¯$v_2$ï¼Œæ”¶å½•è¿› MSTï¼Œæ­¤æ—¶ dist å’Œ parent æ•°ç»„æ›´æ–°ï¼š index 1 2 3 4 5 6 7 dist 0 0 2 0 7 8 4 parent -1 1 4 1 4 4 4 ä¾æ¬¡ç±»æŽ¨ï¼Œæ”¶å½•$v_3$ï¼Œæœ‰ï¼š index 1 2 3 4 5 6 7 dist 0 0 0 0 7 5 4 parent -1 1 4 1 4 3 4 æ”¶å½•$v_7$ï¼Œæœ‰ï¼š index 1 2 3 4 5 6 7 dist 0 0 0 0 6 1 0 parent -1 1 4 1 7 7 4 æœ€åŽå†åˆ†åˆ«é€‰å–$v_6$å’Œ$v_5$åŽï¼ŒMST ä¸­æ”¶å½•çš„é¡¶ç‚¹è¾¾åˆ° |V| ä¸ªåŽå°±å¾—åˆ°äº†æœ€å°ç”Ÿæˆæ ‘ã€‚é€šè¿‡ä¸Šé¢ä¹Ÿå¯ä»¥çœ‹å‡ºï¼ŒPrim ä¸­çš„ dist æ•°ç»„çš„ç”¨é€”ä¸Ž Djikstra ç®—æ³•ä¸­ dist æ•°ç»„çš„ç”¨é€”æ˜¯å®Œå…¨ä¸€è‡´çš„ï¼Œåªæ˜¯ä¸¤è€…çš„åˆ¤æ–­æ¡ä»¶ä¸ä¸€æ ·è€Œå·²ã€‚å¦å¤–ï¼ŒPrim ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿå°±æ˜¯$O(|V|^3)$ã€‚ Kruskal ç®—æ³•Kruskal ç®—æ³•çš„å¤§è‡´è¿‡ç¨‹æ˜¯åœ¨â€œé€‰è¾¹â€ï¼Œä¹Ÿå°±æ˜¯å°†æ£®æž—åˆå¹¶æˆæ ‘ï¼Œå…¶ä¼ªç æè¿°ä¸ºï¼š123456789101112131415void Kruskal(Graph G) &#123; MST = &#123;&#125;; while(MST ä¸­æ‰¾ä¸åˆ° |V|-1 æ¡è¾¹ &amp;&amp; E ä¸­è¿˜æœ‰è¾¹) &#123; ä»Ž E ä¸­å–ä¸€æ¡æƒé‡æœ€å°çš„è¾¹ E(v, w); //ä½¿ç”¨æœ€å°å †å®žçŽ° å°†å–å‡ºçš„æœ€å°è¾¹ E(v, w)ä»Ž E ä¸­åˆ é™¤; if(E(v, w) ä¸åœ¨ MST ä¸­æž„æˆå›žè·¯) &#123; //ä½¿ç”¨å¹¶æŸ¥é›†å®žçŽ° å°† E(v, w)åŠ å…¥ MST; &#125; else &#123; å½»åº•æ— è§† E(v, w); &#125; &#125; if(MST ä¸­æ‰¾ä¸åˆ° |V|-1 æ¡è¾¹) &#123; Error("ç”Ÿæˆæ ‘ä¸å­˜åœ¨"); &#125;&#125; ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ Kruskal ç®—æ³•çš„è¿è¡Œè¿‡ç¨‹ã€‚ ä¾æ¬¡åŠ å…¥è¾¹$(v_1, v_4)$ã€$(v_6, v_7)$ã€$(v_1, v_2)$ã€$(v_3, v_4)$ã€$(v_4, v_7)$ã€$(v_5, v_7)$å³å¯ï¼Œæ•´ä¸ªè¿‡ç¨‹è®²èµ·æ¥æ¯” Prim ç®—æ³•ç®€å•äº†ä¸å°‘ï¼Œä½†æ˜¯å®žçŽ°èµ·æ¥å°±ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œæ—¢è¦ç”¨åˆ°æœ€å°å †ï¼Œåˆè¦ç”¨åˆ°å¹¶æŸ¥é›†ï¼Œä½†å…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿç¨å¾®ä¼˜ç§€ä¸€ç‚¹ï¼ˆç›¸æ¯” Primï¼‰ï¼Œä¸ºï¼š$O(|E|Log|E|)$ã€‚å¦å¤–ï¼Œç¬”è¯•é¢˜ä¸­ï¼ŒKruskal ç®—æ³•è§£é¢˜é€Ÿåº¦æ˜¯ç¬¬ä¸€åï¼Œè°ç”¨è°çŸ¥é“ã€‚ æ‹“æ‰‘æŽ’åºæ‹“æ‰‘æŽ’åºä¸åŒäºŽæ™®é€šæŽ’åºï¼Œæ™®é€šæŽ’åºå°±æ˜¯æŒ‰ç…§æŸä¸€è§„åˆ™å¯¹å…·æœ‰åŒç±»æ€§è´¨çš„å…ƒç´ è¿›è¡Œå‡åºæˆ–é™åºæŽ’åºï¼›è€Œæ‹“æ‰‘æŽ’åºæ˜¯é’ˆå¯¹æœ‰å‘æ— çŽ¯å›¾ï¼ˆDirected Acyclic Graphï¼ŒDAGï¼‰G è¿›è¡Œçš„ï¼Œæ˜¯å°†å›¾ G ä¸­æ‰€æœ‰é¡¶ç‚¹æŽ’æˆä¸€ä¸ªçº¿æ€§åºåˆ—ï¼Œä½¿å¾—å›¾ä¸­ä»»æ„ä¸€å¯¹é¡¶ç‚¹ u å’Œ vï¼Œè‹¥è¾¹ $&lt;u, v&gt;$æ˜¯å›¾ G çš„è¾¹ï¼ˆä¹Ÿå³å­˜åœ¨ä¸€æ¡ u åˆ° v çš„æœ‰å‘è·¯å¾„ï¼‰ï¼Œåˆ™ u åœ¨çº¿æ€§åºåˆ—ä¸­ä¸€å®šå‡ºçŽ°åœ¨ v ä¹‹å‰ï¼Œè¿™æ ·çš„åºåˆ—å«åšæ‹“æ‰‘åºåˆ—ï¼Œè€Œè¿™ä¸ªå¾—åˆ°è¿™ä¸ªåºåˆ—çš„è¿‡ç¨‹å°±å«åšæ‹“æ‰‘æŽ’åºã€‚ è€Œå§¥å§¥è®²çš„ AOV ç½‘ï¼Œå…·ä½“å®šä»¥è¯·ç‚¹å‡»é“¾æŽ¥å‚è€ƒä¸‹ç™¾åº¦ç™¾ç§‘ã€‚å¦å¤–ï¼Œå¯¹äºŽä¸€ä¸ª AOV ç½‘è€Œè¨€ï¼Œå¦‚æžœæœ‰åˆç†çš„æ‹“æ‰‘åºï¼Œåˆ™å…¶å¿…å®šæ˜¯æœ‰å‘æ— çŽ¯å›¾ã€‚æ¢å¥è¯è¯´ï¼Œä¹Ÿå°±æ˜¯è¯´æ‹“æ‰‘æŽ’åºå¯ä»¥ç”¨æ¥æ£€æµ‹å›¾å†…æ˜¯å¦æœ‰çŽ¯ï¼Œè¿™ä¹Ÿæ˜¯ç¬”è¯•é¢˜ä¸­å¸¸ç”¨çš„çŸ¥è¯†ç‚¹ã€‚ æ‹“æ‰‘æŽ’åºçš„ä¼ªç ç®—æ³•å¦‚ä¸‹ï¼š12345678910111213141516171819void TopSort() &#123; for(å›¾ä¸­æ¯ä¸ªé¡¶ç‚¹ V) &#123; if(Indegree[V] == 0) &#123; Enqueue(V, Q); &#125; &#125; while(!IsEmpty(Q)) &#123; V = Dequeue(Q); è¾“å‡ºVï¼Œæˆ–è€…è®°å½• V çš„è¾“å‡ºåºå·; cnt++; for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(--Indegree[W] == 0) &#123; Enqueue(W, Q); &#125; &#125; &#125; if(cnt != |V|) &#123; Error("å›¾ä¸­æœ‰å›žè·¯"); &#125;&#125; å…³é”®è·¯å¾„å…³é”®è·¯å¾„é—®é¢˜æ˜¯é’ˆå¯¹ AOEï¼ˆActivity On Edgeï¼‰ç½‘ç»œè€Œè¨€çš„ï¼Œå±žäºŽæ‹“æ‰‘æŽ’åºçš„åº”ç”¨ï¼Œä¸€èˆ¬ç”¨äºŽå®‰æŽ’é¡¹ç›®çš„å·¥åºé—®é¢˜ï¼Œå›¾ä¸­çš„è¾¹ä»£è¡¨å·¥åºï¼Œå·¥åºä¸Žå·¥åºä¹‹é—´æœ‰å…ˆåŽå…³ç³»ã€‚ä¹Ÿå¯ä»¥ç†è§£ä¸ºè¾¹ä»£è¡¨æ´»åŠ¨ï¼Œé¡¶ç‚¹è¡¨ç¤ºè¿™ä¸ªæ´»åŠ¨çš„ç»“æŸï¼ŒæŒ‰ç…§å§¥å§¥ PPT ä¸­çš„ä»‹ç»æ¥ç†è§£å³å¯ï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºï¼š æŽ¥ç€è·Ÿç€å§¥å§¥çš„ PPT ä¸€èµ·æ‰‹åŠ¨è®¡ç®—å…³é”®è·¯å¾„ï¼Œå¯ä»¥å¾—åˆ°ä¸‹å›¾çš„ç»“æžœã€‚ åœ¨ä¸Šé¢çš„é—®é¢˜ä¸­ï¼Œæ³¨æ„å¯¹é‚£æ¡â€œè™šè¾¹â€çš„ç†è§£ï¼Œä¹‹æ‰€ä»¥ä¼šæœ‰è¿™æ¡è™šè¾¹ï¼Œå…¶å®žæ˜¯å› ä¸ºè¦æƒ³åˆ°è¾¾é¡¶ç‚¹ 7ï¼Œå¿…é¡»è¦å…ˆåˆ°è¾¾é¡¶ç‚¹ 4 å’Œ 5ã€‚å¯èƒ½æœ‰äººä¼šé—®ä¸ºä»€ä¹ˆæ˜¯ä»Ž 5 æŒ‡å‘ 4ï¼Œå¾ˆç®€å•ï¼Œå› ä¸º 4 åŽåˆ°è¾¾ï¼Œ5 ä¼šå…ˆåˆ°è¾¾ï¼Œå¦‚æžœ 5 åŽåˆ°è¾¾ï¼Œ4 å…ˆåˆ°è¾¾ï¼Œé‚£å°±æ˜¯ 4 æŒ‡å‘ 5 äº†ã€‚ å¦å¤–éœ€è¦æ³¨æ„çš„å°±æ˜¯æœºåŠ¨æ—¶é—´çš„è®¡ç®—ï¼Œè¿˜æ˜¯è¦å…ˆç†è§£æœºåŠ¨æ—¶é—´çš„æ¦‚å¿µã€‚æœºåŠ¨æ—¶é—´è¿™ä¸ªä¸œè¥¿ï¼Œå®žé™…ä¸Šå°±æ˜¯å¯ä»¥å·æ‡’çš„æ—¶é—´ï¼ŒåŽå®Œæˆçš„äººä¸èƒ½å·æ‡’ï¼Œä½†å…ˆå®Œæˆçš„äººå°±å¯ä»¥å·æ‡’äº†ã€‚ä»¥é¡¶ç‚¹ 5 ä¸ºä¾‹ï¼Œå®ƒçš„æœºåŠ¨æ—¶é—´å°±æ˜¯ï¼š$D_{&lt;5, 7&gt;} = Latest[7] - Earliest[i] - C_{&lt;5, 7&gt;} = 14 - 7 - 4 = 3$ã€‚ä¼šç®—è¿™äº›ä¸œè¥¿åŽï¼Œå°±å¯ä»¥æ‰¾å‡ºå…³é”®è·¯å¾„äº†ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯å¯¹ä¸€ä¸ª AOE ç½‘è€Œè¨€ï¼Œå…³é”®è·¯å¾„ä¸ä¸€å®šæ˜¯å”¯ä¸€çš„ï¼Œè¿™ä¸ªä»Žä¸Šå›¾å°±å¯ä»¥çœ‹å‡ºã€‚ Homework08-7 å…¬è·¯æ‘æ‘é€šå¾ˆç›´è§‚çš„æœ€å°ç”Ÿæˆæ ‘é—®é¢˜ï¼Œä¸€é Prim ç®—æ³•å°±æžå®šäº†ï¼Œå¦‚æžœä¸è¿žé€šå°±è¾“å‡º -1ï¼Œåä¹‹å°±è¾“å‡ºæœ€å°ç”Ÿæˆæ ‘çš„è¾¹æƒä¹‹å’Œï¼Œä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt; #define maxn 1005const int inf = 0x3fffffff;int nv, ne, G[maxn][maxn], dist[maxn];bool visited[maxn] = &#123; false &#125;;void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; for (int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void prim() &#123; for (int i = 0; i &lt; maxn; i++) dist[i] = inf; dist[1] = 0; int times = 0, totalweight = 0; while(1) &#123; int mindis = inf, v = -1; for (int i = 1; i &lt;= nv; i++) &#123; if (!visited[i] &amp;&amp; dist[i] &lt; mindis) &#123; mindis = dist[i]; v = i; &#125; &#125; if (v == -1) break; times++; visited[v] = true; totalweight += dist[v]; for (int w = 1; w &lt;= nv; w++) &#123; if (G[v][w] != inf &amp;&amp; !visited[w] &amp;&amp; G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; if (times == nv) printf("%d", totalweight); else printf("-1");&#125;int main() &#123; scanf("%d %d", &amp;nv, &amp;ne); init(); int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; scanf("%d %d %d", &amp;v1, &amp;v2, &amp;weight); G[v1][v2] = G[v2][v1] = weight; &#125; prim(); return 0;&#125;/*samples:in:6 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3out:12*/ 08-8 How Long Does It Takeè¿™é“é¢˜è™½ç„¶æ˜¯è‹±æ–‡çš„ï¼Œä½†æ˜¯é¢˜æ„å¾ˆç›´è§‚ï¼Œå°±æ˜¯ç›´æŽ¥æ±‚å…³é”®è·¯å¾„çš„æœ€æ—©å®Œæˆæ—¶é—´ï¼Œä½†å®žé™…ä¸Šå¹¶æ²¡æœ‰è¦æ±‚ä¹Ÿè¦è¾“å‡ºå…³é”®è·¯å¾„ï¼Œå‡å°‘äº†ç‚¹éº»çƒ¦å§ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯å°±æ˜¯åˆ©ç”¨å…ˆæ‹“æ‰‘æŽ’åºï¼Œå¾—åˆ°ä¸€ä¸ªæ‹“æ‰‘åºåˆ—ï¼Œç„¶åŽé€šè¿‡è¿™ä¸ªæ‹“æ‰‘åºåˆ—æ¥å…³é”®è·¯å¾„çš„æœ€æ—©å®Œæˆæ—¶é—´ã€‚æˆ‘ä»¬ä½¿ç”¨ STL æ¥å·ä¸‹æ‡’ï¼Œå°† Vector å½“ä½œé‚»æŽ¥è¡¨æ¥å­˜å‚¨å›¾ï¼Œåˆ©ç”¨ Vector å†…çš„æˆå‘˜å‡½æ•° emplace_backï¼ˆC++11 çš„æ–°ç‰¹æ€§ï¼‰æ¥è¾“å…¥é¡¶ç‚¹å’Œå¯¹åº”çš„è¾¹æƒè¦æ–¹ä¾¿ä¸€äº›ï¼Œä½†è¦è¿™æ ·ç”¨å¾—å…ˆå†™å¥½ node çš„æž„é€ å‡½æ•°ã€‚åœ¨è¿›è¡Œæ‹“æ‰‘æŽ’åºæ—¶ï¼Œå¯ä»¥é¡ºä¾¿å°†æœ€æ—©å®Œæˆæ—¶é—´ä¹Ÿä¸€å¹¶è®¡ç®—å‡ºæ¥ã€‚ä¸ºäº†é¿å…å›¾å¯èƒ½ä¸æ˜¯è¿žé€šçš„ï¼Œä¹Ÿå°±æ˜¯è¯´æ­¤æ—¶æ˜¯æ— è§£çš„ï¼Œéœ€è¦è®¾ç½®ä¸€ä¸ªè®¡æ•°å™¨æ¥è®°å½•æ‰€å¾—åˆ°çš„æ‹“æ‰‘åºåˆ—çš„é¡¶ç‚¹ä¸ªæ•°ï¼Œå¦‚æžœä¸Žå›¾çš„é¡¶ç‚¹æ€»æ•°ä¸ç›¸ç­‰ï¼Œé‚£ä¹Ÿå°±æ˜¯è¯´å›¾æ˜¯ä¸è¿žé€šçš„ã€‚å…·ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node&#123; int w, weight; node(int w, int weight) &#123; this-&gt;w = w; this-&gt;weight = weight; &#125;&#125;;vector&lt;node&gt; G[maxn];int nv, ne, indegree[maxn] = &#123; 0 &#125;, cost[maxn];void topsort() &#123; queue&lt;int&gt; q; for (int v = 0; v &lt; nv; v++) &#123; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]++; &#125; &#125; for (int i = 0; i &lt; maxn; i++) cost[i] = -1; int count = 0; for (int i = 0; i &lt; nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); cost[i] = 0; &#125; &#125; while (!q.empty()) &#123; int v = q.front(); q.pop(); count++; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]--; if (cost[G[v][w].w] &lt; cost[v] + G[v][w].weight) &#123; cost[G[v][w].w] = cost[v] + G[v][w].weight; &#125; if (indegree[G[v][w].w] == 0) &#123; q.push(G[v][w].w); &#125; &#125; &#125; if (count != nv) cout &lt;&lt; "Impossible"; else &#123; int max = cost[0]; for (int i = 1; i &lt; nv; i++) &#123; if (max &lt; cost[i]) max = cost[i]; &#125; cout &lt;&lt; max; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight; G[v1].emplace_back(v2, weight); &#125; topsort(); return 0;&#125;/*samples:in:9 120 1 60 2 40 3 51 4 12 4 13 5 25 4 04 6 94 7 75 7 46 8 27 8 4out:18in:4 50 1 10 2 22 1 31 3 43 2 5out:Impossiblein:7 60 3 23 4 21 2 32 4 24 5 34 6 2out:8*/ 08-9 å…³é”®æ´»åŠ¨è¿™é“é¢˜æ²¡å•¥è¯´çš„ï¼Œå°±æ˜¯å…³é”®è·¯å¾„çš„é—®é¢˜ã€‚ç›¸æ¯”ä¸Šé“é¢˜ï¼Œè¿™é“é¢˜è¦éº»çƒ¦ä¸€äº›ï¼Œå› ä¸ºè¿™ä¸ªé¢˜ä¸ä»…è¦è¾“å‡ºæœ€æ—©å®Œæˆæ—¶é—´ï¼Œè¿˜å¾—è¾“å‡ºå…³é”®è·¯å¾„ï¼Œå¤šäºäº† STL çœäº†å¾ˆå¤šéº»çƒ¦ã€‚æ±‚æœ€æ—©å®Œæˆæ—¶é—´çš„æ€è·¯ä¸Žä¸Šé¢é‚£é¢˜æ˜¯ä¸€æ ·çš„ï¼Œç›´æŽ¥ä¸€ä¸ªæ‹“æ‰‘æŽ’åºå°±å®Œäº‹äº†ã€‚éš¾ç‚¹åœ¨äºŽå¦‚ä½•æ‰¾å…³é”®è·¯å¾„ï¼Œä¸èƒ½ç®€å•çš„ç›´æŽ¥æ‹¿æ‹“æ‰‘åºåˆ—æ¥åå‘è¾“å‡ºï¼Œé‚£æ€Žä¹ˆåŠžå‘¢ï¼Ÿä»”ç»†å›žå¿†ä¸€ä¸‹è¯¾ä¸Šçš„ä¾‹å­ï¼Œå¯ä»¥å‘çŽ°å…³é”®è·¯å¾„çš„å…³é”®æ´»åŠ¨æ²¡æœ‰ç©ºä½™æ—¶é—´ï¼Œå‡å¦‚ e æ˜¯æ´»åŠ¨çš„æœ€æ—©å®Œæˆæ—¶é—´ï¼Œl æ˜¯æ´»åŠ¨çš„æœ€æ™šå¼€å§‹æ—¶é—´ï¼Œé‚£ä¹ˆå…³é”®æ´»åŠ¨çš„ e ä¸Ž l æ˜¯ç›¸ç­‰ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå°†æ‹“æ‰‘åºåˆ—ä¸­çš„æ‰€æœ‰çš„å…³é”®æ´»åŠ¨çš„ e å’Œ l æ±‚å‡ºï¼Œå¹¶è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœç›¸ç­‰ï¼Œå°±æ˜¯å…³é”®æ´»åŠ¨äº†ï¼Œå½“ç„¶äº†ï¼Œå‰ææ˜¯æ‹“æ‰‘åºåˆ—æ˜¯å­˜åœ¨çš„ã€‚ä½†æ˜¯åˆ«å¿˜è®°äº†ï¼Œé¢˜ç›®è¦æ±‚ä»Žå°åˆ°å¤§è¾“å‡ºå…³é”®æ´»åŠ¨ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹æ‰¾å‡ºçš„åºåˆ—è¿›è¡ŒæŽ’åºï¼Œç„¶åŽå†è¾“å‡ºã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node &#123; int v, w; node(int v, int w) &#123; this-&gt;v = v; this-&gt;w = w; &#125;&#125;;bool cmp(int a, int b) &#123; return b - a;&#125;vector&lt;node&gt; G[maxn];stack&lt;int&gt; topo;int nv, ne, ve[maxn] = &#123; 0 &#125;, vl[maxn], indegree[maxn] = &#123; 0 &#125;;bool topoorder() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= nv; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; indegree[G[i][j].v]++; &#125; &#125; for (int i = 1; i &lt;= nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); ve[i] = 0; &#125; &#125; while (!q.empty()) &#123; int u = q.front(); topo.push(u); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; indegree[G[u][i].v]--; if (ve[G[u][i].v] &lt; ve[u] + G[u][i].w) &#123; ve[G[u][i].v] = ve[u] + G[u][i].w; &#125; if (indegree[G[u][i].v] == 0) q.push(G[u][i].v); &#125; &#125; if (topo.size() != nv) return false; else return true;&#125;void criticalpath() &#123; int max = ve[1], maxid = 1; for (int i = 2; i &lt;= nv; i++) &#123; if (ve[i] &gt; max) &#123; max = ve[i]; maxid = i; &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; for (int i = 0; i &lt; maxn; i++) vl[i] = max; while (!topo.empty()) &#123; int u = topo.top(); topo.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v; if (vl[v] - G[u][i].w &lt; vl[u]) &#123; vl[u] = vl[v] - G[u][i].w; &#125; &#125; &#125; vector&lt;int&gt; keyact[maxn]; for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v, w = G[u][i].w; int e = ve[u], l = vl[v] - w; if (e == l) keyact[u].push_back(v); &#125; &#125; for (int i = 1; i &lt;= nv; i++) sort(keyact[i].begin(), keyact[i].end(), cmp); for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; keyact[u].size(); i++) &#123; cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; keyact[u][i] &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int u, v, w; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].emplace_back(v, w); &#125; if (!topoorder()) cout &lt;&lt; 0; else criticalpath(); return 0;&#125;/*samples:in:7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2out:171-&gt;22-&gt;44-&gt;66-&gt;7in:4 41 2 21 3 22 4 23 4 2out:41-&gt;31-&gt;22-&gt;43-&gt;4in:3 31 2 12 3 13 1 1out:0in:3 31 2 11 3 12 3 1out:21-&gt;22-&gt;3*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prologueï¼ˆãƒ—ãƒ­ãƒ­ãƒ¼ã‚° - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼ï¼‰- ç¿»å¼¹]]></title>
    <url>%2F2020%2F08%2F29%2FPrologue%EF%BC%88%E3%83%97%E3%83%AD%E3%83%AD%E3%83%BC%E3%82%B0%20-%20%E6%8A%BC%E5%B0%BE%E3%82%B3%E3%83%BC%E3%82%BF%E3%83%AD%E3%83%BC%EF%BC%89-%20%E7%BF%BB%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Prologueï¼ˆãƒ—ãƒ­ãƒ­ãƒ¼ã‚° - æŠ¼å°¾ã‚³ãƒ¼ã‚¿ãƒ­ãƒ¼ï¼‰æ˜¯æŠ¼å°¾äºŽ 2003 å¹´å‘è¡Œçš„ä¸“è¾‘ã€ŠDramaticã€‹ä¸­çš„ä¸€é¦–è¾ƒä¸ºç®€å•çš„æŒ‡å¼¹æ›²å­ã€‚ è°±å­ä¸€å…±å°±ä¸¤é¡µï¼Œä¸é•¿ï¼Œä½†æ˜¯ç¼–çš„çœŸå¥½ï¼Œæƒ³è¦å®Œæ•´çš„å¼¹ä¸‹æ¥è¿˜å¾—è´¹ä¸€ç•ªåŠŸå¤«ã€‚å…ˆçœ‹ä¸‹åŽŸç‰ˆè°±å­ç¬¬ 1 é¢ï¼ˆæ‰«æä»¶ï¼Œç”»è´¨ç•¥å·®è§è°…ï¼‰ï¼š è°±å­äº”çº¿è°±çš„å·¦ä¸Šè§’å†™ç€ Tuning = Standardï¼Œè¯´æ˜Žè¿™æ˜¯é¦–æ ‡å‡†è°ƒå¼¦çš„æ›²å­ï¼›äº”çº¿è°±çš„å¼€å¤´æœ‰ä¸€ä¸ªé«˜éŸ³è°±å·å’Œä¸€ä¸ªâ€œ#â€å·è¡¨ç¤ºè¿™é¦–æ›²å­æ˜¯ G å¤§è°ƒçš„ï¼›è¾¹ä¸Šçš„$\frac{6}{8}$ï¼Œè¡¨ç¤ºè¿™é¦–æ›²å­çš„èŠ‚æ‹æ˜¯å…«å…­æ‹ï¼›è°±å·ä¸Šè¿˜æœ‰ä¸€ä¸ªå¸¦æ–¹æ¡†çš„ç¼©å†™çš„è‹±æ–‡å•è¯ Introï¼Œè¡¨ç¤ºå‰ä¸¤å°èŠ‚æ˜¯è¿™é¦–æ›²å­çš„å¼•å­ï¼ˆå°±åƒæŸäº›å°è¯´å¼€å¤´çš„å¼•å­ä¸€æ ·ï¼‰ï¼›ç´§æŽ¥ç€è¾¹ä¸Šçš„ G è¡¨ç¤ºè¿™ä¿©å°èŠ‚çš„å’Œå¼¦èµ°å‘æ˜¯ Gï¼›è¿˜æœ‰åŽé¢å¸¦æ–¹æ¡†çš„è‹±æ–‡åˆ†åˆ«ä»£è¡¨è¿™é¦–æ›²å­çš„ A æ®µã€B æ®µã€C æ®µç­‰ã€‚ å»ºè®®åªçœ‹å…­çº¿è°±çš„ä¹Ÿä¸è¦å¿½ç•¥ä¸Šé¢çš„å†…å®¹ã€‚ A æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬äºŒå°èŠ‚äº”çº¿è°±ä¸Šçš„æ•°å­—ä»£è¡¨äº†å·¦æ‰‹çš„æŒ‡æ³•ï¼Œä½†å®žé™…ä¸Šä½ å¯ä»¥æŒ‰ç…§è‡ªå·±ç†Ÿç»ƒçš„æ–¹å¼æ¥æ¼”å¥ï¼›å¦å¤–ï¼ŒS æ ‡è®°ä»£è¡¨ä»Ž 2 å¼¦ 3 å“ç”¨æ»‘éŸ³æ¼”å¥æ³•æ»‘åˆ° 10 å“ï¼Œä¸ºäº†è¾¾åˆ°è·ŸåŽŸæ›²çš„æ•ˆæžœï¼Œæ»‘åˆ° 10 å“åŽï¼Œéœ€è¦åœ¨å¼¹ä¸€æ¬¡ 2 å¼¦ 10 å“ç¬¬å››å°èŠ‚å³æ‰‹ä¸­æŒ‡ä¸Žæ— åæŒ‡éœ€è¦åŒæ—¶å¼¹å“ 1ã€2å¼¦ï¼Œç”¨æ»‘éŸ³å¬èµ·æ¥ä¼šæ›´æ£’ç¬¬äº”å°èŠ‚å·¦æ‰‹ä¸­æŒ‡ä¸Žå°æŒ‡éœ€è¦é¦–å…ˆåŒæ—¶æŒ‰ä½ 6 å¼¦ 8 å“å’Œ 3 å¼¦ 9 å“ç¬¬å…­å°èŠ‚å·¦æ‰‹é£ŸæŒ‡éœ€è¦æ¨ªæŒ‰ï¼Œä½†é£ŸæŒ‡æ¨ªæŒ‰çš„éŸ³å¯ä»¥â€œå¼±å¤„ç†â€ æŽ¥ä¸‹æ¥å°±åˆ° B æ®µäº†ï¼Œä¸ªäººæ„Ÿè§‰ B æ®µç®€å•ä¸€äº›ï¼ŒåŽé¢å‡ ä¸ªå°èŠ‚åœ¨è°±å­çš„ç¬¬äºŒé¢ï¼š B æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬ä¸ƒå°èŠ‚ 1 å¼¦çš„å¤„ç†æ–¹å¼å¯ä»¥ä¸Ž A æ®µç¬¬äºŒå°èŠ‚ç±»ä¼¼ç¬¬å…«å°èŠ‚é£ŸæŒ‡å°æ¨ªæŒ‰ 1-4 å¼¦ 5 å“ æŽ¥ç€æ˜¯ C æ®µéœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ç¬¬äºŒå°èŠ‚éœ€è¦å·¦æ‰‹æœ‰ä¸€å®šçš„â€œåŠ›é‡â€æ‰èƒ½æŒ‰å¥½æ•´ä¸ª C æ®µæœ‰å¤šå¤„éœ€è¦ç”¨ç¶éŸ³æŠ€å·§ï¼Œæ‰èƒ½æ›´å¥½çš„è¡¨è¾¾æ›²å­æƒ…æ„Ÿçš„å˜åŒ–C æ®µå±žäºŽç»“å°¾æ®µï¼ŒåŒ…æ‹¬ä¸¤ä¸ªç»“å°¾éƒ¨åˆ†ï¼Œè°±å­ä¸Šæœ‰æ ‡è®° 1 å’Œ 2ï¼Œæ³¨æ„åŒºåˆ† åŽŸæ›²ï¼š æ¸£ç¿»ï¼ˆè¿˜åœ¨é…é…¿ä¹‹ä¸­ï¼‰ï¼š]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>FingerStyle</tag>
        <tag>Guitar</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_07-å›¾ï¼ˆä¸­ï¼‰]]></title>
    <url>%2F2020%2F08%2F28%2FZJU-DS-07-%E5%9B%BE%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬å‘¨è¯¾ç¨‹ä¸»è¦åŒ…æ‹¬å›¾è®ºä¸­æœ€çŸ­è·¯å¾„çš„é—®é¢˜å’Œæœ‰å…³æ ‘çš„ä¹ é¢˜è¯¾ï¼Œä¹ é¢˜è¯¾ç¬”è®°æ·»åŠ åˆ°å‰é¢å¯¹åº”é¢˜ç›®çš„æ‰€åœ¨çš„æ–‡ç« ä¸­äº†ã€‚ æœ€çŸ­è·¯å¾„é—®é¢˜çš„æŠ½è±¡ä¸€èˆ¬è€Œè¨€ï¼Œæœ€çŸ­è·¯å¾„é—®é¢˜éƒ½å¯æŠ½è±¡ä¸ºï¼šåœ¨ç½‘ç»œä¸­ï¼Œæ±‚ä¸¤ä¸ªä¸åŒé¡¶ç‚¹ä¹‹é—´çš„æ‰€æœ‰è·¯å¾„ä¸­ï¼Œè¾¹çš„æƒå€¼ä¹‹å’Œæœ€å°çš„é‚£ä¸€æ¡è·¯å¾„ï¼Œä»Žè€Œï¼Œæœ‰ï¼š è¿™æ¡è·¯å¾„å°±æ˜¯ä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·¯å¾„ï¼ˆShortest Pathï¼‰ ç¬¬ä¸€ä¸ªé¡¶ç‚¹ä¸ºæºç‚¹ï¼ˆSourceï¼‰ æœ€åŽä¸€ä¸ªé¡¶ç‚¹ä¸ºç»ˆç‚¹ï¼ˆDestinationï¼‰ æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œæœ€çŸ­è·¯å¾„é—®é¢˜åˆå¯ä»¥åˆ†åˆ«ä¸¤ç±»ï¼š å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼šä»ŽæŸå›ºå®šæºç‚¹å‡ºå‘ï¼Œæ±‚å…¶åˆ°æ‰€æœ‰å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œæ ¹æ®å›¾çš„ç±»åž‹ä¸åŒåˆå¯ä»¥åˆ†ä¸ºï¼š ï¼ˆæœ‰å‘ï¼‰æ— æƒå›¾ ï¼ˆæœ‰å‘ï¼‰æœ‰æƒå›¾ å¤šæºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼šæ±‚ä»»æ„ä¸¤é¡¶ç‚¹é—´çš„æœ€çŸ­è·¯å¾„ æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•è€ƒè™‘è¿™ç±»é—®é¢˜æ—¶ï¼Œæœ‰ä¸€ä¸ªåŽŸåˆ™ï¼Œå³ï¼šæŒ‰ç…§é€’å¢žï¼ˆéžé€’å‡ï¼‰çš„é¡ºåºæ‰¾å‡ºå„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯ã€‚ä»¥ä¸‹å›¾ä¸­çš„â€œå›¾â€ä¸ºä¾‹ï¼š æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜æœ¬è´¨ä¸Šå°±æ˜¯ BFSï¼Œå‡è®¾æºç‚¹ä¸º$v_3$ï¼ŒæŒ‰ç…§ BFS çš„æ€è·¯ï¼Œé€šè¿‡$v_3$å¯ä»¥ç›´æŽ¥è®¿é—®$v_1$å’Œ$v_2$ï¼Œè¿™ç®—æ˜¯ä¸Ž$v_3$çš„è·ç¦»ä¸º 1 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹ï¼Œä¾æ¬¡ç±»æŽ¨ï¼Œä¸Ž$V_3$è·ç¦»ä¸º 2 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹å°±æ˜¯$v_2$å’Œ$v_4$ï¼Œä¸Ž$v_3$è·ç¦»ä¸º 3 æ‰€èƒ½è®¿é—®çš„é¡¶ç‚¹å°±æ˜¯$v_5$å’Œ$v_7$ã€‚ æŽ¥ç€åœ¨æŒ‰ç…§ BFS ç®—æ³•å†™å‡ºå…¶ä¼ªç ç®—æ³•ï¼š12345678910111213void Unweighted(Vertex S) &#123; Enqueue(S, Q); while(!IsEmpty(Q)) &#123; V = Dequeue(Q); for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(dist[W] == -1) &#123; dist[W] = dist[V] + 1; path[W] = V; Enqueue(W, Q); &#125; &#125; &#125;&#125; ä¸Ž BFS ç®—æ³•ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œç”¨ dist æ•°ç»„æ¥ä¿å­˜æºç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„è·ç¦»ï¼Œç”¨ path æ•°ç»„ä¿å­˜äº†æºç‚¹åˆ°å„ä¸ªé¡¶ç‚¹çš„è·¯å¾„ã€‚è¿™é‡Œå¤šè¯´ä¸€å¥ï¼Œè‹¥æƒ³çŸ¥é“è·¯å¾„çš„è·ç¦»æ˜¯å¤šå°‘ç›´æŽ¥è®¿é—® dist æ•°ç»„å³å¯ï¼›è‹¥è¦çŸ¥é“è·¯å¾„æ˜¯ä»€ä¹ˆï¼Œé€’å½’è¾“å‡º path æ•°ç»„å³å¯ï¼ˆéžé€’å½’è¾“å‡ºçš„é¡ºåºæ˜¯é€†è¿‡æ¥çš„ï¼‰ã€‚ æœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„æœ‰æƒå›¾çš„æœ€çŸ­è·¯å¾„ä¸Žæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„æœ€æ˜¾è‘—çš„åŒºåˆ«å°±æ˜¯ï¼Œæœ‰æƒå›¾çš„æœ€çŸ­è·¯å¾„ä¸ä¸€å®šæ˜¯è¿›è¿‡é¡¶ç‚¹æœ€å°‘çš„è·¯å¾„ï¼Œè€Œæ— æƒå›¾çš„æœ€çŸ­è·¯å¾„åˆ™ä¸€å®šæ˜¯ç»è¿‡é¡¶ç‚¹æœ€å°‘çš„è·¯å¾„ã€‚ä»¥ä¸‹å›¾ä¸ºä¾‹ï¼Œ$v_1 -&gt; v_4 -&gt; v_6$ä¸Ž$v_1 -&gt; v_4 -&gt; v_7 -&gt; v_6$ç›¸æ¯”ï¼Œç¬¬äºŒæ¡è·¯å¾„è¦æ›´çŸ­ä¸€ç‚¹ã€‚åŒæ ·ï¼Œå½“å›¾å†…å­˜åœ¨è´Ÿæƒå€¼çš„è¾¹æ—¶ï¼Œå°±å¯èƒ½äº§ç”Ÿè´Ÿå€¼åœˆï¼ˆNegative-cost cycleï¼‰ï¼Œå¦‚ä¸‹å›¾ï¼šæ­¤æ—¶å•æºæœ€çŸ­è·¯å¾„çš„ç®—æ³•æ˜¯æ— æ³•å¾—åˆ°æ­£ç¡®ç»“æžœçš„ï¼Œè¿™é‡Œä¸æ·±å…¥è®¨è®ºè¿™ç±»é—®é¢˜ã€‚ å›žè¿‡å¤´æ¥ï¼Œæœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ä¸Žæ— æƒå›¾çš„å•æºæœ€çŸ­è·¯ç®—æ³•æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯äºŒè€…çš†æ˜¯æŒ‰ç…§é€’å¢žçš„é¡ºåºæ‰¾å‡ºåˆ°å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œè€Œæœ‰æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ç®—æ³•ä¹Ÿå«Dijkstraç®—æ³•ã€‚ Dijkstra ç®—æ³•Dijkstra ç®—æ³•æ˜¯å…¸åž‹çš„è´ªå¿ƒç®—æ³•ï¼Œç›´æŽ¥æè¿°å…¶è¿‡ç¨‹æœ‰ç‚¹éº»çƒ¦ï¼Œå…ˆçœ‹ä¸‹é¢çš„ä¼ªç ç®—æ³•æè¿°ï¼š123456789101112131415void Dijkstra(Vertex S) &#123; while(1) &#123; v = æœªæ”¶å½•é¡¶ç‚¹ä¸­ dist æœ€å°è€…; if(è¿™æ ·çš„ v ä¸å­˜åœ¨) break; collected[v] = true; for(v çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ w)&#123; if(collected[w] == false) &#123; if(dist[v] + &lt;v, w&gt;çš„æƒå€¼ &lt; dist[w]) &#123; dist[w] = dist[v] + &lt;v, w&gt;çš„æƒå€¼; path[w] = v; &#125; &#125; &#125; &#125;&#125; éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼š ä¸èƒ½è§£å†³æœ‰è´Ÿè¾¹çš„æƒ…å†µ æ€»æ˜¯æŒ‰ç…§é¡¶ç‚¹åºå·é€’å¢žï¼ˆéžé€’å‡ï¼‰çš„é¡ºåºæ¥å¼€å§‹ç®—æ³• æ¯æ¬¡æ”¶å½•ä¸€ä¸ªé¡¶ç‚¹ w åŽè¦æ›´æ–°ä»Ž v åˆ° w çš„æœ€çŸ­è·¯å¾„çš„æƒå€¼å’Œ æ¯æ¬¡æ”¶å½•ä¸€ä¸ªé¡¶ç‚¹ w åŽå¯èƒ½ä¼šå½±å“ v åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œæ‰€ä»¥è¦å¯¹ v çš„é‚»æŽ¥ç‚¹è¿›è¡Œè®¿é—® å¦‚ä½•ä»Žæœªæ”¶å½•é¡¶ç‚¹ä¸­æ‰¾å‡º dist æœ€å°è€…æ˜¯å½±å“æ­¤ç®—æ³•æ—¶é—´å¤æ‚åº¦çš„å…³é”®ï¼Œæ ¹æ®æ–¹æ³•çš„ä¸åŒï¼Œæœ‰ä¸¤ç§æƒ…å†µï¼š ç›´æŽ¥æ‰«ææ‰€æœ‰æœªæ”¶å½•é¡¶ç‚¹ï¼Œæ¯æ¬¡åœ¨æ‰¾å‡ºæ‰€æœ‰é¡¶ç‚¹ä¸­ dist æœ€å°çš„é¡¶ç‚¹ï¼Œç„¶åŽå†è®¿é—®å½“å‰è¿™ä¸ªé¡¶ç‚¹çš„æ‰€æœ‰é‚»æŽ¥ç‚¹ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(|V^2| + |E|)$ï¼Œè¿™ç§æ–¹æ³•é€‚åˆç¨ å¯†å›¾ å¦‚æžœæ˜¯å°† dist å­˜åœ¨æœ€å°å †ä¸­ï¼Œé‚£ä¹ˆæ‰¾å‡ºæ‰€æœ‰é¡¶ç‚¹ä¸­ dist æœ€å°çš„é¡¶ç‚¹æ‰€è€—è´¹çš„æ—¶é—´å°±æ˜¯$O(log|V|)$ï¼Œä½†æ˜¯æœ€åŽè¿˜å¾—å°†è¿™ä¸ªå€¼æ’å…¥åˆ°å †ä¸­ï¼Œä¸”å¯¹äºŽä¸€ä¸ªè¿žé€šçš„å›¾è€Œè¨€ï¼Œè¾¹æ•°è‚¯å®šå¤§äºŽç­‰äºŽé¡¶ç‚¹æ•°ï¼Œæ‰€ä»¥å…¶æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|)$ï¼Œè¿™ç§æ–¹æ³•é€‚åˆç¨€ç–å›¾ ä¸‹é¢å†ä»¥ä¸‹å›¾ä¸­çš„å›¾ä¸ºä¾‹ï¼Œæ‰‹åŠ¨æ¨¡æ‹Ÿä¸€éç®—æ³•ã€‚ é¦–å…ˆï¼Œdist å’Œ path æ•°ç»„éƒ½è¦å…ˆåˆå§‹åŒ–ï¼š index 1 2 3 4 5 6 7 dist âˆž âˆž âˆž âˆž âˆž âˆž âˆž path -1 -1 -1 -1 -1 -1 -1 æ³¨æ„ä¸Šé¢ä¸‹æ ‡æ˜¯ä»Ž 1 å¼€å§‹çš„ï¼Œä¸Žé¡¶ç‚¹ä¸‹æ ‡å¯¹åº”å…å¾—æžæ··ï¼Œå½“ç„¶ä»Ž 0 å¼€å§‹ä¹Ÿæ˜¯æ²¡æœ‰é—®é¢˜çš„ï¼Œä½†åŽé¢åˆ†æžé—®é¢˜æ—¶å¯èƒ½æžæ··æ·†ã€‚ æŽ¥ç€ä»Ž $v_1$ å¼€å§‹ï¼Œåœ¨è®¿é—®$v_1$çš„é‚»æŽ¥ç‚¹ä¹‹å‰ï¼Œéœ€è¦å…ˆå°† dist[1] çš„å€¼ä¿®æ”¹ä¸º 0ï¼Œå› ä¸ºå…¶è‡ªèº«åˆ°è‡ªèº«çš„è·ç¦»æ˜¯ 0ï¼Œç„¶åŽè®¿é—®$v_1$çš„é‚»æŽ¥ç‚¹ï¼Œå¹¶æ›´æ–°è¿™äº›é‚»æŽ¥ç‚¹å¯¹åº”çš„ dist å’Œ path æ•°ç»„çš„å€¼ï¼ˆ$v_1$çš„é‚»æŽ¥ç‚¹åªæœ‰$v_2$å’Œ$v_4$ï¼‰ï¼Œæ­¤æ—¶ dist ä¸Ž pathæ•°ç»„çš„å€¼ä¸ºï¼š index 1 2 3 4 5 6 7 dist 0 2 âˆž 1 âˆž âˆž âˆž path -1 1 -1 1 -1 -1 -1 æ­¤æ—¶åˆå›žåˆ°å¾ªçŽ¯ä½“çš„å¼€å¤´éƒ¨åˆ†ï¼Œæ‰¾å‡º dist ä¸­æœ€å°çš„ä¸”æœªè¢«è®¿é—®è¿‡çš„ï¼Œæ˜¾ç„¶æ˜¯$v_4$ï¼Œç„¶åŽåˆ©ç”¨$v_4$æ¥æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 å†ç»§ç»­ä¸‹ä¸€è½®å¾ªçŽ¯ï¼Œæ­¤æ—¶é€‰å‡ºçš„é¡¶ç‚¹å°±æ˜¯$v_2$ï¼Œåœ¨æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 ä¸Šé¢è¡¨æ ¼ä¸­çš„å€¼ä¸Žç¬¬äºŒæ¬¡å¾ªçŽ¯æ²¡æœ‰å˜åŒ–ï¼ŒåŽŸå› åœ¨äºŽé€šè¿‡$v_2$å¹¶ä¸èƒ½ä½¿$v_1$åˆ°è¾¾$v_4$å’Œ$v_5$çš„è·ç¦»å˜å°ï¼Œæ‰€ä»¥ä¹Ÿå°±ä¸ç”¨æ›´æ–° dist å’Œ path æ•°ç»„çš„å€¼ã€‚ å†ç»§ç»­ä¸‹ä¸€è½®å¾ªçŽ¯ï¼Œæ­¤æ—¶é€‰å‡ºçš„é¡¶ç‚¹å°±æ˜¯$v_3$ï¼ˆæ³¨æ„æ˜¯æŒ‰é€’å¢žé¡ºåºï¼Œæ‰€ä»¥ä¸æ˜¯$v_5$ï¼‰ï¼Œæ­¤æ—¶é€šè¿‡$v_3$å¯ä»¥ä½¿$v_1$åˆ°$v_6$çš„è·ç¦»å˜å°ï¼Œæ‰€ä»¥æ›´æ–°æ•°ç»„ä¸­çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 8 5 path -1 1 4 1 4 3 4 æŽ¥ç€é€‰å®š$v_5$ï¼ŒæŒ‰ç…§åŒæ ·çš„è¿‡ç¨‹ï¼Œæ•°ç»„å€¼ä¹Ÿä¸ç”¨æ›´æ–°ã€‚ åœ¨é€‰å®š$v_7$ï¼Œæ­¤æ—¶å¯ä»¥ä½¿$v_1$åˆ°$v_6$çš„è·ç¦»å˜å°ï¼Œæ›´æ–°æ•°ç»„çš„å€¼ï¼š index 1 2 3 4 5 6 7 dist 0 2 3 1 3 6 5 path -1 1 4 1 4 7 4 æœ€åŽä¸€ä¸ªé¡¶ç‚¹æ˜¯$v_6$ï¼Œä½†$v_6$æ²¡æœ‰é‚»æŽ¥ç‚¹ï¼ˆå°±ç®—æœ‰ï¼Œæ­¤æ—¶å…¶ä»–é¡¶ç‚¹ä¹Ÿéƒ½è¢«è®¿é—®è¿‡äº†ï¼‰ï¼Œæ‰€ä»¥å¾ªçŽ¯ä¼šç»“æŸã€‚ æ³¨æ„ä¸Šè¿°è¿‡ç¨‹ä¸Žå§¥å§¥è®²çš„ç•¥å¾®æœ‰ç‚¹ä¸ä¸€è‡´ï¼Œä¹Ÿå°±æ˜¯å¼€å¤´åŠ å…¥$v_1$åŽï¼Œæ•°ç»„å€¼éƒ½æ˜¯å¾ªçŽ¯ä½“å†…æ›´æ–°çš„ï¼›è€Œå§¥å§¥è®²çš„æ˜¯åœ¨å¾ªçŽ¯å¼€å§‹ä¹‹å‰å°±å·²ç»å…¨éƒ¨æ›´æ–°å¥½äº†ã€‚å®žé™…ä¸Šï¼Œåœ¨å¾ªçŽ¯ä½“å†…æ›´æ–°è¿˜è¦æ›´åŠ æ–¹ä¾¿ä¸€ç‚¹ã€‚ æœ‰æƒå›¾çš„å¤šæºæœ€çŸ­è·¯å¾„è€ƒè™‘æœ‰æƒå›¾çš„å¤šæºæœ€çŸ­è·¯å¾„æ—¶ï¼Œæ¯«æ— ç–‘é—®ä¼šæƒ³åˆ°ç›´æŽ¥å°†å•æºæœ€çŸ­è·¯å¾„ç®—æ³•è°ƒç”¨$|V|$ï¼ˆå› ä¸ºé¡¶ç‚¹ä¸ªæ•°æ˜¯$|V|$ï¼‰ï¼Œæ­¤æ—¶ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$ T = O(|V^3| + |E| \times |V|)$ï¼Œæ˜¾ç„¶å¦‚æžœæ˜¯ç¨€ç–å›¾ï¼Œæ•ˆçŽ‡è¾ƒé«˜ã€‚ é‚£ç¢°åˆ°ç¨ å¯†å›¾æ€Žä¹ˆåŠžå‘¢ï¼Ÿç­”æ¡ˆæ˜¯ç”¨ Floyd ç®—æ³• Floyd ç®—æ³•Floyd ç®—æ³•ä¸Ž Dijkstra ç®—æ³•æœ‰ç‚¹ç±»ä¼¼ï¼Œä½†æ˜¯å…¶å€ŸåŠ©äº†æ•°å­¦å½’çº³æ³•ï¼Œç›¸æ¯” Dijkstra ç®—æ³•ï¼Œä»£ç è¦ç®€å•ä¸€ç‚¹ã€‚ æ³¨æ„ Floyd ç®—æ³•åªèƒ½ç”¨äºŽé‚»æŽ¥çŸ©é˜µï¼Œå®ƒæœ¬èº«ä¹Ÿæ˜¯é€šè¿‡é‚»æŽ¥çŸ©é˜µæ¥æ›´æ–°æœ€çŸ­è·¯å¾„çš„æƒå€¼ä¹‹å’Œçš„ï¼Œå½“$D^{k-1}$å·²ç»å®Œæˆï¼Œé€’æŽ¨åˆ°$D^k$æ—¶ï¼Œä¸»è¦ç†è§£ä¸¤ä¸ªç‚¹ï¼š è‹¥ k ä¸åœ¨æœ€çŸ­è·¯å¾„$i -&gt; \dots -&gt; j$ä¹‹é—´ï¼Œåˆ™$D^k = D^{k-1}$ è‹¥ k åœ¨æœ€çŸ­è·¯å¾„å¾„$i -&gt; \dots -&gt; j$ä¹‹é—´ï¼Œåˆ™è¯¥è·¯å¾„å¿…å®šç”±ä¸¤æ®µæœ€çŸ­è·¯å¾„ç»„æˆï¼š$D^k[i][j] = D^{k-1}[i][k] + D^{k-1}[k][j]$ å…¶ä¼ªç æè¿°ä¸ºï¼š12345678910111213141516171819void Floyd() &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; D[i][j] = G[i][j]; // initialization path[i][j] = -1; &#125; &#125; // notice these loop variables for(k = 0; k &lt; N; k++) &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(D[i][k] + D[k][j] &lt; D[i][j]) &#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125;&#125; Homework07-4 å“ˆåˆ©Â·æ³¢ç‰¹çš„è€ƒè¯•è¿™é“é¢˜ç›®æ˜¯å…¸åž‹çš„å¤šæºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œç›´æŽ¥ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨å›¾ï¼Œç„¶åŽè°ƒç”¨ Folyd ç®—æ³•å³å¯å¾—åˆ°æ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ã€‚ä½†è¦æ³¨æ„è¿™é“é¢˜ç›®çš„æœ€ä¼˜è§£æ˜¯é€‰æ‹©å‡ºåˆ°å…¶ä»–å„é¡¶ç‚¹çš„ç»¼åˆè·ç¦»æœ€çŸ­çš„é¡¶ç‚¹ï¼Œä¹Ÿå°±æ˜¯è¯´å„ä¸ªé¡¶ç‚¹åˆ°å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸­æœ€é•¿çš„é‚£æ¡æœ€çŸ­è·¯å¾„çš„æœ€å°å€¼è€…å°±æ˜¯æœ€ä¼˜è§£ï¼Œå¥½å§ï¼Œå¾ˆæ‹—å£ã€‚æ³¨æ„ï¼Œå¹¶ä¸èƒ½ä»¥æœ€çŸ­è·¯å¾„ä¹‹å’Œæœ€å°è€…ä¸ºæœ€ä¼˜è§£ï¼Œè¿™æ˜¯é”™è¯¯çš„ã€‚è¿™é“é¢˜çš„ä»£ç å†™çš„æ¯”è¾ƒç®€å•ï¼Œæ€è·¯ä¸Žä¸Šè¿°ä¸€è‡´ï¼Œå¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;int n, m, G[maxn][maxn], dist[maxn][maxn];void floyd() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; dist[i][j] = G[i][j]; &#125; &#125; for(int k = 1; k &lt;= n; k++) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(dist[i][k] + dist[k][j] &lt; dist[i][j] &amp;&amp; i != j) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125;&#125;void findanimal() &#123; floyd(); int mindist = inf; int animal; for(int i = 1; i &lt;= n; i++) &#123; int maxdist = 0; for(int j = 1; j &lt;= n; j++) &#123; if(i != j &amp;&amp; dist[i][j] &gt; maxdist) maxdist = dist[i][j]; &#125; if(maxdist == inf) &#123; cout &lt;&lt; 0; return; &#125; if(mindist &gt; maxdist) &#123; mindist = maxdist; animal = i; &#125; &#125; cout &lt;&lt; animal &lt;&lt; ' ' &lt;&lt; mindist;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2]; G[v2][v1] = G[v1][v2]; &#125; findanimal(); return 0;&#125;/*samples:in:6 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80out:4 70*/ 07-5 Saving James Bond - Hard Versionè¿™é“é¢˜ç›®æ˜¯ä¸Šå‘¨é¢˜ç›®çš„åŠ å¼ºç‰ˆï¼Œé¢˜ç›®å¤§æ„ä¸Žå§¥å§¥åœ¨è¯¾ä¸Šå¼€å¤´è®²çš„ä¸€æ ·ï¼Œä¸ä»…è¦åˆ¤æ–­æ˜¯å¦å¯ä»¥åˆ°è¾¾å²¸è¾¹ï¼Œè¿˜è¦è¾“å‡ºå¯¹åº”çš„è·¯å¾„ã€‚ è§£å†³è¿™ä¸ªé—®é¢˜çš„æ€è·¯å°±æ˜¯åˆ©ç”¨ BFS ç®—æ³•æ¥æ‰¾æœ€çŸ­è·¯å¾„ï¼Œä¹Ÿå°±æ˜¯æ— æƒå›¾çš„å•æºæœ€çŸ­è·¯å¾„ã€‚å¯èƒ½æœ‰çš„åŒå­¦ä¼šè§‰å¾—é¡¶ç‚¹ä¹‹å‰çš„è·ç¦»ä¸å°±æ˜¯è¾¹çš„æƒå—ï¼Ÿå…¶å®žä¸ç„¶ï¼Œè¿™ä¸ªé¢˜ç›®çš„è¾¹æƒä¸æ˜¯ç›´æŽ¥ç»™å‡ºï¼Œéœ€è¦è®¡ç®—å¾—åˆ°ï¼›è€Œä¸”ï¼Œè¿™ä¸ªé¢˜ç›®çš„æœ€ä¼˜è§£ä¸æ˜¯è¦æ±‚æœ€çŸ­è·¯å¾„çš„æƒå€¼æœ€å°ï¼Œè€Œæ˜¯è¦æ±‚è·³çš„æ¬¡æ•°æœ€å°‘ï¼Œæ‰€ä»¥ï¼Œåªéœ€è¦ç”¨è®¡ç®—å‡ºè¾¹æƒç„¶åŽåˆ¤æ–­æ˜¯å¦å¯è¾¾å³å¯ã€‚ è¦æ±‚å¾—å…·ä½“ç»è¿‡äº†å‡ è·³åˆ°è¾¾å²¸è¾¹ï¼Œç¨å¾®æœ‰ç‚¹éº»çƒ¦ï¼Œä½†å¯ä»¥å€Ÿé‰´ä¸Šç¯‡æ–‡ç« å…­åº¦ç©ºé—´é‚£ä¸ªé¢˜ç›®çš„æ€è·¯ï¼Œåœ¨å¼€å§‹ BFS ä¹‹å‰å…ˆè®°å½•æ˜¯å“ªä¸ªé¡¶ç‚¹ï¼Œåœ¨æ¯æ¬¡å¾ªçŽ¯ç»“æŸä¹‹å‰ï¼Œå°†å½“å‰åŠ å…¥è·¯å¾„çš„ç»“ç‚¹ä¸Žè®°å½•çš„ç»“ç‚¹æ¯”å¯¹ï¼Œå¦‚æžœç›¸åŒï¼Œé‚£ä¹ˆè·³æ­¥æ•°åŠ  1ï¼Œå¹¶å°†æ­¤ç»“ç‚¹è®°å½•åŽç”¨ä½œä¸‹è½®å¾ªçŽ¯åˆ¤æ–­ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node &#123; int x, y;&#125; coords[maxn];int n, d, path[maxn];bool vis[maxn] = &#123;false&#125;;int firstjump(int v) &#123; int dis = d - sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) + 7.5; if(dis &gt; 0) return dis; else return 0;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125;bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool cmp(int a, int b) &#123; return firstjump(a) &gt; firstjump(b);&#125;void printpath(int inde) &#123; if(path[inde] == -1) &#123; cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl; return; &#125; printpath(path[inde]); cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl;&#125;void save007() &#123; if(d &gt;= 50 - 15 / 2) &#123; cout &lt;&lt; 1; return; &#125; else &#123; int order[maxn]; queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) &#123; order[i] = i; path[i] = -1; &#125; sort(order, order + n, cmp); int last, tail; for(int i = 0; i &lt; n; i++) &#123; if(firstjump(order[i])) &#123; q.push(order[i]); vis[order[i]] = true; last = order[i]; &#125; &#125; int step = 2; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(issafe(front)) &#123; cout &lt;&lt; step &lt;&lt; endl; printpath(front); return; &#125; for(int i = 0; i &lt; n; i++) &#123; if(!vis[i] &amp;&amp; jump(front, i)) &#123; q.push(i); path[i] = front; vis[i] = true; tail = i; &#125; &#125; if(last == front) &#123; step++; last = tail; &#125; &#125; if(q.empty()) cout &lt;&lt; 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; coords[i].x &gt;&gt; coords[i].y; &#125; save007(); return 0;&#125;/*samples:in:17 1510 -2110 21-40 1030 -5020 4035 100 -10-25 2240 -40-30 30-10 220 1125 2125 1010 1010 35-30 10out:40 1110 2110 35in:4 13-12 1212 12-12 -1212 -12out:0in:1 5030 30out:1*/ 07-6 æ—…æ¸¸è§„åˆ’è¿™é“é¢˜ç›®æ˜¯ä¸­æ–‡çš„ï¼Œè¯»èµ·æ¥æ²¡é‚£ä¹ˆè´¹åŠ²äº†ï¼Œæ‰€ä»¥å¾ˆå®¹æ˜“è®©äººçœ‹å‡ºæ˜¯å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚ é¢˜ç›®å·²ç»ç»™å®šäº†æºç‚¹å’Œç»ˆç‚¹ï¼Œæ‰€ä»¥ç”¨æºç‚¹ç›´æŽ¥å¥— Dijkstra ç®—æ³•å³å¯å¾—åˆ°å…¶åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ã€‚ ä½†è¿™ä¸ªé¢˜ç›®çš„éš¾ç‚¹åœ¨äºŽè¦æ ¹æ®é¢˜ç›®ç»™å®šçš„é€‰è§£æ–¹å¼æ¥ç¡®å®šæœ€ä¼˜è§£ï¼Œå³ï¼š è·¯å¾„æœ€çŸ­ æœ€ä¾¿å®œ æ‰€ä»¥éœ€è¦ä¿®æ”¹ä¸€ä¸‹ Dijkstra ç®—æ³•ï¼Œå…·ä½“ä»£ç å¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* notes: this problem is similar to the Advanced Level 1030. */#include &lt;iostream&gt;using namespace std;const int inf = 0x3fffffff;const int maxn = 500 + 5;int n, m, src, dst, G[maxn][maxn], cost[maxn][maxn];int d[maxn], c[maxn];bool vis[maxn] = &#123;false&#125;;void dijkstra(int src) &#123; fill(d, d + maxn, inf); d[src] = 0; c[src] = 0; for(int i = 0; i &lt; n; i++) &#123; int v = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; d[j] &lt; min) &#123; v = j; min = d[j]; &#125; &#125; if(v == -1) return; vis[v] = true; for(int w = 0; w &lt; n; w++) &#123; if(!vis[w] &amp;&amp; G[v][w] != inf) &#123; if(d[v] + G[v][w] &lt; d[w]) &#123; d[w] = d[v] + G[v][w]; c[w] = c[v] + cost[v][w]; &#125; else if(d[v] + G[v][w] == d[w]) &#123; if(c[v] + cost[v][w] &lt; c[w]) c[w] = c[v] + cost[v][w]; &#125; &#125; &#125; &#125;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2] &gt;&gt; cost[v1][v2]; G[v2][v1] = G[v1][v2], cost[v2][v1] = cost[v1][v2]; &#125; dijkstra(src); cout &lt;&lt; d[dst] &lt;&lt; ' ' &lt;&lt; c[dst]; return 0;&#125;/*samples:in:4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20out:3 40*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_06-å›¾ï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F08%2F27%2FZJU-DS-06-%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯å›¾ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿå›¾åˆæœ‰é‚£äº›åŸºæœ¬çš„æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ ä»€ä¹ˆæ˜¯å›¾å›¾å¸¸ç”¨æ¥å»ºç«‹å¤šå¯¹å¤šçš„å…³ç³»ï¼Œå¦‚ç¤¾äº¤ç½‘ç»œç­‰ã€‚é‚£ä¹ˆç”¨ä»€ä¹ˆæ¦‚å¿µæ¥è¯´æ˜Žè¿™äº›å…³ç³»å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯â€œé¡¶ç‚¹â€è·Ÿâ€œè¾¹â€ã€‚å›¾çš„æž„æˆåªæœ‰ä¸¤ç§ï¼šé¡¶ç‚¹å’Œè¾¹ï¼ŒäºŒè€…å³æ˜¯ç”¨æ¥è¡¨ç¤ºå…³ç³»çš„æ¦‚å¿µã€‚ é¡¶ç‚¹ä¸€ä¸ªå›¾å†…è‚¯å®šä¸æ­¢ä¸€ä¸ªé¡¶ç‚¹ï¼ˆVertexï¼‰ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨ ï¼¶ æ¥è¡¨ç¤ºé¡¶ç‚¹é›†åˆ è¾¹åŒæ ·ï¼Œä¸€ä¸ªå›¾å†…è‚¯å®šä¸æ­¢ä¸€æ¡è¾¹ï¼ˆEdgeï¼‰ï¼Œæ‰€ä»¥ä¸€èˆ¬ç”¨ E æ¥è¡¨ç¤ºè¾¹çš„é›†åˆã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå›¾åˆ†ä¸ºæœ‰å‘å›¾ä¸Žæ— å‘å›¾ï¼Œæ‰€ä»¥è¾¹åœ¨è¿™ä¸¤ç§å›¾ä¸­åˆ†åˆ«ç§°ä½œæœ‰å‘è¾¹ï¼ˆå•è¡Œçº¿ï¼Œå¦‚$&lt;v_1, v_2&gt;$ï¼‰ä¸Žæ— å‘è¾¹ï¼ˆ$(v1, v2)$ï¼‰ã€‚ å¦å¤–ï¼Œåœ¨å›¾å†…æ˜¯ä¸è€ƒè™‘é‡è¾¹å’Œè‡ªå›žè·¯çš„ã€‚ åŸºæœ¬æœ¯è¯­ä¸Žå›¾ç›¸å…³çš„åŸºæœ¬æœ¯è¯­æœ‰å¾ˆå¤šï¼Œç¢°è§ä¸€ä¸ªè®°å½•ä¸€ä¸ªï¼š æ— å‘å›¾ï¼Œå›¾å†…æ‰€æœ‰çš„è¾¹éƒ½æ˜¯æ— å‘è¾¹ï¼Œå¯¹åº”çš„ï¼Œè‹¥å›¾å†…æ‰€æœ‰çš„è¾¹éƒ½æ˜¯æœ‰å‘è¾¹ï¼Œé‚£è¿™ä¸ªå›¾å°±æ˜¯æœ‰å‘å›¾ æ¯ä¸€æ¡è¾¹ä¸Šèµ‹äºˆæƒå€¼åŽï¼Œé‚£ä¹ˆç§°è¿™ä¸ªå›¾å«åšâ€œç½‘ç»œâ€ï¼Œè¿™ä¸ªæ¦‚å¿µä¸Žäº’è”ç½‘ç»œæ˜¯ä¸ä¸€æ ·çš„ å®Œå…¨å›¾ï¼Œå›¾å†…æ‰€æœ‰é¡¶ç‚¹ï¼Œä»»æ„ä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´éƒ½æœ‰è¾¹ è¿žé€šï¼Œå¦‚æžœä»Ž V åˆ° W å­˜åœ¨ä¸€æ¡ï¼ˆæ— å‘ï¼‰è·¯å¾„ï¼Œåˆ™ç§° V å’Œ W æ˜¯è¿žé€šçš„ è·¯å¾„ï¼ŒV åˆ° W çš„è·¯å¾„æ˜¯ä¸€ç³»åˆ—é¡¶ç‚¹${V, V_1, V_2, \dots, V_n, W}$çš„é›†åˆï¼Œå…¶ä¸­ä»»ä¸€å¯¹ç›¸é‚»é¡¶ç‚¹é—´éƒ½æœ‰å›¾ä¸­çš„è¾¹ã€‚è·¯å¾„çš„é•¿åº¦æ˜¯è·¯å¾„ç§çš„è¾¹æ•°ï¼ˆå¦‚æžœå¸¦æƒï¼Œåˆ™æ˜¯æ‰€æœ‰è¾¹çš„æƒé‡å’Œï¼‰ã€‚å¦‚æžœ V åˆ° W ä¹‹é—´çš„æ‰€æœ‰é¡¶ç‚¹éƒ½ä¸åŒï¼Œåˆ™ç§°ç®€å•è·¯å¾„ å›žè·¯ï¼Œèµ·ç‚¹ç­‰äºŽç»ˆç‚¹çš„è·¯å¾„ è¿žé€šå›¾ï¼Œå›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹å‡è¿žé€š è¿žé€šåˆ†é‡ï¼Œæ— å‘å›¾çš„æžå¤§è¿žé€šå­å›¾ï¼Œå…¶ä¸­â€œæžå¤§â€åŒ…å«ä¸‹é¢ä¸¤ä¸ªæ„æ€ï¼š æžå¤§é¡¶ç‚¹æ•°ï¼šå†åŠ ä¸€ä¸ªé¡¶ç‚¹å°±ä¸è¿žé€šäº† æžå¤§è¾¹æ•°ï¼šåŒ…å«å­å›¾ç§æ‰€æœ‰é¡¶ç‚¹ç›¸è¿žçš„æ‰€æœ‰è¾¹ æœ‰å‘å›¾ä¸­é¡¶ç‚¹ V å’Œ W ä¹‹é—´å­˜åœ¨åŒå‘è·¯å¾„ï¼Œåˆ™ç§° V å’Œ W æ˜¯å¼ºè¿žé€šçš„ å¼ºè¿žé€šå›¾ï¼Œæœ‰å‘å›¾ä¸­ä»»æ„ä¸¤é¡¶ç‚¹å‡å¼ºè¿žé€š å¼ºè¿žé€šåˆ†é‡ï¼Œæœ‰å‘å›¾çš„æžå¤§å¼ºè¿žé€šå­å›¾ å¼±è¿žé€šå›¾ï¼Œå¦‚æžœä¸€ä¸ªéžå¼ºè¿žé€šå›¾ï¼Œå°†å…¶ä¸­æ‰€æœ‰çš„æœ‰å‘è¾¹æ”¹ä¸ºæ— å‘è¾¹ï¼Œå¾—åˆ°çš„å›¾ä¸ºè¿žé€šå›¾ï¼Œè¿™æ ·çš„å›¾ç§°ä¸ºå¼±è¿žé€šå›¾ å›¾çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šå›¾ï¼ˆGraphï¼‰æ•°æ®å¯¹è±¡é›†ï¼š$G(V, E)$ç”±ä¸€ä¸ªéžç©ºçš„æœ‰é™é¡¶ç‚¹é›†$V$å’Œä¸€ä¸ªæœ‰é™è¾¹é›†åˆ$E$ç»„æˆã€‚æ“ä½œé›†ï¼šæœ€å¤§å †$H âˆˆ MaxHeap$ï¼Œå…ƒç´ $item âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œæœ‰ï¼š Graph Create()ï¼Œå»ºç«‹å¹¶è¿”å›žç©ºå›¾ Graph InsertVertex(Graph G, Vertex v)ï¼Œå°† v æ’å…¥ G Graph InsertEdge(Graph G, Edge e)ï¼Œå°† e æ’å…¥ G void DFS(Graph G, Vertex v)ï¼Œä»Žé¡¶ç‚¹ v å‡ºå‘æ·±åº¦ä¼˜å…ˆéåŽ†å›¾ G void BFS(Graph G, Vertex v)ï¼Œä»Žé¡¶ç‚¹ v å‡ºå‘å®½åº¦ä¼˜å…ˆéåŽ†å›¾ G void ShortestPath(Graph G, Vertex v, int Dist[])ï¼Œè®¡ç®—å›¾ G ä¸­é¡¶ç‚¹ v åˆ°ä»»æ„å…¶ä»–é¡¶ç‚¹çš„æœ€çŸ­è·ç¦» void MST(Graph G)ï¼Œè®¡ç®—å›¾ G çš„æœ€å°ç”Ÿæˆæ ‘ å›¾çš„è¡¨ç¤ºå›¾çš„è¡¨ç¤ºæœ‰å¤šç§æ–¹æ³•ï¼ŒæŒ‰ç…§æ‰€è¦è§£å†³çš„é—®é¢˜çš„æ€§è´¨ï¼Œç”¨ç¬¦åˆé—®é¢˜æƒ…å†µçš„è¡¨ç¤ºæ–¹æ³•æ¥è¡¨ç¤ºå›¾ï¼Œåœ¨è§£å†³é—®é¢˜æ˜¯å¯ä»¥äº‹åŠåŠŸå€ï¼Œä¸‹é¢åªä»‹ç»ä¸¤ç§å¸¸è§çš„è¡¨ç¤ºæ–¹æ³•ã€‚ é‚»æŽ¥çŸ©é˜µé‚»æŽ¥çŸ©é˜µæœ¬è´¨ä¸Šå°±æ˜¯ä¸€ä¸ªäºŒç»´æ•°ç»„ï¼Œç”¨æ•°ç»„ä¸‹æ ‡$0-N-1$ä»£è¡¨$N$ä¸ªé¡¶ç‚¹çš„ç¼–å·ï¼Œæ•°ç»„çš„å…ƒç´ çš„å€¼è¡¨ç¤ºä¸¤ä¸ªé¡¶ç‚¹ä¹‹é—´æ˜¯å¦æœ‰è¾¹ï¼ˆè‹¥æ˜¯ç½‘ç»œï¼Œé‚£ä¹ˆç›´æŽ¥å°†æ•°ç»„å…ƒç´ çš„å€¼ä¿®æ”¹ä¸ºå¯¹åº”çš„æƒå€¼å³å¯ï¼‰ï¼Œå³æœ‰ï¼š $G[i][j] =\begin{cases}1&amp; è‹¥&lt;v_i, v_j&gt;æ˜¯Gä¸­çš„è¾¹\\0&amp; å¦åˆ™\end{cases}$å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œæ— å‘å›¾çš„é‚»æŽ¥çŸ©é˜µä¸€å®šæ˜¯å¯¹ç§°çš„ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œæ— å‘å›¾çš„é‚»æŽ¥çŸ©é˜µåªéœ€è¦å­˜å‚¨ä¸€åŠå³å¯ã€‚è¦è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œéœ€è¦ç”¨åˆ°çŸ©é˜µçš„åŽ‹ç¼©å­˜å‚¨çŸ¥è¯†ã€‚ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µè¡¨ç¤ºå›¾çš„ä¼˜ç‚¹æœ‰ä»¥ä¸‹å‡ ç‚¹ï¼š ç›´è§‚ã€ç®€å•ã€ä¾¿äºŽç†è§£ æ–¹ä¾¿æ£€æŸ¥ä»»æ„ä¸€å¯¹é¡¶ç‚¹é—´æ˜¯å¦å­˜åœ¨è¾¹ æ–¹ä¾¿æ‰¾ä»»ä¸€é¡¶ç‚¹çš„æ‰€æœ‰â€œé‚»æŽ¥ç‚¹â€ï¼ˆæœ‰è¾¹ç›´æŽ¥ç›¸è¿žçš„é¡¶ç‚¹ï¼‰ æ–¹ä¾¿è®¡ç®—ä»»ä¸€é¡¶ç‚¹çš„â€œåº¦â€ï¼ˆè¿™é‡Œçš„åº¦çš„æ¦‚å¿µä¸Žæ ‘æ˜¯ç±»ä¼¼çš„ï¼Œä»Žè¯¥é¡¶ç‚¹å‘å‡ºçš„è¾¹æ•°ä¸ºâ€œå‡ºåº¦â€ï¼ŒæŒ‡å‘è¯¥ç‚¹çš„è¾¹æ•°ä¸ºâ€œå…¥åº¦â€ï¼‰ æ— å‘å›¾ï¼šå¯¹åº”è¡Œï¼ˆæˆ–åˆ—ï¼‰éž 0 å…ƒç´ çš„ä¸ªæ•° æœ‰å‘å›¾ï¼šå¯¹åº”è¡Œéž 0 å…ƒç´ çš„ä¸ªæ•°æ˜¯â€œå‡ºåº¦â€ï¼Œå¯¹åº”åˆ—éž 0 å…ƒç´ çš„ä¸ªæ•°æ˜¯â€œå…¥åº¦â€ é‚»æŽ¥çŸ©é˜µçš„ç¼ºç‚¹å¦‚ä¸‹ï¼š å­˜å‚¨ç¨€ç–å›¾ï¼ˆé¡¶ç‚¹å¤šè¾¹å¾ˆå°‘ï¼‰æ—¶æœ‰å¤§é‡æ— æ•ˆå…ƒç´ ï¼Œæžå¤§æµªè´¹ç©ºé—´ï¼Œä½†å­˜å‚¨ç¨ å¯†å›¾ï¼ˆç‰¹åˆ«æ˜¯å®Œå…¨å›¾ï¼‰å¾ˆåˆç®— ç»Ÿè®¡ç¨€ç–å›¾ä¸­çš„è¾¹æ•°æ•ˆçŽ‡å¾ˆä½Ž é‚»æŽ¥è¡¨ç”±äºŽé‚»æŽ¥çŸ©é˜µè¡¨ç¤ºç¨€ç–å›¾æµªè´¹ç©ºé—´ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜å¯¹åº”å‡ºçŽ°çš„å°±æ˜¯é‚»æŽ¥è¡¨ã€‚ åœ¨é‚»æŽ¥è¡¨ä¸­ï¼Œ$G[N]$ä¸ºæŒ‡é’ˆæ•°ç»„ï¼Œå¯¹åº”çŸ©é˜µæ¯ä¸€è¡Œä¸€ä¸ªé“¾è¡¨ï¼Œåªå­˜éž 0 å…ƒç´ ï¼Œæ³¨æ„é‚»æŽ¥è¡¨çš„è¡¨ç¤ºå¹¶ä¸å”¯ä¸€ã€‚ é‚»æŽ¥è¡¨çš„ç‰¹ç‚¹ï¼š æ–¹ä¾¿æ‰¾ä»»ä¸€é¡¶ç‚¹çš„æ‰€æœ‰â€œé‚»æŽ¥ç‚¹â€ èŠ‚çº¦ç¨€ç–å›¾çš„ç©ºé—´ï¼Œéœ€è¦ N ä¸ªå¤´æŒ‡é’ˆ å’Œ 2E ä¸ªç»“ç‚¹ï¼ˆæ¯ä¸ªç»“ç‚¹è‡³å°‘ 2 ä¸ªåŸŸï¼‰ æ–¹ä¾¿è®¡ç®—æ— å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„åº¦å’Œæœ‰å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„å‡ºåº¦ï¼Œä½†è®¡ç®—æœ‰å‘å›¾ä»»ä¸€é¡¶ç‚¹çš„å…¥åº¦æ¯”è¾ƒéº»çƒ¦ï¼Œéœ€è¦æž„é€ â€œé€†é‚»æŽ¥è¡¨â€ï¼ˆå­˜å‚¨æŒ‡å‘è‡ªå·±çš„è¾¹ï¼‰æ‰èƒ½æ–¹ä¾¿çš„è®¡ç®—å…¥åº¦ ä¸ä¾¿äºŽæ£€æŸ¥ä»»æ„ä¸€å¯¹é¡¶ç‚¹æ˜¯å¦å­˜åœ¨è¾¹ å›¾çš„éåŽ†å›¾é‡Œé¢éåŽ†çš„æ¦‚å¿µä¸Žæ ‘æ˜¯ä¸€è‡´çš„ï¼Œå›¾çš„åŸºæœ¬éåŽ†æ–¹æ³•æœ‰ä¸¤ç§ï¼šæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆDepth First Searchï¼ŒDFSï¼‰å’Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBreath First Searchï¼ŒBFSï¼‰ã€‚æ ¹æ®åº”ç”¨åœºæ™¯çš„ä¸åŒï¼Œä¸¤ç§éåŽ†ç®—æ³•åœ¨ä¸åŒåœºæ™¯ä¸‹è§£å†³é—®é¢˜çš„éš¾æ˜“ç¨‹åº¦ä¹Ÿä¸ä¸€æ ·ã€‚ DFSDFS ç®—æ˜¯æ ‘çš„å…ˆåºéåŽ†çš„æŽ¨å¹¿ï¼Œå…¶ä¼ªç ç®—æ³•ä¸ºï¼š123456void DFS(Vertex V) &#123; visited[V] = true; // æ­¤ç»“ç‚¹æ ‡è®°ä¸ºå·²è®¿é—® for( V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(!visited[W]) DFS(W); &#125;&#125; æ ¹æ®å›¾çš„å­˜å‚¨ç»“æž„çš„ä¸åŒï¼ŒDFS çš„æ—¶é—´å¤æ‚åº¦ä¹Ÿä¸åŒï¼š ä½¿ç”¨é‚»æŽ¥è¡¨å­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N + E)$ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N^2)$ BFSBFS ç®—æ˜¯æ ‘çš„å±‚åºéåŽ†çš„æŽ¨å¹¿ï¼Œå…¶ä¼ªç ç®—æ³•ä¸ºï¼š12345678910111213void BFS(Vertex V) &#123; visited[V] = true; Enqueu(V, Q); while(!Isempty(Q)) &#123; V = Dequeue(Q); for(V çš„æ¯ä¸ªé‚»æŽ¥ç‚¹ W) &#123; if(!visited[W]) &#123; visited[W] = true; Enqueue(W, Q); &#125; &#125; &#125;&#125; åŒæ ·ï¼Œå…¶æ—¶é—´å¤æ‚åº¦ä¹Ÿåˆ†ä¸¤ç§æƒ…å†µï¼š ä½¿ç”¨é‚»æŽ¥è¡¨å­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N+E)$ ä½¿ç”¨é‚»æŽ¥çŸ©é˜µå­˜å‚¨ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(N^2)$ Homework06-1 åˆ—å‡ºè¿žé€šé›†é¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œç»™å®šä¸€ä¸ªæ— å‘å›¾ï¼Œåˆ†åˆ«ç”¨ DFS å’Œ BFSåˆ—å‡ºå…¶æ‰€æœ‰çš„è¿žé€šé›†ï¼ˆå…¶å®žå°±æ˜¯è¿žé€šåˆ†é‡ï¼Œå¿˜è®°æ˜¯å•¥äº†ï¼Œå¯ä»¥é‡æ–°çœ‹ä¸‹ä¸Šé¢çš„æ¦‚å¿µï¼‰å³å¯ã€‚ä¹‹å‰å§¥å§¥åœ¨è¯¾ä¸Šè®²è¿‡ï¼ŒæŒ‰ç…§ DFS çš„éåŽ†è¿‡ç¨‹ï¼Œä¸€ä¸ªæœ€å¤–å±‚çš„ DFS çš„è°ƒç”¨ï¼Œå°±ç›¸å½“äºŽè®¿é—®äº†è¿™ä¸ªå›¾çš„ä¸€ä¸ªè¿žé€šé›†ã€‚é‚£ä¹ˆä½¿ç”¨ DFS åœ¨è®¿é—®æ¯ä¸ªè¿žé€šé›†æ˜¯é¡ºä¾¿è¾“å‡ºå½“å‰æ‰€å¤„è¿žé€šé›†çš„æ‰€æœ‰å…ƒç´ å³å¯ï¼ŒåŒç†ï¼ŒBFS ä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚ ç”±äºŽå§¥å§¥è®²äº†å›¾çš„ä¸¤ç§å­˜å‚¨æ–¹æ³•ï¼Œç»§ç»­æŒ‰éƒ¨å°±ç­çš„æŒ‰ç…§å§¥å§¥ç»™å®šçš„ä»£ç æŽ¥ç€å¾€ä¸‹å†™ï¼š é‚»æŽ¥è¡¨123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* notes: The adjacency list is built by head pointer, so the traversal sequences is not same as sample output.Actually, the adjacency list is not unique, so the traversal sequences are also not unique.You can use the sort function to get the same result. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct AdjVNode* PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; WeightType Weight; PtrToAdjVNode Next;&#125;;typedef struct Vnode&#123; PtrToAdjVNode FirstEdge; DataType Data;&#125; AdjList[MaxVertexNum];typedef struct GNode* PtrToGNode;struct GNode&#123; int Nv; int Ne; AdjList G; &#125;;typedef PtrToGNode LGraph;LGraph CreateGraph(int VertexNum) &#123; Vertex V; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; Graph-&gt;G[V].FirstEdge = NULL; &#125; return Graph;&#125;void InsertEdge(LGraph Graph, Edge E) &#123; PtrToAdjVNode NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph() &#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125; void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; PtrToAdjVNode W; Visit(S); Visited[S] = true; for(W = Graph-&gt;G[S].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) DFS(Graph, W-&gt;AdjV, Visit, Visited); &#125;&#125;void BFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; Vertex V; Visit(S); Visited[S] = true; Queue[++rear] = S; while(front &lt; rear) &#123; V = Queue[++front]; PtrToAdjVNode W; for(W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) &#123; Visit(W-&gt;AdjV); Visited[W-&gt;AdjV] = true; Queue[++rear] = W-&gt;AdjV; &#125; &#125; &#125;&#125;void ListComponents(LGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; LGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/*samples:in:8 60 70 12 04 12 43 5out:&#123; 0 2 4 1 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 2 1 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ é‚»æŽ¥çŸ©é˜µ123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode &#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct GNode* PtrToGNode;struct GNode &#123; int Nv; int Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];&#125;;typedef PtrToGNode MGraph;MGraph CreateGraph(int VertexNum) &#123; Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; Graph-&gt;G[V][W] = INFINITY; &#125; &#125; return Graph;&#125;void InsertEdge(MGraph Graph, Edge E) &#123; Graph-&gt;G[E-&gt;V1][E-&gt;V2] = 1; Graph-&gt;G[E-&gt;V2][E-&gt;V1] = 1;&#125;MGraph BuildGraph() &#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125;bool IsEdge(MGraph Graph, Vertex V, Vertex W) &#123; return Graph-&gt;G[V][W] &lt; INFINITY ? true : false;&#125;void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(MGraph Graph, Vertex V, void (*Visit)(Vertex), int Visited[]) &#123; Visit(V); Visited[V] = true; Vertex W; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) DFS(Graph, W, Visit, Visited); &#125;&#125;void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; // use a simple queue Vertex V, W; Visit(S); Visited[S] = true; Queue[++rear] = S; //enqueue while(front &lt; rear) &#123; V = Queue[++front]; //dequeue for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) &#123; Visit(W); Visited[W] = true; Queue[++rear] = W; &#125; &#125; &#125;&#125;void ListComponents(MGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; MGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/* simple method: use 2-dimensional array represent adjcent matrix#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10 + 5;const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void dfs(int node) &#123; visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[node][i] != inf) dfs(i); &#125;&#125;void bfs(int node) &#123; queue&lt;int&gt; q; cout &lt;&lt; node &lt;&lt; ' '; visited[node] = true; q.push(node); while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[front][i] != inf) &#123; cout &lt;&lt; i &lt;&lt; ' '; visited[i] = true; q.push(i); &#125; &#125; &#125;&#125;void listcomponents() &#123; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; dfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; bfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125;&#125;int main() &#123; init(); cin &gt;&gt; nv &gt;&gt; ne; for(int i = 0; i &lt; ne; i++) &#123; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; G[v1][v2] = G[v2][v1] = 1; &#125; listcomponents(); return 0;&#125;*//*some samples:in:8 60 70 12 04 12 43 5out:&#123; 0 1 4 2 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 1 2 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 06-2 Saving James Bond - Easy Versionè¿™é“é¢˜ç›®æ˜¯éš¾åº¦é™ä½ŽåŽçš„ç®€å•ç‰ˆï¼ŒæŒ‰ç…§å§¥å§¥ç»™å®šçš„æ€è·¯æ¥å†™å³å¯ï¼Œè¿™é‡Œä½¿ç”¨ C++ çš„éƒ¨åˆ†åŠŸèƒ½æ¥å†™å¯èƒ½ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼ˆç”¨çº¯ C ä¹Ÿå¯ä»¥èƒœä»»ï¼Œå¯èƒ½ä¼šç¨å¾®éº»çƒ¦ï¼‰ï¼Œå¦‚ä¸‹ï¼š12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node&#123; double x, y;&#125; coords[maxn];int n;double d;bool visited[maxn] = &#123;false&#125;;bool firstjump(int v) &#123; return sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) - 7.5 &lt;= d;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125; bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool DFS(int v) &#123; visited[v] = true; bool flag = false; if(issafe(v)) return true; else &#123; for(int w = 0; w &lt; n; w++) &#123; if(!visited[w] &amp;&amp; jump(v, w)) &#123; flag = DFS(w); if(flag) break; &#125; &#125; &#125; return flag;&#125;void save007() &#123; bool flag = false; for(int v = 0; v &lt; n; v++) &#123; if(!visited[v] &amp;&amp; firstjump(v)) &#123; flag = DFS(v); if(flag) break; &#125; &#125; flag ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int v = 0; v &lt; n; v++) &#123; cin &gt;&gt; coords[v].x &gt;&gt; coords[v].y; &#125; save007(); return 0;&#125;/*sample:in:25 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12out:Yesin:4 13-12 1212 12-12 -1212 -12out:No*/ 06-3 å…­åº¦ç©ºé—´ç”±äºŽå…­åº¦ç©ºé—´ç†è®ºå§¥å§¥å·²ç»ä»‹ç»è¿‡äº†ï¼Œæ‰€ä»¥é¢˜ç›®æ„æ€ç†è§£èµ·æ¥æ¯”è¾ƒå®¹æ˜“ï¼ŒæŒ‰ç…§å§¥å§¥çš„è®²è§£ï¼Œåªéœ€è¦ç¨ç¨ä¿®æ”¹ BFS ç®—æ³•å°±å¯ä»¥äº†ï¼Œä½†æ³¨æ„æœ€åŽè¾¹ç•Œæ¡ä»¶çš„è®¾ç½®è¦å¥½å¥½ç†è§£ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define maxn 1005const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;int BFS(int v) &#123; memset(visited, false, sizeof(visited)); visited[v] = true; int Queue[maxn], front = -1, rear = -1; Queue[++rear] = v; int count = 1, level = 0, last = v, tail; while(front &lt; rear) &#123; int first = Queue[++front]; for(int w = 1; w &lt;= nv; w++) &#123; if(!visited[w] &amp;&amp; G[first][w] != inf) &#123; Queue[++rear] = w; visited[w] = true; tail = w; count++; &#125; &#125; if(first == last) &#123; level++; last = tail; &#125; if(level == 6) break; &#125; return count;&#125;void sds() &#123; for(int i = 1; i &lt;= nv; i++) &#123; int count = BFS(i); printf("%d: %.2lf%%\n", i, (double)count / nv * 100.0); &#125;&#125;int main() &#123; init(); scanf("%d %d", &amp;nv, &amp;ne); int v1, v2; for(int i = 0; i &lt; ne; i++) &#123; scanf("%d %d", &amp;v1, &amp;v2); G[v1][v2] = G[v2][v1] = 1; &#125; sds(); return 0;&#125;/*samples:in:10 91 22 33 44 55 66 77 88 99 10out:1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æ‰’è°±è®°å½• - ç§‹æŸ³]]></title>
    <url>%2F2020%2F08%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-%E7%A7%8B%E6%9F%B3%2F</url>
    <content type="text"><![CDATA[å‰æ®µæ—¶é—´ï¼Œæœ‹å‹çªç„¶ç»™æˆ‘å‘äº†ä»–æ¯”è¾ƒå–œæ¬¢çš„æ°‘è°£ â€”â€”ã€Šç§‹æŸ³ã€‹ã€‚æ­£å·§ä»–è‡ªå·±åœ¨å¹å£ç´ï¼Œæ‰€ä»¥æƒ³è¯•ç€æ‰’æ‰’è°±å­ï¼Œç»“æžœè°±å­æ‰’å®ŒåŽï¼Œè®©æˆ‘ç»™ä»–çœ‹çœ‹ã€‚æˆ‘è½¬å°”ä¸€æƒ³ï¼Œç›´æŽ¥è‡ªå·±æ‰’äº†æ¯”å¯¹ç®—äº†ã€‚ä¸è¿‡ï¼Œç½‘ä¸Šä¼°è®¡ä¹Ÿæœ‰å¯¹åº”çš„ç®€è°±ã€‚ åŽŸæ›²ï¼š è‡ªæ‰’è°±ï¼š123 212 1(6)(5)123 335 532123 212 1(6)(5)123 212 1(7)1345 532234 444 323345 321165 132 171()ï¼šé™å…«åº¦ æ‰’çš„æ¯”è¾ƒç®€é™‹ï¼Œæ—¥åŽåœ¨åšä¸€å¼ ç®€è°±å§ã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_05-æ ‘ï¼ˆä¸‹ï¼‰]]></title>
    <url>%2F2020%2F05%2F03%2FZJU-DS-05-%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[æœ¬è®²å°†ä¼šåœ¨äºŒå‰æ ‘ç»“æž„çš„åŸºç¡€ä¸Šåœ¨ä»‹ç»å¦å¤–ä¸‰ç§ç‰¹æ®Šçš„ç»“æž„ï¼šå †ã€å“ˆå¤«æ›¼æ ‘å’Œé›†åˆï¼Œå¿«æ¥å­¦ä¹ å§ï¼ Heapåœ¨äº†è§£å¯¹ä¹‹å‰å…ˆæ¥è€ƒè™‘ä¸€ä¸‹â€œä¼˜å…ˆé˜Ÿåˆ—â€çš„é—®é¢˜ã€‚ æ‰€è°“ä¼˜å…ˆé˜Ÿåˆ—ï¼Œå³å–å‡ºå…ƒç´ çš„é¡ºåºæ˜¯ä¾ç…§å…ƒç´ çš„ä¼˜å…ˆæƒï¼ˆå…³é”®å­—ï¼‰å¤§å°ï¼Œè€Œä¸æ˜¯å…ƒç´ è¿›å…¥é˜Ÿåˆ—çš„å…ˆåŽé¡ºåºï¼Œå¯ä»¥ç”¨æ•°ç»„ã€é“¾è¡¨ã€æœ‰åºæ•°ç»„ã€æœ‰åºé“¾è¡¨ã€æ ‘ç­‰æ¥å®žçŽ°ã€‚ å¦‚æžœä½¿ç”¨å¹³è¡¡äºŒå‰æ ‘æ¥å®žçŽ°ï¼Œæ’å…¥ä¸éš¾å®žçŽ°ï¼Œä½†æ˜¯åˆ é™¤æ“ä½œä¼šå­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œé‚£å°±æ˜¯ï¼Œå¤šæ¬¡åˆ é™¤æ“ä½œåŽï¼Œæ ‘çš„ä¸¤è¾¹ä¼šå˜å¾—ä¸å‡è¡¡ï¼Œå¦‚æžœåœ¨æ¥æ—‹è½¬è°ƒæ•´å°±ä¼šé™ä½Žæ•ˆçŽ‡ï¼ŒäºŽæ˜¯è€ƒè™‘è®©æœ€å¤§å€¼ç§°ä¸ºæ ¹ç»“ç‚¹ï¼ˆå¤§æ ¹å †ï¼‰ï¼Œæ¯æ¬¡åˆ é™¤åªéœ€è¦åˆ é™¤æ ¹ç»“ç‚¹å³å¯ï¼Œè¿™æ ·å°±ä¸ä¼šå½±å“æ ‘çš„é«˜åº¦äº†ã€‚å †æœ‰ä¸¤ä¸ªç‰¹æ€§ï¼ˆæ»¡è¶³ç‰¹æ€§æ‰èƒ½ç§°å †ï¼Œå¦åˆ™ä¸è¡Œï¼‰ï¼š ç»“æž„æ€§ï¼šç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘ æœ‰åºæ€§ï¼šä»»ä¸€ç»“ç‚¹çš„å…³é”®å­—æ˜¯å…¶å­æ ‘æ‰€æœ‰ç»“ç‚¹çš„æœ€å¤§å€¼ï¼ˆæˆ–æœ€å°å€¼ï¼‰ã€‚ æœ€å¤§å †ï¼ˆMaxHeapï¼‰ï¼Œä¹Ÿç§°å¤§æ ¹å †ï¼Œæ ¹ä¸ºæœ€å¤§å€¼ æœ€å°å †ï¼ˆMinHeapï¼‰ï¼Œä¹Ÿç§°å°æ ¹å †ï¼Œæ ¹ä¸ºæœ€å°å€¼ å †çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šæœ€å¤§å †ï¼ˆMaxHeapï¼‰æ•°æ®å¯¹è±¡é›†ï¼šå®Œå…¨äºŒå‰æ ‘ï¼Œæ¯ä¸ªç»“ç‚¹å…ƒç´ å€¼ä¸å°äºŽå…¶å­ç»“ç‚¹çš„å…ƒç´ å€¼æ“ä½œé›†ï¼šæœ€å¤§å †$H âˆˆ MaxHeap$ï¼Œå…ƒç´ $item âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œæœ‰ï¼š MaxHeap Create(int MaxSize)ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„æœ€å¤§å † Boolean IsFull(MaxHeap H)ï¼Œåˆ¤æ–­æœ€å¤§å †Hæ˜¯å¦å·²æ»¡ Insert(MaxHeap H, ElementType item)ï¼Œå°†å…ƒç´ itemæ’å…¥æœ€å¤§å †H Boolean IsEmpty(MaxHeap H)ï¼Œåˆ¤æ–­æœ€å¤§å †Hæ˜¯å¦ä¸ºç©º ElementType DeleteMax(MaxHeap H)ï¼Œè¿”å›žHä¸­æœ€å¤§å…ƒç´ ï¼ˆé«˜ä¼˜å…ˆçº§ï¼‰ å †çš„å®žçŽ°C è¯­è¨€ä¸‹çš„å †å®šä¹‰å¯ä»¥å¦‚ä¸‹ï¼š123456typedef struct HeapStruct *MaxHeap;struct HeapStruct&#123; ElementType *Data; int Size; int Capacity;&#125;; æœ€å¤§å †åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºå †ï¼‰12345678MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125; åˆ¤æ–­å †æ»¡123bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125; åˆ¤æ–­å †ç©º123bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125; æ’å…¥ç”±äºŽå †çš„å®žçŽ°æ˜¯åŸºäºŽå®Œå…¨äºŒå‰æ ‘çš„æ€æƒ³ï¼Œæ’å…¥å…ƒç´ çš„æ—¶å€™ç›´æŽ¥æ”¾åœ¨æœ€åŽå°±å¥½ï¼Œä½†æ˜¯è¦æ³¨æ„æ­¤æ—¶æ ‘çš„ç»“æž„ç¬¦åˆæœ€å¤§å †çš„ç‰¹æ€§ã€‚æ‰€ä»¥éœ€è¦å°†å­ç»“ç‚¹ä¸Žçˆ¶ç»“ç‚¹æ¯”è¾ƒï¼Œå¦‚æžœå­ç»“ç‚¹æ¯”çˆ¶ç»“ç‚¹å¤§ï¼Œå°±å°†å­ç»“ç‚¹ä¸Žçˆ¶ç»“ç‚¹äº’æ¢ã€‚1234567891011121314bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125; åˆ é™¤å¯¹å¤§æ ¹å †è€Œè¨€ï¼Œåˆ é™¤å°±æ˜¯åˆ é™¤æœ€å¤§å€¼å…ƒç´ ï¼ˆä¹Ÿå°±æ˜¯å †é¡¶ï¼‰ã€‚åˆ é™¤äº†å †é¡¶åŽï¼Œç›´æŽ¥å°†æœ€åŽä¸€ä¸ªå…ƒç´ æ”¾åˆ°å †é¡¶æ˜¾ç„¶æ— æ³•ä¿è¯å †çš„ç»“æž„æ€§ï¼Œæ‰€ä»¥è¿˜éœ€è¦å¯¹æ­¤æ—¶çš„å †åšè°ƒæ•´ã€‚123456789101112131415161718ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125; ç›´æŽ¥å»ºå †ä¸Šé¢æåˆ°çš„å»ºå †æ–¹æ³•å®žé™…ä¸Šæ˜¯å°†å…ƒç´ ä¸€ä¸ªä¸ªçš„æ’å…¥åˆ°å †ä¸­ï¼Œæ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(NLogN)$ã€‚ å¯ä»¥ä½¿ç”¨ä¸‹é¢çš„æ€è·¯æ¥å»ºå †ï¼š å°† N ä¸ªå…ƒç´ æŒ‰è¾“å…¥é¡ºåºå­˜å…¥ï¼Œå…ˆæ»¡è¶³å®Œå…¨äºŒå‰æ ‘çš„ç‰¹æ€§ è°ƒæ•´å„ç»“ç‚¹ä½ç½®ï¼Œä»¥æ»¡è¶³æœ€å¤§å †çš„æœ‰åºç‰¹æ€§ã€‚ å­ç»“ç‚¹æ— é¡»è°ƒæ•´ï¼Œæ‰€ä»¥åªéœ€ä¾æ¬¡è°ƒæ•´æ‰€æœ‰å¶ç»“ç‚¹å³å¯ï¼Œè°ƒæ•´çš„æ€è·¯ä¸Žåˆ é™¤ç»“ç‚¹æ—¶è°ƒæ•´å †çš„ç»“æž„çš„æ€è·¯ä¸€è‡´ã€‚å¦å¤–ï¼Œä¸ºäº†ä½¿å¾—ä»£ç ç®€æ´ï¼Œå¯ä»¥å°†ç»“ç‚¹ä¸‹ç§»çš„æ“ä½œç‹¬ç«‹å°è£…å‡ºæ¥ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; å°½ç®¡ä»Žä»£ç ä¸Šçœ‹æ—¶é—´å¤æ‚åº¦å¥½åƒæ˜¯$O(N^2)$ï¼Œä½†å®žé™…æƒ…å†µçš„æ—¶é—´å¤æ‚åº¦æ˜¯$O(NLogN)$ã€‚ æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef int ElementType;typedef struct HNode *Heap;struct HNode&#123; ElementType *Data; int Size; int Capacity;&#125;;typedef Heap MaxHeap;#define MaxData 1000MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125;bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125;#define ERROR -1bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125;ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125;void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MaxHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n'); &#125;int main() &#123; MaxHeap H = Createheap(10); Insert(H, 10); Insert(H, 5); Insert(H, 20); Insert(H, 30); Insert(H, 15); Insert(H, 18); Printheap(H); return 0;&#125; æœ€å°å †æœ€å°å †çš„ç»“æž„ä¸Žæœ€å¤§å †çš„ç»“æž„åŒºåˆ«åªåœ¨äºŽæ ¹ç»“ç‚¹å€¼æ¯”å¶ç»“ç‚¹éƒ½å°ï¼Œæœ¬è´¨ä¸Šè¿˜æ˜¯ä¸€æ£µå®Œå…¨äºŒå‰æ ‘ã€‚æ‰€ä»¥ï¼Œæœ€å°å †çš„æ’å…¥ã€åˆ é™¤å’Œç›´æŽ¥å»ºå †çš„ä»£ç ç•¥æœ‰å·®å¼‚ï¼Œä½†æ€è·¯éƒ½æ˜¯ä¸€è‡´çš„ã€‚ æ’å…¥å‰é¢ä»‹ç»æœ€å¤§å †çš„æ—¶å€™å·²ç»çŸ¥é“äº†ï¼Œæ¯å‘å †ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹å°±éœ€è¦è°ƒæ•´å †çš„ç»“æž„ï¼Œè°ƒæ•´è¿™ä¸ªæ“ä½œå¯ä»¥ç‹¬ç«‹å°è£…èµ·æ¥ï¼Œè¿™æ ·å¯ä»¥ä½¿å¾—ä»£ç æ›´åŠ ç®€æ´ã€‚æ•´ä½“ä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125; åˆ é™¤æ³¨æ„æœ€å°å †ä¸­åˆ é™¤æ“ä½œçš„ Percdown å‡½æ•°ä¸Žæœ€å¤§å †æ˜¯æœ‰åŒºåˆ«çš„ï¼Œä¸»è¦åœ¨äºŽå½“å¶ç»“ç‚¹å°äºŽæ ¹èŠ‚ç‚¹æ—¶ï¼Œæ‰éœ€è¦å°†æ ¹ç»“ç‚¹ä¸‹ç§»ï¼ˆè€Œæ­¤æ—¶æœ€å¤§å †åˆšå¥½å°±æ˜¯åˆé€‚çš„ä½ç½®ï¼‰ã€‚12345678910111213141516171819202122void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125; ç›´æŽ¥å»ºå †ç›´æŽ¥å»ºå †çš„æ€è·¯ä¸€è‡´ï¼Œä¸åŒçš„åªæ˜¯æœ€å°å †çš„ Percdown å‡½æ•°ä¸Žæœ€å¤§å †ä¸åŒï¼Œä½†æ˜¯å¯ä»¥å‘çŽ° Buildheap è¿™ä¸ªå‡½æ•°æ²¡æœ‰å˜åŒ–ï¼Œè¿™å…¶å®žå°±æ˜¯å°† Percdown ç‹¬ç«‹å°è£…èµ·æ¥çš„å¥½å¤„ã€‚1234567891011121314151617void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap Createheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * MAXN); H-&gt;Size = 0; H-&gt;Capacity = Maxsize; return H;&#125; bool Isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Isempty(MinHeap H) &#123; return H-&gt;Size == 0;&#125;void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MinHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; MinHeap H = Createheap(5); Insert(H, 46); Insert(H, 23); Insert(H, 26); Insert(H, 24); Insert(H, 10); Printheap(H); Deletemin(H); Printheap(H); return 0;&#125; Huffman Treeç¼–ç é—®é¢˜æ˜¯è®¡ç®—æœºå­¦ç§‘å†…ååˆ†é‡è¦çš„é—®é¢˜ï¼Œè€Œå“ˆå¤«æ›¼æ ‘å°±æ˜¯ä¸ºäº†è§£å†³ç¼–ç çš„é—®é¢˜è€Œäº§ç”Ÿçš„ã€‚ä¸Žä¹‹ç±»ä¼¼çš„é—®é¢˜è¿˜æœ‰åˆ¤å®šæ ‘å’Œæœç´¢æ ‘å¦‚ä½•æž„é€ æœ€ä¼˜çš„é—®é¢˜ï¼Œè€Œæ‰€è°“æœ€ä¼˜ï¼Œå³æ˜¯æŸ¥æ‰¾æ ‘æ•ˆçŽ‡æœ€é«˜ã€‚ é¦–å…ˆï¼Œå“ˆå¤«æ›¼æ ‘æ˜¯ä¸€ç§å¾ˆç‰¹æ®Šçš„äºŒå‰æ ‘ï¼ˆæ²¡é”™ï¼Œå®ƒæ˜¯äºŒå‰æ ‘ï¼‰ï¼Œå®ƒæœ‰ N ä¸ªå¶å­ç»“ç‚¹ï¼Œè‹¥è¯¥æ ‘çš„å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼‰è¾¾åˆ°æœ€å°ï¼Œç§°è¿™æ ·çš„äºŒå‰æ ‘ä¸ºå“ˆå¤«æ›¼æ ‘ï¼ˆHuffman Treeï¼‰ï¼Œä¹Ÿå«æœ€ä¼˜äºŒå‰æ ‘ã€‚ é‚£ä¹ˆï¼Œä»€ä¹ˆæ˜¯å¸¦æƒè·¯å¾„é•¿åº¦ï¼ˆWPLï¼ŒWeighted Path Length of Treeï¼‰å‘¢ï¼Ÿ è®¾äºŒå‰æ ‘æœ‰ N ä¸ªå¶å­ç»“ç‚¹ï¼Œæ¯ä¸ªå¶å­ç»“ç‚¹å¸¦æœ‰æƒå€¼$w_k$ï¼Œä»Žæ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶å­ç»“ç‚¹çš„é•¿åº¦ä¸º$l_k$ï¼Œåˆ™æ¯ä¸ªå¶å­ç»“ç‚¹çš„å¸¦æƒè·¯å¾„é•¿åº¦ä¹‹å’Œï¼š$WPL = \sum_{k=1}^n w_k l_k$ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå“ˆå¤«æ›¼æ ‘å®žé™…ä¸Šå°±æ˜¯æŒ‡ WPL æœ€å°çš„æ ‘ã€‚ æž„é€ æž„é€ å“ˆå¤«æ›¼æ ‘çš„æ–¹æ³•ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œæ¯æ¬¡æŠŠæƒå€¼æœ€å°çš„ä¸¤æ£µäºŒå‰æ ‘åˆå¹¶å³å¯ã€‚ ç”±äºŽæ¯æ¬¡å»ºæ ‘éƒ½éœ€è¦é€‰å‡ºæƒå€¼æœ€å°çš„ç»“ç‚¹ï¼Œæ‰€ä»¥åœ¨ä»£ç å®žçŽ°è¿‡ç¨‹ä¸­ï¼Œå€ŸåŠ©æœ€å°å †æ¥æ‰¾å‡ºæƒå€¼æœ€å°çš„ç»“ç‚¹æ¯”è¾ƒæ–¹ä¾¿å¿«æ·ã€‚ è¿™é‡Œå·ä¸ªæ‡’ï¼Œç›´æŽ¥ç”¨ä½•å¤´ç»™å‡ºçš„ä»£ç ï¼š12345678910111213141516171819typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman(MinHeap H) &#123; int i; HuffmanTree T; BuildMinHeap(H); for(i = 1; i &lt; H-&gt;Size; i++) &#123; T = malloc(sizeof(struct TreeNode)); T-&gt;Left = Deletemin(H); T-&gt;Right = Deletemin(H); T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; Insert(H, T); &#125; T = DeleteMin(H); // insert new root node return T;&#125; ç‰¹ç‚¹ç”±äºŽå“ˆå¤«æ›¼æ ‘æž„é€ æ–¹æ³•çš„ç‰¹æ®Šæ€§ï¼Œå®ƒå…·æœ‰ä»¥ä¸‹å‡ ä¸ªç‰¹ç‚¹ï¼š æ²¡æœ‰åº¦ä¸º 1 çš„ç»“ç‚¹ n ä¸ªå¶å­ç»“ç‚¹çš„å“ˆå¤«æ›¼æ ‘å…±æœ‰ $2n-1$ ä¸ªç»“ç‚¹ å“ˆå¤«æ›¼æ ‘çš„ä»»æ„éžå¶ç»“ç‚¹çš„å·¦å³å­æ ‘äº¤æ¢åŽä»æ˜¯å“ˆå¤«æ›¼æ ‘ å¯¹åŒä¸€ç»„æƒå€¼${w_1, w_2, w_3, \dots, w_n}$ï¼Œæ˜¯å­˜åœ¨ä¸åŒæž„çš„ä¸¤æ£µå“ˆå¤«æ›¼æ ‘ï¼Œä½†æ³¨æ„å…¶ WPL æ˜¯ä¸€å®šæ˜¯ä¸€æ ·ä¸”æœ€å°çš„ è®°å¥½è¿™äº›ç‰¹ç‚¹ï¼Œç®—æ³•ç¬”è¯•é¢˜å¯èƒ½ä¼šé‡è§ã€‚ ç¼–ç å¦‚å‰æ‰€è¨€ï¼Œå“ˆå¤«æ›¼æ ‘çš„å‡ºçŽ°æ˜¯ä¸ºäº†è§£å†³ç¼–ç é—®é¢˜ï¼Œé‚£ä¹ˆå…·ä½“è§£å†³äº†é‚£äº›é—®é¢˜å‘¢ï¼Ÿ å“ˆå¤«æ›¼æ ‘è§£å†³çš„ç¼–ç é—®é¢˜å°±æ˜¯é¿å…äº†åœ¨è¿›è¡Œä¸ç­‰é•¿ç¼–ç æ—¶çš„å¯èƒ½ä¼šäº§ç”Ÿçš„äºŒä¹‰æ€§ã€‚æ‰€è°“äºŒä¹‰æ€§å°±æ˜¯æŒ‡åŒä¸€ä¸²ç¼–ç ï¼Œè§£é‡Šç»“æžœä¼šæœ‰ä¸åŒã€‚æ ¹æ®å“ˆå¤«æ›¼æ ‘çš„ç»“æž„ï¼Œå¦‚æžœç”¨å­—ç¬¦ä»£è¡¨å¶ç»“ç‚¹ï¼Œå·¦å³åˆ†æ”¯åˆ†åˆ«ä»£è¡¨ 0 å’Œ 1ï¼Œç”¨æ ¹ç»“ç‚¹åˆ°æ¯ä¸ªå¶ç»“ç‚¹çš„è·¯å¾„æ–¹å‘ä»£è¡¨æ¯ä¸ªå­—ç¬¦çš„ç¼–ç ï¼Œå¯ä»¥å¾ˆç¥žå™¨çš„å‘çŽ°ï¼Œå„ç§å­—ç¬¦ç¼–ç ç»„åˆéƒ½ä¸ä¼šäº§ç”ŸäºŒä¹‰æ€§ã€‚ æ­¤æ—¶ï¼Œå¯¹æ¯ä¸ªå­—ç¬¦æ‰€ç¼–çš„ç ä¹Ÿå«åšå‰ç¼€ç ï¼ˆå³ä»»ä½•å­—ç¬¦çš„ç¼–ç éƒ½ä¸æ˜¯å¦ä¸€å­—ç¬¦ç¼–ç çš„å‰ç¼€ï¼‰ã€‚å®žé™…ä¸Šè€Œè¨€ï¼Œå½“æ‰€æœ‰å­—ç¬¦éƒ½å¤„åœ¨å¶ç»“ç‚¹æ—¶ï¼Œå°±ä¸ä¼šäº§ç”Ÿéžå‰ç¼€ç ã€‚ æŒ‰ç…§å“ˆå¤«æ›¼æ ‘è¿›è¡Œçš„ç¼–ç ï¼Œè¿˜æœ‰ä¸€ä¸ªä¼˜ç‚¹ï¼Œé‚£å°±æ˜¯ä»£ä»·æœ€å°ï¼Œæ¯”èµ·ç­‰é•¿ç¼–ç è¦èŠ‚çœäº†å¤§é‡çš„ç©ºé—´ã€‚ è¿™å°±æ˜¯å“ˆå¤«æ›¼æ ‘æ‰€è§£å†³çš„ç¼–ç é—®é¢˜ã€‚ Setè¿™é‡Œé›†åˆçš„æ¦‚å¿µä¸Žæ•°å­¦ä¸Šé›†åˆçš„æ¦‚å¿µåŸºæœ¬ä¸€è‡´ï¼Œä½†å®žé™…ç»å¸¸ç”¨åˆ°çš„é›†åˆå«åšâ€œå¹¶æŸ¥é›†â€ï¼Œå…¶å®žå°±æ˜¯é›†åˆçš„å¹¶å’ŒæŸ¥ä¸¤ä¸ªæ“ä½œã€‚PSï¼šå­¦å®Œæ•´å¥—è¯¾ç¨‹ä¹‹åŽï¼Œå›žè¿‡å¤´ä¼šå‘çŽ°ï¼Œé›†åˆæ›´åƒæ˜¯åŽé¢è¦å­¦çš„â€œå›¾â€ï¼Œä½†å…¶ä¸­ä¸€äº›æ¦‚å¿µåˆä¸Žæ ‘è”ç³»å¯†åˆ‡ã€‚ åˆ©ç”¨é™æ€æ•°ç»„å­˜å‚¨é›†åˆè¾ƒä¸ºæ–¹ä¾¿ï¼Œå€Ÿç”¨ä¸€ä¸‹ä½•å¤´çš„ä»£ç ï¼š1234typedef struct &#123; ElementType Data; int Parent;&#125; SetType; æŸ¥æ‰¾æŸ¥æ‰¾æŸä¸ªå…ƒç´ æ‰€åœ¨çš„é›†åˆï¼Œè¦å…ˆæ‰¾åˆ°è¿™ä¸ªç»“ç‚¹çš„ä½ç½®ï¼Œç„¶åŽåœ¨ä»Žä¸‹å¾€ä¸Šä¾æ¬¡æŸ¥æ‰¾æ ¹ç»“ç‚¹ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567int Find(SetType S[], ElementType X) &#123; int i; for(i = 0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++) if(i &gt;= MaxSize) return -1; // not find the element for(; S[i].Parent &gt;= 0; i = S[i].Parent); return i; // return the root static pointer&#125; å¹¶ä¸¤ä¸ªé›†åˆçš„å¹¶è¿ç®—éœ€è¦åœ¨æŸ¥æ‰¾æ“ä½œçš„åŸºç¡€ä¸Šå®žçŽ°ï¼Œå…ˆåˆ†åˆ«æ‰¾åˆ°ä¸¤ä¸ªé›†åˆçš„æ ¹ç»“ç‚¹ï¼Œå†å°†å…¶ä¸­ä¸€ä¸ªæ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹æŒ‡é’ˆè®¾ç½®æˆå¦ä¸€ä¸ªæ ¹ç»“ç‚¹çš„æ•°ç»„ä¸‹æ ‡ï¼Œå‡è®¾ä¸¤ä¸ªé›†åˆå†…åˆ†åˆ«æœ‰å…ƒç´  $X_1$ å’Œ $X_2$ï¼Œä»£ç å¦‚ä¸‹ï¼š123456void Union(SetType S[], ElementType X1, ElementType X2) &#123; int Root1, Root2; Root1 = Find(S, X1); Root2 = Find(S, X2); if(Root1 != Root2) S[Root2].Parent = Root1;&#125; æŒ‰ç…§ä¸Šé¢çš„æ€è·¯ï¼Œå½“ä¸æ–­çš„å¹¶å…¥æ–°é›†åˆæ—¶ï¼Œå¯èƒ½ä¼šäº§ç”Ÿæ ‘ä¸æ–­å¢žé«˜çš„æƒ…å†µï¼Œè¿™æ ·ä¼šå¯¼è‡´æŸ¥æ‰¾çš„æ•ˆçŽ‡é™ä½Žï¼Œä¸€ç§å¯è¡Œçš„åŠžæ³•å°±æ˜¯å°†å°é›†åˆå¹¶å…¥å¤§é›†åˆã€‚ä½†è¿™æ ·åšçš„æ•ˆçŽ‡ä»ç„¶ä¸é«˜ï¼Œä¸è¿‡åŽé¢å§¥å§¥ä¼šäº¤ç»™æˆ‘ä»¬è·¯å¾„åŽ‹ç¼©å’ŒæŒ‰ç§©å½’å¹¶çš„æ–¹æ³•ã€‚ Homework05-7 å †ä¸­çš„è·¯å¾„é¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œåˆ©ç”¨é¢˜ç›®ç»™å®šçš„ä¸€ä¸²æ•°å­—å»ºç«‹æœ€å°å †ï¼Œç„¶åŽå¯¹ä»»æ„ç»™å®šçš„ä¸‹æ ‡ iï¼Œæ‰“å° H[i] åˆ°æ ¹ç»“ç‚¹çš„è·¯å¾„å³å¯ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap initheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * (Maxsize + 1)); H-&gt;Capacity = Maxsize; H-&gt;Size = 0; return H;&#125;bool isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool insert(MinHeap H, int data) &#123; if(isfull(H)) return false; else &#123; int i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &gt; data &amp;&amp; i &gt; 1; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = data; &#125;&#125;void Printpath(MinHeap H, int index) &#123; for(; index &gt;= 1; index /= 2) &#123; printf("%d", H-&gt;Data[index]); if(index != 1) putchar(' '); &#125; putchar('\n');&#125; int main() &#123; int i, n, m, temp; scanf("%d %d", &amp;n, &amp;m); MinHeap H = initheap(n); for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); insert(H, temp); &#125; for(i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;temp); Printpath(H, temp); &#125; return 0;&#125;/*samples:in:5 346 23 26 24 105 4 3out:24 23 1046 23 1026 10*/ 05-8 File Transferè¿™é“é¢˜ä¸Žè€å¸ˆä¸Šè¯¾è®²çš„è¿žç½‘é—®é¢˜å¾ˆç±»ä¼¼ï¼Œä½†æ˜¯è¦çœ‹æ¸…æ¥šé¢˜ç›®ä¸­I C Såˆ†åˆ«ä»£è¡¨çš„å«ä¹‰ã€‚ Iä»£è¡¨è¾“å…¥è¿žæŽ¥ï¼Œå°±ç›¸å½“äºŽå°†ä¸¤ä¸ªå…ƒç´ å¹¶æˆä¸€ä¸ªé›†åˆï¼›Cä»£è¡¨æ£€æŸ¥ä¸¤ä¸ªå…ƒç´ æ˜¯å¦åœ¨ä¸€ä¸ªé›†åˆï¼›Sä»£è¡¨åœæ­¢æµ‹è¯•ã€‚ æ ¹æ®é¢˜ç›®çš„æµ‹è¯•æ ·ä¾‹ï¼Œæˆ‘ä»¬å¾—çŽ°æž„é€ é›†åˆï¼Œç„¶åŽåœ¨åˆ¤æ–­å…ƒç´ æ˜¯å¦åœ¨åŒä¸€ä¸ªé›†åˆå†…ã€‚å½“ç„¶äº†ï¼Œä¸€å¼€å§‹æ‰€æœ‰çš„å…ƒç´ éƒ½æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„é›†åˆï¼Œåªæœ‰å½“â€œè¾“å…¥è¿žæŽ¥â€åŽä¸¤ä¸ªå…ƒç´ æ‰ç®—æ˜¯å¤„äºŽåŒä¸€ä¸ªé›†åˆã€‚ æ˜Žç™½ä»¥ä¸ŠåŽŸåˆ™åŽï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚æ¥è¿›è¡Œè¾“å‡ºå³å¯ã€‚ å¦å¤–ï¼Œå§¥å§¥å‡ºè¿™é“é¢˜çš„ç›®çš„å°±æ˜¯ä¸ºäº†ç»™å¤§å®¶ä»‹ç»è·¯å¾„åŽ‹ç¼©ä¸ŽæŒ‰ç§©å½’å¹¶ï¼Œä¸ç”¨è¿™ä¸¤ç§æ–¹æ³•ï¼Œæ˜¾ç„¶ä¸èƒ½ ACã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10005typedef int Set[MAXN];typedef int SetType;void init(Set S) &#123; int i; for(i = 0; i &lt; MAXN; i++) &#123; S[i] = -1; &#125;&#125;void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125;SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125;int main() &#123; Set set; init(set); int i, n, c1, c2; scanf("%d%*c", &amp;n); char act; while((act = getchar()) != 'S') &#123; scanf("%d %d%*c", &amp;c1, &amp;c2); int root1, root2; root1 = Find(set, c1); root2 = Find(set, c2); if(act == 'C') &#123; if(root1 == root2 &amp;&amp; (root1 &gt; 0 || root2 &gt; 0)) printf("yes\n"); else printf("no\n"); &#125; else if(act == 'I') &#123; Union(set, root1, root2); &#125; &#125; int cnt = 0; for(i = 1; i &lt;= n; i++) &#123; if(set[i] &lt; 0) cnt++; &#125; if(cnt == 1) printf("The network is connected.\n"); else printf("There are %d components.\n", cnt); return 0;&#125; æŒ‰ç§©å½’å¹¶å§¥å§¥è®²è§£çš„æŒ‰ç§©å½’å¹¶æœ‰ä¸¤ç§æ–¹æ³•ï¼Œå…³é”®å–å†³äºŽå¦‚ä½•ç†è§£â€œç§©â€ï¼Œå¯ä»¥å°†å…¶è®¤ä¸ºæ˜¯æ ‘é«˜ï¼Œä¹Ÿå¯ä»¥è®¤ä¸ºæ˜¯æ ‘ç»“ç‚¹çš„ä¸ªæ•°ã€‚ä½†ä¸¤è€…æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯å°†å°è§„æ¨¡çš„æ ‘å¹¶åˆ°å¤§è§„æ¨¡çš„æ ‘ä¸Šã€‚123456789void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125; è·¯å¾„åŽ‹ç¼©è·¯å¾„åŽ‹ç¼©æ‰€è§£å†³çš„é—®é¢˜æ˜¯å°½å¯èƒ½çš„é™ä½Žæ ‘çš„é«˜åº¦ï¼Œè¿™æ ·å°±ä¼šä½¿å¾—å…¶æŸ¥æ‰¾æ•ˆçŽ‡æé«˜ã€‚ åœ¨ä¹‹å‰ä»‹ç»çš„æŸ¥æ‰¾æ“ä½œä¸­ï¼Œæ¯æ¬¡éœ€è¦å…ˆæ‰¾åˆ°å¶ç»“ç‚¹åœ¨åŽ»æ‰¾æ ¹ç»“ç‚¹ï¼Œæ‰¾åˆ°äº†ä¹‹åŽå¹¶ä¸å¯¹é›†åˆï¼ˆä¹Ÿå°±æ˜¯æŸ¥æ‰¾æ ‘ï¼‰çš„ç»“æž„åšå‡ºä¼˜åŒ–ã€‚ä½†è·¯å¾„åŽ‹ç¼©å€ŸåŠ©é€’å½’ï¼Œæ¯æ‰¾åˆ°ä¸€ä¸ªç»“ç‚¹ï¼Œå°±å°†å®ƒç›´æŽ¥æŒ‚åœ¨æ ¹ç»“ç‚¹çš„ä¸‹é¢ï¼Œè¿™æ ·å½“æ‰¾åˆ°ç›®æ ‡ç»“ç‚¹çš„æ ¹ç»“ç‚¹æ—¶ï¼Œè¿™æ£µæŸ¥æ‰¾æ ‘çš„é«˜åº¦å°±æ˜¯ 2 äº†ï¼Œæžå¤§çš„æé«˜äº†ä¸‹æ¬¡æŸ¥æ‰¾æ—¶çš„æ•ˆçŽ‡ã€‚1234SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125; 05-9 Huffman Codesé¢˜ç›®å¤§æ„å°±æ˜¯ç»™å®šå­—ç¬¦å‡ºçŽ°çš„é¢‘çŽ‡ï¼Œåˆ¤æ–­ç»™å®šçš„æµ‹è¯•æ ·ä¾‹æ˜¯å¦æ˜¯æœ€ä¼˜è§£ï¼Œä½†è¦æ³¨æ„æœ€ä¼˜è§£å¯èƒ½å¹¶ä¸æ˜¯ç”±å“ˆå¤«æ›¼æ ‘æž„æˆçš„ã€‚ å½“åˆåšè¿™ä¸ªé¢˜æ—¶ï¼Œæƒ³æ–¹è®¾æ³•çš„å·æ‡’ï¼Œéžå¸¸ä¸æƒ…æ„¿å»ºå“ˆå¤«æ›¼æ ‘ï¼Œç»“æžœæœ€åŽè¿˜çœŸæ‰¾åˆ°äº† AC çš„æ–¹æ³•ã€‚ è™½ç„¶ä¸å»ºå“ˆå¤«æ›¼æ ‘ï¼Œä½†æ˜¯ WPL è¿˜æ˜¯éœ€è¦è®¡ç®—å‡ºæ¥ç”¨æ¥åˆ¤å®šæ˜¯å¦æœ€ä¼˜çš„ã€‚é‚£ä¹ˆå¦‚ä½•è®¡ç®— WPL å‘¢ï¼Ÿå¯¹ï¼Œç»§ç»­å·æ‡’ï¼Œç›´æŽ¥ç”¨ C++ STL é‡Œé¢çš„ä¼˜å…ˆé˜Ÿåˆ—ï¼ˆå…¶å®žå°±æ˜¯æœ€å°å †ï¼‰ï¼Œæ ¸å¿ƒæ€è·¯å°±æ˜¯å“ˆå¤«æ›¼æ ‘çš„ WPL ä¹Ÿç­‰äºŽé™¤äº†æ ¹ç»“ç‚¹ä»¥å¤–ï¼Œå…¨éƒ¨ç»“ç‚¹çš„æƒå€¼ä¹‹å’Œã€‚è¿™ç§è®¡ç®—æ–¹æ³•ä¸Žè€å¸ˆä¸Šè¯¾è®²çš„æ˜¯å®Œå…¨ä¸åŒäº†ï¼Œåˆ©ç”¨è¿™ç§æ€è·¯ï¼Œå¯ä»¥å¾ˆç®€å•çš„è®¡ç®—å‡ºä¸€æ£µå“ˆå¤«æ›¼æ ‘çš„ WPLï¼Œè€Œä¸”è¿˜ä¸ç”¨å»ºæ ‘ã€‚ æœ‰äº†æœ€ä¼˜è§£çš„ WPL åŽï¼Œåªéœ€è¦åœ¨è®¡ç®—å‡ºæ¯ä¸ªæ ·ä¾‹çš„ WPLï¼Œå¹¶æ¯”å¯¹æ˜¯å¦ä¸€è‡´å³å¯çŸ¥é“æ ·ä¾‹æ˜¯å¦æ­£ç¡®ã€‚ æ˜Žç™½ä»¥ä¸Šé—®é¢˜åŽï¼ŒåŸºæœ¬å·²ç»è§£å†³è¿™é“é¢˜ç›®äº†ã€‚ä¸è¿‡è¿˜æœ‰ä¸€ä¸ªåœ°æ–¹è¦æ³¨æ„ï¼Œå¯¹äºŽéžå‰ç¼€ç ä¸” WPL ç›¸åŒçš„æ ·ä¾‹ï¼Œå°±ä¸æ˜¯æ­£ç¡®ç»“æžœäº†ã€‚æ‰€ä»¥ï¼Œåœ¨è®¡ç®—æ ·ä¾‹çš„ WPL åŽï¼Œè¿˜éœ€è¦åˆ¤æ–­æ ·ä¾‹ä¸­æ˜¯å¦æœ‰éžå‰ç¼€ç çš„å­˜åœ¨ï¼Œå¦‚æžœæœ‰ï¼Œé‚£å°±ä¸æ˜¯æ­£ç¡®ç»“æžœï¼Œéœ€åˆ¤å®šä¸º Noã€‚ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int maxn = 65 + 5;int hashTable[128] = &#123;0&#125;;bool issubstr(string a, string b) &#123; int flag = true; for(int i = 0; i &lt; b.length(); i++) &#123; if(b[i] != a[i]) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; int n; cin &gt;&gt; n; char ch; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch; cin &gt;&gt; hashTable[ch]; q.push(hashTable[ch]); &#125; int wpl = 0; while(q.size() &gt; 1) &#123; int n1, n2, n; n1 = q.top(); q.pop(); n2 = q.top(); q.pop(); n = n1 + n2; q.push(n); wpl += n; &#125; int m; cin &gt;&gt; m; while(m--) &#123; string codes[maxn]; int wpl_tmp = 0; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch &gt;&gt; codes[i]; wpl_tmp += codes[i].length() * hashTable[ch]; &#125; bool prefix = false; for(int i = 0; i &lt; n; i++) &#123; string str_tmp = codes[i]; for(int j = 0; j &lt; n; j++) &#123; if(str_tmp != codes[j] &amp;&amp; issubstr(codes[j], str_tmp)) &#123; prefix = true; break; &#125; &#125; if(prefix) break; &#125; bool repetition = false; for(int i = 0; i &lt; n - 1; i++) &#123; string str_tmp = codes[i]; if(str_tmp == codes[i + 1]) &#123; repetition = true; break; &#125; &#125; if(wpl_tmp == wpl &amp;&amp; !prefix &amp;&amp; !repetition) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_05_01-æµ‹è¯•èµ›]]></title>
    <url>%2F2020%2F05%2F03%2FPAT-05-01-%E6%B5%8B%E8%AF%95%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[æœ¬æ¥è¿™åŽŸæ–‡ä¸­åº”è¯¥åœ¨æ˜¨å¤©å°±å‘å‡ºæ¥çš„ï¼ŒäºŽæ˜¯ä¹Žï¼Œå·äº†ä¸€ä¸‹æ‡’ï¼Œå°±åˆ°ä»Šå¤©äº†...åºŸè¯ä¸å¤šè¯´ç›´æŽ¥çœ‹é¢˜ï¼ 7-1 knuth æ´—ç‰Œæ³•Knuth æ´—ç‰Œæ³•æ˜¯ç”Ÿæˆ { 1, 2, â€¦, n } çš„ä¸€ä¸ªéšæœºé‡æŽ’åˆ—çš„ç®—æ³•ã€‚ä¸Žæ¯æ¬¡åå¤éšæœºç”Ÿæˆä¸€ä¸ªæ•°å­—ï¼Œç›´åˆ°èŽ·å¾—ä¸€ä¸ªä¸é‡å¤çš„æ–°æ•°å­—çš„ç®—æ³•ä¸åŒï¼ŒKnuth æ´—ç‰Œæ³•ä»ŽåŽŸå§‹åºåˆ— { 1, 2, â€¦, n } å¼€å§‹ï¼Œé€æ¬¡æ´—ç‰Œã€‚æ´—ç‰Œçš„æ–¹æ³•æ˜¯ä»Žå·¦åˆ°å³ï¼Œæ¯è½®ä»Žæ²¡ç¡®å®šçš„æ•°å­—ä¸­éšæœºæŠ½å–ä¸€ä¸ªæ•°ï¼ŒæŠŠå®ƒæ”¾åˆ°ç¡®å®šçš„ä½ç½®ä¸Šã€‚ä¾‹å¦‚ä»¤ n ç­‰äºŽ 4ã€‚æˆ‘ä»¬ä»Ž { 1, 2, 3, 4 } å¼€å§‹ã€‚è®° i åˆ° N ä¹‹é—´çš„éšæœºæŠ½ç‰Œæ•°ä¸º random(i,N)ã€‚å‡è®¾æˆ‘ä»¬ç”Ÿæˆçš„éšæœºæ•°åºåˆ— random(i,4) (i=1, 2, 3, 4) ä¸º { 2, 4, 3, 4 }ã€‚åˆ™ Knuth æ´—ç‰Œæ³•æ˜¯è¿™æ ·æ‰§è¡Œçš„ï¼š random(1,4) = 2; å°†ä½ç½® 1 ä¸Žä½ç½® 2 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 1, 3, 4 } random(2,4) = 4; å°†ä½ç½® 2 ä¸Žä½ç½® 4 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } random(3,4) = 3; å°†ä½ç½® 3 ä¸Žä½ç½® 3 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } random(4,4) = 4; å°†ä½ç½® 4 ä¸Žä½ç½® 4 çš„æ•°å­—äº¤æ¢ï¼Œå¾—åˆ° { 2, 4, 3, 1 } çŽ°ç»™å®šéšæœºæŠ½ç‰Œæ•°å­—åºåˆ—ï¼Œè¯·ä½ è¾“å‡º Knuth æ´—ç‰Œæ³•çš„ç»“æžœåºåˆ—ã€‚è¾“å…¥æ ¼å¼ï¼šè¾“å…¥åœ¨ç¬¬ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤ 1000ï¼‰ã€‚éšåŽä¸€è¡Œç»™å‡º N ä¸ªéšæœºæŠ½ç‰Œæ•°å­—ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚é¢˜ç›®ä¿è¯ç¬¬ i ä¸ªæ•°åœ¨ i åˆ° N ä¹‹é—´ã€‚è¾“å‡ºæ ¼å¼ï¼šåœ¨ç¬¬ä¸€è¡Œä¸­è¾“å‡º Knuth æ´—ç‰Œæ³•çš„ç»“æžœåºåˆ—ã€‚æ•°å­—é—´å¿…é¡»ä»¥ 1 ä¸ªç©ºæ ¼åˆ†éš”ï¼Œè¡Œé¦–å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ Input12107 4 4 5 10 6 9 9 10 10 Output17 4 2 5 10 6 9 1 3 8 Analysisé¢˜ç›®å­—å¤ªå¤šäº†ï¼Œä¸çŸ¥é“æ˜¯ä¸æ˜¯å§¥å§¥æ•…æ„è¿™æ ·ï¼Œæ¥è¿·æƒ‘äººï¼Œéšè—é¢˜æ„ã€‚ å…¶å®žè¿™ä¸ªé¢˜ç›®å°±æ˜¯è®©ä½ äº¤æ¢æ•°å­—ï¼ˆç®—æ˜¯ç®€å•æ¨¡æ‹Ÿï¼‰ï¼Œä»¥æ ·ä¾‹ä¸ºä¾‹ï¼šç¬¬ä¸€æ¬¡ï¼Œå¤„äºŽç¬¬ä¸€ä½çš„æ•°å­—ä¸Žå¤„äºŽç¬¬ä¸ƒä½çš„æ•°å­—äº¤æ¢ï¼›ä»¥ç¬¬ä¸€æ¬¡å¾—åˆ°çš„ç»“æžœåºåˆ—ä¸ºåˆå§‹åºåˆ—ï¼Œäº¤æ¢å¤„äºŽç¬¬äºŒä½çš„æ•°å­—å’Œå¤„äºŽç¬¬å››ä½çš„æ•°å­—ï¼›ä¾æ¬¡ç±»æŽ¨å³å¯ã€‚ Code12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; seq[i] = i; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++) &#123; int tmp = seq[i], random; cin &gt;&gt; random; seq[i] = seq[random]; seq[random] = tmp; &#125; for(int i = 1; i &lt;= n - 1; i++) &#123; cout &lt;&lt; seq[i] &lt;&lt; ' '; &#125; cout &lt;&lt; seq[n]; return 0;&#125; 7-2 ä¸‰é˜¶å¹¸ç¦æ•°å¯¹ä¸€ä¸ªåè¿›åˆ¶æ•°çš„å„ä½æ•°å­—åšä¸€æ¬¡ç«‹æ–¹å’Œï¼Œç§°ä½œä¸€æ¬¡è¿­ä»£ã€‚å¦‚æžœä¸€ä¸ªåè¿›åˆ¶æ•°èƒ½é€šè¿‡ h æ¬¡è¿­ä»£å¾—åˆ° 1ï¼Œå°±ç§°è¯¥æ•°ä¸ºä¸‰é˜¶å¹¸ç¦æ•°ï¼Œè¿­ä»£çš„æ¬¡æ•° h ç§°ä¸ºå¹¸ç¦åº¦ã€‚ä¾‹å¦‚ 1579 ç»è¿‡ 1 æ¬¡è¿­ä»£å¾—åˆ° 1198ï¼Œ2 æ¬¡è¿­ä»£åŽå¾—åˆ° 1243ï¼Œ3 æ¬¡è¿­ä»£åŽå¾—åˆ° 100ï¼Œæœ€åŽå¾—åˆ° 1ã€‚åˆ™ 1579 æ˜¯å¹¸ç¦æ•°ï¼Œå…¶å¹¸ç¦åº¦ä¸º 4ã€‚å¦ä¸€æ–¹é¢ï¼Œå¦‚æžœä¸€ä¸ªå¤§äºŽ1çš„æ•°å­—ç»è¿‡æ•°æ¬¡è¿­ä»£åŽè¿›å…¥äº†æ­»å¾ªçŽ¯ï¼Œé‚£è¿™ä¸ªæ•°å°±ä¸å¹¸ç¦ã€‚ä¾‹å¦‚ 97 è¿­ä»£å¾—åˆ° 1072ã€352ã€160ã€217ã€352ã€â€¦â€¦ å¯è§ 352 åˆ° 217 å½¢æˆäº†æ­»å¾ªçŽ¯ï¼Œæ‰€ä»¥ 97 å°±ä¸å¹¸ç¦ï¼Œè€Œ 352 å°±æ˜¯å®ƒæœ€æ—©é‡åˆ°çš„å¾ªçŽ¯ç‚¹ã€‚æœ¬é¢˜å°±è¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œåˆ¤æ–­ä¸€ä¸ªç»™å®šçš„æ•°å­—æ˜¯å¦æœ‰ä¸‰é˜¶å¹¸ç¦ã€‚ è¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 100 çš„æ­£æ•´æ•° Nï¼ŒéšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡ 104 çš„æ­£æ•´æ•°ã€‚ å¯¹äºŽæ¯ä¸€ä¸ªè¾“å…¥çš„æ•°å­—ï¼Œå¦‚æžœå…¶æ˜¯ä¸‰é˜¶å¹¸ç¦æ•°ï¼Œåˆ™åœ¨ä¸€è¡Œä¸­è¾“å‡ºå®ƒçš„å¹¸ç¦åº¦ï¼›å¦åˆ™è¾“å‡ºæœ€æ—©é‡åˆ°çš„å¾ªçŽ¯ç‚¹ã€‚ Input123431579971 Output12343520 Analysisè¿™ä¸ªé¢˜ç›®æœ¬è´¨ä¸Šå…¶å®žæ˜¯ä¸ªæ•°å­—æ¸¸æˆ...æŒ‰ç…§é¢˜ç›®ç»™å®šçš„â€œæ¸¸æˆè§„åˆ™â€æ¥å¤„ç†å°±è¡Œäº†ï¼Œç”±äºŽéœ€è¦åˆ¤æ–­æ•°å­—æ˜¯å¦â€œå¹¸ç¦â€ï¼Œå€ŸåŠ©å“ˆå¸Œè¡¨æ— ç–‘æ˜¯æœ€å¿«æ·ã€æ–¹ä¾¿çš„é€‰æ‹©ã€‚ Codeä¸‹é¢æ˜¯å½“æ—¶å†™çš„ä»£ç ï¼Œæœ‰ç‚¹ä¹±è§è°…ï¼Œè¿™æ®µä»£ç å…¶å®žç”¨åˆ°çš„æ€æƒ³éƒ½æ˜¯ C é‡Œé¢çš„ä¸œè¥¿ï¼Œå°† cin å’Œ cout æ¢æˆ scanf å’Œ printf è¯´ä¸å®šè¿˜èƒ½å¿«ç‚¹å‘¢ã€‚1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100000 + 5;int hashtable[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; hashtable[i] = 0; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; while(n--) &#123; int num, degree = 0; cin &gt;&gt; num; init(); if(num == 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int tmp = num; while(1) &#123; int digit, res = 0; hashtable[tmp] = 1; while(tmp) &#123; digit = tmp % 10; res += pow(digit, 3); tmp /= 10; &#125; degree++; hashtable[res]++; if(res == 1) &#123; cout &lt;&lt; degree &lt;&lt; endl; break; &#125; else if(hashtable[res] == 2) &#123; cout &lt;&lt; res &lt;&lt; endl; break; &#125; tmp = res; &#125; &#125; return 0;&#125; 7-3 ä¸‰é˜¶å¹¸ç¦æ•°æ®é¦™æ¸¯ã€Šå—åŽæ—©æŠ¥ã€‹2019å¹´7æœˆ15æ—¥æ–‡ç« ï¼Œä¸Šæµ·ä¸¥æ ¼çš„åžƒåœ¾åˆ†ç±»æ–°è§„ä»¤ä¸å°‘å±…æ°‘æŠ“ç‹‚ã€‚è¿™å‚¬ç”Ÿå‡ºå¤§é‡å¸®åŠ©æ‰¾å‡ºæ­£ç¡®åˆ†ç±»ç­”æ¡ˆçš„Appå’Œå°ç¨‹åºã€‚ç›®å‰ä»…å¾®ä¿¡ä¸Šå°±è‡³å°‘æœ‰280ç§ä¸Žåžƒåœ¾å¤„ç†æœ‰å…³çš„Appï¼Œåœ¨è‹¹æžœåº”ç”¨å•†åº—ä¹Ÿè¾¾130ç§ã€‚æ”¯ä»˜å®è¡¨ç¤ºï¼Œå·²æœ‰60å¤šå®¶ç‹¬ç«‹Appå¼€å‘å•†ç”³è¯·ä¸ºè¯¥å¹³å°æä¾›ç±»ä¼¼æœåŠ¡ã€‚æœ¬é¢˜å°±è¯·ä½ çŽ°åœºå®žçŽ°ä¸€ä¸ªç®€å•çš„åžƒåœ¾åˆ†ç±»å°åŠ©æ‰‹ã€‚ è¾“å…¥é¦–å…ˆç»™å‡ºå®˜æ–¹åˆ†ç±»æŒ‡å—ä¸­æ¯ç§ç‰©å“çš„å½’å±žã€‚åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•° Nï¼ˆâ‰¤10â€‹5â‰¤10â€‹5 \le10â€‹^5â‰¤10â€‹5â€‹â€‹ï¼‰ï¼Œå³ç‰©å“æ•°é‡ï¼›éšåŽ N è¡Œï¼Œæ¯è¡Œç»™å‡ºä¸€ä¸ªç‰©å“åç§°ï¼ˆé•¿åº¦ä¸è¶…è¿‡ 10 çš„ã€ç”±å°å†™è‹±æ–‡å­—æ¯å’Œä¸‹åˆ’çº¿ç»„æˆçš„å­—ç¬¦ä¸²ï¼‰å’Œè¯¥ç‰©å“æ‰€å±žçš„åˆ†ç±»ï¼ˆ1 ä»£è¡¨å¹²åžƒåœ¾ã€2 ä»£è¡¨æ¹¿åžƒåœ¾ã€3 ä»£è¡¨å¯å›žæ”¶ç‰©ã€4 ä»£è¡¨æœ‰å®³åžƒåœ¾ï¼‰ã€‚é¢˜ç›®ä¿è¯æ‰€æœ‰ç‰©å“åç§°æ— é‡å¤ã€‚éšåŽæ¯è¡Œç»™å‡ºä¸€ä¸ªæŸ¥è¯¢ç‰©å“çš„åç§°ï¼ˆæ ¼å¼ä¸ŽæŒ‡å—ç‰©å“åç§°ç›¸åŒï¼‰ã€‚æœ€åŽä¸€è¡Œç»™å‡ºç»“æŸç¬¦ #ï¼Œè¡¨ç¤ºæŸ¥è¯¢ç»ˆæ­¢ï¼Œè¿™ä¸€è¡Œä¸éœ€è¦æŸ¥è¯¢ã€‚ å¯¹æ¯ä¸ªæŸ¥è¯¢çš„ç‰©å“ï¼Œåœ¨ä¸€è¡Œä¸­ç»™å‡ºå…¶æ‰€å±žåˆ†ç±»ï¼šGan laji ä»£è¡¨å¹²åžƒåœ¾ï¼›Shi laji ä»£è¡¨æ¹¿åžƒåœ¾ï¼›Ke Hui Shou ä»£è¡¨å¯å›žæ”¶ç‰©ï¼›You Hai laji ä»£è¡¨æœ‰å®³åžƒåœ¾ã€‚å¦‚æžœæŸ¥è¯¢çš„ç‰©å“ä¸åœ¨æŒ‡å—ä¸­ï¼Œåˆ™è¾“å‡º ? è¡¨ç¤ºä¸çŸ¥é“ã€‚ Input12345678910114bao_zhi 3dian_chi 4dan_ke 2bei_ke 1dan_kedian_chiren_zhabao_zhibei_ke# Output12345Shi lajiYou Hai laji?Ke Hui ShouGan laji Analysisè€ƒè¯•æ—¶ï¼Œåšè¿™ä¸ªé¢˜åªæƒ³åˆ°äº† mapï¼Œæ²¡æƒ³åˆ° unordered mapï¼Œå•çº¯åªç”¨ mapï¼Œ3åˆ†ï¼Œunordered mapï¼ŒACã€‚æ„Ÿè§‰æŸå¤±æƒ¨é‡... å¦å¤–ï¼Œèƒ½ä¸ç”¨ cin å’Œ coutï¼Œè¿˜æ˜¯å°½é‡ä¸ç”¨... Codeä¸‹é¢æ˜¯å½“æ—¶ç”¨ map å†™çš„ä»£ç ï¼š123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; rab2id;int main() &#123; int n, id; cin &gt;&gt; n; string str; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; id; rab2id[str] = id; &#125; while(cin &gt;&gt; str &amp;&amp; str != "#") &#123; if(rab2id[str] == 1) &#123; cout &lt;&lt; "Gan laji\n"; &#125; else if(rab2id[str] == 2) &#123; cout &lt;&lt; "Shi laji\n"; &#125; else if(rab2id[str] == 3) &#123; cout &lt;&lt; "Ke Hui Shou\n"; &#125; else if(rab2id[str] == 4) &#123; cout &lt;&lt; "You Hai laji\n"; &#125; else cout &lt;&lt; "?\n"; &#125; return 0;&#125; ä¸‹é¢æ˜¯ AC çš„ä»£ç ï¼ˆå¦‚æžœä¸æƒ³é‚£ä¹ˆå¤š if-elseï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨å­—ç¬¦ä¸²æ•°ç»„æ¥è¾“å‡ºï¼‰ï¼š123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; rab2id;char s[20]; int main() &#123; int n, id; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", s, &amp;id); rab2id[s] = id; &#125; while(scanf("%s", s) != EOF) &#123; string str(s); if(str == "#") &#123; break; &#125; else if(rab2id[str] == 1) &#123; printf("Gan laji\n"); &#125; else if(rab2id[str] == 2) &#123; printf("Shi laji\n"); &#125; else if(rab2id[str] == 3) &#123; printf("Ke Hui Shou\n"); &#125; else if(rab2id[str] == 4) &#123; printf("You Hai laji\n"); &#125; else printf("?\n"); &#125; return 0;&#125; æ€»ç»“ä¸‰é“ 20 åˆ†çš„é¢˜ç›®ï¼Œåº”è¯¥å°±æ˜¯ä¹™çº§ 20 åˆ†é¢˜ç›®çš„éš¾åº¦ï¼Ÿ å¯èƒ½æ˜¯æˆ‘å¤ªä¹…æ²¡æœ‰å†™ä»£ç çš„ç¼˜æ•…äº†ï¼Œç¬¬ä¸€é“é¢˜ç›®è¢«è¿·æƒ‘äº†æŒºä¹…çš„ï¼ŒåŽŸæœ¬åº”è¯¥åå‡ åˆ†é’Ÿå°±æžå®šçš„ï¼Œç»“æžœå¥½åƒå¿«åŠä¸ªå°æ—¶æ‰æžå®š... ç¬¬äºŒé“é¢˜ç›®æžœç„¶è§£å†³èµ·æ¥å°±å¿«äº†è®¸å¤šï¼ˆç¨å¾®ç†Ÿæ‚‰äº†ä¸€ç‚¹ï¼‰ï¼Œä¸è¿‡æ„å¤–çš„æ˜¯æ²¡æƒ³åˆ°æœ‰è¿™ä¹ˆå¤šæµ‹è¯•ç‚¹... ç¬¬ä¸‰é“é¢˜ç›®åªæƒ³åˆ°äº† map æ— ç–‘æ˜¯ä¸ªè´¥ç¬”ï¼Œä¸è¿‡ä¹Ÿåæ˜ äº†è‡ªå·±å¿˜è®°äº†å¤ªå¤šä¸œè¥¿äº†...ðŸ˜±è€Œä¸”é¢å¯¹è¿™ç§å¡è¶…æ—¶çš„é¢˜ç›®ï¼ŒèŽ«åçš„æœ‰ç‚¹è™šã€‚ åæ­£ä¸‰é“é¢˜ç›®éƒ½ä¸éš¾å°±æ˜¯äº†ï¼Œæ²¡å…¨éƒ¨ ACï¼Œè¯¥æ£€è®¨ã€‚ç‰¹åˆ«æ˜¯æœ€åŽä¸€é¢˜ï¼Œå‡ åˆ†é’Ÿå°±æ‹¿åˆ°äº† 3 åˆ†ï¼ŒåŽé¢ 40 åˆ†é’Ÿéƒ½é˜µäº¡äº†... PSï¼šå‰ä¸¤é“é¢˜éƒ½æ˜¯ä¸€æ¬¡ AC]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_04-æ ‘ï¼ˆä¸­ï¼‰]]></title>
    <url>%2F2020%2F05%2F01%2FZJU-DS-04-%E6%A0%91%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[å‰é¢å­¦ä¹ äº†æ ‘çš„åŸºæœ¬æœ¯è¯­ã€æ€§è´¨ï¼Œä»¥åŠäºŒå‰æ ‘çš„å½¢æ€ã€éåŽ†æ–¹æ³•ç­‰ï¼Œè¿™æ¬¡ä¼šç»§ç»­å­¦ä¹ ä¸¤ç§â€œæ–°â€äºŒå‰æ ‘ Binary Search Treeå®šä¹‰äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼ŒBinary Search Treeï¼‰ï¼Œä¹Ÿæˆä¸ºäºŒå‰æŽ’åºæ ‘æˆ–äºŒå‰æŸ¥æ‰¾æ ‘ã€‚äºŒå‰æœç´¢æ ‘ï¼šå‰æå¾—æ˜¯ä¸€æ£µäºŒå‰æ ‘ï¼Œå¯ä»¥ä¸ºç©ºï¼›å¦‚æžœä¸ä¸ºç©ºï¼Œæ»¡è¶³ä»¥ä¸‹æ€§è´¨ï¼š éžç©ºå·¦å­æ ‘çš„æ‰€æœ‰é”®å€¼å°äºŽå…¶æ ¹ç»“ç‚¹çš„é”®å€¼ éžç©ºå³å­æ ‘çš„æ‰€æœ‰é”®å€¼å¤§äºŽå…¶æ ¹èŠ‚ç‚¹çš„é”®å€¼ å·¦ã€å³å­æ ‘éƒ½æ˜¯äºŒå‰æœç´¢æ ‘ ç‰¹åˆ«å‡½æ•°äºŒå‰æœç´¢æ ‘æœ¬è´¨ä¸Šè¿˜æ˜¯äºŒå‰æ ‘ï¼Œæ‰€ä»¥å…¶æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ä¸ŽäºŒå‰æ ‘æ˜¯ä¸€è‡´çš„ï¼Œä½†æ“ä½œé›†å­˜åœ¨å·®å¼‚ï¼Œå¤šäº†å‡ ä¸ªç‰¹åˆ«å‡½æ•°ï¼š Position Find(ElementType X, BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å…ƒç´ Xï¼Œè¿”å›žå…¶æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ Position FindMin(BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å¹¶è¿”å›žæœ€å°å…ƒç´ æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ Position FindMax(BinTree BST)ï¼Œä»ŽäºŒå‰æœç´¢æ ‘BSTä¸­æŸ¥æ‰¾å¹¶è¿”å›žæœ€å¤§å…ƒç´ æ‰€åœ¨ç»“ç‚¹çš„åœ°å€ BinTree Insert(ElementType X, BinTree BST)ï¼Œå‘äºŒå‰æœç´¢æ ‘ä¸­æ’å…¥ç»“ç‚¹ BinTree Delete(ElementType X, BinTree BST)ï¼Œåœ¨äºŒå‰æœç´¢æ ‘ä¸­åˆ é™¤ç»“ç‚¹ ä¸‹é¢ä»¥äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æž„ä¸ºå‡†ï¼Œå®Œæˆå‡ ä¸ªå¸¸ç”¨çš„ç‰¹åˆ«å‡½æ•°ã€‚ æŸ¥æ‰¾æŸ¥æ‰¾å‡½æ•°çš„å®žçŽ°æ€è·¯æ¯”è¾ƒç›´æŽ¥ï¼ŒæŒ‰ç…§äºŒå‰æœç´¢æ ‘çš„æ€§è´¨ï¼Œæ¯”æ ¹ç»“ç‚¹å°åˆ™åœ¨å·¦å­æ ‘ä¸­æŸ¥æ‰¾ï¼Œæ¯”æ ¹èŠ‚ç‚¹å¤§åˆ™åœ¨å³å­æ ‘ä¸­æŸ¥æ‰¾ï¼Œå¾ªçŽ¯è¿™ä¸ªè¿‡ç¨‹å³å¯ã€‚ é€’å½’123456Position Find(ElementType X, BinTree BST) &#123; if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(X, BST-&gt;Right); else if(X &lt; BST-&gt;Data) return Find(X, BST-&gt;Left); else return BST;&#125; éžé€’å½’12345678Position IterFind(ElementType X, BinTree BST) &#123; while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else return BST; &#125; return NULL;&#125; æŸ¥æ‰¾æœ€å€¼æœ‰äº†å‰é¢æŸ¥æ‰¾çš„æ€è·¯åŽï¼Œæ ¹æ® BST çš„æ€§è´¨ï¼Œç›´æŽ¥æŸ¥æ‰¾æœ€å€¼çš„å‡½æ•°ä¹Ÿå¾ˆå®¹æ˜“å¾—åˆ°ã€‚ é€’å½’1234567891011Position FindMax(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else FindMin(BST);&#125;Position FindMin(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else FindMin(BST);&#125; éžé€’å½’12345678910111213Position FindMax(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Right) BST = BST-&gt;Right; &#125; return BST;&#125;Position FindMin(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Left) BST = BST-&gt;Left; &#125; return BST;&#125; æ’å…¥æ’å…¥çš„å…³é”®åœ¨äºŽå…ˆç¡®å®šå¥½æ’å…¥çš„ä½ç½®ï¼Œæ—¢ç„¶è¦ç¡®å®šä½ç½®ï¼Œé‚£ä¹ˆå°±å¯ä»¥å€ŸåŠ©æŸ¥æ‰¾çš„æ€è·¯ã€‚ é€’å½’1234567891011BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST;&#125; éžé€’å½’123456789101112131415161718192021222324BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125; åˆ é™¤åˆ é™¤çš„æ€è·¯ä¸Žæ’å…¥çš„æ€è·¯ä¹Ÿç±»ä¼¼ï¼Œè¿˜æ˜¯éœ€è¦å…ˆæ‰¾åˆ é™¤çš„ä½ç½®ã€‚ä½†æ˜¯é’ˆå¯¹åˆ é™¤ç»“ç‚¹çš„ä¸åŒï¼ˆå¶ç»“ç‚¹å’Œéžå¶ç»“ç‚¹ï¼‰ï¼Œéœ€è¦åˆ†åˆ«è€ƒè™‘ã€‚å¦‚æžœåˆ é™¤çš„æ˜¯å¶ç»“ç‚¹ï¼Œé‚£ä¹ˆå¯ä»¥ç›´æŽ¥åˆ é™¤ï¼›ä½†è‹¥åˆ é™¤éžå¶ç»“ç‚¹ï¼Œå°±éœ€è¦åœ¨åˆ é™¤è¿™ä¸ªç»“ç‚¹åŽï¼Œç”¨å¦ä¸€ç»“ç‚¹æ›¿ä»£è¢«åˆ é™¤ç»“ç‚¹ï¼Œè¿™æ ·æ‰ä¸ä¼šä½¿é“¾å¼ç»“æž„æ–­è£‚ã€‚ å¯¹äºŽåº¦ä¸º 1 çš„è¢«åˆ é™¤ç»“ç‚¹ï¼Œå¦ä¸€ç»“ç‚¹ç›´æŽ¥ä½¿ç”¨å…¶å­ç»“ç‚¹å³å¯ï¼›å¯¹äºŽåº¦ä¸º 2 çš„è¢«åˆ é™¤ç»“ç‚¹ï¼Œå¦ä¸€ç»“ç‚¹å¯ä»¥ç”¨å…¶å³å­æ ‘çš„æœ€å°å…ƒç´ æˆ–è€…å…¶å·¦å­æ ‘çš„æœ€å¤§å…ƒç´ ï¼Œä¹‹æ‰€è¦ç”¨è¿™ä¸¤ä¸ªç»“ç‚¹ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªç»“ç‚¹ä¸€å®šæ˜¯å¶ç»“ç‚¹ï¼Œå¯ä»¥ç›´æŽ¥æ‹¿æŽ‰ã€‚123456789101112131415161718192021222324252627BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125; Balanced Treeå¹³è¡¡äºŒå‰æ ‘éœ€è¦å¼•å…¥å¹³è¡¡å› å­çš„æ¦‚å¿µï¼Œå…¶è§£å†³äº†äºŒå‰æœç´¢æ ‘ä¸­å‡ºçŽ°â€œå•æžæ ‘â€è€Œå¯¼è‡´æŸ¥æ‰¾æ•ˆçŽ‡è¿‡ä½Žçš„æ ‘å½¢ç»“æž„é—®é¢˜ã€‚ å¹³è¡¡å› å­ï¼ˆBalance Factorï¼ŒBFï¼‰ï¼š$BF(T) = h_l - h_r$ï¼Œå…¶ä¸­$h_l$å’Œ$h_r$åˆ†åˆ«ä¸ºæ ‘ T çš„å·¦å³å­æ ‘é«˜åº¦ã€‚ å®šä¹‰å¹³è¡¡äºŒå‰æ ‘ï¼ˆBalanced Treeï¼Œä¹Ÿå« AVL æ ‘ï¼‰:ç©ºæ ‘ï¼Œæˆ–è€…ä»»ä½•ä¸€ç»“ç‚¹å·¦å³å­æ ‘é«˜åº¦å·®çš„ç»å¯¹å€¼ä¸è¶…è¿‡ 1ï¼Œå³$|BF(T)| \le 1$ã€‚ è°ƒæ•´å¹³è¡¡äºŒå‰æ ‘çš„ç»“æž„è°ƒæ•´æƒ…å†µæœ‰ä»¥ä¸‹å››ç§æƒ…å†µï¼Œå…³é”®åœ¨äºŽè§‚å¯Ÿç¦»ç ´åè€…æœ€è¿‘çš„è¢«ç ´åè€…å’Œç ´åè€…ä¹‹é—´çš„ä½ç½®å…³ç³»ã€‚ä½†æ˜¯è¦æ³¨æ„æœ‰æ—¶å€™æ’å…¥å…ƒç´ å³ä¾¿ä¸éœ€è¦è°ƒæ•´ç»“æž„ï¼Œä¹Ÿå¯èƒ½éœ€è¦é‡æ–°è®¡ç®—ä¸€äº›å¹³è¡¡å› å­ã€‚RRLLLRRLRRæ—‹è½¬ï¼ˆè™½ç„¶å« RR æ—‹è½¬ï¼Œä½†æ˜¯å®žé™…è¿‡ç¨‹æ˜¯å·¦æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å³å­æ ‘çš„å³å­æ ‘ä¸‹ã€‚ 12345678Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LLæ—‹è½¬ï¼ˆè™½ç„¶å« LL æ—‹è½¬ï¼Œä½†æ˜¯å®žé™…è¿‡ç¨‹æ˜¯å³æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å·¦å­æ ‘çš„å·¦å­æ ‘ä¸‹ã€‚ 12345678Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LRæ—‹è½¬ï¼ˆä¸Žåç§°ä¸€è‡´ï¼Œå…ˆå·¦æ—‹åŽå³æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å·¦å­æ ‘çš„å³å­æ ‘ä¸‹ã€‚ 1234Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;RLæ—‹è½¬ï¼ˆä¸Žåç§°ä¸€è‡´ï¼Œå…ˆå³æ—‹åŽå·¦æ—‹ï¼‰ï¼Œç ´åè€…ä½äºŽè¢«ç ´åè€…çš„å³å­æ ‘çš„å·¦å­æ ‘ä¸‹ã€‚ 1234Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125; Homework04-4 æ˜¯å¦åŒä¸€æ£µäºŒå‰æœç´¢æ ‘è¿™é“é¢˜ä¸Žæ ‘çš„åŒæž„æœ‰ç‚¹åƒï¼Œä¸‹é¢çš„ä»£ç åŒ…å«ä¸¤ç§åšæ³•ï¼š æž„é€ ä¸¤æ£µæ ‘ï¼Œåˆ¤æ–­ä¸¤æ£µæ ‘æ˜¯å¦ä¸€è‡´ åªæž„é€ ä¸€æ£µæ ‘ï¼Œåˆ¤æ–­ç»™å®šåºåˆ—é¡ºåºæ˜¯å¦ä¸Žæ ‘çš„ç»“ç‚¹åºåˆ—ä¸€è‡´ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* method 1: use recursion to judge two trees is same or not */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;PtrToTNode createnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct TNode)); t-&gt;left = t-&gt;right = NULL; t-&gt;data = data; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = createnode(data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); return root;&#125;bool issame(Tree root1, Tree root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if((!root1 &amp;&amp; root2) &amp;&amp; (root1 &amp;&amp; !root2)) return false; else &#123; if(root1-&gt;data != root2-&gt;data) return false; else return issame(root1-&gt;left, root2-&gt;left) &amp;&amp; issame(root1-&gt;right, root2-&gt;right); &#125;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l; scanf("%d", &amp;n); while(n) &#123; scanf("%d", &amp;l); Tree root1 = NULL; int i, data; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root1 = insert(root1, data); &#125; while(l--) &#123; Tree root2 = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root2 = insert(root2, data); &#125; if(issame(root1, root2)) printf("Yes\n"); else printf("No\n"); destorytree(root2); &#125; scanf("%d", &amp;n); if(n == 0) destorytree(root1); &#125; return 0;&#125;/* method 2: constitute a tree, check the path of visiting everynodes is sameor not #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct node&#123; int flag, data; struct node *left, *right;&#125;;typedef struct node* Tree;typedef struct node* PtrToTNode;PtrToTNode newnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct node)); t-&gt;data = data; t-&gt;flag = 0; t-&gt;left = t-&gt;right = NULL; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = newnode(data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); return root;&#125;Tree buildtree(int n) &#123; int i, data; Tree root = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; return root;&#125;bool check(Tree root, int data) &#123; if(root-&gt;flag) &#123; if(data &lt; root-&gt;data) return check(root-&gt;left, data); else if(data &gt; root-&gt;data) return check(root-&gt;right, data); else return false; &#125; else &#123; if(data == root-&gt;data) &#123; root-&gt;flag = 1; return true; &#125; else return false; &#125;&#125;bool judge(Tree root, int n) &#123; int i, data; bool flag = false; scanf("%d", &amp;data); if(data != root-&gt;data) flag = true; else root-&gt;flag = 1; for(i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;data); if(!flag &amp;&amp; !check(root, data)) flag = 1; &#125; return !flag;&#125;void reset(Tree root) &#123; if(root-&gt;left) reset(root-&gt;left); if(root-&gt;right) reset(root-&gt;right); root-&gt;flag = 0;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l, i; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;l); Tree root = buildtree(n); while(l--) &#123; if(judge(root, n)) printf("Yes\n"); else printf("No\n"); reset(root); &#125; destorytree(root); &#125; return 0;&#125; */ 04-5 Root of AVL Treeè¿™é“é¢˜å°±æ˜¯ä½•è€å¸ˆè®²çš„å¹³è¡¡äºŒå‰æ ‘çš„å››ç§æ—‹è½¬æ–¹å¼ï¼Œé¢˜ç›®ä¸€æ¬¡å°†å››ç§æ—‹è½¬æ–¹å¼å…¨éƒ¨è€ƒå¯Ÿåˆ°äº†ï¼Œå‡ºçš„å¾ˆå¥½ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data, height; struct TNode *lchild, *rchild;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int getheight(Tree root) &#123; if(!root) return -1; else return root-&gt;height;&#125;Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125;Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;Tree insert(Tree root, int data) &#123; if(!root) &#123; root = (Tree)malloc(sizeof(struct TNode)); root-&gt;lchild = root-&gt;rchild = NULL; root-&gt;data = data; root-&gt;height = 0; &#125; else if(data &gt; root-&gt;data) &#123; root-&gt;rchild = insert(root-&gt;rchild, data); if(getheight(root-&gt;rchild) - getheight(root-&gt;lchild) == 2) &#123; if(data &gt; root-&gt;rchild-&gt;data) root = RRrotate(root); else root = RLrotate(root); &#125; &#125; else if(data &lt; root-&gt;data) &#123; root-&gt;lchild = insert(root-&gt;lchild, data); if(getheight(root-&gt;lchild) - getheight(root-&gt;rchild) == 2) &#123; if(data &lt; root-&gt;lchild-&gt;data) root = LLrotate(root); else root = LRrotate(root); &#125; &#125; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return root;&#125;int main() &#123; int i, n, data; scanf("%d", &amp;n); Tree root = NULL; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; printf("%d", root-&gt;data); return 0;&#125; 04-6 Complete Binary Search Treeè¿™é“é¢˜å¾ˆæœ‰éš¾åº¦ï¼Œè¦å¯¹å®Œå…¨äºŒå‰æ ‘ã€äºŒå‰æŸ¥æ‰¾æ ‘åŠäºŒå‰æ ‘çš„éåŽ†æœ‰è¾ƒæ·±çš„ç†è§£æ‰èƒ½è§£å‡ºæ¥ï¼Œä¸è¿‡è§£ä¸å‡ºæ¥ä¹Ÿæ²¡äº‹ï¼Œå§¥å§¥åŽé¢ä¼šè®²ã€‚123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1005int n, tree[maxn], seq[maxn], inde = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); tree[root] = seq[inde++]; inorder(2 * root + 1);&#125;int cmp(const void *a, const void *b) &#123; return (*(int*)a - *(int*)b);&#125;int main() &#123; scanf("%d", &amp;n); int i; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;seq[i]); &#125; qsort(seq, n, sizeof(seq[0]), cmp); inorder(1); for(i = 1; i &lt;= n; ++i) &#123; printf("%d", tree[i]); if(i &lt; n) printf(" "); &#125; return 0;&#125; 04-7 äºŒå‰æœç´¢æ ‘çš„æ“ä½œé›†è¿™é“é¢˜ç›®æ˜¯ç”¨æ¥æµ‹è¯•äºŒå‰æœç´¢æ ‘å¸¸ç”¨æ“ä½œçš„ï¼Œå¯ä»¥å°è¯•å¤šç§ä¸åŒçš„å†™æ³•æ¥æäº¤æ¥éªŒè¯æ˜¯å¦æ­£ç¡®ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT );void InorderTraversal( BinTree BT );BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST = NULL; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Insert(BST, X); &#125; printf("Preorder:"); PreorderTraversal(BST); printf("\n"); MinP = FindMin(BST); MaxP = FindMax(BST); scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); Tmp = Find(BST, X); if (Tmp == NULL) printf("%d is not found\n", X); else &#123; printf("%d is found\n", Tmp-&gt;Data); if (Tmp==MinP) printf("%d is the smallest key\n", Tmp-&gt;Data); if (Tmp==MaxP) printf("%d is the largest key\n", Tmp-&gt;Data); &#125; &#125; scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Delete(BST, X); &#125; printf("Inorder:"); InorderTraversal(BST); printf("\n"); return 0;&#125;void PreorderTraversal( BinTree BT ) &#123; if(!BT) return; printf("%d ", BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void InorderTraversal( BinTree BT ) &#123; if(!BT) return; InorderTraversal(BT-&gt;Left); printf("%d ", BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST; */ /* method 2: use loop */ if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125;Position Find( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) return Find(BST-&gt;Left, X); else return BST; */ /* method 2: use loop*/ while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else break; &#125; return BST;&#125;Position FindMin( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Left) BST = BST-&gt;Left; return BST;&#125;Position FindMax( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else return FindMax(BST-&gt;Right); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Right) BST = BST-&gt;Right; return BST;&#125;/*samples:in:105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3out:Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_03-æ ‘ï¼ˆä¸Šï¼‰]]></title>
    <url>%2F2020%2F04%2F01%2FZJU-DS-03-%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯æ ‘ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿæ ‘åˆæœ‰ä»€ä¹ˆæ ·æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ å¼•è¨€åœ¨äº†è§£æ ‘ä¹‹å‰ï¼Œå…ˆäº†è§£ä¸€ä¸‹æ ‘åœ¨ç”Ÿæ´»ä¸­çš„åº”ç”¨ï¼Œæ¯”å¦‚ï¼šäººç±»ç¤¾ä¼šçš„å®¶è°±ã€ç¤¾ä¼šç»„ç»‡ç»“æž„å’Œå›¾ä¹¦ä¿¡æ¯ç®¡ç†ã€‚è¿™ç±»ä¿¡æ¯ç»“æž„éƒ½æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œé‚£å°±æ˜¯å†…éƒ¨çš„ä¸åŒäº‹ç‰©ä¹‹é—´éƒ½å…·æœ‰å±‚æ¬¡å…³ç³»ã€‚ æŸ¥æ‰¾æŸ¥æ‰¾æ˜¯è®¡ç®—æœºä¸­çš„åŸºç¡€æ“ä½œï¼Œæ‰€è°“åŸºç¡€ï¼Œå³æ˜¯æŒ‡æŸ¥æ‰¾æ“ä½œå¹¿æ³›ä½¿ç”¨åœ¨è®¡ç®—æœºçš„å„ä¸ªåº”ç”¨ï¼Œä¼˜ç§€çš„æŸ¥æ‰¾ç®—æ³•å¯¹äºŽæé«˜ç¨‹åºæŸ¥æ‰¾æ•ˆçŽ‡å¾ˆæœ‰å¸®åŠ©ã€‚ æŸ¥æ‰¾ï¼šæ ¹æ®æŸä¸ªç»™å®šå…³é”®å­— K ï¼Œä»Žé›†åˆ R ä¸­æ‰¾å‡ºå…³é”®å­—ä¸ŽKç›¸åŒçš„è®°å½•ï¼ŒæŸ¥æ‰¾å¯ä»¥åˆ†ä¸ºä¸¤ç±»ï¼š é™æ€æŸ¥æ‰¾ï¼šé›†åˆä¸­è®°å½•æ˜¯å›ºå®šçš„ï¼Œæ²¡æœ‰æ’å…¥å’Œåˆ é™¤æ“ä½œï¼Œåªæœ‰æŸ¥æ‰¾ åŠ¨æ€æŸ¥æ‰¾ï¼šé›†åˆä¸­è®°å½•æ˜¯åŠ¨æ€å˜åŒ–çš„ï¼Œé™¤æŸ¥æ‰¾æ“ä½œå¤–ï¼Œè¿˜å¯èƒ½ä¼šæœ‰æ’å…¥å’Œåˆ é™¤æ“ä½œ ä¸‹é¢ä»…å°±é™æ€æŸ¥æ‰¾å±•å¼€è®¨è®ºã€‚ é™æ€æŸ¥æ‰¾é™æ€æŸ¥æ‰¾çš„æ–¹æ³•ï¼Œæ ¹æ®å­˜å‚¨ç»“æž„çš„ä¸åŒæœ‰ç€å¤šç§å¤šæ ·çš„æ–¹æ³•ï¼Œä¸‹é¢ä»¥æ•°ç»„ä¸ºä¾‹æ¥å±•å¼€è®¨è®ºã€‚ é¡ºåºæŸ¥æ‰¾åˆ©ç”¨æ•°ç»„ä¸‹æ ‡æ¥ä½œä¸ºå¾ªçŽ¯çš„è¾¹ç•Œï¼Œä¹Ÿå¯ä»¥é€šè¿‡â€œå“¨å…µâ€çš„è®¾è®¡æŠ€å·§æ¥é¿å…ä½¿ç”¨ä¸‹æ ‡ä½œä¸ºè¾¹ç•Œå€¼ï¼Œå…·ä½“è€Œè¨€ï¼Œå³å½“å‰ä¸‹æ ‡çš„æ•°ç»„å€¼ä¸Žå“¨å…µçš„å€¼ç›¸ç­‰æ—¶ï¼Œè·³å‡ºå¾ªçŽ¯ï¼Œä»£ç å¦‚ä¸‹ï¼š123456int SequentialSearch(StaticTable *Tbl, ElementType K) &#123; int i; Tbl-&gt;ElementType[0] = K; for(i = Tbl-&gt;Length; Tbl-&gt;ElementType[i] != K; i--); return i;&#125; æ˜¾ç„¶ï¼Œé¡ºåºæŸ¥æ‰¾ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ã€‚ äºŒåˆ†æŸ¥æ‰¾äºŒåˆ†æŸ¥æ‰¾åœ¨ç¬¬ä¸€å‘¨çš„ä½œä¸šé¢˜ä¸­å·²ç»è§è¿‡äº†ã€‚å®žé™…ä¸Šï¼ŒäºŒåˆ†æŸ¥æ‰¾æ˜¯æœ‰å‰æçš„ï¼š åºåˆ—æœ‰åº å­˜å‚¨åœ¨æ•°ç»„ä¸­ åœ¨æœ‰åºçš„åŸºç¡€ä¸‹ï¼Œå‡è‹¥è¦æŸ¥æ‰¾å€¼Xï¼Œåˆ†åˆ«è®¾ç½®leftã€midã€rightä¸‰ä¸ªä¸‹æ ‡å€¼ã€‚æ¯æ¬¡æ—¶ï¼ŒæŸ¥æ‰¾mid = (left + right)/2ï¼Œå¦‚è‹¥array[mid] &gt; Xï¼Œåˆ™æœ‰mid = right - 1ï¼Œå¦‚è‹¥array[mid] &lt; Xï¼Œåˆ™æœ‰mid = left + 1ï¼Œå½“left &lt;= rightè¿™ä¸ªæ¡ä»¶ä¸æˆç«‹æ—¶ï¼Œè·³å‡ºå¾ªçŽ¯ã€‚ æ³¨æ„ï¼šæ¯æ¬¡æ›´æ–°çš„leftå’Œrightä¸èƒ½ä¸ºmidã€‚ äºŒåˆ†æŸ¥æ‰¾çš„è¿‡ç¨‹å®žé™…ä¸Šå¯ä»¥æž„é€ å‡ºä¸€æ£µäºŒåˆ†æŸ¥æ‰¾åˆ¤å®šæ ‘ï¼Œè€Œåœ¨è¿™æ£µåˆ¤å®šæ ‘ä¸Šï¼Œæ¯ä¸ªç»“ç‚¹éœ€è¦æŸ¥æ‰¾çš„æ¬¡æ•°åˆšå¥½ä¸ºè¯¥èŠ‚ç‚¹æ‰€åœ¨çš„å±‚æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼ŒæŸ¥æ‰¾æˆåŠŸæ—¶çš„æŸ¥æ‰¾æ¬¡æ•°ä¸ä¼šè¶…è¿‡åˆ¤å®šæ ‘çš„æ·±åº¦ï¼Œä»Žè€Œå¯ä»¥å¾—åˆ°ï¼Œn ä¸ªç»“ç‚¹çš„åˆ¤å®šæ ‘çš„æ·±åº¦ä¸º$[log_{2}n] + 1$ï¼Œè¿™é‡Œå°±åˆæœ‰äº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µ â€” ASL, Average Search Lengthï¼Œå¹³å‡æŸ¥æ‰¾æ¬¡æ•°ï¼ˆä¹Ÿå«å¹³å‡æŸ¥æ‰¾é•¿åº¦ï¼ŒåŽé¢å•ç‹¬è®²æŸ¥æ‰¾æ—¶ä¼šå†æ¬¡é‡åˆ°ï¼‰ ,å¯å¾—ï¼š$ASL = (4 \times 4 + 4 \times 3 + 2 \times 2 + 1) \div 11 = 3$ã€‚ ä»£ç å¦‚ä¸‹ï¼š123456789101112int BinarySearch(StaticTable *Tbl, ElementType K) &#123; int left, right, mid, NotFound = -1; left = 1; right = Tbl-&gt;Length; while(left &lt;= right) &#123; mid = (left + right) / 2; if(K &lt; Tbl-&gt;ElementType[mid]) right = mid - 1; else if(K &gt; Tbl-&gt;ElementType[mid]) left = mid + 1; else return mid; &#125; return NotFound;&#125; äºŒåˆ†æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å‰é¢å·²ç»åˆ†æžè¿‡äº†æ˜¯$O(logN)$ã€‚ æ ‘å®šä¹‰æ ‘ï¼ˆTreeï¼‰ï¼šnï¼ˆnâ‰¥0ï¼‰ä¸ªç»“ç‚¹æž„æˆçš„æœ‰é™é›†åˆï¼Œå½“n=0æ—¶ï¼Œç§°ä¸ºç©ºæ ‘ï¼Œå¯¹äºŽä»»ä½•ä¸€æ£µéžç©ºæ ‘ï¼Œå®ƒå…·å¤‡ä»¥ä¸‹æ€§è´¨ï¼š æ ‘ä¸­æœ‰ä¸€ä¸ªç§°ä¸ºâ€œæ ¹ï¼ˆrootï¼‰â€çš„ç‰¹æ®ŠèŠ‚ç‚¹ï¼Œç”¨rè¡¨ç¤º å…¶ä½™ç»“ç‚¹å¯åˆ†ä¸ºmï¼ˆmï¼ž0ï¼‰ä¸ªäº’ä¸ç›¸äº¤çš„æœ‰é™é›†$T_1, T_2, \ldots, T_m$ï¼Œå…¶ä¸­æ¯ä¸ªé›†åˆæœ¬èº«åˆæ˜¯ä¸€æ£µæ ‘ï¼Œç§°ä¸ºåŽŸæ¥æ ‘çš„â€œå­æ ‘ï¼ˆSubTreeï¼‰â€ã€‚æ³¨æ„ï¼š å­æ ‘ä¸èƒ½ç›¸äº¤ é™¤äº†æ ¹èŠ‚ç‚¹ï¼Œæ¯ä¸ªèŠ‚ç‚¹æœ‰ä¸”ä»…æœ‰ä¸€ä¸ªçˆ¶èŠ‚ç‚¹ ä¸€æ£µNä¸ªèŠ‚ç‚¹çš„æ ‘æœ‰N-1æ¡è¾¹ æ ‘æ˜¯ä¿è¯è¿žé€šä¸”è¾¹æ•°æœ€å°‘çš„ä¸€ç§è¿žæŽ¥æ–¹å¼ åŸºæœ¬æœ¯è¯­ä¸Žæ ‘ç›¸å…³çš„åŸºæœ¬æœ¯è¯­å¦‚ä¸‹ï¼š ç»“ç‚¹çš„åº¦ï¼ˆDegreeï¼‰ï¼šç»“ç‚¹çš„å­æ ‘ä¸ªæ•° æ ‘çš„åº¦ï¼šæ ‘çš„æ‰€æœ‰ç»“ç‚¹ä¸­æœ€å¤§çš„åº¦æ•° å¶ç»“ç‚¹ï¼ˆLeafï¼‰ï¼šåº¦ä¸º 0 çš„ç»“ç‚¹ çˆ¶ç»“ç‚¹ï¼ˆParentï¼‰ï¼šæœ‰å­æ ‘çš„ç»“ç‚¹æ˜¯å…¶å­æ ‘çš„çš„æ ¹ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ å­ç»“ç‚¹ï¼ˆChildï¼‰ï¼šè‹¥ A ç»“ç‚¹æ˜¯ B ç»“ç‚¹çš„çˆ¶ç»“ç‚¹ï¼Œåˆ™ç§° B ç»“ç‚¹æ˜¯ A ç»“ç‚¹çš„å­ç»“ç‚¹ï¼Œå­ç»“ç‚¹ä¹Ÿç§°ä¸ºå­©å­ç»“ç‚¹ å…„å¼Ÿç»“ç‚¹ï¼ˆSiblingï¼‰ï¼šå…·æœ‰åŒä¸€çˆ¶ç»“ç‚¹çš„å„ç»“ç‚¹å½¼æ­¤æ˜¯å…„å¼Ÿç»“ç‚¹ è·¯å¾„å’Œè·¯å¾„é•¿åº¦ï¼šä»Žç»“ç‚¹ $n_1$ åˆ° $n_k$ çš„è·¯å¾„ä¸ºä¸€ä¸ªç»“ç‚¹åºåˆ— $n_1, n_2, \ldots, n_k, n_i$ æ˜¯ $n_{i+1}$ çš„çˆ¶ç»“ç‚¹ï¼Œè·¯å¾„æ‰€åŒ…å«çš„ä¸ªæ•°ä¸ºè·¯å¾„çš„é•¿åº¦ã€‚ ç¥–å…ˆç»“ç‚¹ï¼ˆAncestorï¼‰ï¼šæ²¿æ ‘æ ¹åˆ°æŸä¸€ç»“ç‚¹è·¯å¾„ä¸Šæ‰€æœ‰ç»“ç‚¹éƒ½æ˜¯è¿™ä¸ªç»“ç‚¹çš„ç¥–å…ˆç»“ç‚¹ å­å­™ç»“ç‚¹ï¼ˆDescendantï¼‰ï¼šæŸä¸€ç»“ç‚¹çš„å­æ ‘ä¸­çš„æ‰€æœ‰ç»“ç‚¹éƒ½æ˜¯è¿™ä¸ªç»“ç‚¹çš„å­å­™ ç»“ç‚¹çš„å±‚æ¬¡ï¼ˆLevelï¼‰ï¼šè§„å®šæ ¹èŠ‚ç‚¹åœ¨1å±‚ï¼Œå…¶ä»–ä»»ä¸€ç»“ç‚¹çš„å±‚æ•°æ˜¯å…¶çˆ¶ç»“ç‚¹å±‚æ•°åŠ 1 æ ‘çš„æ·±åº¦ï¼ˆDepthï¼‰ï¼šæ ‘ä¸­æ‰€æœ‰ç»“ç‚¹ä¸­çš„æœ€å¤§å±‚æ¬¡æ˜¯è¿™æ£µæ ‘çš„æ·±åº¦ è¡¨ç¤ºæ ‘çš„è¡¨ç¤ºæ–¹æ³•æœ‰å¤šç§ï¼Œå› éœ€è¦è¡¨ç¤ºå…¶ä¸­çš„é€»è¾‘å…³ç³»ï¼Œä¸€èˆ¬ä¼šç”¨é“¾è¡¨å®žçŽ°ï¼Œæ•°ç»„æ— æ³•è¡¨ç¤ºå…¶ä¸­çš„é€»è¾‘å…³ç³»ã€‚ å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•åˆ©ç”¨ä¸¤ä¸ªæŒ‡é’ˆæ¥ä¿å­˜é€»è¾‘å…³ç³»ï¼Œå³ï¼šFirstChildæŒ‡é’ˆç”¨æ¥ä¿å­˜ç¬¬ä¸€ä¸ªå­©å­ç»“ç‚¹çš„åœ°å€ï¼ŒNextSiblingæŒ‡é’ˆç”¨æ¥ä¿å­˜ä¸‹ä¸€ä¸ªå…„å¼Ÿç»“ç‚¹çš„åœ°å€ã€‚è¿™æ ·ï¼Œæ¯ä¸ªç»“ç‚¹éœ€è¦ 2 ä¸ªæŒ‡é’ˆåŸŸï¼Œä¸€æ£µæ ‘å…±æœ‰ $n-1$ æ¡è¾¹ï¼Œè¿™æ ·æµªè´¹çš„æŒ‡é’ˆåŸŸä¸ªæ•°ä¸º $2n - (n-1) = n+1$ã€‚ äºŒå‰æ ‘è¡¨ç¤ºæ³•äºŒå‰æ ‘ç®€è¨€ä¹‹å°±æ˜¯åº¦ä¸º2çš„æ ‘ï¼Œä½†ç›¸è¾ƒåº¦ä¸º 2 çš„æ ‘è€Œè¨€ï¼ŒäºŒå‰æ ‘çš„å­æ ‘æœ‰å·¦å³ä¹‹åˆ†ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œæ‰€æœ‰èƒ½ç”¨å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•è¡¨ç¤ºçš„æ ‘éƒ½å¯ä»¥ç”¨äºŒå‰æ ‘æ¥è¡¨ç¤ºï¼Œåªéœ€å°†å„¿å­-å…„å¼Ÿè¡¨ç¤ºæ³•å¾—åˆ°çš„æ ‘æ—‹è½¬ 45Â° å³å¯å¾—å¯¹åº”çš„äºŒå‰æ ‘ã€‚ äºŒå‰æ ‘å‰é¢æåˆ°è¿‡äº†ç”¨äºŒå‰æ ‘æ¥è¡¨ç¤ºæ ‘ï¼Œä½†å®žé™…ä¸ŠäºŒå‰æ ‘è‡ªèº«ä¹Ÿå…·æœ‰ååˆ†ç‹¬ç‰¹çš„æ€§è´¨ã€‚ å®šä¹‰äºŒå‰æ ‘Tï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆã€‚è¿™ä¸ªé›†åˆå¯ä»¥ä¸ºç©ºï¼ˆç©ºäºŒå‰æ ‘ï¼‰ï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™å®ƒæ˜¯ç”±æ ¹ç»“ç‚¹å’Œç§°ä¸ºå…¶å·¦å­æ ‘$T_L$å’Œå³å­æ ‘$T_R$çš„ä¸¤ä¸ªä¸ç›¸äº¤çš„äºŒå‰æ ‘ç»„æˆã€‚äºŒå‰æ ‘æœ‰äº”ç§åŸºæœ¬å½¢æ€ï¼šç©ºæ ‘ã€å•ç»“ç‚¹æ ‘ã€å·¦å­æ ‘ä¸ºç©ºçš„æ ‘ã€å³å­æ ‘ä¸ºç©ºçš„æ ‘å’Œå·¦å³å­æ ‘éƒ½ä¸ç©ºçš„æ ‘ã€‚ æ³¨æ„ï¼šäºŒå‰æ ‘ä¸Žæ™®é€šåº¦ä¸º2çš„æ ‘çš„åŒºåˆ«åœ¨äºŽï¼ŒäºŒå‰æ ‘çš„å­æ ‘æœ‰å·¦å³ä¹‹åˆ†ã€‚ ç‰¹æ®ŠäºŒå‰æ ‘ï¼ˆé¢˜ç›®ä¸­ä¹Ÿå¯èƒ½ä¼šå‡ºçŽ°ï¼‰ï¼š æ–œäºŒå‰æ ‘ï¼ˆSkewed Binary Treeï¼‰ï¼šåªæœ‰å·¦ï¼ˆå³ï¼‰å­æ ‘ï¼Œå½¢çŠ¶ä¸Šå‘ˆçŽ°ä¸€è¾¹å€’çš„æ ·å­ï¼Œç±»ä¼¼é“¾è¡¨ å®Œç¾ŽäºŒå‰æ ‘ï¼ˆPerfect Binary Treeï¼‰ï¼Œä¹Ÿå«æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰ï¼šé™¤äº†å¶ç»“ç‚¹å¤–ï¼Œæ¯ä¸€ä¸ªç»“ç‚¹éƒ½æœ‰ä¸¤ä¸ªå„¿å­ç»“ç‚¹ å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰ï¼šæœ‰nä¸ªç»“ç‚¹çš„äºŒå‰æ ‘ï¼Œå¯¹æ ‘ä¸­ç»“ç‚¹æŒ‰ä»Žä¸Šè‡³ä¸‹ã€ä»Žå·¦åˆ°å³é¡ºåºè¿›è¡Œç¼–å·ï¼Œç¼–å·ä¸ºiï¼ˆ1â‰¤iâ‰¤nï¼‰ç»“ç‚¹ä¸Žæ»¡äºŒå‰æ ‘ä¸­ç¼–å·ä¸ºiç»“ç‚¹åœ¨äºŒå‰æ ‘ä¸­ä½ç½®ç›¸åŒã€‚ æ€§è´¨äºŒå‰æ ‘çš„å‡ ä¸ªé‡è¦æ€§è´¨ï¼š ä¸€ä¸ªäºŒå‰æ ‘ç¬¬ i å±‚çš„æœ€å¤§ç»“ç‚¹æ•°ä¸ºï¼š$2^{i-1}, i \ge 1$ã€‚ æ·±åº¦ä¸º k çš„äºŒå‰æ ‘æœ‰æœ€å¤§ç»“ç‚¹æ ‘ä¸ºï¼š$2^k-1, k \ge 1$ã€‚ å¯¹ä»»ä½•éžç©ºäºŒå‰æ ‘Tï¼Œè‹¥$n_0$è¡¨ç¤ºå¶ç»“ç‚¹çš„ä¸ªæ•°ã€$n_2$æ˜¯åº¦ä¸º2çš„éžå¶ç»“ç‚¹ä¸ªæ•°ï¼Œé‚£ä¹ˆä¸¤è€…æ»¡è¶³å…³ç³»$n_0 = n_2 + 1$ï¼Œè¿™ä¸ªç»“è®ºå¯è¯æ˜Žã€‚ äºŒå‰æ ‘æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šäºŒå‰æ ‘æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰ç©·çš„ç»“ç‚¹é›†åˆï¼Œè‹¥ä¸ä¸ºç©ºï¼Œåˆ™ç”±æ ¹ç»“ç‚¹å’Œå…¶å·¦ã€å³äºŒå‰å­æ ‘ç»„æˆã€‚æ“ä½œé›†ï¼šBT âˆˆ BinTreeï¼ŒItemâˆˆ ElementTypeï¼Œé‡è¦æ“ä½œæœ‰ï¼š Boolean IsEmpty(BinTree BT)ï¼Œåˆ¤åˆ«BTæ˜¯å¦ä¸ºç©º void Traversal(BinTree BT)ï¼ŒéåŽ†ï¼ŒæŒ‰ç…§æŸé¡ºåºè®¿é—®æ¯ä¸ªç»“ç‚¹ BinTree CreatBinTree()ï¼Œåˆ›å»ºä¸€ä¸ªäºŒå‰æ ‘ã€‚ å¸¸è§çš„éåŽ†æ–¹æ³•æœ‰ï¼š void PreOrderTraversal(BinTree BT)ï¼Œå…ˆåºéåŽ†ï¼Œæ ¹â†’å·¦â†’å³ void InOrderTraversal(BinTree BT)ï¼Œä¸­åºéåŽ†ï¼Œå·¦â†’æ ¹â†’å³ void PostOrderTraversal(BinTree BT)ï¼ŒåŽåºéåŽ†ï¼Œå·¦â†’å³â†’æ ¹ void LevelOrderTraversal(BinTree BT)ï¼Œå±‚æ¬¡éåŽ†ï¼Œä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³ äºŒå‰æ ‘çš„é¡ºåºå­˜å‚¨ç»“æž„äºŒå‰æ ‘é¡ºåºå­˜å‚¨ä¸€èˆ¬ç›´æŽ¥ä½¿ç”¨ï¼ˆç»“æž„ï¼‰æ•°ç»„å®žçŽ°ï¼Œè€Œå®Œå…¨äºŒå‰æ ‘ç›´æŽ¥ç”¨ä¸€ç»´æ•°ç»„å³å¯å®žçŽ°ï¼Œä¹Ÿæ˜“äºŽæ“ä½œã€‚å¯¹äºŽä½¿ç”¨æ•°ç»„è¡¨ç¤ºçš„å®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼Œå¯ä»¥é€šè¿‡ç»“ç‚¹çš„åºå·ï¼ˆæ•°ç»„çš„ä¸‹æ ‡ï¼‰ä¸­çš„è§„å¾‹æ¥å¸®åŠ©åæ˜ ç»“ç‚¹ä¹‹é—´çš„çˆ¶å­ï¼ˆé€»è¾‘ï¼‰å…³ç³»ï¼Œå…·ä½“å¦‚ä¸‹ï¼š éžæ ¹ç»“ç‚¹ï¼ˆåºå·$iï¼ž1$ï¼‰çš„çˆ¶ç»“ç‚¹çš„åºå·æ˜¯$\lfloor i/2 \rfloor$ ç»“ç‚¹ï¼ˆåºå·ä¸º$i$ï¼‰çš„å·¦å­©å­ç»“ç‚¹çš„åºå·æ˜¯$2i$ï¼Œè‹¥$2i \geqslant n$ï¼Œå¦åˆ™æ²¡æœ‰å·¦å­©å­ ç»“ç‚¹ï¼ˆåºå·ä¸º$i$ï¼‰çš„å·¦å­©å­ç»“ç‚¹çš„åºå·æ˜¯$2i+1$ï¼Œè‹¥$2i+1 \geqslant n$ï¼Œå¦åˆ™æ²¡æœ‰å³å­©å­ ä¸€èˆ¬ç»“æž„çš„äºŒå‰æ ‘ä¹Ÿå¯ä»¥é‡‡ç”¨è¿™ç§ç»“æž„ï¼Œä½†æ˜¯ä¼šé€ æˆç©ºé—´çš„æµªè´¹ï¼Œå› ä¸ºæ•°ç»„ä¸­ä¹Ÿå­˜å‚¨äº†ç©ºç»“ç‚¹ã€‚ äºŒå‰æ ‘çš„é“¾å¼å­˜å‚¨ç»“æž„å®šä¹‰å¦‚ä¸‹ï¼š123456struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree; äºŒå‰æ ‘çš„éåŽ†äºŒå‰æ ‘çš„éåŽ†æ—¢å¯ä»¥ç›´æŽ¥ç”¨é€’å½’çš„æ€æƒ³å®Œæˆï¼Œä¹Ÿå¯ä»¥å€ŸåŠ©æ ˆæ¥æž„é€ éžé€’å½’çš„éåŽ†ç®—æ³•ã€‚å°½ç®¡é€’å½’çš„ç¼ºç‚¹å¾ˆæ˜Žæ˜¾ï¼Œä½†å¥½åœ¨æ˜“äºŽç†è§£ï¼Œä¸”å½¢å¼ç®€å•ï¼Œä¸€èˆ¬è€Œè¨€éƒ½æ˜¯ç”¨é€’å½’æ¥éåŽ†äºŒå‰æ ‘ã€‚ä¸è¿‡ä»Žå­¦ä¹ çš„è§’åº¦æ¥è®²ï¼Œå¤šæŽ¢ç©¶ä¸€ä¸‹æ²¡æœ‰ä»»ä½•åå¤„ï¼Œæ‰€ä»¥ä¸‹é¢çš„å†…å®¹ä¹Ÿç»™å‡ºéžé€’å½’çš„ç®—æ³•ã€‚æ³¨ï¼šä¸‹é¢çš„ä»£ç æœ‰éƒ¨åˆ†æ˜¯ C++ çš„å†…å®¹ï¼Œä½†å¹¶æ²¡æœ‰ç‰¹åˆ«éš¾äºŽç†è§£åœ°æ–¹ã€‚ å…ˆåºéåŽ†éåŽ†è¿‡ç¨‹ï¼šè®¿é—®æ ¹ç»“ç‚¹ â†’ å…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘1234567891011121314151617181920212223void preorder(Tree root) &#123; /* method 1: use recursion if(!root) return; cout &lt;&lt; root-&gt;data &lt;&lt; ' '; preorder(root-&gt;left); preorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; &#125; ä¸­åºéåŽ†éåŽ†è¿‡ç¨‹ï¼šå…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ è®¿é—®æ ¹ç»“ç‚¹ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘1234567891011121314151617181920212223void inorder(Tree root) &#123; /* method 1: use recursion if(!root) return; inorder(root-&gt;left); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; inorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;right; &#125; &#125;&#125; åŽåºéåŽ†éåŽ†è¿‡ç¨‹ï¼šå…ˆåºéåŽ†å…¶å·¦å­æ ‘ â†’ å…ˆåºéåŽ†å…¶å³å­æ ‘ â†’ è®¿é—®æ ¹ç»“ç‚¹åŽåºéåŽ†çš„éžé€’å½’ç®—æ³•å…¶å®žæœ‰å¾ˆå¤šï¼Œè¿™é‡Œä¸¾ä¸¤ä¸ªä¾‹å­ï¼Œåˆ†åˆ«ä½¿ç”¨äº† 2 ä¸ªæ ˆå’Œ 1 ä¸ªæ ˆæ¥å®Œæˆï¼Œä½¿ç”¨åŒæ ˆçš„æ€è·¯è¾ƒä¸ºç›´è§‚ä¸€äº›ï¼Œå»ºè®®åŠ¨æ‰‹æ¨¡æ‹Ÿä¸€ä¸‹ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void postorder(Tree root) &#123; /* method 1: use recursion if(!root) return; postorder(root-&gt;left); postorder(root-&gt;right); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; */ /* method 2: use loop and two stacks stack&lt;PtrToTNode&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; root = st2.top(); st2.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; &#125; */ /* method 3: use loop and one stack */ stack&lt;PtrToTNode&gt; st; PtrToTNode pre = NULL, cur = NULL; st.push(root); while(!st.empty()) &#123; cur = st.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur) &#123; if(cur-&gt;left != NULL) st.push(cur-&gt;left); else if(cur-&gt;right != NULL) st.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre) &#123; if(cur-&gt;right != NULL) &#123; st.push(cur-&gt;right); &#125; &#125; else &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; st.pop(); &#125; pre = cur; &#125;&#125; å±‚åºéåŽ†éåŽ†è¿‡ç¨‹ï¼šä»Žç¬¬ä¸€å±‚å¼€å§‹ï¼Œä»Žå·¦å¾€å³ä¾æ¬¡è®¿é—®æ¯ä¸ªç»“ç‚¹ã€‚å±‚åºéåŽ†ä¸€èˆ¬ç”¨é˜Ÿåˆ—å®žçŽ°ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æ ˆæ¥å®žçŽ°ã€‚å±‚åºéåŽ†ä¸€èˆ¬é‡‡ç”¨è¿­ä»£ï¼ˆå¾ªçŽ¯ï¼‰çš„æ€æƒ³æ¥å®žçŽ°ã€‚123456789101112void levelorder(Tree root) &#123; queue&lt;PtrToTNode&gt; q; q.push(root); while(!q.empty()) &#123; PtrToTNode front = q.front(); q.pop(); cout &lt;&lt; front-&gt;data &lt;&lt; ' '; if(front-&gt;left) q.push(front-&gt;left); if(front-&gt;right) q.push(front-&gt;right); &#125; cout &lt;&lt; endl;&#125; ä½œä¸š03-1 æ ‘çš„åŒæž„æŒ‰ç…§è¿™é“é¢˜ç›®ç»™å®šçš„æ•°æ®å½¢å¼ï¼Œç”¨é™æ€é“¾è¡¨çš„æ–¹å¼è¡¨ç¤ºæ ‘ï¼Œè§£èµ·é¢˜æ¥ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼ˆæ­£å¦‚å§¥å§¥å‰é¢è¯´è¿‡ï¼šåˆé€‚çš„æ•°æ®ç»“æž„èƒ½å¤Ÿå¸®åŠ©æˆ‘ä»¬è§£å†³é—®é¢˜ï¼‰ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥åŠ¨è„‘å­æƒ³ä¸€æƒ³æ€Žä¹ˆç”¨æŒ‡é’ˆæ¥è§£å†³ã€‚å¦å¤–ï¼Œåœ¨åˆ¤æ–­æ ‘æ˜¯å¦åŒæž„æ—¶è¦æ³¨æ„é—®é¢˜è€ƒè™‘å…¨é¢ï¼ˆè¯»é¢˜ä»”ç»†ï¼‰ï¼Œç†è§£é€’å½’çš„å«ä¹‰ï¼Œâ€œåŒæž„å…¶å®žå¹¶æ²¡æœ‰è¦æ±‚æ ‘çš„ç»“æž„å®Œå…¨ä¸€è‡´ï¼Œåªè¦æ±‚ç»“ç‚¹åˆ†å¸ƒä¸€è‡´å³å¯ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 15struct TNode&#123; char data; int left, right;&#125; T1[maxn], T2[maxn];void init() &#123; int i; for(i = 0; i &lt; maxn; i++) &#123; T1[i].left = T1[i].right = T2[i].left = T2[i].right = -1; &#125;&#125;int buildtree(struct TNode T[]) &#123; int i, n; scanf("%d%*c", &amp;n); char data, lc, rc; bool isRoot[maxn] = &#123;false&#125;; for(i = 0; i &lt; n; i++) &#123; scanf("%c %c %c%*c", &amp;data, &amp;lc, &amp;rc); T[i].data = data; if(lc != '-') &#123; T[i].left = lc - '0'; isRoot[lc - '0'] = true; &#125; if(rc != '-') &#123; T[i].right = rc - '0'; isRoot[rc - '0'] = true; &#125; &#125; int root = -1; for(i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; return root;&#125;bool Isomorphic(int root1, int root2) &#123; if(root1 == -1 &amp;&amp; root2 == -1) return true; if((root1 == -1 &amp;&amp; root2 != -1) || (root1 != -1 &amp;&amp; root2 == -1)) return false; if(T1[root1].data != T2[root2].data) return false; if(T1[root1].left == -1 &amp;&amp; T2[root2].left == -1) &#123; return Isomorphic(T1[root1].right, T2[root2].left); &#125; if((T1[root1].left != -1 &amp;&amp; T2[root2].left != -1) &amp;&amp; (T1[T1[root1].left].data == T2[T2[root2].left].data)) &#123; return Isomorphic(T1[root1].left, T2[root2].left) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].right); &#125; else return Isomorphic(T1[root1].left, T2[root2].right) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].left);&#125;int main() &#123; init(); int root1 = buildtree(T1); int root2 = buildtree(T2); if(Isomorphic(root1, root2)) printf("Yes"); else printf("No"); return 0;&#125;/*some samples:in:00out: Yes*/ 03-2 List Leavesé¢˜ç›®è¦æ±‚æ‰¾ä¸€æ£µæ ‘ä¸­çš„æ‰€æœ‰å¶å­ç»“ç‚¹ï¼ˆæ— å­©å­ï¼‰ï¼Œé¡ºåºæ˜¯ä»Žä¸Šåˆ°ä¸‹ï¼Œä»Žå·¦åˆ°å³ã€‚å¦‚æžœè¦è®¿é—®æ‰€æœ‰å¶å­ç»“ç‚¹ï¼Œé‚£ä¹ˆè‚¯å®šå°‘ä¸äº†æ ‘çš„éåŽ†ã€‚è¿›è€Œå¯ä»¥æƒ³åˆ°ï¼Œé¢˜ç›®è¦æ±‚çš„è¾“å‡ºé¡ºåºä¸Žå±‚åºéåŽ†çš„è¾“å‡ºé¡ºåºæ˜¯ä¸€è‡´çš„ã€‚æ‰€ä»¥å¯ä»¥å€ŸåŠ©å±‚åºéåŽ†çš„ä»£ç æ¥æž„é€ è¾“å‡ºå¶å­ç»“ç‚¹çš„ç®—æ³•ã€‚ç”±äºŽå±‚åºéåŽ†éœ€è¦ç”¨åˆ°é˜Ÿåˆ—ï¼Œç›´æŽ¥ç”¨ C++ çš„ STL å†…çš„ Queueã€‚æ ¹æ®é¢˜ç›®çš„å½¢å¼ï¼Œè¿˜æ˜¯ç”¨é™æ€é“¾è¡¨çš„æ–¹æ³•æ¥è¡¨ç¤ºæ ‘ã€‚12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 20;struct node&#123; int left, right;&#125; Tree[maxn];bool isRoot[20] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;void levelorder(int root) &#123; queue&lt;int&gt; q; q.push(root); bool flag = true; while(!q.empty()) &#123; int tmp = q.front(); q.pop(); if(Tree[tmp].left == -1 &amp;&amp; Tree[tmp].right == -1) &#123; if(flag) &#123; cout &lt;&lt; tmp; flag = false; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; tmp; &#125; &#125; if(Tree[tmp].left != -1) q.push(Tree[tmp].left); if(Tree[tmp].right != -1) q.push(Tree[tmp].right); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; char c1, c2; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; c1 &gt;&gt; c2; if(c1 != '-') &#123; isRoot[c1 - '0'] = true; Tree[i].left = c1 - '0'; &#125; if(c2 != '-') &#123; isRoot[c2 - '0'] = true; Tree[i].right = c2 - '0'; &#125; &#125; int root; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; levelorder(root); return 0;&#125; 03-3 Tree Traversals Againé¢˜ç›®è€ƒå¯ŸäºŒå‰æ ‘çš„å…ˆåºã€ä¸­åºå’ŒåŽåºéåŽ†ï¼ˆä¸€é“é¢˜ç›®è€ƒåˆ°äº†æ ‘çš„ä¸‰ç§éåŽ†æ–¹æ³•ï¼‰ã€‚ é¢˜ç›®èƒŒæ™¯æ˜¯äºŒå‰æ ‘ä¸­åºéåŽ†çš„éžé€’å½’ç®—æ³•çš„å…¥ã€å‡ºæ ˆé¡ºåºï¼Œå®žé™…ä¸Šï¼Œå…¥æ ˆé¡ºåºå°±æ˜¯å…ˆåºåºåˆ—ï¼Œå‡ºæ ˆé¡ºåºå°±æ˜¯ä¸­åºåºåˆ—ã€‚è¿™æ ·å¯ä»¥ä½¿ç”¨å…ˆåºåºåˆ—å’Œä¸­åºåºåˆ—æž„é€ æ ‘ï¼Œè¿›è€Œåœ¨é€šè¿‡åŽåºéåŽ†æ¥è¾“å‡ºåŽåºåºåˆ—ã€‚é‚£ä¹ˆå¦‚ä½•è¡¨ç¤ºæ ‘å‘¢ï¼Ÿç”±äºŽæœ¬é¢˜ç»™å®šçš„æ•°æ®å¹¶æ²¡æœ‰ç»™å‡ºæ ‘çš„å…·ä½“ç»“æž„ï¼Œå®žé™…ä¸Šç”¨é“¾å¼ç»“æž„æˆ–è€…é¡ºåºç»“æž„çš„å¤æ‚åº¦éƒ½æ˜¯ä¸€æ ·çš„ã€‚ ä¸è¿‡æ­¤é¢˜ä¹Ÿå¯ä»¥ä¸ç”¨æž„é€ æ ‘ï¼Œç›´æŽ¥é€šè¿‡é€’å½’æ¥å¾—åˆ°åŽåºåºåˆ—ã€‚ä¸è¿‡ä¸æ˜¯é‚£ä¹ˆå¥½ç†è§£ï¼Œå»ºè®®æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€ä¸‹ï¼Œç¬”è¯•ä¸­ä¹Ÿæœ‰ç±»ä¼¼çš„é¢˜ç›®ï¼Œæ€è·¯æœ¬è´¨ä¸Šæ˜¯ä¸€æ ·çš„ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* method 1: Do not build a tree. use recursion */#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5; int in[maxn], pre[maxn], post[maxn], n;void solve(int preL, int inL, int postL, int n) &#123; if(n == 0) return; if(n == 1) &#123; post[postL] = pre[preL]; return; &#125; int root = pre[preL], i; post[postL + n - 1] = root; for(i = 0; i &lt; n; i++) &#123; if(in[inL + i] == root) break; &#125; int L = i, R = n - L - 1; solve(preL + 1, inL, postL, L); solve(preL + L + 1, inL + L + 1, postL + L, R);&#125;int main() &#123; string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; solve(0, 0, 0, n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if(i != n - 1) putchar(' '); &#125; return 0;&#125;/* method 2: use static tree #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5;struct node&#123; int left, right; int data;&#125; Tree[maxn];int in[maxn], pre[maxn], n;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;int buildtree(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) return -1; Tree[preL].data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) break; &#125; int numLeft = k - inL; Tree[preL].left = buildtree(preL + 1, preL + numLeft, inL, k - 1); Tree[preL].right = buildtree(preL + numLeft + 1, preR, k + 1, inR); return preL;&#125;int num = 0;void postorder(int root) &#123; if(root == -1) return; postorder(Tree[root].left); postorder(Tree[root].right); cout &lt;&lt; Tree[root].data; if(num &lt; n - 1) cout &lt;&lt; ' '; num++;&#125;int main() &#123; init(); string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; buildtree(0, n - 1, 0, n - 1); postorder(0); return 0;&#125;*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_02-çº¿æ€§ç»“æž„]]></title>
    <url>%2F2020%2F02%2F12%2FZJU-DS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[ä»€ä¹ˆæ˜¯çº¿æ€§ç»“æž„ï¼Ÿå¦‚ä½•è¡¨ç¤ºå’Œå®žçŽ°ï¼Ÿæœ‰å“ªäº›çº¿æ€§ç»“æž„ï¼Ÿå¯¹åº”çš„æœ‰ä»€ä¹ˆæ ·æ€§è´¨ï¼Ÿå¸¸è§çš„åº”ç”¨æœ‰å“ªäº›ï¼Ÿ Linear Liståœ¨ä»‹ç»çº¿æ€§è¡¨ä¹‹å‰ï¼Œä½•è€å¸ˆå…ˆä»‹ç»äº†çº¿æ€§è¡¨çš„ä¸€ä¸ªåº”ç”¨å®žä¾‹ â€”â€” ä¸€å…ƒå¤šé¡¹å¼åŠå…¶è¿ç®—ã€‚è€Œå…³äºŽä¸€å…ƒå¤šé¡¹å¼çš„è¡¨ç¤ºæ–¹æ³•ï¼Œè€å¸ˆä»‹ç»äº†ä¸‰ç§æ–¹æ³•ï¼š æ•°ç»„ï¼ˆé¡ºåºå­˜å‚¨ç»“æž„ï¼‰ç›´æŽ¥è¡¨ç¤ºï¼Œæ•°ç»„ä¸‹æ ‡å¯¹åº”æœªçŸ¥æ•° x çš„æŒ‡æ•°ï¼Œæ•°ç»„å…ƒç´ çš„å€¼å¯¹åº”å„é¡¹çš„ç³»æ•°ï¼Œä½†å¯¹äºŽæŸäº›ç‰¹æ®Šçš„å¤šé¡¹å¼ï¼Œæ­¤æ³•ä¼šæœ‰è¾ƒå¤šçš„ç©ºé—´æµªè´¹ã€‚ ç»“æž„æ•°ç»„ï¼ˆé¡ºåºå­˜å‚¨ç»“æž„ï¼‰è¡¨ç¤ºéžé›¶é¡¹ï¼Œå°†ä¸€ä¸ªå¤šé¡¹å¼çœ‹æˆæ˜¯ä¸€ä¸ªæŒ‡æ•°ä¸Žç³»æ•°çš„äºŒå…ƒç»„çš„é›†åˆï¼Œå¤šé¡¹å¼çš„æ¯ä¸€é¡¹éœ€æŒ‰ç…§æŒ‡æ•°å¤§å°æœ‰åºå­˜å‚¨ã€‚ é“¾è¡¨å­˜å‚¨éžé›¶é¡¹ï¼Œé“¾è¡¨ä¸­æ¯ä¸ªç»“ç‚¹å­˜å‚¨å¤šé¡¹å¼ä¸­çš„ä¸€ä¸ªéžé›¶é¡¹ï¼ŒåŒ…æ‹¬ç³»æ•°å’ŒæŒ‡æ•°ä¸¤ä¸ªæ•°æ®åŸŸå’Œä¸€ä¸ªæŒ‡é’ˆåŸŸã€‚ ä¸Šè¿°ä¸‰ç§æ–¹æ³•ä¸­ï¼Œåˆ©ç”¨æ•°ç»„è¡¨ç¤ºæ˜¯æ˜“äºŽå®žçŽ°çš„ï¼Œä½†æ˜¯ä¸æ˜“è®¾è®¡ä¸Žå¤šé¡¹å¼ç›¸å…³çš„åŠ å‡æ“ä½œã€‚è€Œä½¿ç”¨é“¾è¡¨æ¥è¡¨ç¤ºååˆ†çµæ´»ï¼Œä¸”æ˜“äºŽå®žçŽ°å¯¹åº”æ“ä½œã€‚ä»Žè¿™å¯ä»¥çœ‹å‡ºï¼ŒåŒä¸€ä¸ªé—®é¢˜å¯ä»¥æœ‰ä¸åŒçš„è¡¨ç¤ºï¼ˆå­˜å‚¨ï¼‰æ–¹æ³•ï¼›å­˜åœ¨ä¸€ç±»å…±æ€§é—®é¢˜ï¼Œå³ï¼šæœ‰åºçº¿æ€§åºåˆ—çš„ç»„ç»‡å’Œç®¡ç†ã€‚ç”±æ­¤å¯ä»¥å¼•å‡ºçº¿æ€§è¡¨çš„æ¦‚å¿µï¼šç”±åŒç±»åž‹æ•°æ®å…ƒç´ æž„æˆæœ‰åºåºåˆ—çš„çº¿æ€§ç»“æž„ï¼Œå…·å¤‡ä»¥ä¸‹ä¸‰ä¸ªç‰¹ç‚¹ï¼š è¡¨ä¸­å…ƒç´ ä¸ªæ•°ç§°ä¸ºçº¿æ€§è¡¨çš„é•¿åº¦ çº¿æ€§è¡¨æ²¡æœ‰å…ƒç´ æ—¶ï¼Œç§°ä¸ºç©ºè¡¨ è¡¨èµ·å§‹ä½ç½®ç§°è¡¨å¤´ï¼Œè¡¨ç»“æŸä½ç½®ç§°è¡¨å°¾ çº¿æ€§è¡¨çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šçº¿æ€§è¡¨ï¼ˆListï¼‰æ•°æ®å¯¹è±¡é›†ï¼šçº¿æ€§è¡¨æ˜¯$n(â‰¥0)$ä¸ªå…ƒç´ æž„æˆçš„æœ‰åºåºåˆ—æ“ä½œé›†ï¼šçº¿æ€§è¡¨$L âˆˆ List$ï¼Œæ•´æ•°$i$è¡¨ç¤ºä½ç½®ï¼Œå…ƒç´ $X âˆˆ ElementType$ï¼Œä¸»è¦æ“ä½œï¼š List MakeEmpty()ï¼Œåˆå§‹åŒ–ä¸€ä¸ªç©ºçº¿æ€§è¡¨ ElementType FindKth(int K, List L)ï¼Œæ ¹æ®ä½åºKï¼Œè¿”å›žç›¸åº”å…ƒç´  int Find(ElementType X, List L)ï¼Œåœ¨çº¿æ€§è¡¨Lä¸­æŸ¥æ‰¾Xçš„ç¬¬ä¸€æ¬¡å‡ºçŽ°ä¸ºæ­¢ void Insert(ElementType X, int i, List L)ï¼Œåœ¨ä½åºiå‰æ’å…¥ä¸€ä¸ªæ–°å…ƒç´ X void Delete(int i, List L)ï¼Œåˆ é™¤æŒ‡å®šä½åºiçš„å…ƒç´  int Length(List L)ï¼Œè¿”å›žçº¿æ€§è¡¨Lçš„é•¿åº¦n çº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨å®žçŽ°é¡ºåºè¡¨çš„é¡ºåºå­˜å‚¨å®žçŽ°åˆ©ç”¨æ•°ç»„æ¥è¿žç»­å­˜å‚¨ç©ºé—´é¡ºåºå­˜æ”¾çº¿æ€§è¡¨çš„å„å…ƒç´ ï¼ŒC è¯­è¨€ç‰ˆæœ¬çš„å®šä¹‰ï¼ˆåŽæ–‡çš„ä»£ç éƒ½æ˜¯ C è¯­è¨€çš„ï¼‰å¦‚ä¸‹ï¼š1234567typedef int ElementType;typedef int Position; /*note here! */typedef struct LNode* List; /* struct LNode * = List */struct LNode&#123; ElementType Data[MAXSIZE]; /* #define MAXSIZE 100 */ Position Last; /* the length of list */&#125;; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºè¡¨ï¼‰æŒ‰ç…§ä¸Šé¢çš„å®šä¹‰ï¼Œæˆ‘ä»¬å¯ä»¥å†™å‡ºå»ºç«‹ç©ºè¡¨çš„æ“ä½œã€‚123456List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; /*use -1 to represent that the list is blank */ return L;&#125; æŸ¥æ‰¾å‰é¢ä¸€è®²ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†äºŒåˆ†æŸ¥æ‰¾ï¼Œé‚£ä¹ˆäºŒåˆ†æŸ¥æ‰¾æ˜¯å¦èƒ½åœ¨æ­¤å¤„åº”ç”¨å‘¢ï¼Ÿè¦æ³¨æ„çš„æ˜¯ï¼ŒäºŒåˆ†æŸ¥æ‰¾çš„å‰ææ¡ä»¶æœ‰ä¸¤ä¸ªï¼š é¡ºåºå­˜å‚¨å’Œæ•°æ®æœ‰åºã€‚ è¿™é‡Œæˆ‘ä»¬é‡‡ç”¨æŒ‰ç…§é¡ºåºä»Žå‰å¾€åŽæŸ¥æ‰¾çš„æ–¹æ³•æ¥ç¼–å†™è¿™ä¸ªæ“ä½œï¼Œéœ€è¦å°†è¢«æŸ¥æ‰¾çš„æ•°æ®å…ƒç´ å’Œæ‰€æŸ¥æ‰¾çš„çº¿æ€§è¡¨äº¤ç»™å‡½æ•°ã€‚å½“ç„¶ï¼Œå¦‚æžœçº¿æ€§è¡¨æ˜¯å…¨å±€å˜é‡ï¼Œé‚£ä¹ˆå¯ä»¥ä¸ç”¨ä¼ å…¥çº¿æ€§è¡¨ï¼Œè¿™é‡Œå‡è®¾çº¿æ€§è¡¨æ˜¯åœ¨mainå‡½æ•°ä¸­å£°æ˜Žçš„ã€‚12345678Position Find(ElementType X, List L) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return -1; /*can't find the element*/ else return i; /*return the index of this element*/&#125; é‚£ä¹ˆè¯¥å¦‚ä½•è®¡ç®—æŸ¥æ‰¾æˆåŠŸçš„å¹³å‡æ¯”è¾ƒæ¬¡æ•°å‘¢ï¼Ÿå‡è®¾æœ‰ n ä¸ªå…ƒç´ ï¼Œå¦‚æžœç¬¬ä¸€ä¸ªå…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å…ƒç´ ï¼Œé‚£ä¹ˆæ­¤æ—¶æŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ 1 æ¬¡ï¼›ç»§è€Œå¯çŸ¥å½“ç¬¬äºŒä¸ªå…ƒç´ å°±æ˜¯æˆ‘ä»¬è¦æŸ¥æ‰¾çš„å…ƒç´ æ—¶ï¼ŒæŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ 2 æ¬¡ï¼›ä»Žè€Œæˆ‘ä»¬å¯ä»¥çŸ¥é“å¯¹äºŽ n ä¸ªå…ƒç´ çš„çº¿æ€§è¡¨æŸ¥æ‰¾æˆåŠŸçš„æ¯”è¾ƒæ¬¡æ•°å°±æ˜¯ï¼š$(1 + 2 + ... + n) / n = (1 + n) / 2$ã€‚è¿™è¯´æ˜Žè¿™ç§æ€è·¯çš„æŸ¥æ‰¾ç®—æ³•çš„å¹³å‡æ—¶é—´æ€§èƒ½æ˜¯$O(n)$ã€‚ æ’å…¥åœ¨ç›´æŽ¥ä¸Šæ‰‹å†™æ’å…¥æ“ä½œä¹‹å‰éœ€è¦æƒ³ä¸€æƒ³æ’å…¥æ“ä½œçš„å‡ ç§æƒ…å†µï¼šè¡¨å¤´ã€è¡¨ä¸­å’Œè¡¨å°¾ã€‚é’ˆå¯¹è¿™ä¸‰ç§ä¸åŒçš„æƒ…å†µï¼Œæˆ‘ä»¬å¯ä»¥å‘çŽ°åªæœ‰å½“åœ¨è¡¨å°¾æ’å…¥çš„æ—¶å€™æ‰ä¸éœ€è¦å°†å…ƒç´ ç§»åŠ¨ï¼›åŒæ—¶ï¼Œåœ¨æ¯ä¸€æ¬¡æ’å…¥æ“ä½œæ—¶ï¼Œç”±äºŽçº¿æ€§è¡¨å¯èƒ½å·²ç»æ»¡äº†ï¼Œé‚£ä¹ˆæ’å…¥æ“ä½œå°±ä¼šå¤±è´¥äº†ï¼Œè¿™ä¹Ÿæ˜¯éœ€è¦è€ƒè™‘çš„æƒ…å†µï¼ŒæŽ¥ç€ï¼Œæˆ‘ä»¬æ¥å†™ä¸€ä¸‹ä»£ç ã€‚12345678910111213141516void Insert(ElementType X, int i, List PtrL) &#123; int j; if(PtrL-&gt;Last == MAXSIZE - 1) &#123; printf("The list is full.\n"); return; &#125; if(i &lt; 1 || i &gt; PtrL-&gt;Last + 2) &#123; printf("The position of the insertion is not valid.\n"); return; &#125; for(j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; PtrL-&gt;Data[i - 1] = X; PtrL-&gt;Last++;&#125; ä»Žä¸Šè¿°ä»£ç å¯ä»¥çœ‹å‡ºï¼š ç”±äºŽçº¿æ€§è¡¨çš„é¡ºåºå­˜å‚¨ç»“æž„å€ŸåŠ©äº†æ•°ç»„ï¼Œæ‰€ä»¥å½“æ•°ç»„ä¸‹æ ‡ä¸º$MAXSIZE - 1$æ—¶ï¼Œè¡¨ç¤ºçº¿æ€§è¡¨å·²æ»¡ã€‚ å½“æ’å…¥ä½ç½® i å°äºŽ 1 æˆ–è€…å¤§äºŽPtrL-&gt;Last + 2æ—¶ï¼Œæ’å…¥ä½ç½®å°±æ˜¯ä¸åˆæ³•çš„ã€‚ä¹‹æ‰€ä»¥å¤§äºŽPtrL-&gt;Last + 2ä¸åˆæ³•æ˜¯å› ä¸ºï¼Œå½“PtrL-&gt;Last == MAXSIZE - 2æ—¶ï¼ŒPtrL-&gt;Last + 2 == MAXSIZEï¼Œé‚£ä¹ˆ i å°±å¤§äºŽäº†MAXSIZEï¼Œé‚£å°±è¶…å‡ºèŒƒå›´äº†ã€‚è¿™é‡Œè¦åŒºåˆ†å¥½ä¸¤ä¸ªæ¦‚å¿µï¼šæ’å…¥ä½ç½®å’Œå­˜å‚¨ä½ç½®ã€‚æ’å…¥ä½ç½®æ˜¯äººä¸ºè§„å®šä¸”ä»Ž 1 å¼€å§‹çš„ï¼ˆç¬¦åˆäººçš„æ€è€ƒä¹ æƒ¯ï¼‰ï¼Œè€Œå­˜å‚¨ä½ç½®æ˜¯ä»Ž 0 å¼€å§‹çš„ï¼Œå› ä¸ºæ•°ç»„ä¸‹æ ‡æ˜¯ä»Ž 0 å¼€å§‹çš„ã€‚åŽé¢çš„ç§»åŠ¨æ“ä½œä¹Ÿæ˜¯åŸºäºŽè¿™ä¸ªå‰ææ¥ç¼–å†™çš„ã€‚ æ‰€æ’å…¥ä½ç½®åŽçš„å…¨éƒ¨å…ƒç´ éœ€è¦å‘åŽç§»åŠ¨ã€‚ åˆ é™¤æœ‰äº†æ’å…¥æ“ä½œçš„åŸºç¡€ï¼Œåˆ é™¤æ“ä½œå°±æ¯”è¾ƒå®¹æ˜“äº†ï¼Œå› ä¸ºæˆ‘ä»¬åªéœ€å…ˆæ‰¾åˆ°è¦åˆ é™¤çš„å…ƒç´ ï¼Œç„¶åŽå°†æ­¤å…ƒç´ åŽçš„æ‰€æœ‰å…ƒç´ å‘å‰ç§»åŠ¨ä¸€ä¸ªä½ç½®å³å¯ï¼Œä½†æ˜¯è¦æ³¨æ„è¡¨ä¸ºç©ºçš„æƒ…å†µï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112void Delete(int P, List PtrL) &#123; Position i; if(P &lt; 1 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125; æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXSIZE 10#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; return L;&#125;Position Find(List L, ElementType X) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return ERROR; else return i;&#125;bool Insert(List L, ElementType X, Position P) &#123; Position i; if(L-&gt;Last == MAXSIZE - 1) &#123; printf("Sequence List is full!\n"); return false; &#125; if(P &lt; 1 || P &gt; L-&gt;Last + 2) &#123; printf("The inserting position is illegal!\n"); return false; &#125; for(i = L-&gt;Last; i &gt;= P - 1; i--) &#123; L-&gt;Data[i + 1] = L-&gt;Data[i]; &#125; L-&gt;Data[P - 1] = X; L-&gt;Last++; return true;&#125;bool Delete(List L, Position P) &#123; Position i; if(P &lt; 0 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125;void Print(List L) &#123; if(L-&gt;Last == -1) printf("The Sequence List is empty!\n"); else &#123; int i = 0; while(i &lt; L-&gt;Last) &#123; printf("%d, ", L-&gt;Data[i]); i++; &#125; printf("%d\n", L-&gt;Data[i]); &#125;&#125;int main() &#123; List Sqlist = MakeEmpty(); bool flag = Insert(Sqlist, 11, 0); printf("flag = %d\n", flag); Insert(Sqlist, 22, 1); Insert(Sqlist, 33, 2); Insert(Sqlist, 44, 3); Print(Sqlist); bool del_flag = Delete(Sqlist, 2); printf("del_flag = %d\n", del_flag); Print(Sqlist); &#125; çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨å®žçŽ°çº¿æ€§è¡¨çš„é“¾å¼å­˜å‚¨å®žçŽ°å°±æ˜¯å¤§å®¶ç†ŸçŸ¥çš„é“¾è¡¨äº†ï¼Œå­¦è¿‡ C è¯­è¨€çš„åŒå­¦å¯èƒ½å·²ç»å­¦ä¼šäº†å¦‚ä½•æž„é€ ã€ä½¿ç”¨é“¾è¡¨ç­‰ã€‚ç›¸æ¯”é¡ºåºè¡¨è€Œè¨€ï¼Œé“¾è¡¨çš„æœ€çªå‡ºçš„ä¸€ä¸ªç‰¹ç‚¹å°±æ˜¯ä¸å†è¦æ±‚é¡ºåºå­˜å‚¨äº†ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œé“¾è¡¨ä¸­çš„å„ä¸ªå…ƒç´ åœ¨å†…å­˜ä¸­çš„ä½ç½®æ˜¯ä¸ä¸€å®šç›¸é‚»çš„ã€‚å…ˆçœ‹ä¸€ä¸‹é“¾è¡¨çš„å®šä¹‰ï¼š123456789#define ERROR NULLtypedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List; è¿™é‡Œä½¿ç”¨ä¸åŒçš„å…³é”®è¯æ¥è¡¨ç¤ºæŒ‡å‘é“¾è¡¨çš„æŒ‡é’ˆï¼Œè¿™æ ·åœ¨åŽé¢çš„å„ç§æ“ä½œä¸­å¯ä»¥åŒºåˆ†å„ä¸ªæŒ‡é’ˆçš„ä½œç”¨ï¼Œè®©è¯»ä»£ç çš„äººæ›´åŠ æ˜“äºŽä»Žå•è¯æ„æ€æ¥ç†è§£ä»£ç ã€‚ åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºè¡¨ï¼‰é“¾è¡¨å»ºç«‹ç©ºè¡¨çš„åŸºæœ¬æ–¹æ³•æœ‰å¤´æ’æ³•å’Œå°¾æ’æ³•ï¼Œä½¿ç”¨ä¸åŒçš„æ–¹æ³•å»ºç«‹é“¾è¡¨å¯ä»¥å¾—åˆ°ä¸åŒçš„æ•ˆæžœï¼Œå¯ä»¥æ–¹ä¾¿æˆ‘ä»¬è§£å†³é—®é¢˜ï¼Œä»¥ä¸‹ä»£ç ä»¥å¸¦å¤´ç»“ç‚¹çš„å•é“¾è¡¨ä¸ºè¯´æ˜Žå¯¹è±¡ã€‚ æ±‚è¡¨é•¿é“¾è¡¨ä¸åŒäºŽé¡ºåºè¡¨ï¼Œé¡ºåºè¡¨çš„è¡¨åŽ‚æ˜¯é™å®šçš„ï¼Œä½†æ˜¯é“¾è¡¨çš„é•¿åº¦æ˜¯æ— é™çš„ï¼ˆå‡è®¾å†…å­˜æ— é™ï¼‰ï¼Œæ‰€ä»¥è‡ªç„¶å°±ä¼šæœ‰æ±‚é“¾è¡¨è¡¨é•¿çš„é—®é¢˜äº§ç”Ÿã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„æœ€ç›´è§‚çš„æ€è·¯ä¹Ÿå°±æ˜¯å°†é“¾è¡¨éåŽ†ï¼ˆä»Žå¤´ç»“ç‚¹è®¿é—®åˆ°å°¾ç»“ç‚¹ï¼‰ä¸€éå³å¯ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789int GetLength(List L) &#123; List p = L-&gt;Next; /*Let's say the linked list has head node. */ int length = 0; while(p) &#123; p = p-&gt;Next; length++; &#125; return length;&#125; æŸ¥æ‰¾é“¾è¡¨çš„æŸ¥æ‰¾æœ‰ä¸¤ç§æƒ…å†µï¼Œåˆ†åˆ«æ˜¯ï¼šæŒ‰åºå·æŸ¥æ‰¾å’ŒæŒ‰å€¼æŸ¥æ‰¾ã€‚è¿™ä¸¤ç§æŸ¥æ‰¾æ–¹æ³•æ€è·¯æ¯”è¾ƒç®€å•ï¼Œæœ¬è´¨ä¸Šéƒ½æ˜¯å¯¹é“¾è¡¨è¿›è¡ŒéåŽ†ã€‚ æŒ‰åºå·æŸ¥æ‰¾12345678910List FindKth(int K, List PtrL) &#123; List p = PtrL; int i = 1; while(p != NULL &amp;&amp; i &lt; K) &#123; p = p-&gt;Next; i++; &#125; if(i == K) return p; else return NULL;&#125; æŒ‰å€¼æŸ¥æ‰¾123456Position Find(ElementType X, List L) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125; æ’å…¥å¾€é“¾è¡¨ä¸­æ’å…¥ä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆå°±éœ€è¦å…ˆæž„é€ ä¸€ä¸ªæ–°çš„ç»“ç‚¹ï¼Œç„¶åŽå†å°†è¿™ä¸ªæ–°çš„ç»“ç‚¹æ’å…¥åˆ°é“¾è¡¨ä¸­ã€‚é‚£ä¹ˆï¼Œå¦‚ä½•è¿›è¡Œæ’å…¥å‘¢ï¼Ÿ å‡å¦‚è¦æ’å…¥åˆ°ç¬¬ i ä¸ªä½ç½®ï¼Œé‚£ä¹ˆå°±å¿…é¡»å…ˆè¦æ‰¾åˆ°ç¬¬ i - 1 ä¸ªä½ç½®ï¼Œç„¶åŽå†å°†è¿™ä¸ªæ–°ç»“ç‚¹æ’å…¥åˆ°ç¬¬ i - 1 ä¸ªç»“ç‚¹çš„åŽé¢ã€‚å¦å¤–ï¼Œæ­¤å¤„é“¾å¼ç»“æž„çš„æŒ‡é’ˆåº”ç”¨ä¸€ç›´æ˜¯è®©åˆå­¦è€…å¤´ç–¼çš„é—®é¢˜ã€‚ä½†å®žé™…ä¸Šï¼Œåˆ†æžè¿™ç±»é—®é¢˜æ—¶ï¼Œéƒ½æœ‰ä¸€ä¸ªåŽŸåˆ™ï¼šå¿…é¡»è¦å…ˆè®©æ–°ç»“ç‚¹æŒ‡å‘åŽé¢çš„ç»“ç‚¹ï¼Œæ‰èƒ½å†è®©å‰é¢çš„ç»“ç‚¹æŒ‡å‘æ–°ç»“ç‚¹ã€‚è¿™ç‚¹å…¶å®žä¹Ÿä¸éš¾ç†è§£ï¼Œå‡å¦‚è®©å‰é¢çš„ç»“ç‚¹å…ˆæŒ‡å‘æ–°ç»“ç‚¹ï¼Œé‚£ä¹ˆåŽé¢çš„ç»“ç‚¹å°±ä¸¢å¤±äº†ï¼Œå› ä¸ºæŒ‡å‘åŽé¢çš„ç»“ç‚¹çš„å”¯ä¸€æŒ‡é’ˆï¼ˆå³å‰é¢ç»“ç‚¹çš„æŒ‡é’ˆï¼‰å·²ç»æŒ‡å‘äº†æ–°ç»“ç‚¹ã€‚è¯è¯´èµ·æ¥æ˜¯å¾ˆæ‹—å£ä¸”ä¸é‚£ä¹ˆç›´è§‚ï¼Œå»ºè®®ç”¨ç¬”åœ¨çº¸ä¸Šç”»ä¸€ç”»ã€‚ æŒ‰ç…§ä¸åŒçš„æŸ¥æ‰¾æ–¹æ³•ï¼Œä¹Ÿå¯ä»¥ç»™å‡ºä¸åŒçš„æ’å…¥æ–¹æ³•ã€‚ æŒ‰åºå·æ’å…¥1234567891011121314151617181920bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125; æŒ‰å€¼æ’å…¥1234567891011121314151617bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125; åˆ é™¤ç”±äºŽæˆ‘ä»¬å·²ç»æ˜Žç¡®äº†æŸ¥æ‰¾çš„æ–¹å¼ï¼Œæ‰€ä»¥åˆ é™¤æ“ä½œå¯ä»¥ç®€åŒ–ä¸€äº›äº†ï¼Œåªè¦ç¡®ä¿æŒ‡å‘è¢«åˆ é™¤å…ƒç´ çš„æŒ‡é’ˆæ­£ç¡®ä¼ ç»™åˆ é™¤å‡½æ•°å³å¯ã€‚12345678910111213141516bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125; æµ‹è¯•ä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define ERROR NULL#define MAXSIZE 10typedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List;Position Find(List L, ElementType X) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125;Position FindKth(List L, int k) &#123; PtrToLNode p = L; int i = 0; while(p &amp;&amp; i &lt; k) &#123; i++; p = p-&gt;Next; &#125; if(i == k) return p; else return NULL;&#125;List MakeEmpty() &#123; List L = (List)malloc(sizeof(struct LNode)); L-&gt;Next = NULL; return L;&#125;PtrToLNode CreateLNode(int value) &#123; PtrToLNode t = (PtrToLNode)malloc(sizeof(struct LNode)); t-&gt;Next = NULL; t-&gt;Data = value; return t;&#125;bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125;bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125;bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125;void Print(List L) &#123; if(L-&gt;Next == NULL) printf("The link list is empty!\n"); else &#123; L = L-&gt;Next; while(L-&gt;Next != NULL) &#123; printf("%d, ", L-&gt;Data); L = L-&gt;Next; &#125; printf("%d\n", L-&gt;Data); &#125;&#125;int main() &#123; List L = MakeEmpty(); PtrToLNode t = CreateLNode(11); L-&gt;Next = t; Print(L); int ins_flag = Insert_1(L, 22, Find(L, 11)); printf("ins_flag = %d\n", ins_flag); Print(L); Insert_1(L, 33, Find(L, 22)); Insert_1(L, 44, Find(L, 33)); Print(L); int del_flag = Delete(L, Find(L, 33)); printf("del_flag = %d\n", del_flag); Print(L); printf("/*--------------------*/\n"); Insert_2(L, 55, 3); Print(L); Insert_2(L, 8, 2); Print(L); printf("%d\n", Insert_2(L, 9, 10)); Print(L); return 0;&#125; Generalized Listå…³äºŽå¹¿ä¹‰è¡¨çš„å«ä¹‰ï¼Œä½•è€å¸ˆçš„ PPT é‡Œé¢è¯´çš„æ¯”è¾ƒæ¸…æ¥šäº†ï¼Œå³: å¹¿ä¹‰è¡¨æ˜¯çº¿æ€§è¡¨çš„æŽ¨å¹¿ å¯¹äºŽå¹¿ä¹‰è¡¨è€Œè¨€ï¼Œn ä¸ªå…ƒç´ éƒ½æ˜¯åŸºæœ¬çš„å•å…ƒç´  å¹¿ä¹‰è¡¨ä¸­ï¼Œè¿™äº›å…ƒç´ ä¸ä»…å¯ä»¥æ˜¯å•å…ƒç´ ä¹Ÿå¯ä»¥æ˜¯å¦ä¸€ä¸ªå¹¿ä¹‰è¡¨ å…¶å®žè¯´ç™½äº†ï¼Œå¹¿ä¹‰è¡¨æ˜¯ä¸ªå¤§é›†åˆï¼Œå›Šæ‹¬äº†çº¿æ€§è¡¨è¿™ä¸ªå°é›†åˆã€‚ å…³äºŽå¤šé‡é“¾è¡¨ï¼Œå…¶å®žæ˜¯å¹¿ä¹‰è¡¨çš„ä¸€ç§åº”ç”¨ï¼Œä¹Ÿå³çº¿æ€§è¡¨ä¸­çš„æ¯ä¸€ä¸ªâ€œç»“ç‚¹â€ï¼Œåˆæ˜¯ä¸€ä¸ªçº¿æ€§è¡¨ã€‚å¤šé‡é“¾è¡¨å¤šåº”ç”¨ä¸ŽäºŽæ ‘ï¼ˆçº¿ç´¢äºŒå‰æ ‘ç­‰ï¼‰å’Œå›¾ï¼ˆåå­—é“¾è¡¨ç­‰ï¼‰è¿™ç±»å¤æ‚çš„æ•°æ®ç»“æž„ï¼Œå½“ç„¶ï¼Œæ ‘å’Œå›¾ä¹Ÿå¯ä»¥ä¸é‡‡ç”¨å¤šé‡é“¾è¡¨æ¥å­˜å‚¨ã€‚ Stackå †æ ˆï¼ˆStackï¼‰ï¼Œå…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨ï¼Œåªåœ¨ä¸€ç«¯ï¼ˆæ ˆé¡¶ï¼ŒTopï¼‰åšæ’å…¥ã€åˆ é™¤æ“ä½œã€‚æ’å…¥æ•°æ®ï¼šå…¥æ ˆï¼ˆPushï¼‰åˆ é™¤æ•°æ®ï¼šå‡ºæ ˆï¼ˆPopï¼‰åŽå…¥å…ˆå‡ºï¼šLast In First Outï¼ˆLIFOï¼‰ å †æ ˆçš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šå †æ ˆï¼ˆStackï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸ºMaxSizeçš„å †æ ˆS âˆˆ Stackï¼Œå †æ ˆå…ƒç´ item âˆˆ ElementTypeï¼Œä¸»è¦æ“ä½œï¼š Stack CreateStack(int MaxSize)ï¼Œç”Ÿæˆç©ºå †æ ˆï¼Œå…¶æœ€å¤§é•¿åº¦ä¸ºMaxSize int IsFull(Stack S, int MaxSize)ï¼Œåˆ¤æ–­å †æ ˆSæ˜¯å¦å·²æ»¡ void Push(Stack S, ElementType item)ï¼Œå°†å…ƒç´ itemåŽ‹å…¥å †æ ˆ int IsEmpty(Stack S)ï¼Œåˆ¤æ–­å †æ ˆSæ˜¯å¦ä¸ºç©º ElementType Pop(Stack S)ï¼Œåˆ é™¤å¹¶è¿”å›žæ ˆé¡¶å…ƒç´  æ ˆçš„é¡ºåºå­˜å‚¨å®žçŽ°æ ˆçš„é¡ºåºå­˜å‚¨ç»“æž„é€šå¸¸ç”±ä¸€ä¸ªä¸€ç»´æ•°ç»„å’Œä¸€ä¸ªè®°å½•æ ˆé¡¶å…ƒç´ ä½ç½®çš„å˜é‡ç»„æˆï¼ŒC è¯­è¨€ç‰ˆæœ¬çš„å®šä¹‰å¦‚ä¸‹ï¼š12345678910#define MAXSIZE 10 /*store the maximum number of data*/#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;typedef struct SNode *Stack; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºæ ˆï¼‰1234567Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125; åˆ¤æ–­æ ˆæ»¡123bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125; åˆ¤æ–­æ ˆç©º123bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125; å…¥æ ˆç”±äºŽé¡ºåºæ ˆæ˜¯ç”±æ•°ç»„å­˜å‚¨ï¼Œè€Œæ•°ç»„æœ‰å¤§å°ï¼Œå½“æ•°ç»„æ²¡æœ‰ç©ºé—´çš„æ—¶å€™å°±æ— æ³•è¿›è¡Œå…¥æ ˆæ“ä½œï¼Œæ‰€ä»¥åœ¨å…¥æ ˆæ“ä½œä¹‹å‰å°±å¿…é¡»è¦åˆ¤æ–­æ ˆæ˜¯å¦æ»¡äº†ã€‚123456789bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125; å‡ºæ ˆä¸Žå…¥æ ˆæ“ä½œç±»ä¼¼ï¼Œå½“æ ˆä¸ºç©ºæ—¶ï¼Œæ˜¾ç„¶æ— æ³•è¿›è¡Œå‡ºæ ˆæ“ä½œã€‚12345678ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125; æ±‚æ ˆå†…å…ƒç´ ä¸ªæ•°123int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125; æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct SNode&#123; ElementType *Data; Position Top; int MaxSize;&#125;;typedef struct SNode *Stack;Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125;bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125;bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125;bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125;ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125;int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125;int main() &#123; Stack S = Createstack(5); Pop(S); printf("S.size = %d\n", Getsize(S)); int push_flag = Push(S, 11); Push(S, 22); Push(S, 33); int x = Pop(S); printf("push_flag = %d, x = %d\n", push_flag, x); printf("S.size = %d\n", Getsize(S)); Push(S, 33); Push(S, 44); Push(S, 55); Push(S, 66); printf("S.size = %d\n", Getsize(S)); return 0;&#125; æ ˆçš„é“¾å¼å­˜å‚¨ç»“æž„å®žçŽ°æ ˆçš„é“¾å¼å­˜å‚¨ç»“æž„å®žé™…ä¸Šå°±æ˜¯ä¸€ä¸ªå•é“¾è¡¨ï¼Œå«åšé“¾æ ˆã€‚æ’å…¥å’Œåˆ é™¤æ“ä½œåªèƒ½åœ¨é“¾æ ˆçš„æ ˆé¡¶è¿›è¡Œï¼Œæ³¨æ„æ ˆé¡¶æŒ‡é’ˆ top åªèƒ½åœ¨é“¾è¡¨çš„è¡¨å¤´ã€‚1234567typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºæ ˆï¼‰123456Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; å…¥æ ˆç”±äºŽé“¾æ ˆæ˜¯é€šè¿‡ç”³è¯·å†…å­˜æž„é€ ç»“ç‚¹çš„ï¼Œæ‰€ä»¥ç†è®ºä¸Šä¸å­˜åœ¨æ ˆæ»¡çš„æƒ…å†µï¼ˆå†…å­˜æ»¡äº†å°±ä¸èƒ½åˆ†é…ç©ºé—´äº†ï¼‰ã€‚1234567bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125; åˆ¤æ–­æ ˆç©ºå°½ç®¡é“¾æ ˆä¸ç”¨åˆ¤æ–­æ ˆæ»¡ï¼Œä½†æ˜¯åœ¨è¿›è¡Œå‡ºæ ˆæ“ä½œæ—¶éœ€è¦åˆ¤æ–­æ ˆæ˜¯å¦ä¸ºç©ºã€‚123bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125; å‡ºæ ˆ1234567891011121314ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125; æ±‚æ ˆå†…å…ƒç´ ä¸ªæ•°12345678int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125; æµ‹è¯•ä»£ç 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack;Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125;bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125;bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125;ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125;int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125;int main() &#123; Stack S = Createstack(); Pop(S); printf("S.size = %d\n", Getsize(S)); Push(S, 11); Push(S, 22); Push(S, 33); printf("S.top = %d\n", Pop(S)); Push(S, 33); Push(S, 44); Push(S, 55); printf("S.size = %d\n", Getsize(S)); return 0;&#125; Queueé˜Ÿåˆ—ä¹Ÿæ˜¯å…·æœ‰ä¸€å®šæ“ä½œçº¦æŸçš„çº¿æ€§è¡¨ï¼ˆä¸Žå †æ ˆç±»ä¼¼ï¼‰ï¼Œåªèƒ½åœ¨ä¸€ç«¯æ’å…¥ï¼Œè€Œåœ¨å¦ä¸€ç«¯åˆ é™¤ã€‚æ•°æ®æ’å…¥ï¼šå…¥é˜Ÿåˆ—ï¼ˆAddQï¼‰æ•°æ®åˆ é™¤ï¼šå‡ºé˜Ÿåˆ—ï¼ˆDeleteQï¼‰å…ˆæ¥å…ˆæœåŠ¡ï¼Œå…ˆè¿›å…ˆå‡ºï¼ŒFirst In First Outï¼ŒFIFO é˜Ÿåˆ—çš„æŠ½è±¡æ•°æ®ç±»åž‹æè¿°ç±»åž‹åç§°ï¼šé˜Ÿåˆ—ï¼ˆQueueï¼‰æ•°æ®å¯¹è±¡é›†ï¼šä¸€ä¸ªæœ‰0ä¸ªæˆ–å¤šä¸ªå…ƒç´ çš„æœ‰ç©·çº¿æ€§è¡¨æ“ä½œé›†ï¼šé•¿åº¦ä¸ºMaxSizeçš„é˜Ÿåˆ—Q âˆˆ Queueï¼Œé˜Ÿåˆ—å…ƒç´ item âˆˆ ElementTypeï¼Œä¸»è¦æ“ä½œï¼š Queue CreatQueue(int MaxSize)ï¼Œç”Ÿæˆé•¿åº¦ä¸ºMaxSizeçš„ç©ºé˜Ÿåˆ— int IsFullQ(Queue Q, int MaxSize)ï¼Œåˆ¤æ–­é˜Ÿåˆ—Qæ˜¯å¦å·²æ»¡ void AddQ(Queue Q, ElementType item)ï¼Œå°†æ•°æ®å…ƒç´ itemæ’å…¥é˜Ÿåˆ—Qä¸­ int IsEmptyQ(Queue Q)ï¼Œåˆ¤æ–­é˜Ÿåˆ—Qæ˜¯å¦ä¸ºç©º ElementType DeleteQ(Queue Q)ï¼Œå°†å¯¹å¤´æ•°æ®å…ƒç´ ä»Žé˜Ÿåˆ—ä¸­åˆ é™¤å¹¶è¿”å›ž é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨å®žçŽ°é˜Ÿåˆ—çš„é¡ºåºå­˜å‚¨å®žçŽ°ä¸Žé¡ºåºæ ˆçš„å®žçŽ°æ–¹å¼ç›¸åŒï¼Œè¿˜æ˜¯éœ€è¦å€ŸåŠ©ä¸€ä¸ªæ•°ç»„æ¥å­˜å‚¨å…ƒç´ ã€‚ä½†ä¸Žæ ˆä¸åŒçš„æ˜¯é˜Ÿåˆ—éœ€è¦æœ‰é˜Ÿå¤´ï¼ˆfrontï¼‰æŒ‡é’ˆå’Œé˜Ÿå°¾ï¼ˆrearï¼‰æŒ‡é’ˆï¼Œå®šä¹‰å¦‚ä¸‹ï¼š12345678typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºé˜Ÿåˆ—ï¼‰1234567Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125; åˆ¤æ–­é˜Ÿç©º123bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125; åˆ¤æ–­é˜Ÿæ»¡123bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125; å…¥é˜Ÿä¸ºäº†æ›´å¥½çš„åˆ©ç”¨æ•°ç»„ï¼Œé‡‡å–å¾ªçŽ¯é˜Ÿåˆ—çš„è®¾è®¡æ–¹æ³•ï¼Œå€ŸåŠ©å–ä½™è¿ç®—åˆšå¥½å¯ä»¥æ»¡è¶³è¦æ±‚ï¼Œå‡ºé˜Ÿæ—¶åŒç†ã€‚12345678910bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125; å‡ºé˜Ÿ123456789ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125; æ±‚é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°123int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125;bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125;ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125;int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125;void print(Queue q) &#123; int i; for(i = 0; i &lt; 5; i++) &#123; printf("%d ", q-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); printf("%d\n", Getsize(q)); Addq(q, 22); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 33); Addq(q, 44); Addq(q, 55); print(q); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); Addq(q, 66); x = Deleteq(q); x = Deleteq(q); Addq(q, 66); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); return 0;&#125; é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨å®žçŽ°é˜Ÿåˆ—çš„é“¾å¼å­˜å‚¨å®žçŽ°è¦æ¯”é“¾æ ˆçš„å®žçŽ°ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œéœ€è¦æœ‰ä¸€ä¸ªå•ç‹¬çš„é˜Ÿåˆ—ç»“æž„ï¼ˆåŒ…å«é˜Ÿå¤´æŒ‡é’ˆå’Œé˜Ÿå°¾æŒ‡é’ˆï¼‰æ¥æŒ‡å‘é˜Ÿåˆ—ï¼Œå®šä¹‰å¦‚ä¸‹ï¼š123456789101112typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; åˆå§‹åŒ–ï¼ˆå»ºç«‹ç©ºé˜Ÿåˆ—ï¼‰123456Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125; æ±‚é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°123456789int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125; åˆ¤æ–­é˜Ÿç©º123bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125; åˆ¤æ–­é˜Ÿæ»¡ç”±äºŽä¸Šè¿°å®šä¹‰è®¾ç½®çš„æœ‰MaxSizeï¼Œé»˜è®¤é“¾é˜Ÿåˆ—æ˜¯æœ‰æœ€å¤§ç©ºé—´çš„ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºæ»¡ã€‚1234bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125; å…¥é˜Ÿ12345678910111213141516bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125; å‡ºé˜Ÿ123456789101112131415ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125; æµ‹è¯•ä»£ç 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125;ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125;int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125;bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); Addq(q, 11); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); Addq(q, 22); Addq(q, 33); Addq(q, 44); Addq(q, 55); Addq(q, 66); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); return 0;&#125; Homework02-1 ä¸¤ä¸ªæœ‰åºé“¾è¡¨åºåˆ—çš„åˆå¹¶æ­¤é¢˜è€ƒå¯Ÿé“¾è¡¨çš„åˆå¹¶æ“ä½œï¼Œæ³¨æ„é“¾è¡¨æœ‰åºä¸”ç»™å®šé“¾è¡¨å¸¦å¤´ç»“ç‚¹ï¼Œè¦æ±‚åˆå¹¶åŽé“¾è¡¨ä¸ºéžé€’å‡åºåˆ—ï¼Œæ‰€ä»¥éœ€è¦å¯¹æ¯ä¸€ä¸ªç»“ç‚¹å€¼è¿›è¡Œæ¯”è¾ƒï¼Œä»£ç å¦‚ä¸‹ï¼ˆå…¶ä¸­å‡½æ•°ä½“ä¸ºéœ€è¦æäº¤çš„ä»£ç ï¼‰ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read();void Print( List L );List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;List Read() &#123; int i, n, temp; scanf("%d", &amp;n); List L, p; L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = temp; t-&gt;Next = NULL; p-&gt;Next = t; p = t; &#125; return L;&#125;void Print( List L ) &#123; PtrToNode p = L-&gt;Next; if(!p) &#123; printf("NULL\n"); return; &#125; while(p-&gt;Next != NULL) &#123; printf("%d ", p-&gt;Data); p = p-&gt;Next; &#125; printf("%d\n", p-&gt;Data);&#125;List Merge( List L1, List L2 ) &#123; PtrToNode p, p1 = L1-&gt;Next, p2 = L2-&gt;Next; L1-&gt;Next = L2-&gt;Next = NULL; List L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;Data &lt; p2-&gt;Data) &#123; p-&gt;Next = p1; p = p1; p1 = p1-&gt;Next; &#125; else &#123; p-&gt;Next = p2; p = p2; p2 = p2-&gt;Next; &#125; &#125; if(p1) p-&gt;Next = p1; if(p2) p-&gt;Next = p2; return L;&#125; 02-2 ä¸€å…ƒå¤šé¡¹å¼çš„ä¹˜æ³•ä¸ŽåŠ æ³•è¿ç®—è¿™é“é¢˜çš„ä½•è€å¸ˆå·²ç»è®²è¿‡äº†ï¼ŒæŒ‰ç…§ä½•è€å¸ˆç»™çš„æ€è·¯ï¼Œè¡¥å…¨æ‰€æœ‰ä»£ç å³å¯ï¼ˆæœ€åº•ä¸‹æä¾›äº†å‡ ç»„æµ‹è¯•ç”¨ä¾‹ï¼‰ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct PolyNode* Polynomial;typedef struct PolyNode* PtrToPolyNode;struct PolyNode &#123; int coef, expon; struct PolyNode *link;&#125;;PtrToPolyNode CreateNode(int c, int e) &#123; PtrToPolyNode t = (PtrToPolyNode)malloc(sizeof(struct PolyNode)); t-&gt;coef = c, t-&gt;expon = e; t-&gt;link = NULL; return t;&#125;Polynomial ReadPoly() &#123; int n, c, e; scanf("%d", &amp;n); Polynomial P, p; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; if(n == 0) &#123; PtrToPolyNode t = CreateNode(0, 0); p-&gt;link = t; &#125; else &#123; while(n--) &#123; scanf("%d %d", &amp;c, &amp;e); PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; &#125; return P;&#125;void Print(Polynomial P) &#123; if(P-&gt;link == NULL) &#123; printf("0 0\n"); return; &#125; else &#123; P = P-&gt;link; while(P-&gt;link != NULL) &#123; printf("%d %d ", P-&gt;coef, P-&gt;expon); P = P-&gt;link; &#125; printf("%d %d\n", P-&gt;coef, P-&gt;expon); &#125;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2 = P2-&gt;link; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;expon == p2-&gt;expon) &#123; int e = p1-&gt;expon, c = p1-&gt;coef + p2-&gt;coef; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else if(p1-&gt;expon &gt; p2-&gt;expon) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; else &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; &#125; while(p1 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; while(p2 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; return P;&#125;Polynomial Multi(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; while(p1) &#123; p2 = P2-&gt;link; while(p2) &#123; int c = p1-&gt;coef * p2-&gt;coef; int e = p1-&gt;expon + p2-&gt;expon; p = P; while(p-&gt;link != NULL &amp;&amp; p-&gt;link-&gt;expon &gt; e) p = p-&gt;link; if(p-&gt;link != NULL) &#123; if(p-&gt;link-&gt;expon == e) &#123; int ctmp = p-&gt;link-&gt;coef + c; if(ctmp == 0) &#123; PtrToPolyNode tmp = p-&gt;link; p-&gt;link = tmp-&gt;link; free(tmp); &#125; else &#123; p-&gt;link-&gt;coef = ctmp; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; p2 = p2-&gt;link; &#125; p1 = p1-&gt;link; &#125; return P;&#125;int main() &#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PS = Add(P1, P2); PP = Multi(P1, P2); Print(PP); Print(PS); return 0;&#125;/*some samples:in:1 -1 11 1 1out:-1 20 0in:2 -1 1 2 01 1 1out:-1 2 2 12 0in:2 1 1 1 02 1 1 -1 0out:1 2 -1 02 1in:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1out:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0in:1 0 03 1 3 1 2 1 1out:0 01 3 1 2 1 1in:2 2 0 0 03 3 2 2 1 1 0out:6 2 4 1 2 03 2 2 1 3 0in:01 10 0out:0 010 0*/ 02-3 Reversing Linked Listæ­¤é¢˜é¢˜æ„æ¯”è¾ƒç›´æŽ¥ï¼Œä½†æ˜¯æµ‹è¯•ç‚¹æ¯”è¾ƒå¤šï¼Œè¦è€ƒè™‘å…¨é¢ã€‚æŽ¨èä½¿ç”¨é™æ€é“¾è¡¨çš„æ–¹æ³•è§£é¢˜ï¼Œè¿™æ ·è€—æ—¶è¾ƒå°‘ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#define maxn 100005int addr[maxn], address[maxn], data[maxn], next[maxn];void reverse(int A[], int left, int right) &#123; for(; left &lt; right; left++, right--) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125;&#125;int main() &#123; int src, n, k, m; scanf("%d %d %d", &amp;src, &amp;n, &amp;k); m = n; int tmp_add, tmp_data, tmp_next; while(m--) &#123; scanf("%d %d %d", &amp;tmp_add, &amp;tmp_data, &amp;tmp_next); address[tmp_add] = tmp_add; next[tmp_add] = tmp_next; data[tmp_add] = tmp_data; &#125; int len = 1, i, j, tmp = src; addr[0] = src; while(src != -1) &#123; addr[len++] = next[src]; src = next[src]; &#125; for(i = 0, j = k; j &lt;= len - 1; i = j, j += k) &#123; reverse(addr, i, j - 1); &#125; for(i = 0; i &lt; len - 2; i++) &#123; src = addr[i]; printf("%05d %d %05d\n", src, data[src], addr[i + 1]); &#125; printf("%05d %d -1\n", address[addr[i]], data[addr[i]]); return 0;&#125;/*some samples:in:00100 6 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:68237 6 9999999999 5 0000000000 4 3321833218 3 1230912309 2 0010000100 1 -1in:00100 6 300000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:33218 3 1230912309 2 0010000100 1 6823768237 6 9999999999 5 0000000000 4 -1in:00100 6 100000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:00100 1 1230912309 2 3321833218 3 0000000000 4 9999999999 5 6823768237 6 -1in:00100 5 300000 4 9999900100 1 1230933218 3 0000099999 5 -112309 2 33218out:33218 3 1230912309 2 0010000100 1 0000000000 4 9999999999 5 -1in:00100 9 200000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 3321833333 7 2222244444 8 1111103333 9 02222out:12309 2 0010000100 1 0000000000 4 3321833218 3 6823768237 6 9999999999 5 -1in:00100 3 200100 1 -111111 2 2222233333 3 44444out:00100 1 -1*/ 02-4 Pop Sequenceæœ¬é¢˜è€ƒå¯Ÿæ ˆçš„ç›¸å…³çŸ¥è¯†ï¼Œæœ¬è´¨ä¸Šæ˜¯æ¨¡æ‹Ÿæ ˆçš„ç›¸å…³æ“ä½œï¼ŒæŽ¨èä½¿ç”¨ C++ è‡ªå¸¦çš„ STL æ¨¡æ¿é‡Œé¢çš„ Stack ï¼Œå¯ä»¥ç›´æŽ¥æ‹¿æ¥ä½¿ç”¨ï¼Œä½†éœ€è¦å…ˆäº†è§£ä¸€ä¸‹ç”¨æ³•ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];int main() &#123; int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; bool flag = true; while(k--) &#123; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; bool flag = true; int i = 1, j = 1; while(j &lt;= n + 1) &#123; if(st.size() &gt; m) &#123; flag = false; break; &#125; if(!st.empty()) &#123; if(st.top() == seq[i]) &#123; st.pop(); i++; &#125; else st.push(j++); &#125; else st.push(j++); &#125; if(flag &amp;&amp; st.size() == 1) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; /*some samples:in:5 7 15 6 4 3 7 2 1out:YESsome sample:in:2 4 41 2 3 42 1 3 41 2 4 33 1 2 4out:YESYESYESNO*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_01-åŸºæœ¬æ¦‚å¿µ]]></title>
    <url>%2F2020%2F02%2F11%2FZJU-DS-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[æ­¤ç¯‡ç³»åˆ—åšæ–‡æ˜¯åšä¸»è‡ªå·±åœ¨ MOOC ä¸Šè‡ªå­¦æµ™æ±Ÿå¤§å­¦æ•°æ®ç»“æž„è¯¾ç¨‹æ—¶çš„ç¬”è®°ï¼Œæ¯ä¸€è®²éƒ½æœ‰å¯¹åº”çš„ç¬”è®°ï¼Œå¯¹åº”ä¸€ç¯‡åšæ–‡ã€‚è™½ç„¶ä¹‹å‰ä¸Šè¯¾æ—¶å°±åšå¥½äº†ç¬”è®°ï¼Œä½†å¯¹å¾ˆå¤šçŸ¥è¯†ç‚¹çš„ç†è§£æ¯”è¾ƒæµ…æ˜¾ï¼ŒçŽ°åœ¨å›žè¿‡å¤´æ¥æ•´ç†ï¼Œå¸Œæœ›ä¼šæœ‰æ‰€å¯å‘ã€‚å¦å¤–ï¼Œè‡ªå­¦ä¹‹è·¯éš¾å…ä¼šæœ‰é”™è¯¯ï¼Œæ¬¢è¿Žçœ‹åˆ°æ–‡ç« çš„åŒå­¦ä¸åèµæ•™ã€‚å¦å¤–ï¼Œé¢˜è§£ä»£ç åœ¨ Github ä¸Šçš„åœ°å€ï¼š201909_MOOC_DS_ChenYue What is Data Structureä½•è°“æ•°æ®ç»“æž„ï¼ŸæŒ‰ç…§å§¥å§¥çš„è®²è§£ï¼Œæ²¡æœ‰ç‰¹å®šçš„æ•°æ®ç»“æž„çš„å®šä¹‰ã€‚ä¸è¿‡ï¼Œé€šè¿‡è¯¾ä¸Šå§¥å§¥ä¸¾çš„ä¸€äº›ä¾‹å­ï¼Œå¯ä»¥å¾—å‡ºï¼šæ•°æ®ç»“æž„å°±æ˜¯æ•°æ®å¯¹è±¡åœ¨è®¡ç®—æœºä¸­çš„ç»„ç»‡æ–¹å¼ã€‚å…·ä½“è€Œè¨€ï¼Œæ•°æ®å¯¹è±¡åŒ…å«ï¼š é€»è¾‘ç»“æž„ï¼šç¬¬ä¸€æ¬¡å­¦æ•°æ®ç»“æž„çš„äººå¯èƒ½ä¼šå¯¹è¿™ä¸ªæ¦‚å¿µæœ‰ç‚¹æ‡µï¼Œå¦‚æžœå·²ç»æŽŒæ¡äº†ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€ï¼Œå¹¶ä¸”å…·å¤‡äº†ä¸€å®šçš„æ°´å¹³çš„è¯ï¼Œç†è§£èµ·æ¥è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ã€‚è¿™é‡Œä¸¾ä¸ªä¾‹å­ï¼Œæ¯”å¦‚å¾‹è¯—çš„é€»è¾‘ç»“æž„å°±æ˜¯ï¼šé¦–è”ã€é¢”è”ã€é¢ˆè”å’Œå°¾è”ã€‚ ç‰©ç†å­˜å‚¨ç»“æž„ï¼šå¯ä»¥æš‚æ—¶ç†è§£ä¸ºç¡¬ç›˜ä¹‹ç±»çš„å­˜å‚¨å™¨çš„ç»“æž„ã€‚ å½“ç„¶ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨æŠ½è±¡æ•°æ®ç±»åž‹ï¼ˆAbstract Data Typeï¼‰æ¥æè¿°æ•°æ®ç»“æž„ï¼ŒåŒ…æ‹¬ï¼š æ•°æ®å¯¹è±¡é›†ï¼šç®€è€Œè¨€ä¹‹å°±æ˜¯ç”±æ•°æ®ç»„æˆçš„é›†åˆã€‚ æ•°æ®é›†åˆç›¸å…³è”çš„æ“ä½œé›†ï¼šå¤„ç†è¿™äº›æ•°æ®å¯¹è±¡çš„æ“ä½œæ–¹æ³•ã€‚ å…¶ä¸­ï¼ŒæŠ½è±¡çš„å«ä¹‰æ˜¯ï¼šæè¿°æ•°æ®ç±»åž‹çš„æ–¹æ³•ä¸ä¾èµ–äºŽå…·ä½“å®žçŽ°ï¼Œä¸Žå­˜æ”¾æ•°æ®çš„æœºå™¨æ— å…³ï¼Œä¸Žæ•°æ®å­˜å‚¨çš„ç‰©ç†ç»“æž„æ— å…³ï¼Œä¸Žå®žçŽ°æ“ä½œçš„ç®—æ³•å’Œç¼–ç¨‹è¯­è¨€å‡æ— å…³ã€‚ æŠ½è±¡æ•°æ®ç±»åž‹å…¶å®žå°±æ˜¯é¢å‘å¯¹è±¡ç¨‹åºè®¾è®¡è¯­è¨€ä¸­çš„â€œç±»ï¼ˆClassï¼‰â€çš„å«ä¹‰ã€‚è¦æ³¨æ„ï¼Œæ•°æ®å¯¹è±¡å¿…å®šä¸Žä¸€ç³»åˆ—åŠ åœ¨ä¸Šé¢çš„æ“ä½œæ˜¯ç›¸å…³è”ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå•ç‹¬å­˜åœ¨çš„æ•°æ®å¯¹è±¡æˆ–æ“ä½œé›†æ˜¯æ— æ³•è¢«ç§°ä¹‹ä¸ºæ•°æ®ç»“æž„çš„ã€‚è€Œåœ¨æ•°æ®ç»“æž„ä¸­ï¼Œå®Œæˆç›¸å…³æ“ä½œé›†æ‰€ç”¨çš„æ–¹æ³•å°±æ˜¯ç®—æ³•ï¼ˆAlgorithmï¼‰ã€‚ å…¶å®žï¼Œæ•°æ®ç»“æž„æœ¬èº«å°±æ˜¯ä¸€ä¸ªé€»è¾‘çš„æ¦‚å¿µã€‚ What is Algorithmç®—æ³•åŒ…å«ä»¥ä¸‹å‡ ä¸ªè¦ç´ ï¼š ä¸€ä¸ªæœ‰é™æŒ‡ä»¤é›† æŽ¥å—ä¸€äº›è¾“å…¥ï¼ˆæœ‰äº›æƒ…å†µä¸‹ä¸éœ€è¦è¾“å…¥ï¼‰ äº§ç”Ÿè¾“å‡º ä¸€å®šåœ¨æœ‰é™æ­¥éª¤ä¹‹åŽç»ˆæ­¢ æ¯ä¸€æ¡æŒ‡ä»¤å¿…é¡»ï¼šæœ‰å……åˆ†æ˜Žç¡®çš„ç›®æ ‡ï¼Œä¸å¯ä»¥æœ‰æ­§ä¹‰ï¼Œå¹¶ä¸”è®¡ç®—æœºèƒ½å¤„ç†çš„èŒƒå›´ä¹‹å†…ï¼Œå¦å¤–ï¼Œæè¿°åº”ä¸ä¾èµ–äºŽä»»ä½•ä¸€ç§è®¡ç®—æœºè¯­è¨€ä»¥åŠå…·ä½“çš„å®žçŽ°æ‰‹æ®µã€‚ Measure for Algorithmæ—¶é—´å¤æ‚åº¦ï¼ˆ$S(n)$ï¼‰ï¼šæ ¹æ®ç®—æ³•å†™æˆçš„ç¨‹åºåœ¨æ‰§è¡Œæ—¶è€—è´¹æ—¶é—´çš„é•¿åº¦ã€‚è¿™ä¸ªé•¿åº¦å¾€å¾€ä¹Ÿä¸Žè¾“å…¥æ•°æ®çš„è§„æ¨¡æœ‰å…³ã€‚æ—¶é—´å¤æ‚åº¦è¿‡é«˜çš„ä½Žæ•ˆç®—æ³•å¯èƒ½å¯¼è‡´æˆ‘ä»¬æœ‰ç”Ÿä¹‹å¹´éƒ½ç­‰ä¸åˆ°è¿è¡Œç»“æžœã€‚ ç©ºé—´å¤æ‚åº¦ï¼ˆ$T(n)$ï¼‰ï¼šæ ¹æ®ç®—æ³•å†™æˆçš„ç¨‹åºåœ¨æ‰§è¡Œæ—¶å ç”¨å­˜å‚¨å•å…ƒçš„é•¿åº¦ã€‚è¿™ä¸ªé•¿åº¦å¾€å¾€ä¸Žè¾“å…¥æ•°æ®çš„è§„æ¨¡æœ‰å…³ã€‚ç©ºé—´å¤æ‚åº¦è¿‡é«˜çš„ç®—æ³•å¯èƒ½å¯¼è‡´å†…å­˜è¶…é™ï¼Œé€ æˆç¨‹åºçš„éžæ­£å¸¸ä¸­æ–­ã€‚ åœ¨åˆ†æžä¸€èˆ¬ç®—æ³•çš„æ•ˆçŽ‡æ—¶ï¼Œæˆ‘ä»¬ç»å¸¸å…³æ³¨ä¸‹é¢ä¸¤ç§å¤æ‚åº¦ï¼š æœ€åæƒ…å†µå¤æ‚åº¦ï¼ˆworstï¼‰ å¹³å‡å¤æ‚åº¦ï¼ˆaverageï¼‰ Complexity Expressionå¤æ‚åº¦çš„æ¸è¿›è¡¨ç¤ºæ³•ï¼š$ T(n) = O(f(n)) $è¡¨ç¤ºå­˜åœ¨å¸¸æ•°$C&gt;0$ï¼Œ$n_0$ä½¿å¾—å½“$n â‰¥ n_0$æ—¶ï¼Œæœ‰$T(n) â‰¤ C * f(n)$ï¼› $ T(n) = Î©(g(n)) $è¡¨ç¤ºå­˜åœ¨å¸¸æ•°$C&gt;0$ï¼Œ$n_0$ä½¿å¾—å½“$n â‰¥ n_0$æ—¶ï¼Œæœ‰$T(n) â‰¥ C * g(n)$ï¼› $ T(n) = Î¸(h(n)) $è¡¨ç¤ºåŒæ—¶æœ‰$ T(n)=O(h(n)) $å’Œ$ T(n)=Î©(h(n)) $ï¼› è¿‡å¤§çš„ä¸Šç•Œå’Œä¸‹ç•Œå¯¹äºŽåˆ†æžç®—æ³•çš„â€œå¥½â€å’Œâ€œåâ€ï¼Œæ²¡æœ‰æ„ä¹‰ï¼Œæ‰€ä»¥ä¸€èˆ¬å–å€¼æ˜¯æˆ‘ä»¬èƒ½æ‰¾åˆ°çš„ã€æœ€å¤§å’Œæœ€å°çš„é‚£ä¸ªä¸Šç•Œå’Œä¸‹ç•Œã€‚ å½“é—®é¢˜çš„è§„æ¨¡ä¸º$n$æ—¶ï¼Œä¸åŒé‡çº§çš„æ—¶é—´å¤æ‚åº¦çš„å…³ç³»ä¸ºï¼š$log n &lt; n &lt; n*log n &lt; n^2 &lt; n^3 &lt; 2^n &lt; n!$ Complexity Analysiså¯¹ç®—æ³•è¿›è¡Œå¤æ‚åº¦çš„åˆ†æžæ˜¯è¡¡é‡ä¸€ä¸ªç®—æ³•â€œå¥½â€ä¸Žâ€œåâ€çš„åŸºæœ¬æ–¹æ³•ï¼Œå…³äºŽè¿™æ–¹é¢æœ‰ä»¥ä¸‹ä¸€äº›çªé—¨ï¼š è‹¥ä¸¤æ®µç®—æ³•åˆ†åˆ«æœ‰å¤æ‚åº¦$T_1(n) = O(f_1(n))$å’Œ$T_2(n) = O(f_2(n))$ï¼Œåˆ™ï¼š $T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))$ $T_1(n) \times T_2(n) = O(f_1(n) \times f_2(n))$ è‹¥$T(n)$æ˜¯å…³äºŽ$n$çš„$k$é˜¶å¤šé¡¹å¼ï¼Œé‚£ä¹ˆ$T(n) = Î¸(n^k)$ ä¸€ä¸ªforå¾ªçŽ¯çš„æ—¶é—´å¤æ‚åº¦ç­‰äºŽå¾ªçŽ¯æ¬¡æ•°ä¹˜ä»¥å¾ªçŽ¯ä½“ä»£ç çš„å¤æ‚åº¦ if-elseç»“æž„çš„å¤æ‚åº¦å–å†³äºŽifçš„æ¡ä»¶åˆ¤æ–­å¤æ‚åº¦å’Œä¸¤ä¸ªåˆ†æ”¯éƒ¨åˆ†çš„å¤æ‚åº¦ï¼Œæ€»ä½“å¤æ‚åº¦å–ä¸‰è€…ä¸­æœ€å¤§ å¹³æ—¶åœ¨åšåˆ°ä¸€äº›é¢˜ç›®çš„æ—¶å€™ä¼šé‡åˆ°è¦åˆ†æžæ—¶é—´å¤æ‚åº¦çš„ä¹ é¢˜ï¼Œå¯ä»¥ä»Žä¸Šè¿°çš„è§’åº¦å…¥æ‰‹ã€‚ä¸è¿‡ä¸€èˆ¬è€Œè¨€ï¼Œç¬¬å››æ¡ç”¨çš„è¦å¤šä¸€äº›ã€‚ Demo Codeexample 2 é¢˜ç›®ï¼šå†™ç¨‹åºå®žçŽ°ä¸€ä¸ªå‡½æ•° PrintN ï¼Œä½¿å¾—ä¼ å…¥ä¸€ä¸ªæ­£æ•´æ•°ä¸º N çš„å‚æ•°åŽï¼Œèƒ½é¡ºåºæ‰“å°ä»Ž 1 åˆ° N çš„å…¨éƒ¨æ­£æ•´æ•°ã€‚ å­¦è¿‡ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€çš„åŒå­¦ï¼Œåº”è¯¥ä¸ä¼šè§‰å¾—æœ‰å›°éš¾ï¼Œå› ä¸ºç›´æŽ¥åˆ©ç”¨å¾ªçŽ¯ä»Ž 1 æ•°åˆ° N å³å¯å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ä½†æ˜¯ï¼Œå¯èƒ½ä¼šæœ‰éƒ¨åˆ†åŒå­¦ä¼šå¯¹é€’å½’ä¸ç†Ÿæ‚‰ï¼Œå¥½åœ¨è€å¸ˆä¹Ÿç»™å‡ºäº†ä»£ç ã€‚123456789101112131415161718192021222324#include &lt;stdio.h&gt;void PrintN(int n) &#123; // method 1: use loop for(int i = 1; i &lt;= n; i++) &#123; printf("%d\n", i); &#125;&#125;/*void PrintN(int n) &#123; // method 2: use recursion if(n) &#123; PrintN(n - 1); printf("%d\n", n); &#125;&#125;*/int main() &#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125; example 3 é¢˜ç›®ï¼šå†™ç¨‹åºè®¡ç®—ç»™å®šå¤šé¡¹å¼åœ¨ç»™å®šç‚¹ x å¤„çš„å€¼ã€‚ å¤„ç†è¿™ä¸ªé¢˜æœ‰ä¸¤ç§æ–¹æ³•ï¼Œæ‰€ä»¥å¯ä»¥é¡ºä¾¿æ¯”è¾ƒä¸€ä¸‹ä¸¤ç§æ–¹æ³•è¿è¡Œçš„æ—¶é—´é•¿çŸ­ã€‚ç”±äºŽè®¡ç®—æœºçš„è¿è¡Œé€Ÿåº¦è¾ƒå¿«ï¼Œä»…è¿è¡Œä¸€æ¬¡æ— æ³•çœ‹å‡ºå·®å¼‚ï¼Œæ‰€ä»¥éœ€è¦å¤šæ‰§è¡Œå‡ æ¬¡ã€‚è®¡ç®—æ—¶é—´éœ€è¦å€ŸåŠ© C è¯­è¨€çš„åº“å‡½æ•°ï¼Œè€Œè¿™äº›åº“å‡½æ•°çš„å£°æ˜Žåœ¨time.hè¿™ä¸ªå¤´æ–‡ä»¶ä¸­ã€‚ç”±äºŽå§¥å§¥åˆç»™å‡ºäº†ä»£ç ï¼Œåˆå¯ä»¥å·æ‡’äº†~ä¸‹é¢ç»™å‡ºä»£ç ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7double f1(int n, double a[], double x) &#123; int i; double p = a[0]; for(i = 1; i &lt;= n; i++) &#123; p += (a[i] * pow(x, i)); &#125; return p;&#125;double f2(int n, double a[], double x) &#123; int i; double p = a[n]; for(i = n; i &gt; 0; i--) &#123; p = a[i - 1] + x * p; &#125; return p;&#125; int main() &#123; int i; double a[MAXN]; for(i = 0; i &lt; MAXN; i++) a[i] = (double)i; start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f1(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks1 = %f\n", (double)(stop - start)); printf("duration1 = %6.2e\n", duration); start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f2(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks2 = %f\n", (double)(stop - start)); printf("duration2 = %6.2e\n", duration); return 0;&#125;/*result:ticks1 = 1969.000000duration1 = 1.97e+000ticks2 = 284.000000duration2 = 2.84e-001*/ ä»Žä¸Šé¢ä»£ç çš„ç»“æžœå¯ä»¥çœ‹å‡ºï¼Œé‡‡ç”¨ä¸åŒè®¡ç®—æ–¹æ³•çš„ä»£ç è¿è¡Œæ—¶é—´ç«Ÿç„¶ç›¸å·®äº†å‡ ä¹Ž 7 å€ï¼ Maximum Subsequence Sum é¢˜ç›®ï¼šæœ€å¤§å­åˆ—å’Œé—®é¢˜ æœ€å¤§å­åˆ—å’Œçš„é—®é¢˜æ˜¯å¾ˆç»å…¸çš„åŠ¨æ€è§„åˆ’ï¼ˆDP, dynamic programmingï¼‰é—®é¢˜ï¼Œè¿™æ˜¯åšä¸»åŽæ¥æŸ¥é˜…èµ„æ–™äº†è§£åˆ°çš„ã€‚æ—¢ç„¶å§¥å§¥å°†è¿™é“é¢˜å½“ä½œä¾‹é¢˜æ”¾åœ¨ç¬¬ä¸€è®²ï¼Œåº”è¯¥ä¹Ÿæœ‰å¥¹çš„é“ç†ï¼Œä½•å†µå¥¹è¿˜ä»‹ç»äº†è¿™ä¹ˆå¤šä¸ç”¨åŠ¨è§„æ€è·¯çš„è§£é¢˜æ–¹æ³•å‘¢ã€‚ä»Žé¢˜ç›®å‡ºå‘ï¼Œæˆ‘ä»¬å¯ä»¥å¤§è‡´å¾—åˆ°è¿™é“é¢˜çš„ç­”é¢˜ä»£ç æ¡†æž¶ï¼š123456789101112131415#include &lt;stdio.h&gt;int MaxSubseqsum(int a[], int k) &#123;&#125;int main(int argc, char const *argv[]) &#123; int i, K; scanf("%d", &amp;K); int arr[K]; for(i=0; i&lt;K; i++) &#123; scanf("%d", &amp;arr[i]); &#125; printf("%d\n", MaxSubseqsum(arr, K)); return 0;&#125; ä¸‹é¢æ¥çœ‹çœ‹å„ç§ä¸åŒçš„è§£æ³•ï¼š directly calculating easy versionç›´æŽ¥æš´åŠ›æ±‚è§£çš„æ€è·¯è¾ƒä¸ºç›´è§‚ï¼Œåˆ©ç”¨ä¸‰é‡å¾ªçŽ¯ï¼Œå°†æ¯ä¸€ä¸ªæ•°æž„æˆçš„åºåˆ—å…¨éƒ¨æžšä¸¾ä¸€éï¼Œå¦‚æžœç¬¦åˆæ¡ä»¶ä¸”æ»¡è¶³æœ€å¤§ï¼Œå°±æ›´æ–°ç»“æžœã€‚å¾ªçŽ¯ç»“æŸåŽï¼Œå¾—åˆ°æœ€åŽç»“æžœã€‚1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j, k; for(i=0; i&lt;N; i++) &#123; for(j=i; j&lt;N; j++) &#123; ThisSum = 0; for(k=i; k&lt;=j; k++) &#123; ThisSum += a[k]; &#125; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; directly calculating advanced versionç»§ç»­æŒ‰ç…§æš´åŠ›æ±‚è§£çš„æ€è·¯è¿›è¡Œè®¡ç®—ï¼Œå¯ä»¥å‘çŽ°ï¼šå¯¹äºŽç›¸åŒçš„ i ï¼Œä¸åŒçš„ j ï¼Œåªè¦åœ¨ j - 1 æ¬¡å¾ªçŽ¯çš„åŸºç¡€ä¸Šç´¯åŠ  1 é¡¹å³å¯ï¼Œè€Œä¸éœ€è¦å†ä»Ž 1 ä¸€ç›´åŠ åˆ° iã€‚è¿™æ ·çš„è¯ï¼Œå°±å¯ä»¥èŠ‚çœä¸€å±‚forå¾ªçŽ¯çš„è¿è¡Œæ—¶é—´äº†ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j; for(i=0; i&lt;N; i++) &#123; ThisSum = 0; for(j=i; j&lt;N; j++) &#123; ThisSum += a[j]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; divide and conquerè¿™é“é¢˜è¿˜å¯ä»¥é‡‡ç”¨åˆ†æ²»æ³•æ¥è§£å†³ï¼Œä¸è¿‡ä¸æ˜¯é‚£ä¹ˆå®¹æ˜“ç†è§£ï¼Œä½†æ ¹æœ¬åœ¨äºŽè¦æŠŠæ¡æ­¤æ³•ä¸­è¾¹ç•Œçš„æ¦‚å¿µï¼Œå¹¶ä¸”è¦æ³¨æ„æœ€ç»ˆç»“æžœæ˜¯ 3 ç§æƒ…å†µä¸‹çš„æœ€å¤§å€¼ã€‚123456789101112131415161718192021222324252627282930313233343536373839404142int MaxSubseqsum(int a[], int N) &#123; /*use same interface*/ return DivideAndConquer(a, 0, N-1);&#125;int DivideAndConquer(int a[], int left, int right) &#123; int MaxLeftSum, MaxRightSum; /*save the result of left and right subsequence */ int MaxLeftBorderSum, MaxRightBorderSum; /*save the result of each subsequence*/ int LeftBorderSum, RightBorderSum; int center, i; if(left == right) &#123; if(a[left] &gt; 0) return a[left]; else return 0; &#125; /*divide*/ center = (left + right) / 2; /*use recursion to get the result*/ MaxLeftSum = DivideAndConquer(a, left, center); MaxRightSum = DivideAndConquer(a, center+1, right); /*get the result of left subsequence*/ MaxLeftBorderSum = 0, LeftBorderSum = 0; for(i=center; i&gt;=left; i--) &#123; LeftBorderSum += a[i]; if(LeftBorderSum &gt; MaxLeftBorderSum) MaxLeftBorderSum = LeftBorderSum; &#125; /*get the result of right subsequence*/ MaxRightBorderSum = 0, RightBorderSum = 0; for(i=center+1; i&lt;=right; i++) &#123; RightBorderSum += a[i]; if(RightBorderSum &gt; MaxRightBorderSum) MaxRightBorderSum = RightBorderSum; &#125; return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);&#125;int Max3(int a, int b, int c)&#123; return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;&#125; online processingæ¯”èµ·ä¸Šé¢çš„å‡ ç§æ–¹æ³•ï¼Œåœ¨çº¿å¤„ç†å°±ç®€å•ç²—æš´äº†è®¸å¤šï¼Œä¸€è¶Ÿå¾ªçŽ¯ä¸‹æ¥å°±å®Œäº‹äº†ï¼Œä½†ä¸æ˜¯é‚£ä¹ˆå¥½ç†è§£ï¼Œæœ€å¥½æ ¹æ®æµ‹è¯•æ ·ä¾‹æ‰‹åŠ¨æ¨¡æ‹Ÿä¸€éã€‚æ­¤æ³•ä¹‹æ‰€ä»¥å¿«çš„åŽŸå› åœ¨äºŽï¼Œä¸€æ—¦å‡ºçŽ°äº†åºåˆ—å‡ºçŽ°äº†è´Ÿæ•°ï¼Œè´Ÿæ•°å¹¶ä¸èƒ½ä½¿ç»“æžœå˜å¤§ï¼Œåè€Œä½¿ç»“æžœå˜å°äº†ã€‚é‚£ä¹ˆè¿™ç§æƒ…å†µå°±ä¸æ˜¯ç¬¦åˆæ¡ä»¶çš„ç»“æžœäº†ï¼Œç›´æŽ¥èˆå¼ƒï¼Œè¿™æ ·å°±ä¸ç”¨åšå¤šä½™çš„è®¡ç®—äº†ï¼Œè¿™å’Œâ€œå‰ªæžâ€æœ‰ç‚¹ç›¸ä¼¼ã€‚è€Œæ‰€è°“â€œåœ¨çº¿â€ï¼Œæ„æ€æ˜¯æŒ‡æ¯è¾“å…¥ä¸€ä¸ªæ•°æ®å°±è¿›è¡Œå³æ—¶å¤„ç†ï¼Œåœ¨ä»»ä½•ä¸€ä¸ªåœ°æ–¹ä¸­æ­¢è¾“å…¥ï¼Œç®—æ³•éƒ½èƒ½æ­£ç¡®ç»™å‡ºå½“å‰çš„è§£ã€‚1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for(i=0; i&lt;N; i++) &#123; ThisSum += a[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; &#125; &#125; return MaxSum;&#125; Homeworkæ­¤è¯¾ç¨‹çš„ä½œä¸šé¢˜ç›®å…¨éƒ¨éƒ½æ”¾åœ¨ PTA çš„ä¹ é¢˜é›†å†…ï¼ŒæŒ‰ç…§å§¥å§¥ç»™çš„é‚€è¯·ç å°±å¯ä»¥è¿›å…¥é¢˜ç›®é›†åšé¢˜å•¦ã€‚ 01-1 æœ€å¤§å­åˆ—å’Œé—®é¢˜è¿™é“é¢˜è¢«å§¥å§¥å½“æˆäº†åº”ç”¨å®žä¾‹è¿›è¡Œè®²è§£ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨å§¥å§¥ç»™çš„ä»£ç ï¼Œç¨åŠ ä¿®æ”¹ä¸€ä¸‹å°±å¯ä»¥ç›´æŽ¥ AC äº†ã€‚ä¸è¿‡ï¼Œæ ¹æ®è¿™é“é¢˜ç»™å®šçš„ä¸€äº›æ¡ä»¶ï¼Œéœ€è¦å¯¹ä¸€äº›æ•°æ®åšä¸€äº›å¤„ç†ã€‚è¿™é‡Œï¼Œæˆ‘ä»¬å·ä¸‹æ‡’ï¼Œç›´æŽ¥ä½¿ç”¨åœ¨çº¿å¤„ç†æ€è·¯çš„ä»£ç è¿›è¡Œè§£é¢˜ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int f(int array[], int N) &#123; int ThisSum = 0, MaxSum = 0; int i; for(i = 0; i &lt; N; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; else if(ThisSum &lt; 0) ThisSum = 0; &#125; return MaxSum;&#125;int main() &#123; int k, i; scanf("%d", &amp;k); for(i = 0; i &lt; k ; i++) &#123; scanf("%d", &amp;array[i]); &#125; printf("%d", f(array, k)); return 0;&#125;/*samples:in:6-2 11 -4 13 -5 -2 out:20*/ 01-2 Maximum Subsequence Sumè¿™é“é¢˜æ˜¯ä¸Šé¢é¢˜ç›®çš„å‡çº§ç‰ˆï¼Œè¦æ±‚ç»™å‡ºæœ€ä½³ç»“æžœçš„å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹çš„ä¸‹æ ‡ã€‚éœ€è¦æ³¨æ„çš„æ˜¯è¿™é“é¢˜ç›®çš„è¾“å‡ºè¦æ±‚æ¯”è¾ƒå¤šï¼Œè¦å½“å¿ƒä¸€ç‚¹ã€‚æ­¤é¢˜è¿˜æ˜¯åˆ©ç”¨åœ¨çº¿å¤„ç†çš„æ€è·¯è¿›è¡Œæ±‚è§£ï¼Œä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int main() &#123; int k, i; scanf("%d", &amp;k); bool flag = false; for(i = 1; i &lt;= k; i++) &#123; scanf("%d", array + i); if(array[i] &gt;= 0) flag = true; &#125; if(!flag) &#123; printf("0 %d %d\n", array[1], array[k]); // all the numbers are negative &#125; else &#123; int left = 1, right = k, temp_left = 1; int ThisSum = 0, MaxSum = -1; // MaxSum need to be initialized as a negative number for(i = 1; i &lt;= k; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) &#123; // update max value, the left index and right index MaxSum = ThisSum; left = temp_left; right = i; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; printf("%d %d %d\n", MaxSum, array[left], array[right]); &#125; return 0;&#125; 01-3 äºŒåˆ†æŸ¥æ‰¾è¿™é“é¢˜ç›®ä»‹ç»çš„ç®—æ³•ç®—æ˜¯ååˆ†åŸºç¡€å…¥é—¨çš„ç®—æ³•äº†ï¼Œå¯¹äºŽå­¦è¿‡ä¸€é—¨ç¨‹åºè®¾è®¡è¯­è¨€çš„åŒå­¦æ¥è¯´ï¼Œè¦è§£å†³åº”è¯¥ä¸ä¼šæœ‰ä»€ä¹ˆå›°éš¾ã€‚ä¸è¿‡ï¼Œå¯èƒ½ä¼šæœ‰éƒ¨åˆ†åŒå­¦ä¼šå¯¹ PTA ä¸Šæ­¤ç±»é¢˜ç›®çš„åšé¢˜æ–¹æ³•æœ‰æ‰€ç–‘æƒ‘ã€‚å…¶å®žï¼Œè¿™ç§å‡½æ•°é¢˜å°±æ˜¯è®©ä½ å†™ä¸ªå‡½æ•°ï¼Œç„¶åŽç³»ç»Ÿä¼šè‡ªåŠ¨çš„å°†ä½ æäº¤çš„è¿™æ®µå‡½æ•°ä»£ç åµŒå…¥åˆ°é¢˜ç›®çš„ä»£ç ä¹‹ä¸­è¿è¡Œï¼Œç»§è€Œåˆ¤æ–­ç»“æžœæ˜¯å¦æ­£ç¡®ã€‚è¦æ³¨æ„è¿™ç±»é¢˜ç›®å¯¹å‡½æ•°æŽ¥å£å’Œä¸€äº›å…³é”®è¯çš„å®šä¹‰ï¼Œä¸è¦æžé”™äº†ã€‚ç¬”è€…åšè¿™ç±»é¢˜ç›®æ—¶ï¼Œéƒ½æ˜¯ç›´æŽ¥æŠŠæ‰€æœ‰ä»£ç å…¨éƒ¨æ‹·è´ä¸‹æ¥ï¼Œç„¶åŽæŠŠç¼ºå¤±çš„ä»£ç å…¨éƒ¨æŒ‰ç…§é¢˜æ„å†™å‡ºæ¥ï¼Œç„¶åŽå†å•ç‹¬çš„æäº¤é¢˜ç›®è¦æ±‚çš„é‚£ä¸ªå‡½æ•°ä»£ç ï¼Œä»£ç å¦‚ä¸‹ï¼š123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* ä¿å­˜çº¿æ€§è¡¨ä¸­æœ€åŽä¸€ä¸ªå…ƒç´ çš„ä½ç½® */&#125;;List ReadInput(); /* è£åˆ¤å®žçŽ°ï¼Œç»†èŠ‚ä¸è¡¨ã€‚å…ƒç´ ä»Žä¸‹æ ‡1å¼€å§‹å­˜å‚¨ */Position BinarySearch( List L, ElementType X );int main() &#123; List L; ElementType X; Position P; L = ReadInput(); scanf("%d", &amp;X); P = BinarySearch( L, X ); printf("%d\n", P); return 0;&#125;List ReadInput() &#123; List L = (List)malloc(sizeof(struct LNode)); int n, t, i; scanf("%d", &amp;n); for(i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;L-&gt;Data[i]); &#125; L-&gt;Last = i; return L;&#125;Position BinarySearch( List L, ElementType X ) &#123; int left = 1, right = L-&gt;Last, mid, flag = 0; while(left &lt;= right) &#123; mid = (left + right) / 2; if(L-&gt;Data[mid] == X) &#123; flag = 1; break; &#125; else if(L-&gt;Data[mid] &lt; X) left = mid + 1; else right = mid - 1; &#125; if(flag) return mid; else return NotFound;&#125;/*some samples:in:512 31 55 89 10131out:2in:326 78 23331out:0in:426 78 88 23388out:3in:426 78 88 23378out:2*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice]]></title>
    <url>%2F2019%2F06%2F30%2FPAT-Advanced-Level-Practice%2F</url>
    <content type="text"><![CDATA[Introä»Žå…¥é—¨åˆ°å…¥åœŸç³»åˆ—ä¹‹ PAT ç”²çº§ é¢˜åº“å¿«ä¹ðŸ¤£å¯åŠ¨ã€‚é•¿æœŸæ›´æ–°ing~ 1001 A+B FormatAnalysisé¢˜ç›®æ„æ€æ¯”è¾ƒç®€å•ï¼Œç»™ä¿©æ•°ï¼Œç›¸åŠ ç®—ç»“æžœï¼Œç„¶åŽè¾“å‡ºçš„æ—¶å€™æ¯ä¸‰ä½ä¸€ä¸ª,éš”å¼€ï¼Œå¹¶ä¸”è´Ÿæ•°å¾—åœ¨å¼€å¤´è¾“å‡º-ã€‚ æŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„æ•°å­—èŒƒå›´ï¼š$-10^6 \le a,\ b \le 10^6$ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨intåž‹å˜é‡è¿›è¡Œç›¸åŠ ï¼Œç„¶åŽåœ¨è¾“å‡ºä¹‹å‰åœ¨åšæ•°ä½æ‹†åˆ†å³å¯ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int MAXN = 10;int main(int argc, char const *argv[]) &#123; int a, b, sum; scanf("%d %d", &amp;a, &amp;b); sum = a + b; if(sum &lt; 0) &#123; putchar('-'); sum = -sum; &#125; int len = 0, num[MAXN]; if(sum == 0) &#123; num[len++] = sum; &#125; while(sum) &#123; num[len++] = sum % 10; sum /= 10; &#125; for(int i = len - 1; i &gt;= 0; i--) &#123; printf("%d", num[i]); if(i &gt; 0 &amp;&amp; i % 3 == 0) &#123; putchar(','); &#125; &#125; return 0;&#125; 1002 A+B for PolynomialsAnalysisæ­¤é¢˜æ˜¯ ZJU æ•°æ®ç»“æž„è¯¾ç¨‹é‡Œé¢çš„ä¾‹é¢˜äº†ï¼Œè€Œä¸”è¿˜åªæ˜¯ä¸€åŠçš„å†…å®¹ï¼Œç®—æ³•æ€æƒ³ä¸éš¾ï¼ˆæ¯•ç«Ÿåªæ˜¯åˆä¸­æ•°å­¦çš„æ°´å¹³ï¼Œæˆ‘ä¸¢ðŸ˜…ï¼‰ï¼Œå…ˆæŒ‰ç…§é“¾è¡¨æ¥åšå§ï¼ŒåŽé¢åœ¨çœ‹çœ‹èƒ½ä¸èƒ½å°è¯•å…¶ä»–æ–¹æ³•ã€‚ä¸€å¼€å§‹å·æ‡’æ²¡æœ‰å°†ç»“æžœæž„é€ æˆä¸€ä¸ªæ–°çš„é“¾è¡¨ï¼Œå‘çŽ°æµ‹è¯•ç‚¹5æ— æ³•é€šè¿‡ï¼Œæ”¹äº†ä¸€ä¼šï¼Œè¿˜æ˜¯ä¸é€‰æ‹©å·æ‡’äº†... Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*test point 5, like this:2 1 2.4 0 3.23 2 2.4 1 2.4 0 -3.2*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct Polynode* Polynomial;struct Polynode &#123; int expo; double coef; Polynomial link;&#125;;Polynomial ReadPoly();Polynomial Add(Polynomial P1, Polynomial P2);void Print(Polynomial PP);int GetNum(Polynomial P);void Attach(double c, int e, Polynomial *pRear);int main(int argc, char const *argv[]) &#123; Polynomial P1 = ReadPoly(); Polynomial P2 = ReadPoly(); Polynomial PP = Add(P1, P2); int number = GetNum(PP); if(number) &#123; printf("%d ", number); Print(PP); &#125; else &#123; printf("%d\n", number); &#125; return 0;&#125;Polynomial ReadPoly() &#123; int K; scanf("%d", &amp;K); Polynomial P, rear; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;link = NULL; rear = P; int e; double c; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;rear); &#125; return P;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial p1 = P1-&gt;link, p2 = P2-&gt;link, p, rear; p = (Polynomial)malloc(sizeof(struct Polynode)); p-&gt;link = NULL; rear = p; double sum; while(p1 &amp;&amp; p2) &#123; int temp = p1-&gt;expo - p2-&gt;expo; if(temp &gt; 0) &#123; Attach(p1-&gt;coef, p1-&gt;expo, &amp;rear); p1 = p1-&gt;link; &#125; else if(temp == 0) &#123; sum = p1-&gt;coef + p2-&gt;coef; if(sum) &#123; Attach(sum, p1-&gt;expo, &amp;rear); &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else &#123; Attach(p2-&gt;coef, p2-&gt;expo, &amp;rear); p2 = p2-&gt;link; &#125; &#125; if(p1) &#123; rear-&gt;link = p1; &#125; if(p2) &#123; rear-&gt;link = p2; &#125; return p;&#125;void Print(Polynomial PP) &#123; Polynomial P = PP-&gt;link; while(P) &#123; if(P-&gt;link == NULL) &#123; printf("%d %.1lf\n", P-&gt;expo, P-&gt;coef); &#125; else &#123; printf("%d %.1lf ", P-&gt;expo, P-&gt;coef); &#125; P = P-&gt;link; &#125;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P-&gt;link; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;coef = c; P-&gt;expo = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125; 1003 EmergencyAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šå‡ ä¸ªåŸŽå¸‚ä¹‹é—´çš„åœ°å›¾ï¼ŒåŸŽå¸‚ä¹‹é—´çš„è·¯æœ‰ç›¸åº”çš„æƒå€¼ï¼Œç„¶åŽç»™å®šèµ·å§‹åŸŽå¸‚å’Œç»ˆç‚¹åŸŽå¸‚ï¼Œé—®ä»Žèµ·å§‹åŸŽå¸‚åˆ°è¾¾ç»ˆç‚¹åŸŽå¸‚çš„è·¯å¾„æœ‰å‡ æ¡ï¼Œå¹¶ä¸”è¿™äº›è·¯å¾„ä¸Šç‚¹æƒä¹‹å’Œæœ€å¤§æ˜¯å¤šå°‘ã€‚ ç”±äºŽé¢˜ç›®çš„å®žé™…æ„ä¹‰ï¼Œæž„é€ å¥½çš„å›¾ä¸€å®šæ˜¯ä¸€ä¸ªæ— å‘å›¾ï¼Œå€ŸåŠ© Dijkstra ç®—æ³•æˆ– Bellman-Ford ç®—æ³•å¯ä»¥è§£å†³è¿™ä¸¤ä¸ªé—®é¢˜ã€‚ è·¯å¾„æ¡æ•°å’Œç‚¹æƒå’Œçš„æœ€å¤§å€¼ï¼Œåˆ†åˆ«ä½¿ç”¨ä¸€ä¸ªæ•°ç»„æ¥ç»Ÿè®¡å³å¯ã€‚ CodeDijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 510;const int INF = 1000000000;int n, m, st, ed, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;;bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, INF); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = INF; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != INF) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; //update the distance of each node w[v] = w[u] + weight[v]; // update the 'hands' num[v] = num[u]; // update the path for a new reachable node &#125; else if(d[u] + G[u][v] == d[v]) &#123; /*only one path can count the 'hands', so the w[v] will be covered by the sum of last node and its own 'hands' */ if(w[u] + weight[v] &gt; w[v]) &#123; w[v] = w[u] + weight[v]; &#125; //but the number of path is not only num[v] += num[u]; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v; fill(G[0], G[0] + maxv * maxv, INF); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v]; G[v][u] = G[u][v]; &#125; dijkstra(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; Bellman-Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct node &#123; int v, dis; node(int _v, int _dis) : v(_v), dis(_dis) &#123;&#125; // constructor&#125;;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, weight[maxv];int num[maxv] = &#123;0&#125;, w[maxv] = &#123;0&#125;, d[maxv];vector&lt;node&gt; Adj[maxv];set&lt;int&gt; pre[maxv];bool bellmanford(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; num[s] = 1; w[s] = weight[s]; for(int i = 0; i &lt; n - 1; i++) &#123; for(int u = 0; u &lt; n; u++) &#123; for(int j = 0; j &lt; Adj[u].size(); j++) &#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) &#123; // more optimal solution d[v] = d[u] + dis; w[v] = w[u] + weight[v]; num[v] = num[u]; pre[v].clear(); // attention: pre[v] must be clear firstly pre[v].insert(u); // save the precursor &#125; else if(d[u] + dis == d[v]) &#123; if(w[v] &lt; w[u] + weight[v]) &#123; // update the maximum w[v] = w[u] + weight[v]; &#125; pre[v].insert(u); // other shortest path also need save num[v] = 0; // the number of shortest path has been changed set&lt;int&gt;::iterator it; for(it = pre[v].begin(); it != pre[v].end(); it++) &#123; num[v] += num[*it]; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; Adj[u].push_back(node(v, dis)); Adj[v].push_back(node(u, dis)); &#125; bellmanford(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; 1004 Counting LeavesAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, child, seq, maxDepth = -1;int leaves[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(Node[front].depth &gt; maxDepth) &#123; maxDepth = Node[front].depth; &#125; if(Node[front].child.size() != 0) &#123; for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; q.push(child); &#125; &#125; else &#123; leaves[Node[front].depth]++; &#125; &#125; &#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); for(int i = 1; i &lt;= maxDepth; i++) &#123; cout &lt;&lt; leaves[i]; if(i &lt; maxDepth) cout &lt;&lt; ' '; &#125; return 0;&#125; 1005 Spell It RightAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œç»™ä¸€ä¸ªæ•°å­—ï¼Œè®¡ç®—å‡ºè¿™ä¸ªæ•°å­—æ¯ä¸€ä½ä¸Šçš„æ•°å­—ä¹‹å’Œï¼Œç„¶åŽç”¨è‹±æ–‡çš„æ–¹å¼åˆ†åˆ«è¾“å‡ºè¿™ä¸ªå’Œçš„æ¯ä¸€ä½æ•°å­—ï¼ˆå¥½å§ï¼Œæœ‰ç‚¹ç»•ðŸ˜…ï¼‰ã€‚ ä¸Žä¹™çº§é¢˜åº“çš„1002å¾ˆç±»ä¼¼ï¼Œè€ƒå¯Ÿæ•°ä½æ‹†åˆ†å§ï¼Œæ¯”è¾ƒç®€å•ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int MAXN = 100 + 5;char NumberTable[11][10] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",&#125;;int main(int argc, char const *argv[]) &#123; char num[MAXN]; int sum = 0; scanf("%s", num); char *p = num; while(*p != '\0') &#123; sum += *p++ - '0'; &#125; int temp = sum, mask = 1; while(temp &gt; 9) &#123; temp /= 10; mask *= 10; &#125; while(mask) &#123; printf("%s", NumberTable[sum / mask]); if(mask &gt; 9) &#123; putchar(' '); &#125; sum %= mask; mask /= 10; &#125; putchar('\n'); return 0;&#125; 1006 Sign in and Sign OutAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œæœ€å…ˆåŽ»æœºæˆ¿çš„äººå¼€é—¨ï¼Œæœ€æ™šå‡ºæœºæˆ¿çš„äººå…³é—¨ï¼Œç”¨å­¦å·ä»£æ›¿äººåï¼Œè¾“å‡ºæœ€æ—©æ¥å’Œæœ€æ™šèµ°çš„äººçš„å­¦å·å³å¯ã€‚åˆ†æžè¾“å…¥æ•°æ®ï¼Œ1ä¸ªå­—ç¬¦ä¸²ï¼Œ6ä¸ªæ•´åž‹æ•°å­—ï¼Œæ¯3ä¸ªæ•°å­—ä¸ºä¸€ä¸ªæ—¶é—´ç‚¹ï¼Œåˆ†åˆ«ä»£è¡¨åˆ°æ¥å’Œç¦»å¼€çš„æ—¶é—´ç‚¹ï¼Œæ—¢ç„¶è¦æ‰¾çš„åªæ˜¯æœ€æ—©å’Œæœ€æ™šçš„ä¸¤ä¸ªæ—¶é—´ç‚¹ï¼Œé‚£ä¹ˆæ¯æ¬¡å¯»æ‰¾æ—¶ï¼Œåªè¦åŽ»æ¯”è¾ƒä¸€ä¸ªæ—¶é—´ç‚¹å³å¯ã€‚æœ€æ—©æ¥çš„æ—¶é—´åˆå§‹åŒ–ä¸ºä¸€å¤©ä¸­æœ€åŽæ™šçš„æ—¶é—´ï¼ˆ23:59:59ï¼‰ï¼Œæœ€æ™šèµ°çš„æ—¶é—´åˆå§‹åŒ–ä¸ºä¸€å¤©ä¸­æœ€æ—©çš„æ—¶é—´ï¼ˆ00:00:00ï¼‰ï¼Œæ³¨æ„è¦åˆ†å¼€æ¯”è¾ƒï¼Œä¸èƒ½ç”¨if-elseå“¦ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;struct person&#123; char ID_number[20]; int start_hh, start_mm, start_ss, end_hh, end_mm, end_ss;&#125; first, last, temp;void Init();bool Earliest(person a, person b);bool Latest(person a, person b);int main(int argc, char const *argv[]) &#123; Init(); int M; scanf("%d", &amp;M); while(M--) &#123; scanf("%s %d:%d:%d %d:%d:%d", temp.ID_number, &amp;temp.start_hh, \ &amp;temp.start_mm, &amp;temp.start_ss, &amp;temp.end_hh, &amp;temp.end_mm, &amp;temp.end_ss); if(Earliest(temp, first)) &#123; first = temp; &#125; if(Latest(temp, last)) &#123; last = temp; &#125; &#125; printf("%s %s\n", first.ID_number, last.ID_number); return 0;&#125;void Init() &#123; first.start_hh = 23; first.start_mm = first.start_ss = 59; last.end_hh = last.end_mm = last.end_ss = 0;&#125;bool Earliest(person a, person b) &#123; if(a.start_hh != b.start_hh) return a.start_hh &lt;= b.start_hh; else if(a.start_mm != b.start_mm) return a.start_mm &lt;= b.start_mm; else return a.start_ss &lt;= a.start_ss;&#125;bool Latest(person a, person b) &#123; if(a.end_hh != b.end_hh) return a.end_hh &gt;= b.end_hh; else if(a.end_mm != b.end_mm) return a.end_mm &gt;= b.end_mm; else return a.end_ss &gt;= b.end_ss;&#125; 1007 Maximum Subsequence SumAnalysisCodeDP123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int maxn = 10010;int a[maxn], dp[maxn];int s[maxn] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; bool flag = false; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if(a[i] &gt;= 0) flag = true; &#125; if(flag == false) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; a[n - 1]; &#125; else &#123; dp[0] = a[0]; for(int i = 1; i &lt; n; i++) &#123; if(dp[i - 1] + a[i] &gt; a[i]) &#123; dp[i] = dp[i - 1] + a[i]; s[i] = s[i - 1]; &#125; else &#123; dp[i] = a[i]; s[i] = i; &#125; &#125; int k = 0; for(int i = 1; i &lt; n; i++) &#123; if(dp[i] &gt; dp[k]) &#123; k = i; &#125; &#125; cout &lt;&lt; dp[k] &lt;&lt; ' ' &lt;&lt; a[s[k]] &lt;&lt; ' ' &lt;&lt; a[k]; &#125; return 0;&#125; Online-Processing1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxk = 10010;int main(int argc, char *argv[]) &#123; int k, arr[maxk] = &#123;0&#125;; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ThisSum = 0, MaxSum = -1; int left = 0, right = k - 1, temp_left = 0; for(int i = 0; i &lt; k; i++) &#123; ThisSum += arr[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; right = i; left = temp_left; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; if(MaxSum &lt; 0) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; else cout &lt;&lt; MaxSum &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; return 0;&#125; 1008 ElevatorAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç”µæ¢¯ç§»åŠ¨å’Œç­‰å¾…çš„æ—¶é•¿ï¼Œå†æŒ‰ç…§é¢˜ç›®ç»™å®šçš„åœç•™é¡ºåºï¼Œè®¡ç®—å‡ºç”µæ¢¯åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­éœ€è¦çš„æ€»æ—¶é—´ã€‚ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼š åˆå§‹ä¸º0å±‚ï¼Œåˆ°2å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$2 \times 6 = 12\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$17s$ ä»Ž2å±‚åˆ°3å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$1 \times 6 = 6\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$11s$ ä»Ž3å±‚åˆ°1å±‚ï¼Œæ—¶é•¿ä¸ºï¼š$2 \times 4 = 8\ s$ï¼Œå†åŠ ä¸Šç­‰å¾…çš„$5s$ï¼Œæ€»è®¡$13s$ åˆè®¡ä¸ºï¼š$17 + 11 + 13 = 41\ s$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int n, array[105] = &#123;0&#125;; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; int total = 0, last = 0; for(int i = 0; i &lt; n; i++) &#123; if(array[i] == last) &#123; total += 5; &#125; else if(array[i] &gt; last) &#123; total += ((array[i] - last) * 6 + 5); &#125; else &#123; total += ((last - array[i]) * 4 + 5); &#125; last = array[i]; &#125; printf("%d\n", total); return 0;&#125; 1009 Product of PolynomialsAnalysisæ­¤é¢˜ä¹Ÿæ˜¯ ZJU æ•°æ®ç»“æž„è¯¾ç¨‹é‡Œé¢çš„ä¾‹é¢˜ï¼Œç®—æ˜¯å¦ä¸€åŠäº†ï¼Œä¸Ž1002æ˜¯ç±»ä¼¼çš„ï¼Œåªä¸è¿‡1002æ˜¯åŠ æ³•ï¼Œè¿™ä¸ªæ˜¯ä¹˜æ³•ï¼Œè¿˜æ˜¯å…ˆç”¨é“¾è¡¨åšå§ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct PolyNode *Polynomial;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial *pRear);Polynomial ReadPoly();Polynomial Mult(Polynomial P1, Polynomial P2);void PrintPoly(Polynomial P);int Compare(int a, int b);int GetNum(Polynomial P);int main(int argc, char const *argv[])&#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PP = Mult(P1, P2); int numbers = GetNum(PP); if(numbers) &#123; printf("%d ", numbers); PrintPoly(PP); &#125; else &#123; printf("%d\n"); &#125; return 0;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125;Polynomial ReadPoly() &#123; Polynomial P, Rear, t; int e, K; double c; scanf("%d", &amp;K); P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t = P; P = P-&gt;link; free(t); return P;&#125;Polynomial Mult(Polynomial P1, Polynomial P2) &#123; Polynomial P, Rear, t1, t2, t; int e; double c; if(!P1 || !P2) return NULL; t1 = P1; t2 = P2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(t1) &#123; t2 = P2; Rear = P; while(t2) &#123; e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) &#123; Rear = Rear-&gt;link; &#125; if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if(Rear-&gt;link-&gt;coef + c) &#123; Rear-&gt;link-&gt;coef += c; &#125; else &#123; t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; &#125; t2 = P; P = P-&gt;link; free(t2); return P;&#125;void PrintPoly(Polynomial P) &#123; int flag = 0; while(P) &#123; if(!flag)&#123; flag = 1; &#125; else &#123; printf(" "); &#125; printf("%d %.1lf", P-&gt;expon, P-&gt;coef); P = P-&gt;link; &#125; printf("\n");&#125;int Compare(int a, int b) &#123; return a &gt; b ? 1 : a == b ? 0 : -1;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125; 1010 RadixAnalysisè¿™ä¸ªé¢˜çš„é¢˜æ„è¯´çš„æ¯”è¾ƒæ¨¡ç³Šï¼Œæ‰€ä»¥ä¸å¤ªå¥½å¯»æ‰¾æ€è·¯ã€‚å…ˆåˆ†æžä¸€ä¸‹é¢˜ç›®æ„æ€ï¼Œç»™å®šN1ï¼ŒN2ï¼Œtagå’Œradixå››ä¸ªæ•°å­—ï¼›è‹¥å½“tagä¸º1æ—¶ï¼Œradixçš„å€¼å°±æ˜¯N1çš„è¿›åˆ¶æ•°ï¼Œtagä¸º2æ—¶ï¼Œradixçš„å€¼å°±æ˜¯N2çš„è¿›åˆ¶æ•°ï¼ˆä¸€èˆ¬é’ˆå¯¹è¿™ç§æƒ…å†µï¼Œæœ€å¥½äº¤æ¢ä¸‹N1å’ŒN2çš„å€¼ï¼Œå†ç»Ÿä¸€å¤„ç†ï¼‰ã€‚ ç´§æŽ¥ç€ï¼Œé¢˜ç›®è¦æ±‚åˆ¤æ–­N1å’ŒN2æ˜¯å¦ç›¸ç­‰ï¼Œç”±äºŽé¢˜ç›®ç»™å®šçš„ä¸¤ä¸ªæ•°å­—çš„è¿›åˆ¶ä¸ç›¸åŒï¼Œæ‰€ä»¥è¿˜å¿…é¡»è¦è½¬æ¢åŽè¿›è¡Œåˆ¤æ–­ã€‚ä¸Žå…¶è¿™æ ·ï¼Œä¸å¦‚ç›´æŽ¥å°†èƒ½ç¡®å®šè¿›åˆ¶çš„é‚£ä¸ªæ•°è½¬åŒ–ä¸ºåè¿›åˆ¶æ•°ï¼Œç„¶åŽä¸Žå¦ä¸€ä¸ªæ•°çš„æ¯ä¸€ä¸ªä¸åŒçš„è¿›åˆ¶å•ä½ä¸‹è½¬æ¢ä¸ºåè¿›åˆ¶æ•°åŽå€¼è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥ç›¸ç­‰ï¼Œåˆ™è¿™ä¸¤ä¸ªæ•°ç›¸ç­‰ï¼ˆåªè¦åœ¨ä¸€ç§è¿›åˆ¶å•ä½ä¸‹ï¼Œä¸¤ä¸ªæ•°ç›¸ç­‰ï¼Œé‚£ä¹ˆåœ¨å…¶ä»–ä»»æ„è¿›åˆ¶å•ä½ä¸‹ï¼Œè¿™ä¸¤ä¸ªæ•°ä¸ç®¡å¦‚ä½•å˜åŒ–éƒ½æ˜¯ç›¸ç­‰çš„ï¼‰ã€‚ æ˜Žç™½é¢˜æ„åŽï¼Œå°±å¾—å¼€å§‹æ‰“ç äº†ã€‚ç”±äºŽé¢˜ç›®ç»™å®šçš„radixæ²¡æœ‰é™åˆ¶èŒƒå›´ï¼Œæ‰€ä»¥è½¬æ¢åŽçš„åè¿›åˆ¶æ•°æ˜¯æœ‰å¯èƒ½æº¢å‡ºçš„ï¼ˆlong longä¹Ÿä¼šï¼‰ï¼Œæ‰€ä»¥ä½¿ç”¨å­—ç¬¦ä¸²æ¥å­˜å‚¨æ•°å­—ã€‚ ç´§æŽ¥ç€ï¼ŒæŒ‰ç…§å‰é¢çš„æ€è·¯ï¼Œå…ˆæž„é€ å­—ç¬¦0 - 9å’Œa - zçš„åè¿›åˆ¶æ•°å¯¹åº”è¡¨ï¼Œæ–¹ä¾¿è°ƒç”¨ã€‚å¦å¤–ï¼Œä¸ç®¡tagçš„å€¼å¦‚ä½•ï¼Œå¯¹N1å’ŒN2è¿›è¡Œå¤„ç†ï¼Œé»˜è®¤N1æ˜¯è¿›åˆ¶ç¡®å®šçš„æ•°ã€‚åœ¨å¼€å§‹å¯¹N2è¿›è¡Œè¿›åˆ¶è½¬æ¢ä¹‹å‰ï¼Œè¦å…ˆç¡®å®šå…¶å¯èƒ½çš„è¿›åˆ¶èŒƒå›´ï¼Œè¿™ä¸ªç»“æžœå°±æ˜¯ï¼šä»¥å…¶å­—ç¬¦æœ€å¤§å€¼ä¸ºä¸‹ç•Œï¼ŒN1çš„åè¿›åˆ¶æ•°å€¼ä¸ºä¸Šç•Œã€‚åœ¨è¿™ä¸ªè¿›åˆ¶èŒƒå›´å†…ï¼Œä¸€ä¸ªä¸€ä¸ªåŽ»æžšä¸¾æ˜¾ç„¶æ˜¯å¾ˆæ…¢çš„ï¼Œæ‰€ä»¥ä½¿ç”¨äºŒåˆ†æ³•æ˜¯ä¸€ä¸ªå¾ˆä¸é”™çš„é€‰æ‹©ã€‚ æ³¨æ„ï¼š ä½¿ç”¨äºŒåˆ†æ³•æ—¶ï¼Œåªéœ€è¦æ‰¾åˆ°æ»¡è¶³æ¡ä»¶ï¼šä¸ŽN1çš„åè¿›åˆ¶æ•°ç›¸ç­‰çš„æ•°å³å¯ï¼Œæ­¤æ—¶å¾—è¿”å›žè¿›åˆ¶æ•°ã€‚ é’ˆå¯¹æ•°æ®çš„æº¢å‡ºæƒ…å†µï¼Œä¸€æ—¦ç»“æžœä¸ºè´Ÿï¼Œå°±å¯ä»¥åˆ¤æ–­ä¸ºæº¢å‡ºï¼Œæ­¤æ—¶N2åœ¨è¿™ä¸ªè¿›åˆ¶ä¸‹çš„è½¬æ¢å‡ºæ¥çš„åè¿›åˆ¶æ•°è‚¯å®šæ˜¯å¤§äºŽN1çš„åè¿›åˆ¶æ•°çš„ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL Map[256];LL inf = (1LL &lt;&lt; 63) - 1;void Init() &#123; for(char c = '0'; c &lt;= '9'; c++) &#123; Map[c] = c - '0'; &#125; for(char c = 'a'; c &lt;= 'z'; c++) &#123; Map[c] = c - 'a' + 10; &#125;&#125;LL ConvertNum10(char *a, LL radix, LL t) &#123; LL ret = 0; for(int i = 0; a[i] != '\0'; i++) &#123; ret = ret * radix + Map[a[i]]; if(ret &lt; 0 || ret &gt; t) &#123; ret = -1; break; &#125; &#125; return ret;&#125;int cmp(char *N2, LL radix, LL t) &#123; int len = strlen(N2); LL num = ConvertNum10(N2, radix, t); if(num &lt; 0) return 1; if(t &gt; num) return -1; else if(t == num) return 0; else return 1;&#125;LL BinarySearch(char *N2, LL left, LL right, LL t) &#123; LL mid; while(left &lt;= right) &#123; mid = (left + right) / 2; int flag = cmp(N2, mid, t); if(flag == 0) return mid; else if(flag == -1) left = mid + 1; else right = mid - 1; &#125; return - 1;&#125; int FindLargestDigit(char *N2) &#123; int ans = -1, len = strlen(N2); for(int i = 0; i &lt; len; i++) &#123; if(Map[N2[i]] &gt; ans) &#123; ans = Map[N2[i]]; &#125; &#125; return ans + 1;&#125;char N1[20], N2[20], temp[20];int tag, radix;int main(int argc, char const *argv[]) &#123; Init(); scanf("%s %s %d %d", N1, N2, &amp;tag, &amp;radix); if(tag == 2) &#123; strcpy(temp, N1); strcpy(N1, N2); strcpy(N2, temp); &#125; LL t = ConvertNum10(N1, radix, inf); LL low = FindLargestDigit(N2); LL high = max(low, t) + 1; LL ans = BinarySearch(N2, low, high, t); if(ans == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%lld\n", ans); &#125; return 0;&#125; 1011 World Cup BettingAnalysisé¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œä¸‰å±€æ¯”èµ›ï¼Œç»™å‡ºæ¯å±€çš„èµ”çŽ‡ï¼Œé»˜è®¤æ¯æ¬¡éƒ½èµŒå¯¹ï¼Œé—®æ€Žæ ·ä¹°æ”¶ç›Šæœ€å¤šã€‚å¾ˆç®€å•ï¼Œæ¯æ¬¡ä¹°èµ”çŽ‡æœ€å¤§çš„å°±å¥½å•¦~ç„¶åŽè¿˜æœ‰ä¸€ä¸ªéº»çƒ¦çš„åœ°æ–¹ï¼Œå°±æ˜¯è¦è¾“å‡ºæ¯å±€èµ”çŽ‡æœ€å¤§çš„æ˜¯å“ªä¸€ç§å±€ï¼Œå³ï¼šèŽ·èƒœï¼ˆWinï¼‰ã€å¹³å±€ï¼ˆTieï¼‰å’Œå¤±è´¥ï¼ˆLoseï¼‰ï¼Œå…ˆä¿å­˜æ¯æ¬¡çš„ä¸‹æ ‡ï¼Œç„¶åŽå†™ä¸ªå‡½æ•°è½¬æ¢ä¸€ä¸‹å°±å¥½äº†ã€‚è‡³äºŽæ”¶ç›Šçš„è®¡ç®—æ–¹æ³•ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å…¬å¼ç®—å°±å¥½äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;char change(int index);int main(int argc, char const *argv[]) &#123; double Bet[3][3], Profit = 0.0; for(int i = 0; i &lt; 3; i++) &#123; scanf("%lf %lf %lf", &amp;Bet[i][0], &amp;Bet[i][1], &amp;Bet[i][2]); &#125; int max_index[3]; double max[3] = &#123;0.0&#125;; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; if(max[i] &lt; Bet[i][j]) &#123; max[i] = Bet[i][j]; max_index[i] = j; &#125; &#125; &#125; Profit = (max[0] * max[1] * max[2] * 0.65 - 1.0) * 2.0; printf("%c %c %c %.2lf\n", change(max_index[0]), change(max_index[1]), change(max_index[2]), Profit); return 0;&#125;char change(int index) &#123; char ret; switch(index) &#123; case 0: ret = 'W'; break; case 1: ret = 'T'; break; case 2: ret = 'L'; break; &#125; return ret;&#125; 1012 The Best RankAnalysisç»™å‡ºæ¯ä¸ªå­¦ç”Ÿçš„å„ç§‘æˆç»©ï¼Œè®¡ç®—å…¶å¹³å‡åˆ†ï¼Œå¹¶æ ¹æ®ä»–ä»¬çš„æˆç»©è¿›è¡ŒæŽ’åºï¼›ç„¶åŽæŸ¥æ‰¾æŒ‡å®šå­¦å·çš„å­¦ç”Ÿçš„æˆç»©ï¼Œè¾“å‡ºå…¶æŽ’åæœ€ä¼˜çš„æˆç»©å’Œç§‘ç›®åç§°ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000 + 5;struct student &#123; int id, grade[4];&#125; stu[MAXN];char course[4] = &#123;'A', 'C', 'M', 'E'&#125;;int Rank[10000000][4] = &#123;0&#125;;int now;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d %d", &amp;stu[i].id, &amp;stu[i].grade[1], &amp;stu[i].grade[2], &amp;stu[i].grade[3]); stu[i].grade[0] = (stu[i].grade[1] + stu[i].grade[2] + stu[i].grade[3]) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, cmp); Rank[stu[0].id][now] = 1; for(int i = 1; i &lt; N; i++) &#123; if(stu[i].grade[now] == stu[i - 1].grade[now]) &#123; Rank[stu[i].id][now] = Rank[stu[i - 1].id][now]; &#125; else &#123; Rank[stu[i].id][now] = i + 1; &#125; &#125; &#125; int query; while(M--) &#123; scanf("%d", &amp;query); if(Rank[query][0] == 0) &#123; printf("N/A\n"); &#125; else &#123; int k = 0; for(int j = 0; j &lt; 4; j++) &#123; if(Rank[query][j] &lt; Rank[query][k]) &#123; k = j; &#125; &#125; printf("%d %c\n", Rank[query][k], course[k]); &#125; &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade[now] &gt; b.grade[now];&#125; 1013 Battle Over CitiesAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* method 1: use union-find set*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];int father[maxn];bool vis[maxn];int n, m, k;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = faB; &#125;&#125;void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; father[i] = i; vis[i] = false; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; int currentPoint; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; init(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; int u = i, v = G[i][j]; if(u == currentPoint || v == currentPoint) continue; Union(u, v); &#125; &#125; int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i == currentPoint) continue; int fa_i = findFather(i); if(vis[fa_i] == false) &#123; block++; vis[fa_i] = true; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;/*method 2: use DFS#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];bool vis[maxn] = &#123;false&#125;;int currentPoint;int n, m, k;void dfs(int v) &#123; if(v == currentPoint) return; vis[v] = true; for(int i = 0; i &lt; G[v].size(); i++) &#123; if(vis[G[v][i]] == false) &#123; dfs(G[v][i]); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; memset(vis, false, sizeof(vis)); int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i != currentPoint &amp;&amp; vis[i] == false) &#123; dfs(i); block++; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;*/ 1015 Reversible PrimesAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸¤ä¸ªæ•´æ•°Nã€Dï¼ŒNæ˜¯åè¿›åˆ¶ä¸‹çš„æ•´æ•°ï¼ŒDæ˜¯è¿›åˆ¶æ•°ï¼Œåˆ¤æ–­Nå’Œå°†Nè½¬æ¢ä¸ºDè¿›åˆ¶ä¸‹çš„æ•°æ˜¯å¦éƒ½æ˜¯ç´ æ•°ã€‚è‹¥æ˜¯ï¼Œè¾“å‡ºYesï¼Œåä¹‹è¾“å‡ºNoã€‚ è€ƒå¯Ÿè¿›åˆ¶è½¬æ¢å’Œç´ æ•°çš„åˆ¤æ–­ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;int Reverse(int number, int radix) &#123; int a[32], temp = number, count = 0, ret = 0; while(temp) &#123; a[count++] = temp % radix; temp /= radix; &#125; for(int i = 0; i &lt; count; i++) &#123; ret = ret * radix + a[i]; &#125; return ret;&#125;bool isPrime(int n) &#123; if(n &lt;= 1 || (n % 2 == 0 &amp;&amp; n != 2)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[]) &#123; int n, d; while(1) &#123; scanf("%d", &amp;n); if(n &lt; 0) break; scanf("%d", &amp;d); if(isPrime(n) &amp;&amp; isPrime(Reverse(n, d))) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125; 1016 Phone BillsAnalysiså…ˆåˆ†æžä¸€ä¸‹è¾“å…¥ï¼ŒåŒ…å«åç§°ã€æ—¶é—´å’ŒçŠ¶æ€ï¼Œå…¶ä¸­åç§°å’ŒçŠ¶æ€æ˜¯ä»¥å­—ç¬¦ä¸²çš„å½¢å¼è¾“å…¥çš„ï¼Œè€Œæ—¶é—´åˆ™æ˜¯åè¿›åˆ¶æ•°å­—ã€‚è¿™é‡Œè¦ç«‹åˆ»ååº”è¿‡æ¥ï¼Œä¸èƒ½ç”¨é¢˜ç›®å­—ç¬¦ä¸²æ¥è¡¨ç¤ºçŠ¶æ€ï¼Œåº”è¯¥æ¢æˆæ•°å­—æ¥è¡¨ç¤ºã€‚è‡³äºŽï¼Œæœ€å¼€å§‹è¾“å…¥çš„è´¹çŽ‡è¡¨ï¼Œä½¿ç”¨ä¸€ä¸ªæ•´åž‹æ•°ç»„æ¥å­˜å‚¨ï¼Œä½¿ç”¨çš„æ—¶å€™è¿›è¡Œè°ƒç”¨å°±å¥½ã€‚ æŽ¥ä¸‹æ¥ï¼Œéœ€è¦å¯¹è¾“å…¥çš„æ•°æ®è¿›è¡ŒæŽ’åºï¼Œä¼˜å…ˆçº§æœ€å¤§çš„æŽ’åºä¾æ®å°±æ˜¯åç§°ï¼ŒæŒ‰ç…§å­—å…¸åºæ¥æŽ’åˆ—ï¼Œæ³¨æ„å­—ç¬¦ä¸²éœ€è¦ç”¨strcmpå‡½æ•°æ¥è¿›è¡Œæ¯”è¾ƒï¼›å…¶æ¬¡ï¼Œç›¸åŒåç§°çš„å…ƒç´ æŒ‰ç…§æ—¶é—´çš„å…ˆåŽè¿›è¡ŒæŽ’åˆ—å°±å¥½äº†ã€‚ æŽ¥ç€å†æ¥çœ‹è¾“å‡ºï¼Œé¦–å…ˆè¦è¾“å‡ºçš„æ˜¯å®¢æˆ·çš„åç§°å’Œå…¶è¯è´¹è´¦å•æ‰€å¤„çš„æœˆä»½ï¼›ç¬¬äºŒè¡Œå¼€å§‹è¾“å‡ºå®¢æˆ·çš„è¯è´¹è´¦å•çš„å¼€å§‹æ—¶é—´å’Œç»“æŸæ—¶é—´ï¼Œç„¶åŽè¾“å‡ºå½“å‰è´¦å•çš„æ€»æ—¶é•¿å’Œè´¹ç”¨ï¼Œæ³¨æ„è´¹ç”¨ä¸ºæµ®ç‚¹åž‹ï¼›æ‰€æœ‰è´¦å•éƒ½è¾“å‡ºå®Œæ¯•åŽï¼Œæœ€åŽä¸€è¡Œè¾“å‡ºå®¢æˆ·æ€»è¯è´¹ã€‚ å¤§è‡´æ¸…æ¥šä¹‹åŽï¼Œå¦‚ä½•åŽ»è®¡ç®—è¯è´¹å‘¢ï¼Ÿæ ¹æ®é¢˜ç›®ï¼Œè¾“å…¥çš„æ¯ä¸€é¡¹å¿…é¡»æ˜¯é…å¯¹çš„on-lineå’Œoff-lineæ‰èƒ½ç»„æˆä¸€ä¸ªåˆæ³•çš„è´¦å•ï¼Œå¹¶ä¸”å¿…é¡»è¦æ˜¯è¿žç»­ã€ç›¸é‚»çš„æ‰èƒ½æ˜¯ä¸€å¯¹ï¼ˆè¿™ä¸ªæ¡ä»¶å¾ˆé‡è¦ï¼‰ã€‚è¯»æ‡‚è¿™ä¸ªæ¡ä»¶åŽï¼Œè®¡ç®—æ—¶é—´å°±æ¯”è¾ƒç®€å•äº†ï¼Œè®©å¼€å§‹æ—¶é—´ä¸€ç›´å¢žåŠ åˆ°ç»“æŸæ—¶é—´ï¼Œç»Ÿè®¡å¥½åˆ†é’Ÿæ•°æ—¢å¯å¾—åˆ°ç»åŽ†çš„æ—¶é—´ï¼Œç„¶åŽè®¡ç®—æ€»è´¹ç”¨ã€‚æ³¨æ„ï¼Œç»™å®šçš„è´¹çŽ‡æ˜¯cents/minuteï¼Œæœ€åŽå¾—è½¬åŒ–ä¸ºdollarï¼Œé™¤ä»¥100å³å¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct record&#123; char name[25]; int month, day, hour, minute; bool status;&#125; rec[MAXN], temp;int rate[25] = &#123;0&#125;;bool cmp(record a, record b);void get_time(int on, int off, int &amp;time, int &amp;money);int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; 24; i++) &#123; scanf("%d", rate + i); &#125; int N; scanf("%d", &amp;N); char line[10]; for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d:%d:%d:%d", rec[i].name, &amp;rec[i].month, &amp;rec[i].day, &amp;rec[i].hour, &amp;rec[i].minute); scanf("%s", line); if(!strcmp(line, "on-line")) &#123; rec[i].status = true; &#125; else &#123; rec[i].status = false; &#125; &#125; sort(rec, rec + N, cmp); int on = 0, off, next; while(on &lt; N) &#123; int needPrint = 0; next = on; // fint the next customer, and check the current customer has paired 'on-line' and 'off-line' or not while(next &lt; N &amp;&amp; strcmp(rec[next].name, rec[on].name) == 0) &#123; if(needPrint == 0 &amp;&amp; rec[next].status == true) &#123; needPrint = 1; &#125; else if(needPrint == 1 &amp;&amp; rec[next].status == false) &#123; needPrint = 2; &#125; next++; &#125; //the current customer has not paired 'on-line' and 'off-line', skip this customer if(needPrint &lt; 2) &#123; on = next; continue; &#125; //calculate the money for current customer int Total = 0; printf("%s %02d\n", rec[on].name, rec[on].month); while(on &lt; next) &#123; //find the paired 'on-line' and 'off-line' while(on &lt; next - 1 &amp;&amp; !(rec[on].status == true &amp;&amp; rec[on + 1].status == false)) &#123; on++; &#125; off = on + 1; if(off == next) &#123; on = next; break; &#125; printf("%02d:%02d:%02d ", rec[on].day, rec[on].hour, rec[on].minute); printf("%02d:%02d:%02d ", rec[off].day, rec[off].hour, rec[off].minute); int time = 0, money = 0; get_time(on, off, time, money); Total += money; printf("%d $%.2lf\n", time, money / 100.0); on = off + 1; &#125; printf("Total amount: $%.2lf\n", Total / 100.0); &#125; return 0;&#125;bool cmp(record a, record b) &#123; if(strcmp(a.name, b.name)) return strcmp(a.name, b.name) &lt; 0; else if(a.month != b.month) return a.month &lt; b.month; else if(a.day != b.day) return a.day &lt; b.day; else if(a.hour != b.hour) return a.hour &lt; b.hour; else return a.minute &lt; b.minute;&#125;void get_time(int on, int off, int &amp;time, int &amp;money) &#123; temp = rec[on]; while(temp.day &lt; rec[off].day || temp.hour &lt; rec[off].hour || temp.minute &lt; rec[off].minute) &#123; time++; money += rate[temp.hour]; temp.minute++; if(temp.minute &gt;= 60) &#123; temp.minute = 0; temp.hour++; &#125; if(temp.hour &gt;= 24) &#123; temp.hour = 0; temp.day++; &#125; &#125;&#125; 1018 Public Bike ManagementAnalysisé¢˜ç›®èƒŒæ™¯ç±»ä¼¼çŽ°åœ¨çš„å…±äº«å•è½¦ï¼Œè¿™ç§å…¬å…±è®¾æ–½æœåŠ¡æœ‰ä¸€ä¸ªç®¡ç†ä¸­å¿ƒï¼Œæœ¬é¢˜å«åš Public Bike Management Centerï¼Œç®€ç§° PMBCï¼Œè€Œè¿™ä¸ª PMBC ä¼šè°ƒæ•´æ¯ä¸ªåœé ç«™ç‚¹çš„è‡ªè¡Œè½¦æ•°ç›®ä»Žè€Œè¾¾åˆ°â€œå®Œç¾Žâ€çŠ¶æ€ï¼Œè¿™ç§â€œå®Œç¾Žâ€çŠ¶æ€æ˜¯æŒ‡åœé æ•°é‡ä¸ºè¯¥ç«™ç‚¹æœ€å¤§å®¹é‡çš„ä¸€åŠã€‚ é¢˜ç›®ç»™å®šå„ä¸ªç«™ç‚¹è·ç¦» PMBC çš„è·ç¦»ã€æ¯ä¸ªåœé ç«™ç‚¹å½“å‰çš„åœé æ•°é‡å’Œéœ€è¦æŠ•æ”¾è‡ªè¡Œè½¦çš„ç«™ç‚¹ï¼Œè¦æ±‚è¾“å‡ºå®ŒæˆæŠ•æ”¾å·¥ä½œéœ€è¦æºå¸¦çš„æœ€å°è‡ªè¡Œè½¦æ•°ç›®ã€å®ŒæˆæŠ•æ”¾å·¥ä½œçš„æœ€çŸ­è·¯å¾„å’Œå‰©ä½™å¸¦å›žçš„è½¦æ•°ï¼Œæ³¨æ„è·¯å¾„ä¸­çš„ç«™ç‚¹å¦‚æžœä¸æ˜¯å®Œç¾ŽçŠ¶æ€ï¼Œä¹Ÿéœ€è¦è°ƒæ•´ä¸ºå®Œç¾ŽçŠ¶æ€ã€‚ é¢˜ç›®çš„ç¬¬ä¸€è¦æ±‚æ˜¯æœ€çŸ­è·¯å¾„ï¼Œå€ŸåŠ© Dijkstra ç®—æ³•å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå†åˆ©ç”¨åŠ¨æ€æ•°ç»„ä¿å­˜å¥½æ¯ä¸€æ¡æœ€çŸ­è·¯å¾„ï¼Œç„¶åŽå€ŸåŠ© DFS æ¥è®¡ç®—é¢˜ç›®è¦æ±‚çš„æ‰€æºå¸¦çš„æœ€å°è‡ªè¡Œè½¦æ•°ç›®åŠå‰©ä½™å¸¦å›žçš„è½¦æ•°ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int Cmax, n, m, sp, G[maxv][maxv], weight[maxv];int d[maxv], minneed = inf, minremain = inf;bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path; void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt;= n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt;= n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt;= n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); int need = 0, remain = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; if(weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; if(remain + weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; need += abs(remain + weight[id]); remain = 0; &#125; &#125; &#125; if(need &lt; minneed) &#123; minneed = need; minremain = remain; path = tempath; &#125; else if(need == minneed &amp;&amp; remain &lt; minremain) &#123; minremain = remain; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; Cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] -= Cmax / 2; //preprocessing: make it 'perfect' &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); dfs(sp); cout &lt;&lt; minneed &lt;&lt; ' '; for(int i = path.size() - 1; i &gt;=0; i--) &#123; cout &lt;&lt; path[i]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; ' ' &lt;&lt; minremain; return 0;&#125; 1019 General Palindromic NumberAnalysisæ­¤é¢˜å±žäºŽç»“åˆäº†è¿›åˆ¶è½¬æ¢å’Œå›žæ–‡åºåˆ—åˆ¤æ–­çš„æ··åˆé¢˜ç›®ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;bool PalindromicNum(long long *digits, long long count);int main(int argc, char const *argv[]) &#123; long long N, b, count = 0, digits[50] = &#123;0&#125;; scanf("%lld %lld", &amp;N, &amp;b); while(N) &#123; digits[count++] = N % b; N /= b; &#125; count--; if(PalindromicNum(digits, count)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(; count &gt; 0; count--) &#123; printf("%lld ", digits[count]); &#125; printf("%lld\n", digits[count]); return 0;&#125;bool PalindromicNum(long long *digits, long long count) &#123; bool flag = true; int i, j; if(count % 2 == 0) &#123; i = j = count / 2; &#125; else &#123; i = count / 2; j = i + 1; &#125; for(; i &gt;= 0 &amp;&amp; j &lt;= count; i--, j++) &#123; if(digits[i] != digits[j]) &#123; flag = false; break; &#125; &#125; return flag;&#125; 1020 Tree TraversalsAnalysisé¢˜ç›®å¤§æ„ï¼Œç»™å®šä¸¤ä¸ªæ ‘çš„ä¸­åºéåŽ†å’ŒåŽåºéåŽ†ï¼Œæ±‚å…¶å±‚æ¬¡éåŽ†ã€‚ æ­¤é¢˜å±žäºŽæ ‘çš„å¸¸è§„é¢˜åž‹ï¼Œæ€è·¯æ˜¯åˆ©ç”¨ä¸­åºéåŽ†å’ŒåŽåºéåŽ†å»ºæ ‘ï¼Œç„¶åŽå†å€ŸåŠ© BFS è¿›è¡Œå±‚æ¬¡éåŽ†ï¼Œå¹¶è¾“å‡ºå±‚æ¬¡éåŽ†åºåˆ—ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50;struct node &#123; int data; node *lchild; node *rchild;&#125;;int pre[maxn], in[maxn], post[maxn];int n;node *create(int postL, int postR, int inL, int inR) &#123; if(postL &gt; postR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = post[postR]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == post[postR]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(postL, postL + numLeft - 1, inL, k - 1); root-&gt;rchild = create(postL + numLeft, postR - 1, k + 1, inR); return root;&#125;int num = 0;void BFS(node *root) &#123; queue&lt;node*&gt; q; q.push(root); while(!q.empty()) &#123; node *now = q.front(); q.pop(); printf("%d", now-&gt;data); num++; if(num &lt; n) printf(" "); if(now-&gt;lchild != NULL) q.push(now-&gt;lchild); if(now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node *root = create(0, n - 1, 0, n - 1); BFS(root); return 0;&#125; 1022 Digital LibraryAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯æ•°å­—å›¾ä¹¦é¦†çš„æ£€ç´¢åŠŸèƒ½ï¼Œè¦æ±‚å¤§è‡´æ¨¡æ‹Ÿä¸€ä¸‹è¿™ä¸ªåŠŸèƒ½ã€‚ æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œè¾“å‡ºä¹¦åæ—¶ï¼Œéœ€è¦æŒ‰åºè¾“å‡ºï¼Œæ¯”èµ·æž„é€ æ–°çš„æ•°æ®ç»“æž„åŽä½¿ç”¨sortå‡½æ•°æ¥å®Œæˆè¿™é¡¹æ“ä½œï¼Œä¸å¦‚ç›´æŽ¥å€ŸåŠ©setã€‚è€Œåœ¨æŸ¥è¯¢æ—¶ï¼Œæ˜¯é€šè¿‡å­—ç¬¦ä¸²æ¥è¿›è¡Œçš„æŸ¥è¯¢ï¼Œä½¿ç”¨mapå»ºç«‹æ˜ å°„åŽï¼Œå°±å¯ä»¥ç±»ä¼¼æ•£åˆ—ä¸€æ ·è¿›è¡ŒæŸ¥è¯¢ã€‚ ç»¼åˆä¸Šè¿°çš„ä¸¤ç§éœ€æ±‚åŽï¼Œå¥½åœ¨mapæ˜¯æ”¯æŒstringå‘setçš„æ˜ å°„çš„ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨å³å¯ã€‚ ç”±äºŽå…³é”®å­—keyæ˜¯ä¸€ä¸ªä¸€ä¸ªç»™å‡ºçš„ï¼Œæ‰€ä»¥éœ€è¦ä¸€ä¸ªä¸€ä¸ªè¾“å…¥å¹¶ç»Ÿè®¡ï¼Œä¾æ®cinæˆ–scanfè¾“å…¥å­—ç¬¦ä¸²çš„ç‰¹æ€§ï¼Œå¯ä»¥å¾ˆæ–¹ä¾¿çš„å•ä¸ªè¯»å…¥ï¼Œå¹¶ä½¿ç”¨getcharè¯»å–å›žè½¦ç¬¦ç»“æŸå¾ªçŽ¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; mpTitle, mpAuthor, mpKey, mpPub, mpYear;void query(map&lt;string, set&lt;int&gt; &gt; &amp;mp, string &amp;str) &#123; if(mp.find(str) == mp.end()) printf("Not Found\n"); else &#123; for(set&lt;int&gt;::iterator it = mp[str].begin(); it != mp[str].end(); it++) &#123; printf("%07d\n", *it); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, m, id, type; string title, author, key, pub, year; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;id); char c = getchar(); getline(cin, title); mpTitle[title].insert(id); getline(cin, author); mpAuthor[author].insert(id); while(cin &gt;&gt; key) &#123; mpKey[key].insert(id); c = getchar(); if(c == '\n') break; &#125; getline(cin, pub); mpPub[pub].insert(id); getline(cin, year); mpYear[year].insert(id); &#125; string temp; cin &gt;&gt; m; while(m--) &#123; scanf("%d: ", &amp;type); getline(cin, temp); cout &lt;&lt; type &lt;&lt; ": " &lt;&lt; temp &lt;&lt; endl; if(type == 1) query(mpTitle, temp); else if(type == 2) query(mpAuthor, temp); else if(type == 3) query(mpKey, temp); else if(type == 4) query(mpPub, temp); else query(mpYear, temp); &#125; return 0;&#125; 1023 Have Fun with NumbersAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™ä¸€ä¸ªä¸è¶…è¿‡20ä½çš„æ•´æ•°ï¼Œå°†è¿™ä¸ªæ•´æ•°ç¿»å€åŽï¼Œåˆ¤æ–­ç»„æˆè¿™ä¸ªæ–°æ•´æ•°çš„æ‰€æœ‰æ•°å­—æ˜¯å¦ä¸ŽåŽŸæ¥çš„æ•°å­—ç›¸åŒã€‚è‹¥æ˜¯ï¼Œè¾“å‡ºYesï¼›åä¹‹ï¼Œè¾“å‡ºNoã€‚æ³¨æ„ï¼Œæ— è®ºæ˜¯å¦ç¬¦åˆéƒ½éœ€è¦è¾“å‡ºç¿»å€åŽçš„æ–°æ•°å­—ã€‚ ç”±äºŽé¢˜ç›®æ˜Žç¡®è¯´äº†ç»™å®šçš„æ•°å­—ä½æ•°ä¸è¶…è¿‡20ä½ï¼Œä½†æ˜¯long longåªèƒ½åˆ°19ä½ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•°ç»„æ¥å­˜å‚¨æ•°å­—ï¼Œç„¶åŽåˆ©ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿä¹˜ä»¥2ã€‚ ç„¶åŽåˆ¤æ–­ä¸¤ä¸ªæ•°å­—çš„æ‰€æœ‰ä½æ•°å­—çš„å‡ºçŽ°æ¬¡æ•°æ˜¯å¦ä¸€è‡´å³å¯ï¼ˆåˆ©ç”¨æ•£åˆ—çš„æ€æƒ³ä¼šæ¯”è¾ƒæ–¹ä¾¿ï¼‰ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int Compare(int *original, int *now, int number);int main(int argc, char const *argv[]) &#123; char Num[22]; int original[22], now[22], original_occurrence[10] = &#123;0&#125;, now_occurrence[10] = &#123;0&#125;; scanf("%s", Num); char *p = Num; int i = 0, j, k, temp = 0, flag = 0; //conver the string to an array(int) while(*p != '\0') &#123; original[i++] = *p++ - '0'; &#125; //count the occurrence of the original number for(j = 0; j &lt; i; j++) &#123; original_occurrence[original[j]]++; &#125; //imitate multiplication for(k = 0, j = i - 1; j &gt;= 0; j--, k++) &#123; now[k] = (original[j] * 2 + temp) % 10; temp = original[j] * 2 / 10; &#125; if(temp) &#123; now[k] = temp; &#125; else &#123; k -= 1; &#125; //count the new number for(j = 0; j &lt;= k; j++) &#123; now_occurrence[now[j]]++; &#125; flag = Compare(original_occurrence, now_occurrence, 10); //print if(flag) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(j = k; j &gt; 0; j--) &#123; printf("%d", now[j]); &#125; printf("%d\n", now[j]); return 0;&#125;int Compare(int *original, int *now, int number) &#123; int i, j, ret = 1; for(i = 0; i &lt; number; i++) &#123; if(original[i] != now[i]) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 1024 Palindromic NumberAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•°å­—ï¼Œåˆ¤æ–­æ˜¯å¦ä¸ºå›žæ–‡æ•°å­—ï¼Œå¹¶è¿›è¡Œä¸€ç³»åˆ—æ“ä½œã€‚å¦å¤–ï¼Œç»™å®šä¸€ä¸ªä¸Šé™æ¬¡æ•°ï¼Œå½“ç»™å®šçš„æ•°ä¸æ˜¯å›žæ–‡æ•°å­—æ—¶ï¼Œä»¤å…¶åŠ ä¸Šå°†å…¶é€†ç½®åŽçš„æ•°å­—ï¼Œåœ¨è¿›è¡Œåˆ¤æ–­æ˜¯å¦ä¸ºä¼šé—®æ•°å­—ï¼Œè‹¥æ˜¯ï¼Œåˆ™è¾“å‡ºè¿™ä¸ªæ•°å­—å’Œå˜æ¢æ¬¡æ•°ï¼Œåä¹‹ï¼Œåˆ™ç»§ç»­ç›´è‡³è¶…è¿‡ä¸Šé™æ¬¡æ•°ã€‚æ³¨æ„ï¼Œå³ä¾¿è¶…è¿‡äº†ä¸Šé™æ¬¡æ•°ï¼Œä¾ç„¶è¦å˜æ¢è¿‡ç¨‹ä¸­æœ€åŽçš„æ•°å­—ã€‚ è§£å†³æ­¤é¢˜éœ€è¦è§£å†³ä¸‹é¢3ä¸ªå­é—®é¢˜ï¼š å›žæ–‡æ•°å­—çš„åˆ¤å®š æ•°å­—é€†ç½® æ•°å­—ç›¸åŠ  é¢˜ç›®è¦æ±‚æ•°å­—çš„èŒƒå›´ä¸è¶…è¿‡$10^{10}$ï¼Œå¯ä»¥ä½¿ç”¨long longï¼Œä½†è¿™ä¼šä½¿å¾—å°†æ•°å­—é€†ç½®çš„è¿™ä¸ªæ­¥éª¤éžå¸¸éº»çƒ¦ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•°ç»„æ¥å­˜å‚¨æ•°å­—ï¼Œå¹¶æ¨¡æ‹Ÿæ•°å­—ä¹‹é—´çš„åŠ æ³•ã€‚å¦å¤–è¿™æ ·è¿˜æœ‰ä¸€ä¸ªå¥½å¤„ï¼Œå°±æ˜¯åœ¨åˆ¤æ–­æ˜¯å¦æ˜¯å›žæ–‡æ•°å­—æ—¶ï¼Œå¯ä»¥ç›´æŽ¥å¯¹æ•°ç»„è¿›è¡Œåˆ¤æ–­ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign &#123; int d[200], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign reversebign(bign a) &#123; int temp; for(int i = 0; i &lt; a.len / 2; i++) &#123; temp = a.d[i]; a.d[i] = a.d[a.len - i - 1]; a.d[a.len - i - 1] = temp; &#125; return a;&#125;bign add(bign a, bign b) &#123; bign c; int carry = 0; for(int i = 0; i &lt; a.len || i &lt; b.len; i++) &#123; int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10; carry = temp / 10; &#125; if(carry != 0) &#123; c.d[c.len++] = carry; &#125; return c;&#125;bool isPalindromic(bign a) &#123; for(int i = 0; i &lt;= a.len / 2; i++) &#123; if(a.d[i] != a.d[a.len - 1 - i]) return false; &#125; return true;&#125;void print(bign a) &#123; for(int i = a.len - 1; i &gt;= 0; i--) &#123; printf("%d", a.d[i]); &#125; putchar('\n');&#125;int main(int argc, char const *argv[]) &#123; char str[150]; int times, count = 0; scanf("%s %d", str, &amp;times); bign a = change(str), rev; while(times--) &#123; if(isPalindromic(a)) &#123; break; &#125; else &#123; rev = reversebign(a); a = add(a, rev); count++; &#125; &#125; print(a); printf("%d", count); return 0;&#125; 1025 PTA RankingAnalysisæ­¤é¢˜è€ƒå¯ŸæŽ’åºï¼Œç›´æŽ¥è°ƒç”¨åº“é‡Œçš„æŽ’åºå‡½æ•°æ¥å¸®åŠ©å®ŒæˆæŽ’åºå°±å¥½äº†ã€‚æ³¨æ„ï¼š ä¸€ä¸ªåœ°ç‚¹å†…çš„æ‰€æœ‰æ•°æ®è¾“å…¥å®Œäº†ä¹‹åŽï¼Œæœ¬åœ°æŽ’åå°±å¯ä»¥å®Œæˆäº† æ¯ä¸ªæ•°æ®åœ¨åœ¨è¾“å…¥çš„æ—¶å€™å°±å¯ä»¥é¡ºä¾¿å¯¹å…¶è¿›è¡Œåœ°ç‚¹ç¼–å· æœ€ç»ˆæŽ’åå¿…é¡»è¦åœ¨æœ¬åœ°æŽ’åä¹‹åŽæ‰èƒ½è¿›è¡Œ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char id[15]; int score; int location_number; int local_rank;&#125; stu[30010];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, K, num = 0; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;K); for(int j = 0; j &lt; K; j++) &#123; scanf("%s %d", stu[num].id, &amp;stu[num].score); stu[num].location_number = i; num++; &#125; sort(stu + num - K, stu + num, cmp); stu[num - K].local_rank = 1; //get local rank for(int j = num - K + 1; j &lt; num; j++) &#123; if(stu[j].score == stu[j - 1].score) &#123; stu[j].local_rank = stu[j - 1].local_rank; &#125; else &#123; stu[j].local_rank = j + 1 - (num - K); &#125; &#125; &#125; printf("%d\n", num); sort(stu, stu + num, cmp); //get final rank int r = 1; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].score != stu[i - 1].score) &#123; r = i + 1; &#125; printf("%s ", stu[i].id); printf("%d %d %d\n", r, stu[i].location_number, stu[i].local_rank); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.id, b.id) &lt; 0;&#125; 1027 Colors in MarsAnalysisè€ƒå¯Ÿè¿›åˆ¶è½¬æ¢çš„é¢˜ç›®ï¼Œ10è¿›åˆ¶è½¬æ¢ä¸º13è¿›åˆ¶ï¼Œä¸Žè½¬æ¢10è¿›åˆ¶è½¬æ¢ä¸º16è¿›åˆ¶æ˜¯ç±»ä¼¼çš„ï¼Œä»£ç å¯èƒ½å†™çš„ä¸å¤ªå¥½çœ‹ï¼Œå˜¿å˜¿~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;char Change(int number);int Transfer(char *dst, int number, int dex);int main(int argc, char const *argv[]) &#123; int R, G, B, index = 1; scanf("%d %d %d", &amp;R, &amp;G, &amp;B); char color[10] = "#00000000"; index = Transfer(color, R, index); index = Transfer(color, G, index); index = Transfer(color, B, index); color[index] = '\0'; puts(color); return 0;&#125;int Transfer(char *dst, int number, int index) &#123; int mask = 1, temp = number; while(temp &gt; 12) &#123; temp /= 13; mask *= 13; &#125; temp = number; if(mask &gt; 1) &#123; while(mask) &#123; dst[index++] = Change(temp / mask); temp %= mask; mask /= 13; &#125; &#125; else &#123; index++; dst[index++] = Change(temp); &#125; return index;&#125;char Change(int number) &#123; char ret; if(0 &lt;= number &amp;&amp; number &lt;= 9) &#123; ret = number + '0'; &#125; else &#123; ret = number - 10 + 'A'; &#125; return ret;&#125; 1028 List SortingAnalysisè€ƒå¯ŸæŽ’åºï¼Œç”¨è¾“å…¥çš„æ•°å­—è¡¨ç¤ºä»¥å…ƒç´ çš„æŸä¸€é¡¹è¿›è¡ŒæŽ’åºï¼Œç›´æŽ¥æŠŠç±»åˆ«æ•°å­—ç”¨å…¨å±€å˜é‡ä»£æ›¿ï¼Œç„¶åŽåœ¨cmpå‡½æ•°ä¸­ç›´æŽ¥ä½¿ç”¨å³å¯ï¼Œæ³¨æ„å­—ç¬¦ä¸²éœ€è¦ç”¨strcmpå‡½æ•°è¿›è¡Œæ¯”è¾ƒã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char id[10], name[15]; int grade;&#125; stu[MAXN];int N, C;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;C); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].id, stu[i].name, &amp;stu[i].grade); &#125; sort(stu, stu + N, cmp); for(int i = 0; i &lt; N; i++) &#123; printf("%s %s %d\n", stu[i].id, stu[i].name, stu[i].grade); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(C == 1) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; else if(C == 2) &#123; int temp = strcmp(a.name, b.name); if(temp != 0) return temp &lt; 0; else return strcmp(a.id, b.id) &lt; 0; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return strcmp(a.id, b.id) &lt; 0; &#125;&#125; 1029 MedianAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸¤ä¸ªé€’å¢žåºåˆ—ï¼Œæ±‚è¿™ä¸¤ä¸ªåºåˆ—åˆå¹¶åŽçš„ä¸­ä½æ•°ã€‚ æ˜Žç¡®äº†ä»€ä¹ˆæ˜¯ä¸­ä½æ•°ä¹‹åŽï¼Œè§£å†³è¿™ä¸ªé—®é¢˜çš„æ–¹æ³•å°±æœ‰å¾ˆå¤šäº†ã€‚è¶…çº§æ— è„‘çš„åšæ³•å°±æ˜¯ç›´æŽ¥æŠŠå…¶ä¸­ä¸€ä¸ªåºåˆ—æ‹¼æŽ¥åœ¨å¦å¤–ä¸€ä¸ªåºåˆ—åŽé¢ï¼ŒæŽ’ä¸ªåºï¼Œç„¶åŽç›´æŽ¥è¾“å‡ºå…¶ä¸­ä½æ•°å°±å¥½äº†ã€‚ä½†æ˜¯æ³¨æ„åˆ°é¢˜ç›®çš„Memory Limit: 1.5 MBï¼Œè¯´æ˜Žé¢˜ç›®å¯¹å†…å­˜æœ‰è¦æ±‚ï¼Œç®€å•ç›´æŽ¥çš„åšæ³•å¯èƒ½å¯¼è‡´Memory Limit Exceededçš„é”™è¯¯ã€‚ é‚£ä¹ˆå°±éœ€è¦æƒ³åŠžæ³•ä¼˜åŒ–ç©ºé—´äº†ï¼Œé¢˜ç›®ç»™å®šçš„ä¸¤ä¸ªåºåˆ—ï¼ŒæŒ‰ç…§ä¸Šè¿°çš„æ€è·¯ï¼Œå°±éœ€è¦ä¸‰ä¸ªæ•°ç»„ï¼ˆä¸¤ä¸ªå­˜ç»™å®šçš„ï¼Œä¸€ä¸ªå­˜åˆå¹¶åŽçš„ï¼‰ï¼Œèƒ½ä¸èƒ½å°‘ç”¨ä¸€ä¸ªæˆ–ä¸¤ä¸ªå‘¢ï¼Ÿç­”æ¡ˆæ˜¯è‚¯å®šçš„ï¼Œå…¶å®žå¯ä»¥ä¸ç”¨å®Œå…¨åˆå¹¶ï¼Œè€Œåªéœ€è¦æ¨¡æ‹Ÿè¿™ä¸ªåˆå¹¶æ“ä½œçš„è¿‡ç¨‹ï¼Œå¹¶åœ¨è¿™ä¸ªè¿‡ç¨‹ä¸­ï¼ŒæŒ‰ç…§é¡ºåºæ¥ç»Ÿè®¡æ˜¯å¦æžšä¸¾åˆ°äº†é‚£ä¸ªä¸­ä½æ•°ï¼ˆæ ¹æ®æ•°ç»„ä¸‹æ ‡çš„åˆå§‹å€¼ï¼Œä¸­ä½æ•°çš„ä½ç½®æ˜¯å¯ä»¥ç›´æŽ¥ç®—å‡ºæ¥çš„ï¼‰å³å¯ã€‚ ä¸è¿‡ï¼Œå¾ˆå¯æƒœï¼Œé“é«˜ä¸€å°ºé­”é«˜ä¸€ä¸ˆï¼Œè¿™ä¸ªé¢˜æ›´æ–°ï¼ˆ2018å¹´3æœˆä¹‹åŽï¼Ÿï¼‰äº†æµ‹è¯•æ ·ä¾‹ï¼Œæœ€åŽä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹è¿˜æ˜¯æ— æ³•é€šè¿‡ï¼Œå¹¶ä¸”è¿˜æ˜¯MLEçš„é”™è¯¯ã€‚ è¿™å°±å¾—é åœ¨çº¿å¤„ç†äº†ï¼Œåœ¨è¯»å…¥ç¬¬äºŒä¸ªåºåˆ—æ—¶ï¼Œå°†æ¯æ¬¡è¯»å…¥çš„æ•°å­—å­˜åœ¨ä¸€ä¸ªå˜é‡å†…ï¼Œæ¯æ¬¡éœ€è¦ç»Ÿè®¡ç¬¬ä¸€ä¸ªåºåˆ—ä¸­æœ‰å¤šå°‘æ•°å­—å°äºŽå®ƒï¼Œç„¶åŽæ ¹æ®è¿™ä¸€ç‚¹æ¥è®¡ç®—å‡ºè¿™ä¸ªæ•°å­—åœ¨åˆå¹¶åŽçš„åºåˆ—ä¸­æ‰€å¤„çš„ä½ç½®ï¼Œå¹¶ä¸Žä¸­ä½æ•°çš„ä½ç½®è¿›è¡Œæ¯”è¾ƒï¼Œç„¶åŽæ¥å†³å®šæ˜¯å¦è¾“å‡ºã€‚åœ¨è¯»å…¥ç¬¬äºŒä¸ªåºåˆ—çš„è¿‡ç¨‹ä¸­å­˜åœ¨ä¸¤ç§æƒ…å†µï¼š æ•°å­—å­˜åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…ï¼Œå¹¶ä¸”æ­¤æ—¶å¯ä»¥ç¡®å®šä¸­ä½æ•°å¿…å®šæ¯”å½“å‰è¯»å…¥çš„æ•°å­—å° æ•°å­—å­˜åœ¨ç¬¬äºŒä¸ªåºåˆ—å†…ï¼Œå°±æ˜¯å½“å‰è¯»å…¥çš„æ•°å­— é’ˆå¯¹ä¸Šè¿°ä¸¤ç§æƒ…å†µï¼Œç»Ÿè®¡åˆ°ä¸­ä½æ•°åŽç›´æŽ¥è¾“å‡ºå³å¯ï¼Œä½†æ˜¯è¦æ³¨æ„ï¼Œè‹¥æ˜¯ç¬¬äºŒä¸ªåºåˆ—çš„æ•°å­—æ¯”ç¬¬ä¸€ä¸ªåºåˆ—å°‘å¾ˆå¤šï¼ˆæˆ–è€…å°å¾ˆå¤šç­‰æžç«¯æƒ…å†µï¼‰ï¼Œé‚£ä¹ˆä¸­ä½æ•°ä¾ç„¶è¿˜æ˜¯åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…ï¼Œæ‰€ä»¥è¿˜æ˜¯å¾—åœ¨ç¬¬ä¸€ä¸ªåºåˆ—å†…æ‰¾ã€‚ Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 200000 + 10;int seq[MAXN];int main(int argc, char const *argv[]) &#123; int n1, n2, temp, count = 0; scanf("%d", &amp;n1); for(int i = 1; i &lt;= n1; i++) &#123; scanf("%d", &amp;seq[i]); &#125; seq[n1 + 1] = 0x7fffffff; scanf("%d", &amp;n2); int median = (n1 + n2 + 1) / 2, i = 1; for(int j = 1; j &lt;= n2; j++) &#123; scanf("%d", &amp;temp); while(seq[i] &lt; temp) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; count++; if(count == median) printf("%d", temp); &#125; while(i &lt;= n1) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; return 0;&#125; 1030 Travel PlanAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ—…æ¸¸åœ°å›¾ï¼Œæ¯ä¸ªç»“ç‚¹ä¹‹é—´çš„è¾¹ï¼ŒåŒ…å«ä¸¤ä¸ªå±žæ€§å€¼ï¼šè·ç¦»å’ŒèŠ±é”€ã€‚ç„¶åŽï¼Œç»™å®šèµ·ç‚¹å’Œç»ˆç‚¹ï¼Œè¦æ±‚è¾“å‡ºäºŒè€…ä¹‹é—´çš„æœ€çŸ­è·¯å¾„çš„æ€»è·ç¦»å’Œå¯¹åº”çš„èŠ±é”€ï¼Œè‹¥å­˜åœ¨ç›¸åŒæ€»è·ç¦»çš„æœ€çŸ­è·¯å¾„ï¼Œæ­¤æ—¶éœ€è¾“å‡ºæœ€å°çš„èŠ±é”€å€¼ã€‚ ç”±äºŽé¢˜ç›®å·²ç»è¯´æ˜Žè¾“å…¥æ•°æ®ä¸å­˜åœ¨è´Ÿæ•°ï¼Œä¸”åªæœ‰ä¸€ä¸ªèµ·ç‚¹ï¼Œé—®é¢˜å°±å˜æˆäº†ä¸å­˜åœ¨è´ŸçŽ¯çš„å›¾çš„å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ã€‚æ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨ Dijkstra ç®—æ³•è¿›è¡Œæ±‚è§£ã€‚ç”±äºŽéœ€è¦è¾“å‡ºå¯¹åº”çš„æœ€çŸ­è·¯å¾„ï¼Œæ‰€ä»¥å¯ä»¥åœ¨ Dijkstra ç®—æ³•æ±‚è§£æœ€çŸ­è·¯å¾„çš„è¿‡ç¨‹ä¸­ï¼Œé¡ºä¾¿åˆ©ç”¨ä¸€ä¸ªæ•°ç»„æ¥ä¿å­˜æœ€ä¼˜è·¯å¾„ï¼Œä¹‹åŽå†åˆ©ç”¨ DFS æ¥æ­£åºè¾“å‡ºè·¯å¾„ï¼›å½“ç„¶ï¼Œä¹Ÿå¯ä»¥åˆ©ç”¨åŠ¨æ€æ•°ç»„ä¿å­˜æ‰€æœ‰çš„è·¯å¾„ï¼Œä¹‹åŽå†åˆ©ç”¨ DFS éåŽ†æ¯æ¡è·¯å¾„ï¼Œæ¥æ±‚è§£èŠ±é”€å€¼æœ€å°çš„è·¯å¾„ã€‚ CodeDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, s, t, G[maxv][maxv], cost[maxv][maxv];int d[maxv], c[maxv], pre[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, inf); // do not forget initialize the distance array for(int i = 0; i &lt; n; i++) pre[i] = i; d[s] = 0; c[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; pre[v] = u; // save the precursor &#125; else if(d[u] + G[u][v] == d[v]) &#123; if(c[u] + cost[u][v] &lt; c[v]) &#123; // more optimized result c[v] = c[u] + cost[u][v]; pre[v] = u; &#125; &#125; &#125; &#125; &#125;&#125; void dfs(int v) &#123; if(v == s) &#123; cout &lt;&lt; v &lt;&lt; ' '; return; &#125; dfs(pre[v]); cout &lt;&lt; v &lt;&lt; ' ';&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(s); dfs(t); cout &lt;&lt; d[t] &lt;&lt; ' ' &lt;&lt; c[t]; return 0;&#125; Dijkstra + DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, G[maxv][maxv], cost[maxv][maxv];int d[maxv], mincost = inf; // mincost need to be initialized to 'inf' bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); // do not forget clear pre[v].push_back(u); &#125; else if(d[u] + G[u][v] == d[v]) &#123; pre[v].push_back(u); // save other shortest path &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == st) &#123; tempath.push_back(v); int tempcost = 0; for(int i = tempath.size() - 1; i &gt; 0; i--) &#123; int id = tempath[i], idNext = tempath[i - 1]; tempcost += cost[id][idNext]; &#125; if(tempcost &lt; mincost) &#123; path = tempath; mincost = tempcost; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(st); dfs(ed); for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; path[i] &lt;&lt; ' '; &#125; cout &lt;&lt; d[ed] &lt;&lt; ' ' &lt;&lt; mincost; return 0;&#125; 1031 Hello World For UAnalysisè¿™é“é¢˜å±žäºŽæ‰“å°å›¾å½¢ç±»çš„é¢˜ç›®ï¼Œé¢˜çœ¼å¤§æ¦‚å°±æ˜¯æ‰¾åˆ°å›¾å½¢è¾“å‡ºçš„è§„å¾‹äº†ï¼Œæ‰€ä»¥è¯»é¢˜å¾—ä»”ç»†ä¸€ç‚¹ã€‚ä¸è¿‡ï¼Œå¾ˆå·§åœ°æ˜¯ï¼Œè¿™é“é¢˜ç›®ï¼Œç”¨æ¥æ‰¾è§„å¾‹çš„é‚£ä¸ªæ¡ä»¶ä¸æ˜¯å¾ˆæ˜Žæ˜¾ï¼Œå¯èƒ½è¿˜ä¸å¤ªå®¹æ˜“çœ‹æ‡‚ï¼ˆå¯èƒ½æˆ‘è‹±è¯­æ¸£~ï¼‰ï¼Œå°±æ˜¯è¿™ä¸ªæ¡ä»¶$n_1 = n_3 = max \lbrace{k | k \le n_2\ for\ all\ 3 \le n_2 \le N}\rbrace \ with \ n_1 + n_2 + n3 - 2 = N$äº†ã€‚æ„æ€å¤§è‡´æ˜¯ï¼š$n_1 = n_3 \le k$ï¼Œè€Œ$k$è¿™ä¸ªæ•°æ˜¯å¾—ä¸¥æ ¼å°äºŽç­‰äºŽ$n_2$ï¼Œè€Œ$n_2$çš„å–å€¼èŒƒå›´ä¸ºï¼š$[3, N]$ï¼Œå¦å¤–è¿˜æœ‰ä¸€ä¸ªæ¡ä»¶$n_1 + n_2 + n_3 - 2 = N$ã€‚ å¦å¤–ï¼Œ$n_1$æ˜¯æŒ‡æœ€å·¦è¾¹ä¸€åˆ—â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$n_2$æ˜¯æŒ‡åº•éƒ¨â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$n_3$æ˜¯æŒ‡æœ€å³è¾¹ä¸€åˆ—â€œå­—ç¬¦ä¸²â€çš„é•¿åº¦ï¼Œ$N$å°±æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„å­—ç¬¦ä¸²é•¿åº¦äº†ã€‚ äº‹å®žä¸Šï¼Œ$n_1 = n_3 = (N + 2) / 3$ï¼Œç„¶åŽæ±‚å¾—$n_2$å³å¯å¼€å§‹æ‰“å°è¾“å‡ºäº†ðŸ˜’ã€‚ å¯ä»¥ç›´æŽ¥æ‰“å°è¾“å‡ºï¼Œä¸è¿‡è¿˜è¦æ‰¾äº›å°è§„å¾‹ï¼ˆæŠ˜ç£¨ä½ ðŸ˜†ï¼‰ï¼Œå¦‚ç¬¬ä¸€è¡Œè¾“å‡ºçš„æ˜¯å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—ç¬¦å’Œæœ€åŽä¸€ä¸ªå­—ç¬¦ï¼›å…ˆè¾“å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ï¼Œç„¶åŽè¾“å‡ºç©ºæ ¼ï¼ŒæŽ¥ç€åœ¨è¾“å‡ºæœ€åŽä¸€ä¸ªå­—ç¬¦å³å¯ã€‚ä¹Ÿå¯ä»¥å…ˆæŠŠæ¯ä¸€ä¸ªå­—ç¬¦æ”¾åˆ°äºŒç»´æ•°ç»„å†…ï¼Œåˆ©ç”¨ç©ºæ ¼åˆå§‹åŒ–äºŒç»´æ•°ç»„ï¼Œç„¶åŽåœ¨æŒ‡å®šä½ç½®æ”¾å…¥å­—ç¬¦ï¼Œæœ€åŽè¾“å‡ºå³å¯ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n1, n2, n3, N; char str[85]; scanf("%s", str); N = strlen(str); n1 = n3 = (N + 2) / 3; //get n1 and n3 first n2 = N + 2 - 2 * n1; //use the condition: n1 + n2 + n3 - 2 = N for(int i = 0; i &lt; n1; i++) &#123; if(i == n1 - 1) &#123; //print the last line for(int j = i; j &lt;= N - i - 1; j++) &#123; printf("%c", str[j]); &#125; &#125; else &#123; printf("%c", str[i]); for(int j = 0; j &lt; n2 - 2; j++) &#123; putchar(' '); &#125; printf("%c", str[N - i - 1]); &#125; putchar('\n'); &#125; return 0;&#125; 1032 SharingAnalysisé¢˜ç›®å¤§æ„æ˜¯ä½¿ç”¨é“¾è¡¨å­˜å‚¨è‹±æ–‡å­—ç¬¦æ—¶ï¼Œå› ä¸ºè‹±æ–‡å­—ç¬¦å­˜åœ¨ç›¸åŒçš„åŽç¼€ï¼Œæ‰€ä»¥å…¬å…±åŽç¼€åªå­˜å‚¨ä¸€æ¬¡ï¼Œç„¶åŽè®©ä¸åŒä¸”å…·æœ‰è¿™ä¸ªå…¬å…±åŽç¼€å•è¯çš„æœ€åŽä¸€ä¸ªä¸å±žäºŽè¿™ä¸ªåŽç¼€çš„å­—æ¯çš„nextæŒ‡å‘å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯å³å¯ï¼Œè¿™æ ·å°±å¯ä»¥èŠ‚çº¦ä¸€å®šçš„å­˜å‚¨ç©ºé—´äº†ã€‚ æŒ‰ç…§é¢˜ç›®èƒŒæ™¯ï¼Œé¢˜ç›®è¦æ±‚æ‰¾å‡ºå…·æœ‰ä¸¤ä¸ªå•è¯çš„å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯çš„åœ°å€å¹¶è¾“å‡ºï¼Œè‹¥ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡º-1ã€‚ç›´è§‚çš„åšæ³•æ˜¯ï¼ŒéåŽ†ç¬¬ä¸€ä¸ªé“¾è¡¨ï¼ŒåŒæ—¶éåŽ†ç¬¬äºŒä¸ªé“¾è¡¨ï¼Œæ‰¾åˆ°äºŒè€…ä¸­å…·æœ‰ç›¸åŒaddressçš„å…ƒç´ ï¼Œè¾“å‡ºå³å¯ï¼Œæ­¤æ—¶çš„æ—¶é—´å¤æ‚åº¦ä¸ºï¼š$O(n^2)$ã€‚ æŒ‰ç…§é¢˜ç›®ç»™å®šçš„å½¢å¼ï¼Œä½¿ç”¨é™æ€é“¾è¡¨æ¥å¤„ç†é—®é¢˜ï¼ŒæŽ¥ç€ä¸Šé¢çš„æ€è€ƒï¼Œè‹¥åœ¨éåŽ†ç¬¬ä¸€ä¸ªé“¾è¡¨æ—¶ï¼Œç»™å…¶æ¯ä¸€ä¸ªç»“ç‚¹éƒ½åŠ ä¸Šä¸€ä¸ªæ ‡å¿—ä½ï¼›æŽ¥ç€åœ¨éåŽ†ç¬¬äºŒä¸ªé“¾è¡¨æ—¶ï¼Œå°±å¯ä»¥ç›´æŽ¥åˆ¤æ–­ç¬¬äºŒä¸ªé“¾è¡¨çš„ç»“ç‚¹çš„æ ‡å¿—ä½æ˜¯å¦ä¸Žç¬¬ä¸€ä¸ªé“¾è¡¨ç»“ç‚¹çš„æ ‡å¿—ä½ç›¸åŒï¼Œè‹¥ç›¸åŒï¼Œåˆ™è¿™ä¸ªç»“ç‚¹å°±æ˜¯äºŒè€…å…¬å…±åŽç¼€çš„ç¬¬ä¸€ä¸ªå­—æ¯äº†ï¼Œå°±å¯ä»¥è¾“å‡ºäº†ï¼Œè¿™æ ·æ—¶é—´å¤æ‚åº¦å°±é™ä¸ºï¼š$O(n)$äº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125; node[maxn];int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int head1, head2, n; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); int address, next; char data; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;address, &amp;data, &amp;next); node[address].next = next; node[address].data = data; &#125; int p; for(p = head1; p != -1; p = node[p].next) &#123; node[p].flag = true; &#125; for(p = head2; p != -1; p = node[p].next) &#123; if(node[p].flag == true) break; &#125; if(p != -1) &#123; printf("%05d\n", p); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1033 To Fill or Not to FillAnalysisæ­¤é¢˜è€ƒå¯Ÿè´ªå¿ƒç®—æ³•ï¼Œå¦‚ä½•è¿›è¡Œâ€œè´ªå¿ƒâ€å¾—ä»Žç»“æžœå’Œé¢˜æ„ä¸ŠåŽ»åˆ†æžã€‚ ä¾æ®ç»“æžœï¼Œæ¯æ¬¡ç»è¿‡ä¸€ä¸ªåŠ æ²¹ç«™æ—¶ï¼Œéœ€è¦å°†å½“å‰åŠ æ²¹ç«™ä¸Žå°è½¦ä»Žå½“å‰åŠ æ²¹ç«™èƒ½åˆ°è¾¾çš„æ¯ä¸ªåŠ æ²¹ç«™çš„æ²¹ä»·è¿›è¡Œæ¯”è¾ƒï¼Œè‹¥å­˜åœ¨æ²¹ä»·æ›´ä½Žçš„åŠ æ²¹ç«™ï¼Œé‚£ä¹ˆå°±åŠ åˆšå¥½èƒ½åˆ°è¾¾é‚£ä¸ªåŠ æ²¹ç«™çš„æ²¹é‡ï¼Œå¦åˆ™å°±åŠ æ»¡ã€‚æ‰€ä»¥éœ€è¦å°†åŠ æ²¹ç«™æŒ‰ç…§ç¦»æ­å·žçš„è·ç¦»ä»Žå°åˆ°å¤§è¿›è¡ŒæŽ’åˆ—ï¼Œå¹¶å‡è®¾ç›®çš„åœ°ç¦»æ­å·žçš„è·ç¦»ä¸ºè¾“å…¥è·ç¦»ï¼Œæ²¹ä»·ä¸º0ï¼ˆè¿™æ ·åšçš„ç›®çš„æ˜¯ä¸ºäº†æ–¹ä¾¿æ¯”è¾ƒï¼Œä¸ç”¨å¤„ç†ç‰¹æ®Šæƒ…å†µï¼‰ã€‚ç„¶åŽï¼Œå¼€å§‹æ¨¡æ‹Ÿå°è½¦ä»Žèµ·ç‚¹å‡ºå‘ã€‚ å½“ç¬¬ä¸€ä¸ªåŠ æ²¹ç«™ç¦»æ­å·žçš„è·ç¦»ä¸ä¸º0æ—¶ï¼Œè¯´æ˜Žå°è½¦æ— æ³•å‡ºåŸŽï¼Œç›´æŽ¥è¾“å‡ºThe maximum travel distance = 0.00å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 500 + 5;const int INF = 1000000000;struct station &#123; double price, dis;&#125; sta[MAXN];bool cmp(station a, station b);int main(int argc, char const *argv[]) &#123; double cmax, d, davg; int N; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[N].price = 0; sta[N].dis = d; sort(sta, sta + N, cmp); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, capacity = 0, max = cmax * davg; while(now &lt; N) &#123; int k = -1; double priceMin = INF; for(int i = now + 1; i &lt;= N &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; priceMin) &#123; priceMin = sta[i].price; k = i; if(priceMin &lt; sta[now].price) &#123; break; &#125; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(priceMin &lt; sta[now].price) &#123; if(capacity &lt; need) &#123; ans += (need - capacity) * sta[now].price; capacity = 0; &#125; else &#123; capacity -= need; &#125; &#125; else &#123; ans += (cmax - capacity) * sta[now].price; capacity = cmax - need; &#125; now = k; &#125; if(now == N) &#123; printf("%.2lf\n", ans); &#125; else &#123; printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; &#125; return 0;&#125;bool cmp(station a, station b) &#123; return a.dis &lt; b.dis;&#125; 1034 Head of a GangAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2010;const int INF = 1000000000;map&lt;int, string&gt; intTostring;map&lt;string, int&gt; stringToint;map&lt;string, int&gt; Gang;int G[maxn][maxn] = &#123;0&#125;, weight[maxn] = &#123;0&#125;;int n, k, numPerson = 0;bool visited[maxn] = &#123;false&#125;;void DFS(int nowVisit, int &amp;head, int &amp;numMember, int &amp;totalValue) &#123; numMember++; visited[nowVisit] = true; if(weight[nowVisit] &gt; weight[head]) &#123; head = nowVisit; &#125; for(int i = 0; i &lt; numPerson; i++) &#123; if(G[nowVisit][i] &gt; 0) &#123; totalValue += G[nowVisit][i]; G[nowVisit][i] = G[i][nowVisit] = 0; if(visited[i] == false) &#123; DFS(i, head, numMember, totalValue); &#125; &#125; &#125;&#125;void DFSTrave() &#123; for(int i = 0; i &lt; numPerson; i++) &#123; if(visited[i] == false) &#123; int head = i, numMember = 0, totalValue = 0; DFS(i, head, numMember, totalValue); if(numMember &gt; 2 &amp;&amp; totalValue &gt; k) &#123; Gang[intTostring[head]] = numMember; &#125; &#125; &#125;&#125;int change(string s) &#123; if(stringToint.find(s) != stringToint.end()) &#123; return stringToint[s]; &#125; else &#123; stringToint[s] = numPerson; intTostring[numPerson] = s; return numPerson++; &#125;&#125;int main(int argc, char const *argv[]) &#123; int w; string s1, s2; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = change(s1); int id2 = change(s2); weight[id1] += w; weight[id2] += w; G[id1][id2] += w; G[id2][id1] += w; &#125; DFSTrave(); cout &lt;&lt; Gang.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator it; for(it = Gang.begin(); it != Gang.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; 1035 PasswordAnalysisé¢˜ç›®çœ‹ç€è‡­é•¿è‡­é•¿çš„ï¼Œå…¶å®žæ¯”è¾ƒç®€å•ï¼Œå°±æ˜¯æœ‰äº›å°å°çš„ç»†èŠ‚... å…ˆåˆ†æžè¾“å…¥æ ¼å¼ï¼Œç»™ä¸ªNä»£è¡¨Nç»„æ•°æ®ï¼Œç„¶åŽæ¯ä¸€ç»„æ•°ç»„æŒ‰ç…§name passwordçš„æ ¼å¼æ¥ç»™å‡ºï¼Œéƒ½æ˜¯å­—ç¬¦ä¸²ï¼Œç”±äºŽè¾“å‡ºæ—¶åŽè¦åŒç­‰è¾“å‡ºï¼Œæ‰€ä»¥æ–¹ä¾¿èµ·è§å®šä¹‰ä¸€ä¸ªç»“æž„ä½“æ¥ä¿å­˜è¿™äº›æ•°æ®ï¼›å†è€…ï¼Œç”±äºŽæœ€åŽå¾—å…ˆè¾“å‡ºè¢«ä¿®æ”¹çš„æ•°é‡ï¼Œæ‰€ä»¥å¾—å…ˆæŠŠæ•°æ®éƒ½å­˜å‚¨ä¸‹æ¥ï¼Œæ‰èƒ½åœ¨è¾“å‡ºæ•°é‡åŽï¼Œåœ¨è¾“å‡ºä¿®æ”¹çš„ä¿¡æ¯ã€‚ å†çœ‹è¾“å‡ºæ ¼å¼ï¼Œè‹¥æœ‰ä¿®æ”¹ï¼Œå°±è¾“å‡ºä¿®æ”¹çš„æ•°é‡ï¼Œç„¶åŽæ¯è¡Œç´§æŽ¥ç€æ¯ä¸ªç»“æž„ä½“å†…çš„ä¿¡æ¯ï¼›è‹¥æ²¡æœ‰ä¿®æ”¹ï¼Œå°±è¾“å‡ºThere are N accounts and no account is modifiedï¼Œæ³¨æ„è¿™é‡Œçš„ç»†èŠ‚ï¼Œå½“Nä¸º1æ—¶ï¼Œå¾—è¾“å‡ºThere is 1 accounts and no account is modifiedï¼Œè¿™ä¸¤å¥è‹±æ–‡åœ¨Nä¸º1å’Œå…¶ä»–æ•°æ—¶ä½¿ç”¨çš„BeåŠ¨è¯ä¸ä¸€æ ·ï¼ˆè€å¸ˆå‡ºé¢˜å¾ˆä¸¥è°¨çš„ï¼ŒðŸ¤£è‹±è¯­è¦å­¦å¥½ï¼Œå“ˆå“ˆ~ï¼‰ã€‚ å…¶ä»–å°±æ²¡ä»€ä¹ˆäº†ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;const int MAXN = 1000 + 5;struct info &#123; char name[12], password[12]; int flag;&#125; Info[MAXN];int main(int argc, char const *argv[]) &#123; int N, count = 0; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s", Info[i].name, Info[i].password); char *p = Info[i].password; while(*p != '\0') &#123; if(*p == '1') &#123; *p = '@'; Info[i].flag = 5; &#125; else if(*p == '0') &#123; *p = '%'; Info[i].flag = 5; &#125; else if(*p == 'l') &#123; *p = 'L'; Info[i].flag = 5; &#125; else if(*p == 'O') &#123; *p = 'o'; Info[i].flag = 5; &#125; p++; &#125; if(Info[i].flag != 5) &#123; count++; &#125; &#125; if(count == N) &#123; if(count == 1) printf("There is %d account and no account is modified\n", count); else printf("There are %d accounts and no account is modified", count); &#125; else &#123; printf("%d\n", N - count); for(int i = 0; i &lt; N; i++) &#123; if(Info[i].flag == 5) &#123; printf("%s %s\n", Info[i].name, Info[i].password); &#125; &#125; &#125; return 0;&#125; 1036 Boys vs GirlsAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œæ‰¾å‡ºå¥³ç”Ÿä¸­åˆ†æœ€é«˜çš„ï¼Œç”·ç”Ÿä¸­åˆ†æœ€ä½Žçš„ï¼Œåˆ†åˆ«è¾“å‡ºä»–ä»¬çš„å§“åã€å­¦å·å’Œåˆ†æ•°ä¹‹å·®å³å¯ï¼Œç”±äºŽæœ€åŽéœ€è¦çš„ä¸¤ä¸ªç»“æžœå¯èƒ½æ²¡æœ‰å‡ºçŽ°ï¼Œåˆ©ç”¨ä¸¤ä¸ªæ ‡è®°æ¥è®°å½•çŠ¶æ€ï¼Œç„¶åŽæ ¹æ®4ç§ä¸åŒçš„çŠ¶æ€ï¼Œåˆ†åˆ«å¯¹åº”è¾“å‡ºå³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;struct student&#123; char name[15]; char id[15]; char gender; int grade;&#125; Fhighest, Mlowest, temp;void Init();bool Highest(student a, student b);bool Lowest(student a, student b);int main(int argc, char const *argv[]) &#123; Init(); int N; bool Fflag = false, Mflag = false; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %c %s %d", temp.name, &amp;temp.gender, temp.id, &amp;temp.grade); if(temp.gender == 'F') &#123; if(Highest(temp, Fhighest)) &#123; Fhighest = temp; Fflag = true; &#125; &#125; else if(temp.gender == 'M') &#123; if(Lowest(temp, Mlowest)) &#123; Mlowest = temp; Mflag = true; &#125; &#125; &#125; if(!Fflag &amp;&amp; !Mflag) &#123; printf("Absent\nAbsent\nNA\n"); &#125; else if(Fflag &amp;&amp; !Mflag) &#123; printf("%s %s\nAbsent\nNA\n", Fhighest.name, Fhighest.id); &#125; else if(!Fflag &amp;&amp; Mflag) &#123; printf("Absent\n%s %s\nNA\n", Mlowest.name, Mlowest.id); &#125; else &#123; printf("%s %s\n%s %s\n%d\n", Fhighest.name, Fhighest.id, Mlowest.name, Mlowest.id, Fhighest.grade - Mlowest.grade); &#125; return 0;&#125;void Init() &#123; Fhighest.grade = -1; Mlowest.grade = 100;&#125;bool Highest(student a, student b) &#123; return a.grade &gt;= b.grade;&#125;bool Lowest(student a, student b) &#123; return a.grade &lt;= b.grade;&#125; 1037 Magic CouponAnalysisè¿™é“é¢˜è€ƒå¯Ÿè´ªå¿ƒç®—æ³•ï¼Œé¢˜ç›®è¦æ±‚è¾“å‡ºå¯ä»¥å¾—åˆ°çš„æœ€å¤§é’±æ•°ã€‚æ³¨æ„è¿™æ®µè¯ï¼šprint in a line the maximum amount of money you can get backçš„è¡¨è¿°ï¼Œæ‰€ä»¥åªéœ€è¦å¾—åˆ°èƒ½å¾—åˆ°çš„æœ€å¤§å€¼å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦ç»Ÿè®¡è´Ÿæ•°çš„æƒ…å†µã€‚è‹¥åªç»Ÿè®¡ä¸€å¼ åˆ¸ä¹˜ä»¥ä¸€ä»¶å•†å“ä»·æ ¼çš„ç»“æžœä¸ºæ­£æ•°çš„æƒ…å†µï¼Œå°±åˆ†ä¸ºä¸¤ç§ï¼š åˆ¸å€¼ä¸ºæ­£ï¼Œå•†å“ä»·æ ¼ä¸ºæ­£ï¼Œé¢å€¼æœ€å¤§çš„åˆ¸éœ€è¦ä¹˜ä»¥ä»·æ ¼æœ€é«˜çš„å•†å“ï¼Œå°±èƒ½å¾—åˆ°æœ€å¤§çš„ç»“æžœ åˆ¸å€¼ä¸ºè´Ÿï¼Œå•†å“ä»·æ ¼ä¸ºè´Ÿï¼Œé¢å€¼æœ€å°ï¼ˆè´Ÿæ•°ï¼‰çš„åˆ¸éœ€è¦ä¹˜ä»¥ä»·æ ¼æœ€ä½Žï¼ˆè´Ÿæ•°ï¼‰çš„å•†å“ï¼Œå°±èƒ½å¾—åˆ°æœ€å¤§çš„ç»“æžœ åˆ©ç”¨ä¸¤ä¸ªæ•°ç»„æ¥åˆ†åˆ«å­˜å‚¨åˆ¸å€¼å’Œå•†å“ä»·æ ¼ï¼ŒæŒ‰ç…§å¤§å°æŽ’åºåŽï¼Œå¼€å§‹ç›¸ä¹˜ï¼Œè®¡ç®—æœ€ç»ˆç»“æžœã€‚æ³¨æ„ï¼Œå‡åºå’Œé™åºä¸å½±å“ç»“æžœï¼Œä½†éœ€è¦ä¸¤ç§æƒ…å†µéœ€è¦åˆ†å¼€å¤„ç†ã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int Nc, Np, coupon[MAXN] = &#123;0&#125;, product[MAXN] = &#123;0&#125;; scanf("%d", &amp;Nc); for(int i = 0; i &lt; Nc; i++) &#123; scanf("%d", &amp;coupon[i]); &#125; scanf("%d", &amp;Np); for(int i = 0; i &lt; Np; i++) &#123; scanf("%d", &amp;product[i]); &#125; sort(coupon, coupon + Nc); sort(product, product + Np); int i = 0, j, ans = 0; while(i &lt; Nc &amp;&amp; i &lt; Np &amp;&amp; coupon[i] &lt; 0 &amp;&amp; product[i] &lt; 0) &#123; ans += coupon[i] * product[i]; i++; &#125; i = Nc - 1; j = Np - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; coupon[i] &gt; 0 &amp;&amp; product[j] &gt; 0) &#123; ans += coupon[i] * product[j]; i--, j--; &#125; printf("%d\n", ans); return 0;&#125; 1038 Recover the Smallest NumberAnalysisé¢˜ç›®ä¼šç»™ä¸€äº›æ•°å­—ï¼Œè¦æ±‚å°†ç»™å®šçš„æ‰€æœ‰æ•°å­—â€œæ‹¼æŽ¥â€èµ·æ¥ï¼Œæœ€ç»ˆå¾—åˆ°ä¸€ä¸ªç»„åˆæ•°ï¼Œè¿™ä¸ªæ•°å­—è¦æ¯”æŒ‰ç…§å…¶ä»–æ–¹å¼ç»„åˆå¾—åˆ°çš„ç»“æžœå°ã€‚ ç”±äºŽä¸èƒ½æ‰“ä¹±ç»™å®šçš„æ¯ä¸ªæ•°å­—çš„æ•°ä½é¡ºåºï¼Œæ‰€ä»¥ä¸€èˆ¬ä¼šæƒ³åˆ°ç›´æŽ¥æŒ‰ç…§å­—å…¸åºæ¯”è¾ƒæ¯ä¸ªæ•°å­—çš„å¤§å°ï¼Œç„¶åŽè®©å°çš„çš„åœ¨å‰é¢ï¼Œå¤§çš„åœ¨åŽé¢ã€‚ä½†è¦æ³¨æ„ï¼Œå¦‚æžœæ•°å­—32, 321ï¼ŒæŒ‰å­—å…¸åºå¤§å°æŽ’åˆ—åŽçš„ç»„åˆæ•°æ˜¯32321ï¼Œæ­¤æ—¶å­˜åœ¨æ›´å°çš„ç»“æžœ32132ï¼Œæ‰€ä»¥ä¸èƒ½å•çº¯çš„æŒ‰ç…§è¿™ç§æ€è·¯è¿›è¡Œã€‚ å¯¹äºŽ32, 321è¿™ä¸¤ä¸ªæ•°å­—è€Œè¨€ï¼ŒæŒ‰ç…§ä¸Šé¢çš„ç»“æžœï¼š32132 &lt; 32321ï¼Œä»Žå­—ç¬¦ä¸²çš„è§’åº¦å‡ºå‘ï¼Œå‡è®¾a = 32, b = 321ï¼Œåˆ™æœ‰ba &lt; abï¼Œè¿™æ ·å°±å¯ä»¥åœ¨ä¸¤ä¸ªæ•°ä¸­æ‰¾å‡ºâ€œæ‹¼æŽ¥â€å‡ºçš„æœ€å°æ•°äº†ã€‚æŒ‰ç…§è¿™ç§æ€è·¯ï¼Œå¯¹æ¯ä¸€ä¸ªæ•°å­—ï¼ˆä»¥å­—ç¬¦ä¸²å½¢å¼å­˜å‚¨ï¼‰éƒ½è¿™æ ·æŽ’åºï¼Œæœ€åŽé€ä¸ªè¾“å‡ºçš„ç»“æžœå°±æ˜¯é¢˜ç›®è¦æ±‚çš„æœ€å°æ•°å­—äº†ã€‚ ç¡®å®šè¦ç”¨å­—ç¬¦ä¸²äº†åŽï¼Œç›´æŽ¥ä½¿ç”¨STLå†…çš„stringç±»å¯ä»¥å¾ˆæ–¹ä¾¿çš„å¯¹å­—ç¬¦ä¸²è¿›è¡Œæ“ä½œã€‚ æ³¨æ„ï¼Œå½“è¾“å…¥çš„å…¨éƒ¨ä¸º0æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤è¾“å‡º0ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;string str[MAXN];bool cmp(string a, string b);int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += str[i]; &#125; while(ans.size() != 0 &amp;&amp; ans[0] == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.size() == 0) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans; &#125; return 0;&#125;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125; 1039 Course List for StudentAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè¯¾ç¨‹æ•°ç›®å’Œæ¯é—¨è¯¾ç¨‹å‚åŠ çš„å­¦ç”Ÿå§“åï¼Œå½“ç”¨å­¦ç”Ÿå§“åæŸ¥æ‰¾æ—¶ï¼Œè¾“å‡ºè¯¥åå­¦ç”Ÿæ‰€æœ‰çš„è¯¾ç¨‹ã€‚ æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œéœ€è¦ä¿å­˜æ¯åå­¦ç”Ÿçš„é€‰è¯¾ä¿¡æ¯ï¼Œè¯¾ç¨‹éƒ½æ˜¯ç”¨æ•°å­—ä»£æ›¿çš„ï¼Œæ‰€ä»¥ä½¿ç”¨æ•°ç»„å°±å¯ä»¥æ»¡è¶³éœ€æ±‚ã€‚ç”±äºŽéœ€è¦æŒ‰åºè¾“å‡ºæ¯åå­¦ç”Ÿçš„è¯¾ç¨‹ç¼–å·ï¼Œæ‰€ä»¥éœ€è¦å¯¹æ¯åå­¦ç”Ÿçš„è¯¾ç¨‹ç¼–å·è¿›è¡ŒæŽ’åºï¼›å¹¶ä¸”ï¼Œè¿˜éœ€è¦å…ˆè¾“å‡ºè¯¥åå­¦ç”Ÿé€‰è¯¾çš„æ€»æ•°ã€‚ç»¼åˆè€ƒè™‘åŽï¼Œä½¿ç”¨vectoræ¥ä¿å­˜æ•°æ®æ¯”è¾ƒåˆé€‚ã€‚å¦å¤–ä¸ºäº†ä¾¿äºŽæŸ¥æ‰¾ï¼Œé‡‡ç”¨æ•£åˆ—çš„æ€æƒ³ï¼Œå°†å­¦ç”Ÿçš„å§“åè½¬æ¢ä¸ºæ•°å­—ï¼Œä½œä¸ºä¸‹æ ‡æ¥ä¿å­˜æ•°æ®ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010;const int M = 26 * 26 * 26 * 10 + 1;vector&lt;int&gt; selectCourse[M];int getID(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) &#123; id = id * 26 + (name[i] - 'A'); &#125; id = id * 10 + (name[3] - '0'); return id;&#125;int main(int argc, char const *argv[]) &#123; char name[5]; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; int course, x; scanf("%d %d", &amp;course, &amp;x); for(int j = 0; j &lt; x; j++) &#123; scanf("%s", name); int id = getID(name); selectCourse[id].push_back(course); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%s", name); int id = getID(name); sort(selectCourse[id].begin(), selectCourse[id].end()); printf("%s %d", name, selectCourse[id].size()); for(int j = 0; j &lt; selectCourse[id].size(); j++) &#123; printf(" %d", selectCourse[id][j]); &#125; putchar('\n'); &#125; return 0;&#125; 1040 Longest Symmetric StringAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºå…¶ä¸­çš„æœ€é•¿å›žæ–‡å­ä¸²ã€‚æ­¤é¢˜å¹¶æ²¡æœ‰è®¾ç½®è¶…æ—¶æµ‹è¯•ç‚¹ï¼Œç›´æŽ¥ä½¿ç”¨æš´åŠ›è§£æ³•å¯ä»¥è¿‡ã€‚ä¸è¿‡ï¼Œè¿™ç±»æœ€é•¿å…¬å…±å­ä¸²ï¼ˆLongest Palindromic Substringï¼‰çš„é¢˜ç›®ï¼Œè¿˜æœ‰å¦å¤–ä¸€ç§æ€è·¯â€”â€”åŠ¨æ€è§„åˆ’ã€‚ CodeViolent Solution123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;bool palindrome(char *s1, char *s2) &#123; bool flag = true; for(; s1 &lt; s2; s1++, s2--) &#123; if(*s1 != *s2) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main(int argc, char const *argv[]) &#123; char str[maxn]; fgets(str, maxn, stdin); char *p1, *p2; int max_len = 0, temp; for(p1 = str; *p1 != '\0'; p1++) &#123; for(p2 = p1 + 1; *p2 != '\0'; p2++) &#123; if(*p1 == *p2) &#123; temp = p2 - p1; if(temp &lt;= max_len) continue; else if(palindrome(p1, p2)) max_len = temp; &#125; &#125; &#125; printf("%d", max_len + 1); return 0;&#125; DP123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;char str[maxn];int dp[maxn][maxn];int main(int argc, char const *argv[]) &#123; fgets(str, maxn, stdin); int len = strlen(str), ans = 1; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; len; i++) &#123; dp[i][i] = 1; if(i &lt; len - 1) &#123; if(str[i] == str[i + 1]) &#123; dp[i][i + 1] = 1; ans = 2; &#125; &#125; &#125; for(int l = 3; l &lt;= len; l++) &#123; for(int i = 0; i + l - 1 &lt; len; i++) &#123; int j = i + l - 1; if(str[i] == str[j] &amp;&amp; dp[i + 1][j - 1] == 1) &#123; dp[i][j] = 1; ans = l; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 Be UniqueAnalysisæ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œæœ€å…ˆçŒœåˆ°åªå‡ºçŽ°ä¸€æ¬¡çš„æ•°å­—å°±èµ¢äº†ï¼Œæ‰€ä»¥å¾—å…ˆæŒ‰ç…§é¡ºåºè¯»å…¥æ¯ä¸ªæ•°ï¼ŒåŒæ—¶ç»Ÿè®¡æ¯ä¸ªæ•°å­—çš„å‡ºçŽ°æ¬¡æ•°ã€‚ç„¶åŽå†æŒ‰ç…§è¾“å…¥é¡ºåºï¼Œæ£€æŸ¥æ¯ä¸ªæ•°å­—çš„å‡ºçŽ°æ¬¡æ•°ï¼Œè‹¥å‡ºçŽ°ä¸€æ¬¡å³ä¸ºèµ¢çš„é‚£ä¸ªæ•°å­—ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int N, Num[MAXN] = &#123;0&#125;, times[MAXN] = &#123;0&#125;; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Num[i]); times[Num[i]]++; &#125; int i; for(i = 0; i &lt; N; i++) &#123; if(times[Num[i]] == 1) &#123; printf("%d", Num[i]); break; &#125; &#125; if(i == N) &#123; printf("None"); &#125; return 0;&#125; 1042 Shuffling MachineAnalysisæ ¹æ®é¢˜ç›®çš„ä¾‹å­ï¼Œè¯»æ‡‚é¢˜ç›®ï¼Œæ³¨æ„ä»…åœ¨ä¸€ä¸ªæ•°ç»„å†…äº¤æ¢å…ƒç´ ä¼š WA ï¼Œè¦ç”¨ä¸¤ä¸ªæ•°ç»„è¿›è¡Œå€’æ¢æ‰èƒ½å¾—åˆ°æ­£ç¡®çš„ç»“æžœã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;char playcards[55][5] = &#123; " ", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "J1", "J2",&#125;;int main() &#123; int k, arr[55], brr[55], order[55], flag = 1; cin &gt;&gt; k; for(int i = 1; i &lt;= 54; i++) &#123; cin &gt;&gt; order[i]; brr[i] = i; &#125; while(k--) &#123; if(flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; arr[order[i]] = brr[i]; &#125; flag = 0; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; brr[order[i]] = arr[i]; &#125; flag = 1; &#125; &#125; if(!flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[arr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[brr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; 1043 Is It a Binary Search TreeAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int data; node *left, *right; &#125;;void insert(node *&amp;root, int data) &#123; if(root == NULL) &#123; root = new node; root-&gt;data = data; root-&gt;left = root-&gt;right = NULL; return; &#125; if(data &lt; root-&gt;data) insert(root-&gt;left, data); else insert(root-&gt;right, data);&#125;void preorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preorder(root-&gt;left, vi); preorder(root-&gt;right, vi);&#125;void preordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preordermirror(root-&gt;right, vi); preordermirror(root-&gt;left, vi);&#125;void postorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postorder(root-&gt;left, vi); postorder(root-&gt;right, vi); vi.push_back(root-&gt;data);&#125;void postordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postordermirror(root-&gt;right, vi); postordermirror(root-&gt;left, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, preM, post, postM;int main(int argc, char const *argv[]) &#123; int n, data; node *root = NULL; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); origin.push_back(data); insert(root, data); &#125; preorder(root, pre); preordermirror(root, preM); postorder(root, post); postordermirror(root, postM); if(origin == pre) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if(i &lt; post.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else if(origin == preM) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; postM.size(); i++) &#123; cout &lt;&lt; postM[i]; if(i &lt; postM.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else &#123; cout &lt;&lt; "NO\n"; &#125; return 0;&#125; 1044 Shopping in MarsAnalysiså…ˆåˆ†æžé¢˜ç›®è¾“å…¥ï¼Œç¬¬ä¸€è¡Œç»™å®šä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªæ•°å­—ä»£è¡¨ä¸€æ¡â€œé“¾â€ä¸Šé’»çŸ³çš„æ•°é‡ï¼Œç¬¬äºŒä¸ªæ•°å­—åˆ™ä»£è¡¨éœ€è¦æ”¯ä»˜çš„é’±ï¼›ç¬¬äºŒè¡Œä¾æ¬¡ç»™å‡ºâ€œé“¾â€ä¸Šæ¯é¢—é’»çŸ³çš„å¯¹åº”çš„ä»·å€¼ï¼ˆç”¨äºŽæ”¯ä»˜ï¼‰ã€‚ ç„¶åŽï¼Œé¢˜ç›®è¦æ±‚ä»Žè¿™æ¡â€œé“¾â€ä¸­æ‰¾å‡ºèƒ½åˆšå¥½ç”¨äºŽæ”¯ä»˜ï¼ˆé’»çŸ³çš„ä»·å€¼å’Œä¸Žå¾…æ”¯ä»˜çš„é’±ç›¸ç­‰ï¼‰çš„â€œé’»çŸ³åºåˆ—â€ï¼Œå½“ç„¶ï¼Œè‹¥æ˜¯æ²¡æœ‰å®Œå…¨ç›¸ç­‰çš„æƒ…å†µï¼Œæ‰¾å‡ºåˆšå¥½å¤§äºŽå¾…æ”¯ä»˜çš„é’±çš„é’»çŸ³åºåˆ—ï¼Œä¹Ÿæ˜¯å¯ä»¥çš„ã€‚ å°†æœ¬ä½“çš„é¢˜æ„æŠ½è±¡å‡ºæ¥å°±æ˜¯ï¼Œç»™å®šä¸€ä¸ªåºåˆ—ï¼Œæ‰¾å‡ºè¿™ä¸ªåºåˆ—ä¸­è¿žç»­å­åºåˆ—å’Œåˆšå¥½å¤§äºŽæˆ–ç­‰äºŽç»™å®šæ•°å­—çš„æ‰€æœ‰å­åºåˆ—ï¼ˆå¦‚æžœæœ‰ç›¸ç­‰çš„æƒ…å†µï¼Œå°±ä¸éœ€è¦å†æ‰¾å¤§äºŽçš„æƒ…å†µï¼‰ã€‚ æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯ä»¥ä½¿ç”¨ä¸€ä¸ªsumæ•°ç»„æ¥ä¿å­˜è¿žç»­çš„å­åºåˆ—å’Œï¼ˆæ¯æ¬¡ç´¯åŠ å³å¯ï¼‰ï¼Œè¿™æ ·åœ¨iå’Œjä¹‹é—´çš„å­åºåˆ—å’Œå°±æ˜¯sum[j] - sum[i - 1]ï¼Œè¿™ä¸ªæ€æƒ³ä¸Ž1046æ˜¯ä¸€è‡´çš„ã€‚è¿™æ ·ï¼Œè¦åšçš„äº‹æƒ…å°±æ˜¯ä»Žsumè¿™ä¸ªæ•°ç»„ä¸­æ‰¾å‡ºæ»¡è¶³æ¡ä»¶çš„åºåˆ—äº†ã€‚åŒæ—¶æ³¨æ„åˆ°ï¼Œç”±äºŽsumæ•°ç»„æ˜¯ç´¯åŠ å¾—å‡ºçš„ï¼Œæ‰€ä»¥ä¸€å®šæ˜¯ä¸¥æ ¼é€’å¢žçš„ï¼Œä¹Ÿå°±å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥æ‰¾è¿™ä¸ªå€¼ã€‚ æ³¨æ„é¢˜ç›®çš„æ¡ä»¶ï¼šIt is guaranteed that the total value of diamonds is sufficient to pay the given amount.ï¼Œè¯´æ˜Žè‚¯å®šä¼šæœ‰è§£ï¼Œé‚£ä¹ˆå¯¹åº”çš„ä¹Ÿå°±åªæœ‰ä¸¤ç§æƒ…å†µï¼š èƒ½æ‰¾åˆ°ç›¸ç­‰çš„åºåˆ—ï¼Œæ­¤æ—¶ç”±äºŽåºåˆ—æœ¬èº«å°±æ˜¯ä¸¥æ ¼é€’å¢žçš„ åªèƒ½æ‰¾åˆ°åˆšå¥½å¤§äºŽç»™å®šå€¼çš„åºåˆ—ï¼Œæ­¤æ—¶éœ€è¦ç”¨ä¸€ä¸ªå˜é‡nearSæ¥ä¿å­˜åˆšå¥½å¤§äºŽç»™å®šå€¼çš„è¿žç»­å­åºåˆ—å’Œ æ‰¾åˆ°åˆç†çš„å€¼åŽï¼ŒæŒ‰ç…§è¿™ä¸ªå€¼è¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int sum[MAXN];int n, S, nearS = 100000000 + 10;int UpperBound(int L, int R, int x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;S); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;sum[i]); sum[i] += sum[i - 1]; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + S); if(sum[j - 1] - sum[i - 1] == S) &#123; nearS = S; break; &#125; else if(j &lt;= n &amp;&amp; sum[j] - sum[i - 1] &lt; nearS) &#123; nearS = sum[j] - sum[i - 1]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + nearS); if(sum[j - 1] - sum[i - 1] == nearS) &#123; printf("%d-%d\n", i, j - 1); &#125; &#125; return 0;&#125;int UpperBound(int L, int R, int x) &#123; int left = L, right = R, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(sum[mid] &gt; x) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 1045 Favorite Color StripeAnalysisé¢˜ç›®å¤§æ„ï¼šç”¨ä¸åŒçš„æ•°å­—è¡¨ç¤ºä¸åŒçš„é¢œè‰²ï¼Œä¸€å…±æœ‰ 220 ç§é¢œè‰²ï¼Œç»™å®šä¸€ä¸²æ•°å­—åºåˆ—ï¼Œä½œä¸º Eva å–œæ¬¢çš„é¢œè‰²ç§ç±»ï¼ˆè¶Šé åŽè¶Šå–œæ¬¢ï¼‰ï¼Œç„¶åŽåœ¨ç»™å®šä¸€ä¸²æ•°å­—åºåˆ—ã€‚çŽ°åœ¨ä»Žä¸­æŒ‘å‡º Eva å–œæ¬¢çš„æ‰€æœ‰æ•°å­—ï¼Œå¹¶ä¸”è¦æ±‚æŒ‰ç…§ç»™å®šçš„é¡ºåºè¿›è¡ŒæŽ’åˆ—ï¼Œæ±‚å‡ºè¿™ä¸ªæœ€å¤§çš„é•¿åº¦ã€‚ å¦‚æžœç›´æŽ¥ä½¿ç”¨æš´åŠ›è§£æ³•ï¼Œå®šä¼šè¶…æ—¶ï¼Œè¦æƒ³å®Œç¾Žè§£å†³è¿™ä¸ªé—®é¢˜ï¼Œæ€è€ƒçš„æ–¹å‘æœ‰ä¸¤ä¸ªï¼Œä½†éƒ½åŒ…å«äº†åŠ¨æ€è§„åˆ’ï¼ˆDynamic Programmingï¼‰çš„æ€æƒ³ï¼š ä»Žæœ€é•¿éžé€’å‡åºåˆ—çš„è§’åº¦æ€è€ƒ ä»Žæœ€é•¿å…¬å…±å­ä¸²çš„è§’åº¦æ€è€ƒ CodeLIS123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int stripe[maxn], hashTable[maxc], dp[maxn];int main(int argc, char const *argv[]) &#123; int n, m, x; cin &gt;&gt; n &gt;&gt; m; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; hashTable[x] = i; &#125; int l, num = 0; cin &gt;&gt; l; for(int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; stripe[num++] = hashTable[x]; &#125; int ans = -1; for(int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for(int j = 0; j &lt; i; j++) &#123; if(stripe[j] &lt;= stripe[i] &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; &#125; &#125; ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans; return 0;&#125; LCS123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int A[maxc], B[maxn], dp[maxc][maxn];int main(int argc, char const *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; A[i]; &#125; int l; cin &gt;&gt; l; for(int i = 1; i &lt;= l; i++) &#123; cin &gt;&gt; B[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; dp[i][0] = 0; &#125; for(int j = 1; j &lt;= l; j++) &#123; dp[0][j] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= l; j++) &#123; int Max = max(dp[i - 1][j], dp[i][j - 1]); if(A[i] == B[j]) &#123; dp[i][j] = Max + 1; &#125; else &#123; dp[i][j] = Max; &#125; &#125; &#125; cout &lt;&lt; dp[m][l]; return 0;&#125; 1046 Shortest DistanceAnalysisé¢˜ç›®æ„æ€å¾ˆæ˜Žç¡®ï¼Œç»™ä½ ä¸€ä¸ªâ€œçŽ¯â€å½¢åœ°å›¾ï¼Œé—®ä½ ä»Žè¿™é‡Œåˆ°é‚£é‡Œæ€Žä¹ˆèµ°æœ€è¿‘ã€‚æ ¹æ®é¢˜ç›®æ„æ€ï¼Œä¸€èˆ¬éƒ½æœ‰ä¸¤ç§èµ°æ³•ï¼Œä¸€ç§é¡ºç€çŽ¯èµ°ï¼Œä¸€ç§é€†ç€çŽ¯èµ°ï¼Œæ‰¾å‡ºäºŒè€…çš„æœ€å°å€¼å³å¯ã€‚ ä¸€èˆ¬è€Œè¨€ï¼Œæˆ‘ä»¬åˆ†åˆ«æ‰¾å‡ºå…¶ä¸­ä¸¤æ¬¡çš„å€¼ï¼Œè¿›è¡Œæ¯”è¾ƒåŽè¾“å‡ºæœ€å°å€¼å³å¯ã€‚ä¸è¿‡ç”±äºŽåœ°åæ˜¯æŒ‰ç…§æ•°å­—ç»™å‡ºçš„ï¼Œå¯èƒ½ä¼šå‡ºçŽ°èµ·å§‹ç‚¹çš„æ•°å­—å¤§äºŽç»ˆç‚¹çš„æƒ…å†µï¼Œæ­¤æ—¶æœ€å¥½äº¤æ¢äºŒè€…çš„å€¼ï¼Œæˆ–è€…åˆ†æƒ…å†µè®¨è®ºã€‚ å¦å¤–ï¼Œè¿˜å¯ä»¥å‘çŽ°ï¼Œå¦‚æžœæ±‚å‡ºäº†ä¸€ç§èµ°æ³•ï¼Œé‚£ä¹ˆæŒ‰ç…§çŽ¯å½¢åœ°å›¾çš„ç‰¹ç‚¹ï¼Œåˆ©ç”¨æ€»è·ç¦»å‡åŽ»æ±‚å¾—çš„ä¸å°±å¾—åˆ°å¦ä¸€ç§èµ°æ³•çš„è·ç¦»äº†å—ï¼Ÿ æŠŠæ¡ä½ä¸Šé¢çš„ç‚¹åŽï¼Œå¯ä»¥é€šè¿‡0å’Œ1ä¸¤ä¸ªæµ‹è¯•ç‚¹äº†ï¼Œç¬¬ä¸‰ä¸ªæµ‹è¯•ç‚¹ä¼šå› ä¸ºè¶…æ—¶æ— æ³•é€šè¿‡ã€‚ åœ¨ä»”ç»†åˆ†æžä¸€ä¸‹ï¼Œå¦‚æžœä¸€å¼€å§‹ç”¨ä¸€ä¸ªæ•°ç»„Dis[MAXN]ï¼ŒæŒ‰ç…§é¡ºåºè¡¨ç¤º1å·åœ°ç‚¹åˆ°è¾¾å…¶ä»–åœ°ç‚¹çš„è·ç¦»ï¼Œé‚£ä¹ˆå¯¹äºŽæ¯ä¸€æ¬¡æŸ¥è¯¢çš„startå’Œendï¼Œå…¶è·ç¦»å°±æ˜¯Dis[end - 1] - Dis[start - 1]ã€‚ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œå¯ä»¥å¾—åˆ°æ•°ç»„ï¼ˆä¸‹æ ‡ä»Ž1å¼€å§‹ï¼‰Dis[6] = {0, 1, 3, 7, 21, 30}ï¼Œæ­¤æ—¶å¦‚æžœè¦è®¡ç®—5åˆ°2çš„è·ç¦»ï¼Œæ ¹æ®æ€è·¯å°±æ˜¯ï¼šDis[5 - 1] - Dist[2 - 1] = 21 - 1 = 20ï¼Œè¿™å°±æ˜¯æŒ‰é¡ºåºæ–¹å‘ä»Ž2åˆ°5çš„è·ç¦»ã€‚ æ­¤æ³•ææ€–ä¹‹æžåœ¨äºŽåŽŸæœ¬æ—¶é—´å¤æ‚åº¦ä¸º $O(n)$ çš„æŸ¥æ‰¾ä¸€ä¸‹å­å°±å˜ä¸º $O(1)$ äº†ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int M, N, Exits[MAXN] = &#123;0&#125;, Dis[MAXN], Sum_D = 0, src, dst; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Exits[i]); Sum_D += Exits[i]; Dis[i] = Sum_D; &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d %d", &amp;src, &amp;dst); if(src &gt; dst) &#123; swap(src, dst); &#125; int temp = Dis[dst - 1] - Dis[src - 1]; printf("%d\n", temp &lt; (Sum_D - temp) ? temp : (Sum_D - temp)); &#125; return 0;&#125; 1047 Student List for CourseAnalysisæ­¤é¢˜ä¸Ž1039çš„é¢˜ç›®èƒŒæ™¯å®Œå…¨ä¸€æ ·ï¼Œè¾“å…¥ä¸Žè¾“å‡ºæ­£å¥½ç›¸åï¼Œæ€è·¯ä¹Ÿæ˜¯ç±»ä¼¼çš„ã€‚åªæ˜¯æœ¬é¢˜ï¼Œä¸éœ€è¦åœ¨åˆ©ç”¨æ•£åˆ—äº†ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40010;const int maxc = 2510;char name[maxn][5];vector&lt;int&gt; course[maxc];bool cmp(int a, int b) &#123; return strcmp(name[a], name[b]) &lt; 0;&#125;int main(int argc, char const *argv[]) &#123; int n, k, c, courseID; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name[i], &amp;c); for(int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;courseID); course[courseID].push_back(i); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; printf("%d %d\n", i, course[i].size()); sort(course[i].begin(), course[i].end(), cmp); for(int j = 0; j &lt; course[i].size(); j++) &#123; printf("%s\n", name[course[i][j]]); &#125; &#125; return 0;&#125; 1048 Find CoinsAnalysisç»™å®šç¡¬å¸ç§ç±»å’Œé¢å€¼ï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚è¾“å‡ºå’Œä¸Žé¢˜ç›®ç›¸ç­‰ä¸¤æžšç¡¬å¸ï¼Œè¦æ±‚V1çš„é¢å€¼å°äºŽç­‰äºŽV2ã€‚åœ¨è¾“å…¥æ—¶ï¼Œåˆ©ç”¨æ•£åˆ—çš„æ€è·¯ï¼Œå…ˆå°†æ¯ä¸€æžšç¡¬å¸çš„ä¸ªæ•°ç»Ÿè®¡ä¸‹æ¥ã€‚ç„¶åŽï¼Œåˆ©ç”¨sortå°†é¢å€¼æŒ‰å‡åºæŽ’åºï¼Œè¿™æ ·æ–¹ä¾¿æŸ¥æ‰¾ã€‚è¾“å‡ºæ—¶æ³¨æ„ä»¥ä¸‹å‡ ç‚¹ï¼š V1å’ŒV2ç›¸ç­‰æ—¶ï¼Œè¦åˆ¤æ–­è¿™æžšç¡¬å¸æ—¶å€™æœ‰ä¸¤æžš å½“V1å’ŒV2ç›¸ç­‰æ—¶ï¼Œå°±å·²ç»æ˜¯é¢˜ç›®è¦æ±‚çš„æœ€åŽä¸€ç§æƒ…å†µäº†ï¼Œè‹¥è¿™ç§æƒ…å†µéƒ½ä¸åˆæ¡ä»¶ï¼Œå°±æ²¡å¿…è¦å†ç»§ç»­æŸ¥æ‰¾ä¸‹åŽ»äº†ï¼Œæ‰€ä»¥ä½¿ç”¨ä¸€ä¸ªæ ‡è¯†flagæ¥ååŠ©è¾“å‡º æ³¨æ„æ‰€ä½¿ç”¨æ•°ç»„çš„ä¸‹æ ‡ï¼Œä»¥å…è°ƒç”¨sortæ—¶å‡ºé”™ åªè¦V1æœ€å°çš„é‚£ä¸€ç»„å°±è¡Œäº†ï¼Œæ‰€ä»¥è¦åœ¨å¾ªçŽ¯å†…è°ƒç”¨break Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int main(int argc, char const *argv[]) &#123; int N, M, coins[MAXN]; scanf("%d %d", &amp;N, &amp;M); int value[MAXN] = &#123;0&#125;; for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;coins[i]); value[coins[i]]++; &#125; sort(coins + 1, coins + N + 1); int i, v1, v2; bool flag = false; for(i = 1; i &lt;= N; i++) &#123; v1 = coins[i]; v2 = M - v1; if(value[v1] &amp;&amp; value[v2]) &#123; if(v1 == v2 &amp;&amp; value[v1] != 2) &#123; break; &#125; printf("%d %d", v1, v2); flag = true; break; &#125; &#125; if(!flag) &#123; printf("No Solution"); &#125; return 0;&#125; 1050 String SubtractionAnalysisåˆ©ç”¨æ•£åˆ—çš„æ€æƒ³æ¥å¤„ç†ï¼Œå…ˆéåŽ†ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ç»Ÿè®¡å…¶ä¸­æ‰€æœ‰å­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼ˆä¹Ÿå¯ä»¥åªç”¨trueæˆ–falseæ¥åŒºåˆ†ï¼‰ï¼Œç„¶åŽéåŽ†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ï¼Œå°†åŒæ—¶å‡ºçŽ°åœ¨ä¸¤ä¸ªå­—ç¬¦ä¸²å†…çš„å­—ç¬¦çš„æ¬¡æ•°æ ‡è®°ä¸º0ï¼Œç„¶åŽæŒ‰ç…§ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²çš„é¡ºåºï¼Œè¾“å‡ºæ ‡è®°ä¸æ˜¯0çš„å­—ç¬¦å³å¯ã€‚ Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int times[128] = &#123;0&#125;; char *p = str2; while(*p != '\0') &#123; times[*p++] = 1; &#125; p = str1; while(*p != '\0') &#123; if(!times[*p]) &#123; putchar(*p); &#125; p++; &#125; return 0;&#125; 1051 Pop SequenceAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ ˆçš„å®¹é‡ã€å‡ºæˆ˜åºåˆ—é•¿åº¦å’Œå¯èƒ½çš„å‡ºæ ˆåºåˆ—ï¼Œåˆ¤æ–­åœ¨å½“å‰æ ˆçš„é•¿åº¦ä¸‹ï¼Œå‡ºæ ˆåºåˆ—æ˜¯å¦åˆæ³•ï¼Œè‹¥æ˜¯ï¼Œè¾“å‡ºYESï¼Œåä¹‹ï¼Œè¾“å‡ºNOã€‚ æŒ‰ç…§é¢˜ç›®çš„è¦æ±‚æ¨¡æ‹Ÿæ ˆçš„æ“ä½œå³å¯ï¼Œä½¿ç”¨ C++ çš„stackå®¹å™¨å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1010;int arr[maxn] = &#123;0&#125;;stack&lt;int&gt; st;int main(int argc, char const *argv[]) &#123; int m, n, t; scanf("%d %d %d", &amp;m, &amp;n, &amp;t); while(t--) &#123; while(!st.empty()) &#123; //clear stack st.pop(); &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int current = 1; bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; st.push(i); if(st.size() &gt; m) &#123; flag = false; break; &#125; while(!st.empty() &amp;&amp; st.top() == arr[current]) &#123; st.pop(); current++; &#125; &#125; if(st.empty() == true &amp;&amp; flag == true) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125; 1052 Linked List SortingAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯å±žäºŽé“¾è¡¨çš„åº”ç”¨ï¼Œå®žé™…æ˜¯æ¨¡æ‹Ÿé“¾è¡¨çš„æ“ä½œï¼Œä½¿ç”¨é™æ€é“¾è¡¨æ¨¡æ‹Ÿè¾ƒä¸ºæ–¹ä¾¿ã€‚ é™æ€é“¾è¡¨éœ€è¦å€ŸåŠ©æ•£åˆ—çš„æ¦‚å¿µï¼Œå€ŸåŠ©ç»“æž„æ•°ç»„ï¼Œä½¿ç”¨é¢˜ç›®ç»™å®šçš„åœ°å€å¯¹åº”æ•°ç»„çš„ä¸‹æ ‡ï¼Œå¯ä»¥è¾ƒä¸ºæ–¹ä¾¿çš„å­˜å‚¨ç»“ç‚¹å€¼å’Œä¸‹ä¸€ä¸ªå…ƒç´ çš„åœ°å€ã€‚ é¢˜ç›®è¦æ±‚çš„æŽ’åºå¯ä»¥ä½¿ç”¨sortå‡½æ•°æ¥å®Œæˆï¼Œæ­¤æ—¶è¦æ³¨æ„ç”±äºŽé¢˜ç›®å¯èƒ½ä¼šè¾“å…¥æ— æ•ˆç»“ç‚¹ï¼Œæ‰€ä»¥éœ€è¦å¢žåŠ ä¸€ä¸ªflagæ¥åˆ¤æ–­æ˜¯å¦å±žäºŽæ— æ•ˆç»“ç‚¹ï¼Œè¿™æ ·sortå‡½æ•°æ‰èƒ½å°†æœ‰æ•ˆç»“ç‚¹æŒ‰åºæŽ’å¥½ï¼Œå¹¶å°†æ— æ•ˆç»“ç‚¹æŽ’åœ¨æœ€åŽä¸€ä¸ªæœ‰æ•ˆç»“ç‚¹çš„åŽé¢ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct Node &#123; int address, data, next; bool flag;&#125; node[maxn];bool cmp(Node a, Node b) &#123; if(a.flag == false || b.flag == false) &#123; return a.flag &gt; b.flag; &#125; else &#123; return a.data &lt; b.data; &#125;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int n, begin, address; scanf("%d %d", &amp;n, &amp;begin); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int count = 0, p = begin; while(p != -1) &#123; node[p].flag = true; count++; p = node[p].next; &#125; if(count == 0) &#123; printf("0 -1"); &#125; else &#123; sort(node, node + maxn, cmp); printf("%d %05d\n", count, node[0].address); for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) &#123; printf("%05d %d %05d\n", node[i].address, node[i].data, node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", node[i].address, node[i].data); &#125; &#125; &#125; return 0;&#125; 1053 Path of Equal WeightAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1054 The Dominant ColorAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªçŸ©é˜µï¼Œæ‰¾å‡ºå…¶ä¸­è¶…è¿‡çŸ©é˜µä¸€åŠå…ƒç´ ä¸ªæ•°çš„å€¼ã€‚é¢˜ç›®ä¿è¯æµ‹è¯•æ ·ä¾‹ä¸­ä¼šæœ‰ç­”æ¡ˆï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ‰ä¸€åŠçš„çŸ©é˜µå…ƒç´ éƒ½æ˜¯åŒä¸€ä¸ªæ•°å­—ï¼Œé‚£ä¹ˆæ¯«æ— ç–‘é—®ï¼Œè¿™ä¸ªå…ƒç´ çš„å‡ºçŽ°æ¬¡æ•°ä¸€å®šæ˜¯è¿™ä¸ªçŸ©é˜µæ‰€æœ‰å…ƒç´ å‡ºçŽ°æ¬¡æ•°çš„æœ€å¤§å€¼ï¼Œæ‰€ä»¥ç›´æŽ¥æŸ¥æ‰¾æœ€å¤§å€¼å³å¯ã€‚ ç”±äºŽåƒç´ ç‚¹æ˜¯ç”±0-24ä½æ•°å­—å­—ç¬¦ç»„æˆï¼Œæ‰€ä»¥éœ€è¦å°†çŸ©é˜µå†…å…ƒç´ å½“ä½œå­—ç¬¦ä¸²å¯¹å¾…ï¼ŒåŒæ—¶éœ€è¦å»ºç«‹ä¸Žæ¬¡æ•°çš„å”¯ä¸€æ˜ å°„ï¼Œä½¿ç”¨ C++ çš„mapå®¹å™¨å¯ä»¥å¾ˆæ–¹ä¾¿çš„å®Œæˆè¿™ä¸ªæ“ä½œã€‚ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; color;int main(int argc, char const *argv[]) &#123; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; temp = n * m; getchar(); while(temp--) &#123; string s; cin &gt;&gt; s; color[s]++; &#125; temp = n * m; map&lt;string, int&gt;::iterator max = color.begin(); map&lt;string, int&gt;::iterator it = color.begin(); for(; it != color.end(); it++) &#123; if(it-&gt;second &gt; max-&gt;second) &#123; max = it; &#125; &#125; cout &lt;&lt; max-&gt;first; return 0;&#125; 1055 The Worldâ€™s RichestAnalysiså…ˆæŒ‰ç…§é¢˜ç›®è¦æ±‚æŽ’å¥½åºï¼Œç„¶åŽæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å¹´é¾„åŒºé—´è¿›è¡Œè¾“å‡ºï¼Œæ³¨æ„æ²¡æœ‰ç¬¦åˆçš„è¾“å‡ºæ—¶ï¼Œéœ€è¦è¾“å‡ºNoneã€‚ æ­¤æ—¶ï¼Œè€ƒè™‘åˆ°é¢˜ç›®ç»™çš„æ¡ä»¶$M (\le 100)$ï¼Œè¯´æ˜Žå¯¹äºŽåŒä¸€ä¸ªå¹´é¾„çš„æ•°æ®ï¼Œæœ€å¤šåªè¾“å‡º100é¡¹ã€‚æ‰€ä»¥å¯ä»¥æ–°å»ºä¸€ä¸ªæ•°ç»„ï¼Œç„¶åŽæŒ‰ç…§æŽ’å¥½åºçš„åºåˆ—ï¼Œé¡ºåºä¿å­˜æ¯ä¸ªå¹´é¾„çš„æ•°æ®ï¼Œä½†åªä¿å­˜100ä¸ªï¼Œè¿™æ ·åœ¨æŸ¥æ‰¾çš„æ—¶å€™èƒ½æžå¤§çš„èŠ‚çº¦æ—¶é—´ã€‚ å°½ç®¡è¿™é“é¢˜åœ¨ç”²çº§é¢˜åº“å†…çš„æ—¶é—´é™åˆ¶æ˜¯500msï¼Œè€ƒè¯•çš„æ—¶å€™è¯´ä¸å®šå°±æ˜¯200msäº†ï¼Œè¦æ³¨æ„ç”¨æœ€ä¼˜è§£æ³•ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int Age[MAXN] = &#123;0&#125;;struct people&#123; char name[10]; int age, worth;&#125; peo[MAXN], valid[MAXN];bool cmp(people a, people b);int main(int argc, char const *argv[]) &#123; int N, K; scanf("%d %d", &amp;N, &amp;K); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", peo[i].name, &amp;peo[i].age, &amp;peo[i].worth); &#125; sort(peo, peo + N, cmp); int validNum = 0; for(int i = 0; i &lt; N; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; valid[validNum++] = peo[i]; &#125; &#125; int M, Amin, Amax; for(int i = 1; i &lt;= K; i++) &#123; bool flag = false; scanf("%d %d %d", &amp;M, &amp;Amin, &amp;Amax); printf("Case #%d:\n", i); for(int j = 0; j &lt; validNum &amp;&amp; M; j++) &#123; if(Amin &lt;= valid[j].age &amp;&amp; valid[j].age &lt;= Amax) &#123; printf("%s %d %d\n", valid[j].name, valid[j].age, valid[j].worth); M--; flag = true; &#125; &#125; if(!flag) &#123; printf("None\n"); &#125; &#125; return 0;&#125;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return strcmp(a.name, b.name) &lt; 0;&#125; 1056 Mice and RiceAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯ä¸€ä¸ªå«åš Mice and Rice çš„æ¸¸æˆï¼Œæ ¹æ®é¢˜ç›®çš„æè¿°å¯ä»¥çŸ¥é“ï¼Œä½“é‡æ•°å­—æœ€å¤§çš„è€é¼ å°±æ˜¯èƒœåˆ©çš„è€é¼ ï¼Œå¹¶ä¸”åœ¨æœ¬é¢˜ä¸­ï¼Œè€é¼ ä¹‹é—´çš„æ¯”èµ›éœ€è¦åˆ†ç»„è¿›è¡Œï¼Œåˆ†ç»„å¤§å°ä¼šç»™å‡ºã€‚æ³¨æ„all the mice left will be put into the last groupæ˜¯æŒ‡ï¼Œç”±äºŽå¯èƒ½å­˜åœ¨æœ€åŽä¸€ç»„è€é¼ å°‘äºŽåˆ†ç»„å¤§å°çš„æƒ…å†µï¼Œé»˜è®¤å°†å‰©ä½™çš„è€é¼ å…¨éƒ¨åŠ å…¥åˆ°ä¸‹ä¸€è½®æ¯”èµ›ä¸­ã€‚ä¾æ¬¡è¿›è¡Œæ¯ä¸€è½®æ¯”èµ›ï¼Œç›´è‡³æœ€åŽå¾—åˆ°å† å†›è€é¼ ï¼Œå¹¶è¾“å‡ºæ‰€æœ‰è€é¼ çš„æŽ’åã€‚ æŒ‰ç…§é¢˜ç›®çš„æ„æ€ï¼Œé¢˜ç›®ä¸€å¼€å§‹ä¼šç»™å®šè€é¼ æ€»æ•°å’Œåˆ†ç»„å¤§å°ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥å¾—åˆ°è¿™ä¸€è½®çš„åˆ†ç»„æ•°ï¼›åŒç†ï¼Œæ¯ä¸€è½®çš„åˆ†ç»„æ•°éƒ½å¯ä»¥è¿™æ ·å¾—åˆ°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;struct mouse&#123; int weight; int r;&#125; mouse[maxn];int main(int argc, char const *argv[]) &#123; int np, ng, order; scanf("%d %d", &amp;np, &amp;ng); for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;mouse[i].weight); &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;order); q.push(order); &#125; int temp = np, group; while(q.size() != 1) &#123; if(temp % ng == 0) group = temp / ng; else group = temp / ng + 1; for(int i = 0; i &lt; group; i++) &#123; int k = q.front(); for(int j = 0; j &lt; ng; j++) &#123; if(i * ng + j &gt;= temp) break; int front = q.front(); if(mouse[front].weight &gt; mouse[k].weight) &#123; k = front; &#125; mouse[front].r = group + 1; q.pop(); &#125; q.push(k); &#125; temp = group; &#125; mouse[q.front()].r = 1; for(int i = 0; i &lt; np; i++) &#123; printf("%d", mouse[i].r); if(i &lt; np - 1) putchar(' '); &#125; return 0;&#125; 1058 A+B in HogwartsAnalysisé¢˜ç›®æ„æ€å¾ˆç®€å•ï¼Œç»™ä½ ä¸¤ä¸ªåœ¨éœæ ¼æ²ƒèŒ¨æœ¬åœ°ä½¿ç”¨çš„è´§å¸æ•°é‡ï¼ŒåŠ èµ·æ¥å°±å¥½ã€‚å°±è·Ÿç”Ÿæ´»ä¸­$100 + 150 = 250$å—ä¸€æ ·å“ˆã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;struct money&#123; int g, k, s;&#125; A, B, Result;int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;A.g, &amp;A.s, &amp;A.k, &amp;B.g, &amp;B.s, &amp;B.k); Result.g = A.g + B.g; Result.k = A.k + B.k; Result.s = A.s + B.s; if(Result.k &gt;= 29) &#123; Result.s += (Result.k / 29); Result.k %= 29; &#125; if(Result.s &gt;= 17) &#123; Result.g += (Result.s / 17); Result.s %= 17; &#125; printf("%d.%d.%d\n", Result.g, Result.s, Result.k); return 0;&#125; 1059 Prime FactorsAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ­£æ•´æ•°ï¼Œç”¨è´¨æ•°å¯¹å…¶è¿›è¡Œåˆ†è§£ï¼Œä¹Ÿå³è´¨å› å­åˆ†è§£ã€‚ æ—¢ç„¶éœ€è¦ç”¨åˆ°è´¨æ•°ï¼Œä¸Žå…¶ä¸€ä¸ªä¸€ä¸ªçš„åˆ¤æ–­ï¼Œä¸å¦‚ä¸€å¼€å§‹å…ˆå°†ç´ æ•°è¡¨æ‰“å°å¥½ï¼Œæ­¤é¢˜ç»™å®šçš„æ•°ä¸ºlong intï¼Œåˆ™ç´ æ•°è¡¨ä¸º$10^5$å³å¯ã€‚ æŽ¥ç€å®šä¹‰ä¸€ä¸ªç»“æž„ä½“æ•°ç»„ï¼Œä¿å­˜è´¨å› å­å’Œå…¶ä¸ªæ•°ã€‚å¯¹äºŽlong intåž‹çš„æ•°è€Œè¨€ï¼Œ2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29å°±å·²ç»æº¢å‡ºäº†ï¼Œæ‰€ä»¥ç»“æž„ä½“æ•°ç»„çš„å¤§å°å–10ä»¥ä¸Šå³å¯ã€‚ ä»Žå°åˆ°å¤§æžšä¸¾è´¨å› å­ï¼Œå¦‚æžœèƒ½æ•´é™¤ç»™å®šçš„æ•°ï¼Œå°±è¿›å…¥å¾ªçŽ¯ï¼Œè®©è¿™ä¸ªæ•°ä¸æ–­çš„æ•´é™¤å®ƒï¼Œä»Žè€Œè®¡ç®—è¿™ä¸ªè´¨å› å­çš„æ•°ç›®ã€‚æ³¨æ„ï¼Œn = 1æ—¶ï¼Œéœ€è¦ç‰¹åˆ¤è¾“å‡º1=1ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100010;bool isPrime(int n) &#123; if(n &lt;= 1) return false; int sqr = sqrt(n); for(int i = 2; i &lt;= sqr; i++) &#123; if(n % i == 0) return false; &#125; return true;&#125;int prime[maxn], pNum = 0;void filterPrime() &#123; for(int i = 1; i &lt; maxn; i++) &#123; if(isPrime(i) == true) &#123; prime[pNum++] = i; &#125; &#125;&#125;struct factor&#123; int x, cnt;&#125; fac[11];int main(int argc, char const *argv[]) &#123; filterPrime(); int n, num = 0; scanf("%d", &amp;n); if(n == 1) printf("1=1"); else &#123; printf("%d=", n); int sqr = sqrt(n); for(int i = 0; i &lt; pNum &amp;&amp; prime[i] &lt;= sqr; i++) &#123; if(n % prime[i] == 0) &#123; fac[num].x = prime[i]; fac[num].cnt = 0; while(n % prime[i] == 0) &#123; fac[num].cnt++; n /= prime[i]; &#125; num++; &#125; if(n == 1) break; &#125; if(n != 1) &#123; fac[num].x = n; fac[num++].cnt = 1; &#125; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0) putchar('*'); printf("%d", fac[i].x); if(fac[i].cnt &gt; 1) &#123; printf("^%d", fac[i].cnt); &#125; &#125; &#125; return 0;&#125; 1060 Are They EqualAnalysisè¿™é“é¢˜è€ƒå¯Ÿå­—ç¬¦ä¸²å¤„ç†ï¼Œä½¿ç”¨STLå†…çš„stringå®¹å™¨ï¼Œå¹¶è°ƒç”¨å…¶ä¸­çš„ä¸€äº›æ–¹æ³•ï¼Œä¼šååˆ†æ–¹ä¾¿ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string s, int &amp;e);int main(int argc, char const *argv[]) &#123; string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if(s3 == s4 &amp;&amp; e1 == e2) &#123; cout &lt;&lt; "YES 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; " 0." &lt;&lt; s4 &lt;&lt; "*10^" &lt;&lt; e2 &lt;&lt; endl; &#125; return 0;&#125;string deal(string s, int &amp;e) &#123; unsigned int k = 0; while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); &#125; if(s[0] == '.') &#123; s.erase(s.begin()); while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); e--; &#125; &#125; else &#123; while(k &lt; s.length() &amp;&amp; s[k] != '.') &#123; k++; e++; &#125; if(k &lt; s.length()) &#123; s.erase(s.begin() + k); &#125; &#125; if(s.length() == 0) &#123; e = 0; &#125; int num = 0; k = 0; string res; while(num &lt; n) &#123; if(k &lt; s.length()) &#123; res += s[k++]; &#125; else &#123; res += '0'; &#125; num++; &#125; return res;&#125; 1061 DatingAnalysisè¿™é“é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1014æ˜¯ä¸€æ ·çš„ï¼Œä¸éš¾ï¼Œå°±æ˜¯æœ‰äº›åœ°æ–¹å¥½åƒè¯´çš„ä¸å¤ªæ˜Žç¡®ï¼Œæ¯”å¦‚ï¼Œæ˜ŸæœŸè¿™ä¸ªä¿¡æ¯å¿…é¡»å¾—æ˜¯å±žäºŽ $[A, G]$ çš„å¤§å†™å­—æ¯æ‰èƒ½å¯ä»¥è¿›è¡Œåˆ¤æ–­... Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;char *Week[7] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1062 Talent and VirtueAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“ 1015 ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student &#123; char id[10]; int scoreD, scoreC, sumDC, flag;&#125; stu[MAXN];int N, L, H, M = 0;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumDC = stu[i].scoreD + stu[i].scoreC; if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L) &#123; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= L) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else &#123; stu[i].flag = 4; &#125; M++; &#125; else &#123; stu[i].flag = 5; &#125; &#125; printf("%d\n", M); sort(stu, stu + N, cmp); for(int i = 0; i &lt; M; i++) &#123; printf("%s %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumDC != b.sumDC) return a.sumDC &gt; b.sumDC; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return strcmp(a.id, b.id) &lt; 0;&#125; 1063 Set SimilarityAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè‹¥å¹²ä¸ªé›†åˆï¼Œç»™å‡ºä¸¤ä¸ªé›†åˆçš„â€œç›¸ä¼¼ç¨‹åº¦â€ã€‚è¿™é‡Œçš„â€œç›¸ä¼¼ç¨‹åº¦â€æ˜¯æŒ‡ä¸¤ä¸ªé›†åˆäº¤é›†çš„å…ƒç´ ä¸ªæ•°é™¤ä»¥ä¸¤ä¸ªé›†åˆå¹¶é›†çš„å…ƒç´ ä¸ªæ•°çš„ç™¾åˆ†æ¯”ï¼Œä¸”æ²¡æœ‰é‡å¤å…ƒç´ ã€‚ æŒ‰ç…§é¢˜ç›®èƒŒæ™¯ï¼Œä½¿ç”¨ STL çš„setæ¥å¤„ç†è¿™ä¸ªé—®é¢˜æ¯”è¾ƒæ–¹ä¾¿ï¼Œä¼˜ç‚¹å¦‚ä¸‹ï¼š setåœ¨å­˜å‚¨æ•°æ®æ—¶ï¼Œä¼šè‡ªåŠ¨åŽ»é™¤é‡å¤æ•°æ® setå†…å…ƒç´ çš„ä¸ªæ•°ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨set.size()å¾—åˆ° æŸ¥æ‰¾setå†…å…ƒç´ æ—¶ï¼Œç›´æŽ¥ä½¿ç”¨set.find(elements)å³å¯ ä½¿ç”¨setè¯»å…¥æ‰€æœ‰è¾“å…¥æ•°æ®åŽï¼Œå¼€å§‹æŸ¥è¯¢ã€‚æ¯æ¬¡æŸ¥è¯¢éœ€è¦å¾—åˆ°ä¸€ä¸ªç™¾åˆ†æ¯”ï¼Œæ‰€ä»¥å°±éœ€è¦æ±‚ä¸¤ä¸ªé›†åˆäº¤é›†çš„å…ƒç´ ä¸ªæ•°å’Œå¹¶é›†çš„å…ƒç´ ä¸ªæ•°ã€‚ å…·ä½“æ–¹æ³•æ˜¯ï¼šéåŽ†å…¶ä¸­ä¸€ä¸ªé›†åˆï¼Œä»¤totalNumä¸ºå¦ä¸€ä¸ªé›†åˆçš„å…ƒç´ ä¸ªæ•°ï¼ŒsameNumä¸ºç›¸åŒå…ƒç´ çš„ä¸ªæ•°ï¼ˆåˆå§‹åŒ–ä¸º0ï¼‰ã€‚æ­¤æ—¶åœ¨å¦ä¸€ä¸ªé›†åˆä¸­æŸ¥æ‰¾å½“å‰éåŽ†çš„é›†åˆä¸­çš„å…ƒç´ ï¼Œè‹¥å­˜åœ¨ï¼Œåˆ™sameNum++ï¼Œåä¹‹åˆ™totalNum++ï¼ŒéåŽ†ç»“æŸåŽï¼Œéœ€è¦çš„æ•°å­—å°±ç®—å¥½äº†ï¼ŒæŽ¥ç€ç›¸é™¤å¾—åˆ°ç™¾åˆ†æ¯”å³å¯è¾“å‡ºã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int MAXN = 50 + 5;set&lt;int&gt; st[MAXN];void compare(int x, int y) &#123; int totalNum = st[y].size(), sameNum = 0; for(set&lt;int&gt;::iterator it = st[x].begin(); it != st[x].end(); it++) &#123; if(st[y].find(*it) != st[y].end()) sameNum++; else totalNum++; &#125; printf("%.1lf%\n", sameNum * 100.0 / totalNum);&#125;int main(int argc, char const *argv[]) &#123; int n, m, k, temp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;m); for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;temp); st[i].insert(temp); &#125; &#125; scanf("%d", &amp;k); while(k--) &#123; int s1, s2; scanf("%d %d", &amp;s1, &amp;s2); compare(s1, s2); &#125; return 0;&#125; 1064 Complete Binary Search TreeAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç»“ç‚¹ä¸ªæ•°å’Œç»“ç‚¹å€¼ï¼Œå»ºç«‹ä¸€é¢—å®Œå…¨äºŒå‰æŽ’åºæ ‘ï¼ˆCBTï¼‰ï¼Œæ ¹æ®åç§°ï¼Œå¯ä»¥çŸ¥é“è¿™ç±»æ ‘æ—¢æœ‰å®Œå…¨äºŒå‰æ ‘çš„æ€§è´¨ï¼Œåˆæœ‰äºŒå‰æŽ’åºæ ‘çš„æ€§è´¨ã€‚ ç»è¿‡ä¸Šé¢çš„åˆ†æžï¼Œä½¿ç”¨ç»“æž„æ•°ç»„å»ºæ ‘å°±ååˆ†æ–¹ä¾¿ï¼Œå¯¹å®Œå…¨äºŒå‰æ ‘è€Œè¨€ï¼Œæ•°ç»„çš„ä¸‹æ ‡å³ä»£è¡¨ç»“ç‚¹ä¹‹é—´çš„å…³ç³»ï¼Œæ‰€ä»¥ç›´æŽ¥ä½¿ç”¨æ•´åž‹æ•°ç»„å³å¯ï¼Œå¹¶ä¸”åœ¨æ•°ç»„çš„é¡ºåºå°±æ˜¯å±‚æ¬¡éåŽ†çš„åºåˆ—ã€‚æŽ¥ç€è¦è§£å†³çš„é—®é¢˜å°±æ˜¯å°†ç»“ç‚¹å€¼èµ‹ç»™ç»“ç‚¹ï¼Œæ ¹æ®äºŒå‰æŽ’åºæ ‘çš„æ€§è´¨ï¼Œåˆ©ç”¨ä¸­åºéåŽ†å³å¯å®Œæˆè¿™ä¸ªéœ€æ±‚ã€‚ Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int n, number[maxn], CBT[maxn], index = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); CBT[root] = number[index++]; inorder(root * 2 + 1);&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(1); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; CBT[i]; if(i &lt; n) cout &lt;&lt; ' '; &#125; return 0;&#125; 1065 A+B and C (64bit)Analysisè¿™é“é¢˜ç®—æ˜¯ä¹™çº§é¢˜ç›®1011 A+B å’Œ Cçš„åŠ å¼ºç‰ˆäº†ï¼Œé¢˜ç›®ç»™å®šçš„æ•°æ®èŒƒå›´æ˜¯$[-2^{63}, 2^{63}]$ï¼Œæ­£å¥½æ˜¯64ä½å¸¦ç¬¦å·æ•´åž‹çš„æ•°æ®èŒƒå›´ï¼Œä¸‹é¢æ¥åˆ†æžå¯èƒ½å‡ºçŽ°çš„å„ç§æƒ…å†µï¼ˆåªç”¨å¯¹Aå’ŒBä¹‹å’Œåˆ†æžå°±å¥½ï¼‰ï¼š Aå’ŒBä¹‹å’Œä»ç„¶åœ¨$[-2^{63}, 2^{63}]$ä¹‹å†…ï¼Œå¯ä»¥ç›´æŽ¥ä¸ŽCè¿›è¡Œåˆ¤æ–­ Aå’ŒBä¹‹å’Œå¤§äºŽ$2^{63}$ï¼Œæ­¤æ—¶ä¼šå‘ç”Ÿæ­£æº¢å‡ºï¼Œä¸”å…¶å€¼çš„èŒƒå›´ä¸ºï¼š$[-2^{63}, -2]$ï¼ˆæº¢å‡ºè¿›ä½ï¼Œç¬¦å·ä¸ºä»Ž0å˜ä¸º1ï¼Œæ‰€ä»¥ä¸ºè´Ÿï¼Œå‰©ä¸‹63ä½æž„æˆçš„æ•°å­—å°±åœ¨è¿™ä¸ªèŒƒå›´å†…äº†ï¼‰ã€‚ Aå’ŒBä¹‹å’Œå°äºŽ$-2^{63}$ï¼Œæ­¤æ—¶ä¼šå‘ç”Ÿè´Ÿæº¢å‡ºï¼Œå…¶å€¼èŒƒå›´ä¸ºï¼š$[0, 2^{63})$ï¼ˆåŽŸç†ç±»ä¼¼ï¼‰ å¯¹åº”ä¸Šè¿°ä¸‰ç§æƒ…å†µï¼ŒæŒ‰ç…§å®žé™…è§„åˆ™è¿›è¡Œæ¯”å¤§å°å³å¯ã€‚ Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1066 Root of AVL TreeAnalysisé¢˜ç›®å¤§æ„ç»™å®šä¸€æ£µæ ‘çš„ç»“ç‚¹ä¸ªæ•°ï¼Œå†ç»™å®šå„ä¸ªç»“ç‚¹çš„å€¼ï¼Œå»ºç«‹ä¸€é¢—å¹³è¡¡äºŒå‰æ ‘ï¼ˆAVLï¼‰ï¼Œç„¶åŽè¾“å‡ºç»“ç‚¹çš„å€¼å³å¯ã€‚ ç”±äºŽé¢˜ç›®éœ€è¦å»ºç«‹ AVL æ ‘ï¼Œä¾æ® AVL æ ‘çš„æ€§è´¨ï¼Œæ¯ä¸ªç»“ç‚¹çš„å¹³è¡¡å› å­ç»å¯¹å€¼ä¸èƒ½å¤§äºŽ1ï¼Œæ‰€ä»¥åœ¨æ’å…¥æ¯ä¸ªç»“ç‚¹æ—¶ï¼Œéœ€è¦å¯¹æ ‘è¿›è¡Œè°ƒæ•´ï¼Œä½¿å…¶æ»¡è¶³ AVL æ ‘çš„æ€§è´¨ã€‚ AVL æ ‘å¤±è¡¡çš„æƒ…å†µæ€»å…±æœ‰4ç§ï¼šLLã€LRã€RR å’Œ RL å››ç§ï¼Œä¼šæ ¹æ®æ¯ç§æƒ…å†µåšå¯¹åº”çš„æ—‹è½¬å³å¯ã€‚æ³¨æ„æ¯æ¬¡æ’å…¥ç»“ç‚¹æ—¶éƒ½éœ€è¦æ£€æŸ¥æ ‘æ˜¯å¦å¤±è¡¡ï¼Œè¿™æ ·èƒ½å¤ŸåŠæ—¶è°ƒæ•´ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 25;struct node &#123; int v, height; node *left, *right;&#125; *root;int n;node *newnode(int v) &#123; node *Node = new node; Node-&gt;v = v; Node-&gt;height = 1; Node-&gt;left = Node-&gt;right = NULL; return Node;&#125;int getheight(node *root) &#123; if(root == NULL) return 0; return root-&gt;height;&#125;void updateheight(node *root) &#123; root-&gt;height = max(getheight(root-&gt;left), getheight(root-&gt;right)) + 1;&#125;int getbalancefactor(node *root) &#123; return getheight(root-&gt;left) - getheight(root-&gt;right);&#125;void leftRotation(node *&amp;root) &#123; node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; updateheight(root); updateheight(temp); root = temp;&#125;void rightRotation(node *&amp;root) &#123; node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; updateheight(root); updateheight(temp); root = temp;&#125;void insert(node *&amp;root, int v) &#123; if(root == NULL) &#123; root = newnode(v); return; &#125; if(v &lt; root-&gt;v) &#123; insert(root-&gt;left, v); updateheight(root); if(getbalancefactor(root) == 2) &#123; if(getbalancefactor(root-&gt;left) == 1) &#123; rightRotation(root); &#125; else if(getbalancefactor(root-&gt;left) == -1) &#123; leftRotation(root-&gt;left); rightRotation(root); &#125; &#125; &#125; else &#123; insert(root-&gt;right, v); updateheight(root); if(getbalancefactor(root) == -2) &#123; if(getbalancefactor(root-&gt;right) == -1) &#123; leftRotation(root); &#125; else if(getbalancefactor(root-&gt;right) == 1) &#123; rightRotation(root-&gt;right); leftRotation(root); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int value; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; insert(root, value); &#125; cout &lt;&lt; root-&gt;v; return 0;&#125; 1067 Sort with SwapAnalysisè¿™é“é¢˜è€ƒå¯Ÿè´ªå¿ƒï¼Œå‚æ‚äº†ä¸€äº›æ¨¡æ‹Ÿã€‚ å¯¹å¾…è´ªå¿ƒç±»çš„é¢˜ç›®ï¼Œå¿…é¡»å¾—æ‰¾å‡†è´ªå¿ƒçš„ç­–ç•¥ï¼Œä¸ç„¶å°±æ²¡æ³•è§£é¢˜äº†ï¼Œå¾—ä»”ç»†è§‚å¯Ÿæ ·ä¾‹ã€‚å‡è®¾æ•°å­—éƒ½å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¯´æ˜Žï¼Œå¯ä»¥å‘çŽ°ï¼š0å€¼æ¯æ¬¡äº¤æ¢çš„å¯¹è±¡éƒ½æ˜¯ä¸‹æ ‡å€¼ä¸Žå…¶æœ¬èº«å€¼ä¸ä¸€æ ·çš„æ•°å­—ã€‚æ‰€ä»¥ï¼Œæ¯æ¬¡å°†0å€¼ä¸Žå…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„å€¼äº¤æ¢å³å¯ï¼›ä½†è¦æ³¨æ„ï¼Œè‹¥0çš„ä¸‹æ ‡ä¸º0æ—¶ï¼Œç®—æ³•å°±æ— æ³•ç»§ç»­è¿›è¡Œäº†ï¼Œæ­¤æ—¶éœ€è¦ç‰¹åˆ«å¤„ç†ä¸‹ï¼Œå°†0ä¸Žå½“å‰å€¼æœ€å°ä¸”å…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„æ•°å­—ç›´æŽ¥è¿›è¡Œäº¤æ¢ã€‚ è¿™æ—¶å¯ä»¥å‘çŽ°ï¼Œå¦‚æžœä»Žæ•°ç»„å¤´éƒ¨å¼€å§‹å‘åŽæŸ¥æ‰¾è¿™æ ·çš„æ•°å­—ï¼Œå°±ä¼šæœ‰å¾ˆå¤šå·²ç»æŽ’å¥½çš„æ•°è¢«éåŽ†åˆ°ã€‚ä¸ºäº†é¿å…è¿™æ ·çš„æƒ…å†µï¼Œéœ€è¦å°†å½“å‰å€¼æœ€å°ä¸”å…·æœ‰ä¸Šè¿°ç‰¹ç‚¹çš„æ•°å­—ä¿å­˜åœ¨ä¸€ä¸ªå˜é‡å†…ï¼Œè¿™æ ·ä¸‹æ¬¡æŸ¥æ‰¾æ—¶ç›´æŽ¥ä»Žè¿™ä¸ªæ•°å­—å¼€å§‹å°±å¯ä»¥é¿å…é‡å¤æŸ¥æ‰¾çš„æƒ…å†µäº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int pos[MAXN];int main(int argc, char const *argv[]) &#123; int n, ans = 0; scanf("%d", &amp;n); int left = n - 1, num; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); pos[num] = i; if(num == i &amp;&amp; num != 0) &#123; left--; &#125; &#125; int k = 1; while(left &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; left--; &#125; &#125; printf("%d\n", ans); return 0;&#125; 1069 The Black Hole of NumbersAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1019ä¸€æ · Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1070 MooncakeAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1020ç±»ä¼¼ï¼ˆå¥½åƒåªæ˜¯æ•°æ®ä¸ä¸€æ ·ï¼‰ï¼Œè€ƒå¯Ÿè´ªå¿ƒã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; ans += cake[i].sell; D -= cake[i].store; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125;bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1071 Speech PatternsAnalysisé¢˜ç›®è¦æ±‚è¾“å…¥ä¸€å¥è¯ï¼Œè¾“å‡ºå…¶ä¸­å‡ºçŽ°æ¬¡æ•°æœ€é•¿çš„å­—ç¬¦ä¸²ï¼Œå­—ç¬¦ä¸²åªèƒ½åŒ…å«0-9ã€A-Zå’Œa-zå†…çš„å­—ç¬¦ï¼Œå…¶ä»–å­—ç¬¦å‡è¢«è®¤ä¸ºæ˜¯å­—ç¬¦ä¸²ä¹‹é—´çš„åˆ†éš”ç¬¦ã€‚ å…ˆå°†å­—ç¬¦ä¸²æ•´è¡Œè¯»å…¥ï¼Œåœ¨é€ä¸ªæ‹†åˆ†å‡ºæ¯ä¸ªå•è¯ï¼Œå¹¶åˆ©ç”¨mapæ¥å»ºç«‹å­—ç¬¦ä¸²ï¼ˆstringï¼‰ä¸Žæ¬¡æ•°ï¼ˆintï¼‰ä¹‹é—´çš„æ˜ å°„ï¼Œæ¯ç»Ÿè®¡åˆ°ç›¸åŒçš„å­—ç¬¦ä¸²ï¼Œæ¬¡æ•°åŠ 1ã€‚ è¾“å‡ºæ—¶ï¼ŒéåŽ†mapï¼Œæ‰¾å‡ºå…¶ä¸­å‡ºçŽ°æ¬¡æ•°æœ€å¤šçš„å­—ç¬¦ä¸²å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; mp;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; if('a' &lt;= c &amp;&amp; c &lt;= 'z') return true; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') return true; return false;&#125;int main(int agrc, char const *argv[]) &#123; map&lt;string, int&gt; count; string str; getline(cin, str); int i = 0; while(i &lt; str.length()) &#123; string word; while(i &lt; str.length() &amp;&amp; check(str[i]) == true) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] += 32; &#125; word += str[i]; i++; &#125; if(word != "") &#123; if(count.find(word) == count.end()) count[word] = 1; else count[word]++; &#125; while(i &lt; str.length() &amp;&amp; check(str[i]) == false) &#123; i++; &#125; &#125; string ans; int max = 0; for(map&lt;string, int&gt;::iterator it = count.begin(); it != count.end(); it++) &#123; if(it-&gt;second &gt; max) &#123; max = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; max; return 0;&#125; 1072 Gas StationAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šè‹¥å¹²ä¸ªæºç‚¹å’Œå›ºå®šç‚¹ï¼Œæ±‚è¿™äº›æºç‚¹åˆ°æ‰€æœ‰å›ºå®šç‚¹è·ç¦»æœ€å°çš„æºç‚¹ï¼Œå¦‚æžœå­˜åœ¨ç›¸åŒè§£ï¼Œå°±è¾“å‡ºå¹³å‡è·ç¦»æœ€å°çš„æºç‚¹ã€‚ æŒ‰ç…§é¢˜ç›®å¤§æ„ï¼Œå¯ä»¥å°†é¢˜ç›®æè¿°æŠ½è±¡ä¸ºå›¾ï¼ŒæŽ¥ç€åˆ©ç”¨ Dijkstra ç®—æ³•å°±å¯ä»¥æ±‚è§£æºç‚¹åˆ°å›ºå®šç‚¹çš„æœ€çŸ­è·ç¦»ï¼›ç”±äºŽé¢˜ç›®ç»™å®šçš„æºç‚¹æœ‰å¤šä¸ªï¼Œæ‰€ä»¥è¦ä½¿ç”¨å¤šæ¬¡ Dijkstra ç®—æ³•ï¼Œæ‰€ä»¥æ¯æ¬¡æ‰§è¡Œç®—æ³•ä¹‹å‰éœ€è¦å°†ç”¨åˆ°çš„boolæ•°ç»„åˆå§‹åŒ–ä¸ºfalseã€‚ç„¶åŽï¼ŒæŒ‰ç…§é¢˜ç›®æ¡ä»¶æ¥åˆ¤æ–­æˆ–ç­›é€‰æœ€ä¼˜è§£ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1020;const int inf = 0x3fffffff;int n, m, k, ds, G[maxv][maxv];int d[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; memset(vis, false, sizeof(vis)); //do not forget initializing this array fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n + m; i++) &#123; int u = -1, min = inf; for(int j = 1; j &lt;= n + m; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 1; v &lt;= n + m; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int getid(char str[]) &#123; //tranfer the id of gas station int len = strlen(str), id = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != 'G') id = id * 10 + (str[i] - '0'); &#125; if(str[0] == 'G') return n + id; else return id;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;ds); int u, v, w; char city1[5], city2[5]; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 0; i &lt; k; i++) &#123; scanf("%s %s %d", city1, city2, &amp;w); u = getid(city1); v = getid(city2); G[v][u] = G[u][v] = w; &#125; double ansdis = -1, ansavg = inf; int ansid = -1; for(int i = n + 1; i &lt;= n + m; i++) &#123; double mindis = inf, avg = 0; dijkstra(i); //every station should execute this dijkstra for(int j = 1; j &lt;=n; j++) &#123; if(d[j] &gt; ds) &#123; //this solution does not fit the problem mindis = -1; break; &#125; if(d[j] &lt; mindis) mindis = d[j]; //cal minimum of distance avg += 1.0 * d[j] / n; //calculate the average &#125; if(mindis == -1) continue; if(mindis &gt; ansdis) &#123; //more optimal solution ansid = i; ansdis = mindis; ansavg = avg; &#125; else if(mindis == ansdis &amp;&amp; avg &lt; ansavg) &#123; //more optimal solution ansid = i; ansavg = avg; &#125; &#125; if(ansid == -1) printf("No Solution\n"); else &#123; printf("G%d\n", ansid - n); printf("%.1lf %.1lf\n", ansdis, ansavg); &#125; return 0;&#125; 1073 Scientific NotationAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1024ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int Epos, exp = 0; for(Epos = 1; Num[Epos] != 'E'; Epos++); for(int i = Epos + 2; Num[i] != '\0'; i++) &#123; exp = exp * 10 + Num[i] - '0'; &#125; if(Num[0] == '-') &#123; putchar(Num[0]); &#125; if(exp == 0) &#123; for(int i = 1; Num[i] != 'E'; i++) &#123; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '-') &#123; printf("0."); for(int i = exp - 1; i &gt; 0; i--) &#123; putchar('0'); &#125; for(int i = 1; Num[i] != 'E'; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '+') &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == exp + 2 &amp;&amp; Epos - 3 != exp) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; exp - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; putchar('\n'); return 0;&#125; 1074 Reversing Linked ListAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1025ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node&#123; int address, data, next; int order;&#125; Node[maxn];bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125; int head, n, k, address; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].data, &amp;Node[address].next); Node[address].address = address; &#125; int p = head, count = 0; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) &#123; printf("-1\n"); &#125; else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1075 PAT JudgeAnalysisè€ƒå¯ŸæŽ’åºï¼Œé¢˜ç›®è¯´æ˜Žæ¯”è¾ƒå¤šï¼Œè¦ä»”ç»†è¯»é¢˜ã€‚å…³é”®æ˜¯è¾“å…¥æ•°æ®çš„å¤„ç†ï¼Œå¤„ç†åŽè¦è¾¾åˆ°ä¾¿äºŽæŽ’åºï¼ˆä¸Žé¢˜ç›®ä¸€è‡´ï¼‰å’Œè¾“å‡ºçš„æ•ˆæžœã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;struct user&#123; int id, score[6], sum, perfect; bool flag;&#125; us[MAXN];int N, K, M;int full[6] = &#123;0&#125;;bool cmp(user a, user b);void Init();int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;K, &amp;M); Init(); for(int i = 1; i &lt;= K; i++) &#123; scanf("%d", full + i); &#125; int uid, pid, score_ob; for(int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;uid, &amp;pid, &amp;score_ob); if(score_ob != -1) &#123; us[uid].flag = true; &#125; if(score_ob == -1 &amp;&amp; us[uid].score[pid] == -1) &#123; us[uid].score[pid] = 0; &#125; if(score_ob == full[pid] &amp;&amp; us[uid].score[pid] &lt; full[pid]) &#123; us[uid].perfect++; &#125; if(score_ob &gt; us[uid].score[pid]) &#123; us[uid].score[pid] = score_ob; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] != -1) &#123; us[i].sum += us[i].score[j]; &#125; &#125; &#125; sort(us + 1, us + N + 1, cmp); int r = 1; for(int i = 1; i &lt;= N &amp;&amp; us[i].flag == true; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) &#123; r = i; &#125; printf("%d %05d %d", r, us[i].id, us[i].sum); for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] == -1) &#123; printf(" -"); &#125; else &#123; printf(" %d", us[i].score[j]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void Init() &#123; for(int i = 1; i &lt;= N; i++) &#123; us[i].id = i; us[i].sum = 0; us[i].perfect = 0; us[i].flag = false; memset(us[i].score, -1, sizeof(us[i].score)); &#125;&#125; 1076 Forwards on WeiboAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;struct node &#123; int id; int layer;&#125;;vector&lt;node&gt; Adj[maxn];bool inq[maxn] = &#123;false&#125;;int BFS(int s, int L) &#123; int numFoward = 0; queue&lt;node&gt; q; node start; start.id = s; start.layer = 0; q.push(start); inq[start.id] = true; while(!q.empty()) &#123; node top = q.front(); q.pop(); int u = top.id; for(int i = 0; i &lt; Adj[u].size(); i++) &#123; node next = Adj[u][i]; next.layer = top.layer + 1; if(inq[next.id] == false &amp;&amp; next.layer &lt;= L) &#123; q.push(next); inq[next.id] = true; numFoward++; &#125; &#125; &#125; return numFoward;&#125;int main(int argc, char const *argv[]) &#123; node user; int n, L, numFollow, idFollow; cin &gt;&gt; n &gt;&gt; L; for(int i = 1; i &lt;= n; i++) &#123; user.id = i; cin &gt;&gt; numFollow; for(int j = 0; j &lt; numFollow; j++) &#123; cin &gt;&gt; idFollow; Adj[idFollow].push_back(user); &#125; &#125; int numQuery, s; cin &gt;&gt; numQuery; while(numQuery--) &#123; memset(inq, false, sizeof(inq)); cin &gt;&gt; s; int numFoward = BFS(s, L); cout &lt;&lt; numFoward &lt;&lt; endl; &#125; return 0;&#125; 1077 KuchiguseAnalysisæœ¬é¢˜çš„å®žè´¨æ˜¯åœ¨æ±‚å­—ç¬¦ä¸²çš„æœ€é•¿ç›¸åŒåŽç¼€ï¼Œä»ŽåŽéåŽ†å­—ç¬¦ä¸²æ¯”è¾ƒéº»çƒ¦ï¼Œæ‰€ä»¥é‡‡å–å…ˆé€†è½¬å­—ç¬¦ä¸²ï¼Œç„¶åŽä»Žå‰éåŽ†çš„åšæ³•ï¼Œè¿™æ ·å°±ä¼šæ–¹ä¾¿è®¸å¤šã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 256 + 5;char str[100][MAXN];void Reverse(char *s);int main(int argc, char const *argv[]) &#123; int N, minLen = 256, ans = 0; scanf("%d", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) &#123; fgets(str[i], MAXN, stdin); int len = strlen(str[i]); if(len &lt; minLen) minLen = len; Reverse(str[i]); &#125; for(int i = 0; i &lt; minLen; i++) &#123; char c = str[0][i]; bool same = true; for(int j = 1; j &lt; N; j++) &#123; if(c != str[j][i]) &#123; same = false; break; &#125; &#125; if(same) &#123; ans++; &#125; else &#123; break; &#125; &#125; if(ans &gt; 1) &#123; for(int i = ans - 1; i &gt;= 0; i--) &#123; putchar(str[0][i]); &#125; &#125; else &#123; puts("nai"); &#125; return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1078 HashingAnalysisé¢˜ç›®å¤§æ„æ˜¯ç”¨çº¿æ€§æŽ¢æµ‹çš„æ–¹æ³•ï¼Œæž„é€ å“ˆå¸Œè¡¨ï¼Œç”¨å¹³æ–¹æŽ¢æµ‹çš„åŠžæ³•è§£å†³å†²çªã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXM = 10005;bool isPrime(int n) &#123; if(n &lt;= 1 || (n != 2 &amp;&amp; n % 2 == 0)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int nearPrime(int n) &#123; while(!isPrime(n)) n++; return n;&#125;int hashTable[MAXM] = &#123;0&#125;; int main(int argc, char const *argv[]) &#123; int m, n, temp, index; scanf("%d %d", &amp;m, &amp;n); m = nearPrime(m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); index = temp % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); &#125; else &#123; int step; for(step = 1; step &lt; m; step++) &#123; index = (temp + step * step) % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); break; &#125; &#125; if(step &gt;= m) &#123; printf("-"); &#125; &#125; if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 1079 Total Sales of SupplyAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1080 Graduate AdmissionAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 40000 + 5;struct student&#123; int ge, gi, sum; int r, id; int cho[6];&#125; stu[MAXN];struct school&#123; int quota; int stuNum; int id[MAXN]; int lastAdmit;&#125; sch[110];bool cmpStu(student a, student b);bool cmpID(int a, int b);int main(int argc, char const *argv[]) &#123; int N, M, K; scanf("%d %d %d", &amp;N, &amp;M, &amp;K); for(int i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;sch[i].quota); sch[i].stuNum = 0; sch[i].lastAdmit = -1; &#125; for(int i = 0; i &lt; N; i++) &#123; stu[i].id = i; scanf("%d %d", &amp;stu[i].ge, &amp;stu[i].gi); stu[i].sum = stu[i].ge + stu[i].gi; for(int j = 0; j &lt; K; j++) &#123; scanf("%d", &amp;stu[i].cho[j]); &#125; &#125; sort(stu, stu + N, cmpStu); for(int i = 0; i &lt; N; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) &#123; stu[i].r = stu[i - 1].r; &#125; else &#123; stu[i].r = i; &#125; &#125; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; K; j++) &#123; int choice = stu[i].cho[j]; int num = sch[choice].stuNum; int last = sch[choice].lastAdmit; if(num &lt; sch[choice].quota || (last != -1 &amp;&amp; stu[i].r == stu[last].r)) &#123; sch[choice].id[num] = i; sch[choice].lastAdmit = i; sch[choice].stuNum++; break; &#125; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; if(sch[i].stuNum &gt; 0) &#123; sort(sch[i].id, sch[i].id + sch[i].stuNum, cmpID); for(int j = 0; j &lt; sch[i].stuNum; j++) &#123; printf("%d", stu[sch[i].id[j]].id); if(j &lt; sch[i].stuNum - 1) &#123; printf(" "); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmpStu(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;bool cmpID(int a, int b) &#123; return stu[a].id &lt; stu[b].id;&#125; 1081 Rational SumAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šNä¸ªa/bå½¢å¼çš„åˆ†æ•°ï¼Œaä¸ºåˆ†å­ï¼Œbä¸ºåˆ†æ¯ï¼Œæ±‚è¿™Nä¸ªåˆ†æ•°çš„å’Œå†è¾“å‡ºã€‚ ç»™å®šçš„åˆ†æ•°åªæœ‰ä¸¤ç§æƒ…å†µï¼šçœŸåˆ†æ•°å’Œå‡åˆ†æ•°ï¼Œä¸å­˜åœ¨å¸¦åˆ†æ•°ï¼Œä½†è¾“å‡ºè¦è¾“å‡ºå¸¦åˆ†æ•°ï¼Œå¹¶ä¸”æ˜¯æœ€ç®€å½¢å¼ã€‚åŒ–ç®€çš„ç›®çš„å…¶å®žé¢˜ç›®è€ƒå¯Ÿæ±‚æœ€å¤§å…¬çº¦æ•°ï¼Œåˆ©ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯æ±‚å¾—ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct fraction &#123; long long up, down;&#125; Fraction;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; long long d = gcd(abs(result.up), result.down); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;void printResult(Fraction result) &#123; Fraction r = Reduction(result); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125;&#125;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); Fraction ans, temp; ans.up = 0; ans.down = 1; while(N--) &#123; scanf("%lld/%lld", &amp;temp.up, &amp;temp.down); ans = Add(ans, temp); &#125; printResult(ans); return 0;&#125; 1082 Read Number in ChineseAnalysiså°†æ•°å­—æŒ‰æ¯4ä½ä¸€ç»„åˆ†å‰²ä¸ºä¸åŒçš„ç»„ï¼Œè‹¥æ˜¯9ä½æ•°ï¼Œåˆ™æœ‰ä¸‰ç»„åˆ†åˆ«ä¸ºï¼šä¸ªä½ç»„ã€ä¸‡ä½ç»„å’Œäº¿ä½ç»„ï¼Œç„¶åŽé’ˆå¯¹æ¯ä¸€ç»„å•ç‹¬è¿›è¡Œåˆ¤æ–­ã€‚å¯¹æ¯ä¸€å°ç»„è€Œè¨€ï¼Œè¦æ³¨æ„1001åªèƒ½è¾“å‡ºä¸ºyi Qian ling yiè€Œä¸æ˜¯yi Qian ling ling yiï¼Œå³æœ‰ç´¯ç§¯çš„0æ—¶ï¼Œåªèƒ½è¾“å‡ºä¸€ä¸ªlingã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;char NumberTable[10][10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu", &#125;;char Digit[5][10] = &#123; "Shi", "Bai", "Qian", "Wan", "Yi", &#125;;int main(int argc, char const *argv[]) &#123; char Num[15]; scanf("%s", Num); int len = strlen(Num), left = 0, right = len - 1; if(Num[0] == '-') &#123; printf("Fu"); left++; &#125; while(left + 4 &lt;= right) &#123; right -= 4; &#125; while(left &lt; len) &#123; bool flag = false, isPrint = false; while(left &lt;= right) &#123; if(left &gt; 0 &amp;&amp; Num[left] == '0') &#123; flag = true; &#125; else &#123; if(flag == true) &#123; printf(" ling"); flag = false; &#125; if(left &gt; 0) printf(" "); printf("%s", NumberTable[Num[left] - '0']); isPrint = true; if(left != right) &#123; printf(" %s", Digit[right - left - 1]); &#125; &#125; left++; &#125; if(isPrint == true &amp;&amp; right != len - 1) &#123; printf(" %s", Digit[(len - 1 - right) / 4 + 2]); &#125; right += 4; &#125; return 0;&#125; 1083 List GradesAnalysisè‡ªå®šä¹‰ç»“æž„ä½“ï¼Œè¾“å…¥æ•°æ®åŽè°ƒç”¨sortå‡½æ•°æŒ‰ç…§é™åºæŽ’åºï¼Œç„¶åŽæ ¹æ®é¢˜ç›®ç»™å®šçš„åŒºé—´é¡ºåºè¾“å‡ºç¬¦åˆè¿™ä¸ªåŒºé—´å†…çš„å…ƒç´ å³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char name[15], id[15]; int grade;&#125; stu[MAXN];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, grade1, grade2; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].id, &amp;stu[i].grade); &#125; scanf("%d %d", &amp;grade1, &amp;grade2); sort(stu, stu + N, cmp); bool flag = false; for(int i = 0; i &lt; N; i++) &#123; if(grade1 &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= grade2) &#123; printf("%s %s\n", stu[i].name, stu[i].id); flag = true; &#125; &#125; if(!flag) &#123; printf("NONE\n"); &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade &gt; b.grade;&#125; 1084 Broken KeyboardAnalysiséåŽ†å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°è¿‡ï¼Œä½†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­æœªå‡ºçŽ°çš„å­—ç¬¦å³å¯ï¼Œå­—æ¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œä½†å­—ç¬¦ä¸²å†…æœ‰ç©ºæ ¼å’Œæ•°å­—ï¼Œç”¨_è¡¨ç¤ºï¼Œæ³¨æ„ä¸èƒ½è¾“å‡ºå°å†™å­—æ¯ï¼Œä¸”é‡å¤çš„å­—ç¬¦åªè¾“å‡ºä¸€æ¬¡ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;int main(int argc, char const *argv[]) &#123; char str1[85], str2[85]; scanf("%s %s", str1, str2); bool HashTable[128] = &#123;false&#125;; for(int i = 0; str1[i] != '\0'; i++) &#123; int j = 0; char c1 = str1[i]; for(; str2[j] != '\0'; j++) &#123; char c2 = str2[j]; if(islower(c1)) c1 = toupper(c1); if(islower(c2)) c2 = toupper(c2); if(c1 == c2) break; &#125; if(str2[j] == '\0' &amp;&amp; HashTable[c1] == false) &#123; printf("%c", c1); HashTable[c1] = true; &#125; &#125; putchar('\n'); return 0;&#125; 1085 Perfect SequenceAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1030ä¸€æ ·ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;long long n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%lld %lld", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1086 Tree Traversals AgainAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šç”¨æ ˆæ¨¡æ‹ŸäºŒå‰æ ‘ä¸­åºéåŽ†çš„å…¥æ ˆã€å‡ºæ ˆé¡ºåºï¼ŒçŽ°åœ¨è¦æ±‚è¾“å‡ºè¿™ä¸ªäºŒå‰æ ‘åŽåºéåŽ†åºåˆ—ã€‚ æ ¹æ®é¢˜ç›®ç»™å®šçš„å…¥æ ˆã€å‡ºæ ˆåºåˆ—ï¼Œå¯ä»¥å¾—åˆ°äºŒå‰æ ‘çš„å…ˆåºéåŽ†åºåˆ—å’ŒåŽåºéåŽ†åºåˆ—ï¼Œæ ¹æ®è¿™ä¸¤ä¸ªåºåˆ—å»ºæ ‘ï¼Œç„¶åŽå†åŽåºéåŽ†è¿™ä¸ªäºŒå‰æ ‘å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int data; node *lchild; node *rchild;&#125;;int n, pre[50], in[50], order;stack&lt;int&gt; st;node *create(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(preL + 1, preL + numLeft, inL, k - 1); root-&gt;rchild = create(preL + numLeft + 1, preR, k + 1, inR); return root;&#125;int num = 0;void postorder(node *root) &#123; if(root == NULL) return; postorder(root-&gt;lchild); postorder(root-&gt;rchild); printf("%d", root-&gt;data); if(num &lt; n - 1) &#123; printf(" "); &#125; num++;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); char str[5]; int x, preIndex = 0, inIndex = 0; for(int i = 0; i &lt; 2 * n; i++) &#123; scanf("%s", str); if(strcmp("Push", str) == 0) &#123; scanf("%d", &amp;x); pre[preIndex++] = x; st.push(x); &#125; else &#123; in[inIndex++] = st.top(); st.pop(); &#125; &#125; node *root = create(0, n - 1, 0, n - 1); postorder(root); return 0;&#125; 1087 All Roads Lead to RomeAnalysisé¢˜ç›®èƒŒæ™¯æ˜¯æ—…æ¸¸çš„è·¯çº¿å›¾ï¼Œè¦æ±‚æŒ‰ç…§æ¡ä»¶æ±‚å‡ºæœ€çŸ­è·¯å¾„åŠç‰¹å®šçš„å€¼ã€‚ é¢˜ç›®é¦–å…ˆè¦æ±‚å‡ºçš„æ˜¯ä»Žèµ·ç‚¹åˆ°ç»ˆç‚¹çš„æœ€çŸ­è·¯å¾„ï¼Œç”±äºŽä¸å­˜åœ¨è´ŸçŽ¯ï¼Œæ‰€ä»¥å¯ä»¥ç›´æŽ¥ä½¿ç”¨ Dijkstra ç®—æ³•æ±‚å¾—ï¼›åŒæ—¶æ³¨æ„åˆ°ï¼Œé¢˜ç›®è¦æ±‚çš„æŸäº›ç‰¹æ®Šå€¼ä¸Žå¯¹åº”çš„è·¯å¾„å¯ä»¥åœ¨æ±‚è§£æœ€çŸ­è·¯æ—¶ï¼Œä¸€å¹¶æ±‚å‡ºï¼Œåªä¸è¿‡éœ€è¦ä½¿ç”¨å¤šä¸ªæ•°ç»„è€Œå·²ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ï¼Œå¯¹é¢˜ç›®è¦æ±‚çš„å€¼å¢žåŠ å¯¹åº”çš„æ•°ç»„ï¼Œå¹¶åœ¨æ±‚è§£æœ€æœ€çŸ­è·¯çš„è¿‡ç¨‹ä¸­å†™æ¸…æ¥šè¿™äº›æ¡ä»¶ä¹‹é—´çš„å±‚æ¬¡å…³ç³»å³å¯ã€‚ å½“ç„¶äº†ï¼Œæœ¬é¢˜ä¹Ÿå¯ä»¥ä½¿ç”¨ Dijkstra ç®—æ³•å…ˆæ±‚å‡ºæ‰€æœ‰çš„æœ€çŸ­è·¯å¾„ï¼Œç„¶åŽå†åˆ©ç”¨ DFS æ¥æ±‚å‡ºç¬¦åˆæ¡ä»¶çš„æœ€ä¼˜è§£å’Œå¯¹åº”çš„å€¼ã€‚ CodeDijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;, pt[maxv] = &#123;0&#125;, pre[maxv];bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v] = u; num[v] = num[u]; w[v] = w[u] + weight[v]; pt[v] = pt[u] + 1; &#125; else if(d[v] == d[u] + G[u][v]) &#123; num[v] += num[u]; if(w[v] &lt; w[u] + weight[v]) &#123; w[v] = w[u] + weight[v]; pre[v] = u; pt[v] = pt[u] + 1; &#125; else if(w[v] == w[u] + weight[v]) &#123; double uavg = 1.0 * (w[u] + weight[v]) / (pt[u] + 1); double vavg = 1.0 * w[v] / pt[v]; if(uavg &gt; vavg) &#123; pt[v] = pt[u] + 1; pre[v] = u; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; cout &lt;&lt; index2city[v]; return; &#125; dfs(pre[v]); cout &lt;&lt; "-&gt;" &lt;&lt; index2city[v];&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; city2index[city1] = i; index2city[i] = city1; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1], v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; cout &lt;&lt; num[rom] &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; w[rom] &lt;&lt; ' ' &lt;&lt; w[rom] / pt[rom] &lt;&lt; endl; dfs(rom); return 0;&#125; Dijkstra + DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], numpath = 0, maxw = 0;double maxavg = 0;bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); numpath++; int tempw = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; tempw += weight[id]; &#125; double tempavg = 1.0 * tempw / (tempath.size() - 1); if(tempw &gt; maxw) &#123; maxw = tempw; maxavg = tempavg; path = tempath; &#125; else if(tempw == maxw &amp;&amp; tempavg &gt; maxavg) &#123; maxavg = tempavg; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; index2city[i] = city1; city2index[city1] = i; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1]; v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; dfs(rom); cout &lt;&lt; numpath &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; maxw &lt;&lt; ' ' &lt;&lt; (int)maxavg &lt;&lt; endl; for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; index2city[path[i]]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; return 0;&#125; 1088 Rational ArithmeticAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1034ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b);struct Fraction&#123; ll up, down;&#125; a, b;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /=d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void showResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); //add showResult(a); printf(" + "); showResult(b); printf(" = "); showResult(Add(a, b)); putchar('\n'); //minu showResult(a); printf(" - "); showResult(b); printf(" = "); showResult(Minu(a, b)); putchar('\n'); //mult showResult(a); printf(" * "); showResult(b); printf(" = "); showResult(Mult(a, b)); putchar('\n'); //divide showResult(a); printf(" / "); showResult(b); printf(" = "); if(b.up == 0) printf("Inf"); else showResult(Divide(a, b)); return 0;&#125; ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125; 1089 Insert or MergeAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1035ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 10;int ori[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;bool InsertionSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;ori[i]); tempOri[i] = ori[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertionSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = ori[i]; &#125; MergeSort(); &#125; return 0;&#125; 1090 Highest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;struct node &#123; double data; vector&lt;int&gt; child;&#125; Node[maxn];int n, num = 0;double p, r, maxDepth = 0;void DFS(int index, int depth) &#123; if(Node[index].child.size() == 0) &#123; if(depth &gt; maxDepth) &#123; maxDepth = depth; num = 1; &#125; else if(depth == maxDepth) &#123; num++; &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; DFS(Node[index].child[i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100; int root, parent; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;parent); if(parent != -1) &#123; Node[parent].child.push_back(i); &#125; else &#123; root = i; &#125; &#125; DFS(root, 0); printf("%.2lf %d\n", p * pow(1 + r, maxDepth), num); return 0;&#125; 1091 Acute StrokeAnalysisé¢˜ç›®çš„èƒŒæ™¯å¤§æ¦‚æ˜¯è®¡ç®—ä½“ç§¯ä¹‹å’Œå§... æ ¹æ®é¢˜ç›®è¾“å…¥æ•°æ®çš„å½¢å¼å’Œé¢˜ç›®å¤§æ„ï¼Œæ€è·¯æ˜¯å€ŸåŠ© BFS å¯¹ä¸‰ç»´æ•°ç»„è¿›è¡ŒéåŽ†ï¼Œè®¡ç®—å‡ºæ¯ä¸€ä¸ªè–„ç‰‡ï¼ˆsliceï¼‰ä¸­ä¸ºâ€œ1â€çš„ä¸ªæ•°ï¼Œå¦‚æžœå¤§äºŽé¢˜ç›®ç»™å®šçš„Tï¼Œåˆ™å½“å‰è¿™ä¸ªè–„ç‰‡å†…â€œ1â€çš„ä¸ªæ•°å°±å¯ä»¥è®¤ä¸ºæ˜¯è¿™ä¸ªè–„ç‰‡çš„â€œæ€¥æ€§è„‘å’ä¸­â€åŒºçš„ä½“ç§¯ã€‚é‚£ä¹ˆï¼Œä¾æ¬¡éåŽ†æ¯ä¸ªè–„ç‰‡å³å¯å¾—åˆ°æœ€ç»ˆç»“æžœã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, z;&#125; Node;int n, m, slice, T;int pixel[1290][130][61];bool inqueue[1290][130][61];int X[6] = &#123;0, 0, 0, 0, 1, -1&#125;;int Y[6] = &#123;0, 0, 1, -1, 0, 0&#125;;int Z[6] = &#123;1, -1, 0, 0, 0, 0&#125;;bool judge(int x, int y, int z) &#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0 || z &gt;= slice || z &lt; 0) return false; if(pixel[x][y][z] == 0 || inqueue[x][y][z] == true) return false; return true;&#125;int BFS(int x, int y, int z) &#123; int tot = 0; queue&lt;node&gt; Q; Node.x = x, Node.y = y, Node.z = z; Q.push(Node); inqueue[x][y][z] = true; while(!Q.empty()) &#123; node top = Q.front(); Q.pop(); tot++; for(int i = 0; i &lt; 6; i++) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; int newZ = top.z + Z[i]; if(judge(newX, newY, newZ)) &#123; Node.x = newX, Node.y = newY, Node.z = newZ; Q.push(Node); inqueue[newX][newY][newZ] = true; &#125; &#125; &#125; if(tot &gt;= T) return tot; else return 0;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;slice, &amp;T); for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; scanf("%d", &amp;pixel[x][y][z]); &#125; &#125; &#125; int ans = 0; for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; if(pixel[x][y][z] == 1 &amp;&amp; inqueue[x][y][z] == false) &#123; ans += BFS(x, y, z); &#125; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1092 To Buy or Not to BuyAnalysisä¸Žä¹™çº§é¢˜åº“çš„1039ä¸€æ ·ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1093 Count PATâ€™sAnalysisä¸Žä¹™çº§é¢˜åº“çš„1040ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') leftNumP[i]++; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt; 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; 1094 The Largest GenerationAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, seq, child;int Depth[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; Depth[Node[1].depth]++; while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; Depth[Node[child].depth]++; q.push(child); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); int max = -1, l = 1; for(int i = 0; i &lt; maxn; i++) &#123; if(Depth[i] &gt; max) &#123; max = Depth[i]; l = i; &#125; &#125; cout &lt;&lt; Depth[l] &lt;&lt; ' ' &lt;&lt; l &lt;&lt; endl; return 0;&#125; 1096 Consecutive FactorsAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•´æ•°ï¼Œæ‰¾å‡ºå…¶æœ€é•¿çš„å› å­åºåˆ—ï¼Œä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œ630=3*5*6*7ï¼Œæ‰€ä»¥å…¶è¿žç»­å› å­åºåˆ—ä¸º3*5*7ï¼Œé•¿åº¦ä¸º3ä¸”æ­¤ä¸ºå…¶æœ€é•¿è¿žç»­å› å­åºåˆ—ã€‚ Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[]) &#123; ll n; scanf("%lld", &amp;n); ll sqr = sqrt(n), ansI = 0, ansLen = 0; for(ll i = 2; i &lt;= sqr; i++) &#123; ll temp = 1, j = i; while(1) &#123; temp *= j; if(n % temp != 0) break; if(j - i + 1 &gt; ansLen) &#123; ansI = i; ansLen = j - i + 1; &#125; j++; &#125; &#125; if(ansLen == 0) &#123; printf("1\n%lld\n", n); &#125; else &#123; printf("%lld\n", ansLen); for(ll i = 0; i &lt; ansLen; i++) &#123; printf("%lld", ansI + i); if(i &lt; ansLen - 1) putchar('*'); &#125; &#125; return 0;&#125; 1097 Deduplication on a Linked ListAnalysisé¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸²é“¾è¡¨çš„å„ä¸ªç»“ç‚¹ï¼Œåˆ é™¤å…¶ä¸­é‡å¤çš„ç»“ç‚¹ï¼Œå¹¶å°†åˆ é™¤çš„ç»“ç‚¹é‡æ–°ç»„æˆä¸€ä¸ªé“¾è¡¨ã€‚ç„¶åŽï¼Œå…ˆè¾“å‡ºåŽŸé“¾è¡¨åˆ é™¤ç»“ç‚¹åŽçš„æ–°é“¾è¡¨ï¼Œç´§æŽ¥ç€åœ¨è¾“å‡ºç”±æ‰€åˆ é™¤çš„ç»“ç‚¹æž„æˆçš„é“¾è¡¨ã€‚ ä½¿ç”¨é™æ€é“¾è¡¨æ¥å¤„ç†è¿™ä¸ªé—®é¢˜ï¼Œå…ˆé»˜è®¤åˆå§‹åŒ–é“¾è¡¨å†…çš„æ‰€æœ‰ç»“ç‚¹å…¨éƒ¨ä¸ºæ— æ•ˆç»“ç‚¹ï¼Œå³ç½®ä¸º2 * maxnï¼Œç„¶åŽå°†é“¾è¡¨å†…æ‰€æœ‰ç»“ç‚¹æ ¹æ®åœ°å€å­˜å‚¨ã€‚ç´§æŽ¥ç€ï¼ŒéåŽ†é“¾è¡¨ï¼Œä½¿ç”¨ä¸€ä¸ªboolæ•°ç»„æ¥è®°å½•ç»“ç‚¹æ˜¯å¦å‡ºçŽ°è¿‡ï¼Œå¯¹äºŽæ²¡æœ‰å‡ºçŽ°çš„åˆæ³•ç»“ç‚¹ï¼Œä»Ž0å¼€å§‹ç¼–å·ï¼Œå‡ºçŽ°è¿‡çš„ç»“ç‚¹ï¼Œä»Žmaxnå¼€å§‹ç¼–å·ã€‚æœ€åŽï¼Œä½¿ç”¨sortå‡½æ•°æ ¹æ®orderæ¥æŽ’åºï¼Œå°±å¯ä»¥å°†ç»“ç‚¹æŒ‰åºåˆ†ä¸ºåˆ é™¤ç»“ç‚¹åŽçš„é“¾è¡¨ã€æ–°é“¾è¡¨å’Œæ— æ•ˆç»“ç‚¹ä¸‰éƒ¨åˆ†ï¼Œåœ¨è¾“å‡ºå³å¯ã€‚ æ³¨æ„è¦ä½¿ç”¨%05dæ¥è¾“å‡ºåœ°å€ä½æ•°è¾ƒå°‘çš„ç»“ç‚¹ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;const int Table = 2 * maxn;struct node&#123; int address, next, key; int order;&#125; Node[maxn];bool isExist[Table] = &#123;false&#125;;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = 2 * maxn; &#125; int n, head, address; scanf("%d %d", &amp;head, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].key, &amp;Node[address].next); Node[address].address = address; &#125; int countValid = 0, countRemoved = 0, p = head; while(p != -1) &#123; if(!isExist[abs(Node[p].key)]) &#123; isExist[abs(Node[p].key)] = true; Node[p].order = countValid++; &#125; else &#123; Node[p].order = maxn + countRemoved++; &#125; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); int count = countValid + countRemoved; for(int i = 0; i &lt; count; i++) &#123; if(i != countValid - 1 &amp;&amp; i != count - 1) &#123; printf("%05d %d %05d\n", Node[i].address, Node[i].key, Node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", Node[i].address, Node[i].key); &#125; &#125; return 0;&#125; 1098 Insertion or Heap SortAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int origin[maxn], tempori[maxn], changed[maxn];int n;bool isSame(int A[], int B[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;bool showArray(int A[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", A[i]); if(i &lt; n) putchar(' '); &#125; putchar('\n');&#125;bool insertSort() &#123; bool flag = false; for(int i = 2; i &lt;= n; i++) &#123; if(i != 2 &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; sort(tempori, tempori + i + 1); if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void downAdjust(int low, int high) &#123; int i = low, j = 2 * i; while(j &lt;= high) &#123; if(j + 1 &lt;= high &amp;&amp; tempori[j + 1] &gt; tempori[j]) &#123; j = j + 1; &#125; if(tempori[j] &gt; tempori[i]) &#123; swap(tempori[j], tempori[i]); i = j; j = i * 2; &#125; else &#123; break; &#125; &#125;&#125;void heapSort() &#123; bool flag = false; for(int i = n / 2; i &gt;= 1; i--) &#123; downAdjust(i, n); &#125; for(int i = n; i &gt; 1; i--) &#123; if(i != n &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; swap(tempori[i], tempori[1]); downAdjust(1, i - 1); if(flag == true) &#123; showArray(tempori); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;origin[i]); tempori[i] = origin[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(insertSort()) &#123; printf("Insertion Sort\n"); showArray(tempori); &#125; else &#123; printf("Heap Sort\n"); for(int i = 1; i &lt;= n; i++) &#123; tempori[i] = origin[i]; &#125; heapSort(); &#125; return 0;&#125; 1099 Build A Binary Search TreeAnalysisé¢˜ç›®å¤§æ„ç»™å®šä¸€é¢—äºŒå‰æŽ’åºæ ‘ï¼ˆBSTï¼‰ï¼Œè¾“å‡ºè¿™æ£µæ ‘çš„å±‚æ¬¡åºåˆ—ã€‚ æ ¹æ®é¢˜ç›®è¾“å…¥æ•°æ®çš„å½¢å¼ï¼Œåˆ©ç”¨ç»“æž„æ•°ç»„å»ºæ ‘æ¯”è¾ƒæ–¹ä¾¿ã€‚å»ºæ ‘ä¹‹åŽï¼Œä¸­åºéåŽ†è¿™æ£µæ ‘ï¼Œå°†æŒ‰å‡åºæŽ’å¥½çš„ç»“ç‚¹å€¼åºåˆ—ï¼ŒæŒ‰ç…§é¡ºåºèµ‹ç»™æ¯ä¸ªç»“ç‚¹ï¼Œè¿™æ ·æ¯ä¸ªç»“ç‚¹çš„å€¼å°±ç¬¦åˆ BST çš„æ€§è´¨äº†ï¼ŒæŽ¥ç€å±‚æ¬¡éåŽ†ï¼Œè¾“å‡ºå…¶åºåˆ—å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int data; int left, right; &#125; Node[maxn];int n, number[maxn], index = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].left); Node[root].data = number[index++]; inorder(Node[root].right);&#125;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int front = q.front(); q.pop(); cout &lt;&lt; Node[front].data; if(num &lt; n - 1) &#123; cout &lt;&lt; ' '; num++; &#125; if(Node[front].left != -1) q.push(Node[front].left); if(Node[front].right != -1) q.push(Node[front].right); &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int lchild, rchild; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; lchild &gt;&gt; rchild; Node[i].left = lchild, Node[i].right = rchild; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(0); levelorder(0); return 0;&#125; 1100 Mars NumbersAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1044ä¸€æ ·ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const*argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); string s; while(n--) &#123; string str; getline(cin, str); if('0' &lt;= str[0] &amp;&amp; str[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; str.length(); i++) &#123; num = num * 10 + (str[i] - '0'); &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[str] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1101 Quick SortAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1045ä¸€æ ·ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int n, array[MAXN], leftmax[MAXN], rightmin[MAXN], pivot[MAXN]; int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftmax[0] = array[0]; for(int i = 1; i &lt; n; i++) &#123; leftmax[i] = max(leftmax[i - 1], array[i - 1]); &#125; rightmin[n - 1] = 0x3fffffff; for(int i = n - 2; i &gt;= 0; i--) &#123; rightmin[i] = min(rightmin[i + 1], array[i + 1]); &#125; int count = 0; for(int i = 0; i &lt; n; i++) &#123; if(leftmax[i] &lt;= array[i] &amp;&amp; array[i] &lt;= rightmin[i]) &#123; pivot[count++] = array[i]; &#125; &#125; printf("%d\n", count); for(int i = 0; i &lt; count; i++) &#123; printf("%d", pivot[i]); if(i &lt; count - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1102 Invert a Binary TreeAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåè½¬è¿™ä¸ªäºŒå‰æ ‘å¹¶è¾“å‡ºåè½¬åŽçš„äºŒå‰æ ‘çš„ä¸­åºåºåˆ—å’Œå±‚åºåºåˆ—ã€‚ æœ¬é¢˜ä½¿ç”¨ç»“æž„æ•°ç»„å»ºæ ‘æ¯”è¾ƒæ–¹ä¾¿ï¼Œå¹¶ä¸”åè½¬æ—¶ç›´æŽ¥äº¤æ¢æ¯ä¸ªç»“ç‚¹çš„å·¦å³å­©å­æŒ‡é’ˆå³å¯ã€‚ç„¶åŽå†åˆ©ç”¨ä¸­åºéåŽ†å’Œå±‚åºéåŽ†ï¼Œè¾“å‡ºå¯¹åº”çš„åºåˆ—ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int data; int lchild, rchild;&#125; Node[15]; int n;bool isRoot[15] = &#123;false&#125;;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;node&gt; q; q.push(Node[root]); while(!q.empty()) &#123; node top = q.front(); q.pop(); printf("%d", top.data); if(num &lt; n - 1) &#123; printf(" "); num++; &#125; if(top.lchild != -1) q.push(Node[top.lchild]); if(top.rchild != -1) q.push(Node[top.rchild]); &#125; putchar('\n');&#125;int num2 = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].lchild); printf("%d", Node[root].data); if(num2 &lt; n - 1) &#123; printf(" "); num2++; &#125; inorder(Node[root].rchild);&#125;int getroot() &#123; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; ret = i; break; &#125; &#125; return ret;&#125;void invert() &#123; int i = 0; for(int i = 0; i &lt; n; i++) &#123; swap(Node[i].lchild, Node[i].rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); getchar(); char left, right; for(int i = 0; i &lt; n; i++) &#123; scanf("%c %c", &amp;left, &amp;right); getchar(); if(left != '-') &#123; Node[i].lchild = left - '0'; isRoot[left - '0'] = true; &#125; else Node[i].lchild = -1; if(right != '-') &#123; Node[i].rchild = right - '0'; isRoot[right - '0'] = true; &#125; else Node[i].rchild = -1; Node[i].data = i; &#125; int root = getroot(); invert(); levelorder(root); inorder(root); return 0;&#125; 1103 Integer FactorizationAnalysisé¢˜ç›®å¤§æ„ï¼Œç»™å®šä¸‰ä¸ªæ•°Nã€Kå’ŒPï¼Œå°†Nè¡¨ç¤ºä¸ºKä¸ªå› å­çš„Pæ¬¡æ–¹çš„è¿žåŠ ã€‚æ³¨æ„é¢˜ç›®çš„è¦æ±‚ï¼š å› å­ä¹‹å’Œå¿…é¡»æœ€å¤§ å› å­åºåˆ—æŒ‰å­—å…¸åºæœ€å¤§ ç”±äºŽå­˜åœ¨å¤šè§£çš„æƒ…å†µï¼Œæœ¬é¢˜éœ€è¦å€ŸåŠ© DFS æ¥æœç´¢æ‰€æœ‰è§£ï¼Œæ‰¾åˆ°ç¬¦åˆæ¡ä»¶çš„æœ€ä¼˜è§£ï¼Œå¯¹äºŽä¸Šè¿°ä¸¤ä¸ªé¢˜ç›®çš„è¦æ±‚ï¼Œå…¶å¯¹åº”çš„è§£å†³æ–¹æ³•ï¼š ä½¿ç”¨å…¨å±€å˜é‡ï¼Œè®°å½•æ¯ä¸ªè§£å’Œå…¶å› å­å’Œï¼Œé€‰æ‹©å› å­å’Œæœ€å¤§çš„ä¸ºæœ€ä¼˜è§£ å°†å› å­çš„Pæ¬¡æ–¹ä¾æ¬¡ç®—å¥½å­˜å‚¨åœ¨æ•°ç»„ä¸­ï¼Œç„¶åŽä»ŽåŽå¾€å‰æžšä¸¾å³å¯ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, k, p, maxFacsum = -1;vector&lt;int&gt; fac, ans, temp;int power(int x) &#123; int ret = 1; for(int i = 0; i &lt; p; i++) &#123; ret *= x; &#125; return ret;&#125;void init() &#123; int i = 0, temp = 0; while(temp &lt;= n) &#123; fac.push_back(temp); temp = power(++i); &#125;&#125;void DFS(int index, int nowK, int sum, int facSum) &#123; if(sum == n &amp;&amp; nowK == k) &#123; if(facSum &gt; maxFacsum) &#123; ans = temp; maxFacsum = facSum; &#125; return; &#125; if(sum &gt; n || nowK &gt; k) return; if(index - 1 &gt;= 0) &#123; temp.push_back(index); DFS(index, nowK + 1, sum + fac[index], facSum + index); temp.pop_back(); DFS(index - 1, nowK, sum, facSum); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;p); init(); DFS(fac.size() - 1, 0, 0, 0); if(maxFacsum == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%d = %d^%d", n, ans[0], p); for(int i = 1; i &lt; ans.size(); i++) &#123; printf(" + %d^%d", ans[i], p); &#125; &#125; return 0;&#125; 1104 Sum of Number SegmentsAnalysisæ­¤é¢˜ä¸Žä¹™çº§é¢˜åº“çš„1049ä¸€æ ·ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; int i = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1106 Lowest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;vector&lt;int&gt; child[maxn];int tot = 0, n, minDepth = maxn;double p, r;void DFS(int index, int depth) &#123; if(child[index].size() == 0) &#123; if(depth &lt; minDepth) &#123; minDepth = depth; tot = 1; &#125; else if(depth == minDepth) &#123; tot++; &#125; return; &#125; for(int i = 0; i &lt; child[index].size(); i++) &#123; DFS(child[index][i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100.0; int num, subchild; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf("%d", &amp;subchild); child[i].push_back(subchild); &#125; &#125; DFS(0, 0); double ans = p * pow(1 + r, minDepth); printf("%.4lf %d", ans, tot); return 0;&#125; 1107 Social ClustersAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int father[maxn], isroot[maxn] = &#123;0&#125;, hobby[maxn] = &#123;0&#125;;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = father[faB]; &#125;&#125;void init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main(int argc, char const *argv[]) &#123; int n, k, h; scanf("%d", &amp;n); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d:", &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;h); if(hobby[h] == 0) &#123; hobby[h] = i; &#125; Union(i, hobby[h]); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; isroot[findFather(i)]++; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; if(isroot[i] != 0) &#123; ans++; &#125; &#125; printf("%d\n", ans); sort(isroot + 1, isroot + n + 1, cmp); for(int i = 1; i &lt;= ans; i++) &#123; printf("%d", isroot[i]); if(i &lt; ans) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gitç®€æ˜“æŒ‡å—]]></title>
    <url>%2F2019%2F06%2F23%2FGit%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[IntroGit æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œè€Œ Github åˆ™æ˜¯ç›®å‰å…¨çƒæœ€å¤§çš„å¼€æºç¤¾åŒºï¼Œé‚£ä¹ˆä½•è°“â€œç‰ˆæœ¬æŽ§åˆ¶â€ï¼Ÿç‰ˆæœ¬æŽ§åˆ¶æ˜¯ä¸€ç§è®°å½•ä¸€ä¸ªæˆ–è‹¥å¹²æ–‡ä»¶å†…å®¹å˜åŒ–ï¼Œä»¥ä¾¿å°†æ¥æŸ¥é˜…ç‰¹å®šç‰ˆæœ¬ä¿®è®¢æƒ…å†µçš„ç³»ç»Ÿï¼Œä½¿ç”¨Gitå¯ä»¥å¯¹ä»»ä½•ç±»åž‹çš„æ–‡ä»¶è¿›è¡Œç‰ˆæœ¬æŽ§åˆ¶ã€‚ ä¸åŒäºŽæœ¬åœ°ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿå’Œé›†ä¸­å¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œåˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„ä¼˜ç‚¹åœ¨äºŽå…¶å¯¹æ–‡ä»¶ä¸¢å¤±é£Žé™©çš„è§„é¿èƒ½åŠ›ã€‚ç®€è€Œè¨€ä¹‹ï¼Œåˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿä¸­çš„æ¯ä¸ªå®¢æˆ·ç«¯ï¼Œéƒ½å…·æœ‰å®Œæ•´çš„æ–‡ä»¶ï¼Œå³åŽŸå§‹ä»“åº“çš„é•œåƒã€‚ Basic Conceptionåœ¨å¼€å§‹ç›´æŽ¥ä½¿ç”¨ Git ä¹‹å‰ï¼Œå¾—å…ˆäº†è§£ä¸€ä¸‹ Git å†…çš„åŸºæœ¬æ¦‚å¿µðŸ§ï¼Œäº†è§£è¿™äº›æ¦‚å¿µä¼šæ›´å¥½çš„ç†è§£ Git çš„å·¥ä½œæ–¹å¼å’ŒåŽŸç†ã€‚ Snapshots, Not Differenceså¦‚æ ‡é¢˜æ‰€è¨€ï¼Œï¼ˆè®°å½•ï¼‰å¿«ç…§ï¼Œè€Œä¸æ˜¯å·®å¼‚ã€‚ä¸åŒäºŽå…¶ä»–ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„å·®å¼‚æ¯”è¾ƒï¼ŒGit ä¼šå°†æ–‡ä»¶è§†ä½œâ€œå¿«ç…§â€ï¼Œæ¯æ¬¡æäº¤æ›´æ–°åŽï¼ŒGit ä¼šå¯¹ä¹‹å‰çš„æ–‡ä»¶åˆ¶ä½œä¸€ä¸ªå¿«ç…§å¹¶ä¿å­˜è¿™ä¸ªå¿«ç…§çš„ç´¢å¼•ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼ŒGit ä¼šå°†æ›´æ–°åŽçš„æ–‡ä»¶æ›¿æ¢æŽ‰ä¹‹å‰æ–‡ä»¶ï¼ŒåŒæ—¶ï¼ŒGit ä¸å†é‡æ–°å­˜å‚¨è¯¥æ–‡ä»¶ï¼Œè€Œæ˜¯åªä¿ç•™ä¸€ä¸ªé“¾æŽ¥æŒ‡å‘ä¹‹å‰å­˜å‚¨çš„æ–‡ä»¶ï¼ˆå¿«ç…§ï¼‰ã€‚ Nearly Every Operation Is Localåœ¨ Git ä¸­çš„ç»å¤§å¤šæ•°æ“ä½œéƒ½åªéœ€è¦è®¿é—®æœ¬åœ°æ–‡ä»¶å’Œèµ„æºï¼Œä¸€èˆ¬ä¸éœ€è¦æ¥è‡ªç½‘ç»œä¸Šå…¶ä»–è®¡ç®—æœºçš„ä¿¡æ¯ã€‚å› ä¸ºï¼Œåœ¨æœ¬åœ°ä¿å­˜ç€è¿™ä¸ªé¡¹ç›®æ–‡ä»¶çš„é•œåƒï¼Œä½ å¯ä»¥ç¦»çº¿è¿›è¡Œæäº¤ï¼Œå¹¶åœ¨ç½‘ç»œçŠ¶æ€è‰¯å¥½çš„æ—¶å€™ï¼Œåœ¨æŽ¨é€åˆ°ä¸»æœåŠ¡å™¨ä¸Šã€‚ The Three StatesGit æœ‰ä¸‰ç§çŠ¶æ€ï¼Œæœ¬åœ°ä»“åº“å†…çš„æ–‡ä»¶å¯èƒ½å¤„äºŽå…¶ä¸­ä¹‹ä¸€ï¼šå·²æäº¤ï¼ˆcommittedï¼‰ã€å·²ä¿®æ”¹ï¼ˆmodifiedï¼‰å’Œå·²æš‚å­˜ï¼ˆstagedï¼‰ã€‚å·²æäº¤å·²ä¿®æ”¹å·²æš‚å­˜æ•°æ®å·²ç»å®‰å…¨çš„ä¿å­˜åœ¨æœ¬åœ°æ•°æ®åº“ä¸­ã€‚ä¿®æ”¹äº†æ–‡ä»¶ï¼Œä½†è¿˜æ²¡ä¿å­˜åˆ°æ•°æ®åº“ä¸­ã€‚å¯¹ä¸€ä¸ªå·²ä¿®æ”¹æ–‡ä»¶çš„å½“å‰ç‰ˆæœ¬åšäº†æ ‡è®°ï¼Œä½¿ä¹‹åŒ…å«åœ¨ä¸‹æ¬¡æäº¤çš„å¿«ç…§ä¸­ã€‚ ç”±æ­¤å¼•å…¥ Git é¡¹ç›®çš„ä¸‰ä¸ªå·¥ä½œåŒºåŸŸçš„æ¦‚å¿µï¼šGit ä»“åº“ã€å·¥ä½œç›®å½•åŠæš‚å­˜åŒºåŸŸã€‚ Git ä»“åº“å·¥ä½œç›®å½•æš‚å­˜åŒºåŸŸGit ç”¨æ¥ä¿å­˜é¡¹ç›®çš„å…ƒæ•°æ®å’Œå¯¹è±¡æ•°æ®åº“çš„åœ°æ–¹ï¼Œä»Žå…¶ä»–è®¡ç®—æœºå…‹éš†ä»“åº“æ—¶ï¼Œæ‹·è´çš„å°±æ˜¯è¿™é‡Œçš„æ•°æ®ã€‚å¯¹é¡¹ç›®çš„æŸä¸ªç‰ˆæœ¬ç‹¬ç«‹æå–å‡ºæ¥çš„å†…å®¹ï¼Œè¿™äº›ä»Ž Git ä»“åº“çš„åŽ‹ç¼©æ•°æ®ä¸­æå–å‡ºæ¥çš„æ–‡ä»¶ï¼Œæ”¾åœ¨ç£ç›˜ä¸Šä¾›ç”¨æˆ·ä½¿ç”¨æˆ–ä¿®æ”¹ã€‚æš‚å­˜åŒºåŸŸæ˜¯ä¸€ä¸ªæ–‡ä»¶ï¼Œä¿å­˜äº†ä¸‹æ¬¡å°†æäº¤çš„æ–‡ä»¶åˆ—è¡¨ä¿¡æ¯ï¼Œä¸€èˆ¬åœ¨ Git ä»“åº“ç›®å½•ä¸­ï¼Œæœ‰æ—¶ä¹Ÿè¢«ç§°ä½œâ€œç´¢å¼•â€ã€‚ åŸºæœ¬çš„ Git å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š åœ¨å·¥ä½œç›®å½•ä¸­ä¿®æ”¹æ–‡ä»¶ æš‚å­˜æ–‡ä»¶ï¼Œå°†æ–‡ä»¶çš„å¿«ç…§æ”¾å…¥æš‚å­˜åŒºåŸŸ æäº¤æ›´æ–°ï¼Œæ‰¾åˆ°æš‚å­˜åŒºåŸŸçš„æ–‡ä»¶ï¼Œå°†å¿«ç…§æ°¸ä¹…æ€§å­˜å‚¨åˆ° Git ä»“åº“å†… How to useGit æœ‰å¤šç§ä½¿ç”¨æ–¹å¼ï¼Œå¯ä»¥ä½¿ç”¨åŽŸç”Ÿçš„å‘½ä»¤è¡Œæ¨¡å¼ï¼ˆæŽ¨èï¼‰ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨ GUI æ¨¡å¼ï¼Œä½†åªæœ‰åœ¨å‘½ä»¤è¡Œæ¨¡å¼ä¸‹ï¼Œæ‰å¯ä»¥æ‰§è¡Œ Git çš„æ‰€æœ‰å‘½ä»¤ã€‚ Installing Gité’ˆå¯¹ä¸åŒçš„æ“ä½œç³»ç»Ÿï¼ŒGit çš„å®‰è£…æ–¹æ³•ä¹Ÿä¸ç›¸åŒï¼Œå¯¹äºŽçŽ°åœ¨æ¯”è¾ƒæˆç†Ÿçš„ Git è€Œè¨€ï¼Œä¸åŒå®‰è£…æ–¹å¼æ‰€å¸¦æ¥çš„åŠŸèƒ½ä¸Šçš„å·®å¼‚å·²ç»ä¸æ˜¯é‚£ä¹ˆæ˜Žæ˜¾ã€‚å¯¹äºŽWindowsç”¨æˆ·è€Œè¨€ï¼Œåœ¨ Git å®˜ç½‘ä¸Šä¸‹è½½åŽå®‰è£…å³å¯ã€‚å…¶ä»–æ–¹å¼è¿™é‡Œä¸å†åšè¿‡å¤šä»‹ç»ã€‚ First-Time Git Setupå®‰è£…å¥½äº† Git ä¹‹åŽï¼Œéœ€è¦å¯¹ Git çŽ¯å¢ƒåšå®šé‡çš„å®šåˆ¶åŒ–æ“ä½œï¼Œæ¯å°è®¡ç®—æœºä¸Šåªç”¨é…ç½®ä¸€æ¬¡ï¼Œç¨‹åºå‡çº§æ—¶ä¼šä¿ç•™é…ç½®ä¿¡æ¯ï¼Œä¹Ÿå¯ä»¥åœ¨ä»»ä½•æ—¶å€™å†æ¬¡é€šè¿‡è¿è¡Œå‘½ä»¤æ¥ä¿®æ”¹å®ƒä»¬ã€‚ User Identityå½“å®‰è£…å®Œ Git åŽåº”è¯¥åšçš„ç¬¬ä¸€ä»¶äº‹å°±æ˜¯è®¾ç½®ä½ çš„ç”¨æˆ·åç§°ä¸Žé‚®ä»¶åœ°å€ï¼ŒåŽé¢çš„æ¯ä¸€æ¬¡æäº¤éƒ½ä¼šä½¿ç”¨è¿™äº›ä¿¡æ¯ï¼Œå¹¶ä¸”å®ƒä¼šå†™å…¥åˆ°ä½ çš„æ¯ä¸€æ¬¡æäº¤ä¸­ï¼Œä¸å¯æ›´æ”¹ã€‚12$ git config --global user.name "Bachzart"$ git config --global user.email "whistlesilp@gmail.com" å¦‚æžœä½¿ç”¨äº†--globalé€‰é¡¹ï¼Œé‚£ä¹ˆè¯¥å‘½ä»¤åªéœ€è¦è¿è¡Œä¸€æ¬¡ï¼Œå› ä¸ºä¹‹åŽæ— è®ºåšä»»ä½•äº‹æƒ…ï¼ŒGit éƒ½ä¼šä½¿ç”¨é‚£äº›ä¿¡æ¯ã€‚è‹¥åƒé’ˆå¯¹ç‰¹å®šé¡¹ç›®ä½¿ç”¨ä¸åŒçš„ç”¨æˆ·åç§°ä¸Žé‚®ä»¶åœ°å€æ—¶ï¼Œå¯ä»¥åœ¨é‚£ä¸ªé¡¹ç›®ç›®å½•ä¸‹è¿è¡Œæ²¡æœ‰--globalé€‰é¡¹çš„å‘½ä»¤æ¥é…ç½®ã€‚ User Editorç”¨æˆ·ä¿¡æ¯è®¾ç½®å®Œæ¯•åŽï¼Œå¯ä»¥é…ç½®é»˜è®¤æ–‡æœ¬ç¼–è¾‘å™¨ï¼Œå½“ Git éœ€è¦ä½ è¾“å…¥ä¿¡æ¯æ—¶ä¼šè°ƒç”¨å®ƒã€‚å¦‚æžœæœªé…ç½®ï¼ŒGit ä¼šä½¿ç”¨æ“ä½œç³»ç»Ÿé»˜è®¤çš„æ–‡æœ¬ç¼–è¾‘å™¨ã€‚1$ git config --gloabl core.editor emacs Checkingå¦‚ä½•æ£€æŸ¥ Git é…ç½®ä¿¡æ¯å‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥åˆ—å‡ºåœ¨å½“å‰ç›®å½•ä¸‹ Git èƒ½æ‰¾åˆ°çš„æ‰€æœ‰é…ç½®ä¿¡æ¯ã€‚1$ git config --list å¯ä»¥å¾—åˆ°å¦‚ä¸‹æ‰€ç¤ºç»“æžœï¼š12345678910111213141516171819core.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslcainfo=D:/Git/Git/mingw64/ssl/certs/ca-bundle.crthttp.sslbackend=openssldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecredential.helper=manageruser.name=Bachzartuser.email=whistlesilp@gmail.com Getting HelpGit è‡ªå¸¦æœ‰è¯´æ˜Žæ–‡æ¡£ï¼Œå¯ä»¥ç›´æŽ¥ä½¿ç”¨ä»¥ä¸‹ä¸‰ä¸ªå‘½ä»¤æŸ¥æ‰¾æŒ‡å®šå‘½ä»¤çš„ä½¿ç”¨è¯´æ˜Žï¼Œæˆ–ç™¾åº¦ã€googleã€‚123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; è‹¥æƒ³èŽ·å¾—configå‘½ä»¤çš„æ‰‹å†Œï¼Œæ‰§è¡Œ1$ git help config Summaryä¸Šé¢çš„å†…å®¹ä»‹ç»äº† Git æ˜¯ä»€ä¹ˆï¼ŒGit å’Œå…¶ä»–ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿçš„åŒºåˆ«å’ŒåŸºæœ¬ç”¨æ³•ç­‰ï¼ŒæŽ¥ä¸‹æ¥å°±å¼€å§‹ä½¿ç”¨å§~ Basic Usageåœ¨ç†Ÿæ‚‰äº† Git çš„åŸºæœ¬æ¦‚å¿µå’Œç”¨æ³•åŽï¼Œå°±å¯ä»¥å¼€å§‹ä½¿ç”¨äº†ã€‚ Getting a Git RepositoryèŽ·å– Git é¡¹ç›®ä»“åº“çš„æ–¹æ³•æœ‰ä¸¤ç§ï¼š åœ¨çŽ°æœ‰é¡¹ç›®æˆ–ç›®å½•ä¸‹å¯¼å…¥æ‰€æœ‰æ–‡ä»¶åˆ° Git ä¸­ ä»Žä¸€ä¸ªæœåŠ¡å™¨å…‹éš†çŽ°æœ‰çš„ Git ä»“åº“ Initializing a Repository in an Existing Directoryå¦‚æžœåªæƒ³åœ¨æœ¬åœ°é€šè¿‡ Git æ¥è¿›è¡Œç‰ˆæœ¬æŽ§åˆ¶ï¼Œé‚£ä¹ˆåœ¨bashå†…è¿›å…¥åˆ°æƒ³è¦å»ºç«‹ä»“åº“çš„ç›®å½•ï¼Œé€šè¿‡ä»¥ä¸‹å‘½ä»¤å°±å¯ä»¥å»ºç«‹ä¸€ä¸ªä»“åº“äº†ã€‚1$ git init æ­¤æ—¶ï¼Œåœ¨è¿™ä¸ªæœ¬åœ°ç›®å½•ä¸‹ä¼šè‡ªåŠ¨äº§ç”Ÿä¸€ä¸ªâ€œ.gitâ€çš„ç›®å½•ï¼Œè¿™ä¸ªå°±æ˜¯ Git ç®¡ç†ä¿¡æ¯çš„ç›®å½•ï¼Œåœ¨ Windows ä¸‹é»˜è®¤éšè—ã€‚ Cloning an Existing Repositoryå¦‚æžœåªæ˜¯æƒ³èŽ·å–ä¸€ä»½ç½‘ç»œä¸Šï¼ˆæˆ–å±€åŸŸç½‘æœåŠ¡å™¨ï¼‰å·²å­˜åœ¨çš„ Git ä»“åº“çš„æ‹·è´ï¼Œé‚£ä¹ˆå¯ä»¥ä½¿ç”¨ä»¥ä¸‹å‘½ä»¤æ¥å°†ä»“åº“å…‹éš†åˆ°æœ¬åœ°ã€‚1$ git clone https://github.com/example ä¸Šè¿°å‘½ä»¤çš„æ ¼å¼ä¸ºgit clone [url]ï¼Œhttps://github.com/exampleè¿™ä¸ªurlå¹¶ä¸æ˜¯çœŸæ­£çš„å­˜åœ¨ï¼Œè¿™é‡Œåªåšè¯´æ˜Žä½¿ç”¨ã€‚ æ­¤æ—¶åœ¨å½“å‰ç›®å½•ä¸‹ä¼šåˆ›å»ºä¸€ä¸ªâ€œexampleâ€çš„ç›®å½•ï¼Œå¹¶åœ¨è¿™ä¸ªç›®å½•ä¸‹åˆå§‹åŒ–ä¸€ä¸ª.gitç›®å½•ï¼Œä»Žè¿œç¨‹ä»“åº“æ‹‰å–ä¸‹æ‰€æœ‰æ•°æ®æ”¾å…¥.gitç›®å½•ï¼Œç„¶åŽä»Žä¸­è¯»å–æœ€æ–°ç‰ˆæœ¬çš„æ–‡ä»¶æ‹·è´ã€‚å¦‚æžœæƒ³é‡å‘½åå…‹éš†ä¸‹æ¥çš„æœ¬åœ°ä»“åº“çš„åå­—ï¼Œå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤ï¼š1$ git clone https://github.com/example myexample Local Repositoryå‰é¢å·²ç»æåˆ°äº†å¦‚ä½•åœ¨æœ¬åœ°åˆ›å»º Git ä»“åº“ï¼ŒçŽ°åœ¨æ¥ä½¿ç”¨ä¸€ä¸‹ Git çš„éƒ¨åˆ†åŠŸèƒ½ã€‚ Checking the Status of Local Reposityè¦æŸ¥çœ‹å½“å‰ç›®å½•ä¸‹å“ªäº›æ–‡ä»¶å¤„äºŽä»€ä¹ˆçŠ¶æ€ï¼Œå¯ä»¥ä½¿ç”¨git statusã€‚ä»¥åœ¨æœ¬åœ°æ–°å»ºçš„ä»“åº“ä¸ºä¾‹ï¼Œå½“ä½¿ç”¨git statuså‘½ä»¤æ—¶ï¼Œä¼šå‡ºçŽ°å¦‚ä¸‹ç»“æžœï¼š1234$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track) æ ¹æ®æ˜¾ç¤ºçš„è‹±æ–‡çš„å«ä¹‰ï¼Œå¯ä»¥å¾—çŸ¥å½“å‰ç›®å½•ä¸‹ï¼Œæ²¡æœ‰æ–‡ä»¶ï¼Œä¹Ÿæ— æ³•è¿›è¡Œæäº¤ï¼Œå¯ä»¥ä½¿ç”¨git addå‘½ä»¤æ¥è·Ÿè¸ªæ–‡ä»¶ã€‚ Tracking a new fileçŽ°åœ¨ï¼Œåœ¨ä»“åº“å†…åˆ›å»ºä¸€ä¸ªæ–°çš„test.cæ–‡ä»¶ï¼Œåœ¨ä½¿ç”¨git statuså‘½ä»¤æ¥æŸ¥çœ‹å½“å‰ç›®å½•çš„çŠ¶æ€ã€‚123456789$ git statusOn branch masterNo commits yetUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.cnothing added to commit but untracked files present (use "git add" to track) æ­¤æ—¶ï¼Œåœ¨Untracked filesä¸‹é¢ï¼Œå‡ºçŽ°äº†test.cæ–‡ä»¶ï¼Œè¿™æ„å‘³ç€ Git åœ¨ä¹‹å‰çš„å¿«ç…§ï¼ˆæäº¤ï¼‰ä¸­æ²¡æœ‰è¿™äº›æ–‡ä»¶ï¼ˆå®žé™…ä¸Šï¼Œç›®å‰è¿˜æ²¡æœ‰ä¸€æ¬¡æäº¤ï¼‰ã€‚Gitä¸ä¼šè‡ªåŠ¨å°†æ–‡ä»¶çº³å…¥è·Ÿè¸ªèŒƒå›´ï¼Œæ‰€ä»¥éœ€è¦ä½¿ç”¨git add [file name]å‘½ä»¤æ¥è·Ÿè¸ªæŒ‡å®šæ–‡ä»¶ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c æ­¤æ—¶ï¼Œå¯ä»¥çœ‹åˆ°Changes to be committedè¿™è¡Œä¸‹ï¼Œå­˜åœ¨new file: test.cï¼Œå°±è¯´æ˜Žtest.cæ–‡ä»¶æ˜¯å·²æš‚å­˜çŠ¶æ€ï¼ˆstagedï¼‰äº†ã€‚å¦å¤–ï¼Œgit addå‘½ä»¤ä½¿ç”¨æ–‡ä»¶æˆ–ç›®å½•çš„è·¯å¾„ä½œä¸ºå‚æ•°ï¼›å¦‚æžœå‚æ•°æ˜¯ç›®å½•çš„è·¯å¾„ï¼Œè¯¥å‘½ä»¤å°†é€’å½’åœ°è·Ÿè¸ªè¯¥ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ã€‚ Staging Modified Filesç´§æŽ¥ä¸Šé¢çš„æ­¥éª¤ï¼Œè‹¥æ­¤æ—¶ï¼Œä¿®æ”¹äº†å·²æš‚å­˜çš„test.cæ–‡ä»¶ï¼Œæ­¤æ—¶ä½¿ç”¨git statuså‘½ä»¤ï¼Œä¼šçœ‹åˆ°å¦‚ä¸‹ç»“æžœï¼š123456789101112On branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.cChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: test.c è¿™å®žé™…ä¸Šå°±æ˜¯ Git çš„ç‰ˆæœ¬æŽ§åˆ¶æœºåˆ¶çš„ç‰¹ç‚¹â€”ä¿å­˜æ–‡ä»¶çš„å¿«ç…§è€Œä¸æ˜¯å·®å¼‚ã€‚ä¹Ÿå³æ˜¯è¯´ï¼ŒçŽ°åœ¨ Git æš‚å­˜åŒºåŸŸå†…å­˜å‚¨çš„æ–‡ä»¶æ˜¯ä»æœªä¿®æ”¹çš„test.cï¼Œè¦æš‚å­˜è¿™æ¬¡æ›´æ–°ï¼Œéœ€è¦å†æ¬¡ä½¿ç”¨git addå‘½ä»¤æ¥å®Œæˆæš‚å­˜ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c git statuså‘½ä»¤çš„è¾“å‡ºååˆ†è¯¦ç»†ï¼Œä½¿ç”¨git status -sæˆ–git status --shortå¯ä»¥å¾—åˆ°æ›´åŠ ç´§å‡‘çš„ä¿¡æ¯ï¼š1234$ git status -sA change.cAM test.c?? test.exe æ–°æ·»åŠ çš„æœªè·Ÿè¸ªæ–‡ä»¶å‰é¢æœ‰??æ ‡è®°ï¼Œæ–°æ·»åŠ åˆ°æš‚å­˜åŒºåŸŸçš„æ–‡ä»¶å‰é¢æœ‰Aæ ‡è®°ï¼Œä¿®æ”¹è¿‡çš„æ–‡ä»¶å‰é¢æœ‰Mæ ‡è®°ï¼›å½“ç„¶ï¼ŒMçš„æœ‰ä¸¤ä¸ªå¯èƒ½çš„å‡ºçŽ°ä½ç½®ï¼Œå‡ºçŽ°åœ¨å³è¾¹çš„Mè¡¨ç¤ºè¯¥æ–‡ä»¶è¢«ä¿®æ”¹äº†ä½†æ˜¯è¿˜æ²¡æ”¾å…¥æš‚å­˜åŒºï¼Œå‡ºçŽ°åœ¨å·¦è¾¹çš„Mè¡¨ç¤ºè¯¥æ–‡ä»¶è¢«ä¿®æ”¹å¹¶æ”¾å…¥äº†æš‚å­˜åŒºã€‚ä¾‹å¦‚ï¼Œä¸Šé¢çš„çŠ¶æ€æ˜¾ç¤ºtest.cæ–‡ä»¶åœ¨å·¥ä½œåŒºè¢«ä¿®æ”¹äº†ï¼Œè¿˜æœªæ”¾å…¥æš‚å­˜åŒºã€‚ Ignoring Filesä¸€èˆ¬æ€»ä¼šæœ‰äº›æ–‡ä»¶æ— éœ€çº³å…¥ Git çš„ç®¡ç†ï¼Œä¹Ÿä¸å¸Œæœ›å®ƒä»¬æ€»å‡ºçŽ°åœ¨æœªè·Ÿè¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œé€šå¸¸è¿™ç±»æ–‡ä»¶éƒ½æ˜¯äº›è‡ªåŠ¨ç”Ÿæˆçš„æ–‡ä»¶ï¼Œæ¯”å¦‚æ—¥å¿—æ–‡ä»¶ï¼Œæˆ–è€…ç¼–è¯‘è¿‡ç¨‹ä¸­åˆ›å»ºçš„ä¸´æ—¶æ–‡ä»¶ç­‰ã€‚æ­¤æ—¶ï¼Œå¯ä»¥åˆ›å»ºä¸€ä¸ªåä¸º.gitignoreçš„æ–‡ä»¶ï¼Œåˆ—å‡ºè¦å¿½ç•¥çš„æ–‡ä»¶æ¨¡å¼ã€‚12345$ vim .gitignore*.[oa]*~*.exe*.txt .gitignoreæ–‡ä»¶çš„æ ¼å¼è§„èŒƒå¦‚ä¸‹ï¼š æ‰€æœ‰ç©ºè¡Œæˆ–è€…ä»¥#å¼€å¤´çš„è¡Œéƒ½ä¼šè¢« Git å¿½ç•¥ å¯ä»¥ä½¿ç”¨æ ‡å‡†çš„ glob æ¨¡å¼åŒ¹é… åŒ¹é…æ¨¡å¼å¯ä»¥ä»¥/å¼€å¤´é˜²æ­¢é€’å½’ åŒ¹é…æ¨¡å¼å¯ä»¥ä»¥/ç»“å°¾æŒ‡å®šç›®å½• è¦å¿½ç•¥æŒ‡å®šæ¨¡å¼ä»¥å¤–çš„æ–‡ä»¶æˆ–ç›®å½•ï¼Œå¯ä»¥åœ¨æ¨¡å¼å‰åŠ ä¸ŠæƒŠå¹å·!å–å æ‰€è°“çš„ glob æ¨¡å¼æ˜¯æŒ‡ shell æ‰€ä½¿ç”¨çš„ç®€åŒ–äº†çš„æ­£åˆ™è¡¨è¾¾å¼ï¼Œæ¯”å¦‚*å°±å¯ä»¥åŒ¹é…é›¶ä¸ªæˆ–å¤šä¸ªä»»æ„å­—ç¬¦ã€‚ TIPSï¼šGitHubæœ‰ä¸€ä¸ªååˆ†è¯¦ç»†çš„é’ˆå¯¹æ•°åç§é¡¹ç›®åŠè¯­è¨€çš„.gitignoreæ–‡ä»¶åˆ—è¡¨ï¼Œå¯ä»¥è®¿é—® https://github.com/github/gitignore èŽ·å–æ›´å¤šå¸®åŠ©ã€‚ Viewing Changesgit statuså‘½ä»¤è¾“å‡ºçš„ä¿¡æ¯åªå¯¹æ–‡ä»¶æ‰€å¤„çš„çŠ¶æ€è¿›è¡Œäº†å±•ç¤ºï¼Œå¯èƒ½è§‰å¾—æ¨¡ç³Šï¼Œå¦‚æžœæƒ³çŸ¥é“å…·ä½“æ”¹äº†ä»€ä¹ˆåœ°æ–¹ï¼Œå¯ä»¥ä½¿ç”¨git diffå‘½ä»¤ã€‚git diffå‘½ä»¤ä¼šå›žç­”ä¸¤ä¸ªé—®é¢˜ï¼š å½“å‰åšçš„é‚£äº›æ›´æ–°è¿˜æ²¡æœ‰æš‚å­˜ï¼Ÿ æœ‰å“ªäº›æ›´æ–°å·²ç»æš‚å­˜èµ·æ¥å‡†å¤‡å¥½äº†ä¸‹æ¬¡æäº¤ï¼Ÿ git diffä¼šé€šè¿‡æ–‡ä»¶è¡¥ä¸çš„æ ¼å¼åœ¨ç›¸åº”æ ä¸‹æ˜¾ç¤ºå…·ä½“å“ªäº›è¡Œå‘ç”Ÿäº†æ”¹å˜ã€‚çŽ°åœ¨ä¿®æ”¹test.cæ–‡ä»¶ï¼Œåœ¨æ–‡ä»¶ä¸­åŠ å…¥å¦‚ä¸‹ä¸€è¡Œï¼štest.c12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0;&#125; æŽ¥ä¸‹æ¥ï¼Œä½¿ç”¨git diffå‘½ä»¤æŸ¥çœ‹ä¿®æ”¹çš„éƒ¨åˆ†ï¼š12345678910111213$ git diffdiff --git a/test.c b/test.cindex e0e5171..8642431 100644--- a/test.c+++ b/test.c@@ -3,5 +3,6 @@ int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0; &#125;\ No newline at end of file å¯ä»¥çœ‹åˆ°ï¼ŒGit å›žæ˜¾äº†æ–‡ä»¶æ›´æ–°åŒºåŸŸçš„ä¿¡æ¯ä»¥åŠå¯¹åº”çš„æ›´æ–°å†…å®¹ï¼Œè€Œæ­¤æ—¶ï¼Œgit diffæ¯”è¾ƒçš„æ˜¯å·¥ä½œç›®å½•ä¸­å½“å‰æ–‡ä»¶ï¼ˆæœªæš‚å­˜ï¼‰å’Œæš‚å­˜åŒºåŸŸå¿«ç…§ï¼ˆå·²æš‚å­˜ï¼‰ä¹‹é—´çš„å·®å¼‚ï¼Œä¹Ÿå°±æ˜¯ä¿®æ”¹ä¹‹åŽè¿˜æ²¡æš‚å­˜èµ·æ¥çš„å˜åŒ–å†…å®¹ã€‚ ä½¿ç”¨git diff --cached/git diff --stagedå¯ä»¥æŸ¥çœ‹å·²æš‚å­˜çš„å°†è¦æ·»åŠ åˆ°ä¸‹æ¬¡æäº¤é‡Œçš„å†…å®¹ã€‚123456789101112131415$ git diff --cacheddiff --git a/test.c b/test.cnew file mode 100644index 0000000..e0e5171--- /dev/null+++ b/test.c@@ -0,0 +1,7 @@+#include &lt;stdio.h&gt;++int main(int argc, char const *argv[]) &#123;+ printf("Hello Git!\n");+ printf("I want to change this file.\n");+ return 0;+&#125;\ No newline at end of file æ³¨æ„åˆ°ä¸Šé¢å¹¶æ²¡æœ‰printf(&quot;Test git diff!\n&quot;);ï¼Œé‚£æ˜¯å› ä¸ºï¼Œæ›´æ–°åŽçš„test.cæ–‡ä»¶å¹¶æ²¡æœ‰æš‚å­˜ã€‚å¦å¤–ï¼Œgit diffåªèƒ½æ˜¾ç¤ºå°šæœªæš‚å­˜çš„æ”¹åŠ¨ï¼Œè€Œä¸æ˜¯è‡ªä¸Šæ¬¡æäº¤ï¼ˆcommitï¼‰ä»¥æ¥æ‰€ä½œçš„æ‰€æœ‰æ”¹åŠ¨ã€‚ Committing ChangesçŽ°åœ¨çš„æš‚å­˜åŒºä¸Žå·²ç»æ‘¸ç†Ÿäº†ï¼Œå¯ä»¥æ¥æ„‰å¿«çš„æäº¤äº†ðŸ˜Šï¼Œä¸è¿‡æ­£å¼ä½¿ç”¨ä»“åº“çš„æ—¶å€™ï¼Œæäº¤ä¹‹å‰æœ€å¥½çœ‹çœ‹æœ‰æ²¡æœ‰ä»€ä¹ˆè®°å½•æ²¡æœ‰æš‚å­˜èµ·æ¥ï¼Œå¯ä»¥å…ˆç”¨git statuså‘½ä»¤çœ‹ä¸‹ï¼Œæ˜¯ä¸æ˜¯éƒ½å·²æš‚å­˜èµ·æ¥äº†ï¼Œç„¶åŽè¿è¡Œæäº¤å‘½ä»¤ï¼š1$ git commit æäº¤åŽï¼Œä¼šè·³å…¥åˆ° vi/vim ç¼–è¾‘å™¨ç•Œé¢ï¼ˆä¸åŒç³»ç»Ÿå¯èƒ½ä¸ä¸€è‡´ï¼‰ï¼ŒåŸºæœ¬ä¸Šéƒ½æ˜¯é»˜è®¤çš„æäº¤æ¶ˆæ¯ï¼Œä¿å­˜åœ¨.gitç›®å½•ä¸‹çš„COMMIT_EDITMSGæ–‡ä»¶å†…ï¼Œå¼€å¤´çš„ç©ºè¡Œç”¨æ¥é”®å…¥æäº¤è¯´æ˜Žï¼Œå…¶ä»–#å¼€å¤´çš„éƒ½æ˜¯æ³¨é‡Šï¼ŒåŽ»æŽ‰ä¸Žå¦å–å†³äºŽä¸ªäººï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å¦‚ä¸‹å‘½ä»¤æ¥ç®€åŒ–æäº¤ï¼š123456$ git commit -m "Test Commit"[master (root-commit) 88ba107] Test Commit 3 files changed, 18 insertions(+) create mode 100644 .gitignore create mode 100644 change.c create mode 100644 test.c æ³¨æ„ï¼Œmasterè¡¨ç¤ºå½“å‰æäº¤æ˜¯åœ¨masteråˆ†æ”¯è¿›è¡Œçš„æäº¤ï¼Œ88ba107å°±æ˜¯æœ¬æ¬¡æäº¤çš„å®Œæ•´ SHA-1 æ ¡éªŒå’Œï¼Œä¸‹é¢çš„ä¿¡æ¯è¡¨ç¤ºæœ¬æ¬¡æäº¤ä¸­ï¼Œæœ‰å¤šå°‘æ–‡ä»¶ä¿®è®¢è¿‡ï¼Œå¤šå°‘è¡Œæ·»åŠ å’Œä¿®æ”¹è¿‡ã€‚ ä½¿ç”¨git commit -aå¯ä»¥è·³è¿‡æäº¤ä¹‹å‰å…ˆä½¿ç”¨git addæš‚å­˜æ–‡ä»¶ï¼ˆè¿™äº›æ–‡ä»¶å¿…é¡»å·²ç»è¢«æš‚å­˜è¿‡ï¼‰çš„æ­¥éª¤è€Œç›´æŽ¥æäº¤ã€‚ Removing Filesè¦ä»Ž Git ä¸­ç§»é™¤æŸä¸ªæ–‡ä»¶ï¼Œå°±å¿…é¡»è¦ä»Žå·²è·Ÿè¸ªæ–‡ä»¶æ¸…å•ä¸­ç§»é™¤ï¼ˆç¡®åˆ‡åœ°è¯´ï¼Œæ˜¯ä»Žæš‚å­˜åŒºåŸŸï¼‰ï¼Œç„¶åŽæäº¤ã€‚å¯ä»¥ä½¿ç”¨git rmå‘½ä»¤å®Œæˆæ­¤é¡¹å·¥ä½œï¼Œå¹¶è¿žå¸¦çš„ä»Žå·¥ä½œç›®å½•ä¸­åˆ é™¤æŒ‡å®šçš„æ–‡ä»¶ï¼Œè¿™æ ·ä»¥åŽå°±ä¸ä¼šå‡ºçŽ°åœ¨æœªè·Ÿè¸ªæ–‡ä»¶æ¸…å•ä¸­äº†ã€‚ å¦‚æžœåªæ˜¯ç®€å•åœ°ä»Žå·¥ä½œç›®å½•ä¸­æ‰‹å·¥åˆ é™¤æ–‡ä»¶ï¼Œè¿è¡Œgit statusæ—¶å°±ä¼šåœ¨â€œChanges not staged for commitâ€éƒ¨åˆ†ï¼ˆä¹Ÿå°±æ˜¯æœªæš‚å­˜æ¸…å•ï¼‰çœ‹åˆ°è¯¥æ–‡ä»¶çš„åˆ é™¤è®°å½•äº†ã€‚ä¾‹å¦‚ï¼Œåœ¨Testç›®å½•ä¸‹ï¼Œåˆ é™¤change.cæ–‡ä»¶ï¼Œä½¿ç”¨git statuså‘½ä»¤å¯ä»¥çœ‹åˆ°ï¼š123456789$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: change.cno changes added to commit (use "git add" and/or "git commit -a") ç„¶åŽè¿˜éœ€åœ¨è¿è¡Œgit rmè®°å½•æ­¤æ¬¡ç§»é™¤æ–‡ä»¶çš„æ“ä½œï¼š12345678$ git rm change.crm 'change.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: change.c è¿™æ ·ä¸‹ä¸€æ¬¡æäº¤æ—¶ï¼Œè¯¥æ–‡ä»¶å°±ä¸å†çº³å…¥ç‰ˆæœ¬ç®¡ç†äº†ã€‚ å¦‚æžœå°†æ–‡ä»¶ä¿ç•™åœ¨ç£ç›˜å†…ï¼Œä½†æ˜¯å¹¶ä¸æƒ³è®© Git ç»§ç»­è·Ÿè¸ªï¼Œå¯ä»¥ä½¿ç”¨--cachedé€‰é¡¹ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š12345678910111213$ git rm --cached update.crm 'update.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: update.cUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) update.c æŽ¥ç€ä½¿ç”¨git commitå‘½ä»¤æäº¤åŽupdate.cæ–‡ä»¶å°±ä¸åœ¨ä»“åº“å†…ï¼Œä½†ä»åœ¨ç£ç›˜ä¸Šäº†ã€‚ Moving FilesGit å¾ˆèªæ˜Žï¼Œä¸€æ¡ç§»åŠ¨æ–‡ä»¶çš„å‘½ä»¤å°±èƒ½é‡å‘½åæ–‡ä»¶å¹¶ä¿ç•™ç›¸åŒå¼‚åæ–‡ä»¶çš„çŠ¶æ€ï¼Œå¦‚ä¸‹ï¼š1$ git mv file_from file_to ä¸Šè¿°å‘½ä»¤ä¸Žä¸‹é¢ä¸‰æ¡å‘½ä»¤ç±»ä¼¼ï¼š123$ mv file_from file_to$ git rm file_from$ git add file_from ä½¿ç”¨ä¸€æ¡å‘½ä»¤å¹²ä¸‰ä»¶äº‹ï¼Œå¾ˆæ£’å§~]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ç´ æ•°çš„æ±‚æ³•]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%B4%A0%E6%95%B0%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[å®šä¹‰ä»‹ç»å¦‚ä½•æ±‚ç´ æ•°ä¹‹å‰ï¼Œé¦–å…ˆå¾—æ˜Žç™½ç´ æ•°æ˜¯ä»€ä¹ˆï¼Ÿæ‰€è°“ç´ æ•°ï¼ˆä¹Ÿå«è´¨æ•°ï¼‰ï¼Œæ˜¯æŒ‡å¤§äºŽ1ï¼Œä¸”åªèƒ½è¢«1å’Œå…¶æœ¬èº«æ•´é™¤çš„æ•°ï¼ˆæ­¤å®šä¹‰ä¸Žåˆæ•°çš„å®šä¹‰ç›¸å¯¹ï¼‰ã€‚ ç®€ä¾¿æ±‚æ³•åœ¨å¯¹æ—¶é—´å¤æ‚åº¦æ²¡æœ‰è¦æ±‚çš„æƒ…å†µä¸‹ï¼Œç›´æŽ¥ä»Žå®šä¹‰å‡ºå‘ï¼Œåˆ©ç”¨å¾ªçŽ¯ï¼Œä¸€ç›´åšå–ä½™è¿ç®—ï¼Œå°±å¯ä»¥å¾ˆå®¹æ˜“çš„å¾—åˆ°åˆ¤æ–­ä¸€ä¸ªæ•°å­—æ˜¯å¦ä¸ºç´ æ•°çš„ç®—æ³•ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1) &#123; flag = false; &#125; else &#123; for(i = 2; i &lt; number; i++) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; å¾ˆæ˜Žæ˜¾ï¼Œå› ä¸ºå€ŸåŠ©äº†ä¸€å±‚å¾ªçŽ¯ï¼Œæ‰€ä»¥æ—¶é—´å¤æ‚åº¦$O(n)$ï¼Œä¼˜ç‚¹å°±æ˜¯ååˆ†å®¹æ˜“ç†è§£äº†ã€‚ ç»“åˆæ•°å­¦çŸ¥è¯†çš„ä¼˜åŒ–åœ¨ç†è§£äº†ç®€ä¾¿æ±‚æ³•ä¹‹åŽï¼Œæ¥ç¨å¾®æ€è€ƒä¸€ä¸‹ï¼Œå¶æ•°èƒ½è¢«2æ•´é™¤ï¼Œæ‰€ä»¥è‚¯å®šä¸æ˜¯ç´ æ•°ï¼Œå¦‚æžœä¸€å¼€å§‹å…ˆåˆ¤æ–­numberæ˜¯ä¸æ˜¯å¶æ•°ï¼Œç„¶åŽåœ¨ä»Ž 3 å¼€å§‹åˆ¤æ–­numberæ˜¯å¦èƒ½è¢«å¥‡æ•°æ•´é™¤ï¼Œå¦‚æ­¤ä¸€æ¥ï¼Œæ•´ä¸ªå¾ªçŽ¯æ¬¡æ•°å°±æ˜¯$(n - 3) / 2 + 1$ï¼ˆå¥‡æ•°æ¯æ¬¡å¢žåŠ 2ï¼Œæ‰€ä»¥åˆ†æ¯ä¸º2ï¼‰äº†ï¼Œå½“$n$è¾ƒå¤§çš„æ—¶å€™ï¼Œè¿™ä¸ªå€¼æ˜¯è¶‹è¿‘äºŽ$n / 2$çš„ã€‚æŽ¥ç€æ¥æ”¹å†™ä¸€ä¸‹ä»£ç ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ç›¸æ¯”ç®€ä¾¿æ±‚æ³•ï¼Œå°†æ€»ä½“æ—¶é—´ç¼©çŸ­äº†ä¸€åŠï¼Œæ—¶é—´å¤æ‚åº¦æ˜¯$O(n/2)$ã€‚ å®žé™…ä¸Šï¼Œå¾ªçŽ¯åŒºé—´å¯ä»¥ç¼©å‡ä¸º$[3, \sqrt{number})$ï¼ˆæ­¤å¤„çš„æ•°å­¦è¯æ˜Žå°±ä¸å¤šè¯´äº†ðŸ˜ï¼Œå¯ä»¥ç®€å•æƒ³ä¸€ä¸‹ï¼Œä¸€ä¸ªæ•°$n$ï¼Œå¯¹äºŽ$x &lt;= n$ï¼Œå¦‚æžœ$n$èƒ½æ•´é™¤$x$ï¼Œåˆ™$n$ä¹Ÿä¸€å®šèƒ½æ•´é™¤$n/x$ï¼Œè¿™ä¸¤ä¸ªæ•°ä¸­å¿…å®šæœ‰ä¸€ä¸ªå¤§äºŽç­‰äºŽ$\sqrt{n}$ï¼‰ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i * i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ä¸Šè¿°ä»£ç å—ä¸­ç”¨i * iæ¥ä»£è¡¨å¹³æ–¹æ ¹çš„å†™æ³•è¾ƒä¸ºå¸¸è§ï¼Œè¿™æ ·æ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å°±ä¸º$O(\sqrt{n})$ã€‚ è½¬æ¢æ€è·¯æŒ‰ç…§ä¹‹å‰çš„åšæ³•ï¼Œæ— è®ºiçš„å€¼æ˜¯ç´ æ•°è¿˜æ˜¯åˆæ•°ï¼Œéƒ½å¯¹numberè¿›è¡Œäº†æ•´é™¤çš„è¿ç®—ã€‚å®žé™…ä¸Šï¼Œåˆ¤æ–­numberæ˜¯å¦ä¸ºç´ æ•°ï¼Œåªéœ€è¦åœ¨içš„å€¼ä¸ºç´ æ•°çš„æƒ…å†µä¸‹ï¼Œåˆ¤æ–­numberæ˜¯å¦èƒ½è¢«iæ•´é™¤å³å¯ï¼Œè‹¥èƒ½æ•´é™¤åˆ™ä¸æ˜¯ç´ æ•°ï¼Œåä¹‹åˆ™æ˜¯ã€‚åœ¨è¿›è¡Œä¸Šè¿°è®¡ç®—çš„è¿‡ç¨‹ä¸­ï¼Œéœ€è¦æå‰å‡†å¤‡ä¸€å¼ ç´ æ•°è¡¨æ¥å¸®åŠ©è®¡ç®—ï¼Œå…·ä½“å¦‚ä¸‹ï¼š1234567891011bool Is_Prime(int number, int Prime[], int NumOfPrime) &#123; bool flag = true; int i; for(i = 0; i &lt; NumOfPrime; i++) &#123; if(a % Prime[i] == 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; åœ¨è®¡ç®—çš„æ•°æ®è¾ƒå¤§çš„æƒ…å†µä¸‹ï¼Œæ— æ³•ç›´æŽ¥ç»™å®šç´ æ•°è¡¨ï¼Œéœ€è¦è¾¹åˆ¤æ–­è¾¹æ›´æ–°ï¼Œè¿™æ ·ä¼šæ¶ˆè€—æŽ‰ä¸€å®šçš„æ—¶é—´ï¼Œæ‰€ä»¥ä¸Šè¿°ç®—æ³•çš„å®žé™…æ—¶é—´å¤æ‚åº¦$O(n) âˆˆ (\sqrt{n}, n/2)$ï¼Œä½†æ­¤æ³•å¾ˆé€‚åˆéœ€è¦æž„é€ ç´ æ•°è¡¨å¹¶æ±‚å’Œçš„åœºæ™¯ã€‚ ç´§æŽ¥ç€åˆšæ‰çš„æ€è·¯ï¼Œä»¥2ä¸ºä¾‹ï¼Œåœ¨åˆ¤æ–­å‡ºå…¶ä¸ºç´ æ•°åŽï¼Œå…¶å€æ•°$4ã€6ã€8ã€10...$å°±æ˜¯éžç´ æ•°äº†ï¼Œé‚£ä¹ˆä¸€æ¬¡æ€§å°†è¿™äº›æ•°å­—æ ‡è®°ä¸ºéžç´ æ•°ï¼Œä¹Ÿå¯ä»¥æé«˜æ•ˆçŽ‡ï¼Œè¿™å°±æ˜¯â€œç­›é€‰æ³•â€æž„é€ ç´ æ•°è¡¨ï¼Œå…·ä½“å¦‚ä¸‹ï¼š1234567891011121314bool IsPrime[NumOfPrime];for(i = 2; i &lt; NumOfPrime; i++) &#123; IsPrime[NumOfPrime] = 1;&#125;void Get_Prime() &#123; int x, i; for(x = 2; x &lt; MaxNum; x++) &#123; if( IsPrime[x] ) &#123; for(i = 2; i * x &lt; MaxNum; i++) &#123; IsPrime[i*x] = 0; &#125; &#125; &#125;&#125; å°½ç®¡åˆ†æžä»£ç ï¼Œç²—ç•¥å¯å¾—æ­¤ç®—æ³•æ—¶é—´çš„å¤æ‚åº¦ä¸º$O(n * loglog{n})$ï¼Œä¹‹æ‰€ä»¥æ˜¯è¿™ä¸ªæ—¶é—´å¤æ‚åº¦ï¼Œæ˜¯å› ä¸ºä¸€æ¬¡æ€§è®¡ç®—å‡ºäº†$[0, MaxNum)$è¿™ä¸ªåŒºé—´å†…çš„æ‰€æœ‰ç´ æ•°ï¼Œæ­¤ç®—æ³•å®žé™…æ•ˆæžœè¾ƒå¥½ï¼Œå¯¹äºŽéœ€è¦æž„é€ ç´ æ•°è¡¨çš„æƒ…å†µå¾ˆæ–¹ä¾¿ã€‚ æ‰©å±•ä¸Šé¢ä»‹ç»çš„â€œç­›é€‰æ³•â€ï¼Œå…¶å®žæ˜¯å¤å¸Œè…Šæ•°å­¦å®¶åŸƒæ‹‰æ‰˜è‰²å°¼ï¼ˆEratosthenesï¼Œ274 B.C ~ 194 B.Cï¼‰æå‡ºçš„ä¸€ç§ç­›é€‰æ³•ï¼Œä¹Ÿç§°åŸƒæ°ç­›æ³•ã€‚å®žé™…ä¸Šï¼Œç»“åˆåˆ©ç”¨ç´ æ•°è¡¨æ¥åˆ¤æ–­ç´ æ•°çš„æ€è·¯ï¼Œå¯¹äºŽåˆæ•°è€Œè¨€ï¼Œå¦‚æžœå…¶åªè¦è¢«å…¶æœ€å°è´¨å› å­æ•´é™¤ï¼Œå³å¯åˆ¤æ–­å…¶ä¸æ˜¯ç´ æ•°ã€‚é‚£ä¹ˆåŽ»æŽ‰è¿™éƒ¨åˆ†é‡å¤è®¡ç®—çš„è¿‡ç¨‹ï¼Œä¸å°±å¯ä»¥æé«˜æ•ˆçŽ‡äº†å—ï¼Ÿä»¥16ä¸ºä¾‹ï¼Œåœ¨åŸƒæ°ç­›æ³•ä¸­ï¼Œ$x = 2$æ—¶ï¼Œç­›é€‰æŽ‰äº†$4ã€6ã€8ã€10...$ï¼Œå½“$x = 3$æ—¶ï¼Œåˆé‡å¤è®¡ç®—äº†$6ã€12...$ç­‰æ•°ã€‚æŽ¥ç€æ¥ä¿®æ”¹ä¸‹ä»£ç ï¼š123456789101112bool Number[MaxNum];memset(Number, true, sizeof(Number));int Prime[MaxNum], count = 0;for(i = 2; i &lt; MaxNum; i++) &#123; if( Number[i] ) &#123; Prime[count++] = i; for(j = 1; j &lt;= num &amp;&amp; i * Prime[j] &lt;= n; j++) &#123; Number[i * Prime[j]] = false; if(i % Prime[j] == 0) break; &#125; &#125;&#125; ä¸Šè¿°ä»£ç çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ï¼ˆè®¡ç®—è¿‡ç¨‹æš‚ä¸æ·±ç©¶ï¼‰ï¼Œæ‰€ä»¥æ­¤ç§ç­›æ³•ä¹Ÿå«çº¿æ€§ç­›æ³•ï¼Œä¸è¿‡æå‡æ•ˆçŽ‡çš„ä»£ä»·å°±æ˜¯å¤šä½™çš„ç©ºé—´å¼€é”€äº†ï¼Œä¸€èˆ¬è€Œè¨€çš„ä¼˜åŒ–éƒ½æ˜¯è¿™æ ·çš„æ€è·¯ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Prime Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[é›¨å¤œæ‚æ€]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%9B%A8%E5%A4%9C%E6%9D%82%E6%80%9D%2F</url>
    <content type="text"><![CDATA[æ˜¯å¤œï¼Œçª—å¤–çš„é›¨å£°æ·…æ·…æ²¥æ²¥çš„ä¸‹ç€ï¼Œå¿ƒé‡Œæƒ³ç€è‡ªå·±è¿™æ®µæ—¶é—´çš„ç”Ÿæ´»ï¼Œä¸ç”±å¾—æœ‰äº†äº›æ„Ÿæ…¨ï¼Œæ¯•ç«Ÿåˆæ˜¯ä¸€å¹´é€åŽ»äº†ã€‚ See the sky about the rain - Neil YoungYour browser does not support the audio tag. é›¨ï¼ŒåŽŸæ¥æˆ‘æ˜¯å¾ˆè®¨åŽŒçš„ã€‚å› ä¸ºï¼Œä¸‹é›¨å°±æ„å‘³ç€è¦æ‰“ä¼žï¼Œä¼šå«Œéº»çƒ¦ï¼Œè€Œä¸”è¿˜ä¼šæ·‹æ¹¿ã€‚æ›´ç”šè€…ï¼Œè‹¥æ˜¯é›¨ä¸‹çš„å¤ªå¤§ï¼Œä¸€æ—¦æŠŠéž‹æ‰“æ¹¿äº†ï¼Œé‚£æ»‹å‘³å¯å°±ä¸å¥½å—äº†ã€‚ä¸è¿‡ï¼Œå³ä¾¿å¦‚æ­¤ï¼ŒçŽ°åœ¨çš„æˆ‘ï¼ŒäºŽé›¨ï¼Œæ˜¯å–œæ¬¢çš„ã€‚ æ¯å½“ä¸‹é›¨ä¹‹æ—¶ï¼Œæˆ‘æ€»ä¼šæœ‰è¿™æ ·çš„æƒ³æ³•ï¼šæ˜¯è°åˆåœ¨ç‹¬è‡ªä¼¤å¿ƒï¼Ÿæƒ¹å¾—è€å¤©çˆ·é™ªå¥¹ï¼ˆä»–ï¼‰ä¸€èµ·å“­ï¼Ÿã€‚æœ€åˆèŒç”Ÿè¿™ä¸ªæƒ³æ³•çš„æ—¶é—´ï¼Œæ˜¯è‡ªå·±çš„é«˜ä¸­é˜¶æ®µï¼Œå…·ä½“æ— æ³•è®°æ¸…æ˜¯é‚£ä¸ªå¹´çº§äº†ï¼ŒåªçŸ¥é“é‚£æ˜¯ä¸€ä¸ªå‚æ™šï¼Œä¸‹è¯¾åŽå¤§å®¶éƒ½åŽ»åƒé¥­äº†ï¼Œæ­£å·§é‚£å¤©æˆ‘å¿ƒä¸­æœ‰äº‹ï¼Œå°±åœ¨æ•™å®¤å‘å‘†ï¼Œç­‰å›žè¿‡ç¥žæ¥çš„æ—¶å€™ï¼Œæ‰å‘çŽ°è¿˜å¾—åŽ»åƒé¥­ï¼Œæ¯•ç«Ÿæ™šä¸Šè¿˜å¾—ä¸Šè¯¾ã€‚äºŽæ˜¯ä¸‹æ¥¼ï¼Œå‡ºåŽ»æ‰å‘çŽ°ä¸‹é›¨äº†ï¼Œæƒ³ä¹Ÿæ²¡æƒ³ï¼Œè¿ˆç€æ­¥å­å°±å¾€å‰èµ°ï¼Œèµ°ç€èµ°ç€ï¼Œçªç„¶å‘çŽ°ï¼Œå¥½åƒæ²¡é‚£ä¹ˆå¤§ï¼ŒäºŽæ˜¯åŽŸå…ˆçš„ç–¾æ­¥æˆäº†æ¼«æ­¥ï¼Œç´§æŽ¥ç€ï¼Œè„‘ä¸­å°±å†’å‡ºäº†è¿™ä¸ªæƒ³æ³•ï¼Œå›žè¿‡ç¥žæ¥æ‰å‘çŽ°ï¼Œæˆ‘æ€Žä¹ˆä¼šæœ‰è¿™æ ·çš„æƒ³æ³•ï¼Ÿå› çƒ¦äº‹åƒµç›´çš„å˜´è§’ï¼Œæ­¤æ—¶æœ‰äº†å¾®å¾®ä¸Šæ‰¬çš„å¼§åº¦ï¼Œå¿ƒä¸­ä¸å…ä¹è§‚äº†èµ·æ¥ã€‚è‡³æ­¤ä¹‹åŽï¼Œæ¯å½“ä¸‹é›¨çš„æ—¶å€™ï¼Œåœ¨å…¶ä»–äººéƒ½æŠ±æ€¨ä¸‹é›¨åœ°æ»‘ã€æ·‹æ¹¿ä¹‹ç±»çš„æ—¶å€™ï¼Œæˆ‘æ€»ä¼šåœ¨å¿ƒä¸­æƒ³ï¼Œåˆ°åº•æ˜¯è°åˆåœ¨ä¼¤å¿ƒå‘¢ï¼Ÿå¸Œæœ›è€å¤©çˆ·çš„é›¨å¯ä»¥æŠšæ…°ä½å¥¹ï¼ˆä»–ï¼‰å—ä¼¤çš„å¿ƒ...åŽæ¥æ¯å½“è‡ªå·±å¿ƒæƒ…ä¸å¥½çš„æ—¶å€™ï¼Œæ€»çœ‹çœ‹å¤©ä¸Šæ˜¯å¦æœ‰é›¨ï¼Œåƒæ˜¯è¦å¾—åˆ°å®‰æ…°çš„å­©å­ä¸€æ ·ï¼Œä¸è¿‡å¥½åœ¨ï¼Œè‡ªå·±æ˜¯è¢«æ»¡è¶³çš„ã€‚ çŽ°åœ¨åˆä¸€å¹´çš„äº”æœˆæœ€åŽçš„æ—¥å­äº†ï¼Œé¢ä¸´å³å°†åˆ°æ¥çš„å…­æœˆï¼Œå¿ƒä¸­ä¸å…æœ‰äº›ä¸èˆï¼Œæ—¶å…‰å¥½åƒåˆè¶ç€è‡ªå·±ä¸æ³¨æ„æºœèµ°äº†ã€‚æ›¾ç»æ„Ÿå¹æ—¶é—´è¿‡çš„å¤ªæ…¢çš„è‡ªå·±ï¼ŒçŽ°åœ¨å·²ç»æˆäº†æ„Ÿå¹æ—¶å…‰çš„â€œè€äººâ€ã€‚æ˜¯ä»Žä»€ä¹ˆæ—¶å€™å¼€å§‹ï¼Œè‡ªå·±çš„å¿ƒæ²¡æœ‰å½“åˆçš„é‚£ä»½â€œå¹´è½»â€äº†å‘¢ï¼Ÿå¥½åƒè¿žè‡ªå·±è¿™ä¸ªå˜åŒ–ä¹Ÿè®°ä¸æ¸…äº†ï¼Œè¿™ä¸ªé—®é¢˜æ­å¼€æ¥çœ‹ï¼Œæ„Ÿè§‰è‡ªå·±æœ‰ç‚¹å¯æ‚²å‘ã€‚ä»¥ä¸ºè‡ªå·±æ˜¯æŒ‰ç…§è‡ªå·±çš„æ–¹å‘å‰è¡Œï¼Œä½†å´è¿žè‡ªå·±çš„è½¬æŠ˜ç‚¹éƒ½ä¸æ¸…æ¥šï¼Œé‚£ä¹Ÿå°±æ„å‘³ç€å¤šå¹´æ¥çš„è‡ªå·±ä¾ç„¶æ˜¯ä¸€ä¸ªè¢«åŠ¨çš„é€‰æ‹©è€…ï¼Ÿè¯¶ï¼Œä¸å¯¹ï¼Œæœ‰å¥è¯ï¼Œä¸æ˜¯å«æ—¶é—´æ€»æ˜¯åœ¨ä¸ç»æ„é—´æ”¹å˜äº†å¤§å®¶å—ï¼Ÿè¿™åº”è¯¥æ˜¯â€œå¸¸ç†â€ï¼Œä¸æ˜¯æˆ‘å¯æŠ—çš„...å§ï¼Ÿè¯´è¿™ä¹ˆå¤šï¼Œå…¶å®žç»“æžœå¦‚ä½•ï¼Œå¿ƒä¸­æ‰€æ€ï¼Œç­”æ¡ˆæ—©å·²ä¸å˜ã€‚ çª—å¤–çš„é›¨å£°å¥½åƒå°äº†äº›ï¼Œä»Žçª—æˆ·çš„ç»†ç¼ä¸­æœ‰å‡‰é£Žå¹è¿›æ¥ï¼Œå¾®å¾®æ‹‚èµ·äº†çª—å¸˜ï¼Œæ˜¯æ¥æé†’æˆ‘è¯¥ç¡è§‰äº†å—ï¼Ÿå¥½åƒåˆæ˜¯åœ¨è‡ªæˆ‘å®‰æ…°å‘¢ï¼ˆå›§ï¼‰ï¼Œå¤§åŠå¤œéš”å£ç«Ÿç„¶è¿˜æœ‰æ€çŒªä¸€æ ·çš„ç¬‘å£°ä¼ å‡ºæ¥ï¼Œæ˜¯ä»€ä¹ˆäº‹æƒ…è®©ä»–ä»¬è¿™ä¹ˆå…´å¥‹ï¼Ÿç®—äº†ï¼Œæ²¡æœ‰å…´è¶£åŽ»äº†è§£ï¼ŒçŽ°åœ¨çš„è‡ªå·±åªæƒ³ä¸“æ³¨åˆ°è‡ªå·±çš„äº‹æƒ…ä¸Šã€‚ æŒ‡ç”²è¿˜æœ‰ä¸€ä¸¤å‘¨å°±é•¿å‡ºæ¥äº†ï¼Œè¿™æ ·æˆ‘åˆå¯ä»¥åšæ‰‹æŒ‡æ“äº†ã€‚ç³Ÿç³•ï¼Œç¬”è®°æœ¬å¥½åƒè¦æ²¡ç”µäº†ï¼Œè¿™æ¬¡å°±å…ˆå†™åˆ°è¿™é‡Œå§ï¼Œæ»šåŽ»ç¡è§‰ingã€‚]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cè¯­è¨€å¸¸ç”¨åº“å‡½æ•°]]></title>
    <url>%2F2019%2F05%2F24%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Introæœ€è¿‘å‘çŽ°ä¸€ä¸ªé—®é¢˜ï¼Œåšé¢˜çš„æ—¶å€™ï¼Œä¸ç®¡æœ‰çš„æ²¡çš„ï¼Œè¦ç”¨çš„å‡½æ•°å…¨é è‡ªå·±å†™ï¼Œå†™æ¥å†™åŽ»ä¹Ÿæ‡’å¾—åŽ»ç®¡åˆ°åº•æœ‰æ²¡æœ‰é‚£ä¸ªåº“å‡½æ•°äº†â€¦è¿™æ ·ä¸å¤ªå¥½ï¼Œæ—¥åŽè¿˜ä¸æ˜¯å¾—æŠŠè‡ªå·±ç´¯æ­»ï¼Œè¿˜æ˜¯å¾—å–„äºŽåˆ©ç”¨ä¸œè¥¿æ‰è¡Œï¼ˆåˆä¸ºè‡ªå·±å·æ‡’æ‰¾å€Ÿå£ðŸ¤£ï¼‰ã€‚äºŽæ˜¯ï¼Œè¿™ç¯‡æ–‡ç« å°±ç”¨æ¥è®°å½•Cä¸­å¸¸ç”¨çš„ä¸€äº›åº“å‡½æ•°ï¼Œä»¥å…æ—¥åŽåˆå¿˜è®°äº†ã€‚ stdlib.hstdlib.hå³standard libraryæ ‡å‡†åº“å¤´æ–‡ä»¶ï¼Œè¿™ä¸ªå¤´æ–‡ä»¶å†…æœ‰å¾ˆå¤šæœ‰ç”¨çš„å·¥å…·å‡½æ•°ã€‚ qsortqsortå‡½æ•°æ˜¯Cè¯­è¨€è‡ªå¸¦çš„æŽ’åºå‡½æ•°ï¼Œé‡‡ç”¨æŽ’åºæ–¹æ³•æ˜¯å¿«é€ŸæŽ’åºï¼Œå…¶å£°æ˜Žä½äºŽå¤´æ–‡ä»¶stdlib.hä¸­ï¼Œè²Œä¼¼å¿«é€ŸæŽ’åºæ˜¯å®žé™…ä½¿ç”¨æ•ˆæžœæœ€å¥½çš„å‡ ç§æŽ’åºæ–¹æ³•ä¹‹ä¸€ã€‚ Function Prototypeå‡½æ•°åŽŸåž‹å¦‚ä¸‹ï¼š1void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *)); å‚æ•°è¯´æ˜Žï¼šbasenumsizecomparebaseæŒ‡å‘æ•°ç»„çš„èµ·å§‹åœ°å€ï¼Œé€šå¸¸ä¼šä¼ å…¥ä¸€ä¸ªæ•°ç»„ånumè¡¨ç¤ºè¯¥æ•°ç»„å…ƒç´ çš„ä¸ªæ•°sizeè¡¨ç¤ºæ•°ç»„ä¸­æ¯ä¸ªå…ƒç´ çš„å¤§å°ï¼ˆå­—èŠ‚æ•°ï¼‰(*compare)(const void*, const void*)ä¸ºæŒ‡å‘æ¯”è¾ƒå‡½æ•°çš„å‡½æ•°æŒ‡é’ˆï¼Œå†³å®šäº†æŽ’åºé¡ºåº Compare Functionqsortå‡½æ•°å£°æ˜Žä¸­çš„compareå‚æ•°æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼ŒæŒ‡å‘ä¸€ä¸ªæ¯”è¾ƒä¸¤ä¸ªå…ƒç´ çš„å‡½æ•°ã€‚æ¯”è¾ƒå‡½æ•°çš„åŽŸåž‹åº”è¯¥æ˜¯int compare(const void *a, const void *b);ï¼Œæ³¨æ„è¿™ä¸ªå‡½æ•°çš„å½¢å‚æ˜¯const void *åž‹ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæ˜¯ä¸é™åˆ¶å‚æ•°æŒ‡é’ˆç±»åž‹çš„ï¼Œå¹¶ä¸”ï¼Œè¿”å›žå€¼æ˜¯intåž‹çš„ã€‚qsortå‡½æ•°åœ¨ä½¿ç”¨compareå‡½æ•°æŒ‡é’ˆè°ƒç”¨compareæ¯”è¾ƒå‡½æ•°æ—¶ï¼Œä¼ å…¥çš„å®žå‚æ˜¯æ²¡æœ‰é™å®šæŒ‡é’ˆç±»åž‹çš„ã€‚ä¸€èˆ¬è€Œè¨€ï¼Œcompareå‡½æ•°æŒ‰ç…§ä¸‹é¢çš„ä»£ç æ¥å†™ï¼š123456int compare(const void *a, const void *b)&#123; if(*(int*)a &lt; *(int*)b) return -1; if(*(int*)a == *(int*)b) return 0; if(*(int*)a &gt; *(int*)b) return 1;&#125; ä»Žä¸Šé¢çš„ä»£ç å¯ä»¥çœ‹å‡ºï¼ŒæŒ‡é’ˆaå’Œbåœ¨ä¼ å…¥åˆ°compareæ¯”è¾ƒå‡½æ•°å†…åŽï¼Œå…ˆè¿›è¡Œäº†æŒ‡é’ˆç±»åž‹çš„å¼ºè½¬æ“ä½œï¼Œç„¶åŽå†åˆ†åˆ«å¯¹å¼ºè½¬åŽçš„aå’ŒbæŒ‡é’ˆè¿›è¡Œè§£å¼•ç”¨ï¼Œå¹¶åšå·®æ¥åˆ¤æ–­*aå’Œ*bçš„å¤§å°ï¼Œæ ¹æ®ä¸‰ç§ä¸åŒçš„æƒ…å†µè¿”å›žä¸‰ä¸ªå€¼ï¼Œåˆ†åˆ«å¯¹åº”ä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼š-101(*a)æ‰€æŒ‡å‘å…ƒç´ ä¼šè¢«æŽ’åœ¨*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹å‰(*a)æ‰€æŒ‡å‘å…ƒç´ å’Œ*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹é—´é¡ºåºä¸ç¡®å®š(*a)æ‰€æŒ‡å‘å…ƒç´ ä¼šè¢«æŽ’åœ¨*(b)æ‰€æŒ‡å‘å…ƒç´ ä¹‹åŽ Exampleså¯¹æ™®é€šintåž‹æ•°ç»„è¿›è¡ŒæŽ’åºæ—¶ï¼š1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(const void *a, const void *b)&#123; return (*(int*)a - *(int*)b);&#125;int main(int argc, char const *argv[])&#123; int i, array[8] = &#123;30, 52, 11, 29, 58, 3, 88, 60&#125;; qsort(array, 8, sizeof(array[0]), compare); for(i=0; i&lt;8; i++) &#123; printf("%d ", array[i]); &#125; return 0;&#125;/*Print: 3 11 29 30 52 58 60 88if '(*(int*)b - *(int*)a)' replaces '(*(int*)a - *(int*)b)'then Print: 88 60 58 52 30 29 11 3*/ å¯¹å…¶ä»–ç±»åž‹çš„æ•°ç»„è€Œè¨€ï¼Œä½¿ç”¨æ–¹æ³•ä¹Ÿå¤§è‡´å¦‚æ­¤ï¼Œå¯¹å­—ç¬¦ä¸²æ•°ç»„ï¼ˆå³äºŒç»´å­—ç¬¦æ•°ç»„ï¼‰ä½¿ç”¨æ—¶ï¼Œå¯ä»¥å°†æ¯”è¾ƒå‡½æ•°è¿™æ ·å†™ï¼š1234int compare(const void *a, const void *b)&#123; return (strcmp((char*)a, (char*)b));&#125; é…åˆstrcmpå‡½æ•°ä½¿ç”¨å°±ä¼šå¾ˆæ–¹ä¾¿ã€‚å¦å¤–ï¼Œå¿«é€ŸæŽ’åºæ˜¯ä¸ç¨³å®šçš„æŽ’åºç®—æ³•ï¼Œå¯¹äºŽç»“æž„ä½“è€Œè¨€ï¼Œå½“ä¸¤ä¸ªå…ƒç´ çš„å€¼ç›¸ç­‰æ—¶ï¼Œç»è¿‡å¿«é€ŸæŽ’åºåŽï¼Œå…¶ç›¸å¯¹ä½ç½®å¯èƒ½å‘ç”Ÿäº†æ”¹å˜ï¼Œè¿™å°±å¯¼è‡´ç»“æž„ä½“æŽ’åºå®Œæˆä¹‹åŽï¼Œè¾“å‡ºç»“æžœä¸å¯¹ï¼ˆä½†æ˜¯åºåˆ—æœ‰åºæ— è¯¯ï¼‰ï¼Œä¸ºäº†é¿å…è¿™ç§æƒ…å†µï¼Œéœ€è¦åœ¨ç»“æž„ä½“å†…æ–°å¢žä¸€ä¸ªæ ‡è®°ä½ï¼Œå½“ä¸¤ä¸ªç»“æž„ä½“å€¼ç›¸ç­‰æ—¶ï¼Œæ¯”è¾ƒæ ‡å¿—ä½çš„å¤§å°ï¼Œä»Žè€Œä¿æŒäºŒè€…ç›¸å¯¹ä½ç½®ä¸å‘ç”Ÿæ”¹å˜ã€‚ ctype.hctype.hè¿™ä¸ªå¤´æ–‡ä»¶å…¨ç§°åº”è¯¥æ˜¯character typeå§ï¼Œå› ä¸ºå…¶å†…éƒ¨å®šä¹‰äº†ä¸€æ‰¹Cè¯­è¨€å­—ç¬¦åˆ†ç±»å‡½æ•°ï¼Œç”¨äºŽæµ‹è¯•å­—ç¬¦æ˜¯å¦å±žäºŽç‰¹å®šçš„å­—ç¬¦ç±»åˆ«ã€‚è¿™äº›å‡½æ•°å®žçŽ°èµ·æ¥éƒ½ä¸éš¾ï¼Œå†é‡å¤é€ è½®å­å°±æœ‰ç‚¹åˆ’ä¸æ¥äº†ã€‚ å¯¹äºŽä¸€ä¸ªå­—ç¬¦å˜é‡è€Œè¨€ï¼Œå…¶æœ¬è´¨ä¾ç„¶æ˜¯æ•´åž‹å˜é‡ã€‚ isalphaè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å­—æ¯ï¼ˆåŒ…å«å¤§å°å†™ï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isalpha(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isdigitè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯ç½—é©¬æ•°å­—ï¼ˆ0-9ï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isdigit(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯æ•°å­—ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isxdigitè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯åå…­è¿›åˆ¶å­—ç¬¦ï¼ˆ0-9ã€A-Zã€a-zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isxdigit(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯åå…­è¿›åˆ¶å­—ç¬¦ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ islowerè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å°å†™å­—æ¯ï¼ˆa-zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int islower(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å°å†™å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ isupperè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å¤§å†™å­—æ¯ï¼ˆA-Zï¼‰ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isupper(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å¤§å†™å­—æ¯ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚ tolowerè¿™ä¸ªå‡½æ•°ç”¨äºŽå°†ä¼ å…¥çš„å­—ç¬¦è½¬æ¢ä¸ºå°å†™å­—æ¯ã€‚å‡½æ•°åŽŸåž‹ï¼š1int tolower(int ch); è¿”å›žå€¼ä¸ºæ‰€ä¼ å…¥å­—ç¬¦å˜é‡çš„å°å†™å­—æ¯ã€‚ toupperè¿™ä¸ªå‡½æ•°ç”¨äºŽå°†ä¼ å…¥çš„å­—ç¬¦è½¬æ¢ä¸ºå¤§å†™å­—æ¯ã€‚å‡½æ•°åŽŸåž‹ï¼š1int tolower(int ch); è¿”å›žå€¼ä¸ºæ‰€ä¼ å…¥å­—ç¬¦å˜é‡çš„å¤§å†™å­—æ¯ã€‚ isalnumè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ¤æ–­ä¼ å…¥çš„å­—ç¬¦æ˜¯å¦æ˜¯å­—æ¯æˆ–æ•°å­—ã€‚å‡½æ•°åŽŸåž‹ï¼š1int isalnum(int ch); è‹¥ä¼ å…¥çš„å­—ç¬¦æ˜¯å­—æ¯æˆ–æ•°å­—ï¼Œåˆ™è¿”å›žéžé›¶ï¼Œè‹¥ä¸æ˜¯åˆ™è¿”å›ž0ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cè¯­è¨€é‡Œçˆ¬è¿‡çš„â€œå‘â€]]></title>
    <url>%2F2019%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E9%87%8C%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Introé‚£æ˜¯ä¸€ä¸ªä¸‹ç€å¤§é›¨çš„å¤œæ™šï¼Œå®¤å¤–æ€¥ä¿ƒçš„é›¨å£°æ­£å¥½æ˜ è¡¬ç€å®¤å†…ç´§å¼ çš„æ°”æ°›ï¼Œå¿«ï¼Œåªå‰©ä¸‹æœ€åŽä¸€ä¸ªBUGäº†ï¼ç»ˆäºŽåœ¨å¤§åŠä¸ªå°æ—¶ä¹‹åŽè§£å†³äº†ï¼Œä»”ç»†ä¸€çœ‹ï¼ŒåŽŸæ¥æ˜¯ä¹‹å‰ç¢°åˆ°è¿‡ä¸€æ¬¡çš„é—®é¢˜äº†...å¿ƒä¸­ä¸å…æƒ³åˆ°ï¼Œè¦æ˜¯ä¸Šæ¬¡æœ‰å¥½å¥½è®°å½•å°±å¥½äº†ã€‚äºŽæ˜¯ï¼Œå°±åŠ¨äº†æ•´ç†è¿™ç¯‡Blogçš„å¿ƒæ€å•¦~æ­¤Blogä¼šé•¿æœŸä¸å®šæ—¶æ›´æ–°ï¼Œè®°å½•ä¸‹è‡ªå·±åœ¨è·Ÿè€çˆ·å­CçŽ©è€çš„è¿‡ç¨‹ä¸­ï¼Œç¢°åˆ°çš„ä¸€äº›å‘çˆ¹ä¹‹å¤„ï¼ˆèœè¯·è½»å–·ï¼Œå˜¿å˜¿ï¼‰~ scanf å…³äºŽscanfå…ˆè¯´ä¸€ç‚¹ï¼Œscanfå‡½æ•°æ˜¯å¸¦è¿”å›žå€¼çš„ï¼Œæœ‰çš„ç¼–è¯‘å™¨ä¼šå¿½ç•¥æŽ‰è¿™ä¸ªè¿”å›žå€¼ï¼ˆæ²¡æœ‰å‘Šè­¦äº§ç”Ÿï¼‰ï¼Œä½†æ˜¯å®žé™…ä¸Šæ˜¯å­˜åœ¨çš„ï¼Œåˆ‡è®°ã€‚ scanfè¿™ä¸ªå‡½æ•°ç»™ç”¨æˆ·ç•™ä¸‹çš„å‘ï¼Œå®žé™…ä¸Šä¸æ˜¯å®ƒçš„è¿”å›žå€¼ï¼Œè€Œæ˜¯è¿™ä¸ªå‡½æ•°å¯¹ç”¨æˆ·èƒ½å‘å…¶è¾“å…¥çš„ä¸œè¥¿çš„è§„å®šï¼ˆðŸ˜“è¯´äº†ä¸€å¤§å †è®©äººå¬ä¸æ‡‚çš„è¯...ï¼‰ã€‚æ¢å¥è¯è¯´ï¼Œä¹Ÿå°±æ˜¯scanfè‡ªèº«å¯¹è¾“å…¥æµä¸­çš„æ•°æ®çš„èŽ·å–çš„æœºåˆ¶å¯èƒ½ä¼šè®©ç”¨æˆ·â€œå‘çˆ¹â€ã€‚å¯¹äºŽCè¯­è¨€è€Œè¨€ï¼Œåœ¨è¯»å–é”®ç›˜è¾“å…¥çš„æ•°æ®æ—¶ï¼Œä¸€èˆ¬æ˜¯å¸¦ç¼“å­˜çš„æ•°æ®è¾“å…¥ï¼Œéœ€è¦æŒ‰å›žè½¦é”®æ‰èƒ½å®Œæˆè¯¥â€œè¡Œâ€æ•°æ®çš„è¾“å…¥ç¡®å®šã€‚è€Œscanfå¯¹è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦å¹¶ä¸è¿›è¡Œå¤„ç†ï¼Œå›žè½¦ç¬¦ä¼šç•™åœ¨è¾“å…¥ç¼“å­˜åŒºä¸­ã€‚å› æ­¤ï¼Œåœ¨ä¸‹ä¸€ä¸ªâ€œå­—ç¬¦â€æ“ä½œå‡½æ•°ï¼ˆgetchar()ã€scanf(&quot;%c&quot;, &amp;x)ã€gets(s)ç­‰ï¼‰è¿è¡Œæ—¶ï¼Œä¼šè¯»åˆ°è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ã€‚å¦å¤–ï¼Œåœ¨è¯»å–æ•°å€¼åž‹æ•°æ®æˆ–å­—ç¬¦ä¸²ï¼ˆæ³¨æ„è¿™é‡Œæ²¡æœ‰å­—ç¬¦å˜é‡ï¼‰æ—¶ï¼Œscanfä¼šä»Žç¬¬ä¸€ä¸ªéžç©ºç™½å­—ç¬¦ï¼ˆç©ºç™½å­—ç¬¦æŒ‡ï¼šå›žè½¦ã€ç©ºæ ¼ã€TABç­‰ï¼‰å¼€å§‹è¯»å–ï¼Œè‡ªåŠ¨å¿½ç•¥å‰é¢çš„ç©ºç™½å­—ç¬¦ï¼Œè€Œé‡åˆ°ç©ºç™½å­—ç¬¦ç»“æŸè¯¥ç±»åž‹æ•°æ®çš„è¾“å…¥ã€‚å› æ­¤ï¼Œå¯¹äºŽè¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ï¼ˆç©ºç™½å­—ç¬¦ï¼‰çš„å¤„ç†ï¼Œéœ€è¦çœ‹ä¸‹ä¸€ä¸ªè¾“å…¥çš„æ•°æ®ç±»åž‹æ˜¯ä»€ä¹ˆï¼Œå¦‚æžœæ˜¯å­—ç¬¦ç±»ï¼Œé‚£å°±éœ€è¦æ¶ˆé™¤æŽ‰è¿™ä¸ªå›žè½¦ç¡®è®¤ç¬¦ï¼Œå¤„ç†åŠžæ³•æœ‰å¤šç§æ–¹å¼ï¼Œä¸‹é¢ä»‹ç»3ç§æ–¹æ³•ï¼šMethod 1Method 2Method 3ä½¿ç”¨fflush(stdin)å‘½ä»¤å¼ºåˆ¶åˆ·æ–°è¾“å…¥ç¼“å­˜ï¼Œä¸¢å¼ƒç¼“å­˜ä¸­çš„æ•°æ®ï¼Œæ³¨æ„æ­¤ç§æ–¹æ³•åœ¨windowsä¸‹ä½¿ç”¨æœ‰æ•ˆï¼Œlinuxæ— æ•ˆï¼Œå› ä¸ºLinuxæ²¡æœ‰fflushã€‚ 12345int a;char c;scanf(â€œ%dâ€, &amp;a);fflush(stdin); //clear the â€˜enterâ€™ charscanf(â€œ%câ€, &amp;c);å›žè½¦ç¬¦ä¹Ÿæ˜¯å­—ç¬¦ï¼Œå¯ä»¥ä½¿ç”¨getchar();æ¥åƒæŽ‰è¿™ä¸ªå›žè½¦ç¬¦å·ã€‚ 12345int a;char c;scanf(â€œ%dâ€, &amp;a);getchar(); //clear the â€˜enterâ€™ charscanf(â€œ%câ€, &amp;c);åˆ©ç”¨scanfå‡½æ•°çš„ä¸€äº›æœºåˆ¶ï¼Œå¦‚ï¼šscanf(&quot;%d%*c&quot;, &amp;i)ï¼Œ%*cè¡¨ç¤ºè¯»ä¸€ä¸ªå­—ç¬¦ï¼Œå¹¶ä¸èµ‹å€¼ç»™ä»»ä½•å˜é‡ã€‚ 123int a;char c;scanf(â€œ%d%*c%câ€, &amp;a, &amp;c); å¦å¤–ï¼Œå…³äºŽscanfè¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰ç‰¹ç‚¹çš„åœ°æ–¹ï¼Œå°±æ˜¯æ— æ³•è¯»å…¥ç©ºæ ¼å­—ç¬¦ï¼Œæ‰€ä»¥åŒ…å«ç©ºæ ¼å­—ç¬¦çš„å­—ç¬¦ä¸²å°±å¾—ä½¿ç”¨getsæˆ–è€…fgetså‡½æ•°æ¥è¯»å…¥äº†ã€‚è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯&amp;çš„ä½¿ç”¨ã€‚æ³¨æ„ï¼Œé™¤äº†è¯»å…¥å­—ç¬¦ä¸²å¤–ï¼Œå…¶ä»–éƒ½éœ€è¦ä½¿ç”¨&amp;ï¼Œä¼°è®¡è¿™æ˜¯ä¸å°‘æ–°æ‰‹ä¼šçŠ¯çš„é”™è¯¯äº†ðŸ˜€ï¼Œé—®é¢˜æ˜¯ä¸ä¼šç¼–è¯‘ä¸æŠ¥é”™ä¹Ÿä¸è­¦å‘Šï¼Œå¶å°”ä¸ä»”ç»†ï¼Œè€æ‰‹éƒ½è¦æ‰¾åŠå¤©... ififå…³é”®å­—å¯ä¸â€œå‘â€ï¼Œâ€œå‘â€çš„æ˜¯ä½¿ç”¨å®ƒçš„äººï¼ˆåˆé»‘è‡ªå·±ä¸€æŠŠ...ðŸ˜‚ï¼‰ï¼Œifä¸€èˆ¬å’ŒelseåŠelse ifé…åˆä½¿ç”¨ï¼ˆä¹Ÿå¯ä»¥å•ç‹¬ä½¿ç”¨ï¼‰ï¼Œä¸€èˆ¬ç”¨æ³•å¦‚ä¸‹ï¼š123456789101112131415/*if-else*/if(expression)&#123; statement1;&#125;else&#123; statement2;&#125;/*if-else if-else*/if(expression)&#123; statement1;&#125;else if(expression)&#123; statement2;&#125;else&#123; statement3;&#125; ä¸Šè¿°å†…å®¹ï¼Œè¯»æ‡‚å¾ˆå®¹æ˜“ï¼Œä½†é—®é¢˜å…¶å®žå°±åœ¨è¿™ä¸ªexpressionä¸Šï¼Œè¿™ä¸ªè¡¨è¾¾çš„å€¼ä¼šå½±å“ifè¿™ç±»è¯­å¥çš„åˆ¤æ–­ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼Œexpressionä¸ºtrueæ‰§è¡Œstatement1ï¼Œä¸ºfalseåˆ™æ‰§è¡Œstatement2ï¼Œelse ifåŒç†ã€‚æ‰€ä»¥ä¸¥æ ¼ä¸Šè®²ï¼Œifè®¤ä¸ºçš„trueæ˜¯éž0ï¼ˆå…¶ä»–è¯­å¥ï¼Œå¦‚whileçš„æ¡ä»¶åˆ¤æ–­æœºåˆ¶åº”è¯¥ä¹Ÿæ˜¯è¿™æ ·ï¼‰ï¼Œå•¥æ„æ€ï¼Ÿå°±æ˜¯è¯´ï¼Œä¸ç®¡expressionçš„å€¼æ˜¯1è¿˜æ˜¯-1ï¼Œiféƒ½æ˜¯è®¤ä¸ºæ˜¯trueï¼ˆå»ºè®®å°è¯•ï¼‰ï¼Œæ‰€ä»¥ï¼Œå¯åˆ«çœ‹åˆ°è¡¨è¾¾å¼çš„å€¼æ˜¯è´Ÿæ•°ï¼Œå°±è®¤ä¸ºæ¡ä»¶ä¸æˆç«‹äº†ã€‚ parameter passingè¿™é‡Œæ‰€ä»‹ç»çš„å‚æ•°ä¼ é€’ä¸»è¦æ˜¯é’ˆå¯¹Cè¯­è¨€å†…çš„å‡½æ•°ã€‚ä¼—æ‰€å‘¨çŸ¥ï¼ŒCçš„å‡½æ•°é‡‡ç”¨çš„æ˜¯å€¼ä¼ é€’çš„æ–¹å¼ï¼Œä¹Ÿå³ä¼ å…¥åˆ°å‡½æ•°å†…çš„å‚æ•°ï¼Œä¸ç®¡ä¼ å…¥çš„å€¼å¦‚ä½•ä¿®æ”¹ï¼Œä¾ç„¶ä¸ä¼šæ”¹å˜mainæˆ–å…¶ä»–å‡½æ•°å†…å˜é‡çš„å€¼ï¼Œè¦æƒ³æ”¹å˜æœ‰å¤šç§æ–¹å¼ï¼Œè¿™é‡Œç®€å•ä»‹ç»ä¸‰ç§ï¼Œå…·ä½“å¦‚ä¸‹ï¼šWay 1Way 2Way 3ä½¿ç”¨å…¨å±€å˜é‡åˆ©ç”¨å‡½æ•°è¿”å›žå€¼ï¼Œå½¢å¦‚ï¼ša = abs(a);è¿™æ ·çš„ä½¿ç”¨æ–¹æ³•ä½¿ç”¨æŒ‡é’ˆï¼Œåˆ©ç”¨&amp;ä¼ å…¥å˜é‡åœ°å€ï¼Œä¿®æ”¹æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ä¿å­˜çš„å€¼ï¼Œå¦‚ï¼š*p = x;çš„ç”¨æ³•å¦‚æžœåªæ˜¯ä»‹ç»è¿™äº›ï¼Œé‚£å¤ªç®€å•äº†ï¼Œè¿™é‡Œæƒ³è¦è¯´æ˜Žçš„æ˜¯æŒ‡é’ˆåœ¨å‡½æ•°å‚æ•°ä¼ é€’è¿‡ç¨‹ä¸­çš„å˜åŒ–ã€‚å¦‚æžœä¸€ä¸ªå‡½æ•°çš„å‚æ•°ä¸­å­˜åœ¨æŒ‡é’ˆï¼Œå¹¶ä¸”è¿™ä¸ªå‡½æ•°å†…ä¼šæ”¹å˜ä¼ å…¥è¿™ä¸ªæŒ‡é’ˆçš„æŒ‡å‘ï¼ˆå¦‚ï¼šé“¾è¡¨éåŽ†ï¼‰ï¼Œé’ˆå¯¹è¿™ç§æƒ…å†µï¼ŒCä¾ç„¶éµå¾ªå€¼ä¼ é€’çš„è§„åˆ™ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå³ä¾¿æŒ‡é’ˆè¢«ä¼ å…¥å‡½æ•°ä¸­äº†ï¼Œå®ƒä¹Ÿä¸ä¼šæ”¹å˜è¿™ä¸ªæŒ‡é’ˆåœ¨mainæˆ–å…¶ä»–å‡½æ•°ä¸­çš„æŒ‡å‘ï¼Œå…·ä½“è¯·çœ‹ä¸‹é¢çš„ä»£ç ï¼š1234567891011121314#include &lt;stdio.h&gt;void f(int *a);int main(int argc, char const * argv[])&#123; int *A; printf("%p\n", A); f(A); printf("%p\n", A); return 0;&#125;void f(int *a)&#123; a++;&#125; ä¸Šè¿°è¿™æ®µä»£ç çš„ä¸¤æ¬¡è¾“å‡ºç»“æžœæ˜¯ä¸€è‡´çš„ï¼Œä¹Ÿå³æŒ‡é’ˆä¹Ÿæ˜¯éµå¾ªå€¼ä¼ é€’çš„åŽŸåˆ™çš„ã€‚ typedefå…³äºŽtypedefçš„ç”¨æ³•ï¼Œè¿™é‡Œä¸åšè¿‡å¤šä»‹ç»ï¼Œåªæ”¶é›†ä¸€ä¸‹å¹³å¸¸è§åˆ°çš„ä½¿ç”¨æ–¹æ³•ã€‚ ä¸ºåŸºæœ¬æ•°æ®ç±»åž‹å®šä¹‰æ–°çš„ç±»åž‹å1typedef int Data; ä¸Šè¿°ä»£ç çš„ä½œç”¨èƒ½è¾¾åˆ°çš„æ•ˆæžœå°±æ˜¯intå’ŒDataç­‰ä»·ï¼Œä¹Ÿå³int a;å’ŒData a;æ˜¯ä¸¤ç§ç›¸åŒçš„å†™æ³•ï¼Œæ­¤ç§æ–¹æ³•åœ¨è·¨å¹³å°ç§»æ¤å’Œä½œæœ‰æ„ä¹‰çš„ç±»åž‹åæ—¶å¾ˆæ–¹ä¾¿ã€‚ ä¸ºè‡ªå®šä¹‰ç»“æž„ç±»åž‹å®šä¹‰ç±»åž‹åç§°æ³¨æ„è¯´æ³•ï¼Œä¸ºè‡ªå®šä¹‰ç»“æž„ç±»åž‹å®šä¹‰ç±»åž‹åç§°ï¼Œæ³¨æ„åªæ˜¯ç±»åž‹åç§°å“¦ï¼Œä¸‹é¢æ˜¯ä¸€èˆ¬çš„ä½¿ç”¨æ–¹æ³•ã€‚1234typedef struct point&#123; int x, y;&#125; Point; å¦‚æžœéœ€è¦ä¸ºç»“æž„å®šä¹‰æŒ‡é’ˆï¼Œéœ€è¦æ¢ä¸€ç§æ–¹æ³•ï¼š12345typedef struct LNode *List;struct LNode&#123; int Data; List Next;&#125;; ä¸è¿‡ä¸€èˆ¬è€Œè¨€ï¼Œæ ‡å‡†çš„å†™æ³•æ˜¯ä¸‹é¢è¿™ç§ï¼š12345struct LNode&#123; int Data; struct LNode *Next;&#125;;typedef struct LNode *List; ä¸¤ç§å†™æ³•éƒ½æ˜¯ç¼–è¯‘é€šè¿‡çš„ï¼ˆNo Warningsï¼‰ï¼Œç©¶ç«Ÿæ€Žä¹ˆå†™ï¼Œå°±æ˜¯æ™ºè€…è§æ™ºçš„äº‹æƒ…äº†ã€‚ ä¸ºæ•°ç»„å®šä¹‰ç±»åž‹åç§°12typedef int int_array[10];int_array array; æŒ‰ç…§ä¸Šè¿°ä»£ç ï¼Œ arrayå°±æ˜¯ä¸€ä¸ªå®¹é‡ä¸º10çš„æ•´åž‹æ•°ç»„äº†ã€‚ ä¸ºæŒ‡é’ˆå®šä¹‰åç§°123456/*odinary pointer*/typedef char* Pchar;/*function pointer*/typedef int *(*Pfun)(int, char *);Pfun a[5]; //Pfun a[5] &lt;==&gt; int *(*a[5])(int, char *); ä¸Šè¿°ä»£ç ä¸­ï¼Œint *(*a[5])(int, char *)å®žé™…ä¸Šæ˜¯å®šä¹‰äº†ä¸€ä¸ªè¿”å›žå€¼ä¸ºint*çš„å‡½æ•°æŒ‡é’ˆæ•°ç»„ï¼Œå‡½æ•°çš„æœ‰ä¸¤ä¸ªï¼Œåˆ†åˆ«æ˜¯intå’Œchar *ã€‚ two-dimensional arrayCè¯­è¨€ä¸­å®žé™…ä¸Šå¹¶æ²¡æœ‰ä¸¥æ ¼æ„ä¹‰ä¸Šçš„äºŒç»´æ•°ç»„ï¼ˆå…¶ä»–ç¨‹åºè®¾è®¡è¯­è¨€å¯èƒ½ä¹Ÿæ˜¯å¦‚æ­¤ï¼Ÿï¼‰ï¼Œå› ä¸ºç‰©ç†å†…å­˜çš„åœ°å€æ˜¯è¿žç»­ä¸”ä¸€å—ä¸€å—çš„ï¼Œé‚£Cè¯­è¨€æ˜¯å¦‚ä½•åŽ»ä¿å­˜äºŒç»´æ•°ç»„å’Œå¯»å€çš„å‘¢ï¼Ÿ æŒ‰ç…§ä¸Šè¿°çš„æ€è·¯ï¼Œå…ˆæ¥æ€»ç»“ä¸€ä¸‹äºŒç»´æ•°ç»„çš„ç‰¹ç‚¹ã€‚å¾ˆæ˜Žæ˜¾ï¼ŒäºŒç»´æ•°ç»„åŒ…å«ä¸‰ä¸ªå‚æ•°ï¼šè¡Œï¼ˆRowï¼‰ã€åˆ—ï¼ˆColumnï¼‰å’Œéœ€è¦å­˜çš„æ•°æ®ï¼ˆDataï¼‰ï¼Œæ—¢ç„¶å‰é¢å·²ç»è¯´è¿‡äº†ç‰©ç†å†…å­˜æ˜¯è¿žç»­åˆ†å¸ƒçš„ï¼Œé‚£æ¯«æ— ç–‘é—®ï¼ŒäºŒç»´æ•°ç»„ä¸­çš„ Data ä¾ç„¶æ˜¯è¿žç»­çš„å­˜å‚¨åœ¨ç‰©ç†å†…å­˜ä¸­çš„ï¼Œè¿™ä¸ªçŽ°è±¡æ˜¯ä¸æ˜¯åœ¨å“ªè§è¿‡ï¼Ÿæ²¡é”™ï¼Œå°±æ˜¯ä¸€ç»´æ•°ç»„ï¼›æŽ¥ç€ï¼Œå¦‚ä½•åŽ»å¯»å€å‘¢ï¼Ÿè¿™ä¸ªé—®é¢˜å…¶å®žå¯ä»¥ç”¨äºŒç»´æ•°ç»„çš„è¡Œå’Œåˆ—æ¥è§£å†³ï¼Œå‡è®¾æ€»è¡Œæ•°ä¸ºRï¼Œæ€»åˆ—æ•°ä¸ºCï¼Œæ‰¾ç¬¬2è¡Œï¼Œç¬¬3åˆ—çš„å…ƒç´ ï¼ŒæŒ‰ç…§é¡ºåºå­˜å‚¨çš„è§„åˆ™ï¼Œå®žé™…ä¸Šå¯¹åº”å…ƒç´ çš„ä¸‹æ ‡ï¼ˆä¸‹æ ‡ä»Ž0å¼€å§‹ï¼‰åº”è¯¥æ˜¯2 * C + 3ï¼Œä¸€èˆ¬åŒ–å°±æ˜¯i * C + jã€‚ä¸¾ä¸ªå®žä¾‹ï¼ŒæŒ‰ç…§å¦‚ä¸‹çš„çŸ©é˜µï¼š$$\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6\\7 &amp; 8 &amp; 9\\10 &amp; 11 &amp; 12\\\end{matrix}$$Cè¯­è¨€ç¼–è¯‘å™¨è¦æå–8è¿™ä¸ªå…ƒç´ ï¼Œæ•´ä¸ªçŸ©é˜µæ˜¯4è¡Œ3çš„ï¼Œè‹¥è¡Œã€åˆ—ä¸‹æ ‡ä»Ž0å¼€å§‹ï¼Œè¡Œã€åˆ—å¾ªçŽ¯å˜é‡åˆ†åˆ«ä¸ºiã€jï¼Œé‚£ä¹ˆ8è¿™ä¸ªå…ƒç´ å¯¹åº”çš„ä¸‹æ ‡ï¼ˆi = 2, j = 2ï¼‰å°±æ˜¯i * C + j = 2 * 3 + 2 = 8ï¼Œå®žé™…ä¸Šä¹Ÿå°±æ˜¯ä»Žå·¦å¾€å³ä¾æ¬¡æŒ‰åºæ•°ä¸‹æ¥çš„ç»“æžœã€‚ characteräºŒç»´æ•°ç»„ä¹Ÿæœ‰å­—ç¬¦äºŒç»´æ•°ç»„å’Œæ•´åž‹äºŒç»´æ•°ç»„ï¼Œå­—ç¬¦äºŒç»´æ•°ç»„çš„ä½¿ç”¨ä¼šç®€å•ç‚¹ï¼Œå’±å…ˆä»Žç®€å•çš„æ¥ã€‚å­—ç¬¦äºŒç»´æ•°ç»„å®žé™…ä¸Šå¾ˆå®¹æ˜“ç†è§£ï¼Œå¯ä»¥æŠŠäºŒç»´æ•°ç»„æƒ³è±¡æˆä¸€æ ¹ä¸€æ ¹â€œè¾£æ¡â€ï¼ˆåˆ«è¯´ä½ æ²¡åƒè¿‡...å›§ï¼‰ï¼Œè¿™ä¸€æ ¹æ ¹â€œè¾£æ¡â€ï¼Œæ¯ä¸€æ ¹éƒ½æ˜¯ä¸€ä¸ªä¸€ç»´å­—ç¬¦æ•°ç»„ï¼ˆå…¶å®žå°±æ˜¯ä¸€ä¸ªå­—ç¬¦ä¸²å•¦~ï¼‰ã€‚1char str[3][5]; ä¸Šé¢è¿™è¡Œä»£ç çš„æ„æ€æ˜¯å£°æ˜Žä¸€ä¸ªå­—ç¬¦ä¸²æ•°ç»„ï¼Œè¿™ä¸ªå­—ç¬¦ä¸²æ•°ç»„çš„å®¹é‡å¤§å°æ˜¯3ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²èƒ½å­˜å‚¨çš„æœ€å¤§é•¿åº¦æ˜¯4ï¼ˆå› ä¸º\0ä¹Ÿè¦å ä¸€ä½ï¼‰ï¼Œä¹Ÿå¯ä»¥æŒ‰ç…§ä¸‹é¢çš„æ–¹æ³•åˆå§‹åŒ–ï¼š123char str[3][5] = &#123;"str1", "str2", "str3"&#125;; ä¹‹æ‰€ä»¥åˆ†å¼€ä¸‰è¡Œå†™ï¼Œæ˜¯å› ä¸ºæƒ³å±•ç¤ºå‡ºä¸€æ¡ä¸€æ¡çš„æ ·å­ï¼ˆç¬‘ingï¼‰ï¼Œè¿™æ˜¯å¯ä»¥ç›´æŽ¥è¾“å‡ºçš„å“¦~ å¦‚æžœä½ æŒ‡é’ˆå­¦çš„ä¸é”™çš„è¯ï¼Œä½ ä¸€å®šä¼šå‘çŽ°str[0]ã€str[1]å’Œstr[2]å…¶å®žå°±æ˜¯åˆ†åˆ«æŒ‡å‘è¿™ä¸‰ä¸ªå­—ç¬¦ä¸²çš„æŒ‡é’ˆã€‚ æ‰€ä»¥ï¼Œå­—ç¬¦ä¸²æ•°ç»„è¿˜å¯ä»¥è¿™æ ·å£°æ˜Žå’Œåˆå§‹åŒ–ï¼š123char *str[3] = &#123;"str1", "str2", "str3"&#125;; ä¸¥æ ¼ä¸Šæ¥è®²ï¼Œchar *str[3]å…¶å®žå£°æ˜Žäº†ä¸€ä¸ªæŒ‡é’ˆæ•°ç»„ï¼Œè¿™ä¸ªæŒ‡é’ˆæ•°ç»„æœ‰3ä¸ªå­—ç¬¦åž‹æŒ‡é’ˆå˜é‡ï¼Œåˆ†åˆ«æŒ‡å‘ä¸‰ä¸ªå­—ç¬¦ä¸²ã€‚å…¶ä¸­çš„æ¯ä¸ªæŒ‡é’ˆå˜é‡ï¼Œå…¶å®žå¯ä»¥å½“ä½œæ¯ä¸ªå­—ç¬¦ä¸²çš„å¤´æŒ‡é’ˆæ¥ç”¨ã€‚ numberæ˜Žç™½äº†å­—ç¬¦äºŒç»´æ•°ç»„åŽï¼Œæ•°å­—åž‹çš„äºŒç»´æ•°ç»„ç†è§£èµ·æ¥å°±ç®€å•äº†ã€‚é¦–å…ˆï¼Œå®ƒä¸å†æ˜¯â€œè¾£æ¡â€äº†ï¼Œä»–æ˜¯å•ç‹¬ä¸€ä¸ªä¸€ä¸ªçš„ï¼Œä¸è¿‡å­˜å‚¨æ–¹å¼ä¾ç„¶æ˜¯é¡ºåºå­˜å‚¨çš„ï¼ŒäºŒç»´æ•°ç»„çš„é€»è¾‘ç»“æž„ï¼Œå…¶å®žå°±æ˜¯ä¸Šé¢æåˆ°è¿‡çš„çŸ©é˜µã€‚ä¸è¿‡å®ƒçš„å®¹é‡è®¡ç®—å¾ˆç®€å•ï¼Œä¹Ÿå°±æ˜¯è¡Œåˆ—ä¹‹ç§¯äº†ã€‚ how to useå¦‚ä½•ä½¿ç”¨è¿™ç±»äºŒç»´æ•°ç»„ï¼Œæˆ‘ä»¬è€ƒè™‘ä¸‰ä¸ªæ–¹é¢çš„åº”ç”¨ï¼šè¾“å…¥ã€è¾“å‡ºå’Œä¼ é€’ã€‚ input and outputæ‡‚äº†è¾“å…¥ï¼Œå…¶å®žä¹Ÿå°±ä¼šè¾“å‡ºäº†ï¼Œé‚£å°±åªä»‹ç»è¾“å…¥äº†ï¼ˆå·æ‡’ðŸ˜œï¼‰ã€‚ å¯¹äºŽå­—ç¬¦ä¸²æ•°ç»„ï¼ˆè¿™æ ·å«å…¶å®žæ›´åˆé€‚ä¹Ÿæ›´æ˜“äºŽç†è§£ï¼‰ï¼Œä¸Žæ™®é€šä¸€ç»´æ•°ç»„ä¸€æ ·ï¼Œè‹¥æœ‰å¤šä¸ªè¾“å…¥ï¼Œåˆ™ä½¿ç”¨å¾ªçŽ¯ï¼Œé€ä¸ªè¯»å…¥å³å¯ã€‚ å¯¹äºŽæ•°å­—åž‹äºŒç»´æ•°ç»„ï¼Œå…ˆè¾“å…¥è¡Œï¼Œè¿˜æ˜¯å…ˆè¾“å…¥åˆ—å–å†³äºŽå®žé™…åº”ç”¨ï¼Œç”±äºŽä¸ä»…è¦è¾“å…¥è¡Œï¼Œè¿˜éœ€è¦è¾“å…¥åˆ—ï¼Œæ‰€ä»¥å¾—ä½¿ç”¨äºŒé‡å¾ªçŽ¯æžå®šã€‚ function parameter transfer äºŒç»´æ•°ç»„ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’çš„è¿‡ç¨‹å°±æ˜¯ä¸ªæœ‰ç‚¹çŽ„ä¹Žçš„è¿‡ç¨‹äº†ï¼Œä¸è¿‡åˆ‡è®°ä¸€ç‚¹ï¼Œæ•°ç»„ä¼ é€’åˆ°å‡½æ•°ä¸­çš„éƒ½æ˜¯æŒ‡é’ˆã€‚ å­—ç¬¦ä¸²æ•°ç»„ä¼ é€’æ—¶ï¼Œæœ‰ä¸¤ç§ä½¿ç”¨æ–¹æ³•ï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼šCharacter 1Character 21void fun(char (*str)[5], int n);1void fun(char str[][5], int n); ä¸Šè¿°çš„è¿™ä¸¤ç§æ–¹æ³•æœ‰ä¸€ä¸ªå…±åŒç‚¹ï¼Œä¹Ÿå³éœ€è¦ç»™å®šæ¯ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ã€‚ æ•°å­—åž‹äºŒç»´æ•°ç»„çš„ä¼ é€’ä¸Žå­—ç¬¦ä¸²æ•°ç»„çš„ä¼ é€’ç±»ä¼¼ï¼šNumber 1Number 21void fun(int (*array)[5], int n);1void fun(int array[][5], int n); boolæ—©æœŸçš„Cæ ‡å‡†å†…å…¶å®žæ˜¯æ²¡æœ‰boolç±»åž‹çš„ï¼ŒåŽŸå…ˆä¸€ç›´å­˜åœ¨äºŽC++ä¸­ï¼ŒåŽæ¥åœ¨C99æ ‡å‡†å‘å¸ƒçš„æ—¶å€™ï¼ŒåŠ å…¥äº†boolç±»åž‹ã€‚ åœ¨ä½¿ç”¨boolç±»åž‹æ—¶ï¼Œéœ€è¦å¼•å…¥å¤´æ–‡ä»¶stdlib.hï¼Œç”¨æ³•å¦‚ä¸‹ï¼š1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool func(int a) &#123; if(a &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main(int argc, char const *argv[]) &#123; printf("func(-1) = %d, func(1) = %d, func(0) = %d\n", func(-1), func(1), func(0)); return 0;&#125;/*Result:func(-1) = 0, func(1) = 1, func(0) = 1*/ æ˜Žæ˜¾å¯ä»¥çœ‹å‡ºæ­¤æ—¶false = 0, true = 1ã€‚ è‹¥æ— æ³•å¼•å…¥å¤´æ–‡ä»¶stdbool.hæ—¶ï¼Œè¯¥å¦‚ä½•ç»§ç»­ä¼˜é›…çš„ä½¿ç”¨boolç±»åž‹å‘¢ï¼Ÿ ä¸€èˆ¬è€Œè¨€ï¼Œæœ‰ä¸¤ç§æ–¹æ³•ï¼štypedef#define1typedef enum&#123;false, true&#125; bool;åˆ©ç”¨typedefå’Œenumå…³é”®å­—æž„é€ æžšä¸¾ã€‚123#define bool int#define false 0#define true 1ä½¿ç”¨å®å®šä¹‰ç›´æŽ¥å®šä¹‰ï¼ˆC99å°±æ˜¯è¿™æ ·å¹²çš„ï¼Œå¯ä»¥çœ‹çœ‹stdbool.hå¤´æ–‡ä»¶çš„å†…å®¹ï¼‰ã€‚ operatorå…³äºŽCè¯­è¨€è¿ç®—ç¬¦çš„é—®é¢˜ï¼Œå®žé™…ä¸Šå°±æ˜¯ä¸åŒè¿ç®—ç¬¦ä¹‹é—´ä¼˜å…ˆçº§ï¼ˆprecedenceï¼‰çš„é—®é¢˜ï¼Œè¿™éƒ¨åˆ†é—®é¢˜ï¼Œä¸»è¦æ˜¯é’ˆå¯¹åº”è¯•å§ï¼Œç”Ÿäº§çŽ¯å¢ƒä¸­å¤§æ¦‚å†™ä¸ªæµ‹è¯•ç¨‹åºå°±èƒ½å¾—å‡ºç»“è®ºäº†å§~ ä¼˜å…ˆçº§ è¿ç®—ç¬¦ ç»“åˆæ€§ 1 () ä»Žå·¦åˆ°å³ 2 !ã€+ã€-ã€++ã€â€“ ä»Žå³åˆ°å·¦ï¼ˆå•ç›®+ã€-ï¼‰ 3 *ã€/ã€% ä»Žå·¦åˆ°å³ 4 +ã€- ä»Žå·¦åˆ°å³ 5 &lt;ã€&lt;=ã€&gt;ã€&gt;= ä»Žå·¦åˆ°å³ 6 ==ã€!= ä»Žå·¦åˆ°å³ 7 &amp;&amp; ä»Žå·¦åˆ°å³ 8 &#124;&#124; ä»Žå·¦åˆ°å³ 9 =ã€+=ã€-=ã€*=ã€/=ã€%= ä»Žå·¦åˆ°å³ æ³¨æ„ï¼šä¸Šè¿°è¡¨æ ¼ç¬¬äºŒè¡Œä¸­ï¼Œâ€œå•ç›®+ã€-â€æŒ‡çš„å³æ˜¯æ­£è´Ÿå·ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[æˆ¿å±‹è£…ä¿®ä¹‹â€œå‘â€]]></title>
    <url>%2F2019%2F05%2F15%2F%E8%A3%85%E4%BF%AE%2F</url>
    <content type="text"><![CDATA[å¼•å­è¿™å‡ å¤©å®¶é‡Œçš„æˆ¿å­åœ¨è£…ä¿®ï¼Œçœ‹ç€æ¯äº²é‚£ä¹ˆå¿™ç¢Œå’Œæ“å¿ƒçš„æ ·å­ï¼ŒäºŽæ˜¯ä¾¿è¶ç€è‡ªå·±å·æ‡’çš„æ—¶é—´ï¼Œå›žåŽ»ååŠ©ä¸€ä¸‹æ¯äº²ï¼Œå¹¶é¡ºä¾¿æ”¶æ‹¾ç‚¹è‡ªå·±ä¹‹å‰çš„â€œå®¶å½“â€â€”â€” å°±æ˜¯ä¹¦å’Œå†™è¿‡çš„ç¬”è®°äº†ã€‚ ä½•è°“è£…ä¿®è¯´èµ·è£…ä¿®ï¼Œæˆ‘å¯¹è¿™ä¸ªåè¯çš„æ¦‚å¿µç•¥å¾®æœ‰ç‚¹æ¨¡ç³Šï¼Œå¾—åœ¨è¿™ä¸ªè¯å‰é¢åŠ ç‚¹å•¥æ¥å¸®åŠ©ç†è§£å’Œæƒ³è±¡ï¼Œæ¯”å¦‚ï¼šæˆ¿å­è£…ä¿®ã€‚ä»”ç»†æ¥è®²ï¼Œè£…ä¿®åˆç§°è£…æ½¢æˆ–è£…é¥°ï¼Œæ˜¯æŒ‡åœ¨ä¸€å®šåŒºåŸŸå’ŒèŒƒå›´å†…è¿›è¡Œçš„ï¼ŒåŒ…æ‹¬æ°´ç”µæ–½å·¥ã€å¢™ä½“ã€åœ°æ¿ã€å¤©èŠ±æ¿ã€æ™¯è§‚ç­‰æ‰€å®žçŽ°çš„ï¼Œä¾æ®ä¸€å®šè®¾è®¡ç†å¿µå’Œç¾Žè§‚è§„åˆ™å½¢æˆçš„ä¸€æ•´å¥—æ–½å·¥æ–¹æ¡ˆå’Œè®¾è®¡æ–¹æ¡ˆã€‚ä¸€èˆ¬è€Œè¨€ï¼Œé’ˆå¯¹ä¸åŒçš„çŽ¯å¢ƒï¼Œæœ‰ç€ä¸åŒçš„è£…ä¿®æ–¹æ¡ˆå’Œé£Žæ ¼ï¼Œé…’åº—å’Œå•†åœºçš„è£…ä¿®æ–¹æ¡ˆå’Œé£Žæ ¼å°±å¤§ä¸ç›¸åŒï¼Œè€Œè¿™æ˜¯ç”±è¿™äº›åœºæ‰€çš„èŒèƒ½æ‰€ç¡®å®šçš„ï¼Œå¿…é¡»è¦æ»¡è¶³å¤§ä¼—åŒ–çš„è®¤çŸ¥ï¼Œå³è£…ä¿®èƒ½è¢«å¤§ä¼—æ‰€æŽ¥å—ã€ç†è§£ï¼Œè¿›è€Œè¾¾åˆ°å–œæ¬¢ã€‚è£…ä¿®ï¼Œéœ€è¦æ–½å·¥ï¼Œä¾æ®æ–½å·¥çš„å¯¹è±¡ï¼ˆæ°´ç”µã€å¢™ä½“ã€åœ°æ¿ã€å¤©èŠ±æ¿ç­‰ï¼‰ï¼Œå¯¹åº”çš„å·¥äººå¸ˆå‚…ä¹Ÿå¯ä»¥åˆ†ä¸ºï¼šæœ¨å·¥ã€æ°´ç”µå·¥ã€ç“¦å·¥ã€æ²¹å·¥ï¼Œè€Œæ‚¨å®¶ä½çš„æˆ¿å­çš„â€œå¤–è§‚â€å°±æ˜¯ç”±è¿™äº›äººï¼Œä¸€æ­¥ä¸€æ­¥æ¥å®Œæˆçš„ã€‚ å¦‚ä½•â€œè£…ä¿®â€çœ‹ç€ä¸Šé¢çš„å¤§æ ‡é¢˜ï¼Œä¹‹æ‰€ä»¥åŠ ä¸Šå¼•å·çš„åŽŸå› åœ¨äºŽï¼Œå¯¹äºŽæˆ¿ä¸»ï¼ˆä¹°æˆ¿çš„äººï¼‰è€Œè¨€ï¼Œå¦‚ä½•è£…ä¿®å‘¢ï¼Œå…¶å®žå°±æ˜¯èŠ±é’±æ‰¾äººå¹²æ´»ç½¢äº†ï¼Œæ¯•ç«Ÿå’±åˆä¸ä¼šå’Œæ°´æ³¥ã€åšæœ¨å·¥çš„ã€‚å—¯ï¼Œæ—¢ç„¶æ˜¯è¦èŠ±é’±ï¼Œé‚£å’±è¿™é’±å¾—èŠ±çš„åœ¨â€œç‚¹â€ä¸Šæ‰è¡Œï¼Œè‡³äºŽä¼šä¸ä¼šè¢«å‘ï¼Œè¿™å°±å¾—æ‰¾å¯¹äººäº†ã€‚é‚£ä¹ˆå›žåˆ°æ­£é¢˜ï¼Œå°±ç›®å‰å¸‚åœºè€Œè¨€ï¼Œæˆ¿å­è£…ä¿®çš„æ–¹å¼ï¼ˆå’Œå¸ˆå‚…çš„â€œå•†åŠ¡â€åˆä½œæ–¹å¼ðŸ˜‚ï¼‰å¤§æ¦‚æœ‰ä¸¤ç§ï¼š åŒ…å·¥åŒ…æ–™ï¼Œä¹Ÿå³â€œåŒ…å¹²â€ï¼ˆè¿™ç§å®£ä¼ æ‰‹æ®µéšå¤„å¯è§â€¦ï¼‰åŒ…å·¥ä¸åŒ…æ–™ï¼Œææ–™éœ€è¦ä¸»äººè´­ä¹°ï¼Œå¸ˆå‚…åªè´Ÿè´£å¹²æ´»äº† é‚£ä¹ˆï¼ŒæŒ‰ç…§ä»¥ä¸Šçš„ä¸¤ç§æ–¹å¼ï¼Œä¹Ÿæœ‰ä¸åŒçš„ä¼˜ç‚¹å’Œç¼ºç‚¹ï¼ŒåŒ…å·¥åŒ…æ–™æœ€ç›´æŽ¥çš„ä¼˜ç‚¹å°±æ˜¯ï¼Œå®¢å®˜æ‚¨ç»™é’±å°±æˆï¼Œä¸€åˆ‡å¸ˆå‚…æ›¿æ‚¨æžå®šã€‚è¿™ç§æ–¹å¼ï¼Œå¾—çœ‹æ‰¾çš„å¸ˆå‚…çš„äººå“äº†ï¼Œè¦ä¸ç„¶ç»™æ‚¨å·ç‚¹å·¥ã€å‡ç‚¹æ–™ï¼Œæˆ¿å­ä½ä¸ªä¸€å¹´åŠè½½å°±è¿”å·¥çš„ï¼Œé‚£å¯æ­£æ˜¯æœ‰çš„å—äº†ï¼Œå½“ç„¶äº†ï¼Œè¦æ˜¯æ‚¨é’±ç»™çš„è¶³ï¼Œé‚£å½“å’±æ²¡è¯´è¿™è¯ã€‚ä¸è¿‡ï¼Œå¯¹äºŽä¸€èˆ¬å®¶åº­è€Œè¨€ï¼Œå¤šå°‘è¿˜æ˜¯ä¼šè€ƒè™‘åˆ°ç»¼åˆé¢„ç®—åŠæ€§ä»·æ¯”ç­‰æ–¹é¢çš„ã€‚æ‰€ä»¥å‘¢ï¼Œé€‰æ‹©è¿™ç§æ–¹å¼çš„ï¼Œä¸€èˆ¬ä¼šæ‰¾äº²æˆšæˆ–å…³ç³»ç‰¹åˆ«é“çš„â€œå“¥ä»¬â€ï¼ˆäº²æœ‹å¥½å‹ï¼‰ã€‚å¯¹äºŽå¦å¤–ä¸€ç§æ–¹å¼è€Œè¨€ï¼Œé‚£å°±æ„å‘³ç€æˆ¿ä¸»åˆå¾—æƒ³åŠžæ³•æ‰¾äººï¼Œåˆå¾—æƒ³åŠžæ³•åŽ»æ‰¾æ¸ é“è´­ä¹°åˆæ ¼çš„ææ–™ï¼ˆåŠ³å¿ƒå•ŠðŸ˜ï¼‰ã€‚å…ˆä¸è¯´æ‰¾äººå¹²æ´»å¾—æ‰¾ä¸ªé è°±çš„äººï¼Œå•å•åªä»Žè´­ä¹°ææ–™çš„è§’åº¦è®²ï¼Œæˆ¿ä¸»è‹¥ä¸æ˜¯ç›¸å…³è¡Œä¸šå†…çš„äººå£«ï¼Œåœ¨è´­ä¹°è¿™äº›ææ–™çš„æ—¶å€™ï¼Œä¼šæ¯”è¾ƒå›°éš¾ã€‚é¦–å…ˆï¼Œä¸çŸ¥é“è´­ä¹°é‚£ä¸ªåž‹å·ã€é‚£ä¸ªå“ç‰Œçš„ææ–™ï¼Œä¸è¿‡è¿™ä¸ªé—®é¢˜å¯ä»¥é€šè¿‡åŽ»è¯¢é—®é›‡ä½£çš„å¸ˆå‚…æ¥è§£å†³ã€‚ç´§æŽ¥ç€çš„é—®é¢˜ï¼Œå°±æ˜¯è´­ä¹°çš„æ¸ é“å’Œâ€œè¯†è´§â€çš„æœ¬é¢†äº†ï¼Œè´­ä¹°æ¸ é“ç•¥å¸¦é£Žé™©ï¼Œä¸ç„¶ä¹°åˆ°æ¬¡å“æˆ–å‡è´§å°±éš¾å—äº†ï¼Œå½“ç„¶å¦‚è‹¥èƒ½è‡ªå·±åˆ†è¾¨å‡è´§ï¼Œé‚£æœ€å¥½ä¸è¿‡äº†ï¼ˆéœ€è¦ç»éªŒï¼‰ã€‚å…¶å®žï¼Œåœ¨æ•´ä¸ªè£…ä¿®è¿‡ç¨‹ä¸­ï¼Œä»…ä»…åªæ³¨æ„ä¸Šé¢çš„å†…å®¹è¿˜ä¸å¤Ÿï¼Œä»Žä¸€å¼€å§‹ç¡®å®šè£…ä¿®çš„æ—¶å€™ï¼Œæœ‰ç‚¹éœ€è¦ç¡®å®šçš„å°±æ˜¯ï¼Œè£…ä¿®çš„é¡ºåºäº†ï¼ä¸€èˆ¬è€Œè¨€ï¼Œå¯ä»¥å¤§æ¦‚æŒ‰ç…§ä¸‹é¢è¿™ä¸ªé¡ºåºæ¥è¿›è¡Œï¼š ä¸»ä½“æ”¹é€  â†’ æ°´ç”µ â†’ ç“¦å·¥ â†’ æœ¨å·¥ â†’ æ²¹å·¥ â†’ ç¯é¥° â†’ æ¸…æ´ â†’ éªŒæ”¶å½“ç„¶äº†ï¼Œä¸åŒåœ°åŒºçš„è£…ä¿®å¸‚åœºçš„è£…ä¿®é¡ºåºå¯èƒ½ä¸æ˜¯ä¸€è‡´çš„ï¼Œä½†å¤§ä½“ä¸Šæ˜¯ä¸€æ ·çš„ï¼Œä¸ç„¶çš„è¯ï¼Œä¸åŒæ‰‹è‰ºçš„å¸ˆå‚…æ— æ³•é…åˆå¹²æ´»çš„ã€‚ è£…ä¿®ä¹‹â€œå‘â€ä¿—è¯è¯´çš„å¥½ï¼šåƒä¸€å ‘é•¿ä¸€æ™ºæ‰€è°“çš„è£…ä¿®ä¹‹â€œå‘â€ï¼Œâ€œå‘â€åœ¨ä»€ä¹ˆåœ°æ–¹å‘¢ï¼Ÿè¿˜èƒ½åœ¨å“ªâ€¦é’±å‘—ï¼Œæ­£æ‰€è°“ï¼Œæ— å•†ä¸å¥¸ï¼Œä¸œè¥¿å–ç»™ä½ ï¼Œå•†å®¶å“ªèƒ½ä¸èµšé’±å‘¢ï¼Œæ˜¯å§ã€‚ä¸è¿‡è¯è¯´å›žæ¥ï¼Œå’±è¿˜æ˜¯é‚£ä¸ªæ€åº¦ï¼Œèµšé’±å¯ä»¥ï¼Œä»·æ ¼åˆç†å…¬é“ï¼Œè´¨é‡ä¼˜è‰¯è€ç”¨ï¼Œè¯¥ä»˜çš„é’±å’±ç…§æ ·ç»™ï¼ˆå“‡ï¼Œå¥½æ— åŠ›çš„æ„Ÿè„š~ï¼‰ã€‚ä¸è¿‡å‘¢ï¼Œä¸åŒåœ°åŒºçš„å¸‚åœºå¯èƒ½åœ¨æŸäº›åœ°æ–¹ä¸Šæœ‰æ‰€å·®å¼‚ã€‚å°±æ‹¿å‰å‡ å¤©ï¼Œå’±ç¢°åˆ°çš„ä¸€ä¸ªâ€œå‘çˆ¹â€çš„äº‹æƒ…ä¸ºä¾‹ã€‚ èµ·å› å®¶ä¸­æˆ¿å­è£…ä¿®ï¼Œéœ€è¦å®‰è£…é˜²ç›—ç½‘ï¼ŒäºŽæ˜¯ä¾¿æ‰¾äººåŽ»åšäº†ï¼Œä½†æ²¡æœ‰æå‰æŠŠä»·æ ¼è°ˆå¥½ï¼ˆè¿™ä¸ªæ˜¯çœŸçš„çƒ¦ï¼Œä»¥åŽåšäº‹ä¹‹å‰ä¸€å®šå¾—å…ˆæŠŠè¿™äº›åˆ©ç›Šå…³ç³»å¤„ç†å¥½ï¼‰ã€‚ å®‰è£…åšå¥½ä¹‹åŽï¼Œå³è¿›è¡Œå®‰è£…ï¼Œæ•´ä¸ªè¿‡ç¨‹ä¸­ä¸€åˆ‡OKã€‚ é—®é¢˜ç”±äºŽåœ¨åšä¹‹å‰ï¼Œæ²¡æœ‰è°ˆå¥½ä»·æ ¼çš„é—®é¢˜ï¼Œä»Žè€Œå¯¼è‡´ï¼Œæœ€åŽåœ¨ç»“è´¦çš„æ—¶å€™ï¼Œæˆäº†â€œç³Šæ¶‚è´¦â€ï¼Œé€ æˆäº†ä¸€ç§å…¬è¯´å…¬æœ‰ç†ï¼Œå©†è¯´å©†æœ‰ç†çš„å±€é¢ï¼Œæ‰‹åŠ¨æ‚è„¸ingã€‚ é—®é¢˜æˆå› ä¹‹æ‰€ä»¥ä¼šå­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œå’±å¾—å…ˆæ˜Žç¡®è¿™ä¸ªé˜²ç›—ç½‘çš„è®®ä»·è§„åˆ™ï¼ŒæŒ‰ç…§æˆ‘è¿™è¾¹æœ¬åœ°çš„å¸‚åœºï¼Œé˜²ç›—ç½‘æ˜¯æŒ‰ç…§$Xå…ƒ/m^2$çš„ä»·æ ¼æ¥è®¡ç®—çš„ï¼Œè€Œé˜²ç›—ç½‘çš„ç»“æž„æ˜¯ä¸‹é¢è¿™ç§ç»“æž„ï¼šæŽ¥ä¸‹æ¥çš„é—®é¢˜æ˜¯æŒ‰ç…§è¿™ä¸ªç»“æž„ï¼Œå¦‚ä½•è®¡ç®—è¿™ä¸ªç‰©ä½“æ‰€å çš„é¢ç§¯ï¼ˆ$m^2$ï¼‰ï¼Œæ°å·§é—®é¢˜å°±å‡ºåœ¨è¿™é‡Œäº†ã€‚ è®¡ç®—æ–¹å¼æŒ‰ç…§ä¹‹å‰çš„æ€è·¯ï¼Œé˜²ç›—é—¨çª—é¢ç§¯çš„è®¡ç®—æ–¹æ³•å…¶å®žæœ‰ä¸¤ç§ï¼š é€é¢è®¡ç®—ï¼Œç´¯åŠ å¾—ç»“æžœé€é¢å¹³é“ºï¼Œè®¡ç®—æ•´ä½“ï¼Œå‡åŽ»ä¸å­˜åœ¨é¢ï¼Œå³å¾—ç»“æžœ å…·ä½“è€Œè¨€ï¼Œå¯ä»¥å‚ç…§ä¸‹å›¾è¿›è¡Œè®¡ç®—ï¼šä»Žå›¾ä¸­å¯ä»¥åˆ†åˆ«çŸ¥é“ä¸¤ç§æ–¹æ³•å¯¹åº”çš„è®¡ç®—æ–¹æ³•ï¼š $1.\ S_{sum} = S_1 + S_2 + S_3 + S_4 + S_5$$2.\ S_{sum} = S - 4 \times S_1$ åªè¦å°ºå¯¸é‡çš„æ˜¯æ­£ç¡®çš„ï¼Œä¸¤ç§æ–¹æ³•çš†å¯è®¡ç®—å‡ºé˜²ç›—é—¨çª—çš„çœŸå®žé¢ç§¯ï¼Œå•†å®¶é‡‡ç”¨çš„æ˜¯ç¬¬äºŒç§æ–¹æ³•ï¼Œä¸è¿‡æ²¡æœ‰å‡åŽ»é‚£4å—ä¸å­˜åœ¨çš„é¢ç§¯ï¼Œè€Œè¿™ä¹Ÿå°±å¯¼è‡´æŒ‰ç…§è¿™ä¸¤ç§æ–¹æ³•è®¡ç®—å‡ºæ¥çš„ç»“æžœç›¸å·®äº†å¤§æ¦‚10ä¸ª$m^2$å·¦å³ï¼Œä¸Žå•ä»·ä¸€åˆè®¡ï¼Œå·®å€¼è¿˜æ˜¯æ¯”è¾ƒå¤§çš„ã€‚å¦‚æžœæ˜¯å­˜åœ¨çš„é¢ç§¯è®¡ç®—åœ¨å†…ï¼Œè¿˜å¯ä»¥ç†è§£ï¼Œä½†é‚£4å—é¢ç§¯æ˜¯ä¸å­˜åœ¨çš„ï¼Œä¸å­˜åœ¨è¿˜ç®—è¿›åŽ»ï¼Œé‚£ä¸æ˜¯æ— ä¸­ç”Ÿæœ‰å—ï¼ŸäºŽæ˜¯åŽ»æ‰¾å•†å®¶ç†è®ºï¼Œç»“æžœè¢«å‘ŠçŸ¥æ˜¯å¸‚åœºè§„åˆ™ã€è¡Œä¸šè§„åˆ™ï¼ˆæ€»ä¹‹å°±æ˜¯ä¸è®©ä»·ï¼‰ï¼Œè¿™ä¸æ˜¯æ‘†æ˜Žäº†å‘äººä¹ˆï¼ŸåŽæ¥ï¼Œåˆäº†è§£åˆ°ï¼Œæ®è¯´å¦‚æžœæ˜¯ç»™äº²æœ‹å¥½å‹åšï¼Œæ˜¯å¾—å‡åŽ»é‚£å››ä¸ªä¸å­˜åœ¨çš„é¢ç§¯çš„ï¼Œå¦‚æžœä¸æ˜¯äº²æœ‹å¥½å‹ï¼Œé‚£å°±æ­‡èœäº†ï¼ˆðŸ˜‚ï¼Œæžœç„¶æ˜¯æ— å•†ä¸å¥¸ï¼‰ã€‚ è§£å†³æ–¹å¼ç£¨å˜´çš®å­ç£¨å˜´çš®å­ç£¨å˜´çš®å­â€¦æ²¡æœ‰å•¥æ·å¾„å“ˆ~ æ€»ç»“è¿˜æ˜¯é‚£å¥è¯ï¼Œåšäº‹ä¹‹å‰ï¼Œåƒä¸‡è¦å¤„ç†å¥½åˆ©ç›Šå…³ç³»ã€‚ä¸è¿‡è¯è¯´å›žæ¥ï¼Œå•†å®¶è¿™ç¡®å®žæœ‰ç‚¹â€œå‘â€äººï¼Œæ˜Žé‡Œæ¥è¯´ææ–™è´µå³å¯ï¼Œè¿˜çŽ©è¿™äº›â€œèŠ±æ‹›â€ï¼ŒçœŸæ˜¯â€œå…µä¸åŽŒè¯ˆâ€ï¼Ÿæ›´ä½•å†µåªæ˜¯ç®€å•çš„å°å­¦æ•°å­¦ðŸ˜‚ï¼å“Žï¼Œè¿™ä¹Ÿå°±æ¬ºè´Ÿä¸€ä¸‹å¸¸å¹´åœ¨å¤–æ‰“å·¥æŒ£é’±çš„å’Œæ–‡åŒ–æ°´å¹³ä¸é«˜çš„äººï¼Œæ°å·§æ­£å¥½æ˜¯å’±ä»¬çˆ¶äº²ã€æ¯äº²é‚£ä¸€è¾ˆäººã€‚å¦å¤–ï¼Œä»Žè¿™äº›äº‹æƒ…ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œå®¶è£…è¿™ä¸ªè¡Œä¸šçš„æ°´ä¹Ÿæ˜¯è¶³å¤Ÿæ·±çš„å“ˆï¼Œå…ˆä¸è¯´ææ–™å¯èƒ½ä¼šæžé¬¼äº†ï¼Œå…‰ç€ç®—è´¦éƒ½ç€å®žè®©äººè§‰ç€å‘çˆ¹ðŸ˜‘ï¼Œéƒ½ä¸çŸ¥é“è¯¥è¯´å•¥å¥½äº†ã€‚ç±»ä¼¼çš„é—®é¢˜ï¼Œåœ¨æœ¨å·¥ã€ç“¦å·¥ç­‰è£…ä¿®è¿‡ç¨‹ä¸­åŒæ ·å­˜åœ¨ï¼ˆå…¶ä»–è¡Œä¸šä¼°è®¡ä¹Ÿè¿™æ ·ï¼‰ï¼Œæ‰€ä»¥ï¼Œåƒä¸€å ‘é•¿ä¸€æ™ºï¼Œè¿™è¯è®°ä½å‡†æ²¡é”™~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>Interior Finish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¥‡è‘©çš„å›½å†…BGPä¸šåŠ¡æž¶æž„]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%A5%87%E8%91%A9%E7%9A%84%E5%9B%BD%E5%86%85BGP%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Introå›½å†…å­˜åœ¨BGPä¸šåŠ¡ï¼Œä½†æ˜¯å®žé™…ä¸Šå¹¶ä¸æ˜¯ä¸¥æ ¼æ„ä¹‰ä¸Šçš„BGPï¼Œè€Œæ˜¯é€šè¿‡æ¨¡æ‹Ÿæ¥æž„å»ºçš„â€œé™æ€BGPâ€ï¼›ä¹‹æ‰€ä»¥æ˜¯è¿™æ ·çš„æƒ…å†µï¼ŒåŽŸå› æ˜¯è¿è¥å•†å’Œæ”¿ç­–â€¦æ‰“ä½ï¼Œæ‰¯è¿œäº†ï¼Œæˆ‘ä»€ä¹ˆéƒ½ä¸çŸ¥é“ðŸ¤«ã€‚åæ­£å®¢æˆ·éœ€è¦å°±åšðŸ˜‚ï¼Œæœ¬ç€å…ˆåšå…ˆå®Œäº‹ï¼Œéšæ‚£æ—¥åŽå†è¯´çš„åŽŸåˆ™ï¼ˆç¬‘ingï¼‰ï¼Œå¥½æ­¹ç®—æ˜¯æ¯é¥¬å‡ºæ¥ä¸€ä¸ªã€‚ Static BGP Brief Descriptionä¸ŽBGPç›¸å…³çš„åŽŸç†å†…å®¹åœ¨è¿™é‡Œä¸ä»‹ç»äº†ï¼ˆå’±ä¹Ÿä¸å¤ªæ‡‚ðŸ¤£ï¼‰ï¼Œå…·ä½“è¯´ä¸‹åšè¿™çŽ©æ„çš„å‰å› åŽæžœå§ï¼Œè¿™éƒ¨åˆ†å†…å®¹å°±å½“â€œä¾ƒå¤§å±±â€å§ðŸ¤”ã€‚ å›½å†…è¿è¥å•†ä¸‰å·¨å¤´ï¼šä¸­å›½ç”µä¿¡ã€ä¸­å›½ç§»åŠ¨ã€ä¸­å›½è”é€šï¼Œè¿™ä¸‰å®¶å›½ä¼æƒ³å¿…å¤§å®¶éƒ½æ¯”è¾ƒç†Ÿï¼ˆtaoï¼‰çŸ¥ï¼ˆyanï¼‰ï¼›è€Œä¸Žè¿™ä¸‰å®¶è¿è¥å•†äº’è”çš„æ–¹å¼å‘¢ï¼Œä¸€å¾‹å…¨éƒ¨éƒ½æ˜¯é‡‡ç”¨é™æ€äº’è”çš„æ–¹å¼ï¼›ä¹‹æ‰€ä»¥é‡‡ç”¨é™æ€äº’è”ï¼Œä¹Ÿä¸æ˜¯å› ä¸ºåŠ¨æ€æŠ€æœ¯ä¸æˆç†Ÿç­‰ä¹‹ç±»çš„ç¼˜ç”±ï¼Œå…¶å®žå°±æ˜¯ç®€å•ä¸”æ˜“æŽ§åˆ¶ï¼Œç›´æŽ¥æ”¾ç»™ä½ å°±å®Œäº‹ï¼Œæƒ³æŽ§åˆ¶ç›´æŽ¥ä¿®æ”¹é…ç½®å°±å¥½ï¼Œå…¶å®žè¿˜æœ‰ä¸€ä¸ªç‚¹ï¼Œé‚£å°±æ˜¯é‡‡ç”¨åŠ¨æ€åŽï¼Œå¯¹æŸäº›ç½‘ç»œæä¾›å•†è€Œè¨€ä¼šæ¯”è¾ƒâ€œä¸å…¬å¹³â€ï¼ŒåŠ¨æ€è·¯ç”±æ”¶æ•›å¯æ˜¯é€‰æ‹©å»¶è¿Ÿæœ€å°ã€æŸè€—æœ€ä½Žçš„çº¿è·¯çš„ã€‚å…·ä½“å˜›ï¼Œå’±ä¹Ÿåˆ«å¤ªæ·±ç©¶ï¼Œæ˜¯è¿™ä¹ˆä¸ªè§„å®šï¼Œå¤§çŽ¯å¢ƒæ˜¯è¿™æ ·ï¼Œå’±æ”¹å˜ä¸äº†ï¼Œéµå®ˆå°±è¡Œäº†ã€‚è¯åœ¨è¯´å›žæ¥ï¼ŒæŒ‰ç…§è¿™æ ·çš„çŽ¯å¢ƒï¼Œå¯¹äºŽç½‘ç»œæä¾›å•†å’Œè¿è¥å•†æŽ¥å…¥çš„è·¯ç”±å™¨è€Œè¨€å°±åªèƒ½ä¿è¯ä¸€ä¸ªçº¿è·¯çš„æ–¹å‘äº†ï¼ˆå•ã€å¤šçº¿æ— æ³•ä¸ŽBGPå…±å­˜ï¼‰ï¼Œé‚£BGPåˆæ˜¯ä»Žä½•è°ˆèµ·çš„å‘¢ï¼Ÿè¿˜æœ‰å…¶ä»–çš„åŒçº¿ã€ä¸‰çº¿ä¹‹ç±»çš„ä¸šåŠ¡åˆæ˜¯æ€Žä¹ˆåšçš„ï¼Ÿ å¾—å˜žï¼Œå’±è¿˜æ˜¯å…ˆä»Žå•çº¿ä¸šåŠ¡è¯´èµ·å§ï¼Œè¿™æ²¡å•¥éš¾åº¦çš„ï¼Œå•çº¿ä¸šåŠ¡ï¼Œç»™æœåŠ¡å™¨é…ä¸€ä¸ªIPå®Œäº‹ï¼Œæ²¡å•¥è¯´çš„ã€‚è¿™ç±»ä¸šåŠ¡çš„ç‰¹ç‚¹å°±æ˜¯â€”ä¸ç®¡ä½ ç”¨æºIPåŽ»è®¿é—®ä»€ä¹ˆåœ°å€ï¼Œéƒ½æ˜¯ä»Žä¸€ä¸ªçº¿è·¯å‡ºåŽ»çš„ï¼Œæ¯”å¦‚ï¼ŒæºIPç”µä¿¡çš„ï¼Œé‚£ä½ å‡ºå±€å°±æ˜¯ç”µä¿¡çº¿è·¯ï¼ŒæºIPè”é€šçš„ï¼Œå‡ºå±€å°±æ˜¯è”é€šçº¿è·¯ã€‚ åœ¨è¯´åŒçº¿ä¸šåŠ¡ï¼Œå•çº¿ä¸šåŠ¡é…ä¸€ä¸ªIPï¼Œé‚£åŒçº¿ä¸šåŠ¡ä¸å°±é…ä¸¤ä¸ªIPå®Œäº‹å—ï¼Ÿ(âŠ™ï¹âŠ™)ï¼Œå¯¹äº†ä¸€åŠï¼›åŒçº¿ä¸šåŠ¡çš„ç¡®éœ€è¦é…ç½®ä¸¤ä¸ªIPï¼Œä½†æ˜¯å¹¶ä¸æ˜¯é…ç½®ä¸¤ä¸ªIPå°±å®Œäº‹äº†ï¼Œè¿˜éœ€è¦åœ¨æœåŠ¡å™¨ä¸Šå¯¼å…¥åŽ»å¾€å„ä¸ªåœ°å€æ®µçš„è·¯ç”±ã€‚ä»€ä¹ˆé¬¼ï¼ŸæœåŠ¡å™¨è¿˜èƒ½åŠ è·¯ç”±ï¼Œè¿˜çœŸèƒ½åŠ ðŸ˜“ï¼Œè¿™å¦‚æžœè¦è¯´ï¼Œåˆè¦ç‰µæ‰¯åˆ°ä¸€äº›ä¸œè¥¿ï¼Œå—¯ï¼Œåˆ«æ€¥ï¼Œç»™ä½ å¨“å¨“é“æ¥ã€‚ å’±å…ˆä¸è¯´æ€Žä¹ˆåŽ»åŠ è·¯ç”±ï¼Œå’±å…ˆä»‹ç»ä¸‹å›½å†…çš„ç½‘ç»œçŽ¯å¢ƒã€‚é¦–å…ˆå¾—æ˜Žç¡®IPåœ°å€è¿™ä¸ªçŽ©æ„åœ¨å¤§ç½‘çŽ¯å¢ƒå†…æ˜¯å”¯ä¸€å­˜åœ¨çš„ï¼ˆç§ç½‘åœ°å€ä½ å°±æŠ˜è…¾åŽ»å§ï¼‰ï¼Œæ¢å¥è¯è¯´ï¼Œä¸‰å¤§è¿è¥å•†æ˜¯æ‹¥æœ‰åªå±žäºŽè‡ªå·±çš„IPåœ°å€çš„ï¼ˆä»€ä¹ˆï¼Ÿä½ ä¹Ÿæƒ³è¦å±žäºŽè‡ªå·±çš„IPåœ°å€ï¼Ÿè‡ªå·±åŽ»æ‰¾ç®¡ç†IPçš„ç»„ç»‡åŽ»ä¹°å§ï¼Œå¤šå°‘é’±ï¼Ÿå˜¿å˜¿ï¼Œè‡ªå·±åŽ»é—®ã€‚ï¼‰ï¼Œå¹¶ä¸”è¿™äº›åœ°å€åœ¨å›½å†…çš„å¤§ç½‘çŽ¯å¢ƒä¸‹æ˜¯å”¯ä¸€çš„ã€‚è¿™æ ·å°±ä¼šäº§ç”Ÿä¸€ä¸ªé—®é¢˜ï¼Œæ—¢ç„¶è”é€šçš„åœ°å€åªå±žäºŽè”é€šï¼Œé‚£ç”µä¿¡ç”¨æˆ·å¦‚ä½•åŽ»è®¿é—®è”é€šçš„åœ°å€å‘¢ï¼Ÿç­”æ¡ˆå°±æ˜¯è¿è¥å•†ä¹‹é—´åšäº†äº’è”ï¼Œè‡³äºŽæ˜¯åŠ¨æ€çš„è¿˜æ˜¯é™æ€çš„ï¼Œè¿™ä¸ªï¼Œå˜¿å˜¿ï¼Œä¸æ˜¯å’±è®¨è®ºçš„èŒƒå›´ï¼Œåœ¨æœ‰äº’è”çš„å‰æä¸‹ï¼Œç”µä¿¡ç”¨æˆ·ä¹Ÿå°±å¯ä»¥åŽ»è®¿é—®è”é€šçš„åœ°å€å•¦ã€‚å¥½ï¼Œè¿™ä¸ªé—®é¢˜æ˜Žç™½äº†ï¼Œå’±åœ¨æ¥çœ‹çœ‹å¦å¤–ä¸€ä¸ªçŽ°è±¡ï¼Œä¸çŸ¥é“å„ä½çœ‹å®˜æœ‰æ²¡æœ‰ç•™æ„è¿‡ï¼Œç½‘ç»œæ¸¸æˆæ€»ä¼šæœ‰ä¸€äº›ç½‘é€šåŒºã€ç”µä¿¡åŒºç­‰ï¼Œå¦‚æžœç”µä¿¡ç”¨æˆ·å·²ç»å¯ä»¥è®¿é—®è”é€šåœ°å€äº†ï¼Œé‚£ä¹ˆè¿è¥å•†éƒ½åšæˆå…¨ç½‘å¯ä»¥äº’ç›¸è®¿é—®ä¸å°±å¾—äº†ï¼Œé‚£è¿™æ ·è¿˜æžè¿™äº›åŒºå¹²æ¯›ï¼Ÿè¯¶ï¼Œè¿™ä¸ªå…¶å®žæ˜¯æœ‰ç‚¹è®²ç©¶çš„ï¼Œå˜¿å˜¿ã€‚ç­”æ¡ˆå°±æ˜¯ï¼Œå¦‚æžœä½ æ˜¯è”é€šç”¨æˆ·ï¼Œä½ é€‰æ‹©ç½‘é€šåŒºè¿›è¡Œæ¸¸æˆï¼Œä½ ä¼šè§‰å¾—ç½‘é€Ÿéžå¸¸å¿«ã€‚ä½ é—®ä¸ºå•¥ï¼Ÿå› ä¸ºç½‘é€šåŒºçš„æ¸¸æˆæœåŠ¡å™¨IPè‚¯å®šä¹Ÿæ˜¯è”é€šçš„IPï¼Œè¿™æ ·åœ¨æœ¬è¿è¥å•†å†…éƒ¨è¿›è¡Œè®¿é—®çš„æ—¶å€™ï¼Œé‚£ä¸å°±æ˜¯åœ¨â€œå†…ç½‘â€é‡Œé¢è¿›è¡Œæ•°æ®äº¤äº’äº†å—ï¼Ÿéƒ½æ²¡è·‘åˆ°â€œå…¬ç½‘â€ä¸ŠåŽ»ï¼Œé€Ÿåº¦è‚¯å®šå¿«å•ŠðŸ˜‚ã€‚å…¶ä»–ä¹ŸåŒç†ï¼Œè¿™ä¹Ÿæ˜¯ä¸ºå•¥æœ‰äººä¼šè¯´ä¸­å›½çš„ç½‘ç»œå®žé™…ä¸Šæ˜¯ä¸€ä¸ªå¤§çš„å±€åŸŸç½‘ï¼Œç‰¹åˆ«æ˜¯è¢«Great Firewall of Chinaç¦æŽ‰ä¸€äº›å›½é™…IPåŽðŸ™Šã€‚ å¥½äº†ï¼Œåœ¨å›žåˆ°åŠ è·¯ç”±çš„é—®é¢˜ä¸Šæ¥ï¼Œå’±å·²ç»çŸ¥é“ç»™æœåŠ¡å™¨é…ç½®ä¸¤ä¸ªIPäº†ï¼ˆçŽ°åœ¨åº”è¯¥ä¹ŸçŸ¥é“ä¸ºå•¥è¦æžè¿™ç§åŒçº¿æœºå™¨äº†å§ï¼Œæ‰‹åŠ¨ç¬‘å“­ï¼‰ï¼Œé‚£åŠ è·¯ç”±æ€Žä¹ˆåŠ å‘¢ï¼Ÿå¯¹äºŽä¸€ä¸ªIPåœ°å€è€Œè¨€ï¼Œå¦‚æžœè¦å’Œå…¶ä»–å­ç½‘é€šä¿¡ï¼Œå¿…é¡»å­˜åœ¨ç½‘å…³ï¼Œåˆ©ç”¨ç½‘å…³æ¥æŽ¥æ”¶ã€å‘é€æ•°æ®åŒ…ï¼ŒåŒçº¿æœºå™¨ä¸¤ä¸ªIPï¼Œè‚¯å®šä¹Ÿæœ‰ä¸¤ä¸ªç½‘å…³å•Šï¼ŒæœåŠ¡å™¨èƒ½åŒæ—¶é…ç½®ä¸¤ä¸ªç½‘å…³ï¼Ÿç­”æ¡ˆæ˜¯ä¸èƒ½ï¼Œé‚£ta niangçš„æ€Žä¹ˆåŠžå‘¢ï¼Ÿç­”æ¡ˆæ˜¯å†™è·¯ç”±å•Šï¼ˆä¸ºäº†å¼•å‡ºä½ æ¥ï¼Œå†™äº†è¿™ä¹ˆå¤šå­—ï¼Œæ‰‹é…¸å•ŠðŸ™ƒï¼‰ã€‚ä»¥é…ç½®äº†è”é€šã€ç”µä¿¡çš„åœ°å€çš„åŒçº¿æœºå™¨ä¸ºä¾‹ï¼Œè®¿é—®è”é€šåœ°å€ä½¿ç”¨è”é€šç½‘å…³ï¼Œè®¿é—®ç”µä¿¡åœ°å€ä½¿ç”¨ç”µä¿¡ç½‘å…³ï¼Œè¿™æ ·å°±å¯ä»¥å•¦ï¼Œå°±å¯ä»¥æ„‰å¿«çš„è®¿é—®æŒ‰æŒ‡å®šçº¿è·¯è®¿é—®æŒ‡å®šçš„è¿è¥å•†çš„IPåœ°å€å•¦ã€‚ å†™åˆ°è¿™é‡Œï¼Œç½‘ç»œå·¥ç¨‹å¸ˆå¯èƒ½ä¼šæœ‰é—®é¢˜äº†ï¼Œè·¯ç”±å™¨ã€äº¤æ¢æœºä¸Šæ€Žä¹ˆåŽ»é…ç½®å¤šä¸ªç½‘å…³ï¼ˆå­ç½‘åˆ’åˆ†ï¼‰ï¼Œå¹¶ä¸”åšåˆ°ä¸åŒçº¿è·¯çš„å‡ºå±€å‘¢ï¼Ÿ å½“ç„¶äº†ï¼Œå¯¹äºŽç½‘ç»œå·¥ç¨‹å¸ˆè€Œè¨€ï¼Œè¿™é‡Œè¿˜éœ€è¦è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼ŒåŒçº¿æœºå™¨æœ‰å‡ ä¸ªç½‘å¡ï¼Œå‡å¦‚æœ‰å¤šä¸ªç½‘å¡ï¼Œé‚£å¾ˆç®€å•ï¼Œä¸åŒçš„ç½‘å¡åšé€šä¸åŒçš„æ•°æ®å°±å¥½å•¦ï¼Œé‚£ä¸€ä¸ªç½‘å¡æ€Žä¹ˆåŠžï¼Ÿ é¦–å…ˆï¼Œå…ˆæ¥è§£å†³å¤šä¸ªç½‘å…³çš„é—®é¢˜ï¼ŒæœåŠ¡å™¨å¦‚ä½•åŽ»é…ç½®ï¼Œè¿ç»´å·¥ç¨‹å¸ˆè‡ªæœ‰å¦™è®¡ï¼Œå’±ä¸åŽ»ç®¡å®ƒï¼›è·¯ç”±å™¨ã€äº¤æ¢æœºå¦‚ä½•é…ç½®å‘¢ï¼Ÿä»¥åŽä¸ºè®¾å¤‡ä¸ºä¾‹ï¼Œé…ç½®è¿‡ç¨‹å¤§æ¦‚å¦‚ä¸‹ï¼š1234[R1]vlan 10[R1-vlan10]interface vlanif 10[R1-Vlanif10]ip address 10.0.254.1 24[R1-Vlanif10]ip address 10.0.253.1 24 sub å®Œäº‹åŽæ˜¯è¿™æ ·ï¼š12345#interface Vlanif10 ip address 10.0.254.1 255.255.255.0 ip address 10.0.253.1 255.255.255.0 sub# è¿™æ ·å°±æŠŠä¸¤ä¸ªä¸åŒç½‘æ®µçš„æ•°æ®åšåˆ°ä¸€ä¸ªvlanä¸‹äº†ã€‚ å’±ä»¬åœ¨çœ‹å‡ºå±€çš„é—®é¢˜ï¼Œå‡ºå±€éœ€è¦å€ŸåŠ©ä¸€ä¸ªå«PBR, Policy Based Routingçš„çŽ©æ„ï¼Œå˜¿å˜¿ï¼ŒåŽ‚å•†çœŸä¼šçŽ©ï¼Œæ˜¯è·Ÿè¿è¥å•†å·å·å•†é‡å¥½äº†æ˜¯å§ã€‚å…·ä½“å¦‚ä½•åŽ»åšï¼Œè¦è§†å…·ä½“çš„ç½‘ç»œæž¶æž„å’ŒçŽ¯å¢ƒåŽ»åšï¼ˆè‡ªå·±åŽ»ç™¾åº¦ðŸ˜ï¼‰ã€‚ å¥½ï¼ŒåŒçº¿ä¸šåŠ¡å¤§è‡´å°±æ˜¯è¿™æ ·äº†ï¼Œå¯¹åº”çš„ä¸‰çº¿ä¸šåŠ¡ï¼Œå°±ä¸ç”¨æˆ‘è¯´äº†å§ï¼Œå˜¿å˜¿ï¼Œä¸è¿‡ç½‘ç»œæä¾›å•†å¯èƒ½ä¼šç”¨â€œBGPâ€åœ°å€æ¥ä»£æ›¿å¤šçº¿ä¸šåŠ¡é…ç½®çš„å¤šä¸ªIPåœ°å€æ¥é¿å…IPåœ°å€çš„æµªè´¹ï¼ˆä½†æ®è¯´â€œBGPâ€åœ°å€è´µå•Šï¼Œä¸è¿‡ï¼Œè¿™æ˜¯å•†åŠ¡çš„äº‹æƒ…ï¼Œå•†åŠ¡è‡ªæœ‰å•†åŠ¡çš„ä¸€å¥—ï¼‰ã€‚ å›žè¿‡å¤´æ¥çœ‹ä¸€ä¸‹ï¼ŒåŒçº¿ã€ä¸‰çº¿ä¸šåŠ¡éœ€è¦åšçš„é…ç½®è¿˜æ˜¯æ¯”è¾ƒå¤šçš„ï¼Œä¸ç®¡æ˜¯æœåŠ¡å™¨è¿˜æ˜¯è·¯ç”±å™¨ï¼Œä¸ä¹Ÿæ˜¯ç´¯çš„ä¸€é€¼å—ï¼Ÿæœ‰æ²¡æœ‰ä»€ä¹ˆèƒ½ä¸€æ¬¡æ€§æžå®šï¼Œè€Œä¸”ä¸‰ç½‘å†…éƒ½è·Ÿè·‘â€œå†…ç½‘â€ä¸€æ ·å‘¢ï¼Ÿè¯¶ï¼Œè¿è¥å•†åˆå‡ºé©¬äº†ï¼šè§‰å¾—éº»çƒ¦æ˜¯ä¸æ˜¯ï¼Œå¥½ï¼Œæˆ‘ç»™ä½ ä»¬å‡è´Ÿï¼ˆçœŸæ˜¯è¿™æ ·ä¹ˆï¼Ÿè¿è¥å•†ä¼šè¿™ä¹ˆå¥½å¿ƒï¼Ÿï¼‰ï¼Œæˆ‘ä»¬çŽ°åœ¨èƒ½æä¾›ä¸€ç§â€œBGPâ€çš„äº§å“ï¼Œè¿™ç±»åœ°å€å…·æœ‰èƒ½ä»Žä¸‰ç½‘çº¿è·¯ç‹¬ç«‹è®¿é—®çš„ç‰¹æ€§ã€‚ä»€ä¹ˆæ„æ€å‘¢ï¼Ÿä¹Ÿå°±æ˜¯è¯´å„ä¸ªè¿è¥å•†çš„ç”¨æˆ·è®¿é—®è¿™äº›â€œBGPâ€åœ°å€çš„æ—¶å€™èƒ½ç”¨è‡ªèº«è¿è¥å•†çš„çº¿è·¯åŽ»è®¿é—®ï¼Œè€Œä¸éœ€è¦è·¨è¿è¥å•†ã€‚æ‰€è¾¾åˆ°çš„æ•ˆæžœå…¶å®žæ˜¯å’Œä¸‰çº¿ä¸šåŠ¡ä¸€æ ·çš„ï¼Œåªä¸è¿‡ä¼šæ–¹ä¾¿å¾ˆå¤šï¼ˆå¯¹å®¢æˆ·è€Œè¨€ï¼ŒIPé…ç½®ä¸€ä¸ªï¼ŒæœåŠ¡å™¨ä¹Ÿä¸ç”¨å†™è·¯ç”±ï¼Œå—¨å•Šï¼‰ï¼Œä½†æ˜¯ä¸€æ ·éœ€è¦å‰æœŸæŠŠè·¯ç”±å™¨ä¸Šçš„é…ç½®éƒ½åšå¥½å•Šå•Šå•Šï¼Œè¿˜æ˜¯å¥½éº»çƒ¦å•Šã€‚ åŽæ¥ï¼Œäººä»¬ç»™è¿™ç§â€œBGPâ€åœ°å€ä¸€ä¸ªæ´‹æ°”çš„åå­—ï¼Œå°±å«åšStatic BGPðŸ¤£ã€‚ å¥½ï¼Œæ•…äº‹åˆ°æ­¤ç»“æŸðŸ¤£ã€‚ Static BGP Routingä¸‹é¢å°±è¿›å…¥æ­£é¢˜å•¦ã€‚å…·ä½“æž¶æž„å°±æŒ‰ç…§ä¸‹é¢è¿™ä¸ªå›¾å§~ åˆå¼„äº†ä¸€å¼ å›¾ï¼Œä¸¤å¼ å›¾ç»“åˆä¸€èµ·çœ‹ï¼Œå¯¹æ¯”æ¥çœ‹ï¼Œå®¹æ˜“ä¸€äº›ï¼ˆæ®è¯´æ˜¯TXçš„ç½‘ç»œéƒ¨é—¨å¤§ç‰›ç”»çš„ï¼‰ã€‚ Basic Connectionåº•å±‚äº’è”ï¼Œä½¿ç”¨é™æ€äº’è”å³å¯ï¼Œä½†è¿™éœ€è¦åº•å±‚çš„ä¼ è¾“ç½‘ç»œè¶³å¤Ÿå¥å£®ã€ç¨³å®šã€‚ä¿è¯äºŒå±‚ä¼ è¾“ç½‘ç»œå¥å£®æ€§æŠ€æœ¯ä¸»è¦æœ‰VCSã€ERPSç­‰ï¼Œè¿™äº›éƒ½å±žäºŽäºŒå±‚æ— çŽ¯è·¯ä¿æŠ¤åè®®ï¼Œå…·ä½“å¦‚ä½•é…ç½®ï¼Œåœ¨è‡ªè¡Œç ”ç©¶ã€‚çŽ°åœ¨å°±ä»¥äºŒå±‚å·²ç»é…ç½®å¥½äº†ä¿æŠ¤åè®®ä¸ºä¾‹ï¼Œç»™å‡ºä¸¤å°è·¯ç”±å™¨çš„é™æ€äº’è”IPä¿¡æ¯æ¥ååŠ©é…ç½®BGPã€‚ R1-CM-Access1234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# R2-BGP-Router1234!interface ve 925 ip address 10.0.254.1/30! å•å‘æµ‹è¯•ä¸€ä¸‹ï¼šBGP-Router1ping 10.0.254.1 source 10.254.0.2 BGP Configä¸‹é¢ä»‹ç»BGPçš„ç›¸å…³é…ç½®ï¼Œä»¥ä¸Žä¸€ä¸ªè¿è¥å•†æŽ¥å…¥çš„æƒ…å†µä¸ºä¾‹ï¼Œå…¶ä¸­CM-Accessä¸ºåŽä¸ºè®¾å¤‡ï¼ŒBGP-Routerä¸ºåšç§‘è®¾å¤‡ã€‚ä¸Žè¿è¥å•†æŽ¥å…¥çš„è®¾å¤‡é…ç½®æ¯”è¾ƒç®€å•ï¼Œå’±åªç”¨åšå¥½BGPè¿žæŽ¥å°±å¥½äº†ã€‚R1-CM-Access12345678910111213&lt;R1&gt;system-view[R1]bgp 9527 //å»ºç«‹BGPè¿›ç¨‹ï¼Œè®¾ç½®ASå·ä¸º9527[R1-bgp]router-id x.x.x.x //è®¾ç½®router-idï¼Œä¸€èˆ¬ä¸ºçŽ¯å›žæŽ¥å£åœ°å€[R1-bgp]peer 10.0.254.1 as-number 35129 //è®¾ç½®BGPå¯¹ç­‰ä½“[R1-bgp]peer 10.0.254.1 description BGP-Router //æ·»åŠ è¯¥å¯¹ç­‰ä½“çš„æè¿°ä¿¡æ¯[R1-bgp]peer 10.0.254.1 enable //å»ºç«‹å’ŒBGPå¯¹ç­‰ä½“çš„TCPè¿žæŽ¥[R1-bgp-af-ipv4]import-route static //å¯¼å…¥é™æ€è·¯ç”±[R1-bgp-af-ipv4]quit[R1-bgp]quit[R1]ip route-static ..... //å†™å…¥ç§»åŠ¨è¿è¥å•†è·¯ç”±[R1]ip route-static ...[R1]quit&lt;R1&gt;save //ä¿å­˜é…ç½® BGPæ ¸å¿ƒè·¯ç”±å™¨R2çš„é…ç½®ç›¸æ¯”R1è¦å¤šå¾ˆå¤šäº†ï¼Œå¹¶ä¸”æ˜¯åœ¨æœ‰æ„è¯†çš„è¿›è¡Œé…ç½®ã€‚R2-BGP-Router1234567891011121314151617181920212223242526272829R2#configure terminalR2(config)#router bgpR2(config-bgp)#local-as 35129 //è®¾ç½®æœ¬åœ°ASå·R2(config-bgp)#neighbor 10.0.254.2 remote-as 9527 //è®¾ç½®BGPå¯¹ç­‰ä½“R2(config-bgp)#neighbor 10.0.254.2 soft-reconfiguration inbound //å¼€å¯å¯¹ç­‰ä½“æµå…¥è·¯ç”±è½¯åˆ·æ–°R2(config-bgp)#neighbor 10.0.254.2 description CM-Access //æ·»åŠ è¯¥å¯¹ç­‰ä½“çš„æè¿°ä¿¡æ¯R2(config-bgp)#show ip bgp summary //æ£€æŸ¥BGPå¯¹ç­‰ä½“ä¹‹é—´çš„çŠ¶æ€æ˜¯å¦ä¸ºEstablishedR2(config-bgp)#neighbor 10.0.254.2 shutdown //æ£€æŸ¥æ­£å¸¸åˆ™å…ˆå…³é—­TCPè¿žæŽ¥R2(config-bgp)#exitR2(config)#ip prefix-list Private_Deny seq 5 deny 0.0.0.0/8 le 32 //åˆ›å»ºå‰ç¼€åˆ—è¡¨R2(config)#ip prefix-list Private_Deny seq 10 deny 10.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 15 deny 172.16.0.0/12 le 32 R2(config)#ip prefix-list Private_Deny seq 20 deny 192.168.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 25 deny 127.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 30 deny 169.254.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 35 deny 192.0.2.0/24 le 32 R2(config)#ip prefix-list Private_Deny seq 40 deny 224.0.0.0/3 le 32 R2(config)#ip prefix-list Private_Deny seq 45 deny 172.160.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 50 permit 0.0.0.0/0 le 32R2(config)#router bgpR2(config-bgp)#neighbor 10.0.254.2 prefix-list Private_Deny in //æ‹’ç»ç§ç½‘åœ°å€ç­‰æµå…¥R2(config-bgp)#redistribute connected //é‡åˆ†å¸ƒå‘ç›´è¿žè·¯ç”±R2(config-bgp)#redistribute static //é‡åˆ†å¸ƒå‘é™æ€è·¯ç”±R2(config-bgp)#default-information-origina //é‡åˆ†å¸ƒå‘é»˜è®¤è·¯ç”±R2(config-bgp)#no neighbor 10.0.254.2 shutdown //æ‰“å¼€BGPå¯¹ç­‰ä½“ä¹‹é—´çš„TCPè¿žæŽ¥R2(config-bgp)#show ip bgp routes //æŸ¥çœ‹ä»ŽBGPå¯¹ç­‰ä½“èŽ·å–åˆ°çš„è·¯ç”±ä¿¡æ¯R2(config-bgp)#exitR2(config)#exitR2#write-memory //ä¿å­˜é…ç½® CM-Accesså’ŒBGP-Routerä¹‹é—´çš„EBGPå»ºç«‹å¥½åŽï¼Œç›¸äº’ä¹‹é—´ä¼šè‡ªåŠ¨å­¦ä¹ è·¯ç”±ï¼Œå…¶ä»–è¿è¥å•†å¯¹æŽ¥çš„æƒ…å†µä¹Ÿå¯ä»¥è¿™æ ·æ¥åšã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯åšå¥½ä¹‹åŽï¼Œæ˜¯å¦å°±å®Œäº‹äº†å‘¢ï¼Ÿè¿™ä¸ªå¾—ä»Žéœ€æ±‚ä¸Šçœ‹ï¼Œå…¶å®žä¸»è¦åˆ†ä¸¤ç§æƒ…å†µï¼š BGP-Routerå’ŒISP-AccessåŒ…å«å•çº¿ã€å¤šçº¿åŠBGPåŠŸèƒ½ BGP-Routerå’ŒISP-Accessåªç”¨ä½œBGPçº¿è·¯ ä¸€èˆ¬è€Œè¨€ï¼Œå¯¹äºŽç¬¬äºŒç§æƒ…å†µï¼Œä¸Šè¿°çš„åšæ³•å·²ç»å®Œäº‹äº†ï¼Œä½†å¯¹äºŽä¸€å®¶ä¼ä¸šè€Œè¨€ï¼Œè®¾å¤‡çš„å¯åˆ©ç”¨æ€§å¯èƒ½æ˜¯è¶Šé«˜è¶Šå¥½çš„ï¼Œè¿™æ ·å¯¹åº”çš„æˆæœ¬å°±è¶Šä½Žï¼ˆé¢†å¯¼ï¼šèŠ‚çº¦æˆæœ¬å•Šï¼Œæˆ‘å¯éƒ½æ˜¯è¡€æ±—é’±ï¼Œ23333ï¼‰ã€‚æ‰€ä»¥ï¼Œå¦‚ä½•åŽ»å°†å•çº¿ã€å¤šçº¿åŠBGPåŠŸèƒ½å…¨éƒ¨æ‰¿è½½åœ¨è¿™ä¸ªæž¶æž„ä¸­å‘¢ï¼Ÿç­”æ¡ˆæ˜¯ä½¿ç”¨VRFï¼Œåˆ©ç”¨VRFæ¥å»ºç«‹BGPçº¿è·¯çš„EBGPè¿žæŽ¥ï¼Œè¿™æ ·å¯¹äºŽBGPä¸šåŠ¡å°±å¯ä»¥åœ¨å•ä¸ªVRFå†…å®žçŽ°äº†ï¼Œè€Œå…¶ä»–çš„ä¸šåŠ¡ä¹Ÿåœ¨ä¸åŒçš„VRFå†…å®žçŽ°å³å¯ã€‚å¦å¤–ï¼Œè€Œå¯¹äºŽå„ä¸ªISP-Accessè®¾å¤‡ï¼ŒCT-Accesså‘EBGPå†…é‡åˆ†å¸ƒé»˜è®¤è·¯ç”±ï¼Œå…¶ä»–ISP-Accesså‘EBGPé‡åˆ†å¸ƒæ˜Žç»†é™æ€è·¯ç”±ï¼ŒCT-Accesséœ€è¦æ‹’ç»ï¼ˆä½¿ç”¨ip-prefix listå®Œæˆå³å¯ï¼‰ä»ŽBGP-Routerå­¦ä¹ åˆ°çš„CMæ˜Žç»†è·¯ç”±å’ŒCUæ˜Žç»†è·¯ç”±ç­‰ï¼Œå¦åˆ™å°±ä¼šå½±å“å•çº¿åŠå¤šçº¿ä¸šåŠ¡çš„é»˜è®¤å‡ºå±€ã€‚åŒæ—¶ï¼Œä¸ºäº†ä¿è¯å•ã€å¤šçº¿ä¸šåŠ¡ï¼Œå…¶ä»–ISP-Accessä¹Ÿéƒ½éœ€è¦å†™å…¥é»˜è®¤è·¯ç”±ï¼Œä½†ä¸èƒ½é‡åˆ†å¸ƒåˆ°EBGPå†…ï¼Œé¿å…é€ æˆçŽ¯è·¯å’Œè·¯ç”±é”™ä¹±ã€‚ SummaryæŒ‰ç…§è¿™æ ·çš„æž¶æž„å®žçŽ°çš„Static BGPç»“æž„æ¯”è¾ƒç®€å•ï¼Œä¸éœ€è¦Traffic-Policyç­‰ä¹‹ç±»çš„æŠ€æœ¯æ¥é…åˆå®žçŽ°ï¼ŒæŽ§åˆ¶èµ·æ¥ä¹Ÿæ¯”è¾ƒç®€å•ï¼Œç›´æŽ¥æ”¾é™æ€è·¯ç”±å°±å¥½ï¼Œè‡³äºŽä»ŽBGP-Routeråˆ°BGP-Accessä¹‹é—´çš„ç¨³å®šæ€§ï¼Œè¿™ä¸ªä¹Ÿå¯ä»¥ç”¨Static with BFDçš„æ–¹å¼æ¥å®žçŽ°ï¼Œæˆ–è€…çº¯ä¾é åº•å±‚ä¼ è¾“ç½‘çš„å¥å£®æ€§ã€‚ä¸è¿‡æœ‰ä¸ªé—®é¢˜åœ¨äºŽï¼Œè¿™æ ·åšå¥½ä¹‹åŽï¼ŒBGP-Routerå°±åªèƒ½ç”¨ä½œBGPåœ°å€çš„å‡ºå£ç½‘å…³è·¯ç”±å™¨äº†ï¼Œå½“ç„¶æ ¹æ®è®¾å¤‡çš„åŠŸèƒ½ç‰¹æ€§ï¼Œå¼ºè¡Œè¦ä½¿ç”¨æŸæŸåŠŸèƒ½ï¼Œä¾ç„¶å¯ä»¥ç”¨VRFç­‰å®žçŽ°ï¼Œä½†è¿™æ ·å°±ä¼šä½¿å¾—è®¾å¤‡çš„åŠŸèƒ½å˜å¾—ç¹æ‚ï¼Œåœ¨æ“ä½œçš„æ—¶ï¼Œè¯¯æ“ä½œæˆ–å…¶ä»–BUGå°±ä¼šå½±å“åˆ°æ•´ä¸ªBGPç½‘ç»œæž¶æž„çš„ç¨³å®šæ€§ã€‚å¦å¤–ï¼Œè¿™ä¸ªæž¶æž„çš„ä¼˜ç‚¹å…¶å®žå¾ˆç›´è§‚ï¼Œå°±æ˜¯ç®€å•ï¼Œæ˜“äºŽæŽ’éšœï¼ˆç½‘ç»œæž¶æž„åœ¨ä¸å¤±å¥å£®æ€§çš„åŸºç¡€ä¸‹ï¼Œè¶Šç®€å•è¶Šå¥½ï¼ŒçœŸç†å•ŠðŸ˜­ï¼‰ï¼Œå¹¶ä¸”ä¸åŒè¿è¥å•†çš„è·¯ç”±è¡¨æ˜“äºŽç»´æŠ¤ã€‚ç¼ºç‚¹å°±æ˜¯ï¼Œå¯¹åº•å±‚ä¼ è¾“ç½‘çš„ç¨³å®šæ€§è¦æ±‚æ¯”è¾ƒé«˜ã€‚ä½†æ˜¯ï¼Œå¦‚æžœæ˜¯è·¨åŒºåŸŸçš„BGPä¸šåŠ¡çš„è¯ï¼Œåˆä¼šé¢ä¸´æ–°çš„é—®é¢˜ï¼šéš¾é“æ¯ä¸ªåœ°æ–¹éƒ½æžä¸€å°BGPæ ¸å¿ƒè·¯ç”±å™¨å—ï¼Ÿé‚£åœ¨å†…ç½‘é‡Œï¼Œè¿™äº›åœ°å€åˆå¦‚ä½•äº’ç›¸è®¿é—®å‘¢ï¼Ÿ]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFDåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F29%2FBFD%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroBFDå¸¸ç”¨äºŽå¤šçº¿é™æ€è·¯ç”±çš„æ£€æµ‹å’Œè‡ªåŠ¨åˆ‡æ¢ï¼Œåœ¨æ²¡æœ‰ä½¿ç”¨å…¶ä»–åŠ¨æ€åè®®çš„æƒ…å†µä¸‹ï¼Œè‹¥ç½‘ç»œå‡ºçŽ°æ•…éšœï¼Œå¯ä»¥ä½¿ç”¨BFDè¾¾åˆ°æ•…éšœçº¿è·¯å’Œæ­£å¸¸çº¿è·¯çš„è·¯ç”±åˆ‡æ¢æ•ˆæžœã€‚å½“ç„¶ï¼ŒBFDä¾ç„¶å¯ä»¥å’Œå…¶ä»–åè®®é…åˆä½¿ç”¨ï¼ˆMPLSä¹Ÿå¯ä»¥ï¼‰ï¼Œè¿™é‡Œåªä»‹ç»BFDå’Œé™æ€è·¯ç”±çš„é…åˆä½¿ç”¨ï¼Œåœ¨ä¸åŒçš„åº”ç”¨åœºæ™¯å†…æŠŠæ¡å¥½BFDæœ¬èº«çš„ä½œç”¨æœºåˆ¶ï¼Œä»Žè€Œè¾¾åˆ°ä½¿ç”¨è€…æƒ³è¦è¾¾åˆ°çš„æ•ˆæžœå³å¯ã€‚å¦å¤–ï¼Œä¸€èˆ¬çš„åŠ¨æ€åè®®æ”¶æ•›é€Ÿåº¦æ¯”è¾ƒæ…¢ï¼Œä¸ºç§’çº§ï¼ŒBFDå¯ä»¥å°†æ”¶æ•›æ—¶é—´é™ä½Žåˆ°æ¯«ç§’çº§ã€‚ BFD Brief Descriptionä¸€èˆ¬è€Œè¨€ï¼ŒBFDéœ€è¦è®¾ç½®çš„å‚æ•°ä¸å¤šï¼Œå¤§è‡´åŒ…å«ï¼šsource ipã€destination ipã€multiplierã€min_rxã€intervalï¼Œå„ä¸ªå‚æ•°åªè¦è®¾ç½®å¥½äº†ï¼Œè®¾å¤‡ä¹‹é—´çš„BFDè¿žæŽ¥éƒ½é…ç½®OKï¼Œé‚£ä¹ˆBFDè¿žæŽ¥å°±å¯ä»¥UPäº†ã€‚ä¸åŒè®¾å¤‡å¯èƒ½å¯¹è¿™äº›åè¯çš„å«æ³•ä¸ä¸€è‡´ï¼Œä½†æ˜¯å·®ä¸å¤šéƒ½æ˜¯è¿™äº›â€œè¯â€ã€‚ Source IPBFDçš„æºIPï¼Œæœ¬ç«¯è®¾å¤‡è®¾ç½®æœ¬ç«¯IPå³å¯ã€‚ Destination IPBFDçš„ç›®çš„IPï¼Œæœ¬ç«¯è®¾å¤‡è®¾ç½®å¯¹ç«¯IPå³å¯ã€‚ Multiplierå…è®¸BFDè¿žæŽ¥æŠ¥æ–‡å¤±æ•ˆçš„æœ€å¤§ä¸ªæ•°ï¼Œä¾‹å¦‚è®¾ç½®ä¸º5ï¼Œé‚£ä¹ˆç”¨äºŽè¿™ä¸ªBFDè¿žæŽ¥çš„Control packetä¸€æ—¦å¤±æ•ˆè¶…è¿‡5ä¸ªï¼Œè¿™æ¡BFDè·¯å¾„è¿žæŽ¥å°±ä¼šdownï¼Œç±»ä¼¼pingæµ‹è¯•ä¸¢åŒ…è¶…è¿‡5ä¸ªã€‚ Min_rxBFDæ£€æµ‹æŠ¥æ–‡çš„æŽ¥æ”¶å‘¨æœŸã€‚ intervalBFDæ£€æµ‹æŠ¥æ–‡çš„å‘é€å‘¨æœŸã€‚ TipsBFDæ£€æµ‹çš„æ—¶é—´å‘¨æœŸè®¾ç½®ï¼Œæ˜¯ä¸€ä¸ªå¾ˆæœ‰æ„æ€çš„ä¸œè¥¿ã€‚å‡è®¾æ€»ä½“æ€§èƒ½çš„æŒ‡æ ‡æ˜¯è¦æ±‚é“¾è·¯æ£€æµ‹ä¸Šçš„æ—¶é—´ä¸è¦è¶…è¿‡150msï¼Œè¿™æ ·å¯ä»¥è®¾ç½®BFDçš„helloæŠ¥æ–‡å‘¨æœŸä¸º50msï¼Œè¿žç»­ä¸¢å¤±3ä¸ªæŠ¥æ–‡å³è®¤ä¸ºé“¾è·¯å¤±æ•ˆã€‚å¦‚æžœæ¢ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬è®¾ç½®BFDçš„helloæŠ¥æ–‡å‘¨æœŸä¸º30msï¼Œè¿žç»­ä¸¢å¤±5ä¸ªæŠ¥æ–‡å³è®¤ä¸ºé“¾è·¯å¤±æ•ˆï¼Œè¿™æ ·å‡†ç¡®åº¦ä¼šæ›´é«˜äº›ä¸”ä¾ç„¶å¯ä»¥è¾¾åˆ°æŒ‡æ ‡ã€‚ä½†æ˜¯éœ€è¦è·¯ç”±å™¨æ”¯æŒè®¾ç½®30msè¿™ä¸ªæ—¶é—´ã€‚ BFD Connectiongä¸‹é¢å¼€å§‹é…ç½®ã€‚æ³¨ï¼šR1ä¸ºåšç§‘è®¾å¤‡ï¼ŒR2ä¸ºåŽä¸ºè®¾å¤‡ Basic Connectionåº•å±‚äº’è”é‡‡ç”¨é™æ€çš„æ–¹å¼ï¼Œç›´æŽ¥ç»™å‡ºR1å’ŒR2äº’è”çš„ä¸‰å±‚æŽ¥å£é…ç½®ã€‚R11234!interface ve 925 ip address 10.0.254.1/30! R21234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# BFD ConfigæŽ¥ä¸‹æ¥å¼€å§‹é…ç½®BFDã€‚R1123456R1#configure terminalR1(config)#interface ve 925R1(config-vif-ve-925)#bfd interval 500 min-rx 500 multiplier 5 //è®¾ç½®å‚æ•°R1(config-vif-ve-925)#exitR1(config)#ip route static-bfd 10.0.254.2 10.0.254.1 //å¼€å¯bfdR1(config)#ip route 192.168.1.0/24 10.0.254.2 bfd //ä¸ºé™æ€è·¯ç”±ç»‘å®šbfd R21234567&lt;R2&gt;system-view[R2]bfd to-r1 bind peer-ip 10.0.254.1 interface vlanif925 source-ip 10.0.254.1 auto //è®¾ç½®bfd[R2-bfd-session-to-r1]detect-multiplier 5 //è®¾ç½®å‚æ•°[R2-bfd-session-to-r1]min-tx-interval 500[R2-bfd-session-to-r1]min-rx-interval 500[R2-bfd-session-to-r1]quit[R2]ip route-static 192.168.2.0 24 10.0.254.1 track bfd-session to-r1 //ä¸ºé™æ€è·¯ç”±ç»‘å®šbfd é…ç½®å¥½äº†ä¹‹åŽï¼ŒBFDå°±æ­£å¼å¯åŠ¨äº†ï¼Œå¹¶ä¸”æ­¤æ—¶R1è®¿é—®192.168.1.0/24ç½‘æ®µçš„è·¯ç”±æ˜¯ä¸ŽR1å’ŒR2ä¹‹é—´çš„BFDç»‘å®šåœ¨ä¸€èµ·çš„ï¼ŒR2è®¿é—®192.168.2.0/24ç½‘æ®µçš„è·¯ç”±ä¹Ÿæ˜¯ä¸ŽR1å’ŒR2ä¹‹é—´çš„BFDç»‘å®šåœ¨ä¸€èµ·çš„ã€‚ ManagementR1å¯ä»¥ä½¿ç”¨show bfd neighborså‘½ä»¤æ¥æ£€æŸ¥BFDè¿žæŽ¥æ˜¯å¦æ­£å¸¸ï¼›R2å¯ä»¥ä½¿ç”¨display bfd session allæ¥æ£€æŸ¥BFDè¿žæŽ¥æ˜¯å¦æ­£å¸¸ï¼›å½“ç„¶äº†ï¼Œä¸åŒè®¾å¤‡è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„ç®€æ·å‘½ä»¤æ¥æ–¹ä¾¿ç®¡ç†ã€‚é…åˆä½¿ç”¨éœ€è¦æŸ¥è®¾å¤‡çš„æ‰‹å†Œï¼Œä½†æ˜¯éœ€è¦è®¾ç½®çš„å‚æ•°æ˜¯ä¸€æ ·çš„ï¼Œè¿™å°±å¾ˆNICEäº†ã€‚æ‰€ä»¥ï¼Œä¸ç®¡åŠ¨æ€åè®®æ˜¯å•¥ï¼Œä½¿ç”¨BFDå®žçŽ°çš„åŠŸèƒ½æ˜¯ä¸Žå…¶ä»–ä¸ç›¸å…³çš„ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPLSåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F27%2FMPLS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroMPLSï¼ŒMulti-Protocol Label Switchingï¼Œå…¨ç§°å¤šåè®®æ ‡è®°äº¤æ¢ï¼Œæ˜¯ä¸€ç§æ ‡è®°æœºåˆ¶çš„åŒ…äº¤æ¢æŠ€æœ¯ï¼Œé€šè¿‡ç®€å•çš„2å±‚äº¤æ¢æ¥é›†æˆIP Routingçš„æŽ§åˆ¶ã€‚MPLSç©¶ç«Ÿæ˜¯ä¸æ˜¯è·¯ç”±åè®®ï¼Œç©¶ç«Ÿå·¥ä½œåœ¨ç¬¬å‡ å±‚ï¼Œåœ¨è¿™é‡Œï¼Œä¸åšæŽ¢è®¨ï¼Œä»¥ä¸‹å†…å®¹åªä»‹ç»å…¶åŸºç¡€çš„é…ç½®ï¼Œå¹¶è¡”æŽ¥ISISåŸºç¡€é…ç½®è¿™ç¯‡æ–‡ç« ã€‚ ä»¥ä¸‹é…ç½®å‘½è¿˜æ˜¯ä»¥åšç§‘è®¾å¤‡ä¸ºä¾‹ Network Informationè´´å‡ºR1å’ŒR2çš„éƒ¨åˆ†é…ç½®ä¿¡æ¯ååŠ©æž„å»ºISIS + MPLSã€‚R1123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.10/30!interface ve 922 ip router isis ip address 10.0.254.14/30!!interface loopback 1 ip router isis ip address 169.254.254.1/32!ip router-id 169.254.254.1!router isis net 49.0001.0000.0000.1000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! R2123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.9/30!interface ve 922 ip router isis ip address 10.0.254.13/30!!interface loopback 1 ip router isis ip address 169.254.254.2/32!ip router-id 169.254.254.2!router isis net 49.0002.0000.0000.2000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! MPLS Brief Descriptionç®€è¦è¯´æ˜Žä¸€ä¸‹MPLSä¸­çš„æŸäº›ç»„æˆéƒ¨åˆ†ï¼Œå…¶ä½™çš„éƒ¨åˆ†ä¸åœ¨èµ˜è¿°äº†ðŸ˜´ã€‚ Network Componentså°±åƒBGPå¯¹ç­‰ä½“ä¸€æ ·ï¼ŒMPLSå†…ä¹ŸåŒ…å«ä¸€äº›æ¦‚å¿µï¼Œä¾æ¬¡å¦‚ä¸‹ï¼š Pç½‘ç»œï¼šæä¾›å•†ç½‘ç»œPè·¯ç”±å™¨ï¼šéƒ¨ç½²MPLS/IPç½‘ç»œçŽ¯å¢ƒçš„è·¯ç”±å™¨PEè·¯ç”±å™¨ï¼šæä¾›å•†ç½‘ç»œçš„è¾¹ç•Œè·¯ç”±å™¨ï¼Œæä¾›VPNç»ˆç«¯å®¢æˆ·è¿žæŽ¥å’ŒæœåŠ¡CEè·¯ç”±å™¨ï¼šå®¢æˆ·çš„è·¯ç”±å™¨ï¼Œç”¨åšå®¢æˆ·ç½‘ç»œå’Œæä¾›å•†ç½‘ç»œä¹‹é—´çš„ç½‘å…³Cç½‘ç»œï¼šå®¢æˆ·çš„ç½‘ç»œ MPLS-Interfaceç”¨äºŽå»ºç«‹pathçš„ä¸‰å±‚æŽ¥å£ï¼Œæ³¨æ„ï¼Œæ˜¯ä¸‰å±‚æŽ¥å£ã€‚ LSPLSP, Label Switched Pathï¼Œæ ‡ç­¾äº¤æ¢è·¯å¾„ï¼Œå³åˆ°è¾¾åŒä¸€ç›®çš„åœ°å€çš„æŠ¥æ–‡åœ¨MPLSç½‘ç»œä¸­ç»è¿‡çš„è·¯å¾„ã€‚è¿™çŽ©æ„ï¼Œå°±æ˜¯æµé‡çš„â€œæ–¹å‘â€äº†ã€‚ LDPLDP, Label Distribution Protocolï¼Œæ ‡ç­¾åˆ†å‘åè®®ï¼Œè¿™çŽ©æ„æ˜¯è·¯ç”±å™¨åœ¨æž„å»ºMPLSæ ‡ç­¾è½¬å‘è¡¨æ—¶éµå®ˆçš„è§„åˆ™ï¼ŒMPLSçš„æ ‡ç­¾è½¬å‘è¡¨çš„å»ºç«‹å°±æ˜¯é è¿™çŽ©æ„ã€‚ VPLSVPLSï¼ŒVirtual Private Lan Serviceï¼Œè¿™çŽ©æ„å…¶å®žå¹¶åªæ˜¯MPLSæ‰€æœ‰çš„ä¸œè¥¿ï¼ŒæŒ‰ç…§ä¸åŒçš„ä¿¡ä»¤åè®®ï¼Œä¹Ÿæœ‰ä¸åŒçš„åº”ç”¨æ–¹æ³•ï¼ˆBGP-l2vpnï¼‰ï¼Œè¿™é‡Œæ‰€ä»‹ç»çš„VPLSæœ¬è´¨ä¸Šæ˜¯åŸºäºŽIP/MPLSçš„L2VPNæŠ€æœ¯ï¼ˆå…¶å®žæ˜¯çŽ°åœ¨ç”¨çš„æœ€å¤šçš„ä¹Ÿå°±æ˜¯MPLSä¸‹çš„VPLSäº†ðŸ˜‚ï¼‰ã€‚ä¸è¿‡ï¼Œè¿™çŽ©æ„è¿˜æœ‰ä¸ªæ›´åŠ é€šä¿—çš„ç†è§£æ–¹å¼ï¼Œé‚£å°±æ˜¯è¿è¥å•†ç»™å®¢æˆ·çš„â€œä¸šåŠ¡ç½‘â€ã€‚ MPLS Configæƒ³è¦MPLSèƒ½æ­£å¸¸ä½¿ç”¨ï¼Œéœ€è¦åšçš„è·¯ç”±å™¨é…ç½®å…¶å®žå¹¶ä¸æ˜¯å¾ˆå¤šï¼Œå¤§ä½“ä¸Šå°±åŒ…æ‹¬ï¼šmpls-interfaceã€pathå’Œlspè¿™äº›ã€‚ä»¥ä¸‹çš„é…ç½®æ­¥éª¤å¯ä½œä¸ºå‚è€ƒï¼šR11234567891011121314151617181920212223242526272829R1#configure terminalR1(config)#router mpls //å¯ç”¨mplsR1(config-mpls)#ldp //è¿›å…¥ldpåè®®R1(config-mpls-ldp)#load-sharing 8 //è®¾ç½®lspçš„èƒ½æ”¯æŒçš„æœ€å¤§è·¯å¾„æ¡æ•°ä¸º8R1(config-mpls-ldp)#exitR1(config-mpls)#path To-R2-1 //åˆ›å»ºpathR1(config-mpls-path-To-R2-1)#strict 10.0.254.9 //æŒ‡å®šè¿™æ¡è·¯å¾„çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹æ˜¯10.0.254.9R1(config-mpls-path-To-R2-1)#exitR1(config-mpls)#path To-R2-2R1(config-mpls-path-To-R2-2)#strict 10.0.254.13R1(config-mpls-path-To-R2-2)#exitR1(config-mpls)#mpls-interface ve921 //å°†ve 921è¿™ä¸ªä¸‰å±‚æŽ¥å£å¯ç”¨åˆ°mplsä¸­R1(config-mpls-if-ve-921)#ldp-enable //å¼€å¯æ­¤æŽ¥å£ldpåŠŸèƒ½R1(config-mpls-if-ve-921)#exitR1(config-mpls)#mpls-interface ve922R1(config-mpls-if-ve-922)#ldp-enableR1(config-mpls-if-ve-922)#exitR1(config-mpls)#lsp To-R2-1 //åˆ›å»ºæ ‡ç­¾è½¬å‘è·¯å¾„R1(config-mpls-lsp-To-R2-1)#to 169.254.254.2 //è®¾ç½®æ ‡ç­¾è½¬å‘è·¯å¾„çš„å‡ºå£è·¯ç”±å™¨åœ°å€R1(config-mpls-lsp-To-R2-1)#primary-path To-R2-1 //è®¾ç½®ä¸»è·¯å¾„R1(config-mpls-lsp-To-R2-1)#secondary-path To-R2-2R1(config-mpls-lsp-To-R2-1)#enableR1(config-mpls-lsp-To-R2-1)#lsp To-R2-2R1(config-mpls-lsp-To-R2-2)#to 169.254.254.2R1(config-mpls-lsp-To-R2-2)#primary-path To-R2-2R1(config-mpls-lsp-To-R2-2)#secondary-path To-R2-1R1(config-mpls-lsp-To-R2-2)#enableR1(config-mpls-lsp-To-R2-2)#exitR1(config-mpls)#write memory R21234567891011121314151617181920R2#configure terminalR2(config)#router mplsR2(config-mpls)#path To-R1-1R2(config-mpls-path-To-R1-1)#strict 10.0.254.10R2(config-mpls-path-To-R1-1)#path To-R1-2R2(config-mpls-path-To-R1-2)#strict 10.0.254.14R2(config-mpls-path-To-R1-2)#exitR2(config-mpls)#lsp To-R1-1R2(config-mpls-lsp-To-R1-1)#to 169.254.254.1R2(config-mpls-lsp-To-R1-1)#primary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#enableR2(config-mpls-lsp-To-R1-1)#lsp To-R1-2R2(config-mpls-lsp-To-R1-2)#to 169.254.254.1R2(config-mpls-lsp-To-R1-2)#primary-path To-R1-2R2(config-mpls-lsp-To-R1-2)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-2)#enableR2(config-mpls-lsp-To-R1-2)#exitR2(config-mpls)#exitR2(config)#write memory ä¸Šé¢è´´å‡ºçš„æ˜¯å®Œæ•´çš„é…ç½®è¿‡ç¨‹ï¼Œä½†æ˜¯å®žé™…ä¸Šä¸¤å°è®¾å¤‡çš„é…ç½®é¡ºåºæ˜¯äººä¸ºè‡ªå®šçš„ï¼Œä¸è¿‡éœ€è¦è¯´æ˜Žçš„æ˜¯ï¼Œä¸€æ—¦åˆ›å»ºäº†pathï¼Œä½¿ç”¨show mpls routeså‘½ä»¤æ—¶ï¼Œå°±å¯ä»¥çœ‹åˆ°mplsçš„æ ‡ç­¾è½¬å‘è¡¨äº†ã€‚å…¶æ¬¡ï¼Œåˆ›å»ºlspæ—¶å¯ä»¥ä¸æŒ‡å®šprimary-pathå’Œsecondary-pathï¼Œæ­¤æ—¶lspä¼šé»˜è®¤ä½¿ç”¨mplså†…å­˜åœ¨ä¸”upçš„pathï¼ˆå·²è¿žæŽ¥çš„è·¯å¾„ï¼‰ï¼Œå¹¶ä¸”lspä¸€æ—¦åˆ›å»ºåŽè®¾å¤‡ä¼šè‡ªåŠ¨ç”Ÿæˆä¸€ä¸ªtunnelç”¨äºŽä¼ è¾“æ•°æ®ï¼Œè¿™ä¸ªå¯ä»¥ä¸ç”¨ç®¡ï¼›ä¹‹æ‰€ä»¥åˆ›å»ºprimary-pathå’Œsecondary-pathï¼Œå®žè´¨ä¸Šæ˜¯ä¸ºäº†æ‰‹åŠ¨è°ƒåº¦æµé‡æ¯”è¾ƒæ–¹ä¾¿ã€‚å¦å¤–ï¼Œåœ¨ä¿®æ”¹lspæ—¶ï¼Œå¿…é¡»è¦å…ˆdisableè¿™æ¡lspï¼ˆå…ˆå…³é—­è¿™æ¡è·¯å¾„ï¼‰æ‰å¯ä»¥è¿›è¡Œä¿®æ”¹ï¼ˆåšç§‘çš„è®¾å¤‡æ˜¯è¿™æ ·ï¼‰ã€‚è¿˜æœ‰ï¼Œä½¿ç”¨router-idæ¥ä½œä¸ºå‡ºå£PEè·¯ç”±å™¨çš„åœ°å€ï¼Œååˆ†æ–¹ä¾¿ã€‚å½“ç„¶äº†ï¼Œä¸åŒåŽ‚å•†è®¾æ‰€æ”¯æŒçš„MPLSæ‰©å±•åŠŸèƒ½å¯èƒ½ä¸ä¸€æ ·çš„ï¼ˆåŽ‚å•†ç‰¹è‰²ï¼Œ23333ï¼‰ï¼Œä½†æ˜¯åŸºæœ¬ä¸Šéƒ½æ˜¯ä¸€æ ·çš„ã€‚ VPLSMPLSç½‘ç»œæž„å»ºå¥½äº†ä¹‹åŽï¼Œåˆ›å»ºVPLSå°±å¾ˆç®€å•å•¦ã€‚å¯ä»¥æŒ‰ç…§ä¸‹é¢çš„è„šæœ¬è¿›è¡Œæ‰§è¡Œã€‚R112345678910R1#configure terminalR1(config)#router mpls //è¿›å…¥mplsåè®®R1(config)#vpls Test911 911 //åˆ›å»ºvplsR1(config-mpls-vpls-Test911)#vpls-peer 169.254.254.2 load-balance //æ·»åŠ vpls peerR1(config-mpls-vpls-Test911)#vlan 911 //åˆ›å»ºvpls vlanR1(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/x //é€ä¼ åˆ°æ±‡èšç«¯å£R1(config-mpls-vpls-Test911-vlan-911)#exitR1(config-mpls-vpls-Test911)#exitR1(config-mpls)#exitR1(config)#write memory //ä¿å­˜é…ç½® R212345678910R2#configure terminalR2(config)#router mplsR2(config)#vpls Test911 911R2(config-mpls-vpls-Test911)#vpls-peer 169.254.254.1R2(config-mpls-vpls-Test911)#vlan 911R2(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/xR2(config-mpls-vpls-Test911-vlan-911)#exitR2(config-mpls-vpls-Test911)#exitR2(config-mpls)#exitR2(config)#write memory åˆ›å»ºå¥½äº†ä¹‹åŽï¼Œå¯ä»¥ä½¿ç”¨show mpls vplsæ¥æŸ¥çœ‹vpls peeræ˜¯å¦upï¼Œå¦‚æžœupï¼Œåˆ™åˆ›å»ºæˆåŠŸï¼Œåä¹‹ï¼Œåˆ™ä¸æˆåŠŸï¼Œéœ€è¦æ£€æŸ¥é…ç½®ã€‚ Summaryæ€»çš„æ¥è¯´ï¼ŒMPLSå’ŒVPLSçš„åˆ›å»ºè¿˜æ˜¯ååˆ†ç®€å•çš„ï¼Œéš¾ç‚¹åœ¨äºŽï¼Œéª¨å¹²ç½‘èŠ‚ç‚¹è¿‡å¤šçš„ç½‘ç»œçŽ¯å¢ƒä¸­ï¼Œå®žçŽ°MPLSçš„æµé‡è°ƒåº¦å·¥ç¨‹ï¼Œåšè¿™ä¸ªäº‹æƒ…ä¸€å®šè¦æ€è·¯æ¸…æ™°æ‰è¡Œã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISISåŸºç¡€é…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F27%2FISIS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroISISä¹Ÿæ˜¯IGPè·¯ç”±åè®®æ—ä¸­ä¸€å‘˜ï¼Œä¸ŽOSPFååˆ†ç±»ä¼¼ï¼ŒOSPFä¸»è¦ç”¨äºŽå›­åŒºç½‘ï¼ŒISISä¸»è¦ç”¨äºŽéª¨å¹²ç½‘ã€‚æ³¨ï¼šæœ¬æ–‡å†…æ‰€æœ‰å‘½ä»¤ï¼Œå‡å·²åšç§‘è®¾å¤‡(ä¸ŽCiscoç±»ä¼¼)ä¸ºä¾‹ã€‚ ISIS Brief Descriptionç®€çŸ­è¯´æ˜Žä¸€ä¸‹ï¼ŒISISä¸­çš„ä¸€äº›éœ€è¦æ³¨æ„çš„åœ°æ–¹ï¼Œå¯èƒ½ä¸æ¸…æ™°å’Œå®Œå…¨ï¼Œæ¬¢è¿Žä¸€èµ·äº¤æµã€‚ ISIS NETæç¤ºï¼šè¿™éƒ¨åˆ†å†…å®¹ä¸è¦æ·±ç©¶ðŸ¤£ï¼Œä¸çŸ¥é“ä¸ºå•¥ä¼šè¿™ä¹ˆå†—æ‚ï¼Œå¯èƒ½æ˜¯å› ä¸ºISISæ˜¯ä¸ºOSIè®¾è®¡çš„ï¼Œè€ŒOSIç”¨çš„æ˜¯NSAPæ ¼å¼çš„åœ°å€å§ï¼ŒXDï¼Œå»ºè®®ç‚¹å¼€é“¾æŽ¥ç»“åˆå›¾ç‰‡ä¸€èµ·çœ‹ã€‚ ISISçš„NET(ç½‘ç»œå®žä½“å)é‡‡ç”¨çš„æ ¼å¼ä¸€ç§å«åšNSAPçš„â€œæ ¼å¼â€(Network Service Access Point)ï¼Œå…¶å½¢å¼æœ‰ç‚¹åƒIPåœ°å€åŠ ç«¯å£å·çš„å½¢å¼ï¼Œå¦‚:169.254.254.1:80ï¼Œä»¥NETä¸º49.0001.0000.0000.0001.00ä¸ºä¾‹ï¼Œ49.0001æ˜¯Area IDï¼Œé•¿åº¦å¯å˜ï¼›0000.0000.0001æ˜¯System IDï¼Œé•¿åº¦ä¸å˜ï¼›00æ˜¯N-SELï¼Œé•¿åº¦ä¸å˜ï¼Œè¿™ä¸ªç±»ä¼¼äºŽTCP/IPä¸­çš„ç«¯å£ã€‚ å¦‚æžœæ¢ä¸€ç§æ ‡è¯†çš„æ–¹æ³•ï¼Œé‚£ä¹ˆ49å°±æ˜¯IDPï¼Œç”¨AFIå’ŒIDIæ¥æ ‡è¯†ï¼›0001å°±æ˜¯Areaï¼ŒSystem IDå’ŒN-SELä¸å˜ï¼Œæ­¤æ—¶ï¼ŒAreaã€System IDå’ŒN-SELåˆç§°ä¸ºDSPã€‚ æ³¨ï¼šå¯¹äºŽåŒä¸€å°è·¯ç”±å™¨è€Œè¨€ï¼Œåœ¨æœ‰å¤šä¸ªISIS Areaè¿žæŽ¥çš„æƒ…å†µä¸‹ï¼ŒArea IDä¸åŒï¼Œä½†æ˜¯System IDå¿…é¡»ç›¸åŒå¯¹äºŽä¸åŒè·¯ç”±å™¨è€Œè¨€ï¼ŒSystem IDä¸€å®šä¸èƒ½ç›¸åŒä¸åŒè·¯ç”±å™¨çš„domainè¦ç›¸åŒï¼Œè¿™æ ·ISISæ‰å¯ä»¥äº’è”å¸¸ç”¨çš„NETè®¾ç½®ä¸ºï¼š49.0001.0000.0000.1000.00ï¼Œè¿™ä¸ªç®—æ˜¯æœ€çŸ­ä¸”ç¬¦åˆè¦æ±‚çš„é•¿åº¦äº† ISIS RoutingISISçš„è·¯ç”±èŽ·å–æ–¹å¼ä¸ŽOSPFæ˜¯ååˆ†ç±»ä¼¼çš„ï¼ŒåŒ…å«IPåœ°å€çš„å‘å¸ƒã€é™æ€è·¯ç”±çš„å¯¼å…¥ã€è·¯ç”±çš„é‡åˆ†é…ç­‰ç­‰ï¼Œä½†ISISçš„è·¯ç”±æ˜¯æ‹¥æœ‰Levelï¼ˆè·¯ç”±ç­‰çº§ï¼‰è¿™ä¸ªå±žæ€§çš„ï¼Œä¸€èˆ¬è€Œè¨€ï¼Œå·¥ä¸šä¸Šä½¿ç”¨çš„è®¾å¤‡éƒ½æ˜¯æ˜¯æ”¯æŒLevel 1/2ï¼ˆè·¯ç”±ç­‰çº§ä¸º1æˆ–2ï¼‰çš„è·¯ç”±ï¼Œä½†è¿™ä¸ªå®žé™…ä¸Šæ˜¯å¯ä»¥è®¾ç½®çš„ï¼ˆè®¾å¤‡å¯ä»¥è®¾ç½®å¯¹ç‰¹å®šç­‰çº§è·¯ç”±ä¸åŠ è¡¨ï¼‰ã€‚å¦å¤–ï¼Œéª¨å¹²ç½‘ä¸Šä½¿ç”¨çš„ISISå…¶å®žåªå‚ä¸Žäº†ä¸åŒæœºæˆ¿çš„æ ¸å¿ƒè·¯ç”±å™¨ä¹‹é—´çš„äº’è”ï¼Œå¹¶æ²¡æœ‰é€šè¿‡ISISè·¨æœºæˆ¿ä¼ é€’æœ¬åœ°çš„IPè·¯ç”±ä¿¡æ¯ï¼Œè€Œè¿™éƒ¨åˆ†åŠŸèƒ½æ˜¯é€šè¿‡MPLSæ¥å®Œæˆçš„ï¼Œå½“ç„¶MPLSçš„æž„å»ºä¹Ÿå¯ä»¥å’Œå…¶ä»–çš„åŠ¨æ€è·¯ç”±åè®®é…åˆå®Œæˆã€‚ä¸åŒç­‰çº§çš„è·¯ç”±ç‰¹æ€§å¦‚ä¸‹ï¼šLevel 1Level 2åªèƒ½å…è®¸åœ¨ä¸€ä¸ªareaå†…è·¯ç”±å…è®¸åœ¨ä¸€ä¸ªdomainå†…è·¯ç”±ï¼Œåªå«Level 1çš„è·¯ç”±å™¨è‹¥è¦åˆ°è¾¾å¦å¤–ä¸€ä¸ªareaï¼Œéœ€è¦è½¬å‘åˆ°ç¦»å®ƒâ€œæœ€è¿‘â€çš„å«Level 2è·¯ç”±çš„è·¯ç”±å™¨ã€‚ä¸‹é¢ä»‹ç»çš„å†…å®¹æ˜¯åˆ©ç”¨ISISæ¥æž„å»ºéª¨å¹²ç½‘çš„å®žè·µåœºæ™¯ã€‚ Basic Connetionä¸ŽOSPFçš„é…ç½®ç±»ä¼¼ï¼ŒISISçš„é…ç½®ä¾ç„¶éœ€è¦å…ˆåœ¨ä¸¤å°è®¾å¤‡ä¸Šé…ç½®å¥½é™æ€äº’è”IPã€‚æœ¬æ¬¡å®žéªŒé‡‡ç”¨vlan 921å’Œvlan 922æ¥ä½œä¸ºä¸¤å°è®¾å¤‡çš„äº’è”vlanï¼Œä½¿ç”¨10.0.254.8/30å’Œ10.0.254.12/30ä½œä¸ºä¸¤å¯¹äº’è”IP(ä¸¤æ¡çº¿è·¯)ã€‚é…ç½®å¥½åŽçš„éƒ¨åˆ†é…ç½®å¦‚ä¸‹ï¼šR21234567!interface ve 921 ip address 10.0.254.9/30!interface ve 922 ip address 10.0.254.13/30! R11234567!interface ve 921 ip address 10.0.254.10/30!interface ve 922 ip address 10.0.254.14/30! è®¾å¤‡ä¹‹é—´çš„vlané€ä¼ ï¼Œè‡ªå·±åŽ»ä¼ å§ï¼Œæ³¨æ„åˆ«æˆçŽ¯äº†å°±è¡Œã€‚é…ç½®å¥½äº†ä¹‹åŽï¼Œæµ‹è¯•ä¸€ä¸‹ã€‚R2#12ping 10.0.254.10 source 10.0.254.9ping 10.0.254.13 source 10.0.254.14 R1#12ping 10.0.254.9 source 10.0.254.10ping 10.0.254.13 source 10.0.254.14 ISIS Configä¸‹é¢ä»‹ç»ISISç›¸å…³çš„é…ç½®ï¼Œä¸åŒåŽ‚å•†çš„å‘½ä»¤å’Œå¼€å¯æ–¹å¼å¯èƒ½ä¸ä¸€æ ·ï¼Œä½†å¤§éƒ¨åˆ†åŠŸèƒ½æ˜¯ä¸€è‡´çš„ã€‚æŒ‰ç…§ä»¥ä¸‹çš„è„šæœ¬æ¥é…ç½®å³å¯ï¼šR112345678910111213141516R1#configure terminalR1(config)#router isis //è¿›å…¥isisåè®®ï¼Œè¿›å…¥åŽï¼Œä¼šæç¤ºå…ˆè®¾ç½®netR1(config-isis-router)#net 49.0001.0000.0000.1000.00 //è®¾ç½®netR1(config-isis-router-ipv4u)#address-family ipv4 unicast //å¼€å¯isisçš„ipv4å•æ’­åŠŸèƒ½R1(config-isis-router-ipv4u)#maximum-paths 8 //è®¾ç½®æœ€å¤§è·¯å¾„ï¼Œä¸åŒè®¾å¤‡ä¸ä¸€è‡´R1(config-isis-router-ipv4u)#exit //é€€å‡ºR1(config)#ip router-id 169.254.254.1 //è®¾ç½®router-idR1(config)#interface loopback 1 //è¿›å…¥çŽ¯å›žæŽ¥å£R1(config-lbif-1)#ip address 169.254.254.1/32 //è®¾ç½®çŽ¯å›žæŽ¥å£IPä¸ºrouter-idR1(config-lbif-1)#ip router isis //å¼€å¯isisåŠŸèƒ½R1(config-lbif-1)#interface ve 921 //è¿›å…¥ä¸‰å±‚è™šæ‹ŸæŽ¥å£R1(config-vif-921)#ip router isisR1(config-vif-921)#interface ve 922R1(config-vif-922)#ip router isisR1(config-vif-922)#exitR1(config)#write memory R2è·¯ç”±å™¨çš„é…ç½®è¿‡ç¨‹ä¸ŽR1æ˜¯ç›¸ä¼¼çš„ï¼Œä½†æ˜¯éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒR2çš„netå°†è®¾ç½®ä¸º49.0002.0000.0000.2000.00ï¼Œrouter-idå°†è®¾ç½®ä¸º169.254.254.2ï¼Œå¯¹åº”çš„çŽ¯å›žåœ°å€æŽ¥å£çš„IPè®¾ç½®ä¸º169.254.254.2/32ã€‚è®¾ç½®å¥½åŽæ‰§è¡Œå‘½ä»¤show isis routesæ¥æ£€æŸ¥ISISæ˜¯å¦æ­£å¸¸å­¦ä¹ è·¯ç”±ã€‚R1/R212R1#show isis routesR2#show isis routes æŒ‰ç…§ä¹‹å‰çš„é…ç½®æ€è·¯ï¼Œæ­¤æ—¶å¯ä»¥åœ¨R2ä¸­çœ‹åˆ°ä»¥ä¸‹è·¯ç”±ä¿¡æ¯ï¼šR112345678910111213Total number of IS-IS routes: 3Destination Mask Cost Type Tag Flags10.0.254.8 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 10.0.254.12 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 169.254.254.1 255.255.255.255 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 å¯¹åº”çš„R1ä¹Ÿä¼šæœ‰ç±»ä¼¼çš„è·¯ç”±ä¿¡æ¯ï¼Œè¿™é‡Œä¸åœ¨èµ˜è¿°äº†ã€‚ Summaryåˆ°è¿™é‡Œï¼ŒR1å’ŒR2ä¹‹é—´çš„ISISäº’è”å°±å»ºç«‹å¥½äº†ï¼Œä¹Ÿå°±æ˜¯è¯´éª¨å¹²ç½‘çŽ°åœ¨å·²ç»å»ºç«‹å¥½äº†ï¼ŒçŽ°åœ¨å°±å¯ä»¥åœ¨ISISä¹‹ä¸Šåœ¨æ¥æž„å»ºå…¶ä»–çš„ç½‘ç»œé…ç½®äº†ã€‚æ•´ä¸ªè¿‡ç¨‹ï¼Œä¸ŽOSPFçš„åŸºç¡€æž„å»ºè¿‡ç¨‹å¾ˆç±»ä¼¼ï¼Œå¤§éƒ¨åˆ†åŠ¨æ€è·¯ç”±åè®®éƒ½æ”¯æŒç”¨å¯†é’¥çš„æ–¹å¼æ¥å…è®¸å»ºç«‹è¿žæŽ¥ï¼ŒISISä¹Ÿä¸ä¾‹å¤–çš„ï¼Œä½†éœ€è¦è®¾å¤‡æ”¯æŒä¸”é€šä¿¡åŒæ–¹éƒ½å·²çŸ¥å¯†é’¥ï¼Œå½“ç„¶ï¼ŒBFDä¾ç„¶å¯ä»¥ç”¨åœ¨ISISä¸­ï¼ˆåˆç†ç»“åˆä½¿ç”¨ä¼šä½¿å¾—ISISçš„è·¯ç”±æ”¶æ•›é€Ÿåº¦æ›´å¿«ï¼‰ï¼Œä½†è¿™éœ€è¦è®¾å¤‡æ”¯æŒï¼Œå¹¶ä¸”è¦æŸ¥é˜…è®¾å¤‡æ‰‹å†Œï¼Œæ‰¾åˆ°å…¶å…·ä½“é…ç½®æ–¹æ³•ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brocade VDX VCSé…ç½®æ–¹æ³•]]></title>
    <url>%2F2019%2F03%2F19%2FBrocade-VDX-VCS%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroductionVCSå…¨ç§°å«åšVCSçŸ©é˜µéƒ¨ç½²æ¨¡å¼ï¼Œæ˜¯å°†å¤šå°VDXç³»åˆ—ä»»æ„åž‹å·çš„ç‰©ç†äº¤æ¢æœºè®¾å¤‡é€šè¿‡ä¸‡å…†æˆ–è€…40Gä»»æ„æ‹“æ‰‘äº’è”å½¢æˆä¸€ä¸ªçŸ©é˜µï¼Œè¿›è¡Œç»Ÿä¸€é…ç½®ã€ç®¡ç†ã€ç›‘æŽ§(å¥—è¯)ã€‚æ³¨æ„ï¼š åªèƒ½ç”¨10Gæˆ–è€…40Gé“¾è·¯å®žçŽ°ï¼Œä¹Ÿå°±æ˜¯è¯´åªèƒ½ç”¨ç‰©ç†æŽ¥å£ï¼ˆport-channgelå¯ä»¥è¯•è¯•ï¼‰åŽ»å®žçŽ°ï¼Œä½†æ˜¯å¥½åœ¨å¯ä»¥ä½¿ç”¨å¤šæ¡10Gé“¾è·¯ï¼Œä¸”æµé‡æ˜¯è´Ÿè½½å‡è¡¡çš„ã€‚ æ‰€æœ‰ç‰©ç†äº¤æ¢æœºçš„è½¯ä»¶(å°±æ˜¯ç³»ç»Ÿç‰ˆæœ¬)å¿…é¡»ä¸€è‡´ éœ€æ‰‹åŠ¨è®¾å®šVCSé›†ç¾¤çš„IPå·ç ï¼Œé›†ç¾¤å”¯ä¸€çš„ç¼–å·ï¼Œä»Ž1-8192 éœ€æ‰‹åŠ¨è®¾å®šVCSé›†ç¾¤å†…éƒ¨ç‰©ç†äº¤æ¢æœºrbridge-idç¼–å·ï¼Œï¼Œè¯¥ç¼–å·å”¯ä¸€ï¼Œä»Ž1-239 éƒ¨ç½²å®ŒVCSé…ç½®åŽä¼šæ¸…ç©ºç‰©ç†äº¤æ¢æœºå†…éƒ¨å·²æœ‰çš„é…ç½® Configurationä¸‹é¢ä»‹ç»å¤§è‡´é…ç½®ã€‚ Physical Interfaceç‰©ç†æŽ¥å£çš„é…ç½®åŸºæœ¬éƒ½æ˜¯ä¸€è‡´çš„ï¼Œæ‰€ä»¥ä»¥ä¸€ä¸ªç«¯å£ä¸ºä¾‹å³å¯ã€‚1234567#interface TenGigabitEthernet 1/0/1 des xxxx //æè¿°ä¿¡æ¯ fabric isl enable //è®¾ç½®ç§°ä¸ºVCSçš„fabric isl port fabric trunk enable //è®¾ç½®ç«¯å£çš„æ¨¡å¼ä¸ºtrunk no shutdown //å¼€å¯ç«¯å£# è‹¥ä¸æƒ³è®¾ç½®æ­¤æŽ¥å£ä¸ºVCSçŸ©é˜µäº’è”çš„ISLæŽ¥å£ï¼Œéœ€è¦é…ç½®ä»¥ä¸‹å‘½ä»¤åœ¨æŽ¥å£ä¸Šï¼š12fabric neighbor-discovery disableno fabric isl enable æ£€æŸ¥äº’è”ç«¯å£æ­£å¸¸ä¹‹åŽï¼Œå³å¯ä»¥å¼€å§‹ä¸‹ä¸€æ­¥æ“ä½œã€‚ Set VCS Cluster Numberåˆ©ç”¨consoleå£è¿›å…¥åˆ°æ¯å°VDXåŽï¼Œæ‰§è¡Œå‘½ä»¤ï¼švcs vcsid X rbridge-id Y logical-chassis enableXä»£è¡¨VCSé›†ç¾¤IDç¼–å·ï¼Œæ˜¯æ•´ä¸ªé›†ç¾¤å†…éƒ¨å”¯ä¸€çš„ç¼–å·ï¼›Yä»£è¡¨VCSé›†ç¾¤å†…éƒ¨æ¯ä¸€å°VDXäº¤æ¢æœºçš„ç¼–å·ï¼Œä¹Ÿå°±æ˜¯rbridge-idï¼Œç”¨äºŽæ ‡è¯†é›†ç¾¤å†…éƒ¨æ¯ä¸€å°VDXäº¤æ¢æœºï¼ŒåŒæ—¶ä¹Ÿæ˜¯ä½œä¸ºæŽ¥å£ç¼–å·çš„ç¬¬ä¸€ä½ï¼Œæ¯”å¦‚TenGigabitEthernet 1/0/1ä¸­çš„1å°±æ˜¯rbridge-id 1ï¼ŒåŽé¢çš„1å°±æ˜¯ç¬¬ä¸€ä¸ªç«¯å£ã€‚ æ³¨æ„ï¼Œä¸€æ—¦æ‰§è¡Œè¿™æ¡å‘½ä»¤ï¼Œå¾…VDXè‡ªåŠ¨é‡å¯åŽï¼Œæ‰€æœ‰åœ¨VCSé›†ç¾¤å†…çš„VDXå°±åœ¨é€»è¾‘ä¸Šæˆä¸ºä¸€å°äº†ï¼›ç†è®ºä¸Šè€Œè¨€ï¼Œæˆ‘ä»¬åªéœ€è¦æ“ä½œä¸€å°å°±å¯ä»¥å®Œæˆå¯¹æ‰€æœ‰è®¾å¤‡çš„é…ç½®äº†ï¼Œæ­¤æ—¶ï¼ŒVCSçš„æ¨¡å¼æ˜¯Logical Chassisã€‚VDXçš„VCSæ¨¡å¼æ˜¯Fabric Clusterï¼Œæ‰€ä»¥æˆ‘ä»¬åªéœ€è®¾ç½®vcs vcsid X rbridge-id Yå°±å¥½ã€‚ è‹¥é€‰æ‹©ä½¿ç”¨Logical Chassisæ¨¡å¼ï¼Œé»˜è®¤æƒ…å†µä¸‹æ˜¯ï¼Œæœºå™¨é‡å¯åŽï¼Œå…ˆå¯åŠ¨å®Œæˆçš„æœºå™¨ä¸ºç®¡ç†å‘˜ï¼Œè‹¥æƒ³æŒ‡å®šæŸå°æœºå™¨ï¼Œåˆ™æ‰§è¡Œå‘½ä»¤ï¼šlogical-chassis principal-priority 1å…¶ä¸­ï¼Œ1æ˜¯rbridge-idã€‚VCSé›†ç¾¤å†…éƒ¨çš„principalåˆ‡æ¢å‘½ä»¤ï¼šlogical-chassis principal switchover Management And SummaryVCSçŸ©é˜µé›†ç¾¤å¸¸ç”¨çš„æ£€æŸ¥å‘½ä»¤ï¼š1234567show vcs detailshow fabric allshow fabric islshow fabric islports rbridge-id 1/2/3...show fabric trunkreload rbridge-id 1/2/3... #é‡å¯rbridge-idä¸º1/2/3...çš„æŸä¸ªäº¤æ¢æœºvcs replace rbridge-id x #éœ€è¦æ›´æ¢å’Œæ›¿æ¢rbridge-idæ—¶ï¼Œå¯ä»¥å…ˆæ›¿æ¢æŽ‰ï¼Œéœ€è¦ç³»ç»Ÿæ”¯æŒ é»˜è®¤æƒ…å†µä¸‹ï¼Œåœ¨VCSåˆ›å»ºä¹‹åŽï¼Œç”¨æˆ·ç®¡ç†å‘˜æ“ä½œä»»ä½•é…ç½®éƒ½ä¸éœ€è¦æ‰§è¡Œä¿å­˜çš„åŠ¨ä½œï¼Œå› ä¸ºç³»ç»Ÿä¼šè‡ªåŠ¨ä¿å­˜ã€‚]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F03%2F14%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[IntroPTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†å¥½æ­¹ç®—æ˜¯å†™å®Œäº†ï¼Œä¹°äº†ç´«ä¹¦ï¼Œå¤šå¤šå°‘å°‘ç®—æ˜¯ä¼‘æ¯äº†ä¸‰å››å¤©å§ï¼ŒçŽ°åœ¨ä¹Ÿè¯¥é‡æ–°å¼€å§‹æ–°çš„æ—…ç¨‹(å—è™ðŸ˜¤)äº†ã€‚PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†å› ä¸ºæŒ‰ç…§PTAç½‘ç«™çš„æ ¼å¼ï¼Œåœ¨Blogä¸­ç»™å‡ºäº†é¢˜ç›®çš„å†…å®¹ã€è¾“å…¥è¾“å‡ºæ ·ä¾‹ã€è¦æ±‚ç­‰ä¿¡æ¯ï¼Œå—¯ï¼Œå†™çš„ååˆ†è¯¦ç»†(æ°´æ–‡)ï¼Œæ´‹æ´‹æ´’æ´’çš„å¥½å‡ ä¸‡å­—å‘¢(å‡‘å­—æ•°)ï¼Œå“ˆå“ˆã€‚è¯´åˆ°åº•æ˜¯è‡ªå·±æ•´ç†çš„ç´¯ï¼Œåˆ«äººçœ‹çš„ä¹Ÿç´¯ã€‚æ‰€ä»¥ï¼Œåœ¨æœ¬ç¯‡Blogä¸­å°±ä¸åœ¨ç»™å‡ºå…¶ä»–ä¿¡æ¯äº†ï¼Œåªç»™å‡ºä»£ç å’Œåˆ†æžå§ã€‚é¢˜ç›®ä¿¡æ¯ï¼Œè¯·ç‚¹å‡»ï¼šPAT (Basic Level) Practiceã€‚ä¸è¿‡ï¼Œæƒ³æ¥å„ä½çœ‹å®˜åº”è¯¥ä¹Ÿåªæœ‰åœ¨çœ‹åˆ°é¢˜ç›®æ‘¸å¤´ã€æŒ å¤´çš„æ—¶å€™ï¼Œæ‰ä¼šæ¥çœ‹è¿™é‡Œçš„å†…å®¹å§ï¼Œè¿™ä¹Ÿå°±æ›´åŠ æ²¡æœ‰æ˜¾ç¤ºé¢˜ç›®ä¿¡æ¯çš„å¿…è¦äº†ã€‚å—¯ï¼Œå°±æŒ‰ç…§è¿™æ ·çš„æƒ³æ³•æ¥åšå§ã€‚ è¯è¯´ï¼Œåœ¨Basic Levelå†…å¥½åƒåªæœ‰ç¼–ç¨‹é¢˜å“¦ã€‚ 1001 å®³æ­»äººä¸å¿å‘½çš„(3n+1)çŒœæƒ³Analysisé¢˜ç›®æ¯”è¾ƒç®€å•ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„ç®—æ³•åŽ»æž„é€ è®¡ç®—è¿‡ç¨‹å³å¯ï¼Œcount++å…¶å®žåªåœ¨æœ€åŽå†™ä¸€å¥å°±å¯ä»¥äº†ã€‚ Code12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, count = 0; cin &gt;&gt; n; while(n != 1) &#123; if(n % 2 == 1) n = 3 * n + 1; n /= 2; count++; &#125; cout &lt;&lt; count; return 0;&#125; 1002 å†™å‡ºè¿™ä¸ªæ•°Analysisè¿™ä¸ªé¢˜ç›®20åˆ†å‘¢ï¼Œä¸è¿‡ä¸éš¾ï¼Œå˜»å˜»ï¼Œå°±æ˜¯æ¯”è¾ƒéº»çƒ¦ï¼Œçœ‹ç€é¢˜ç›®ä¸­çš„è¯ï¼šè¿™é‡Œä¿è¯$n$å°äºŽ$10^{100}$ï¼Œå¥½åƒçœ‹åˆ°äº†å‡ºé¢˜äººâ€œå–„æ„â€çš„å¾®ç¬‘ä¸€æ ·å‘¢(wo zhen xiang da si ni~)ã€‚å¤§è‡´æ€è·¯ï¼Œå…ˆè¦ç®—å‡ºæ¯ä¸ªæ•°ä½ä¸Šæ•°å­—çš„æ€»å’Œï¼Œç„¶åŽå†å°†ç»“æžœè¿›è¡Œæ•°ä½æ‹†åˆ†è¾“å‡ºä¸€ä½ä¸€ä½çš„æ•°å­—å°±å¥½äº†ã€‚å¯¹äºŽè¾“å…¥çš„æ•°å­—ä¸²ï¼Œå¯ä»¥ç”¨å•å­—ç¬¦çš„å½¢å¼æ¥å¤„ç†ï¼Œä¹Ÿå¯ä»¥ä»Žå­—ç¬¦ä¸²çš„è§’åº¦åŽ»å¤„ç†ï¼Œå¦å¤–æ³¨æ„åšæ•°ä½æ‹†åˆ†æ—¶çš„ä¸ªä½æ•°ï¼Œæ³¨æ„0çš„æ‹¼éŸ³æ˜¯lingä¸æ˜¯linã€‚ ç»§ç»­åˆ†æžä¸€ä¸‹é¢˜ç›®æ¡ä»¶ï¼Œâ€œä¿è¯$n$å°äºŽ$10^{100}$è¿™ä¸ªæ¡ä»¶å¥½åƒè¿˜æœ‰ç‚¹çŒ«è…»ï¼Ÿå°äºŽ$10^{100}$é‚£èƒ½å–åˆ°çš„æœ€å¤§çš„æ•°ä¸å°±æ˜¯$10^{100} - 1$äº†ï¼Œä¸”è¿™ä¸ªæ•°çš„æ¯ä¸€ä½éƒ½æ˜¯9ï¼Œæ€»å…±100ä½ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œæœ€åŽå¾—åˆ°çš„å„ä½æ•°å­—ä¹‹å’Œè‚¯å®šä¸ä¼šå¤§äºŽ$9 \times 100 = 900$ï¼Œæœ€å¤šä¹Ÿä¸ä¼šè¶…è¿‡ä¸‰ä½æ•°äº†ï¼Œè¿™æ˜¯ä¸ªå¥½æ¶ˆæ¯ï¼æ˜Žç¡®äº†è¿™ç‚¹åŽï¼Œæ•°ä½æ‹†åˆ†çš„è¿‡ç¨‹å°±ç®€å•äº†ï¼›å¦å¤–ï¼Œéœ€è¦è¾“å‡ºçš„å­—ç¬¦ä¸²ï¼Œå¯ä»¥å•ç‹¬æ”¾åœ¨äºŒç»´æ•°ç»„å†…ï¼Œåˆ©ç”¨èƒ½åˆ°çš„æ•°ä½ä»£æ›¿ä¸‹æ ‡ï¼Œæ¥è¾“å‡ºå°±å¾ˆæ–¹ä¾¿äº†ï¼ CodeæŒ‰ç…§ä¸Šè¿°çš„ä¸¤ç§æ€è·¯å¾—åˆ°çš„ AC åˆ†åˆ«ä»£ç å¦‚ä¸‹ï¼š1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; char c; int num, sum=0; while((c=getchar()) != '\n') &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; num = c - '0'; sum+=num; &#125;else continue; &#125; /* method 1: int digit, temp=sum, mask=1; while(temp &gt; 9) &#123; temp/=10; mask*=10; &#125; temp=sum; do &#123; digit=temp/mask; temp%=mask; mask/=10; switch(digit) &#123; case 0:printf("ling");break; case 1:printf("yi");break; case 2:printf("er");break; case 3:printf("san");break; case 4:printf("si");break; case 5:printf("wu");break; case 6:printf("liu");break; case 7:printf("qi");break; case 8:printf("ba");break; case 9:printf("jiu");break; &#125; if(mask == 0) printf("\n"); else printf(" "); &#125; while(mask &gt; 0); */ /*method 2:*/ char num2chinese[][6] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; int unit, tens, hundred; unit = sum%10; tens = sum/10%10; hundred=sum/100; if(sum &gt; 100) &#123; printf("%s %s %s\n", num2chinese[hundred], num2chinese[tens], num2chinese[unit]); &#125; else if(10 &lt; sum &amp;&amp; sum &lt; 100) &#123; printf("%s %s\n", num2chinese[tens], num2chinese[unit]); &#125; else &#123; printf("%s\n", num2chinese[unit]); &#125; return 0;&#125; 1003 æˆ‘è¦é€šè¿‡ï¼AnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;int select_str(char s[], int length); int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); char str[105]; while(n--) &#123; scanf("%s", str); int left, mid, right; left = mid = right = 0; int i, cnt, len = strlen(str); //calculate the number of 'A' in different area. for(i=0; i&lt;len; i++) &#123; if(str[i] != 'P') left++; else break; &#125; for(i=0, cnt=0; i&lt;len; i++) &#123; if(str[i] != 'T') cnt++; else &#123; mid = cnt - left - 1; //subtract the number of 'P' right = len - cnt - 1; //subtract the number of 'T' break; &#125; &#125;// printf("left=%d, mid=%d, right=%d\n", left, mid, right); //output the number of 'A' in different area. if(select_str(str, len)) &#123; if(!mid) printf("NO\n"); else &#123; if(left * mid == right) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125;int select_str(char s[], int length) &#123; //when the string has other chars dislike 'P' or 'A' or 'T', the string is wrong. int i, flag=1; for(i=0; i&lt;length; i++) &#123; if(s[i] != 'P' &amp;&amp; s[i] != 'A' &amp;&amp; s[i] != 'T')&#123; flag=0; break; &#125; &#125; return flag;&#125; 1004 æˆç»©æŽ’åAnalysisè¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œç®—æ˜¯æŸ¥æ‰¾å§ï¼Œå®šä¹‰å¥½ç»“æž„ä½“è¿›è¡Œå¤„ç†å°±å¥½ï¼Œæ³¨æ„æœ€å¤§ã€æœ€å°å€¼å¾—åˆ†å¼€åˆ¤æ–­ï¼Œè€Œä¸æ˜¯åªç”¨if-elseå°±å®Œäº‹å¤§å‰ã€‚ Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef struct Stu &#123; char name[12]; char number[12]; int grade;&#125; students;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); int i=0; students stu, max, min; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); max = min = stu; for(i=1; i&lt;n; i++) &#123; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); /*online processing, find the minimum and maximum when inputing. */ if(stu.grade &lt; min.grade) min = stu; if(stu.grade &gt; max.grade) max = stu; &#125; printf("%s %s\n%s %s\n", max.name, max.number, min.name, min.number); return 0;&#125; 1005 ç»§ç»­(3n+1)çŒœæƒ³AnalysisæŒ‰ç…§1001çš„æ€è·¯ï¼Œå¯¹è¾“å…¥çš„æ¯ä¸ªæ•°è¿›è¡Œæ¨¡æ‹Ÿï¼Œå¼€è¾Ÿä¸€ä¸ªboolæ•°ç»„æ¥è®°å½•æŸä¸ªæ•°å­—æ˜¯å¦å‡ºçŽ°ï¼Œå‡ºçŽ°åˆ™å°†ä¸‹æ ‡ä¸ºå…¶å€¼çš„boolé‡ç½®ä¸ºtrueï¼Œç”±äºŽæ¯ä¸ªæ•°åœ¨æ¨¡æ‹Ÿä¸­å¯èƒ½ä¼šå‡ºçŽ°ä¸åŒçš„æ•°å­—ï¼Œæœ€å¥½è¿˜æ˜¯æ¯ä¸ªæ•°å­—éƒ½æ¨¡æ‹Ÿä¸€ä¸‹ã€‚å¦å¤–ï¼Œç”±äºŽæœ€åŽéœ€è¦ä»Žå°åˆ°å¤§è¾“å‡ºï¼Œæ‰€ä»¥å°†è¾“å…¥æ•°å­—åºåˆ—æŒ‰ä»Žå¤§åˆ°å°æŽ’åºåŽï¼Œåœ¨è¿›è¡Œè¾“å‡ºã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;int main(int argc, char const *argv[]) &#123; int K, Num[105] = &#123;0&#125;, temp; bool times[MAXN] = &#123;false&#125;; scanf("%d", &amp;K); for(int i = 0; i &lt; K; i++) &#123; scanf("%d", &amp;Num[i]); temp = Num[i]; while(temp != 1) &#123; if(temp % 2 == 1) &#123; temp = 3 * temp + 1; &#125; temp /= 2; times[temp] = true; &#125; &#125; sort(Num, Num + K); bool flag = true; for(int i = K - 1; i &gt;= 0; i--) &#123; if(!times[Num[i]]) &#123; if(flag) &#123; printf("%d", Num[i]); flag = false; &#125; else &#123; printf(" %d", Num[i]); &#125; &#125; &#125; return 0;&#125; 1006 æ¢ä¸ªæ ¼å¼è¾“å‡ºæ•´æ•°Analysisæ°´é¢˜ä¸€é“ï¼Œé¢˜ç›®å·²ç»è¯´äº†ç»™ä¸€ä¸ªä¸è¶…è¿‡3ä½çš„æ­£æ•´æ•°ï¼Œåšå¥½æ•°ä½æ‹†åˆ†åŽï¼ŒæŒ¨ä¸ªè¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, num, unit, tens, hundred; scanf("%d", &amp;num); unit = num % 10; tens = num / 10 % 10; hundred = num / 100; for(i=0; i&lt;hundred; i++) &#123; printf("B"); &#125; for(i=0; i&lt;tens; i++) &#123; printf("S"); &#125; for(i=1; i&lt;=unit; i++) &#123; printf("%d", i); &#125; printf("\n"); return 0;&#125; 1007 ç´ æ•°å¯¹çŒœæƒ³Analysisè¿™é“é¢˜è¦ç¨å¾®ç†è§£ä¸€ä¸‹é¢˜ç›®æ„æ€ï¼Œä¹ä¸€çœ‹ï¼Œå¯èƒ½ä¼šæ²¡æ˜Žç™½é¢˜ç›®çš„æ„æ€ã€‚å…³é”®çš„æ¡ä»¶ï¼šå­˜åœ¨æ— ç©·å¤šå¯¹ç›¸é‚»ä¸”å·®ä¸º2çš„ç´ æ•°ï¼Œä¹Ÿå³æ˜¯è¯´ï¼Œå¯¹äºŽé¢˜ç›®ç»™å®šçš„$N = 20$è€Œè¨€ï¼Œåœ¨$2 - 20$ä¹‹é—´ï¼Œå¿…ç„¶å­˜åœ¨ç›¸é‚»ä¸”å·®ä¸º2çš„ç´ æ•°å¯¹ï¼è€Œé¢˜ç›®çš„é—®é¢˜æ˜¯ï¼šè®¡ç®—ä¸è¶…è¿‡$N$çš„æ»¡è¶³çŒœæƒ³çš„ç´ æ•°å¯¹çš„ä¸ªæ•°ï¼Œé‚£ä¹ˆç›´æŽ¥è¿›è¡Œè®¡ç®—å°±å¥½äº†ã€‚è‡³äºŽï¼Œåˆ¤æ–­ç´ æ•°çš„å‡½æ•°åˆ™æ˜¯è€ç”Ÿå¸¸è°ˆçš„é—®é¢˜äº†ï¼Œæ–¹æ³•å¾ˆå¤šã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef enum&#123; false, true&#125; bool;bool IsPrime(int n);int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d", &amp;N); for(i = 2; i &lt;= N - 2; i++) &#123; if(IsPrime(i) &amp;&amp; IsPrime(i + 2)) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;bool IsPrime(int n) &#123; bool flag = true; if(n &lt;= 1 || n % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(n); i+=2) &#123; if(n % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 1008 æ•°ç»„å…ƒç´ å¾ªçŽ¯å³ç§»é—®é¢˜Analysisæœ¬é¢˜çš„è§£ç­”æ–¹æ³•è¾ƒå¤šï¼Œé¦–å…ˆéœ€è¦å¯¹ç§»åŠ¨æ¬¡æ•°$M$è¿›è¡Œå¤„ç†ï¼Œåˆ†åˆ«å¯¹åº”ä¸¤ç§æƒ…å†µï¼Œ$M &gt;= N$å’Œ$M &lt; N$ï¼Œä½¿ç”¨å–ä½™è¿ç®—å³å¯ã€‚ä¸‹é¢ä»‹ç»ä¸€ä¸‹å„ç§æ–¹æ³•ï¼š ä¸ç§»åŠ¨ï¼Œå…ˆè¾“å‡ºæŒ‡å®šä½ç½®ï¼Œå†è¾“å‡ºä½™ä¸‹ä½ç½®å³å¯ åˆ©ç”¨é˜Ÿåˆ—ï¼Œç§»åŠ¨çš„è¿‡ç¨‹æ­£å¥½å¯¹åº”é˜Ÿåˆ—å‡ºä¸€æ¬¡é˜Ÿï¼Œå†å…¥ä¸€æ¬¡é˜Ÿ é‡‡ç”¨ç§»ä½ç®—æ³•ï¼Œå¤§è‡´è¿‡ç¨‹ï¼ˆä»¥æ ·ä¾‹ä¸ºä¾‹ï¼‰ï¼š 12345n = 6, m = 2, move 3 turns-&gt; 1 2 3 4 5 6, firstly swap a[0] and a[3], then swap a[1] and a[2] -&gt; 4 3 2 1 5 6, swap a[4] and a[5]-&gt; 4 3 2 1 6 5, fristly swap a[0] and a[5], then swap a[1] and a[4]-&gt; 5 6 1 2 3 4 ç§»ä½ç®—æ³•çš„å¤§è‡´ä»£ç ï¼š 1234567void reverse(int *array, int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = array[i]; array[i] = array[start + end - i]; array[start + end - i] = temp; &#125;&#125; Codedirect output12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; for(int i = n - m; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; for(int i = 0; i &lt; n - m; i++) &#123; cout &lt;&lt; a[i]; if(i != n - m - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; use queue12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt; q; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; m %= n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q.push(temp); &#125; for(int i = 0; i &lt; n - m; i++) &#123; temp = q.front(); q.pop(); q.push(temp); &#125; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); if(q.size() != 0) cout &lt;&lt; ' '; &#125; return 0;&#125; shift algorithm1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn = 110;void Reverse(int a[], int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = a[i]; a[i] = a[end + start - i]; a[end + start - i] = temp; &#125;&#125;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; Reverse(a, 0, n - m - 1); Reverse(a, n - m, n - 1); Reverse(a, 0, n - 1); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 1009 è¯´åè¯Analysisè¿™ä¸ªé¢˜å¦‚æžœå•çº¯çš„å¤„ç†å­—ç¬¦ä¸²çš„è¯ï¼Œä¼šæ¯”è¾ƒéº»çƒ¦ã€‚ä¸è¿‡è‹¥æ˜¯ä½¿ç”¨äºŒç»´æ•°ç»„ï¼ˆå­—ç¬¦ä¸²æ•°ç»„ï¼‰å°±å¾ˆç®€å•äº†ï¼Œåˆ©ç”¨çš„æ˜¯scanfæ— æ³•è¯»å…¥å¸¦ç©ºæ ¼çš„å­—ç¬¦ä¸²çš„ç‰¹æ€§ã€‚ Code123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int count = 0; char Str[85][85], c; while(1) &#123; scanf("%s", Str[++count]); c = getchar(); if(c == '\n') &#123; break; &#125; &#125; for(; count &gt; 1; count--) &#123; printf("%s ", Str[count]); &#125; puts(Str[count]); return 0;&#125; 1010 ä¸€å…ƒå¤šé¡¹å¼æ±‚å¯¼Analysé¢˜ç›®å¤§æ„è¾ƒä¸ºæ˜Žç¡®ï¼Œä½†æ„Ÿè§‰æœ‰äº›ä¸œè¥¿æ²¡è¯´æ˜Žç™½...æ³¨æ„çš„åœ°æ–¹å¤§è‡´å¦‚ä¸‹ï¼š å› ä¸ºæ²¡è¯´è¾“å…¥ä»€ä¹ˆæ—¶å€™ç»“æŸï¼Œæ‰€ä»¥åªèƒ½æ‰‹åŠ¨ä½¿ç”¨ Windows ä¸‹çš„Ctrl + Zæ¥ç»“æŸè¾“å…¥ï¼Œåˆ¤é¢˜ç³»ç»Ÿå»ºåœ¨ Linux ä¸Šï¼Œåº”è¯¥è‡ªåŠ¨ä½¿ç”¨çš„Ctrl + Dï¼Œè¿™ä¸¤ä¸ªæ“ä½œéƒ½è¡¨ç¤ºEOFï¼Œæ‰€ä»¥å¾—ä½¿ç”¨!= EOFæ¥ä½œä¸ºè¾“å…¥ç»“æŸçš„æ ‡å¿— å¸¸æ•°é¡¹æ±‚å¯¼åŽä¸º0ï¼Œéœ€è¦è¾“å‡ºä¸º0 0ï¼Œè¿™åº”è¯¥æ˜¯é¢˜ç›®æœ€åŽä¸€ä¸ªæ¡ä»¶çš„æç¤ºäº† å¯èƒ½å‡ºçŽ°æŒ‡æ•°ä¸ºè´Ÿçš„é¡¹ï¼Œè¾“å‡ºé¡ºåºæ˜¯æŒ‡æ•°é€’é™çš„ï¼Œè¿™é‡Œç”¨é“¾è¡¨å°±å¾ˆæ— è„‘ï¼Œå› ä¸ºè¾“å…¥ç»å¯¹æ˜¯æŒ‡æ•°é€’é™çš„ï¼Œé‚£ä¹ˆæ±‚å¯¼å®ŒåŽï¼Œä¹Ÿç»å¯¹æ˜¯æŒ‡æ•°é€’é™çš„ï¼Œç›´æŽ¥è¾“å‡ºå³å¯ è¿™é“é¢˜ä¹Ÿå¯ä»¥ç”¨é“¾è¡¨æ¥åšï¼Œæ±‚å¯¼çš„è¿‡ç¨‹ä¼šå¤æ‚ä¸€äº›ã€‚ Codeuse linked list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node* List;typedef struct node&#123; int coef, expo; List next;&#125; Node;List CreateList(void);void Derivation(List L);void Print(List L);int main(int argc, char const *argv[]) &#123; List L = CreateList(); Derivation(L); Print(L); return 0;&#125; List CreateList(void) &#123; List L = (List)malloc(sizeof(Node)), rear; L-&gt;next = NULL; rear = L; int c, e; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; List temp_node = (List)malloc(sizeof(Node)); temp_node-&gt;next = NULL; rear-&gt;next = temp_node; rear = temp_node; temp_node-&gt;coef = c; temp_node-&gt;expo = e; &#125; return L;&#125;void Print(List L) &#123; List Temp = L-&gt;next; int flag = 1; while(Temp) &#123; if(flag) &#123; printf("%d %d", Temp-&gt;coef, Temp-&gt;expo); flag = 0; &#125; else &#123; if(Temp-&gt;coef != 0) &#123; printf(" %d %d", Temp-&gt;coef, Temp-&gt;expo); &#125; &#125; Temp = Temp-&gt;next; &#125; putchar('\n');&#125;void Derivation(List L) &#123; List p = L-&gt;next; while(p) &#123; if(p-&gt;expo) &#123; p-&gt;coef = p-&gt;coef * p-&gt;expo; p-&gt;expo--; &#125; else &#123; p-&gt;coef = 0; &#125; p = p-&gt;next; &#125;&#125; use array123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, items[1005] = &#123;0&#125;, c, e, count = 0; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; items[e] = c; &#125; items[0] = 0; for(i = 1; i &lt;= 1000; i++) &#123; items[i - 1] = items[i] * i; items[i] = 0; if(items[i - 1] != 0) &#123; count++; &#125; &#125; if(count == 0) printf("0 0\n"); else &#123; for(i = 1000; i &gt;= 0; i--) &#123; if(items[i]) &#123; printf("%d %d", items[i], i); count--; if(count != 0) &#123; putchar(' '); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125; 1011 A+Bå’ŒCAnalysisç”±äºŽé¢˜ç›®é™å®šäº†è¾“å…¥æ•°æ®èŒƒå›´ä¸º$[-2^{31}, 2^{31}]$ï¼Œæœ¬é¢˜å¯ä»¥æœ‰ä¸¤ç§è§£æ³•ï¼š ç›´æŽ¥ä½¿ç”¨long longï¼Œé¿å…ä½¿ç”¨intå¸¦æ¥çš„æº¢å‡º ä¾æ—§ä½¿ç”¨intï¼Œä½†æ˜¯éœ€è¦åšæº¢å‡ºå¤„ç†ï¼ŒåŒ…æ‹¬æ­£æº¢å‡ºå’Œè´Ÿæº¢å‡ºä¸¤ç§æƒ…å†µ Codeuse long long1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &gt; c) cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; &#125; return 0;&#125; use int1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; //positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; //negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; //normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1012 æ•°å­—åˆ†ç±»AnalysisæŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œä¾æ¬¡æ±‚å‡ºæ‰€æœ‰æ•°å­—ï¼Œä½†åœ¨è¾“å‡ºçš„æ—¶å€™è¦æ³¨æ„ï¼ŒA2çš„ç»“æžœå¯èƒ½æ˜¯ 0 ï¼Œæ­¤æ—¶A2æ˜¯å­˜åœ¨çš„ï¼Œè¦è¾“å‡º0ï¼Œè€Œä¸æ˜¯Nï¼Œç±»ä¼¼çš„æœ‰$A_4$ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;int main() &#123; int n, temp, a[6] = &#123;0&#125;, sign = 1, count = 0, flag = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;temp); int remain = temp % 5; if(remain == 0 &amp;&amp; temp % 2 == 0) a[1] += temp; if(remain == 1) &#123; a[2] += sign * temp; sign = -sign; flag = 1; &#125; if(remain == 2) a[3]++; if(remain == 3) &#123; a[4] += temp; count++; &#125; if(remain == 4 &amp;&amp; temp &gt; a[5]) &#123; a[5] = temp; &#125; &#125; if(a[1]) printf("%d ", a[1]); else printf("N "); if(flag) printf("%d ", a[2]); else printf("N "); if(a[3]) printf("%d ", a[3]); else printf("N "); if(a[4]) printf("%.1lf ", (double)a[4] / count); else printf("N "); if(a[5]) printf("%d", a[5]); else printf("N"); return 0;&#125; 1013 æ•°ç´ æ•°Analysisç´ æ•°ç›¸å…³çš„é¢˜ç›®å¥½åƒå·²ç»æ˜¯è€ç”Ÿå¸¸è°ˆçš„é¢˜åž‹äº†ï¼Œæ³¨æ„ä¸è¦è¶…æ—¶ã€‚ Codeéžç­›æ³•123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX 15000bool IsPrime(int number);int main(int argc, char const *argv[]) &#123; int M, N, Prime[MAX]; scanf("%d %d", &amp;M, &amp;N); int i, count = 2; Prime[1] = 2; for(i = 3; i &lt;= 105000; i++) &#123; if( IsPrime(i) ) &#123; Prime[count++] = i; &#125; &#125; count = 0; for(; M &lt; N; M++) &#123; printf("%d", Prime[M]); count++; if(count % 10 == 0) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; printf("%d\n", Prime[M]); return 0;&#125; bool IsPrime(int number) &#123; bool flag = true; if(number &lt;= 1 || number % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(number); i+=2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; ç­›æ³•1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 1000001;int prime[MAXN], pNum = 0;bool p[MAXN] = &#123;false&#125;;void filterPrime(int n) &#123; for(int i = 2; i &lt; MAXN; i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; if(pNum &gt;= n) break; for(int j = i + i; j &lt; MAXN; j += i) &#123; p[j] = true; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int m, n, count = 0; scanf("%d %d", &amp;m, &amp;n); filterPrime(n); for(int i = m; i &lt;= n; i++) &#123; printf("%d", prime[i - 1]); count++; if(count % 10 != 0 &amp;&amp; i &lt; n) putchar(' '); else putchar('\n'); &#125; return 0;&#125; 1014 ç¦å°”æ‘©æ–¯çš„çº¦ä¼šAnalysisè¿™ä¸ªé¢˜ç›®çš„ç»†èŠ‚å¤„ç†ï¼ŒçœŸæ˜¯...å¤ªå¤ªå¤ªéº»çƒ¦å•¦~å¤§è‡´åˆ†æžä¸€ä¸‹ï¼š å­—ç¬¦ç›¸åŒçš„æ—¶å€™æ‰èƒ½åˆ¤æ–­æ˜¯å¦è¾“å‡º æ˜ŸæœŸåˆ¤æ–­å¿…é¡»æ˜¯å¤§å†™å­—æ¯ï¼Œä¸”å¿…é¡»å±žäºŽ $[A, G]$ è¿™ä¸ªèŒƒå›´å†…ï¼ˆæµ‹è¯•ç‚¹4ï¼‰ï¼Œç”¨å–ä½™ä¸æ˜¯æ›´å¥½ä¹ˆï¼Ÿ æ—¶é—´å•ä½éœ€è¦ç”¨0æ¥è¡¥å…¨2ä½ ç‰¹åˆ«è¦æ³¨æ„çš„å°±è¿™äº›ï¼Œå…¶ä»–çš„å†ä»”ç»†è¯»è¯»é¢˜ç›®å°±OKäº†~ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char Week[7][5] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1015 å¾·æ‰è®ºAnalysisè¿™é“é¢˜ä¸€å¼€å§‹åšçš„æ—¶å€™è¿˜æƒ³äº†æŒºä¹…çš„ï¼Œè€Œä¸”è¿˜æ²¡æƒ³å‡ºæ¥ï¼Œä¸‹é¢æ¥åˆ†æžä¸€ä¸‹ã€‚ ä½¿ç”¨åº“å‡½æ•°sortæ¥å®ŒæˆæŽ’åºçš„åŸºæœ¬æ“ä½œå°±ä¸è¯´äº†ï¼Œå¤§æ¦‚å¾—æ³¨æ„ä¸¤ä¸ªç‚¹ï¼š æ€»åˆ†éœ€è¦è®¡ç®—å‡ºæ¥ä½œä¸ºæŽ’åºçš„ä¾æ®ï¼Œè¿™ä¸ªæ˜¯é¢˜ç›®æ˜Žç¡®è¯´æ˜Žçš„ é¢˜ç›®ç»™çš„è€ƒç”Ÿç§ç±»å¾ˆå¤šï¼Œä¸ºäº†æŽ’åºæ–¹ä¾¿å¯ä»¥ç»™è¿™äº›è€ƒç”Ÿåˆ†ç±»ï¼Œæ•°å­—è¶Šå¤§ç­‰çº§è¶Šä½Žï¼ˆæˆ–åä¹‹ï¼‰ èƒ½æ³¨æ„åˆ°è¿™ä¸¤ä¸ªç‚¹ï¼Œé¢˜ç›®åŸºæœ¬å°±å¯ä»¥å®Œæˆäº†ã€‚æ‰€ä»¥ï¼Œä»¥åŽåœ¨é‡åˆ°ç±»ä¼¼çš„é¢˜ç›®ï¼Œå°±æå‰åˆ†å¥½ç±»å§ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; int id, scoreD, scoreC, sumCD, flag;&#125; stu[MAXN];bool cmp(student a, student b);int N, L, H, M = 0;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d", &amp;stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumCD = stu[i].scoreC + stu[i].scoreD; if(stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreC &gt;= L) &#123; M++; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &lt; H) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else stu[i].flag = 4; &#125; else &#123; stu[i].flag = 5; &#125; &#125; sort(stu, stu + N, cmp); printf("%d\n", M); for(int i = 0; i &lt; M; i++) &#123; printf("%d %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumCD != b.sumCD) return a.sumCD &gt; b.sumCD; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return a.id &lt; b.id;&#125; 1016 éƒ¨åˆ†A+BAnalysisæ ¹æ®é¢˜ç›®çš„è¦æ±‚è¿›è¡Œè®¡ç®—å³å¯ï¼Œä»Žå­—ç¬¦ä¸²æˆ–è€…æ•°å­—çš„è§’åº¦éƒ½å¯ä»¥å¾—åˆ°è§£å†³æ–¹æ³•ã€‚ Codeuse string123456789101112131415161718#include &lt;iostream&gt;using namespace std;int getnum(char *str, char D) &#123; int ret = 0; char *p = str; for(; *p != '\0'; p++) &#123; //loop condition also can use str[i] != '\0' if(*p == D) &#123; ret = ret * 10 + (*p - '0'); &#125; &#125; return ret;&#125;int main() &#123; char A[12], B[12], a, b; scanf("%s %c %s %c", A, &amp;a, B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; use int12345678910111213141516#include &lt;iostream&gt;using namespace std;int getnum(int A, int a) &#123; int ret = 0; do&#123; if(A % 10 == a) ret = ret * 10 + a; A /= 10; &#125; while(A &gt; 0); return ret;&#125;int main() &#123; int A, B, a, b; scanf("%d %d %d %d", &amp;A, &amp;a, &amp;B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; 1017 Aé™¤ä»¥BAnalysisæ­¤é¢˜è€ƒå¯Ÿå¤§æ•´æ•°è¿ç®—ï¼Œå…¶ä¸­Aä¸ºå¤§æ•´æ•°ï¼ŒBä¸ºintç±»åž‹çš„æ•´æ•°ï¼Œè®¡ç®—è¿™ä¸¤ä¸ªæ•°çš„å•†å’Œä½™æ•°ã€‚æ­¤ç±»åž‹çš„é¢˜ç›®ï¼Œéœ€è¦ä½¿ç”¨æ•°ç»„æ¥ä¿å­˜å¤§æ•´æ•°ï¼Œå¹¶ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿé¢˜ç›®è¦æ±‚åšçš„è¿ç®—ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign&#123; int d[1005], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign divide(bign a, int b, int &amp;r) &#123; bign c; c.len = a.len; for(int i = a.len - 1; i &gt;= 0; i--) &#123; r = r * 10 + a.d[i]; if(r &lt; b) c.d[i] = 0; else &#123; c.d[i] = r / b; r %= b; &#125; &#125; while(c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) &#123; c.len--; &#125; return c;&#125;int main(int argc, char const *argv[]) &#123; char str[1005]; int b, r = 0; cin &gt;&gt; str &gt;&gt; b; bign a = change(str), c; c = divide(a, b, r); for(int i = c.len - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; c.d[i]; &#125; cout &lt;&lt; ' ' &lt;&lt; r ;; return 0;&#125; 1018 é”¤å­å‰ªåˆ€å¸ƒAnalysisé¢˜ç›®å¤§æ„å°±æ˜¯å‰ªåˆ€çŸ³å¤´å¸ƒçš„æ¸¸æˆè§„åˆ™ï¼Œå¯¹åº” 9 ç§æƒ…å†µï¼Œè¿›è¡Œæ¨¡æ‹Ÿå³å¯ï¼Œæ³¨æ„è¾“å‡ºèµ¢çš„æ¬¡æ•°æœ€å¤šä¸”å­—å…¸åºæœ€å°çš„è§£ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;char gesture(int *a) &#123; int index = 1; char ges = '\0'; for(int i = 1; i &lt;= 3; i++) &#123; if(a[i] &gt; a[index]) index = i; &#125; switch(index) &#123; case 1: ges = 'B'; break; case 2: ges = 'C'; break; case 3: ges = 'J'; break; &#125; return ges;&#125;int main() &#123; int n, tie = 0, win = 0, ar[4] = &#123;0&#125;, br[4] = &#123;0&#125;; cin &gt;&gt; n; char a, b; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if(a == b) tie++; else if(a == 'C' &amp;&amp; b == 'J') &#123; win++; ar[2]++; &#125; else if(a == 'J' &amp;&amp; b == 'B') &#123; win++; ar[3]++; &#125; else if(a == 'B' &amp;&amp; b == 'C') &#123; win++; ar[1]++; &#125; else if(b == 'C' &amp;&amp; a == 'J') &#123; br[2]++; &#125; else if(b == 'J' &amp;&amp; a == 'B') &#123; br[3]++; &#125; else if(b == 'B' &amp;&amp; a == 'C') &#123; br[1]++; &#125; &#125; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; n - tie - win &lt;&lt; endl; cout &lt;&lt; n - tie - win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; cout &lt;&lt; gesture(ar) &lt;&lt; ' ' &lt;&lt; gesture(br); return 0;&#125; 1019 æ•°å­—é»‘æ´žAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªå››ä½æ•°å­—ï¼Œæ‹†åˆ†å‡ºå…¶å„ä½æ•°åŽï¼Œèƒ½å¾—åˆ°ä¸€ä¸ªæœ€å¤§å€¼å’Œæœ€å°å€¼ï¼ŒäºŒè€…ç›¸å‡åŽï¼Œä¼šå¾—åˆ°ä¸€ä¸ªæ–°æ•°å­—ã€‚é‡å¤è¿™ä¸ªè¿‡ç¨‹ï¼Œæœ€åŽå·®ä¼šä¸€ç›´ç­‰äºŽ6174ã€‚æ‰€ä»¥ï¼Œå½“å·®ä¸º6174æ—¶ï¼Œå°±åœæ­¢å¾ªçŽ¯ã€‚ æŒ‰ç…§ä¸‹é¢çš„ä»£ç æ€è·¯ï¼Œæ¯æ¬¡å¿…é¡»è¦å°†ä¿å­˜å„ä½æ•°å­—çš„æ•°ç»„åˆå§‹åŒ–ä¸º0ï¼Œå¦åˆ™ä¼šæœ‰é”™è¯¯ï¼ˆå› ä¸ºæ•°ç»„æœ‰å››ä¸ªå…ƒç´ å‚ä¸Žäº†è¿ç®—ï¼‰ã€‚å¦å¤–ï¼Œéœ€è¦è¾“å‡ºç­¾åˆ°0ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1020 æœˆé¥¼Analysisè¿™æ˜¯é“è€ƒå¯Ÿè´ªå¿ƒç®—æ³•çš„é¢˜ç›®ï¼Œé¢˜ç›®è¦æ±‚è¾“å‡ºçš„æœ€å¤§æ”¶ç›Šï¼Œå®žé™…ä¸Šå°±æ˜¯å¯¹åº”å•ä»·æœ€é«˜çš„æœˆé¥¼å–å‡ºåŽçš„æ€»æ”¶ç›Šã€‚è‹¥å•ä»·æœ€é«˜çš„æœˆé¥¼çš„è´®å­˜é‡ä¸æ»¡è¶³å¸‚åœºéœ€æ±‚ï¼ŒæŒ‰ç…§å‰©ä½™çš„å¸‚åœºéœ€æ±‚é‡ç»§ç»­å–å•ä»·ç¬¬äºŒé«˜çš„æœˆé¥¼ã€‚æ‰€ä»¥ï¼Œéœ€è¦è®¡ç®—å‡ºæ¯ç§æœˆé¥¼çš„å•ä»·ï¼Œå†å¯¹å…¶è¿›è¡ŒæŽ’åºï¼ŒæŽ¥ç€æŒ‰ç…§é¢˜ç›®è¦æ±‚è®¡ç®—æ€»æ”¶ç›Šï¼Œæœ€åŽåœ¨è¾“å‡ºã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store; double sell; double price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; D -= cake[i].store; ans += cake[i].sell; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125; bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1021 ä¸ªä½æ•°ç»Ÿè®¡Analysisä»¥å­—ç¬¦ä¸²çš„å½¢å¼è¯»å…¥é¢˜ç›®ç»™å®šçš„æ•°å­—ï¼Œå†åˆ©ç”¨æ•£åˆ—çš„æ€æƒ³ï¼Œç»Ÿè®¡å„ä¸ªæ•°å­—å‡ºçŽ°çš„æ¬¡æ•°ï¼Œç»§è€Œè¾“å‡ºã€‚ Code123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 1005int main(int argc, char const *argv[]) &#123; char num[MAXN]; int i, digit[10]=&#123;0&#125;; scanf("%s", num); char *p; p = num; while(*p) &#123; digit[*p - '0']++; p++; &#125; for(i=0; i&lt;10; i++) &#123; if(digit[i] != 0) printf("%d:%d\n", i, digit[i]); &#125; return 0;&#125; 1022 Dè¿›åˆ¶çš„A+BAnalysisè¿›åˆ¶è½¬æ¢çš„å¸¸è§„é¢˜åž‹ï¼Œåˆ©ç”¨å–ä½™è¿ç®—èŽ·å–åˆ°è½¬æ¢è¿›åˆ¶çš„æ¯ä¸€ä½ï¼Œç„¶åŽä»Žé«˜ä½å¾€åœ°ä½è¾“å‡ºå³å¯ï¼Œæ³¨æ„è¾“å…¥0 0 8æ—¶ç‰¹åˆ¤ï¼Œè¾“å‡ºä¸º0ã€‚ Code1234567891011121314151617181920#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; long long A, B, D, digit[50] = &#123;0&#125;, count = 0; scanf("%lld %lld %lld", &amp;A, &amp;B, &amp;D); A += B; while(A) &#123; digit[count++] = A % D; A /= D; &#125; if(count) &#123; for(count--; count &gt;= 0; count--) &#123; printf("%d", digit[count]); &#125; &#125; else &#123; printf("0"); &#125; putchar('\n'); return 0;&#125; 1023 ç»„ä¸ªæœ€å°æ•°Analysisè¾“å‡ºç¬¬ä¸€ä¸ªæ•°å­—æ—¶ï¼Œä¸èƒ½è¾“å‡º0ï¼Œæ‰€ä»¥ç›´æŽ¥ä»Žæ•°å­—1å¼€å§‹éåŽ†ï¼Œå­˜åœ¨åˆ™è¾“å‡ºï¼Œç„¶åŽä¸ªæ•°å‡1ï¼Œå¹¶è·³å‡ºå¾ªçŽ¯ï¼›æŽ¥ç€åœ¨è¾“å‡ºå‰©ä¸‹çš„æ•°å­—ï¼Œæ­¤æ—¶0æ˜¯å¯ä»¥è¢«ç›´æŽ¥è¾“å‡ºçš„ï¼Œæ‰€ä»¥ä»Žæ•°å­—0å¼€å§‹éåŽ†ï¼ˆä¹Ÿæ˜¯ä»Žå°åˆ°å¤§çš„è§„å¾‹ï¼‰ï¼Œå°†æ¯ä¸€ä¸ªæ•°å­—å…¨éƒ¨è¾“å‡ºå®ŒåŽï¼Œå†å¼€å§‹è¾“å‡ºä¸‹ä¸€ä¸ªæ•°å­—ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int count[10] = &#123;0&#125;; for(int i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;count[i]); &#125; //print the first number for(int i = 1; i &lt; 10; i++) &#123; if(count[i]) &#123; printf("%d", i); count[i]--; break; &#125; &#125; //print the rest of numbers for(int i = 0; i &lt; 10; i++) &#123; while(count[i]) &#123; printf("%d", i); count[i]--; &#125; &#125; return 0;&#125; 1024 ç§‘å­¦è®¡æ•°æ³•Analysisé¢˜ç›®æ„æ€æ¯”è¾ƒæ˜Žç¡®ï¼Œç§‘å­¦è®°æ•°æ³•è½¬æ¢æˆæ­£å¸¸çš„æ•°å­—ï¼Œè¦æŠŠæŒ‡æ•°æå–å‡ºæ¥ï¼Œåœ¨æŒ‡æ•°ä¸ºæ­£ã€è´Ÿæˆ–é›¶æ—¶ï¼Œåˆ†åˆ«å¯¹åº”ä¸åŒçš„æƒ…å†µã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int Getexpon(char *s, int Epos);int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int count = 0, expo, Epos = 0, len = strlen(Num); for(; Num[Epos] != 'E'; Epos++); if(Num[0] == '-') putchar(Num[0]); expo = Getexpon(Num, Epos); if(expo &gt; 0) &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; Epos - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; Num[Epos] = '\0'; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; Epos; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125;int Getexpon(char *s, int Epos) &#123; int ret = 0, flag = 1, i = Epos + 1; if(s[i] == '-') &#123; flag = -1; &#125; i++; for(; s[i] != '\0'; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; return ret * flag;&#125; 1025 åè½¬é“¾è¡¨Analysisé¢˜ç›®å¤§æ„ï¼šç»™å®šä¸€ä¸ªå•é“¾è¡¨ï¼Œæ¯Kä¸ªç»“ç‚¹è¿›è¡Œé€†ç½®ï¼Œè‹¥æœ€åŽKä¸ªç»“ç‚¹ï¼Œåˆ™ä¸éœ€é€†ç½®ï¼Œè¾“å‡ºé€†ç½®åŽçš„é“¾è¡¨ã€‚ å¯¹å¾…æ­¤ç±»é¢˜ç›®ï¼Œè¿˜æ˜¯æ˜¯ä½¿ç”¨é™æ€é“¾è¡¨çš„æ€è·¯æ¥å¤„ç†ã€‚å…ˆé»˜è®¤ç»“æž„æ•°ç»„å†…çš„ç»“ç‚¹å…¨éƒ¨ä¸ºæ— æ•ˆç»“ç‚¹ï¼Œå†æŒ‰ç…§åœ°å€é€ä¸ªè¾“å…¥æ¯ä¸ªç»“ç‚¹ã€‚ç„¶åŽï¼Œåˆ©ç”¨ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€éåŽ†é“¾è¡¨ï¼Œå°†åˆæ³•ç»“ç‚¹çš„orderæ”¹ä¸ºé“¾è¡¨ç»“ç‚¹çš„é¡ºåºï¼Œå†åˆ©ç”¨sortå‡½æ•°å°†åˆæ³•ç»“ç‚¹å…¨éƒ¨æŒ‰åºæŽ’åœ¨ç»“æž„æ•°ç»„çš„å·¦ç«¯ï¼Œéžæ³•ç»“ç‚¹åˆ™åœ¨å³ç«¯ã€‚ ç´§æŽ¥ç€ï¼Œå¼€å§‹é€†ç½®è¾“å‡ºã€‚å¯¹äºŽå…·æœ‰nä¸ªåˆæ³•ç»“ç‚¹çš„é“¾è¡¨è€Œè¨€ï¼ŒæŒ‰ç…§kæ¥é€†ç½®ï¼Œåˆ™å…¶å¿…å¯è¢«åˆ†ä¸ºn / kä¸ªå­å—æ¥åˆ†åˆ«é€†ç½®ã€‚ç»§è€Œï¼Œç”±äºŽæ˜¯é€†ç½®ï¼Œæ‰€ä»¥éœ€è¦å°†æ¯ä¸€ä¸ªå­å—å€’ç€è¾“å‡ºã€‚ä½†è¿™ä¸€å—çš„æœ€åŽä¸€ä¸ªéœ€è¦è¾“å‡ºçš„ç»“ç‚¹éœ€è¦åˆ†å¼€è€ƒè™‘ï¼Œå› ä¸ºå…¶nextå·²ç»å˜æˆäº†ä¸‹ä¸€ä¸ªå—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹çš„åœ°å€äº†ã€‚é’ˆå¯¹è¿™ä¸ªç»“ç‚¹çš„ä½ç½®æœ‰ä¸‰ç§æƒ…å†µï¼š è‹¥å½“å‰è¾“å‡ºçš„å—ä¸æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œé‚£ä¹ˆå…¶nextå°±æ˜¯(i + 2) * K - 1ç»“ç‚¹ï¼ˆä¹Ÿå°±æ˜¯ä¸‹ä¸€ä¸ªæ•´å—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼‰çš„åœ°å€ è‹¥å½“å‰è¾“å‡ºçš„å—æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œä¸”æ˜¯æœ€åŽä¸€ä¸ªæ•´å—çš„æœ€åŽä¸€ä¸ªç»“ç‚¹ï¼Œé‚£ä¹ˆå…¶nextå³ä¸º-1 è‹¥å½“å‰è¾“å‡ºçš„å—æ˜¯æœ€åŽä¸€ä¸ªæ•´å—ï¼Œä½†å…¶åŽé¢è¿˜æœ‰å°äºŽKçš„ç»“ç‚¹ä¸ªæ•°ï¼Œæ‰€ä»¥å…¶nextæœ€åŽâ€œå°¾å·´â€çš„ç¬¬ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ï¼Œå³(i + 1) * Kå·ç»“ç‚¹ï¼Œç„¶åŽå†å°†å‰©ä½™ç»“ç‚¹è¾“å‡ºå³å¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node &#123; int address, data, next; int order;&#125; Node[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; init(); int n, k, head, address; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n ; i++) &#123; cin &gt;&gt; address; cin &gt;&gt; Node[address].data &gt;&gt; Node[address].next; Node[address].address = address; &#125; int count = 0, p = head; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) printf("-1\n"); else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1026 ç¨‹åºè¿è¡Œæ—¶é—´Analysisç»™å®šçš„æ˜¯æ•´æ•°ï¼Œä½†æ˜¯è¦æ±‚å››èˆäº”å…¥ï¼ŒåˆçŸ¥é¢˜ç›®ç»™å®šçš„é™¤æ•°æ˜¯ 100 ï¼Œç»™è¢«é™¤æ•°åŠ ä¸Š 50 åŽï¼Œå°±å¯ä»¥æ¨¡æ‹Ÿå‡ºå››èˆäº”å…¥çš„æ•ˆæžœã€‚ Code123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int c1, c2, c; scanf("%d %d", &amp;c1, &amp;c2); c = (c2 - c1 + 50) / 100; printf("%02d:%02d:%02d", c / 3600, c / 60 % 60, c % 60); return 0;&#125; 1027 æ‰“å°æ²™æ¼Analysisè¿™ç§æ‰“å°å›¾åƒçš„é¢˜ç›®ï¼Œéœ€è¦æ‰¾æ‰¾è§„å¾‹ã€‚ ä»¥æ ·ä¾‹ä¸ºä¾‹ï¼Œåªçœ‹å›¾åƒä¸€åŠï¼Œä»Žä¸­å¿ƒå¼€å§‹å‡ºå‘ï¼Œå°±æ˜¯$a_1 = 1, a_2 = 3, a_3 = 5$çš„ç­‰å·®æ•°åˆ—ï¼ŒæŒ‰ç…§è¿™ç§æ€è·¯çš„è¯ï¼Œéœ€è¦æ‰“å°çš„å›¾åƒå…¶å®žå°±æ˜¯ä¸¤ä¸ªç­‰å·®æ•°åˆ—ï¼Œåªä¸è¿‡ç¬¬äºŒä¸ªç­‰å·®æ•°åˆ—æ²¡æœ‰é¦–é¡¹ï¼Œåªæœ‰ä¸¤é¡¹$a_1 = 3, a_2 = 5$ï¼Œä½†è¿™å¹¶ä¸å½±å“è®¡ç®—ï¼Œå½“ä½œä¸¤ä¸ªç›¸åŒçš„ç­‰å·®æ•°åˆ—è®¡ç®—å¥½è™Žï¼Œå‡åŽ»å¤šä½™çš„éƒ¨åˆ†å³å¯ã€‚ ä»Žè€Œæœ‰ï¼š$2S_n - 1= 2 \times \frac{3 \times (1 + 5)}2 = 17$ï¼Œè¿™å°±æ˜¯éœ€è¦æ‰“å°å‡ºæ¥çš„ç¬¦å·æ•°é‡ï¼Œè€Œæ­¤æ—¶çš„å±‚æ•°ä¸º3ï¼ˆå…¶å®žä¹Ÿæ˜¯ç­‰å·®æ•°åˆ—çš„é¡¹æ•°ï¼‰ã€‚ ä¸‹é¢å†æ¥è¿›è¡Œè¾“å‡ºï¼Œæ³¨æ„æ¯è¡Œè¦å…ˆè¾“å‡ºç©ºæ ¼ï¼Œåœ¨è¾“å‡ºå­—ç¬¦ï¼Œæœ€åŽä¸€è¡Œè¾“å‡ºæœªä½¿ç”¨çš„å­—ç¬¦æ•°ã€‚ä½¿ç”¨ç»å¯¹å€¼ï¼Œèƒ½ç®€åŒ–ä¸€åŠçš„ä»£ç é‡ï¼Œçœ‹ç€å¾ˆæ¸…çˆ½~ Code123456789101112131415161718192021#include &lt;cstdio&gt;#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))int main(int argc, char const *argv[]) &#123; int N, layers; char c; scanf("%d %c", &amp;N, &amp;c); for(layers = 1; 2 * layers * layers - 1 &lt;= N; layers++); layers--; for(int i = 0; i &lt; 2 * layers - 1; i++) &#123; for(int j = 0; j &lt; layers - ABS(layers - i - 1) - 1; j++) &#123; putchar(' '); &#125; for(int k = 0; k &lt; 2 * ABS(layers - i - 1) + 1; k++) &#123; putchar(c); &#125; putchar('\n'); &#125; printf("%d\n", N - 2 * layers * layers + 1); return 0;&#125; 1028 äººå£æ™®æŸ¥Analysisè¿™é“é¢˜å¦‚ä½•åœ¨å¤„ç†æ—¥æœŸä¸Šé¢æ²¡æœ‰ç»éªŒçš„è¯ï¼Œå°±å¾ˆéš¾å—...ä¸€å¼€å§‹åœ¨åˆ¤æ–­æ—¥æœŸåˆæ³•æ€§çš„æ—¶å€™ï¼Œæƒ³åˆ°äº†å…¨éƒ¨è½¬åŒ–ä¸ºå¤©æ•°ï¼Œå…‰æ˜¯è½¬æ¢å¤©æ•°ï¼Œè¿˜æœ‰å¹³é—°å¹´çš„åŒºåˆ†ï¼Œæ„Ÿè§‰åˆæ˜¯ä¸€é“é¢˜äº†ðŸ¤”ï¼Œè¿™åº”è¯¥ä¸æ˜¯å§¥å§¥æƒ³è®©ç­”é¢˜è€…å¹²çš„æ´»ã€‚äº‹å®žè¯æ˜Žï¼Œç¡®å®žæƒ³æ­ªäº†ðŸ˜‚ï¼Œå¯¹äºŽè¿™ç±»æ—¥æœŸçš„åˆ¤æ–­ï¼Œä»Žå¹´è¿™ä¸ªæ•°å­—å¼€å§‹é€ä¸ªè¿›è¡Œæ¯”è¾ƒå³å¯ï¼ˆå‚è€ƒä¸‹é¢çš„ä»£ç ï¼‰ï¼ŒåŒæ—¶æ³¨æ„ä¸è¦ç”¨if-elseæ¥å¾—åˆ°æœ€å¹´é•¿å’Œå¹´è½»çš„äººå°±å¥½ï¼Œè¦åˆ†å¼€åˆ¤æ–­ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;struct citizen&#123; int year, month, day; char name[7];&#125; youngest, oldest, left, right, temp;void Init();bool Less(citizen a, citizen b);bool More(citizen a, citizen b);int main(int argc, char const *argv[]) &#123; Init(); int N, valid = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d/%d/%d", temp.name, &amp;temp.year, &amp;temp.month, &amp;temp.day); if(Less(temp, right) &amp;&amp; More(temp, left)) &#123; valid++; if(More(temp, youngest)) &#123; youngest = temp; &#125; if(Less(temp, oldest)) &#123; oldest = temp; &#125; &#125; &#125; if(valid) &#123; printf("%d %s %s\n", valid, oldest.name, youngest.name); &#125; else &#123; printf("0\n"); &#125; return 0;&#125;void Init() &#123; left.year = youngest.year = 1814; right.year = oldest.year = 2014; youngest.month = oldest.month = left.month = right.month = 9; youngest.day = oldest.day = left.day = right.day = 6;&#125;bool Less(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &lt;= b.year; else if(a.month != b.month) return a.month &lt;= b.month; else return a.day &lt;= b.day;&#125;bool More(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &gt;= b.year; else if(a.month != b.month) return a.month &gt;= b.month; else return a.day &gt;= b.day;&#125; 1029 æ—§é”®ç›˜AnalysiséåŽ†å­—ç¬¦ä¸²ï¼Œæ‰¾å‡ºç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°è¿‡ï¼Œä½†ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­æœªå‡ºçŽ°çš„å­—ç¬¦å³å¯ï¼Œå­—æ¯ä¸åŒºåˆ†å¤§å°å†™ï¼Œä½†å­—ç¬¦ä¸²å†…æœ‰ç©ºæ ¼å’Œæ•°å­—ï¼Œç”¨_è¡¨ç¤ºï¼Œæ³¨æ„ä¸èƒ½è¾“å‡ºå°å†™å­—æ¯ï¼Œä¸”é‡å¤çš„å­—ç¬¦åªè¾“å‡ºä¸€æ¬¡ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cctype&gt;void levelup(char *str);int main(int argc, char const *argv[]) &#123; char str1[85], str2[85], Result[30]; scanf("%s %s", str1, str2); levelup(str1); levelup(str2); int count = 0; for(int i = 0; str1[i] != '\0'; i++) &#123; char temp = str1[i]; bool flag = true; for(int j = 0; str2[j] != '\0'; j++) &#123; if(temp == str2[j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; int k = 0; for(k = 0; k &lt; 30; k++) &#123; if(temp == Result[k]) &#123; break; &#125; &#125; if(k == 30) &#123; Result[count++] = temp; &#125; &#125; &#125; Result[count] = '\0'; puts(Result); return 0;&#125;void levelup(char *str) &#123; char *p = str; while(*p != '\0') &#123; if(islower(*p)) &#123; *p = toupper(*p); &#125; p++; &#125;&#125; 1030 å®Œç¾Žæ•°åˆ—Analysisé¢˜ç›®å¤§æ„æ˜¯ç»™ä¸€å †æ•°å­—ï¼Œè¿™äº›æ•°å­—ä»¥ä»»æ„ä¸ªæ•°å’Œé¡ºåºç»„æˆåºåˆ—ï¼Œä½¿å¾—è¿™ä¸ªæ•°åˆ—çš„æœ€å¤§ã€æœ€å°å€¼å­˜åœ¨è¿™æ ·çš„å…³ç³»ï¼š$M\ \le\ m \times p$ï¼Œå¹¶è¦æ±‚è¿™ä¸ªæ•°åˆ—åŒ…å«çš„æ•°å­—æ•°é‡è¦å°½å¯èƒ½çš„å¤šã€‚ çœ‹åˆ°é¢˜ç›®ä¸€èˆ¬ä¼šæƒ³åˆ°å…ˆå°†åºåˆ—æŽ’åºï¼Œç„¶åŽæ‰¾å‡ºå…¶ä¸­çš„æœ€å¤§å€¼ï¼Œå†ä»Žå°åˆ°å¤§æžšä¸¾æ¯ä¸€ä¸ªæ•°å­—ï¼Œç›´åˆ°ä¸æ»¡è¶³å…³ç³»æ—¶ï¼Œé€€å‡ºå¾ªçŽ¯ï¼Œä¸‹æ ‡ä¹‹å·®å³æ˜¯ç»“æžœã€‚ä½†è¿™å®žé™…ä¸ŠåªæŠŠé¢˜ç›®çš„è¾“å…¥æ•°æ®å½“ä½œäº†ä¸€ä¸ªæ•°åˆ—å¤„ç†ï¼ˆæ­¤æ—¶æäº¤å¯å¾—20åˆ†ï¼‰ã€‚è‹¥è¿™ä¸ªæ•°åˆ—è¿˜å­˜åœ¨æ¯”$m \times p$å°çš„æ•°ï¼ŒæŒ‰ç…§è¿™æ ·çš„æ€è·¯å°±æ— æ³•è®©æ•°å­—æ•°é‡å¢žåŠ äº†ï¼ˆå› ä¸ºæœ€å¤§å€¼å·²ç»é™å®šäº†ï¼‰ã€‚ ç»§ç»­æ·±å…¥æ€è€ƒï¼Œå¯¹æœ‰åºåºåˆ—è€Œè¨€ï¼ŒæŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œå°±éœ€è¦ä»¥å½“å‰æ•°å­—ä¸ºå·¦ç«¯ç‚¹ï¼Œç„¶åŽæ‰¾åˆ°ç¬¦åˆè¦æ±‚çš„æœ€å¤§çš„å³ç«¯ç‚¹å€¼ï¼ˆæ­¤æ—¶è¿™ä¸ªå³ç«¯ç‚¹å€¼çš„ä¸‹æ ‡æœ€å¤§ï¼Œä¸‹æ ‡å·®è¶Šå¤§ï¼Œæ•°å­—æ•°é‡å°±è¶Šå¤šï¼‰ã€‚æŒ‰ç…§è¿™æ ·çš„æ€è·¯ä¾æ¬¡æžšä¸¾æ¯ä¸ªæ•°å­—å°±å¯ä»¥å¾—åˆ°æœ€ç»ˆç»“æžœï¼Œæ­¤ç®—æ³•çš„æ—¶é—´å¤æ‚åº¦ä¸º$O(n)$ã€‚ å¦‚ä½•èƒ½å°†æŸ¥æ‰¾å³ç«¯ç‚¹å€¼è¿‡ç¨‹ç¼©çŸ­ä¸€ç‚¹å‘¢ï¼Ÿæ³¨æ„åˆ°æ•°ç»„å·²ç»è¢«æŽ’å¥½åºäº†ï¼Œæ‰€ä»¥å¯ä»¥ä½¿ç”¨äºŒåˆ†æŸ¥æ‰¾æ¥åšè¿™ä»¶äº‹ã€‚æ­¤æ—¶ï¼Œé—®é¢˜å°±æ¼”å˜ä¸ºï¼šä»Žä¸€ä¸ªæ•°çš„åŽé¢æ‰€æœ‰æ•°ä¸­ï¼Œæ‰¾å‡ºåˆšå¥½æ»¡è¶³ $M\ \le\ m \times p$ è¿™ä¸ªæ¡ä»¶çš„æ•°å­—ï¼Œå…¶ä¸­$M$å’Œ$m$åˆ†åˆ«ä¸ºç¬¬ä¸€ä¸ªæ•°å­—ä¸ŽæŸ¥æ‰¾åˆ°çš„æ•°å­—ç»„æˆçš„æ•°åˆ—çš„æœ€å¤§å’Œæœ€å°å€¼ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, (long long)Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1031 æŸ¥éªŒèº«ä»½è¯Analysisé¢˜ç›®ä¸éš¾ï¼Œå°±æ˜¯è¦è®¤çœŸè¯»é¢˜ï¼Œæ ¹æ®é¢˜ç›®è¦æ±‚è¿›è¡Œè®¡ç®—å³å¯ï¼Œåˆ«é©¬è™Žï¼Œåˆ«å¿˜è®°æ•°å­—æ˜¯å¯ä»¥ç”¨Xè¡¨ç¤ºçš„ï¼Œè¿™ä¸ªè¦åŒºåˆ†ä¸€ä¸‹ã€‚ Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;char Comparison_Table[12] = &#123;'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'&#125;;int Weight_Table[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;int main(int argc, char const *argv[])&#123; char ID_Number[19]; int N, flag = 1; scanf("%d", &amp;N); while(N--) &#123; scanf("%s", ID_Number); char *p = ID_Number; int i, Digit_Sum = 0, Check_value; for(i=0; i&lt;17; i++, p++) &#123; if(*p == 'X') Digit_Sum += (10 * Weight_Table[i]); else Digit_Sum += ((*p - '0') * Weight_Table[i]); &#125; Check_value = Digit_Sum % 11; char Check_code = Comparison_Table[Check_value]; if(Check_code == ID_Number[17]) continue; else&#123; printf("%s\n", ID_Number); flag = 0; &#125; &#125; if(flag) printf("All passed\n"); return 0;&#125; 1032 æŒ–æŽ˜æœºæŠ€æœ¯å“ªå®¶å¼ºAnalysisè¿™é“é¢˜å¾ˆç®€å•ï¼Œç”¨æ•°ç»„ç®€å•æ¨¡æ‹Ÿä¸€ä¸‹å°±å¥½äº†ï¼Œæ³¨æ„æœ€åŽä¸€ä¸ªå¤§æ•°æ®çš„æµ‹è¯•ç‚¹ã€‚ Code12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 100005int main(int argc, char const *argv[]) &#123; int i, Num, Max = 0, N, School_Num[MAXN] = &#123;0&#125;, temp; scanf("%d", &amp;N); while(N--) &#123; scanf("%d %d", &amp;Num, &amp;temp); School_Num[Num] += temp; &#125; for(i = 0; i &lt; MAXN; i++) &#123; if(Max &lt; School_Num[i]) &#123; Num = i; Max = School_Num[i]; &#125; &#125; printf("%d %d\n", Num, Max); return 0;&#125; 1033 æ—§é”®ç›˜æ‰“å­—Analysisä¸Ž1029æ­£å¥½ç›¸åçš„ä¸€é“é¢˜ç›®ï¼Œè¦æ³¨æ„çš„ç‚¹ï¼š ä¸åŒºåˆ†å¤§å°å†™ï¼Œåªè¦æ˜¯ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å‡ºçŽ°è¿‡çš„å­—æ¯ï¼Œç¬¬äºŒä¸ªå­—ç¬¦ä¸²åœ¨è¾“å‡ºæ—¶ï¼Œæ— è®ºå¤§å°å†™ï¼Œéƒ½ä¸èƒ½è¾“å‡º ä¸Šæ¡£é”®åäº†ï¼Œå°½ç®¡æŸä¸ªå­—æ¯æŒ‰é”®æ²¡åï¼Œä½†æ˜¯ä¹Ÿä¸èƒ½è¾“å‡ºè¿™ä¸ªå­—æ¯çš„å¤§å†™äº† ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¯èƒ½æ˜¯ç©ºä¸² Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; bool brokenkey[128] = &#123;false&#125;; fgets(str2, MAXN, stdin); fgets(str1, MAXN, stdin); for(int i = 0; str2[i] != '\0'; i++) &#123; brokenkey[str2[i]] = true; if(islower(str2[i])) &#123; brokenkey[str2[i] - 32] = true; &#125; else if(isupper(str2[i])) &#123; brokenkey[str2[i] + 32] = true; &#125; &#125; for(int i = 0; str1[i] != '\0'; i++) &#123; if(!brokenkey[str1[i]]) &#123; if(isupper(str1[i]) &amp;&amp; brokenkey['+']) &#123; continue; &#125; printf("%c", str1[i]); &#125; &#125; return 0;&#125; 1034 æœ‰ç†æ•°è¿ç®—Analysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®š2ä¸ªa/bå½¢å¼çš„åˆ†æ•°ï¼Œaä¸ºåˆ†å­ï¼Œbä¸ºåˆ†æ¯ï¼Œæ±‚è¿™2ä¸ªåˆ†æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ï¼Œå†è¾“å‡ºã€‚ ç»™å®šçš„åˆ†æ•°åªæœ‰ä¸¤ç§æƒ…å†µï¼ˆå½¢å¼ä¸Šï¼‰ï¼šçœŸåˆ†æ•°å’Œå‡åˆ†æ•°ï¼Œä¸å­˜åœ¨å¸¦åˆ†æ•°ï¼Œä½†è¾“å‡ºè¦è¾“å‡ºå¸¦åˆ†æ•°ï¼Œå¹¶ä¸”æ˜¯æœ€ç®€å½¢å¼ã€‚åŒ–ç®€çš„ç›®çš„å…¶å®žé¢˜ç›®è€ƒå¯Ÿæ±‚æœ€å¤§å…¬çº¦æ•°ï¼Œåˆ©ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•å³å¯æ±‚å¾—ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ æ³¨æ„ï¼š é™¤æ•°ä¸º0æ—¶ï¼Œéœ€è¦è¾“å‡ºInf è´Ÿæ•°éœ€è¦ä½¿ç”¨()æ‹¬èµ·æ¥ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Fraction &#123; ll up, down;&#125; f1, f2;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void printResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;f1.up, &amp;f1.down, &amp;f2.up, &amp;f2.down); //add printResult(f1); printf(" + "); printResult(f2); printf(" = "); printResult(Add(f1, f2)); putchar('\n'); //minu printResult(f1); printf(" - "); printResult(f2); printf(" = "); printResult(Minu(f1, f2)); putchar('\n'); //mult printResult(f1); printf(" * "); printResult(f2); printf(" = "); printResult(Mult(f1, f2)); putchar('\n'); //divide printResult(f1); printf(" / "); printResult(f2); printf(" = "); if(f2.up == 0) printf("Inf"); else printResult(Divide(f1, f2)); return 0;&#125; 1035 æ’å…¥ä¸Žå½’å¹¶Analysisé¢˜ç›®çš„æ„æ€æ¯”è¾ƒæ˜Žç¡®ï¼Œç»™å®šä¸¤ä¸ªåºåˆ—ï¼Œåˆ¤æ–­å±žäºŽå“ªä¸€ç§æŽ’åºï¼Œç„¶åŽè¾“å‡ºè¿™ä¸ªåºåˆ—åœ¨è¿™ç§æŽ’åºä¸‹çš„ä¸‹ä¸€è½®æŽ’åºç»“æžœã€‚ å¯¹ç»™å®šçš„åˆå§‹åºåˆ—ï¼ŒæŒ‰ç…§æ’å…¥æŽ’åºçš„è¿‡ç¨‹è¿›è¡Œæ¨¡æ‹Ÿï¼Œæ¯è½®æŽ’åºéƒ½ä¸Žç»™å®šçš„ä¸­é—´åºåˆ—è¿›è¡Œæ¯”è¾ƒï¼Œå¦‚æžœç›¸åŒå°±å±žäºŽInsertion Sortï¼Œå¦åˆ™å°±æ˜¯Merge Sortäº†ã€‚ åœ¨æ•´ä¸ªæŽ’åºå’Œæ¯”è¾ƒçš„è¿‡ç¨‹ä¸­ï¼Œå…ˆè¿›è¡Œæ¯”è¾ƒï¼Œåœ¨éœ€è¦è¾“å‡ºçš„æ—¶å€™å°±ä¸éœ€è¦å†è¿›è¡Œä¾æ¬¡æŽ’åºæ“ä½œï¼Œå¯ä»¥å‡å°‘ä¸€éƒ¨åˆ†çš„ä»£ç é‡ã€‚å¦å¤–ï¼Œä½¿ç”¨sortå‡½æ•°æ¥æ¨¡æ‹Ÿå½’å¹¶æŽ’åºçš„è¿‡ç¨‹ï¼Œè¦æ³¨æ„sortå‡½æ•°æ¯æ¬¡åªèƒ½æŽ’åˆ¶å®šé—´éš”å†…çš„æ•°å­—ã€‚æ‰€ä»¥é‡‡ç”¨min(i + step, n)çš„å†™æ³•é¿å…æœ€åŽä¸€æ¬¡æŽ’åºæ—¶å…ƒç´ ä¸ªæ•°ä½ŽäºŽå½’å¹¶é—´éš”çš„æƒ…å†µï¼Œå³å†æœ€åŽä¸€æ¬¡æŽ’åºè¿‡ç¨‹ä¸­ï¼ŒåªæŽ’å‰©ä¸‹çš„å…ƒç´ ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 5;int origin[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125; putchar('\n');&#125;bool InsertSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag == true) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;origin[i]); tempOri[i] = origin[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = origin[i]; &#125; MergeSort(); &#125; return 0;&#125; 1036 è·Ÿå¥¥å·´é©¬ä¸€èµ·ç¼–ç¨‹Analysisè¿™ç§æ‰“å°å›¾å½¢ç±»çš„é¢˜ç›®ä¸»è¦æ˜¯åœ¨æ‰¾è¾“å‡ºçš„ä½ç½®ï¼Œæ³¨æ„é¢˜ç›®ç»™å®šçš„æ˜¯å­—ç¬¦å˜é‡Cï¼Œè€Œä¸æ˜¯Cå­—ç¬¦ã€‚ Code12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N, i, j; char C; scanf("%d %c", &amp;N, &amp;C); /*actually, you just need to find the place you want print */ for(i=0; i&lt;(N+1)/2; i++) &#123; for(j=0; j&lt;N; j++) &#123; if(i==0 || i==(N-1)/2 || j==0 || j==N-1) putchar(C); else putchar(' '); &#125; putchar('\n'); &#125; return 0;&#125; 1037 åœ¨éœæ ¼æ²ƒèŒ¨æ‰¾é›¶é’±Analysisé¢˜ç›®æ„æ€å¾ˆç›´è§‚å°±æ˜¯æ‰¾é›¶é’±äº†ï¼Œåªä¸è¿‡åº¦é‡å•ä½ä¸ä¸€æ ·ï¼Œåœ¨è®¡ç®—çš„æ—¶å€™ï¼ŒæŒ‰ç…§ç»™å®šçš„é‡è¿›è¡Œè®¡ç®—å³å¯ã€‚æ³¨æ„ç”±äºŽï¼Œæœ¬é¢˜ä¸­é’±çš„å½¢å¼æœ‰ä¸‰æ ·ï¼Œæ‰€ä»¥åœ¨è®¡ç®—å‰å¾—å…ˆåˆ¤æ–­å¤§å°ï¼Œç„¶åŽè®©å¤§çš„å‡å°çš„ï¼Œè¿™æ ·è®¡ç®—èµ·æ¥å°±å¾ˆç®€å•äº†ï¼›å¦å¤–ï¼Œç›¸ç­‰çš„æ—¶å€™è¦ç‰¹åˆ¤è¾“å‡º0.0.0ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;struct money &#123; int g, s, k;&#125; P, A, Result;bool Bigger(money a, money b);money Substract(money big, money small);int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;P.g, &amp;P.k, &amp;P.s, &amp;A.g, &amp;A.k, &amp;A.s); if(Bigger(P, A)) &#123; Result = Substract(P, A); if(!Result.g &amp;&amp; !Result.k &amp;&amp; !Result.s) printf("0.0.0\n"); else printf("-%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; else &#123; Result = Substract(A, P); printf("%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; return 0;&#125;bool Bigger(money a, money b) &#123; if(a.g != b.g) return a.g &gt;= b.g; else if(a.k != b.k) return a.k &gt;= b.k; else return a.s &gt;= b.s;&#125;money Substract(money big, money small) &#123; money ret; if(big.s &gt;= small.s) &#123; ret.s = big.s - small.s; &#125; else &#123; ret.s = big.s + 29 - small.s; big.k--; &#125; if(big.k &gt;= small.k) &#123; ret.k = big.k - small.k; &#125; else &#123; ret.k = big.k + 17 - small.k; big.g--; &#125; ret.g = big.g - small.g; return ret;&#125; 1038 ç»Ÿè®¡åŒæˆç»©å­¦ç”ŸAnalysisè€ƒå¯ŸåŸºæœ¬æ•£åˆ—çš„æ€æƒ³ï¼Œå°†è¾“å…¥çš„åˆ†æ•°å€¼ä½œä¸ºæ•°ç»„ä¸‹æ ‡ï¼Œæ¯æ¬¡æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦å°±å˜ä¸ºäº†ï¼š$O(1)$ã€‚ Code123456789101112131415161718#include &lt;cstdio&gt;int grade[101] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int N, K, temp; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;temp); grade[temp]++; &#125; scanf("%d", &amp;K); while(K--) &#123; scanf("%d", &amp;temp); printf("%d", grade[temp]); if(K &gt; 0) putchar(' '); &#125; return 0;&#125; 1039 åˆ°åº•ä¹°ä¸ä¹°Analysiså°†å­—ç¬¦å¸¸é‡ä½œä¸ºä¸‹æ ‡æ•£åˆ—åœ¨ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ä¸­ï¼Œå°±å¯ä»¥å¾ˆæ–¹ä¾¿çš„ç»Ÿè®¡ç å­çš„ä¸ªæ•°äº†ã€‚ä¹°ä¸Žä¸ä¹°å¯¹åº”ä¸¤ç§æƒ…å†µï¼š ä¹°ï¼Œå¤šä½™çš„ç å­æ•°ç›®å°±æ˜¯ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦ä¹‹å·® ä¸ä¹°ï¼ŒéåŽ†ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ï¼Œæ‰¾åˆ°ç¬¬äºŒä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°æ¬¡æ•°æ¯”ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²ä¸­å‡ºçŽ°æ¬¡æ•°å¤šçš„å­—ç¬¦ï¼Œå¹¶è®°å½•ä¸‹å…¶å·®å€¼ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1040 æœ‰å‡ ä¸ªPATAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªåªå«Pã€Aã€Tä¸‰ä¸ªå­—æ¯çš„å­—ç¬¦ä¸²ï¼ŒæŒ‰ç…§PATçš„é¡ºåºï¼Œåœ¨ä¸æ”¹å˜å­—ç¬¦ä¸²å†…å­—ç¬¦æŽ’åˆ—é¡ºåºçš„å‰æä¸‹ï¼Œæœ€å¤šèƒ½æœ‰å‡ ä¸ªPATè¿™æ ·çš„å­ä¸²ã€‚ æŒ‰ç…§é¢˜ç›®è¦æ±‚ï¼Œæœ€å®¹æ˜“æƒ³åˆ°çš„æ€è·¯å°±æ˜¯åˆ©ç”¨ä¸‰ä¸ªå¾ªçŽ¯æš´åŠ›æžšä¸¾æ‰€æœ‰å¯èƒ½çš„å‡ºçŽ°æƒ…å†µï¼Œç„¶åŽç»Ÿè®¡ç¬¦åˆè¦æ±‚çš„æƒ…å†µï¼Œæœ€åŽåœ¨è¾“å‡ºã€‚ä½†è¿™æ ·ä¼šè¶…æ—¶ï¼Œæ‰€ä»¥éœ€è¦æ¢ä¸ªæ€è·¯ã€‚ å¯¹äºŽå­—ç¬¦ä¸²ä¸­ç¡®å®šä½ç½®çš„æ¯ä¸€ä¸ªAè€Œè¨€ï¼Œå…¶èƒ½å¤Ÿä¸ŽPã€Tç»„æˆPATçš„ä¸ªæ•°ï¼Œç­‰äºŽå…¶å·¦è¾¹Pçš„ä¸ªæ•°ä¹˜ä»¥å…¶å³è¾¹Tçš„ä¸ªæ•°ã€‚é‚£ä¹ˆï¼Œè¿™ä¸ªé—®é¢˜å°±å˜æˆäº†ï¼ŒéåŽ†å­—ç¬¦ä¸²æ—¶ï¼Œç´¯åŠ æ¯ä¸€ä¸ªAçš„å·¦è¾¹Pçš„ä¸ªæ•°ä¸Žå³è¾¹Tçš„ä¸ªæ•°çš„ä¹˜ç§¯ã€‚ é‚£ä¹ˆï¼Œå¦‚ä½•æ‰èƒ½è¾ƒå¿«çš„èŽ·å¾—Pçš„ä¸ªæ•°å‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•°ç»„ä¸€æ¬¡æ€§è®¡ç®—å‡ºå­—ç¬¦ä¸²ä¸­æ¯ä¸€ä¸ªå­—ç¬¦ä¸²å·¦è¾¹Pçš„ä¸ªæ•°ã€‚ç›´æŽ¥ä»Žå·¦è‡³å³éåŽ†å­—ç¬¦ä¸²ï¼Œå¦‚æžœå½“å‰ä½æ˜¯Pï¼Œé‚£ä¹ˆæ­¤ä½ç½®çš„æ•°ç›®å°±æ˜¯å‰ä¸€ä½çš„æ•°ç›®åŠ 1ï¼›å¦‚æžœå½“å‰ä½ä¸æ˜¯Pï¼Œé‚£ä¹ˆæ­¤ä½ç½®çš„æ•°ç›®å°±æ˜¯å‰ä¸€ä½çš„æ•°ç›®ã€‚ è§£å†³äº†Pçš„é—®é¢˜ï¼ŒTæ€Žä¹ˆåŠžå‘¢ï¼Ÿå®šä¹‰ä¸€ä¸ªå˜é‡ï¼Œä»Žå³å¾€å·¦éåŽ†å­—ç¬¦ä¸²ï¼ŒçŽ°åœ¨åªè€ƒè™‘ä¸¤ç§æƒ…å†µï¼š å½“å‰å­—ç¬¦ä¸ºTï¼Œå˜é‡åŠ 1 å½“å‰å­—ç¬¦ä¸ºAï¼Œç»Ÿè®¡æ­¤ä½ç½®Aèƒ½ç»„æˆçš„å­ä¸²PATçš„æ•°ç›®ï¼ˆè®¡ç®—æ—¶åˆ«å¿˜äº†å–ä½™ï¼‰ï¼Œå†ç´¯åŠ  éåŽ†ç»“æŸåŽï¼Œå°±å¯ä»¥ç›´æŽ¥è¾“å‡ºæ€»æ•°ç›®äº†ã€‚ Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt; const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') &#123; leftNumP[i]++; &#125; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt;= 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 è€ƒè¯•åº§ä½å·Analysisç”±äºŽæœ€åŽè¦è¾“å‡ºå‡†è€ƒè¯å·ï¼Œæ‰€ä»¥æ¯æ¬¡è¾“å…¥éƒ½å¿…é¡»ä¿å­˜è¾“å…¥çš„å‡†è€ƒè¯å·ç­‰ä¿¡æ¯ã€‚è¿™æ ·çš„è¯ï¼Œä½¿ç”¨ç»“æž„ä½“æ•°ç»„æ— ç–‘æ˜¯ä¸€ç§å¾ˆæ–¹ä¾¿çš„é€‰æ‹©ï¼Œä¹‹åŽå†éåŽ†ç»“æž„ä½“æ•°ç»„è¾“å‡ºç¬¦åˆæ¡ä»¶çš„ä¿¡æ¯å³å¯ï¼Œ Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct examinee_info&#123; char number[17]; int test_seat; int exam_seat;&#125; Examinee_Info[1005];int main(int argc, char const *argv[]) &#123; int N, M, i, temp; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", Examinee_Info[i].number, &amp;Examinee_Info[i].test_seat, &amp;Examinee_Info[i].exam_seat); &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;temp); for(i = 0; i &lt; N; i++) &#123; if(temp == Examinee_Info[i].test_seat) &#123; printf("%s %d\n", Examinee_Info[i].number, Examinee_Info[i].exam_seat); &#125; &#125; &#125; return 0;&#125; 1042 å­—ç¬¦ç»Ÿè®¡Analysisåˆ©ç”¨æ•°ç»„ç»Ÿè®¡æ¯ä¸ªè‹±æ–‡å­—ç¬¦ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰çš„å‡ºçŽ°æ¬¡æ•°ï¼Œç›´æŽ¥ä½¿ç”¨å­—ç¬¦å˜é‡ï¼ˆASCIIç å€¼ï¼‰ä½œä¸ºä¸‹æ ‡ä¼šå¾ˆæ–¹ä¾¿ï¼ŒåŒæ—¶å¾—åˆ°å‡ºçŽ°çš„æœ€å¤§æ¬¡æ•°ã€‚è¾“å‡ºæ—¶ï¼ŒéåŽ†ç»Ÿè®¡æ¬¡æ•°çš„æ•°ç»„ï¼Œåªè¾“å‡ºå­—å…¸åºæœ€å°çš„å­—æ¯å³å¯ã€‚ Code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 1000 + 5;int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); int times[27] = &#123;0&#125;, maxtimes = -1; for(int i = 0; str[i] != '\0'; i++) &#123; char c1 = str[i]; if(isalpha(c1)) &#123; if(isupper(c1)) c1 = tolower(c1); times[c1 - 'a']++; if(times[c1 - 'a'] &gt; maxtimes) &#123; maxtimes = times[c1 - 'a']; &#125; &#125; &#125; for(int i = 0; i &lt; 27; i++) &#123; if(maxtimes == times[i]) &#123; printf("%c %d\n", i + 'a', times[i]); break; &#125; &#125; return 0;&#125; 1043 è¾“å‡ºPATestAnalysiså…ˆç»Ÿè®¡å­—ç¬¦ä¸²ä¸­PATestè¿™å…­ä¸ªå­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼Œç„¶åŽä¾æ¬¡è¾“å‡ºPATestï¼Œæ³¨æ„å½“å…¶ä¸­æŸä¸ªå­—ç¬¦è¾“å‡ºå®ŒåŽï¼Œä»ç„¶è¦ä¿æŒPATestè¿™ä¸ªé¡ºåºæ¥è¾“å‡ºå­—ç¬¦ã€‚ Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int MAXN = 10000 + 5;char PATest[10] = "PATest";int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['P'] || times['A'] || times['T'] || times['e'] || times['s'] || times['t']) &#123; for(p = PATest; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1044 ç«æ˜Ÿæ•°å­—Analysisé¢˜ç›®ç»™å‡ºäº†ç«æ˜Ÿä¸Šçš„æ•°ä½è§„åˆ™ï¼Œè¦æ±‚å°†åè¿›åˆ¶æ•°è½¬æ¢ä¸ºç«æ˜Ÿæ•°å­—å¹¶è¾“å‡ºã€‚å°½ç®¡ç«æ˜Ÿä¸Šæ¯ä¸€ä½æ•°è¾“å‡ºçš„å½¢å¼ä¸ä¸€æ ·ï¼Œä½†å…¶æœ¬è´¨æ˜¯13è¿›åˆ¶çš„ï¼Œæ‰€ä»¥æŒ‰ç…§è¿™ä¸ªè§„åˆ™è¿›è¡Œå³å¯ã€‚ ç”±äºŽæ•´ä¸ªèŒƒå›´çš„æ•°å­—æœ‰169ä¸ªï¼Œæ‰€ä»¥æå‰å°†æ‰€æœ‰éœ€è¦è¾“å‡ºçš„æ•°å­—å…¨éƒ¨æ‰“å°å¥½ï¼Œä¹‹åŽç›´æŽ¥è¾“å‡ºæ¯”è¾ƒå¥½ã€‚ä¸ºæ­¤ï¼Œéœ€è¦å€ŸåŠ© C++ çš„stringå’Œmapï¼Œæ¥åˆ†åˆ«å»ºç«‹æ•°å­—å¯¹åº”å­—ç¬¦ä¸²ã€å­—ç¬¦ä¸²å¯¹åº”æ•°å­—çš„æ˜ å°„æ•°ç»„ã€‚ æ³¨æ„ï¼šè¾“å…¥13æ—¶ï¼Œéœ€è¦è¾“å‡ºtamï¼Œè€Œä¸æ˜¯tam tretã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const *argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); //get the extra ' ' from stdin while(n--) &#123; string s; getline(cin, s); if('0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; s.length(); i++) &#123; num = num * 10 + s[i] - '0'; &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[s] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; //string concatenation string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1045 å¿«é€ŸæŽ’åºAnalysisé¢˜ç›®çš„èƒŒæ™¯æ˜¯å¿«é€ŸæŽ’åºç®—æ³•å†…çš„ä¸€äº›æ¦‚å¿µï¼Œå·²ç»ç»™å‡ºäº†æè¿°ï¼Œæ‰€ä»¥ä¸å½±å“è¯»é¢˜ã€‚ä¾æ®é¢˜ç›®çš„ä¾‹å­ï¼Œå¯ä»¥å¾—åˆ°ä¸»å…ƒçš„ç‰¹ç‚¹ï¼š ä¸»å…ƒå·¦è¾¹çš„æ•°å­—å…¨éƒ¨æ¯”å®ƒå°ï¼Œå³æœ€å¤§å€¼å°äºŽå®ƒ ä¸»å…ƒå³è¾¹çš„æ•°å­—å…¨éƒ¨æ¯”å®ƒå¤§ï¼Œå³æœ€å°å€¼å¤§äºŽå®ƒ æŒ‰ç…§ä¸Šè¿°åˆ†æžï¼Œä¾æ¬¡æžšä¸¾æ•°ç»„å†…æ¯ä¸€ä¸ªå…ƒç´ ï¼Œå¦‚æžœæ¯æ¬¡éƒ½åŽ»æŸ¥æ‰¾å½“å‰å…ƒç´ çš„æœ€å€¼ï¼Œä¼šå¾ˆè€—æ—¶é—´ã€‚æ‰€ä»¥ï¼Œè¦æ¢ä¸€ä¸ªè§’åº¦åŽ»æ€è€ƒé—®é¢˜ã€‚ å®šä¹‰ä¸€ä¸ªæ•°ç»„ï¼Œä¸€æ¬¡æ€§å°†æ‰€æœ‰æ•°å­—å·¦è¾¹çš„æœ€å°å€¼å…¨éƒ¨è®¡ç®—å‡ºæ¥ï¼Œæ¯æ¬¡æžšä¸¾æ—¶ï¼Œå°±åªç”¨å’Œå‰ä¸€ä¸ªæ•°å­—æœ€å·¦è¾¹çš„æœ€å°å€¼è¿›è¡Œæ¯”è¾ƒï¼Œæ‰¾æœ€å¤§å€¼æ—¶åŒç†ã€‚ æœ€åŽåœ¨éåŽ†ä¸€æ¬¡æ•°ç»„ï¼Œæ‰¾å‡ºç¬¦åˆæ¡ä»¶çš„æ•°åŽç›´æŽ¥è¾“å‡ºå³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;const int INF = 0x3fffffff;int array[MAXN], leftMax[MAXN], rightMin[MAXN];int ans[MAXN], num = 0;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftMax[0] = 0; for(int i = 1; i &lt; N; i++) &#123; leftMax[i] = max(leftMax[i - 1], array[i - 1]); &#125; rightMin[N - 1] = INF; for(int i = N - 2; i &gt;= 0; i--) &#123; rightMin[i] = min(rightMin[i + 1], array[i + 1]); &#125; for(int i = 0; i &lt; N; i++) &#123; if(leftMax[i] &lt; array[i] &amp;&amp; rightMin[i] &gt; array[i]) &#123; ans[num++] = array[i]; &#125; &#125; printf("%d\n", num); for(int i = 0; i &lt; num; i++) &#123; printf("%d", ans[i]); if(i &lt; num - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1046 åˆ’æ‹³Analysisæ³¨æ„è¯»é¢˜ï¼Œç†è§£é¢˜ç›®æ„æ€åŽå°±å¥½åŠžäº†ã€‚å¦å¤–æ³¨æ„ï¼Œè¾“å®¶ç½šä¸€æ¯é…’ï¼Œç”²è‹¥è¾“äº†ï¼Œç”²å–ä¸€æ¯ï¼Œä¹™ä¸å–ï¼›åŒèµ¢æˆ–åŒè¾“éƒ½ä¸å–ã€‚ Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a, b, c, d, countA = 0, countB = 0; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if(a + c == b &amp;&amp; a + c == d) continue; // all win else if(a + c != b &amp;&amp; a + c != d) continue; // all lose else if(a + c == b) countB++; // A win else countA++; // B win &#125; cout &lt;&lt; countA &lt;&lt; ' ' &lt;&lt; countB; return 0;&#125; 1047 ç¼–ç¨‹å›¢ä½“èµ›Analysisç»Ÿè®¡æ¯æ”¯é˜Ÿä¼çš„æ€»åˆ†ï¼Œç„¶åŽæ‰¾å‡ºæ€»åˆ†çš„æœ€å¤§å€¼ï¼Œå³å¯å¾—åˆ°å† å†›é˜Ÿçš„ç¼–å·ã€‚ç„¶åŽï¼Œè¾“å‡ºå† å†›é˜Ÿçš„ç¼–å·å’Œæ€»æˆç»©ã€‚ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int N, team, score[1010] = &#123;0&#125;, eachScore, maxteam = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%d-%*d %d", &amp;team, &amp;eachScore); score[team] += eachScore; if(team &gt; maxteam) &#123; maxteam = team; &#125; &#125; int maxscore = -1, index = 0; for(int i = 1; i &lt;= maxteam; i++) &#123; if(score[i] &gt; maxscore) &#123; maxscore = score[i]; index = i; &#125; &#125; printf("%d %d", index, maxscore); return 0;&#125; 1048 æ•°å­—åŠ å¯†Analysisé¢˜ç›®æ„æ€ç®€å•ï¼Œåšæ³•ä¹Ÿä¸éš¾ï¼Œå°±æ˜¯æœ‰é™·é˜±ðŸ¤©ï¼Œå³ï¼šè‹¥æ˜¯Bçš„ä½æ•°å°‘äºŽåŠ å¯†å¯†é’¥çš„ä½æ•°ï¼Œéœ€è¦å‡è®¾Bçš„å½“å‰ä½ä¸Šçš„æ•°å­—æ˜¯0ç„¶åŽå‚ä¸Žè®¡ç®—ï¼ˆæ³¨æ„å¥‡å¶ä½ä¸åŒï¼‰å³å¯ã€‚ ä¸€å¼€å§‹å·æ‡’ï¼Œä»¥ä¸ºçŸ­å°±çŸ­å§ï¼ŒåªåŠ å¯†åˆ°éœ€è¦åŠ å¯†çš„ä½æ•°å°±è¡Œäº†ï¼Œç»“æžœæœ‰ä¸¤ä¸ªæµ‹è¯•ç‚¹æ— æ³•é€šè¿‡ï¼Œçœ‹æ¥è¿˜æ˜¯é¢˜æ„ç†è§£çš„ä¸å¤Ÿæ·±å…¥ã€‚ å¦å¤–ï¼Œç”±äºŽè¾“å…¥åŽï¼Œæ•°å­—çš„ä¸ªä½åœ¨å­—ç¬¦ä¸²æœ€åŽä¸€ä½ï¼Œæ‰€ä»¥éœ€è¦é€†ç½®ä¸€ä¸‹ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100 + 5;char change[14] = "0123456789JQK";void Reverse(char *s);int main(int argc, char const *argv[]) &#123; char A[MAXN], B[MAXN], Result[MAXN]; scanf("%s %s", A, B); Reverse(A); Reverse(B); int i, lenA = strlen(A), lenB = strlen(B), len; len = lenA &gt; lenB ? lenA : lenB; for(i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? A[i] - '0' : 0; int numB = i &lt; lenB ? B[i] - '0' : 0; if(i % 2 == 0) &#123; int sum = numA + numB; Result[i] = change[sum % 13]; &#125; else &#123; int diff = numB - numA; if(diff &lt; 0) &#123; diff += 10; &#125; Result[i] = change[diff]; &#125; &#125; Result[i] = '\0'; Reverse(Result); puts(Result); return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1049 æ•°åˆ—çš„ç‰‡æ®µå’ŒAnalysisé¢˜ç›®å¤§æ„æ˜¯ç»™å®šä¸€ä¸ªæ•°åˆ—ï¼Œè®¡ç®—å…¶æ‰€æœ‰æŒ‰åºæŽ’åˆ—çš„å­åˆ—å’Œã€‚åˆ—ä¸¾å‡º$N$åˆ†åˆ«å–3ã€4ã€5æ—¶ï¼Œå…¶å’Œï¼ˆ$Sum$ï¼‰æƒ…å†µå¦‚ä¸‹ï¼š $N$ $Sum$ 3 $3 \times a_1 + 4 \times a_2 + 3 \times a_3$ 4 $4 \times a_1 + 6 \times a_2 + 6 \times a_3 + 4 \times a_4$ 5 $5 \times a_1 + 8 \times a_2 + 9 \times a_3 + 8 \times a_4 + 5 \times a_5$ äºŽæ˜¯å¯ä»¥æŽ¨å‡ºè§„å¾‹ä¸ºï¼šé¦–é¡¹å’Œå°¾é¡¹ä¹˜ä»¥é¡¹æ•°ç›¸åŠ ï¼Œä¸­é—´æ¯é¡¹å…¶å·¦ã€å³ä¸¤è¾¹é¡¹æ•°ä¹‹ç§¯ï¼ˆåŒ…å«å®ƒè‡ªèº«ï¼‰ã€‚ Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(int i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1051 å¤æ•°ä¹˜æ³•Analysisæ­¤é¢˜ä¸éš¾ï¼Œå±žäºŽâ€œçº¸è€è™Žâ€ï¼Œä¸è¿‡æ‰¾ç‰¹æ®Šæƒ…å†µå¾ˆæ˜¯çƒ¦äººçš„ðŸ˜…~ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(int argc, char const *argv[]) &#123; double R1, P1, R2, P2, R, P; scanf("%lf %lf %lf %lf", &amp;R1, &amp;P1, &amp;R2, &amp;P2); R = R1 * R2 * (cos(P1) * cos(P2) - sin(P1) * sin(P2)); P = R1 * R2 * (cos(P1) * sin(P2) + sin(P1) * cos(P2)); //prevent to print '-0.00' if(-0.05 &lt; R &amp;&amp; R &lt; 0.05) &#123; R = 0.0; &#125; if(-0.05 &lt; P &amp;&amp; P &lt; 0.05) &#123; P = 0.0; &#125; printf("%.2lf", R); if(P &gt;= 0) &#123; printf("+%.2lfi\n", P); &#125; else &#123; printf("-%.2lfi\n", fabs(P)); &#125; return 0;&#125; 1056 ç»„åˆæ•°çš„å’ŒAnalysisé¢˜ç›®ä¸éš¾ï¼Œè¯»æ‡‚é¢˜ç›®ä¹‹åŽç›´æŽ¥åšå°±å¯ä»¥äº†ã€‚ Code123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAXN 10int main(int argc, char const *argv[]) &#123; int i, j, N, Array[MAXN], Sum = 0; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Array[i]); &#125; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(i == j) &#123; continue; &#125; else &#123; Sum += (Array[i] * 10 + Array[j]); &#125; &#125; &#125; printf("%d\n", Sum); return 0;&#125; 1061 åˆ¤æ–­é¢˜Analysisé¢˜ç›®ç¨å¾®æœ‰ç‚¹ç»•ï¼Œå¤§è‡´æ„æ€å°±åƒè€å¸ˆæ”¹å·ä¸€æ ·ï¼Œæ­£ç¡®æ‰“å‹¾ï¼Œé”™è¯¯æ‰“å‰ï¼Œç„¶åŽæŠŠå¯¹çš„é¢˜ç›®çš„åˆ†æ•°åŠ åˆ°ä¸€èµ·ï¼Œä»Žè€Œå¾—åˆ°æ¯ä½å­¦ç”Ÿçš„æ€»åˆ†ã€‚ Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); int i, j, Scores[M], Right[M], Temp[M], Sum; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Scores[i]); &#125; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Right[i]); &#125; while(N--) &#123; Sum = 0; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Temp[i]); if(Temp[i] == Right[i]) &#123; Sum += Scores[i]; &#125; &#125; printf("%d\n", Sum); &#125; return 0;&#125; 1066 å›¾åƒè¿‡æ»¤Analysisè¿™é“é¢˜çš„æ„æ€ï¼Œå…¶å®žå°±æ˜¯å›¾åƒçš„ç°åº¦åŒ–å¤„ç†ï¼ˆå½“ç„¶è¿™é‡Œçš„æ¯”è¾ƒç®€å•ï¼‰ã€‚Matlab å†…æœ‰ç›´æŽ¥è¿›è¡Œæ­¤ç§æ“ä½œçš„å›¾åƒå¤„ç†å‡½æ•°ï¼Œå¯ä»¥ç›´æŽ¥è°ƒç”¨ã€‚æ³¨æ„ N å’Œ M çš„æœ€å¤§å€¼ï¼Œæœ€åŽä¸€ä¸ªæµ‹è¯•ç‚¹æ˜¯æœ€å¤§å€¼æµ‹è¯•ã€‚ Code12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define MAXN 500#define MAXM 500int main(int argc, char const *argv[]) &#123; int r, c, M, N, A, B, gray_value; scanf("%d %d %d %d %d", &amp;M, &amp;N, &amp;A, &amp;B, &amp;gray_value); int image_array[MAXM][MAXN]; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; scanf("%d", &amp;image_array[r][c]); if(A &lt;= image_array[r][c] &amp;&amp; image_array[r][c] &lt;= B) &#123; image_array[r][c] = gray_value; &#125; &#125; &#125; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; printf("%03d", image_array[r][c]); if(c == N-1) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125; 1071 å°èµŒæ€¡æƒ…Analysisè¿™é“é¢˜çš„é¢˜ç›®æ¯”è¾ƒé•¿ï¼Œè€å¿ƒä¸€ç‚¹ï¼Œä»”ç»†è¯»å®Œï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å®šçš„å››ç§æƒ…å†µçš„å¤„ç†æ–¹å¼æ¥å†™ä»£ç ï¼Œåº”è¯¥å°± OK äº†ï¼Œæ³¨æ„è¾“å…‰åŽï¼ˆç­¹ç x &lt;= 0ï¼‰ï¼Œå°±å¯ä»¥ç›´æŽ¥é€€å‡ºäº†ã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define MAXK 100int main(int argc, char const *argv[]) &#123; int T, K, n1, b, t, n2, x, system_result; scanf("%d %d", &amp;T, &amp;K); x = T; while(K-- &amp;&amp; x) &#123; scanf("%d %d %d %d", &amp;n1, &amp;b, &amp;t, &amp;n2); if(t &gt; x) &#123; printf("Not enough tokens. Total = %d.\n", x); continue; &#125; if(n2 &gt; n1) &#123; system_result = 1; &#125; else &#123; system_result = 0; &#125; if(system_result == b) &#123; x += t; printf("Win %d! Total = %d.\n", t, x); &#125; else &#123; x -= t; printf("Lose %d. Total = %d.\n", t, x); &#125; &#125; if(x &lt;= 0) &#123; printf("Game Over.\n"); &#125; return 0;&#125; 1076 Wifiå¯†ç Analysisä¸ºäº†ä¿ƒè¿›å­¦ç”Ÿå­¦ä¹ ï¼Œè¿™é¢˜ä¹ŸçœŸæ˜¯éš¾ä¸ºè€å¸ˆäº†ï¼Œå“ˆå“ˆ~æ­¤é¢˜ä¸éš¾ï¼Œä¸è¿‡éœ€è¦ç»†å¿ƒä¸€ç‚¹ï¼Œè¾“å…¥çš„æ ¼å¼æ˜¯ç¡®å®šå¥½äº†çš„ã€‚å¦‚æžœæ¯æ¬¡è¾“å…¥åˆ©ç”¨å­—ç¬¦æ¥åšå¤„ç†ï¼Œåˆ™éœ€è¦æ³¨æ„å›žè½¦ç¬¦\nä¸è¦è¢«è¾“å…¥å‡½æ•°èŽ·å–åˆ°äº†ï¼ˆæµ‹è¯•ç‚¹2å°±æ˜¯è¿™æ ·ï¼‰ã€‚å¯ä»¥æŒ‰ç…§å­—ç¬¦ä¸²çš„æ€è·¯åŽ»å¤„ç†ï¼Œå¹¶ä¸”å¾ªçŽ¯è¿›è¡Œçš„æ¬¡æ•°å¯èƒ½ä¼šå°‘ä¸€äº›ã€‚ Code1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 105int Wifi_Password[4] = &#123;1, 2, 3, 4&#125;;int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d%*c", &amp;N); char Answers[MAXN], temp, flag; for(i = 0; i &lt; 4 * N; i++) &#123; scanf("%c-%c%*c", &amp;temp, &amp;flag); if(flag == 'T') &#123; Answers[count++] = temp; &#125; &#125; for(i = 0; i &lt; count; i++) &#123; printf("%d", Wifi_Password[Answers[i] - 'A']); &#125; putchar('\n'); return 0;&#125; 1081 æ£€æŸ¥å¯†ç Analysisæ­¤é¢˜çš„éš¾ç‚¹åœ¨äºŽæƒ…å†µçš„åˆ†ç±»ï¼Œæ— è®ºè¾“å…¥çš„â€œå¯†ç â€æ˜¯å¦åˆæ³•ï¼Œé¦–å…ˆåˆ¤æ–­é•¿åº¦æ˜¯å¦ä¸å°äºŽ6ï¼Œç´§æŽ¥ç€ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰éžæ³•å­—ç¬¦ï¼Œç»§è€Œç¡®è®¤æœ‰æ— æ•°å­—ï¼Œæœ€åŽç¡®è®¤æœ‰æ— å­—æ¯ã€‚æ³¨æ„å¯èƒ½ä¼šè¾“å…¥å¸¦ç©ºæ ¼çš„å­—ç¬¦ä¸²ï¼ˆæµ‹è¯•ç‚¹2ï¼‰ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define MaxLength 85int Validity_Check(char *password);char Result[5][100] = &#123; "Your password is tai duan le.", "Your password is tai luan le.", "Your password needs shu zi.", "Your password needs zi mu.", "Your password is wan mei.",&#125;;int main(int argc, char const *argv[]) &#123; int flag, N; char Password[MaxLength]; scanf("%d%*c", &amp;N); while(N--) &#123; gets(Password); //notice the space flag = Validity_Check(Password); puts(Result[flag]); &#125; return 0;&#125;int Validity_Check(char *password) &#123; int ret = 4, len = strlen(password), i; int num_flag, alpha_flag, invalid_flag; num_flag = alpha_flag = invalid_flag = 0; if(len &gt;= 6) &#123; for(i = 0; i &lt; len; i++) &#123; if( isdigit(password[i]) ) &#123; num_flag = 1; &#125; else if( isalpha(password[i]) ) &#123; alpha_flag = 1; &#125; else if(password[i] == '.') &#123; continue; &#125; else &#123; invalid_flag = 1; &#125; &#125; if(invalid_flag) &#123; ret = 1; &#125; else if(!num_flag) &#123; ret = 2; &#125; else if(!alpha_flag) &#123; ret = 3; &#125; &#125; else &#123; ret = 0; &#125; return ret;&#125; 1086 å°±ä¸å‘Šè¯‰ä½ Analysisæ°´é¢˜ä¸€é“ï¼Œæ³¨æ„$700$ï¼Œä¸è¦å€’ç€è¾“å‡ºä¸º$007$äº†ã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int A, B, Product, temp, digit, result = 0; scanf("%d %d", &amp;A, &amp;B); Product = A * B; temp = Product; while(temp) &#123; digit = temp % 10; temp /= 10; result = result * 10 + digit; &#125; printf("%d\n", result); return 0;&#125; 1091 N-è‡ªå®ˆæ•°Analysisæ³¨æ„è¯»é¢˜ï¼Œåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯å¦è‡ªå®ˆï¼Œå°±æ˜¯ç”¨è¿™ä¸ªæ•°çš„æœ€åŽå‡ ä½æž„æˆçš„æ•°å­—ä¸ŽåŽŸæ•°å­—æ¯”è¾ƒæ˜¯å¦ç›¸ç­‰å³å¯ï¼Œè€Œâ€œæœ€åŽå‡ ä½â€å°±æ˜¯åŽŸæ•°å­—çš„ä½æ•°äº†ï¼Œèƒ½å¾—åˆ°è¿™ä¸ªç»†èŠ‚ï¼ˆé¢˜ç›®ä¸­çš„è¿™äº›ç»†èŠ‚ï¼ŒçœŸæ˜¯å«äººåˆçˆ±åˆæ¨ï¼‰åŽï¼Œè¿™ä¸ªé¢˜ç›®å°±å¾ˆç®€å•äº†ã€‚æœ¬æ¥ä»¥ä¸ºï¼Œä½¿ç”¨intå¯èƒ½ä¼šæœ‰æµ‹è¯•ç‚¹ä¸è¿‡ï¼Œç»“æžœæ²¡æœ‰ï¼Œæ²¡è®¾ç½®å¤§æ•°çš„æµ‹è¯•ç‚¹ä¹ˆï¼Ÿå˜¿å˜¿ï¼Œé€ƒè¿‡ä¸€åŠ«~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool Judge_Automorphic(int test_number, int original_number);int main(int argc, char const *argv[]) &#123; int M, N, K, each_item; bool flag; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;K); flag = false; for(N = 1; N &lt; 10; N++) &#123; each_item = N * K * K; if( Judge_Automorphic(each_item, K) ) &#123; flag = true; break; &#125; &#125; if(flag) &#123; printf("%d %d\n", N, each_item); &#125; else &#123; puts("No"); &#125; &#125; return 0;&#125;bool Judge_Automorphic(int test_number, int original_number) &#123; bool flag = false; int mask = 1, temp; temp = original_number; while(temp) &#123; temp /= 10; mask *= 10; &#125; temp = test_number; temp %= mask; if(temp == original_number) &#123; flag = true; &#125; return flag;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†]]></title>
    <url>%2F2019%2F02%2F20%2FPTA%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Introæ­¤Blogç”¨æ¥è®°å½•è‡ªå·±çš„â€PTAåŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†ä¹‹æ—…(å—è™)â€ã€‚æ¯é“é¢˜ç›®åŒ…å«è¾“å…¥(è¾“å‡º)æ ·ä¾‹ã€è¾“å…¥(è¾“å‡º)è¯´æ˜Žã€æ€è·¯åˆ†æžåŠå¾—åˆ°ACçš„æºç ã€‚æ‰€æœ‰ACä»£ç å·²ä¸Šä¼ åˆ°GitHubä¸Šï¼Œç‚¹å‡»PTA-Basical-Programming-problem-setå³å¯èŽ·å–ã€‚ Programming7-1 åŽ˜ç±³æ¢ç®—è‹±å°ºè‹±å¯¸å¦‚æžœå·²çŸ¥è‹±åˆ¶é•¿åº¦çš„è‹±å°º$foot$å’Œè‹±å¯¸$inch$çš„å€¼ï¼Œé‚£ä¹ˆå¯¹åº”çš„ç±³æ˜¯$(foot+inch/12)Ã—0.3048$ã€‚çŽ°åœ¨ï¼Œå¦‚æžœç”¨æˆ·è¾“å…¥çš„æ˜¯åŽ˜ç±³æ•°ï¼Œé‚£ä¹ˆå¯¹åº”è‹±åˆ¶é•¿åº¦çš„è‹±å°ºå’Œè‹±å¯¸æ˜¯å¤šå°‘å‘¢ï¼Ÿåˆ«å¿˜äº†1è‹±å°ºç­‰äºŽ12è‹±å¯¸ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º1ä¸ªæ­£æ•´æ•°ï¼Œå•ä½æ˜¯åŽ˜ç±³ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªåŽ˜ç±³æ•°å¯¹åº”è‹±åˆ¶é•¿åº¦çš„è‹±å°ºå’Œè‹±å¯¸çš„æ•´æ•°å€¼ï¼Œä¸­é—´ç”¨ç©ºæ ¼åˆ†å¼€ã€‚ Sample Input &amp; Sample Output Input 1:170 Output 1:5 6 Analysisè¿™é“é¢˜ç›®ä¹ä¸€çœ‹æŒºç®€å•çš„ï¼Œå…¶å®žä¹Ÿæœ‰ç‚¹ç»•(é¢˜ç›®æœ‰ç‚¹è¿·ðŸ˜’)ã€‚é¦–å…ˆï¼Œè¦æ˜Žç¡®é¢˜ç›®éœ€è¦æˆ‘ä»¬å¾—åˆ°çš„ç»“æžœæ˜¯ï¼šç»™å‡ºçš„åŽ˜ç±³å¯¹åº”æ¢ç®—ä¸ºè‹±å°ºã€è‹±å¯¸çš„é•¿åº¦ï¼Œä¹Ÿå°±æ˜¯è¯´ï¼Œå­˜åœ¨è¿™æ ·ä¸€ä¸ªå…³ç³»ï¼š$170CMâ‰ˆ5foot6inch$(é¢˜ç›®åªè¦æ±‚æ•´æ•°)ï¼Œå°±å¥½æ¯”æ˜¯$103=20Ã—5+3$ï¼Œè€Œæˆ‘ä»¬è¦çš„å€¼å°±æ˜¯è¿™ä¸ª5å’Œ3ã€‚æ˜Žç™½è¿™ä¸ªä¹‹åŽï¼Œå°±ä¼šå‘çŽ°ï¼Œå•çº¯çš„å°†$1foot=12inch$è¿™ä¸ªæ¡æŒ‰é¢˜ç›®ç»™çš„æ–¹ç¨‹å¸¦å…¥è®¡ç®—æ˜¯å¾—ä¸å‡ºç»“æžœçš„ï¼Œé‚£ä¹ˆå¯ä»¥å…ˆæ±‚å¤§çš„å•ä½($foot$)çš„å€¼ï¼Œé‚£ä¹ˆå°å•ä½($inch$)çš„å€¼å°±æ˜¯å‰©ä¸‹çš„å·®äº†ã€‚æŽ¥ä¸‹æ¥ï¼Œè¿˜å¾—æ‰¾$foot$å’Œ$CM$çš„æ•°å€¼å…³ç³»(è¿™é‡Œä¹Ÿå¯ä»¥ç›´æŽ¥ç™¾åº¦)ï¼Œä¾æ®$(foot+inch/12)Ã—0.3048$ï¼Œè¿™ä¸ªå¼å­è®¡ç®—ç»“æžœçš„å•ä½æ˜¯$M$ï¼Œè€Œå·¦è¾¹$(foot+inch/12)$çš„å•ä½æ˜¯$foot$ï¼Œæ‰€ä»¥å°±å¯ä»¥çŸ¥é“ï¼š$1foot=30.48CM$ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥ç›´æŽ¥ç®—å‡ºæ­£ç¡®çš„$foot$å€¼äº†ã€‚ Code1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int foot,inch,centimeters; scanf("%d", &amp;centimeters); // centimeters = 170; foot = centimeters / 30.48; inch = centimeters / 2.54 - 12*foot; printf("%d %d\n", foot, inch); return 0;&#125; 7-2 ç„¶åŽæ˜¯å‡ ç‚¹æœ‰æ—¶å€™äººä»¬ç”¨å››ä½æ•°å­—è¡¨ç¤ºä¸€ä¸ªæ—¶é—´ï¼Œæ¯”å¦‚1106è¡¨ç¤º11ç‚¹é›¶6åˆ†ã€‚çŽ°åœ¨ï¼Œä½ çš„ç¨‹åºè¦æ ¹æ®èµ·å§‹æ—¶é—´å’Œæµé€çš„æ—¶é—´è®¡ç®—å‡ºç»ˆæ­¢æ—¶é—´ã€‚è¯»å…¥ä¸¤ä¸ªæ•°å­—ï¼Œç¬¬ä¸€ä¸ªæ•°å­—ä»¥è¿™æ ·çš„å››ä½æ•°å­—è¡¨ç¤ºå½“å‰æ—¶é—´ï¼Œç¬¬äºŒä¸ªæ•°å­—è¡¨ç¤ºåˆ†é’Ÿæ•°ï¼Œè®¡ç®—å½“å‰æ—¶é—´ç»è¿‡é‚£ä¹ˆå¤šåˆ†é’ŸåŽæ˜¯å‡ ç‚¹ï¼Œç»“æžœä¹Ÿè¡¨ç¤ºä¸ºå››ä½æ•°å­—ã€‚å½“å°æ—¶ä¸ºä¸ªä½æ•°æ—¶ï¼Œæ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå³5ç‚¹30åˆ†è¡¨ç¤ºä¸º530ã€‚æ³¨æ„ï¼Œç¬¬äºŒä¸ªæ•°å­—è¡¨ç¤ºçš„åˆ†é’Ÿæ•°å¯èƒ½è¶…è¿‡60ï¼Œä¹Ÿå¯èƒ½æ˜¯è´Ÿæ•°ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ•´æ•°ï¼Œåˆ†åˆ«æ˜¯å››ä½æ•°å­—è¡¨ç¤ºçš„èµ·å§‹æ—¶é—´ã€ä»¥åŠæµé€çš„åˆ†é’Ÿæ•°ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚æ³¨æ„ï¼šåœ¨èµ·å§‹æ—¶é—´ä¸­ï¼Œå½“å°æ—¶ä¸ºä¸ªä½æ•°æ—¶ï¼Œæ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå³5ç‚¹30åˆ†è¡¨ç¤ºä¸º530ï¼›æµé€çš„åˆ†é’Ÿæ•°å¯èƒ½è¶…è¿‡60ï¼Œä¹Ÿå¯èƒ½æ˜¯è´Ÿæ•°ã€‚ Output Specificationè¾“å‡ºå››ä½æ•°å­—è¡¨ç¤ºçš„ç»ˆæ­¢æ—¶é—´ã€‚é¢˜ç›®ä¿è¯èµ·å§‹æ—¶é—´å’Œç»ˆæ­¢æ—¶é—´åœ¨åŒä¸€å¤©å†…ã€‚ Sample Input &amp; Sample Output Input 1:1120 110 Output 1:1310 Analysisç®€å•é¢˜ï¼Œæ±‚å‡ºæ€»çš„åˆ†é’Ÿå€¼ï¼Œç„¶åŽæ±‚å‡ºå°æ—¶çš„å€¼ï¼Œåœ¨æŒ‰ç…§é¢˜ç›®è¦æ±‚è¾“å‡ºå³å¯ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int start_time,waste_time; scanf("%d %d", &amp;start_time, &amp;waste_time); // start_time = 1120; waste_time = 110; int hours,minutes; minutes = start_time/100*60 + start_time%100 + waste_time; hours = minutes/60; minutes -= hours*60; printf("%d\n", hours*100+minutes); return 0;&#125; 7-3 é€†åºçš„ä¸‰ä½æ•°ç¨‹åºæ¯æ¬¡è¯»å…¥ä¸€ä¸ªæ­£3ä½æ•°ï¼Œç„¶åŽè¾“å‡ºæŒ‰ä½é€†åºçš„æ•°å­—ã€‚æ³¨æ„ï¼šå½“è¾“å…¥çš„æ•°å­—å«æœ‰ç»“å°¾çš„0æ—¶ï¼Œè¾“å‡ºä¸åº”å¸¦æœ‰å‰å¯¼çš„0ã€‚æ¯”å¦‚è¾“å…¥700ï¼Œè¾“å‡ºåº”è¯¥æ˜¯7ã€‚ Input Specificationæ¯ä¸ªæµ‹è¯•æ˜¯ä¸€ä¸ª3ä½çš„æ­£æ•´æ•°ã€‚ Output Specificationè¾“å‡ºæŒ‰ä½é€†åºçš„æ•°ã€‚ Sample Input &amp; Sample Output Input 1:123 Output 1:321 Analysisè¿™é“é¢˜ç›®å¾ˆç®€å•ï¼Œè€ƒå¯Ÿæ•°ä½æ‹†åˆ†ï¼Œåœ¨é¢˜ç›®å‘Šè¯‰å·²çŸ¥3ä½æ•°çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥ç›´æŽ¥è¿›è¡Œæ•°ä½æ‹†åˆ†(ä¸€èˆ¬é¢˜ç›®éƒ½ä¸ä¼šç»™è¾“å…¥æ•°å­—çš„ä½æ•°ï¼Œè€Œåªç»™èŒƒå›´)ï¼›å¹¶ä¸”é¢˜ç›®ä¹Ÿå·²ç»ç»™å‡ºäº†è¦æ³¨æ„çš„åœ°æ–¹ï¼š700é€†åºåŽä¸èƒ½æ˜¯007ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; scanf("%d", &amp;n); // n=700; int units,tens,hundred; units=n%10; tens=n/10%10; hundred=n/100; printf("%d\n", units*100+tens*10+hundred); return 0;&#125; 7-4 BCDè§£å¯†BCDæ•°æ˜¯ç”¨ä¸€ä¸ªå­—èŠ‚æ¥è¡¨è¾¾ä¸¤ä½åè¿›åˆ¶çš„æ•°ï¼Œæ¯å››ä¸ªæ¯”ç‰¹è¡¨ç¤ºä¸€ä½ã€‚æ‰€ä»¥å¦‚æžœä¸€ä¸ªBCDæ•°çš„åå…­è¿›åˆ¶æ˜¯0x12ï¼Œå®ƒè¡¨è¾¾çš„å°±æ˜¯åè¿›åˆ¶çš„12ã€‚ä½†æ˜¯å°æ˜Žæ²¡å­¦è¿‡BCDï¼ŒæŠŠæ‰€æœ‰çš„BCDæ•°éƒ½å½“ä½œäºŒè¿›åˆ¶æ•°è½¬æ¢æˆåè¿›åˆ¶è¾“å‡ºäº†ã€‚äºŽæ˜¯BCDçš„0x12è¢«è¾“å‡ºæˆäº†åè¿›åˆ¶çš„18äº†ï¼çŽ°åœ¨ï¼Œä½ çš„ç¨‹åºè¦è¯»å…¥è¿™ä¸ªé”™è¯¯çš„åè¿›åˆ¶æ•°ï¼Œç„¶åŽè¾“å‡ºæ­£ç¡®çš„åè¿›åˆ¶æ•°ã€‚æç¤ºï¼šä½ å¯ä»¥æŠŠ18è½¬æ¢å›ž0x12ï¼Œç„¶åŽå†è½¬æ¢å›ž12ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ª$[0, 153]$èŒƒå›´å†…çš„æ­£æ•´æ•°ï¼Œä¿è¯èƒ½è½¬æ¢å›žæœ‰æ•ˆçš„BCDæ•°ï¼Œä¹Ÿå°±æ˜¯è¯´è¿™ä¸ªæ•´æ•°è½¬æ¢æˆåå…­è¿›åˆ¶æ—¶ä¸ä¼šå‡ºçŽ°A-Fçš„æ•°å­—ã€‚ Output Specificationè¾“å‡ºå¯¹åº”çš„åè¿›åˆ¶æ•°ã€‚ Sample Input &amp; Sample Output Input 1:18 Output 1:12 Analysisç®€å•é¢˜ï¼Œé¢˜ç›®ç»™çš„æç¤ºå¾ˆæ˜Žæ˜¾ï¼Œå•ç‹¬å‡ºåŽ»åè¿›åˆ¶æ•°çš„ä¸ªä½å’Œåä½åŽï¼Œç›´æŽ¥ç»„åˆè®¡ç®—å³å¯å¾—åˆ°ã€‚ Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int BCD; scanf("%d", &amp;BCD); // BCD=18; int units,tens; units=BCD%16; tens=BCD/16; printf("%d\n", tens*10+units); return 0;&#125; 7-5 è¡¨æ ¼è¾“å‡ºæœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼ŒæŒ‰ç…§è§„å®šæ ¼å¼è¾“å‡ºè¡¨æ ¼ã€‚ Input Specificationæœ¬é¢˜ç›®æ²¡æœ‰è¾“å…¥ã€‚ Output Specificationè¦æ±‚ä¸¥æ ¼æŒ‰ç…§ç»™å‡ºçš„æ ¼å¼è¾“å‡ºä¸‹åˆ—è¡¨æ ¼ï¼š123456789------------------------------------Province Area(km2) Pop.(10K)------------------------------------Anhui 139600.00 6461.00Beijing 16410.54 1180.70Chongqing 82400.00 3144.23Shanghai 6340.50 1360.26Zhejiang 101800.00 4894.00------------------------------------ Analysisé€åˆ†é¢˜ï¼Œç›´æŽ¥åŽŸæ ·è¾“å‡ºå³å¯ã€‚ Code1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf("------------------------------------\n"); printf("Province Area(km2) Pop.(10K)\n"); printf("------------------------------------\n"); printf("Anhui 139600.00 6461.00\n"); printf("Beijing 16410.54 1180.70\n"); printf("Chongqing 82400.00 3144.23\n"); printf("Shanghai 6340.50 1360.26\n"); printf("Zhejiang 101800.00 4894.00\n"); printf("------------------------------------\n"); return 0;&#125; 7-6 æ··åˆç±»åž‹æ•°æ®æ ¼å¼åŒ–è¾“å…¥æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œé¡ºåºè¯»å…¥æµ®ç‚¹æ•°1ã€æ•´æ•°ã€å­—ç¬¦ã€æµ®ç‚¹æ•°2ï¼Œå†æŒ‰ç…§å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°1ã€æµ®ç‚¹æ•°2çš„é¡ºåºè¾“å‡ºã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­é¡ºåºç»™å‡ºæµ®ç‚¹æ•°1ã€æ•´æ•°ã€å­—ç¬¦ã€æµ®ç‚¹æ•°2ï¼Œå…¶é—´ä»¥1ä¸ªç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§å­—ç¬¦ã€æ•´æ•°ã€æµ®ç‚¹æ•°1ã€æµ®ç‚¹æ•°2çš„é¡ºåºè¾“å‡ºï¼Œå…¶ä¸­æµ®ç‚¹æ•°ä¿ç•™å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input:2.12 88 c 4.7 Output:c 88 2.12 4.70 AnalysisæŒ‰é¢˜ç›®è¦æ±‚è¾“å…¥è¾“å‡ºå³å¯ã€‚ Code12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float a1,a2; int b; char c; scanf("%f %d %c %f", &amp;a1, &amp;b, &amp;c, &amp;a2); printf("%c %d %.2f %.2f\n", c, b, a1, a2); return 0;&#125; 7-7 12-24å°æ—¶åˆ¶ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥24å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œç„¶åŽæ˜¾ç¤º12å°æ—¶åˆ¶çš„æ—¶é—´ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå¸¦æœ‰ä¸­é—´çš„:ç¬¦å·ï¼ˆåŠè§’çš„å†’å·ï¼‰çš„24å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œå¦‚12:34è¡¨ç¤º12ç‚¹34åˆ†ã€‚å½“å°æ—¶æˆ–åˆ†é’Ÿæ•°å°äºŽ10æ—¶ï¼Œå‡æ²¡æœ‰å‰å¯¼çš„é›¶ï¼Œå¦‚5:6è¡¨ç¤º5ç‚¹é›¶6åˆ†ã€‚æç¤ºï¼šåœ¨scanfçš„æ ¼å¼å­—ç¬¦ä¸²ä¸­åŠ å…¥:ï¼Œè®©scanfæ¥å¤„ç†è¿™ä¸ªå†’å·ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªæ—¶é—´å¯¹åº”çš„12å°æ—¶åˆ¶çš„æ—¶é—´ï¼Œæ•°å­—éƒ¨åˆ†æ ¼å¼ä¸Žè¾“å…¥çš„ç›¸åŒï¼Œç„¶åŽè·Ÿä¸Šç©ºæ ¼ï¼Œå†è·Ÿä¸Šè¡¨ç¤ºä¸Šåˆçš„å­—ç¬¦ä¸²AMæˆ–è¡¨ç¤ºä¸‹åˆçš„å­—ç¬¦ä¸²PMã€‚å¦‚5:6 PMè¡¨ç¤ºä¸‹åˆ5ç‚¹é›¶6åˆ†ã€‚æ³¨æ„ï¼Œåœ¨è‹±æ–‡çš„ä¹ æƒ¯ä¸­ï¼Œä¸­åˆ12ç‚¹è¢«è®¤ä¸ºæ˜¯ä¸‹åˆï¼Œæ‰€ä»¥24å°æ—¶åˆ¶çš„12:00å°±æ˜¯12å°æ—¶åˆ¶çš„12:0 PMï¼›è€Œ0ç‚¹è¢«è®¤ä¸ºæ˜¯ç¬¬äºŒå¤©çš„æ—¶é—´ï¼Œæ‰€ä»¥æ˜¯0:0 AMã€‚ Sample Input &amp; Sample Output Input:21:11 Output:9:11 PM Analysisæ ¹æ®è¾“å‡ºæ ¼å¼è¿›è¡Œè¾“å‡ºå³å¯ï¼Œæ³¨æ„ä¸­åˆ12ç‚¹è¢«è®¤ä¸ºæ˜¯PMï¼›è¾“å…¥åªéœ€æ³¨æ„:å³å¯ã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int hours,minutes; scanf("%d:%d", &amp;hours, &amp;minutes); // hours = 21, minutes = 11; if(hours == 12)&#123; printf("%d:%d PM\n", hours, minutes); &#125;else if(hours &lt; 12)&#123; printf("%d:%d AM\n", hours, minutes); &#125;else&#123; printf("%d:%d PM\n", hours-12, minutes); &#125; return 0;&#125; 7-8 è¶…é€Ÿåˆ¤æ–­æ¨¡æ‹Ÿäº¤é€šè­¦å¯Ÿçš„é›·è¾¾æµ‹é€Ÿä»ªã€‚è¾“å…¥æ±½è½¦é€Ÿåº¦ï¼Œå¦‚æžœé€Ÿåº¦è¶…å‡º60 mphï¼Œåˆ™æ˜¾ç¤ºSpeedingï¼Œå¦åˆ™æ˜¾ç¤ºOKã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º1ä¸ªä¸è¶…è¿‡500çš„éžè´Ÿæ•´æ•°ï¼Œå³é›·è¾¾æµ‹åˆ°çš„è½¦é€Ÿã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæµ‹é€Ÿä»ªæ˜¾ç¤ºç»“æžœï¼Œæ ¼å¼ä¸ºï¼šSpeed: V - Sï¼Œå…¶ä¸­Væ˜¯è½¦é€Ÿï¼ŒSæ˜¯Speedingã€æˆ–è€…æ˜¯OKã€‚ Sample Input &amp; Sample Output Input 1:40 Output 1:Speed: 40 - OK Input 2:75 Output 2:Speed: 75 - Speeding Analysisæ ¹æ®é¢˜ç›®è¦æ±‚ç›´æŽ¥è¾“å‡ºå³å¯ã€‚ Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int speed; scanf("%d", &amp;speed); // speed=75; if(speed &gt; 60)&#123; printf("Speed: %d - Speeding\n", speed); &#125;else&#123; printf("Speed: %d - OK\n", speed); &#125; return 0;&#125; 7-9 ç”¨å¤©å¹³æ‰¾å°çƒä¸‰ä¸ªçƒAã€Bã€Cï¼Œå¤§å°å½¢çŠ¶ç›¸åŒä¸”å…¶ä¸­æœ‰ä¸€ä¸ªçƒä¸Žå…¶ä»–çƒé‡é‡ä¸åŒã€‚è¦æ±‚æ‰¾å‡ºè¿™ä¸ªä¸ä¸€æ ·çš„çƒã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º3ä¸ªæ­£æ•´æ•°ï¼Œé¡ºåºå¯¹åº”çƒAã€Bã€Cçš„é‡é‡ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå”¯ä¸€çš„é‚£ä¸ªä¸ä¸€æ ·çš„çƒã€‚ Sample Input &amp; Sample Output Input:1 1 2 Output:C Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œå¦‚æžœè¦è¾“å‡ºå”¯ä¸€çš„é‚£ä¸ªä¸ä¸€æ ·çš„çƒï¼Œå…¶å®žå°±åªæœ‰ä¸‰ç§æƒ…å†µï¼Œç›´æŽ¥è¾“å‡ºå°±å¥½ã€‚ Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,C; scanf("%d %d %d", &amp;A, &amp;B, &amp;C); // A=1, B=1, C=2; if(A != B &amp;&amp; A != C) printf("A\n"); if(B != A &amp;&amp; B != C) printf("B\n"); if(C != A &amp;&amp; C != B) printf("C\n"); return 0;&#125; 7-10 è®¡ç®—å·¥èµ„æŸå…¬å¸å‘˜å·¥çš„å·¥èµ„è®¡ç®—æ–¹æ³•å¦‚ä¸‹ï¼šä¸€å‘¨å†…å·¥ä½œæ—¶é—´ä¸è¶…è¿‡40å°æ—¶ï¼ŒæŒ‰æ­£å¸¸å·¥ä½œæ—¶é—´è®¡é…¬ï¼›è¶…å‡º40å°æ—¶çš„å·¥ä½œæ—¶é—´éƒ¨åˆ†ï¼ŒæŒ‰æ­£å¸¸å·¥ä½œæ—¶é—´æŠ¥é…¬çš„1.5å€è®¡é…¬ã€‚å‘˜å·¥æŒ‰è¿›å…¬å¸æ—¶é—´åˆ†ä¸ºæ–°èŒå·¥å’Œè€èŒå·¥ï¼Œè¿›å…¬å¸ä¸å°‘äºŽ5å¹´çš„å‘˜å·¥ä¸ºè€èŒå·¥ï¼Œ5å¹´ä»¥ä¸‹çš„ä¸ºæ–°èŒå·¥ã€‚æ–°èŒå·¥çš„æ­£å¸¸å·¥èµ„ä¸º30å…ƒ/å°æ—¶ï¼Œè€èŒå·¥çš„æ­£å¸¸å·¥èµ„ä¸º50å…ƒ/å°æ—¶ã€‚è¯·æŒ‰è¯¥è®¡é…¬æ–¹å¼è®¡ç®—å‘˜å·¥çš„å·¥èµ„ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ­£æ•´æ•°ï¼Œåˆ†åˆ«ä¸ºæŸå‘˜å·¥å…¥èŒå¹´æ•°å’Œå‘¨å·¥ä½œæ—¶é—´ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œè¾“å‡ºè¯¥å‘˜å·¥çš„å‘¨è–ªï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input 1:5 40 Output 1:2000.00 Input 2:3 50 Output 2:1650.00 Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œé’ˆå¯¹ä¸åŒæƒ…å†µè®¡ç®—å·¥èµ„å³å¯ï¼Œå®žè´¨ä¸ºåˆ†æ®µå‡½æ•°æ±‚å€¼ã€‚ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int years,hours; float wage; scanf("%d %d", &amp;years, &amp;hours); // years=3, hours=50; if(years &gt;= 5)&#123; if(hours &gt; 40)&#123; wage = 50*40 + 1.5*50*(hours - 40); &#125;else&#123; wage = 50*hours; &#125; &#125;else&#123; if(hours &gt; 40)&#123; wage = 30*40 + 1.5*30*(hours - 40); &#125;else&#123; wage = 30*hours; &#125; &#125; printf("%.2f\n", wage); return 0;&#125; 7-11 åˆ†æ®µè®¡ç®—å±…æ°‘æ°´è´¹ä¸ºé¼“åŠ±å±…æ°‘èŠ‚çº¦ç”¨æ°´ï¼Œè‡ªæ¥æ°´å…¬å¸é‡‡å–æŒ‰ç”¨æ°´é‡é˜¶æ¢¯å¼è®¡ä»·çš„åŠžæ³•ï¼Œå±…æ°‘åº”äº¤æ°´è´¹$y$ï¼ˆå…ƒï¼‰ä¸Žæœˆç”¨æ°´é‡$x$ï¼ˆå¨ï¼‰ç›¸å…³ï¼šå½“$x$ä¸è¶…è¿‡15å¨æ—¶ï¼Œ$y=4x/3$ï¼›è¶…è¿‡åŽï¼Œ$y=2.5xâˆ’17.5$ã€‚è¯·ç¼–å†™ç¨‹åºå®žçŽ°æ°´è´¹çš„è®¡ç®—ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºéžè´Ÿå®žæ•°$x$ã€‚ Output Specificationåœ¨ä¸€è¡Œè¾“å‡ºåº”äº¤çš„æ°´è´¹ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input 1:12 Output 1:16.00 Input 2:16 Output 2:22.50 Analysisæ ¹æ®é¢˜ç›®æ¡ä»¶ï¼Œé’ˆå¯¹ä¸åŒæƒ…å†µè®¡ç®—æ°´è´¹å³å¯ï¼Œå®žè´¨ä¸ºåˆ†æ®µå‡½æ•°æ±‚å€¼ã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int x; scanf("%d", &amp;x); // x=16; float water_fee; if(x &lt;= 15)&#123; water_fee = 4.0*x/3; &#125;else&#123; water_fee = 2.5*x - 17.5; &#125; printf("%.2f\n", water_fee); return 0;&#125; 7-12 ä¸¤ä¸ªæ•°çš„ç®€å•è®¡ç®—å™¨æœ¬é¢˜è¦æ±‚ç¼–å†™ä¸€ä¸ªç®€å•è®¡ç®—å™¨ç¨‹åºï¼Œå¯æ ¹æ®è¾“å…¥çš„è¿ç®—ç¬¦ï¼Œå¯¹2ä¸ªæ•´æ•°è¿›è¡ŒåŠ ã€å‡ã€ä¹˜ã€é™¤æˆ–æ±‚ä½™è¿ç®—ã€‚é¢˜ç›®ä¿è¯è¾“å…¥å’Œè¾“å‡ºå‡ä¸è¶…è¿‡æ•´åž‹èŒƒå›´ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ä¾æ¬¡è¾“å…¥æ“ä½œæ•°1ã€è¿ç®—ç¬¦ã€æ“ä½œæ•°2ï¼Œå…¶é—´ä»¥1ä¸ªç©ºæ ¼åˆ†éš”ã€‚æ“ä½œæ•°çš„æ•°æ®ç±»åž‹ä¸ºæ•´åž‹ï¼Œä¸”ä¿è¯é™¤æ³•å’Œæ±‚ä½™çš„åˆ†æ¯éžé›¶ã€‚ Output Specificationå½“è¿ç®—ç¬¦ä¸º+ã€-ã€*ã€/ã€%æ—¶ï¼Œåœ¨ä¸€è¡Œè¾“å‡ºç›¸åº”çš„è¿ç®—ç»“æžœã€‚è‹¥è¾“å…¥æ˜¯éžæ³•ç¬¦å·ï¼ˆå³é™¤äº†åŠ ã€å‡ã€ä¹˜ã€é™¤å’Œæ±‚ä½™äº”ç§è¿ç®—ç¬¦ä»¥å¤–çš„å…¶ä»–ç¬¦å·ï¼‰åˆ™è¾“å‡ºERRORã€‚ Sample Input &amp; Sample output Input 1:-7 / 2 Output 1:-3 Input 2:3 &amp; 6 Output 2:ERROR Analysisé’ˆå¯¹ä¸åŒçš„æƒ…å†µä½¿ç”¨switchè¯­å¥åˆ†åˆ«å¤„ç†å³å¯ã€‚ Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int a, b; char c; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); switch(c)&#123; case '+': printf("%d\n", a + b);break; case '-': printf("%d\n", a - b);break; case '*': printf("%d\n", a * b);break; case '/': printf("%d\n", a / b);break; case '%': printf("%d\n", a % b);break; default : printf("ERROR\n"); &#125; return 0;&#125; 7-13 æ—¥Kèœ¡çƒ›å›¾è‚¡ç¥¨ä»·æ ¼æ¶¨è·Œè¶‹åŠ¿ï¼Œå¸¸ç”¨èœ¡çƒ›å›¾æŠ€æœ¯ä¸­çš„Kçº¿å›¾æ¥è¡¨ç¤ºï¼Œåˆ†ä¸ºæŒ‰æ—¥çš„æ—¥Kçº¿ã€æŒ‰å‘¨çš„å‘¨Kçº¿ã€æŒ‰æœˆçš„æœˆKçº¿ç­‰ã€‚ä»¥æ—¥Kçº¿ä¸ºä¾‹ï¼Œæ¯å¤©è‚¡ç¥¨ä»·æ ¼ä»Žå¼€ç›˜åˆ°æ”¶ç›˜èµ°å®Œä¸€å¤©ï¼Œå¯¹åº”ä¸€æ ¹èœ¡çƒ›å°å›¾ï¼Œè¦è¡¨ç¤ºå››ä¸ªä»·æ ¼ï¼šå¼€ç›˜ä»·æ ¼Openï¼ˆæ—©ä¸Šåˆšåˆšå¼€å§‹å¼€ç›˜ä¹°å–æˆäº¤çš„ç¬¬1ç¬”ä»·æ ¼ï¼‰ã€æ”¶ç›˜ä»·æ ¼Closeï¼ˆä¸‹åˆæ”¶ç›˜æ—¶æœ€åŽä¸€ç¬”æˆäº¤çš„ä»·æ ¼ï¼‰ã€ä¸­é—´çš„æœ€é«˜ä»·Highå’Œæœ€ä½Žä»·Lowã€‚ å¦‚æžœClose&lt;Openï¼Œè¡¨ç¤ºä¸ºBW-Solidï¼ˆå³â€œå®žå¿ƒè“ç™½èœ¡çƒ›â€ï¼‰ï¼›å¦‚æžœClose&gt;Openï¼Œè¡¨ç¤ºä¸ºR-Hollowï¼ˆå³â€œç©ºå¿ƒçº¢èœ¡çƒ›â€ï¼‰ï¼›å¦‚æžœOpenç­‰äºŽCloseï¼Œåˆ™ä¸ºR-Crossï¼ˆå³â€œåå­—çº¢èœ¡çƒ›â€ï¼‰ã€‚å¦‚æžœLowæ¯”Openå’ŒCloseä½Žï¼Œç§°ä¸ºLower Shadowï¼ˆå³â€œæœ‰ä¸‹å½±çº¿â€ï¼‰ï¼Œå¦‚æžœHighæ¯”Openå’ŒCloseé«˜ï¼Œç§°ä¸ºUpper Shadowï¼ˆå³â€œæœ‰ä¸Šå½±çº¿â€ï¼‰ã€‚è¯·ç¼–ç¨‹åºï¼Œæ ¹æ®ç»™å®šçš„å››ä¸ªä»·æ ¼ç»„åˆï¼Œåˆ¤æ–­å½“æ—¥çš„èœ¡çƒ›æ˜¯ä¸€æ ¹ä»€ä¹ˆæ ·çš„èœ¡çƒ›ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º4ä¸ªæ­£å®žæ•°ï¼Œåˆ†åˆ«å¯¹åº”Openã€Highã€Lowã€Closeï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ—¥Kèœ¡çƒ›çš„ç±»åž‹ã€‚å¦‚æžœæœ‰ä¸Šã€ä¸‹å½±çº¿ï¼Œåˆ™åœ¨ç±»åž‹åŽåŠ ä¸Šwith å½±çº¿ç±»åž‹ã€‚å¦‚æžœä¸¤ç§å½±çº¿éƒ½æœ‰ï¼Œåˆ™è¾“å‡ºwith Lower Shadow and Upper Shadowã€‚ Sample Input &amp; Sample output Input 1:5.110 5.250 5.100 5.105 Output 1:BW-Solid with Lower Shadow and Upper Shadow Input 2:5.110 5.110 5.110 5.110 Output 2:R-Cross Input 3:5.110 5.125 5.112 5.126 Output 3:R-Hollow Analysiså…ˆåˆ¤æ–­å›¾å½¢ç±»åž‹ï¼Œåœ¨åˆ¤æ–­æ˜¯å¦åŒ…å«å½±çº¿ï¼›æŒ‰ç…§ä¸‹é¢çš„ä»£ç çš„æ€è·¯ï¼Œéœ€è¦å°†æ—¢æœ‰ä¸‹å½±çº¿åˆæœ‰ä¸Šå½±çº¿çš„æƒ…å†µæ”¾åœ¨ç¬¬ä¸€ä½è¿›è¡Œåˆ¤æ–­ã€‚ Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float open,high,low,close; scanf("%f %f %f %f", &amp;open, &amp;high, &amp;low, &amp;close); if(close &lt; open)&#123; printf("BW-Solid"); &#125;else if(close == open)&#123; printf("R-Cross"); &#125;else&#123; printf("R-Hollow"); &#125; if(low &lt; open &amp;&amp; low &lt; close &amp;&amp; high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Lower Shadow and Upper Shadow\n"); &#125;else if(high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Upper Shadow\n"); &#125;else if(low &lt; open &amp;&amp; low &lt; close)&#123; printf(" with Lower Shadow\n"); &#125;else&#123; printf("\n"); &#125; return 0;&#125; 7-14 æ±‚æ•´æ•°æ®µå’Œç»™å®šä¸¤ä¸ªæ•´æ•°Aå’ŒBï¼Œè¾“å‡ºä»ŽAåˆ°Bçš„æ‰€æœ‰æ•´æ•°ä»¥åŠè¿™äº›æ•°çš„å’Œã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡º2ä¸ªæ•´æ•°Aå’ŒBï¼Œå…¶ä¸­$âˆ’100â‰¤Aâ‰¤Bâ‰¤100$ï¼Œå…¶é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationé¦–å…ˆé¡ºåºè¾“å‡ºä»ŽAåˆ°Bçš„æ‰€æœ‰æ•´æ•°ï¼Œæ¯5ä¸ªæ•°å­—å ä¸€è¡Œï¼Œæ¯ä¸ªæ•°å­—å 5ä¸ªå­—ç¬¦å®½åº¦ï¼Œå‘å³å¯¹é½ã€‚æœ€åŽåœ¨ä¸€è¡Œä¸­æŒ‰Sum=Xçš„æ ¼å¼è¾“å‡ºå…¨éƒ¨æ•°å­—çš„å’ŒXã€‚ Sample Input &amp; Sample output Input:-3 8 Output: -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 Analysisè€ƒå¯Ÿæ ¼å¼è¾“å‡ºå’Œæ±‚å’Œï¼Œè¾“å‡ºæ—¶æ³¨æ„æ ¼å¼å³å¯ï¼Œæœ€å¥½å°†æ•°å­—å’Œæ¢è¡Œåˆ†å¼€è¾“å‡ºã€‚ Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,i,sum; scanf("%d %d", &amp;A, &amp;B); // A=1, B=5; for(i=0, sum=0; A&lt;=B; A++, i++) &#123; if(i%5 == 0 &amp;&amp; i != 0) printf("\n"); printf("%5d", A); sum+=A; &#125; printf("\nSum = %d\n", sum); return 0;&#125; 7-15 è®¡ç®—åœ†å‘¨çŽ‡æ ¹æ®ä¸‹é¢å…³ç³»å¼ï¼Œæ±‚åœ†å‘¨çŽ‡çš„å€¼ï¼Œç›´åˆ°æœ€åŽä¸€é¡¹çš„å€¼å°äºŽç»™å®šé˜ˆå€¼ã€‚${\pi\over2}=1+{1\over3}+{2!\over{3Ã—5}}+{3!\over{3Ã—5Ã—7}}+{\cdots}+{n!\over{3Ã—5Ã—7Ã—{\cdots}Ã—(2Ã—n+1)}}$ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå°äºŽ1çš„é˜ˆå€¼ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ»¡è¶³é˜ˆå€¼æ¡ä»¶çš„è¿‘ä¼¼åœ†å‘¨çŽ‡ï¼Œè¾“å‡ºåˆ°å°æ•°ç‚¹åŽ6ä½ã€‚ Sample Input &amp; Sample output Input:0.01 Output:3.132157 Analysisæœ¬é¢˜æ¯”è¾ƒç›´è§‚ï¼Œä½†éœ€è¦ç»†å¿ƒä¸€ç‚¹ã€‚å…ˆåˆ†æžä¸€ä¸‹ç»™å‡ºçš„å…³ç³»å¼çš„è§„å¾‹ï¼Œå·¦è¾¹å¸¸é‡ï¼Œæˆ‘ä»¬åªçœ‹å³è¾¹å°±è¡Œï¼›å‡è®¾å³è¾¹é¡¹æ•°æ˜¯ä»Ž1å¼€å§‹çš„ï¼Œé‚£ä¹ˆ$a_1=1$ï¼Œ$a_2={1\over3}$ï¼Œ$a_3={2!\over3Ã—5}$ï¼Œâ€¦ï¼ŒæŠŠ$a_1$å’Œ$a_2$æ¢ä¸ªå†™æ³•å°±æ˜¯$a_1={0!\over1}$ã€$a_2={1!\over{1Ã—3}}$ï¼Œè¿™ä¸‹å°±å¯ä»¥çœ‹å‡ºè§„å¾‹äº†ï¼Œä¸ŽåŽé¢çš„é€šé¡¹å…¬å¼æ˜¯ä¸€è‡´çš„ã€‚å¦‚æžœé¦–é¡¹çš„åˆ†å­ä»Ž0å¼€å§‹ï¼Œé‚£ä¹ˆå°±æ— æ³•é€šè¿‡å¾ªçŽ¯è‡ªåŠ¨å®Œæˆé˜¶ä¹˜çš„è®¡ç®—äº†ï¼ˆæˆ–è€…å•ç‹¬å†™ä¸€ä¸ªé˜¶ä¹˜å‡½æ•°ï¼Œè¿™æ ·å°±èƒ½ä»Ž0å¼€å§‹å–å€¼äº†ï¼‰ï¼Œæ‰€ä»¥æˆ‘ä»¬ç›´æŽ¥ä»Ž$a_1$å¼€å§‹è®¡ç®—ï¼Œè®©$\pi$çš„åˆå§‹å€¼å°±ä¸º1.0ï¼›è¾“å‡ºç»“æžœæ—¶ï¼Œåˆ«å¿˜è®°äº†è¦ä¹˜ä¸Š2å€ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float pi=1.0,denominator=3.0,member=1.0,each_item=0.0,i=2.0; float threshold; scanf("%f", &amp;threshold); // threshold=0.01; do&#123; each_item = member/denominator; pi+=each_item; member*=i; denominator*=(2*i+1); i++; &#125;while(each_item &gt; threshold); printf("%.6f\n", 2*pi); return 0;&#125; 7-16 æ±‚ç¬¦åˆç»™å®šæ¡ä»¶çš„æ•´æ•°é›†ç»™å®šä¸è¶…è¿‡6çš„æ­£æ•´æ•°Aï¼Œè€ƒè™‘ä»ŽAå¼€å§‹çš„è¿žç»­4ä¸ªæ•°å­—ã€‚è¯·è¾“å‡ºæ‰€æœ‰ç”±å®ƒä»¬ç»„æˆçš„æ— é‡å¤æ•°å­—çš„3ä½æ•°ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºAã€‚ Output Specificationè¾“å‡ºæ»¡è¶³æ¡ä»¶çš„çš„3ä½æ•°ï¼Œè¦æ±‚ä»Žå°åˆ°å¤§ï¼Œæ¯è¡Œ6ä¸ªæ•´æ•°ã€‚æ•´æ•°é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†è¡Œæœ«ä¸èƒ½æœ‰å¤šä½™ç©ºæ ¼ã€‚ Sample Input &amp; Sample output Input:2 Output:234 235 243 245 253 254324 325 342 345 352 354423 425 432 435 452 453523 524 532 534 542 543 AnalysisæŒ‰ç…§é¢˜ç›®çš„æ„æ€ï¼Œå°†éœ€è¦è¾“å‡ºçš„ä¸‰ä½æ•°ï¼Œåˆ†åˆ«è¾“å‡ºå³å¯ï¼›ä¹Ÿå¯ä»¥ç›´æŽ¥è¾“å‡ºä¸€ä¸ªç™¾ä½æ•°ï¼Œä½†æ˜¯é‚£æ ·éœ€è¦è®¡ç®—ï¼Œä¼šç¨å¾®éº»çƒ¦ä¸€ç‚¹ã€‚æŒ‰ç…§ä¸‹é¢çš„ä»£ç ï¼Œå½“ä¸åŒä½çš„æ•°å­—å­˜åœ¨ç›¸åŒçš„æ—¶å€™ï¼Œå°±ç”¨continue;è¯­å¥è·³å‡ºæœ¬æ¬¡å¾ªçŽ¯ï¼Œi==jçš„åˆ¤æ–­ä¹Ÿå¯ä»¥åœ¨ç¬¬ä¸‰å±‚å¾ªçŽ¯å†…åšï¼Œå³ï¼šæ”¹ä¸ºk==j || k==i || i==jï¼Œä½†å½“i==jçš„æ—¶å€™å°±ä¼šè¿è¡Œå¤šæ¬¡åˆ¤æ–­äº†ã€‚ Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,i,j,k,count; scanf("%d", &amp;A);// A=2; count=0; for(i=A; i&lt;A+4; i++) &#123; for(j=A; j&lt;A+4; j++)&#123; if(i == j) continue; else&#123; for(k=A; k&lt;A+4; k++) &#123; if(k==j || k==i) continue; else&#123; printf("%d%d%d", i, j, k); count++; if(count%6 == 0) printf("\n"); else printf(" "); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 7-17 çˆ¬åŠ¨çš„è •è™«ä¸€æ¡è •è™«é•¿1å¯¸ï¼Œåœ¨ä¸€å£æ·±ä¸ºNå¯¸çš„äº•çš„åº•éƒ¨ã€‚å·²çŸ¥è •è™«æ¯1åˆ†é’Ÿå¯ä»¥å‘ä¸Šçˆ¬Uå¯¸ï¼Œä½†å¿…é¡»ä¼‘æ¯1åˆ†é’Ÿæ‰èƒ½æŽ¥ç€å¾€ä¸Šçˆ¬ã€‚åœ¨ä¼‘æ¯çš„è¿‡ç¨‹ä¸­ï¼Œè •è™«åˆä¸‹æ»‘äº†Då¯¸ã€‚å°±è¿™æ ·ï¼Œä¸Šçˆ¬å’Œä¸‹æ»‘é‡å¤è¿›è¡Œã€‚è¯·é—®ï¼Œè •è™«éœ€è¦å¤šé•¿æ—¶é—´æ‰èƒ½çˆ¬å‡ºäº•ï¼Ÿè¿™é‡Œè¦æ±‚ä¸è¶³1åˆ†é’ŸæŒ‰1åˆ†é’Ÿè®¡ï¼Œå¹¶ä¸”å‡å®šåªè¦åœ¨æŸæ¬¡ä¸Šçˆ¬è¿‡ç¨‹ä¸­è •è™«çš„å¤´éƒ¨åˆ°è¾¾äº†äº•çš„é¡¶éƒ¨ï¼Œé‚£ä¹ˆè •è™«å°±å®Œæˆä»»åŠ¡äº†ã€‚åˆå§‹æ—¶ï¼Œè •è™«æ˜¯è¶´åœ¨äº•åº•çš„ï¼ˆå³é«˜åº¦ä¸º0ï¼‰ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­é¡ºåºç»™å‡º3ä¸ªæ­£æ•´æ•°Nã€Uã€Dï¼Œå…¶ä¸­D&lt;Uï¼ŒNä¸è¶…è¿‡100ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè •è™«çˆ¬å‡ºäº•çš„æ—¶é—´ï¼Œä»¥åˆ†é’Ÿä¸ºå•ä½ã€‚ Sample Input &amp; Sample output Input:12 3 1 Output:11 Analysisæ‰¾è§„å¾‹ï¼Œå…ˆè¦æ˜Žç¡®â€èš¯èš“â€æ•´ä¸ªçˆ¬è¡Œçš„è¿‡ç¨‹ï¼Œåœ¨ç¬¬ä¸€åˆ†é’Ÿä¼šçˆ¬è¡ŒUå¯¸ï¼Œç¬¬äºŒåˆ†é’Ÿä¼šä¸‹æ»‘Då¯¸ï¼Œç¬¬äºŒåˆ†é’Ÿå®ŒåŽï¼Œèš¯èš“ä¸€å…±çš„çˆ¬è¡Œè·ç¦»å°±æ˜¯U-Dï¼Œç¬¬ä¸‰åˆ†é’Ÿçš„æ—¶å€™ï¼Œèš¯èš“çˆ¬è¡ŒUå¯¸ï¼Œæ€»è·ç¦»æ˜¯2*U-Dï¼Œç¬¬å››åˆ†é’Ÿå°±æ˜¯2*U-2*Dâ€¦ã€‚å¯ä»¥å‘çŽ°ï¼ŒUå’ŒDçš„ç³»æ•°ä¹‹å’Œå°±æ˜¯å½“å‰çš„æ—¶åˆ»ï¼Œæ‰¾åˆ°è¿™ä¸ªè§„å¾‹ä¹‹åŽå°±å¥½åŠžäº†ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,U,D; scanf("%d%d%d", &amp;N, &amp;U, &amp;D); // N=12, U=3, D=1; int i,j,times; for(i=1, j=0; N&lt;=100; i++, j++) &#123; if(i*U - j*D &gt;= N)&#123; times = i+j; break; &#125; &#125; printf("%d\n", times); return 0;&#125; 7-18 äºŒåˆ†æ³•æ±‚å¤šé¡¹å¼å•æ ¹äºŒåˆ†æ³•æ±‚å‡½æ•°æ ¹çš„åŽŸç†ä¸ºï¼šå¦‚æžœè¿žç»­å‡½æ•°$f(x)$åœ¨åŒºé—´$[a,b]$çš„ä¸¤ä¸ªç«¯ç‚¹å–å€¼å¼‚å·ï¼Œå³$f(a)f(b)&lt;0$ï¼Œåˆ™å®ƒåœ¨è¿™ä¸ªåŒºé—´å†…è‡³å°‘å­˜åœ¨1ä¸ªæ ¹$r$ï¼Œå³$f(r)=0$ã€‚äºŒåˆ†æ³•çš„æ­¥éª¤ä¸ºï¼šæ£€æŸ¥åŒºé—´é•¿åº¦ï¼Œå¦‚æžœå°äºŽç»™å®šé˜ˆå€¼ï¼Œåˆ™åœæ­¢ï¼Œè¾“å‡ºåŒºé—´ä¸­ç‚¹$(a+b)/2$ï¼›å¦åˆ™å¦‚æžœ$f(a)f(b)&lt;0$ï¼Œåˆ™è®¡ç®—ä¸­ç‚¹çš„å€¼$f((a+b)/2)$ï¼›å¦‚æžœ$f((a+b)/2)$æ­£å¥½ä¸º0ï¼Œåˆ™$(a+b)/2$å°±æ˜¯è¦æ±‚çš„æ ¹ï¼›å¦åˆ™å¦‚æžœ$f((a+b)/2)$ä¸Ž$f(a)$åŒå·ï¼Œåˆ™è¯´æ˜Žæ ¹åœ¨åŒºé—´$[(a+b)/2,b]$ï¼Œä»¤$a=(a+b)/2$ï¼Œé‡å¤å¾ªçŽ¯ï¼›å¦‚æžœ$f((a+b)/2)$ä¸Ž$f(b)$åŒå·ï¼Œåˆ™è¯´æ˜Žæ ¹åœ¨åŒºé—´$[a,(a+b)/2]$ï¼Œä»¤$b=(a+b)/2$ï¼Œé‡å¤å¾ªçŽ¯ã€‚æœ¬é¢˜ç›®è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—ç»™å®š3é˜¶å¤šé¡¹å¼$f(x)=a_3x^3+a_2x^2+a_1x+a_0$åœ¨ç»™å®šåŒºé—´$[a,b]$å†…çš„æ ¹ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­é¡ºåºç»™å‡ºå¤šé¡¹å¼çš„4ä¸ªç³»æ•°$a_3$ã€$a_2$ã€$a_1$ã€$a_0$ï¼Œåœ¨ç¬¬2è¡Œä¸­é¡ºåºç»™å‡ºåŒºé—´ç«¯ç‚¹$a$å’Œ$b$ã€‚é¢˜ç›®ä¿è¯å¤šé¡¹å¼åœ¨ç»™å®šåŒºé—´å†…å­˜åœ¨å”¯ä¸€å•æ ¹ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¯¥å¤šé¡¹å¼åœ¨è¯¥åŒºé—´å†…çš„æ ¹ï¼Œç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ2ä½ã€‚ Sample Input &amp; Sample Output Input:3 -1 -3 1-0.5 0.5 Output:0.33 AnalysisäºŒåˆ†æ³•æ±‚å¤šé¡¹å¼å•æ ¹ï¼Œæ‰€ä¾æ®çš„åŽŸç†å…¶å®žæ˜¯å‡½æ•°çš„é›¶ç‚¹æ€§è´¨ï¼šå‡½æ•°é›¶ç‚¹ä¸¤è¾¹çš„å‡½æ•°å€¼æ˜¯å¼‚å·çš„ï¼Œæ‰€ä»¥é›¶ç‚¹ä¸¤è¾¹å‡½æ•°å€¼çš„ä¹˜ç§¯å°äºŽ0ã€‚æ˜Žç™½è¿™ä¸ªåŽŸç†ä¹‹åŽï¼Œæˆ‘ä»¬æŒ‰ç…§é¢˜ç›®ç»™çš„ç®—æ³•è¿›è¡Œè®¡ç®—å³å¯ï¼›æ—¢ç„¶é¢˜ç›®å·²ç»ç»™å‡ºäº†å‡½æ•°å¼ï¼Œå¯ä»¥ç›´æŽ¥å°è£…æˆä¸€ä¸ªä¸“é—¨æ±‚å€¼çš„å‡½æ•°ï¼Œå‡½æ•°çš„ç³»æ•°å°±ç”¨å…¨å±€å˜é‡æ¥ä¿å­˜å³å¯ï¼Œè¿™æ ·ä»£ç çš„ä¸»ä½“å°±å¾ˆæ¸…æ™°ï¼›f(left)å’Œf(right)è¿™ä¸¤ä¸ªå‡½æ•°å€¼ä¸º0çš„æƒ…å†µæ˜¯å•ç‹¬çš„ï¼Œå¹¶ä¸èƒ½ç”¨if-elseç»„æˆå¯¹ç«‹å…³ç³»ï¼Œæ³¨æ„é¢˜ç›®å¯¹ç²¾åº¦çš„è¦æ±‚æ˜¯å°æ•°ç‚¹åŽ2ä½ï¼Œæ‰€ä»¥å·¦ç«¯ç‚¹å’Œå³ç«¯ç‚¹çš„å·®å€¼è¦å¤§äºŽ0.01ï¼Œè‹¥æ²¡æœ‰è¿™ä¸ªæ¡ä»¶ï¼Œæäº¤æ—¶ä¼šè¶…æ—¶ã€‚ Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;float a3,a2,a1,a0;float Cal_polynomial(float n);int main(int argc, char const *argv[])&#123; float left,right,mid; scanf("%f %f %f %f %f %f", &amp;a3, &amp;a2, &amp;a1, &amp;a0, &amp;left, &amp;right); while(Cal_polynomial(left) * Cal_polynomial(right) &lt;= 0 &amp;&amp; (right-left) &gt; 0.01) &#123; if(Cal_polynomial(left) == 0)&#123; printf("%.2f\n", left); return 0; &#125; if(Cal_polynomial(right) == 0)&#123; printf("%.2f\n", right); return 0; &#125; mid=(left+right)/2; if(Cal_polynomial(left) * Cal_polynomial(mid) &gt; 0)&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; printf("%.2f\n", (right+left)/2); return 0;&#125;float Cal_polynomial(float n)&#123; float ret=0.0; ret = a3*n*n*n + a2*n*n + a1*n + a0; return ret;&#125; 7-19 æ”¯ç¥¨é¢é¢ä¸€ä¸ªé‡‡è´­å‘˜åŽ»é“¶è¡Œå…‘æ¢ä¸€å¼ yå…ƒfåˆ†çš„æ”¯ç¥¨ï¼Œç»“æžœå‡ºçº³å‘˜é”™ç»™äº†få…ƒyåˆ†ã€‚é‡‡è´­å‘˜ç”¨åŽ»äº†nåˆ†ä¹‹åŽæ‰å‘è§‰æœ‰é”™ï¼ŒäºŽæ˜¯æ¸…ç‚¹äº†ä½™é¢å°šæœ‰2yå…ƒ2fåˆ†ï¼Œé—®è¯¥æ”¯ç¥¨é¢é¢æ˜¯å¤šå°‘ï¼Ÿ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºå°äºŽ100çš„æ­£æ•´æ•°nã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰æ ¼å¼y.fè¾“å‡ºè¯¥æ”¯ç¥¨çš„åŽŸå§‹é¢é¢ã€‚å¦‚æžœæ— è§£ï¼Œåˆ™è¾“å‡ºNo Solutionã€‚ Sample Input &amp; Sample Output Input 1:23 Output 1:25.51 Input 2:22 Output 2:No Solution Analysisæœ¬é¢˜ä¹ä¸€çœ‹æŒºæ‡µé€¼çš„ðŸ˜“ï¼Œå…¶å®žæ˜¯é“æ•°å­¦é¢˜ã€‚å¤šè¯»å‡ éé¢˜ç›®ï¼Œå¯ä»¥åˆ—å‡ºæ–¹ç¨‹ï¼š100*f+y-n=200*y+2*f(è¿™é‡Œçš„å…ƒã€åˆ†åº”è¯¥å°±æ˜¯RMBä¸­çš„å•ä½äº†)ï¼ŒåŒ–ç®€å¾—ï¼š98*f-199*y=nï¼Œä¾é¢˜æ„ï¼Œn&lt;100ä¸”n&gt;0ï¼Œè¯´æ˜Ž98*f-199*y&gt;0ï¼Œè¿™é‡Œéœ€è¦æ”¾ç¼©ä¸€ä¸‹ï¼Œå³ï¼š98*f-199*y â‰ˆ 100*f-200*y = f-2*y &gt; 0ï¼Œå°±æ˜¯f&gt;2*yäº†ï¼Œè€Œfåœ¨æœ¬é¢˜ä¸­çš„å•ä½æ˜¯åˆ†ï¼Œæ‰€ä»¥0&lt;f&lt;100(èƒ½æƒ³åˆ°çš„å”¯ä¸€è§£é‡Šâ€¦)ï¼Œæ‰€ä»¥å°±å¾—åˆ°ï¼š0&lt;f&lt;100, 0&lt;y&lt;50ï¼Œè¿™å°±æ˜¯å¾ªçŽ¯çš„æ¡ä»¶ã€‚æœ‰ç‚¹å‘çˆ¹~ Code12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int y,f,n,flag=0; scanf("%d", &amp;n); // n=23; for(y=0; y&lt;50; y++) &#123; for(f=0; f&lt;100; f++) &#123; if(98*f - 199*y == n)&#123; printf("%d.%d\n", y, f); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-20 æ‰“å°ä¹ä¹å£è¯€è¡¨ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä¸‹ä¸‰è§’ä¹ä¹å£è¯€è¡¨ï¼š1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„ä¸€ä½æ­£æ•´æ•°Nï¼Œè¾“å‡ºä»Ž11åˆ°NNçš„éƒ¨åˆ†å£è¯€è¡¨ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ­£æ•´æ•°Nï¼ˆ1â‰¤Nâ‰¤9ï¼‰ã€‚ Output Specificationè¾“å‡ºä¸‹ä¸‰è§’N*Néƒ¨åˆ†å£è¯€è¡¨ï¼Œå…¶ä¸­ç­‰å·å³è¾¹æ•°å­—å 4ä½ã€å·¦å¯¹é½ã€‚ Sample Input &amp; Sample output Input:4 Output:12341*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 Analysisåˆ†æžä¸€ä¸‹ï¼Œä¹ä¹ä¹˜æ³•è¡¨çš„ç»„æˆï¼Œä¸¤ä¸ªå€¼å’Œè¿™ä¸¤ä¸ªå€¼çš„ä¹˜ç§¯ï¼Œä»Žè¿™é‡Œï¼Œåº”è¯¥å¯ä»¥æƒ³åˆ°åŒé‡å¾ªçŽ¯ï¼›åœ¨ä»”ç»†è§‚å¯Ÿä¸€ä¸‹æ ·ä¾‹ï¼Œç»„åŽçš„é¡¹ä¸­çš„å› å­ç­‰äºŽè¾“å…¥æ ·ä¾‹çš„Nå€¼çš„ï¼Œæ‰€ä»¥å¯ä»¥æŽ¨æ–­ï¼Œå› å­çš„å€¼æ˜¯å°äºŽç­‰äºŽNçš„ï¼›å¦å¤–ï¼Œè¿˜å¯ä»¥å‘çŽ°ï¼Œç¬¬äºŒä¸ªå› å­çš„å€¼æ˜¯å°äºŽç­‰äºŽç¬¬ä¸€ä¸ªå› å­çš„å€¼çš„ï¼›æŒ‰ç…§ä»¥ä¸Šçš„æ€è·¯ï¼Œåœ¨æ³¨æ„ä¸€ä¸‹è¾“å‡ºæ ¼å¼ï¼Œå°±å¯ä»¥æ‹¿ä¸‹è¿™é“é¢˜äº†ï¼Œæ³¨æ„è¾“å‡ºçš„æ ¼å¼ï¼Œæ¢è¡Œå¯ä»¥æ”¾åœ¨ç¬¬äºŒå±‚å¾ªçŽ¯å†…æ‰§è¡Œï¼Œæ¡ä»¶æ”¹ä¸ºj == iå³å¯ã€‚ Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,i,j; scanf("%d", &amp;N); // N=4; for(i=1; i&lt;=N; i++) &#123; for(j=1; j&lt;=i; j++)&#123; printf("%d*%d=%-4d", j, i, i*j); &#125; if(j-1 == i)&#123; printf("\n"); &#125; &#125; return 0;&#125; 7-21 æ±‚ç‰¹æ®Šæ–¹ç¨‹çš„æ­£æ•´æ•°è§£æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„æ­£æ•´æ•°Nï¼Œæ±‚æ–¹ç¨‹$X^2â€‹+Y^2=N$çš„å…¨éƒ¨æ­£æ•´æ•°è§£ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤10000ï¼‰ Output Specificationè¾“å‡ºæ–¹ç¨‹$X^2+Y^2=N$çš„å…¨éƒ¨æ­£æ•´æ•°è§£ï¼Œå…¶ä¸­Xâ‰¤Yã€‚æ¯ç»„è§£å 1è¡Œï¼Œä¸¤æ•°å­—é—´ä»¥1ç©ºæ ¼åˆ†éš”ï¼ŒæŒ‰Xçš„é€’å¢žé¡ºåºè¾“å‡ºã€‚å¦‚æžœæ²¡æœ‰è§£ï¼Œåˆ™è¾“å‡ºNo Solutionã€‚ Sample Input &amp; Sample Output Input 1:884 Output 1:10 2820 22 Input 2:11 Output 2:No Solution Analysisæ­¤é¢˜ä¸éš¾ï¼Œçœ‹é¢˜ç›®å½¢å¼ä¹Ÿæ˜¯é“æ•°å­¦é¢˜ï¼Œå¤§è‡´åˆ†æžä¸€ä¸‹ï¼ŒN = X^2+Y^2 &gt;= 2*x*yï¼Œæ—¢æœ‰2*x*y &lt;= N &lt;= 10000ï¼ŒåŒ–ç®€å¾—xy &lt;= 5000ï¼ŒåˆçŸ¥Nçš„æœ€å¤§å€¼æ˜¯10000ï¼Œå¼€æ–¹æ˜¯100ï¼Œè€ŒXå’ŒYçš„å¹³æ–¹ä¹‹å’Œå°äºŽç­‰äºŽNï¼Œæ‰€ä»¥Xå’ŒYéƒ½ä¸å¤§äºŽ100ï¼›ä¾æ®é¢˜ç›®çš„è¦æ±‚ï¼Œéœ€è¦æŒ‰ç…§Xé€’å¢žçš„é¡ºåºè¿›è¡Œè¾“å‡ºï¼Œæ‰€ä»¥ç›´æŽ¥ä»¥Yä¸ºæœ€å¤§å€¼ï¼ŒXä»Žæœ€å°å¼€å§‹å–å€¼å°±å¯ä»¥äº†ï¼ˆä¹Ÿæœ‰å…¶ä»–åšæ³•ï¼‰ã€‚ä¹‹æ‰€ä»¥å†™break;çš„åŽŸå› æ˜¯ï¼šåœ¨è¿™é“é¢˜ç›®ä¸­ï¼Œå½“Xå’ŒNç¡®å®šåŽï¼ŒYä¹Ÿæ˜¯ç¡®å®šçš„ï¼ŒåŒç†Yå’ŒNç¡®å®šåŽï¼ŒXä¹Ÿæ˜¯ç¡®å®šçš„äº†ã€‚ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N; scanf("%d", &amp;N);// N=884; int X,Y,flag=0; for(Y=100; Y&gt;0; Y--) &#123; for(X=1; X&lt;=Y; X++) &#123; if(X*X + Y*Y == N &amp;&amp; (X*Y) &lt;= 5000)&#123; printf("%d %d\n", X, Y); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-22 é¾Ÿå…”èµ›è·‘ä¹Œé¾Ÿä¸Žå…”å­è¿›è¡Œèµ›è·‘ï¼Œè·‘åœºæ˜¯ä¸€ä¸ªçŸ©åž‹è·‘é“ï¼Œè·‘é“è¾¹å¯ä»¥éšåœ°è¿›è¡Œä¼‘æ¯ã€‚ä¹Œé¾Ÿæ¯åˆ†é’Ÿå¯ä»¥å‰è¿›3ç±³ï¼Œå…”å­æ¯åˆ†é’Ÿå‰è¿›9ç±³ï¼›å…”å­å«Œä¹Œé¾Ÿè·‘å¾—æ…¢ï¼Œè§‰å¾—è‚¯å®šèƒ½è·‘èµ¢ä¹Œé¾Ÿï¼ŒäºŽæ˜¯ï¼Œæ¯è·‘10åˆ†é’Ÿå›žå¤´çœ‹ä¸€ä¸‹ä¹Œé¾Ÿï¼Œè‹¥å‘çŽ°è‡ªå·±è¶…è¿‡ä¹Œé¾Ÿï¼Œå°±åœ¨è·¯è¾¹ä¼‘æ¯ï¼Œæ¯æ¬¡ä¼‘æ¯30åˆ†é’Ÿï¼Œå¦åˆ™ç»§ç»­è·‘10åˆ†é’Ÿï¼›è€Œä¹Œé¾Ÿéžå¸¸åŠªåŠ›ï¼Œä¸€ç›´è·‘ï¼Œä¸ä¼‘æ¯ã€‚å‡å®šä¹Œé¾Ÿä¸Žå…”å­åœ¨åŒä¸€èµ·ç‚¹åŒä¸€æ—¶åˆ»å¼€å§‹èµ·è·‘ï¼Œè¯·é—®Tåˆ†é’ŸåŽä¹Œé¾Ÿå’Œå…”å­è°è·‘å¾—å¿«ï¼Ÿ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºæ¯”èµ›æ—¶é—´Tï¼ˆåˆ†é’Ÿï¼‰ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºæ¯”èµ›çš„ç»“æžœï¼šä¹Œé¾Ÿèµ¢è¾“å‡º@_@ï¼Œå…”å­èµ¢è¾“å‡º^_^ï¼Œå¹³å±€åˆ™è¾“å‡º-_-ï¼›åŽè·Ÿ1ç©ºæ ¼ï¼Œå†è¾“å‡ºèƒœåˆ©è€…è·‘å®Œçš„è·ç¦»ã€‚ Sample Input &amp; Sample output Input:242 Output:@_@ 726 Analysisè¿™é“é¢˜çš„éš¾ç‚¹åœ¨å¦‚ä½•è®¡ç®—å…”å­åœ¨Tæ—¶é—´å†…è·‘è¿‡çš„è·ç¦»ã€‚å…ˆçœ‹ä¹Œé¾Ÿï¼Œä¹Œé¾Ÿåœ¨Tæ—¶é—´å†…è·‘è¿‡çš„è·ç¦»æ¯”è¾ƒç®€å•ï¼Œå› ä¸ºä¹Œé¾Ÿæ˜¯ä¸ä¼šä¼‘æ¯çš„ï¼Œæ‰€ä»¥å…¶è·ç¦»å°±æ˜¯å…¶é€Ÿåº¦å’ŒTçš„ä¹˜ç§¯ï¼›è€Œå…”å­ä¼šä¼‘æ¯ï¼Œå¹¶ä¸”æ˜¯æ¯éš”10åˆ†é’Ÿç¡®è®¤æ¯”ä¹Œé¾Ÿå¿«åŽä¼‘æ¯ï¼Œæ‰€ä»¥ï¼Œéœ€è¦åœ¨æ¯ä¸ªä»¥10åˆ†é’Ÿä¸ºæ—¶é—´é—´éš”çš„æ—¶é—´ç‚¹è¿›è¡Œåˆ¤æ–­ï¼Œä¸Žä¹‹è€Œæ¥çš„å¦å¤–ä¸€ä¸ªé—®é¢˜å°±æ˜¯å…”å­ä¸æ˜¯ä¼‘æ¯10åˆ†é’Ÿï¼Œè€Œæ˜¯ä¼‘æ¯30åˆ†é’Ÿï¼Œæ‰€ä»¥ï¼Œè¿˜éœ€è¦ä¸€ä¸ªè¡¨ç¤ºå…”å­ä»ç„¶åœ¨ä¼‘æ¯çš„æ ‡å¿—ä½ï¼Œè¿™ä¸ªæ ‡å¿—ä½ä¼šåœ¨ä¹Œé¾Ÿå‰è¿›ï¼Œå…”å­ä¼‘æ¯æ—¶ï¼Œè‡ªåŠ¨å‡å°‘ã€‚å½“å‡å°‘åˆ°0æ—¶ï¼Œå…”å­ä¼šå†æ¬¡ç¡®è®¤æ˜¯å¦è¶…è¿‡ä¹Œé¾Ÿã€‚è¾“å‡ºç»“æžœæ—¶ï¼Œæ³¨æ„å¹³å±€çš„æ—¶å€™ä¹Ÿè¦è¾“å‡ºè·‘å®Œçš„è·ç¦»ï¼›å¹¶ä¸”æ—¶é—´è¦ä»Ž0æ—¶åˆ»å¼€å§‹ï¼Œå³æ—¶é—´åŒºé—´ä¸º$[0,T-1]$ï¼Œè‹¥åŒºé—´ä¸º$[1,T]$ï¼Œå°½ç®¡åŒºé—´é•¿åº¦æ—¶ä¸€è‡´çš„ï¼Œåœ¨30åˆ†é’Ÿæ—¶ï¼Œå…”å­çš„è·ç¦»å°±æ˜¯81ï¼Œä¹Œé¾Ÿçš„è·ç¦»å°±æ˜¯90äº†ï¼Œä½†å®žé™…ä¸Šåº”è¯¥æ˜¯ç›¸ç­‰çš„ï¼Œå³å¹³å±€ã€‚ Code12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int rabbit_dis=0,turtle_dis=0,rabbit_spd=9,turtle_spd=3,T; scanf("%d", &amp;T); // T=30; int i,rabbit_on=1,break_times=0; for(i=0; i&lt;T; i++) &#123; if(i%10 == 0)&#123; if(rabbit_dis &gt; turtle_dis &amp;&amp; break_times == 0)&#123; rabbit_on=0; break_times=30; &#125;else&#123; rabbit_on=1; &#125; &#125; if(rabbit_on &amp;&amp; break_times == 0)&#123; rabbit_dis+=rabbit_spd; &#125; turtle_dis+=turtle_spd; if(break_times)&#123; break_times--; &#125; &#125; if(turtle_dis &gt; rabbit_dis)&#123; printf("@_@ %d\n", turtle_dis); &#125;else if(turtle_dis == rabbit_dis)&#123; printf("-_- %d\n", turtle_dis); &#125;else&#123; printf("^_^ %d\n", rabbit_dis); &#125; return 0;&#125; 7-23 å¸å€¼è½¬æ¢è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼ˆä½æ•°ä¸è¶…è¿‡9ä½ï¼‰ä»£è¡¨ä¸€ä¸ªäººæ°‘å¸å€¼ï¼ˆå•ä½ä¸ºå…ƒï¼‰ï¼Œè¯·è½¬æ¢æˆè´¢åŠ¡è¦æ±‚çš„å¤§å†™ä¸­æ–‡æ ¼å¼ã€‚å¦‚23108å…ƒï¼Œè½¬æ¢åŽå˜æˆâ€œè´°ä¸‡åä»Ÿå£¹ç™¾é›¶æŒâ€å…ƒã€‚ä¸ºäº†ç®€åŒ–è¾“å‡ºï¼Œç”¨å°å†™è‹±æ–‡å­—æ¯a-jé¡ºåºä»£è¡¨å¤§å†™æ•°å­—0-9ï¼Œç”¨Sã€Bã€Qã€Wã€Yåˆ†åˆ«ä»£è¡¨æ‹¾ã€ç™¾ã€ä»Ÿã€ä¸‡ã€äº¿ã€‚äºŽæ˜¯23108å…ƒåº”è¢«è½¬æ¢è¾“å‡ºä¸ºâ€œcWdQbBaiâ€å…ƒã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡9ä½çš„éžè´Ÿæ•´æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè½¬æ¢åŽçš„ç»“æžœã€‚æ³¨æ„â€œé›¶â€çš„ç”¨æ³•å¿…é¡»ç¬¦åˆä¸­æ–‡ä¹ æƒ¯ã€‚ Sample Input &amp; Sample output Input 1:813227345 Output 1:iYbQdBcScWhQdBeSf Input 2:6900 Output 2:gQjB Analysisè¿™é“é¢˜æœ‰ç‚¹éš¾ðŸ˜‘ï¼Œå€Ÿé‰´äº†ä¸€ä¸‹ccDLIyyçš„æ€è·¯ï¼Œå¹¶ä¿®æ”¹äº†å…¶ä¸­ä¸€äº›ä»£ç ã€‚å¦‚æžœæœ¬é¢˜åªæ˜¯å°†è¾“å…¥çš„æ•°å­—çš„æ¯ä¸€ä½æ‹†åˆ†å‡ºæ¥çš„è¯ï¼Œå°±ååˆ†ç®€å•ï¼Œä½†æ˜¯è¿˜éœ€è¦æŒ‰ç…§ä¸­æ–‡ä¹ æƒ¯è¾“å‡ºè¿™äº›æ•°å­—çš„è¯»æ³•ï¼Œå°±æ¯”è¾ƒéº»çƒ¦äº†ã€‚é¦–å…ˆï¼Œéœ€è¦ä¸€ä¸ªæ•°ç»„æ¥å•ç‹¬å­˜æ”¾æ¯ä¸€ä½æ•°ï¼Œå› ä¸ºï¼Œå¦‚æžœä¸è¿™æ ·ï¼Œå°±æ— æ³•å¯¹ä¸­æ–‡ä¹ æƒ¯è¿›è¡Œåˆ¤æ–­äº†(å³å½“å‰ä½ä¸Šçš„æ•°å­—éž0ï¼Œå‰ä¸€ä½æˆ–è€…åŽä¸€ä½ä¸º0çš„æƒ…å†µä¸‹ï¼Œæ­¤æ—¶çš„è¯»æ³•)ï¼›æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œä¸å¦¨ç›´æŽ¥ç”¨æ•°ç»„å»ºç«‹èµ·æ•°å­—å’Œå­—æ¯çš„æ˜ å°„å…³ç³»ï¼Œè¿™æ ·åŽé¢è°ƒç”¨ä¹Ÿæ–¹ä¾¿ä¸€äº›(ä¸å¾—ä¸è¯´ï¼Œè¿™ä¸ªæƒ³æ³•å¾ˆé«˜æ˜Žä¹Ÿå¾ˆçœäº‹)ï¼›å¦å¤–ï¼Œåœ¨å†™ä»£ç ä¹‹å‰ï¼Œå…ˆå¤§æ¦‚åˆ†æžä¸€ä¸‹å¹³å¸¸æˆ‘ä»¬éƒ½è¿™äº›æ•°å­—çš„è¯»æ³•ï¼š23108æ˜¯è¯»ä½œäºŒä¸‡ä¸‰åƒä¸€ç™¾é›¶å…«ï¼Œ813227345æ˜¯è¯»ä½œå…«äº¿ä¸€åƒä¸‰ç™¾äºŒåäºŒä¸‡ä¸ƒåƒä¸‰ç™¾å››åäº”ï¼Œä»Žè¿™é‡Œï¼Œå¯ä»¥çœ‹å‡ºï¼Œä¸‡æ˜¯åœ¨æ•°å­—ä½æ•°å¤§äºŽç­‰äºŽ5çš„æ—¶å€™æ‰ä¼šè¾“å‡ºï¼Œè€Œäº¿æ˜¯åœ¨æ•°å­—ä½æ•°å¤§äºŽç­‰äºŽ9çš„æ—¶å€™æ‰ä¼šè¾“å‡ºï¼Œåœ¨æ¯å››ä½å†…ï¼Œè¿›è¡Œè¾“å‡ºçš„æ ¼å¼å­—ç¬¦éƒ½æ˜¯åã€ç™¾å’Œåƒï¼Œæ‰€ä»¥ï¼Œéœ€è¦æ ¹æ®ä½æ•°è¿›è¡Œä¸åŒæƒ…å†µçš„åˆ¤æ–­ã€‚å¦å¤–ï¼Œåœ¨ä¸‹é¢çš„ä»£ç ä¸­å¯¹äºŽ100000001è¿™ç§æƒ…å†µè¾“å‡ºçš„ç»“æžœæ˜¯ä¸€äº¿é›¶é›¶é›¶ä¸€ï¼Œå¯¹äºŽ10è¿™ç§æƒ…å†µè¾“å‡ºçš„ç»“æžœæ˜¯ä¸€åã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;char num2letter[11]="abcdefghij";char units[4]="QBS";void exchange(int num[], int n);int main(int argc, char const *argv[])&#123; char number[10]; scanf("%s", number); int i,len=strlen(number); int num[9]=&#123;0&#125;; for(i=0; i&lt;len; i++)&#123; num[i]=number[i] - '0'; &#125; if(len &lt;= 4)&#123; exchange(num, len-1); &#125;else if(len &lt;= 8)&#123; exchange(num, len-5); printf("W"); exchange(num+len-4, 3); &#125;else&#123; printf("%cY", num2letter[num[0]]); exchange(num+1, 3); if(num[1]!=0 &amp;&amp; num[2]!=0 &amp;&amp; num[3]!=0 &amp;&amp; num[4]!=0)&#123; printf("W"); &#125; if(num[len-4] == 0)&#123; printf("%c", num2letter[0]); &#125; exchange(num+5, 3); &#125; return 0;&#125;void exchange(int num[], int n)&#123; int index = 0; while(num[index] == 0)&#123; index++; &#125; if(num[index-1] == 0 &amp;&amp; index != 0)&#123; printf("%c", num2letter[0]); &#125; while(index &lt;= n) &#123; if(num[index] != 0 &amp;&amp; index &lt;= n)&#123; if(index != n)&#123; printf("%c%c", num2letter[num[index]], units[4-n-1+index]); &#125;else&#123; printf("%c", num2letter[num[index]]); &#125; &#125;else if(num[index] == 0 &amp;&amp; num[index+1] != 0 &amp;&amp; index &lt;= n-1)&#123; printf("%c", num2letter[0]); &#125; index++; &#125;&#125; 7-24 çº¦åˆ†æœ€ç®€åˆ†å¼åˆ†æ•°å¯ä»¥è¡¨ç¤ºä¸ºåˆ†å­/åˆ†æ¯çš„å½¢å¼ã€‚ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œè¦æ±‚ç”¨æˆ·è¾“å…¥ä¸€ä¸ªåˆ†æ•°ï¼Œç„¶åŽå°†å…¶çº¦åˆ†ä¸ºæœ€ç®€åˆ†å¼ã€‚æœ€ç®€åˆ†å¼æ˜¯æŒ‡åˆ†å­å’Œåˆ†æ¯ä¸å…·æœ‰å¯ä»¥çº¦åˆ†çš„æˆåˆ†äº†ã€‚å¦‚6/12å¯ä»¥è¢«çº¦åˆ†ä¸º1/2ã€‚å½“åˆ†å­å¤§äºŽåˆ†æ¯æ—¶ï¼Œä¸éœ€è¦è¡¨è¾¾ä¸ºæ•´æ•°åˆåˆ†æ•°çš„å½¢å¼ï¼Œå³11/8è¿˜æ˜¯11/8ï¼›è€Œå½“åˆ†å­åˆ†æ¯ç›¸ç­‰æ—¶ï¼Œä»ç„¶è¡¨è¾¾ä¸º1/1çš„åˆ†æ•°å½¢å¼ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªåˆ†æ•°ï¼Œåˆ†å­å’Œåˆ†æ¯ä¸­é—´ä»¥æ–œæ /åˆ†éš”ï¼Œå¦‚ï¼š12/34è¡¨ç¤º34åˆ†ä¹‹12ã€‚åˆ†å­å’Œåˆ†æ¯éƒ½æ˜¯æ­£æ•´æ•°ï¼ˆä¸åŒ…å«0ï¼Œå¦‚æžœä¸æ¸…æ¥šæ­£æ•´æ•°çš„å®šä¹‰çš„è¯ï¼‰ã€‚æç¤ºï¼šåœ¨scanfçš„æ ¼å¼å­—ç¬¦ä¸²ä¸­åŠ å…¥/ï¼Œè®©scanfæ¥å¤„ç†è¿™ä¸ªæ–œæ ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªåˆ†æ•°å¯¹åº”çš„æœ€ç®€åˆ†å¼ï¼Œæ ¼å¼ä¸Žè¾“å…¥çš„ç›¸åŒï¼Œå³é‡‡ç”¨åˆ†å­/åˆ†æ¯çš„å½¢å¼è¡¨ç¤ºåˆ†æ•°ã€‚å¦‚5/6è¡¨ç¤º6åˆ†ä¹‹5ã€‚ Sample Input &amp; Sample output Input:66/120 Output:11/20 Analysisè¿™é“é¢˜æ¯”è¾ƒç®€å•ï¼Œåªè¦çŸ¥é“åˆ†å­/åˆ†æ¯çº¦åˆ†åˆ°æœ€ç®€å½¢å¼ç›´æŽ¥é™¤ä»¥äºŒè€…çš„æœ€å¤§å…¬çº¦æ•°å³å¯ã€‚æ‰€ä»¥ï¼Œç›´æŽ¥æ±‚æœ€å¤§å…¬çº¦æ•°å³å¯ï¼Œä½¿ç”¨è¾—è½¬ç›¸é™¤æ³•æˆ–æ›´ç›¸å‡æŸæ³•çš†å¯ï¼Œé€’å½’ä¸Žå¦ä¹Ÿçš†å¯ã€‚ Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int gcd(int a, int b);int main(int argc, char const *argv[])&#123; int member,denominator; scanf("%d/%d", &amp;member, &amp;denominator); // member=66, denominator=120; printf("%d/%d\n", member/gcd(member, denominator), denominator/gcd(member, denominator)); return 0;&#125;int gcd(int a, int b)&#123; if(a &gt; b) return gcd(b, a); int temp; while(a) &#123; temp=b%a; b=a; a=temp; &#125; return b; /* other method: use recursion. return a==0?b:gcd(b%a, a); */&#125; 7-25 å¿µæ•°å­—è¾“å…¥ä¸€ä¸ªæ•´æ•°ï¼Œè¾“å‡ºæ¯ä¸ªæ•°å­—å¯¹åº”çš„æ‹¼éŸ³ã€‚å½“æ•´æ•°ä¸ºè´Ÿæ•°æ—¶ï¼Œå…ˆè¾“å‡ºfuå­—ã€‚åä¸ªæ•°å­—å¯¹åº”çš„æ‹¼éŸ³å¦‚ä¸‹ï¼š123456789100: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€ä¸ªæ•´æ•°ï¼Œå¦‚ï¼š1234ã€‚æç¤ºï¼šæ•´æ•°åŒ…æ‹¬è´Ÿæ•°ã€é›¶å’Œæ­£æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™ä¸ªæ•´æ•°å¯¹åº”çš„æ‹¼éŸ³ï¼Œæ¯ä¸ªæ•°å­—çš„æ‹¼éŸ³ä¹‹é—´ç”¨ç©ºæ ¼åˆ†å¼€ï¼Œè¡Œæœ«æ²¡æœ‰æœ€åŽçš„ç©ºæ ¼ã€‚å¦‚yi er san siã€‚ Sample Input &amp; Sample output Input:-600 Output:fu liu ling ling Analysisæ­¤é¢˜ä¸éš¾ï¼Œåªéœ€å¯¹æ³¨æ„è´Ÿæ•°å’Œè¾“å‡ºçš„æ ¼å¼å³å¯ï¼›å¯ä»¥ç›´æŽ¥å½“ä½œå­—ç¬¦å¤„ç†ï¼Œä¹Ÿå¯ä»¥ç”¨æ•°ä½æ‹†åˆ†çš„æ€è·¯æ¥åšï¼Œå¯èƒ½ç¨å¾®ä¼šéº»çƒ¦ä¸€ç‚¹ï¼›å¯ä»¥ä½¿ç”¨æŒ‡é’ˆï¼Œä¹Ÿå¯ä»¥ä¸ä½¿ç”¨æŒ‡é’ˆã€‚ Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char num[100]; scanf("%s", num); char *p = num; if(*p == '-')&#123; printf("fu "); p++; &#125; for(; *p != '\0'; p++) &#123; switch(*p) &#123; case '0': printf("ling");break; case '1': printf("yi");break; case '2': printf("er");break; case '3': printf("san");break; case '4': printf("si");break; case '5': printf("wu");break; case '6': printf("liu");break; case '7': printf("qi");break; case '8': printf("ba");break; case '9': printf("jiu");break; default: continue; &#125; if(*(p+1) == '\0') printf("\n"); else printf(" "); &#125; return 0;&#125; 7-26 å•è¯é•¿åº¦ä½ çš„ç¨‹åºè¦è¯»å…¥ä¸€è¡Œæ–‡æœ¬ï¼Œå…¶ä¸­ä»¥ç©ºæ ¼åˆ†éš”ä¸ºè‹¥å¹²ä¸ªå•è¯ï¼Œä»¥.ç»“æŸã€‚ä½ è¦è¾“å‡ºæ¯ä¸ªå•è¯çš„é•¿åº¦ã€‚è¿™é‡Œçš„å•è¯ä¸Žè¯­è¨€æ— å…³ï¼Œå¯ä»¥åŒ…æ‹¬å„ç§ç¬¦å·ï¼Œæ¯”å¦‚it&#39;sç®—ä¸€ä¸ªå•è¯ï¼Œé•¿åº¦ä¸º4ã€‚æ³¨æ„ï¼Œè¡Œä¸­å¯èƒ½å‡ºçŽ°è¿žç»­çš„ç©ºæ ¼ï¼›æœ€åŽçš„.ä¸è®¡ç®—åœ¨å†…ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­ç»™å‡ºä¸€è¡Œæ–‡æœ¬ï¼Œä»¥.ç»“æŸæç¤ºï¼šç”¨scanf(&quot;%c&quot;,...);æ¥è¯»å…¥ä¸€ä¸ªå­—ç¬¦ï¼Œç›´åˆ°è¯»åˆ°.ä¸ºæ­¢ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºè¿™è¡Œæ–‡æœ¬å¯¹åº”çš„å•è¯çš„é•¿åº¦ï¼Œæ¯ä¸ªé•¿åº¦ä¹‹é—´ä»¥ç©ºæ ¼éš”å¼€ï¼Œè¡Œæœ«æ²¡æœ‰æœ€åŽçš„ç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:Itâ€™s great to see you here. Output:4 5 2 3 3 4 Analysisæœ¬é¢˜ä¸éš¾ï¼Œå¯¹æ¯ä¸€ä¸ªå•è¯çš„å­—ç¬¦è¿›è¡ŒéåŽ†å³å¯ï¼Œæ¯æ¬¡æ‰«æåˆ°ç©ºæ ¼ï¼Œå°±è·³è¿‡ï¼Œä¸€æ—¦æ‰«æåˆ°ä¸‹ä¸€ä¸ªå•è¯çš„ç¬¬ä¸€ä¸ªå­—æ¯ï¼Œå°±è¾“å‡ºä¸Šä¸€ä¸ªå•è¯çš„é•¿åº¦ã€‚æ³¨æ„æ ¼å¼ï¼Œç©ºå¥å­ä¸éœ€è¦è¾“å‡º0ï¼Œç›´æŽ¥è¾“å‡º\nå³å¯ã€‚ Code123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int length=0,flag=0; char ch; while((ch=getchar()) != '.') &#123; if(ch != ' ')&#123; if(length &gt; 0 &amp;&amp; flag &gt; 0)&#123; printf("%d ", length); length=0; &#125; length++; flag=0; &#125; if(ch == ' ') flag++; &#125; if(length &gt; 0) printf("%d\n", length); else printf("0\n"); return 0;&#125; 7-27 å†’æ³¡æ³•æŽ’åºå°†Nä¸ªæ•´æ•°æŒ‰ä»Žå°åˆ°å¤§æŽ’åºçš„å†’æ³¡æŽ’åºæ³•æ˜¯è¿™æ ·å·¥ä½œçš„ï¼šä»Žå¤´åˆ°å°¾æ¯”è¾ƒç›¸é‚»ä¸¤ä¸ªå…ƒç´ ï¼Œå¦‚æžœå‰é¢çš„å…ƒç´ å¤§äºŽå…¶ç´§éšçš„åŽé¢å…ƒç´ ï¼Œåˆ™äº¤æ¢å®ƒä»¬ã€‚é€šè¿‡ä¸€éæ‰«æï¼Œåˆ™æœ€åŽä¸€ä¸ªå…ƒç´ å¿…å®šæ˜¯æœ€å¤§çš„å…ƒç´ ã€‚ç„¶åŽç”¨åŒæ ·çš„æ–¹æ³•å¯¹å‰Nâˆ’1ä¸ªå…ƒç´ è¿›è¡Œç¬¬äºŒéæ‰«æã€‚ä¾æ­¤ç±»æŽ¨ï¼Œæœ€åŽåªéœ€å¤„ç†ä¸¤ä¸ªå…ƒç´ ï¼Œå°±å®Œæˆäº†å¯¹Nä¸ªæ•°çš„æŽ’åºã€‚æœ¬é¢˜è¦æ±‚å¯¹ä»»æ„ç»™å®šçš„Kï¼ˆ&lt;Nï¼‰ï¼Œè¾“å‡ºæ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœæ•°åˆ—ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºNå’ŒKï¼ˆ1â‰¤K&lt;Nâ‰¤100ï¼‰ï¼Œåœ¨ç¬¬2è¡Œä¸­ç»™å‡ºNä¸ªå¾…æŽ’åºçš„æ•´æ•°ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå†’æ³¡æŽ’åºæ³•æ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœæ•°åˆ—ï¼Œæ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ï¼Œä½†æœ«å°¾ä¸å¾—æœ‰å¤šä½™ç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:6 22 3 5 1 6 4 Output:2 1 3 4 5 6 Analysisæ­¤é¢˜ä¸éš¾ï¼Œç®—æ˜¯å¸®åŠ©ç†Ÿæ‚‰å†’æ³¡æŽ’åºç®—æ³•çš„é¢˜å§ï¼ŒæŒ‰ç…§é¢˜ç›®ç»™å‡ºçš„ç®—æ³•ï¼Œä½¿ç”¨ä¸¤å±‚å¾ªçŽ¯ï¼Œç›´æŽ¥è¿›è¡Œå¤„ç†å³å¯ã€‚æ³¨æ„ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œåœ¨äº¤æ¢ä¸¤ä¸ªç›¸é‚»çš„å…ƒç´ çš„æ—¶å€™ï¼Œåªèƒ½äº¤æ¢æ•´ä¸ªæ•°ç»„å†…çš„å…ƒç´ ã€‚å¦å¤–ï¼ŒæŒ‰ç…§ä¸‹é¢çš„ä»£ç ï¼Œå¦‚æžœä¸åŠ æ¡ä»¶j+1 &lt; Nï¼Œå°†6æŽ’åˆ°æœ€åŽé¢åŽï¼Œæ•°å­—6ä»ç„¶ä¼šå’Œå…¶ä¸‹ä¸€ä½è¿›è¡Œäº¤æ¢ã€‚æˆ–è€…ä¸åŠ æ¡ä»¶j+1 &lt; Nï¼Œå°±éœ€è¦å°†ç¬¬äºŒå±‚å¾ªçŽ¯çš„æ¡ä»¶æ”¹ä¸ºj&lt;N-i Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); int array[105]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%d", &amp;array[i]); &#125; for(i=0; i&lt;K; i++) &#123; int temp=0; for(j=0; j&lt;N; j++) /*j&lt;N -&gt; j&lt;N-i-1*/ &#123; if(array[j] &gt; array[j+1] &amp;&amp; j+1 &lt; N)&#123; /*delete the "&amp;&amp; j+1 &lt; N"*/ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; if(i == N-1) printf("%d\n", array[i]); else printf("%d ", array[i]); &#125; return 0;&#125; 7-28 çŒ´å­é€‰å¤§çŽ‹ä¸€ç¾¤çŒ´å­è¦é€‰æ–°çŒ´çŽ‹ã€‚æ–°çŒ´çŽ‹çš„é€‰æ‹©æ–¹æ³•æ˜¯ï¼šè®©Nåªå€™é€‰çŒ´å­å›´æˆä¸€åœˆï¼Œä»ŽæŸä½ç½®èµ·é¡ºåºç¼–å·ä¸º1~Nå·ã€‚ä»Žç¬¬1å·å¼€å§‹æŠ¥æ•°ï¼Œæ¯è½®ä»Ž1æŠ¥åˆ°3ï¼Œå‡¡æŠ¥åˆ°3çš„çŒ´å­å³é€€å‡ºåœˆå­ï¼ŒæŽ¥ç€åˆä»Žç´§é‚»çš„ä¸‹ä¸€åªçŒ´å­å¼€å§‹åŒæ ·çš„æŠ¥æ•°ã€‚å¦‚æ­¤ä¸æ–­å¾ªçŽ¯ï¼Œæœ€åŽå‰©ä¸‹çš„ä¸€åªçŒ´å­å°±é€‰ä¸ºçŒ´çŽ‹ã€‚è¯·é—®æ˜¯åŽŸæ¥ç¬¬å‡ å·çŒ´å­å½“é€‰çŒ´çŽ‹ï¼Ÿ Input Specificationè¾“å‡ºåœ¨ä¸€è¡Œä¸­ç»™ä¸€ä¸ªæ­£æ•´æ•°N(â‰¤1000)ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå½“é€‰çŒ´çŽ‹çš„ç¼–å·ã€‚ Sample Input &amp; Sample Output Input:11 Output:7 Analysisè¿™é“é¢˜ï¼Œå±žäºŽâ€œå¥—è·¯é¢˜â€ï¼Œå®žè´¨æ˜¯â€œçº¦ç‘Ÿå¤«çŽ¯â€é—®é¢˜ï¼›ä»¥ä¸‹çš„ä»£ç ä»‹ç»äº†ä¸‰ç§æ–¹æ³•ï¼šå›žæº¯æ³•(ä¸¥æ ¼æ„ä¹‰ä¸Šä¹Ÿè®¸ä¸æ˜¯)ã€é€’å½’å’Œè¿­ä»£ï¼Œåˆ†åˆ«å‚è€ƒäº†liuxuquan_ã€Little_Swordå’Œd4shmançš„ä»£ç ã€‚æ„Ÿè§‰ä½¿ç”¨å›žæº¯æ³•æ˜¯æœ€å®¹æ˜“ç†è§£çš„ï¼Œå¯¹äºŽä½¿ç”¨é€’å½’å’Œè¿­ä»£çš„æ–¹æ³•ï¼ŒåŽŸç†æ˜¯ä¸€æ ·çš„ï¼Œç†è§£ä¸€ç§äº†ï¼Œå¦å¤–ä¸€ç§ä¹Ÿå°±æ²¡é—®é¢˜äº†ï¼›å¥½åƒè¿˜å¯ä»¥é€šè¿‡å…¶ä»–çš„æ–¹å¼æ¥åšï¼Œè¿™é‡Œæš‚æ—¶å…ˆä¸æ·±ç©¶ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define maxn 1005int josephus_recursion(int n, int m);int main(int argc, char const *argv[])&#123; /* method 1: use backtracking int N; scanf("%d", &amp;N); // N=11; int i,monkey_array[maxn]=&#123;0&#125;; for(i=1; i&lt;=N; i++)&#123; monkey_array[i]=i; &#125; int j,k,temp; for(i=N; i&gt;=1; i--) &#123; for(j=1; j&lt;=3; j++)&#123; temp=monkey_array[1]; for(k=1; k&lt;=i; k++)&#123; monkey_array[k]=monkey_array[k+1]; &#125; monkey_array[i]=temp; &#125; &#125; printf("%d\n", monkey_array[1]); */ /* method 2: use recursion int N; N=11; if(!N) return 0; int result = josephus_recursion(N,3); printf("%d\n", result+1); */ /* method 3: use iteration*/ int i,N,result=0; scanf("%d", &amp;N); for(i=2; i&lt;=N; i++) &#123; result=(result + 3)%i; &#125; printf("%d\n", result+1); return 0;&#125;int josephus_recursion(int n, int m)&#123; if(n == 1) return 0; else return (josephus_recursion(n-1, m)+m)%n;&#125; 7-29 åˆ é™¤å­—ç¬¦ä¸²ä¸­çš„å­ä¸²è¾“å…¥2ä¸ªå­—ç¬¦ä¸²S1å’ŒS2ï¼Œè¦æ±‚åˆ é™¤å­—ç¬¦ä¸²S1ä¸­å‡ºçŽ°çš„æ‰€æœ‰å­ä¸²S2ï¼Œå³ç»“æžœå­—ç¬¦ä¸²ä¸­ä¸èƒ½åŒ…å«S2ã€‚ Input Specificationè¾“å…¥åœ¨2è¡Œä¸­åˆ†åˆ«ç»™å‡ºä¸è¶…è¿‡80ä¸ªå­—ç¬¦é•¿åº¦çš„ã€ä»¥å›žè½¦ç»“æŸçš„2ä¸ªéžç©ºå­—ç¬¦ä¸²ï¼Œå¯¹åº”S1å’ŒS2ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºåˆ é™¤å­—ç¬¦ä¸²S1ä¸­å‡ºçŽ°çš„æ‰€æœ‰å­ä¸²S2åŽçš„ç»“æžœå­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:Tomcat is a male ccatatcat Output:Tom is a male Analysisæœ¬é¢˜ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä¸è¿‡è¿˜æ˜¯è¦ä»”ç»†æƒ³ä¸€æƒ³ã€‚å¯¹éœ€è¦åˆ é™¤çš„å­—ç¬¦ä¸²è¿›è¡ŒéåŽ†ï¼Œæ¯”å¯¹å­—ç¬¦ä¸²åºåˆ—ï¼Œå¦‚æžœä¸æ˜¯å­ä¸²ï¼Œå°±è¿›è¡Œä¸‹ä¸€æ¬¡å¾ªçŽ¯ï¼Œè‹¥æ˜¯å­ä¸²ï¼Œå°±å°†å­ä¸²åŽçš„å­—ç¬¦åºåˆ—å‰ç§»ï¼Œç„¶åŽä¿®æ”¹å­—ç¬¦ä¸²çš„é•¿åº¦ï¼Œå¹¶è®©å­—ç¬¦ä¸²æœ€åŽä¸€ä½ä¸º\0ï¼Œè¿™æ ·å°±åˆ é™¤æŽ‰äº†å­ä¸²ï¼›é‡å¤éåŽ†å³å¯åˆ é™¤æ‰€æœ‰å­ä¸²ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s1[85],s2[85]; gets(s1); gets(s2); int len1=strlen(s1),len2=strlen(s2); int i,k; for(k=0; k&lt;len1; k++) &#123; for(i=0; i&lt;len1; i++) &#123; if(s1[i] == s2[0])&#123; int temp=i,flag=1,j; for(i+=1,j=1; j&lt;len2; i++,j++) &#123; if(s1[i] != s2[j])&#123; flag=0; break; &#125; &#125; if(!flag)&#123; i=temp; &#125;else&#123; for(j=temp; i&lt;len1; j++,i++) &#123; s1[j]=s1[i]; &#125; len1=len1-len2; s1[len1]='\0'; &#125; i=temp; &#125; &#125; &#125; printf("%s\n", s1); return 0;&#125; 7-30 å­—ç¬¦ä¸²çš„å†’æ³¡æŽ’åºæˆ‘ä»¬å·²ç»çŸ¥é“äº†å°†Nä¸ªæ•´æ•°æŒ‰ä»Žå°åˆ°å¤§æŽ’åºçš„å†’æ³¡æŽ’åºæ³•ã€‚æœ¬é¢˜è¦æ±‚å°†æ­¤æ–¹æ³•ç”¨äºŽå­—ç¬¦ä¸²åºåˆ—ï¼Œå¹¶å¯¹ä»»æ„ç»™å®šçš„Kï¼ˆ&lt;Nï¼‰ï¼Œè¾“å‡ºæ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœåºåˆ—ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºNå’ŒKï¼ˆ1â‰¤K&lt;Nâ‰¤100ï¼‰ï¼Œæ­¤åŽNè¡Œï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªé•¿åº¦ä¸è¶…è¿‡10çš„ã€ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆçš„éžç©ºå­—ç¬¦ä¸²ã€‚ Output Specificationè¾“å‡ºå†’æ³¡æŽ’åºæ³•æ‰«æå®Œç¬¬KéåŽçš„ä¸­é—´ç»“æžœåºåˆ—ï¼Œæ¯è¡ŒåŒ…å«ä¸€ä¸ªå­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:6 2bestcateastafreeday Output:bestacatdayeastfree Analysisæœ¬é¢˜ä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œä½†ä¹Ÿéœ€è¦ç»†ç»†æƒ³ä¸€æƒ³ï¼Œå¦å¤–æ„Ÿè§‰é¢˜å¹²ä¸€å¼€å§‹æ²¡è¯´æ¸…æ¥šæ€Žæ ·è®¤ä¸ºä¸€ä¸ªå­—ç¬¦ä¸²â€œå¤§â€æˆ–â€œå°â€ï¼Œå…¶å®žå°±æ˜¯é¦–å­—æ¯åœ¨å­—æ¯è¡¨é¡ºåºæ¥å†³å®šå¤§å°ï¼Œè‹¥é¦–å­—æ¯ç›¸åŒåˆ™æ¯”è¾ƒé¦–å­—æ¯åŽçš„å­—æ¯çš„é¡ºåºï¼Œä¾æ¬¡ç±»æŽ¨ï¼›äº†è§£äº†è¿™äº›åŽï¼Œå¯ä»¥å‘çŽ°ï¼Œè¾“å…¥æ ·ä¾‹ä¸­çš„å­—ç¬¦ä¸²æž„æˆçš„åºåˆ—å°±æ˜¯2 3 5 1 6 4ï¼Œè€Œè¾“å‡ºæ ·ä¾‹çš„åºåˆ—å°±æ˜¯2 1 3 4 5 6ï¼Œè¿™ä¸ªä¸Ž7-27 å†’æ³¡æ³•æŽ’åºæ˜¯ä¸€è‡´çš„ã€‚è§£å†³è¿™ä¸ªé—®é¢˜çš„ä¸»è¦æ€è·¯å…¶å®žæ˜¯åˆ©ç”¨äºŒç»´æ•°ç»„å­˜å‚¨æ¯ä¸€ä¸ªå­å­—ç¬¦ä¸²ï¼Œè¿›è¡Œæ¯”è¾ƒåŽæŽ’åºå³å¯ã€‚ä¸»è¦è¯¥æ³¨æ„çš„ç‚¹ï¼šabcdå’Œacbdè¿™ç§å‰ä¸€ä¸ªæˆ–å‡ ä¸ªå­—æ¯æ˜¯ç›¸åŒçš„å­å­—ç¬¦ä¸²çš„æ¯”è¾ƒï¼Œå·§åˆçš„æ˜¯ï¼Œstrcmpå‡½æ•°æ­£å¥½å¯ä»¥å¤„ç†è¿™æ ·çš„æƒ…å†µðŸ‘ï¼Œæ‰€ä»¥ï¼Œç›´æŽ¥ä½¿ç”¨strcmpå‡½æ•°æ¯”è¾ƒåŽï¼Œåœ¨ç”¨strcpyå‡½æ•°äº’æ¢å­—ç¬¦ä¸²å³å¯ï¼ˆç±»ä¼¼æ•´åž‹å˜é‡çš„æ¢å€¼ï¼‰ï¼›strcmpå’Œstrcpyè¿™ä¸¤ä¸ªå‡½æ•°å¯ä»¥è‡ªå·±å†™ï¼›C++å¥½åƒè‡ªå¸¦äº†åº”å¯¹è¿™ç§å­—ç¬¦ä¸²æŽ’åºéœ€æ±‚çš„å¤„ç†å‡½æ•°ï¼Œç›´æŽ¥è°ƒç”¨å³å¯ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;string.h&gt;char* mycpy(char* dst, char* src);int mycmp(char const *s1, char const *s2);int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); char str[N][11]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%s", str[i]); &#125; char temp[11]; char *p=temp; for(i=1; i&lt;=K; i++) &#123; for(j=0; j&lt;N-i; j++) &#123; if(mycmp(str[j], str[j+1]) &gt; 0)&#123; mycpy(p, str[j]); mycpy(str[j], str[j+1]); mycpy(str[j+1], temp); &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; printf("%s\n", str[i]); &#125; return 0;&#125;char* mycpy(char *dst, char *src)&#123; char* ret = dst; while(*src) &#123; *dst++ = *src++; &#125; *dst = '\0'; return ret;&#125;int mycmp(char const *s1, char const *s2)&#123; while(*s1 == *s2 &amp;&amp; *s1 != '\0') &#123; s1++; s2++; &#125; return *s1-*s2;&#125; 7-31 å­—ç¬¦ä¸²å¾ªçŽ¯å·¦ç§»è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²å’Œä¸€ä¸ªéžè´Ÿæ•´æ•°Nï¼Œè¦æ±‚å°†å­—ç¬¦ä¸²å¾ªçŽ¯å·¦ç§»Næ¬¡ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬1è¡Œä¸­ç»™å‡ºä¸€ä¸ªä¸è¶…è¿‡100ä¸ªå­—ç¬¦é•¿åº¦çš„ã€ä»¥å›žè½¦ç»“æŸçš„éžç©ºå­—ç¬¦ä¸²ï¼›ç¬¬2è¡Œç»™å‡ºéžè´Ÿæ•´æ•°Nã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­è¾“å‡ºå¾ªçŽ¯å·¦ç§»Næ¬¡åŽçš„å­—ç¬¦ä¸²ã€‚ Sample Input &amp; Sample Output Input:Hello World!2 Output:llo World!He Analysisæœ¬é¢˜ä¸éš¾ï¼Œç†Ÿæ‚‰å­—ç¬¦æ•°ç»„çš„å­˜å‚¨æ–¹å¼çš„è¯åšèµ·æ¥ä¼šæ„Ÿè§‰æ¯”è¾ƒå®¹æ˜“ã€‚ä¸»è¦æ€è·¯æ˜¯æŒ‰ç…§é¢˜ç›®ç»™çš„ç§»åŠ¨æ¬¡æ•°ï¼Œå°†éœ€è¦ç§»åŠ¨çš„å­—ç¬¦æŒ‰ç§»åŠ¨é¡ºåºæ”¾åˆ°ä¸€ä¸ªæ–°çš„å­—ç¬¦æ•°ç»„å†…ï¼Œå°†åŽŸæ¥çš„å­—ç¬¦æ•°ç»„çš„å‰©ä½™å­—ç¬¦å‰ç§»ï¼Œç„¶åŽå†å°†æ–°çš„å­—ç¬¦æ•°ç»„å†…çš„å­—ç¬¦å¤åˆ¶å›žè€çš„å­—ç¬¦æ•°ç»„å†…å³å¯ã€‚æ³¨æ„å½“ç§»åŠ¨çš„æ¬¡æ•°å¤§äºŽå­—ç¬¦ä¸²çš„é•¿åº¦æ—¶ï¼Œè¦å–ä½™å¤„ç†ï¼Œæ¯”å¦‚ï¼Œå­—ç¬¦ä¸²é•¿åº¦ä¸º5ï¼Œè¦ç§»åŠ¨9æ¬¡ï¼Œå®žé™…ä¸Šç§»åŠ¨çš„æ¬¡æ•°å°±æ˜¯9%5=4ã€‚ä¹Ÿå¯ä»¥åªä½¿ç”¨ä¸€ä¸ªå­—ç¬¦æ•°ç»„ï¼Œå…ˆè¾“å‡ºç§»åŠ¨åŽçš„åŽåŠæ®µå­—ç¬¦ï¼Œåœ¨è¾“å‡ºå‰åŠæ®µå­—ç¬¦ï¼Œæœ€åŽæ¢è¡Œå³å¯ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int mylen(char const *s1);int main(int argc, char const *argv[])&#123; char str1[105]; char str2[105]; gets(str1); int N,i=1; scanf("%d", &amp;N); char* p=str1; char* q=str2; int len=mylen(p); for(p+=(N%len); *p != '\0'; p++, q++) &#123; *q=*p; &#125; p=str1; for(i=1; i&lt;=(N%len); i++, p++, q++) &#123; *q=*p; &#125; *q='\0'; printf("%s\n", str2); /* method 2: use one char_array int i=0,len=mylen(str); char* p=str; printf("%s", p+(N%len); p=str; for(; i&lt;(N%len); i++,p++) &#123; printf("%c", *p); &#125; printf("\n"); */ return 0;&#125;int mylen(char const *s1)&#123; int len=0; while(*s1) &#123; s1++; len++; &#125; return len;&#125; 7-32 è¯´åè¯-åŠ å¼ºç‰ˆç»™å®šä¸€å¥è‹±è¯­ï¼Œè¦æ±‚ä½ ç¼–å†™ç¨‹åºï¼Œå°†å¥ä¸­æ‰€æœ‰å•è¯çš„é¡ºåºé¢ å€’è¾“å‡ºã€‚ Input Specificationæµ‹è¯•è¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œåœ¨ä¸€è¡Œå†…ç»™å‡ºæ€»é•¿åº¦ä¸è¶…è¿‡500000çš„å­—ç¬¦ä¸²ã€‚å­—ç¬¦ä¸²ç”±è‹¥å¹²å•è¯å’Œè‹¥å¹²ç©ºæ ¼ç»„æˆï¼Œå…¶ä¸­å•è¯æ˜¯ç”±è‹±æ–‡å­—æ¯ï¼ˆå¤§å°å†™æœ‰åŒºåˆ†ï¼‰ç»„æˆçš„å­—ç¬¦ä¸²ï¼Œå•è¯ä¹‹é—´ç”¨è‹¥å¹²ä¸ªç©ºæ ¼åˆ†å¼€ã€‚ Output Specificationæ¯ä¸ªæµ‹è¯•ç”¨ä¾‹çš„è¾“å‡ºå ä¸€è¡Œï¼Œè¾“å‡ºå€’åºåŽçš„å¥å­ï¼Œå¹¶ä¸”ä¿è¯å•è¯é—´åªæœ‰1ä¸ªç©ºæ ¼ã€‚ Sample Input &amp; Sample Output Input:Hello World Here I Come Output:Come I Here World Hello Analysisæœ¬é¢˜æœ¬è´¨ä¸Šè€Œè¨€ï¼Œä¸æ˜¯ç‰¹åˆ«çš„å¤æ‚ï¼Œä½†ä¹Ÿéœ€è¦ä»”ç»†åŽ»ç¢ç£¨ä¸€äº›ç»†èŠ‚ï¼Œä»¥ä¸‹çš„ä»£ç å‚è€ƒäº†qq_37729102çš„ä»£ç ï¼Œä¸”æ–‡ç« ä¹‹å†…åšäº†å¾ˆå¤šç»†èŠ‚è¯´æ˜Žï¼›å¤§è‡´çš„æ€è·¯ï¼Œå°±æ˜¯ä»ŽåŽå¾€å‰éåŽ†å­—ç¬¦ä¸²ï¼Œç©ºæ ¼è·³è¿‡ï¼Œæ‰«æåˆ°éžå­—ç¬¦æ—¶ï¼Œè®°å½•å­—ç¬¦çš„ä¸ªæ•°(å…¶å®žå°±æ˜¯å•è¯çš„é•¿åº¦äº†)ï¼Œæ¯æ‰«æåˆ°ä¸‹ä¸€ä¸ªç©ºæ ¼çš„æ—¶å€™ï¼Œå°±è¾“å‡ºå‰ä¸€ä¸ªå•è¯å³å¯ã€‚ç”±äºŽç¬¬ä¸€ä¸ªå•è¯æ¯”è¾ƒç‰¹æ®Šï¼Œå¦‚æžœä¾ç„¶é‡‡å–ä»ŽåŽéåŽ†çš„æ–¹æ³•åŽ»è¾“å‡ºç¬¬ä¸€ä¸ªå•è¯ï¼Œè¿™æ ·å°±æ— æ³•ä¿è¯ä¸Žé¢˜ç›®æ ¼å¼çš„ä¸€è‡´(æ¢è¡Œç¬¦)ï¼Œæ‰€ä»¥éœ€è¦å…ˆè®°å½•ç¬¬ä¸€ä¸ªå•è¯çš„é¦–å­—æ¯åœ¨å­—ç¬¦æ•°ç»„ä¸­çš„ä¸‹æ ‡ï¼Œæ­¤æ—¶ï¼Œè‹¥ç¬¬ä¸€ä¸ªå•è¯çš„å‰é¢å­˜åœ¨ç©ºæ ¼ï¼Œè·³è¿‡ï¼Œè‹¥æ²¡æœ‰ç©ºæ ¼ï¼Œé‚£ä¹ˆå¾ªçŽ¯å˜é‡ä¸º0åŽå°±è‡ªåŠ¨è·³å‡ºå¾ªçŽ¯äº†ï¼Œç´§æŽ¥ç€ï¼Œå†è¾“å‡ºç¬¬ä¸€ä¸ªå•è¯å°±å¯ä»¥äº†ã€‚ Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 500005int main(int argc, char const *argv[])&#123; char str[maxn]; gets(str); int len=strlen(str); int i,j=0,char_cnt=0,next_flag=1,last_flag=1; for(i=0; i&lt;len; i++) &#123; if(str[i] != ' ')&#123; last_flag=i; break; &#125; &#125; for(i=len-1; i&gt;=0; i--) &#123; if(str[i] != ' ')&#123; next_flag=0; char_cnt++; &#125;else if(!next_flag)&#123; next_flag=1; for(j=i+1; j&lt;i+1+char_cnt; j++) &#123; printf("%c", str[j]); &#125; if(i+1 != last_flag) printf(" "); char_cnt=0; &#125; &#125; for(i=last_flag; i&lt;last_flag+char_cnt; i++) &#123; printf("%c", str[i]); &#125; printf("\n"); return 0;&#125; 7-33 æœ‰ç†æ•°åŠ æ³•æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—ä¸¤ä¸ªæœ‰ç†æ•°çš„å’Œã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§a1/b1å’Œa2/b2çš„æ ¼å¼ç»™å‡ºä¸¤ä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å½¢èŒƒå›´å†…çš„æ­£æ•´æ•°ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§a/bçš„æ ¼å¼è¾“å‡ºä¸¤ä¸ªæœ‰ç†æ•°çš„å’Œã€‚æ³¨æ„å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€åˆ†æ•°å½¢å¼ï¼Œè‹¥åˆ†æ¯ä¸º1ï¼Œåˆ™åªè¾“å‡ºåˆ†å­ã€‚ Sample Input &amp; Sample Output Input 1:1/3 1/6 Output 2:1/2 Input 3:4/3 2/3 Output 4:2 Analysisæœ¬é¢˜ç®—æ˜¯7-24 çº¦åˆ†æœ€ç®€åˆ†å¼çš„å‡çº§ç‰ˆäº†ï¼Œé¢˜ç›®ä¸éš¾ï¼ŒæŒ‰ç…§åŸºæœ¬è®¡ç®—è§„åˆ™è¿›è¡Œçº¦åˆ†å³å¯ï¼Œå®žè´¨ä¸Šæ˜¯å¯¹æœ€å¤§å…¬çº¦æ•°å’Œæœ€å°å…¬å€æ•°çš„ç†è§£ã€åº”ç”¨å’Œè®¡ç®—å§ã€‚ Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int a1,b1,a2,b2; scanf("%d/%d %d/%d", &amp;a1, &amp;b1, &amp;a2, &amp;b2); int member,denominator,LCM,GCD; LCM=lcm(b1, b2); member=a1*LCM/b1 + a2*LCM/b2; denominator=LCM; GCD=gcd(member, denominator); if(denominator/GCD == 1)&#123; printf("%d\n", member/GCD); &#125;else&#123; printf("%d/%d\n", member/GCD, denominator/GCD); &#125; return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a);&#125;int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-34 é€šè®¯å½•çš„å½•å…¥ä¸Žæ˜¾ç¤ºé€šè®¯å½•ä¸­çš„ä¸€æ¡è®°å½•åŒ…å«ä¸‹è¿°åŸºæœ¬ä¿¡æ¯ï¼šæœ‹å‹çš„å§“åã€å‡ºç”Ÿæ—¥æœŸã€æ€§åˆ«ã€å›ºå®šç”µè¯å·ç ã€ç§»åŠ¨ç”µè¯å·ç ã€‚ æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œå½•å…¥Næ¡è®°å½•ï¼Œå¹¶ä¸”æ ¹æ®è¦æ±‚æ˜¾ç¤ºä»»æ„æŸæ¡è®°å½•ã€‚ Input Specificationè¾“å…¥åœ¨ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤10ï¼‰ï¼›éšåŽNè¡Œï¼Œæ¯è¡ŒæŒ‰ç…§æ ¼å¼å§“å ç”Ÿæ—¥ æ€§åˆ« å›ºè¯ æ‰‹æœºç»™å‡ºä¸€æ¡è®°å½•ã€‚å…¶ä¸­å§“åæ˜¯ä¸è¶…è¿‡10ä¸ªå­—ç¬¦ã€ä¸åŒ…å«ç©ºæ ¼çš„éžç©ºå­—ç¬¦ä¸²ï¼›ç”Ÿæ—¥æŒ‰yyyy/mm/ddçš„æ ¼å¼ç»™å‡ºå¹´æœˆæ—¥ï¼›æ€§åˆ«ç”¨Mè¡¨ç¤ºâ€œç”·â€ã€Fè¡¨ç¤ºâ€œå¥³â€ï¼›å›ºè¯å’Œæ‰‹æœºå‡ä¸ºä¸è¶…è¿‡15ä½çš„è¿žç»­æ•°å­—ï¼Œå‰é¢æœ‰å¯èƒ½å‡ºçŽ°+ã€‚åœ¨é€šè®¯å½•è®°å½•è¾“å…¥å®ŒæˆåŽï¼Œæœ€åŽä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Kï¼Œå¹¶ä¸”éšåŽç»™å‡ºKä¸ªæ•´æ•°ï¼Œè¡¨ç¤ºè¦æŸ¥è¯¢çš„è®°å½•ç¼–å·ï¼ˆä»Ž0åˆ°Nâˆ’1é¡ºåºç¼–å·ï¼‰ã€‚æ•°å­—é—´ä»¥ç©ºæ ¼åˆ†éš”ã€‚ Output Specificationå¯¹æ¯ä¸€æ¡è¦æŸ¥è¯¢çš„è®°å½•ç¼–å·ï¼Œåœ¨ä¸€è¡Œä¸­æŒ‰ç…§å§“å å›ºè¯ æ‰‹æœº æ€§åˆ« ç”Ÿæ—¥çš„æ ¼å¼è¾“å‡ºè¯¥è®°å½•ã€‚è‹¥è¦æŸ¥è¯¢çš„è®°å½•ä¸å­˜åœ¨ï¼Œåˆ™è¾“å‡ºNot Foundã€‚ Sample Input &amp; Sample Output Input:3Chris 1984/03/10 F +86181779452 13707010007LaoLao 1967/11/30 F 057187951100 +8618618623333QiaoLin 1980/01/01 M 84172333 100862 1 7 Output:LaoLao 057187951100 +8618618623333 F 1967/11/30Not Found Analysisæœ¬é¢˜ä¸éš¾ï¼Œæ¯”è¾ƒç›´æŽ¥ï¼›ç›´æŽ¥ç”¨ç»“æž„ä½“æž„é€ å‡ºæ¥ä¿å­˜é€šè®¯å½•çš„æ•°æ®ç»“æž„å³å¯ï¼Œç„¶åŽå†ä»Žè¿™ä»½é€šè®¯å½•å†…åˆ†åˆ«æŒ‰é¡ºåºè¾“å‡ºéœ€è¦çš„ä¿¡æ¯å³å¯ã€‚å…¶å®žç”¨äºŒç»´æ•°ç»„åº”è¯¥ä¹Ÿå¯ä»¥è¾¾åˆ°è¿™æ ·çš„æ•ˆæžœï¼Œå¦å¤–ï¼Œå¯¹äºŽç”Ÿæ—¥è¿™æ¡è®°å½•ï¼Œç›´æŽ¥ç”¨å­—ç¬¦ä¸²å­˜å‚¨æ¯”è¾ƒæ–¹ä¾¿ã€‚ Code123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;typedef struct address_list&#123; char name[12]; char brith[12]; char gender; char landline[18]; char phone[18];&#125;address_list;int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); address_list list[N]; for(i=0; i&lt;N; i++) &#123; scanf("%s %s %c %s %s", list[i].name, list[i].brith, &amp;list[i].gender, list[i].landline, list[i].phone); getchar(); &#125; int K,j; scanf("%d", &amp;K); for(i=1; i&lt;=K; i++) &#123; int j,check_num=0,flag=0; scanf("%d", &amp;check_num); for(j=0; j&lt;N; j++) &#123; if(j == check_num)&#123; printf("%s %s %s %c %s\n", list[j].name, list[j].landline, list[j].phone, list[j].gender, list[j].brith); flag=1; &#125; &#125; if(!flag) printf("Not Found\n"); &#125; return 0;&#125; 7-35 æœ‰ç†æ•°å‡å€¼æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—Nä¸ªæœ‰ç†æ•°çš„å¹³å‡å€¼ã€‚ Input Specificationè¾“å…¥ç¬¬ä¸€è¡Œç»™å‡ºæ­£æ•´æ•°Nï¼ˆâ‰¤100ï¼‰ï¼›ç¬¬äºŒè¡Œä¸­æŒ‰ç…§a1/b1 a2/b2 â€¦çš„æ ¼å¼ç»™å‡ºNä¸ªåˆ†æ•°å½¢å¼çš„æœ‰ç†æ•°ï¼Œå…¶ä¸­åˆ†å­å’Œåˆ†æ¯å…¨æ˜¯æ•´å½¢èŒƒå›´å†…çš„æ•´æ•°ï¼›å¦‚æžœæ˜¯è´Ÿæ•°ï¼Œåˆ™è´Ÿå·ä¸€å®šå‡ºçŽ°åœ¨æœ€å‰é¢ã€‚ Output Specificationåœ¨ä¸€è¡Œä¸­æŒ‰ç…§a/bçš„æ ¼å¼è¾“å‡ºNä¸ªæœ‰ç†æ•°çš„å¹³å‡å€¼ã€‚æ³¨æ„å¿…é¡»æ˜¯è¯¥æœ‰ç†æ•°çš„æœ€ç®€åˆ†æ•°å½¢å¼ï¼Œè‹¥åˆ†æ¯ä¸º1ï¼Œåˆ™åªè¾“å‡ºåˆ†å­ã€‚ Sample Input &amp; Sample Output Input 1:41/2 1/6 3/6 -5/10 Output 1:1/6 Input 2:24/3 2/3 Output 2:1 Analysisæœ¬é¢˜ç¨å¾®å¤æ‚ä¸€ç‚¹ï¼Œä¸è¿‡å¤§è‡´æ€è·¯è¿˜ç®—ç®€å•ï¼›ä¸»è¦çš„æ€è·¯å°±æ˜¯ä¾æ¬¡å°†è¾“å…¥çš„åˆ†å¼ç›¸åŠ ï¼Œç„¶åŽé™¤ä»¥æ•°é‡å³å¯å¾—åˆ°å‡å€¼äº†ã€‚ç”±äºŽé¢˜ç›®ä¼šç»™è¾“å…¥çš„åˆ†å¼çš„æ•°ç›®ï¼Œæ‰€ä»¥å¯ä»¥æå‰å®šä¹‰å¥½å­˜å‚¨ç»“æž„ï¼Œç„¶åŽåœ¨è¿›è¡Œè¿ç®—ï¼›æ³¨æ„æ¯æ¬¡è¿ç®—å®Œä¹‹åŽéœ€è¦å¯¹åˆ†å­åˆ†æ¯è¿›è¡ŒåŒ–ç®€ï¼Œæ¯æ¬¡è®¡ç®—å¾—åˆ°çš„åˆ†å­memberå’Œåˆ†æ¯denominatoréœ€è¦ä½¿ç”¨long longçš„ç±»åž‹æ¥å®šä¹‰ï¼Œå¦åˆ™ä¼šè¶…å‡ºèŒƒå›´ã€‚åˆ†å¼çš„åŒ–ç®€å’Œç›¸åŠ ä¸»è¦ä¾æ®æœ€å°å…¬å€æ•°å’Œæœ€å¤§å…¬çº¦æ•°æ¥å®Œæˆï¼Œæœ€å¤§å…¬çº¦æ•°å¯ä»¥ä½¿ç”¨æ¬§å‡ é‡Œå¾—ç®—æ³•ï¼Œæœ€å°å…¬å€æ•°å³ä¸ºä¸¤ä¸ªæ•°çš„ä¹˜ç§¯é™¤ä»¥ä¸¤ä¸ªæ•°çš„æœ€å¤§å…¬çº¦æ•°ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;typedef struct Fraction&#123; int a; int b;&#125;fraction;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); fraction fra[N]; for(i=0; i&lt;N; i++) &#123; scanf("%d/%d", &amp;fra[i].a, &amp;fra[i].b); &#125; int GCD=0, LCM=0; long long member=fra[0].a, denominator=fra[0].b; for(i=1; i&lt;N; i++) &#123; GCD=gcd(denominator, fra[i].b); LCM=denominator*fra[i].b/GCD; member=member*LCM/denominator + fra[i].a*LCM/fra[i].b; denominator=LCM; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; &#125; denominator*=N; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; if(denominator == 1) printf("%ld\n", member); else printf("%ld/%ld\n", member, denominator); return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a); &#125; int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-36 å¤æ•°å››åˆ™è¿ç®—æœ¬é¢˜è¦æ±‚ç¼–å†™ç¨‹åºï¼Œè®¡ç®—2ä¸ªå¤æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ã€‚ Input Specificationè¾“å…¥åœ¨ä¸€è¡Œä¸­æŒ‰ç…§a1ã€b1ã€a2ã€b2çš„æ ¼å¼ç»™å‡º2ä¸ªå¤æ•°C1=a1+b1iå’ŒC2=a2+b2içš„å®žéƒ¨å’Œè™šéƒ¨ã€‚é¢˜ç›®ä¿è¯C2ä¸ä¸º0ã€‚ Output Specificationåˆ†åˆ«åœ¨4è¡Œä¸­æŒ‰ç…§(a1+b1i) è¿ç®—ç¬¦ (a2+b2i) = ç»“æžœçš„æ ¼å¼é¡ºåºè¾“å‡º2ä¸ªå¤æ•°çš„å’Œã€å·®ã€ç§¯ã€å•†ï¼Œæ•°å­—ç²¾ç¡®åˆ°å°æ•°ç‚¹åŽ1ä½ã€‚å¦‚æžœç»“æžœçš„å®žéƒ¨æˆ–è€…è™šéƒ¨ä¸º0ï¼Œåˆ™ä¸è¾“å‡ºã€‚å¦‚æžœç»“æžœä¸º0ï¼Œåˆ™è¾“å‡º0.0ã€‚ Sample Input &amp; Sample Output Input 1:2 3.08 -2.04 5.06 Output 1:(2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i Input 2:1 1 -1 -1.01 Output 2:(1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 Analysisæœ¬é¢˜çš„è®¡ç®—æ–¹æ³•æ¯”è¾ƒç®€å•ï¼Œæ³¨æ„å¤æ•°çš„*å’Œ/è¿ç®—å³å¯ï¼›æ­¤é¢˜æ¯”è¾ƒéº»çƒ¦çš„åœ°æ–¹åœ¨äºŽæŽ§åˆ¶è¾“å‡ºçš„æ ¼å¼ï¼Œç”±äºŽå­˜åœ¨å®žéƒ¨å’Œè™šéƒ¨ï¼Œæ‰€ä»¥éœ€è¦åˆ†å¤šç§æƒ…å†µï¼Œè¿™ä¸ªå°±éœ€è¦æ³¨æ„ç»†èŠ‚äº†ã€‚è‹¥ç”¨realä»£è¡¨å®žéƒ¨ï¼Œç”¨imaginaryä»£è¡¨è™šéƒ¨ï¼Œå°±å¯ä»¥å¾—åˆ°ä»¥ä¸‹å‡ ç§æƒ…å†µï¼šreal==0, imaginary==0ã€real==0, imaginary&gt;0ã€real==0, imaginary &lt; 0ã€real!=0, imaginary&gt;0ã€real!=0, imaginary&lt;0å’Œreal!=0, imaginary==0ï¼Œæ ¹æ®è¿™å…­ç§æƒ…å†µè¦åˆ†åˆ«è¾“å‡ºç»“æžœä¸­è™šéƒ¨å‰çš„+å’Œ-å·ï¼›ç”±äºŽè¾“å…¥çš„æ•°æ®æ˜¯å°æ•°ï¼Œåœ¨åšåˆ¤æ–­æ—¶ï¼Œå¾—è€ƒè™‘å››èˆäº”å…¥çš„æƒ…å†µï¼Œè€Œåœ¨è¾“å‡ºæ—¶ï¼Œ%lfä¼šè‡ªåŠ¨å››èˆäº”å…¥ï¼›ä¸è¦ç”¨flaotï¼Œå› ä¸ºæ•°å€¼å¯èƒ½ä¼šæœ‰æŸå¤±ï¼Œæœ€å¥½ç›´æŽ¥ç”¨doubleã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;math.h&gt;double a1,b1,a2,b2;void print_complex_number(double a, char c, double b);int main(int argc, char const *argv[])&#123; double real_part=0.0,imaginary_part=0.0; scanf("%lf %lf %lf %lf", &amp;a1, &amp;b1, &amp;a2, &amp;b2); real_part=a1 + a2; imaginary_part=b1 + b2; print_complex_number(real_part, '+', imaginary_part); real_part=a1 - a2; imaginary_part=b1 - b2; print_complex_number(real_part, '-', imaginary_part); real_part=a1*a2 - b1*b2; imaginary_part=a2*b1 + a1*b2; print_complex_number(real_part, '*', imaginary_part); real_part=(a1*a2 + b1*b2) / (a2*a2 + b2*b2); imaginary_part=(a2*b1 - a1*b2) / (a2*a2 + b2*b2); print_complex_number(real_part, '/', imaginary_part); return 0;&#125;void print_complex_number(double a, char c, double b)&#123; if(b1 &gt;= 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &gt;= 0 &amp;&amp; b2 &lt; 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &lt; 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else&#123; printf("(%.1lf%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125; if(fabs(a) &lt; 0.1 &amp;&amp; fabs(b) &lt; 0.1)&#123; printf("0.0\n"); return; &#125; int flag=0; if(fabs(a) &gt;= 0.1)&#123; printf("%.1lf", a); flag++; &#125; if(fabs(b) &gt;= 0.1)&#123; if(flag &amp;&amp; b &gt; 0.0)&#123; printf("+%.1lfi", b); &#125;else&#123; printf("%.1lfi", b); &#125; &#125; printf("\n");&#125; 7-37 æ•´æ•°åˆ†è§£ä¸ºè‹¥å¹²é¡¹ä¹‹å’Œå°†ä¸€ä¸ªæ­£æ•´æ•°Nåˆ†è§£æˆå‡ ä¸ªæ­£æ•´æ•°ç›¸åŠ ï¼Œå¯ä»¥æœ‰å¤šç§åˆ†è§£æ–¹æ³•ï¼Œä¾‹å¦‚7=6+1ï¼Œ7=5+2ï¼Œ7=5+1+1ï¼Œâ€¦ã€‚ç¼–ç¨‹æ±‚å‡ºæ­£æ•´æ•°Nçš„æ‰€æœ‰æ•´æ•°åˆ†è§£å¼å­ã€‚ Input Specificationæ¯ä¸ªè¾“å…¥åŒ…å«ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹ï¼Œå³æ­£æ•´æ•°N (0&lt;Nâ‰¤30)ã€‚ Output SpecificationæŒ‰é€’å¢žé¡ºåºè¾“å‡º$N$çš„æ‰€æœ‰æ•´æ•°åˆ†è§£å¼å­ã€‚é€’å¢žé¡ºåºæ˜¯æŒ‡ï¼šå¯¹äºŽä¸¤ä¸ªåˆ†è§£åºåˆ—$N_1={n_1,n_2,â‹¯}$å’Œ$N_2={m_1,m_2,â‹¯}$ï¼Œè‹¥å­˜åœ¨$i$ä½¿å¾—$n_1=m_1,â‹¯,n_i=m_i$ï¼Œä½†æ˜¯$n_{i+1} &lt; m_{i+1}$,åˆ™$N_1$åºåˆ—å¿…å®šåœ¨$N_2$åºåˆ—ä¹‹å‰è¾“å‡ºã€‚æ¯ä¸ªå¼å­ç”±å°åˆ°å¤§ç›¸åŠ ï¼Œå¼å­é—´ç”¨åˆ†å·éš”å¼€ï¼Œä¸”æ¯è¾“å‡º4ä¸ªå¼å­åŽæ¢è¡Œã€‚ Sample Input &amp; Sample Output Input:7 Output:7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 Analysisä»¥ä¸‹ä»£ç å‚è€ƒäº†æ–‡ä¹‹çš„ä»£ç ï¼›é¢˜ç›®å…¶å®žä¸éš¾ï¼Œä¹Ÿç®—æ˜¯â€œå¥—è·¯é¢˜â€çš„ä¸€ç§ï¼Œé‡‡ç”¨äº†æ·±åº¦ä¼˜å…ˆå’Œé€’å½’çš„æ€æƒ³ï¼›æ–‡ä¹‹åšæ–‡å†…ç»†èŠ‚è¯´çš„å¾ˆæ¸…æ¥šï¼Œè¿™é‡Œæš‚æ—¶å…ˆä¸è®¨è®ºï¼ˆå…¶å®žæ˜¯è‡ªå·±çœ‹çš„ä¼¼æ‡‚éžæ‡‚ðŸ˜ï¼‰ã€‚ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;void division(int i);int N;int s[31];int top=-1;int cnt=0;int sum=0;int main(int argc, char const *argv[])&#123; scanf("%d", &amp;N); division(1); return 0;&#125;void division(int i)&#123; if(sum == N)&#123; cnt++; printf("%d=", N); int k; for(k=0; k&lt;top; k++) &#123; printf("%d+", s[k]); &#125; if(cnt%4 == 0 || s[top] == N)&#123; printf("%d\n", s[top]); &#125;else&#123; printf("%d;", s[top]); &#125; return ; &#125; if(sum &gt; N)&#123; return ; &#125; int j; for(j=i; j&lt;=N; j++) &#123; s[++top]=j; sum+=j; division(j); sum-=j; top--; &#125;&#125; 7-38 æ•°åˆ—æ±‚å’Œ-åŠ å¼ºç‰ˆç»™å®šæŸæ•°å­—$Aï¼ˆ1â‰¤Aâ‰¤9ï¼‰$ä»¥åŠéžè´Ÿæ•´æ•°$Nï¼ˆ0â‰¤Nâ‰¤100000ï¼‰$ï¼Œæ±‚æ•°åˆ—ä¹‹å’Œ$S=A+AA+AAA+â‹¯+AAâ‹¯Aï¼ˆNä¸ªAï¼‰$ã€‚ä¾‹å¦‚$A=1, N=3$æ—¶ï¼Œ$S=1+11+111=123$ã€‚ Input Specificationè¾“å…¥æ•°å­—$A$ä¸Žéžè´Ÿæ•´æ•°$N$ã€‚ Output Specificationè¾“å‡ºå…¶$N$é¡¹æ•°åˆ—ä¹‹å’Œ$S$çš„å€¼ã€‚ Sample Input &amp; Sample Output Input:1 3 Output:123 Analysisè¿™é“é¢˜ï¼Œä¸æ˜¯ç‰¹åˆ«éš¾ï¼Œå…¶å®žè¿™ç§ç±»åž‹çš„é¢˜ç›®å¤§ä½“ä¸Šç®—ï¼Œå¤§æ¦‚åˆä¸¤ç§æ–¹æ³•åŽ»è§£å†³ï¼›é¦–å…ˆæ˜¯æ¯”è¾ƒç›´æŽ¥çš„å°±æ˜¯åˆ©ç”¨æ•°ç»„åŽ»æ¨¡æ‹Ÿæ•´ä¸ªè®¡ç®—è¿‡ç¨‹ï¼Œå…¶å®žè´¨æ˜¯ç”¨æ•°ç»„è¿›è¡ŒåŸºæœ¬å››åˆ™è¿ç®—ï¼›å¦å¤–ä¸€ç§æ–¹æ³•å°±æ˜¯æ•°å­¦ï¼Œæ¯ä¸€æ¬¡æ•°ä½çš„ç›¸åŠ ï¼Œå…¶å®žæ˜¯(A*(N-i) + carryï¼Œå…¶ä¸­Aæ˜¯æ•°ä½å€¼ï¼Œ(N-i)æ˜¯æ•°ä½ä¸Šçš„åŠ çš„æ¬¡æ•°ï¼Œcarryæ˜¯è¿›ä½å€¼ï¼Œæ‰€ä»¥(A*(N-i) + carryçš„ç»“æžœå–ä½™åŽæ‰æ˜¯è¿™ä¸ªæ•°ä½çœŸæ­£çš„å€¼ã€‚ä¸‹é¢çš„ä»£ç ä¸­åˆ†åˆ«ç»™å‡ºäº†ç”¨æ•°ç»„æ¨¡æ‹Ÿçš„æ–¹æ³•å’Œæ•°å­¦æ–¹æ³•ï¼Œä¸”æ•°å­¦æ–¹æ³•ç†è§£èµ·æ¥ä¸éš¾ï¼Œè¦èƒ½æƒ³åˆ°è¿™æ ·åŽ»è§£å†³çš„è¯ï¼Œè¿˜éœ€è¦ç§¯ç´¯ã€‚ Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#define maxn 100002int main(int argc, char const *argv[])&#123; /* method 1: use the array do analog computation, but Time Limit Exceeded int A,N,sum[maxn],num[maxn]; // scanf("%d %d", &amp;A, &amp;N); A=1, N=3; if(N == 0)&#123; printf("0\n"); &#125;else if(N == 1)&#123; printf("%d\n", A); &#125;else&#123; int i,j,temp,len,flag=0,carry=0; for(i=1; i&lt;=N; i++) &#123; num[i]=A; &#125; while(N) &#123; carry=0; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=A; &#125; for(i=1; i&lt;=N-1; i++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; for(j=i; j&lt;=N; j++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; while(carry) &#123; num[j++] = carry%10; carry/=10; len = j; flag = 1; &#125; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=0; &#125; N--; if(N == 1) break; &#125; if(flag)&#123; for(i=len; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=j; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; return 0; */ /* method 2: use the '%' */ int num[maxn]=&#123;0&#125;,i,j,carry,flag,A,N; scanf("%d%d", &amp;A, &amp;N); // A=9, N=4; if(N == 0) printf("0\n"); else if(N == 1) printf("%d\n", A); else&#123; carry=0, flag=0; for(i=0; i&lt;N; i++) &#123; num[i] = (A*(N-i) + carry)%10; carry = (A*(N-i) + carry)/10; &#125; while(carry) &#123; num[i++] = carry%10; carry = carry/10; flag = 1; &#125; if(flag == 1)&#123; for(i=N; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=N-1; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; &#125; Code-Completion6-1 ç®€å•è¾“å‡ºæ•´æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œå¯¹ç»™å®šçš„æ­£æ•´æ•°Nï¼Œæ‰“å°ä»Ž1åˆ°Nçš„å…¨éƒ¨æ­£æ•´æ•°ã€‚ Function interface definitionvoid PrintN ( int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚è¯¥å‡½æ•°å¿…é¡»å°†ä»Ž1åˆ°Nçš„å…¨éƒ¨æ­£æ•´æ•°é¡ºåºæ‰“å°å‡ºæ¥ï¼Œæ¯ä¸ªæ•°å­—å 1è¡Œã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;void PrintN ( int N );int main ()&#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:3 Output:123 Analysisçƒ­èº«é¢˜ðŸ§ã€‚ Code123456void PrintN(int N)&#123; int i; for(i=1;i&lt;=N;i++)&#123; printf("%d\n",i); &#125;&#125; 6-2 å¤šé¡¹å¼æ±‚å€¼æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œè®¡ç®—é˜¶æ•°ä¸ºnï¼Œç³»æ•°ä¸ºa[0]â€¦a[n]çš„å¤šé¡¹å¼$f(x)=\sum_{i=0}^n(a[i]Ã—xi)$åœ¨xç‚¹çš„å€¼ã€‚ Function interface definitiondouble f( int n, double a[], double x );å…¶ä¸­næ˜¯å¤šé¡¹å¼çš„é˜¶æ•°ï¼Œa[]ä¸­å­˜å‚¨ç³»æ•°ï¼Œxæ˜¯ç»™å®šç‚¹ã€‚å‡½æ•°é¡»è¿”å›žå¤šé¡¹å¼f(x)çš„å€¼ã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main()&#123; int n, i; double a[MAXN], x; scanf("%d %lf", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(â€œ%lfâ€, &amp;a[i]); printf("%.1f\n", f(n, a, x)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:2 1.11 2.5 -38.7 Output:-43.1 Analysisç›´æŽ¥æŒ‰ç…§å…¬å¼æ±‚å€¼å³å¯ï¼Œæ³¨æ„ç›´æŽ¥ç®—æœ‰æµ‹è¯•ç‚¹ä¼šè¶…æ—¶ï¼Œå¯ç”¨æå–å…¬å› å¼çš„åŠžæ³•æ¥è§£å†³ã€‚ Code123456789101112double f( int n, double a[], double x ) &#123; int i; double sum=0,X=x; if(n == 0) &#123; sum=a[0]*1.0; &#125; else &#123; sum=a[n]*X + a[n-1]; for(i=n-2; i&gt;=0; i--) &#123; sum=sum*X + a[i]; &#125; &#125; return sum; 6-3 ç®€å•æ±‚å’Œæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚ç»™å®šçš„Nä¸ªæ•´æ•°çš„å’Œã€‚ Function interface definitionint Sum ( int List[], int N );å…¶ä¸­ç»™å®šæ•´æ•°å­˜æ”¾åœ¨æ•°ç»„List[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªList[]å…ƒç´ çš„å’Œã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main ()&#123; int List[MAXN], N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%d", &amp;List[i]); printf("%d\n", Sum(List, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312 34 -5 Output:41 AnalysisåŸºç¡€æ±‚å’Œï¼Œå¾ˆç®€å•ã€‚ Code123456789int Sum ( int List[], int N )&#123; int i,ret=0; for(i=0; i&lt;N; i++) &#123; ret+=list[i]; &#125; return ret;&#125; 6-4 æ±‚è‡ªå®šç±»åž‹å…ƒç´ çš„å¹³å‡æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ S[]çš„å¹³å‡å€¼ï¼Œå…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Average( ElementType S[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„S[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªS[]å…ƒç´ çš„å¹³å‡å€¼ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Average(S, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:13.77 AnalysisåŸºç¡€æ±‚å¹³å‡å€¼ï¼Œå¾ˆç®€å•ã€‚ Code12345678910ElementType Average( ElementType S[], int N )&#123; ElementType sum=0; int i=0; for(; i&lt;N; i++) &#123; sum+=S[i]; &#125; return sum/N;&#125; 6-5 æ±‚è‡ªå®šç±»åž‹å…ƒç´ çš„æœ€å¤§å€¼æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ S[]ä¸­çš„æœ€å¤§å€¼ï¼Œå…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Max( ElementType S[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„S[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªS[]å…ƒç´ ä¸­çš„æœ€å¤§å€¼ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case1234567891011121314151617#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Max(S, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:34.00 AnalysisåŸºç¡€æ±‚æœ€å¤§å€¼ï¼Œä¹Ÿå¾ˆç®€å•ã€‚ Code12345678910ElementType Max( ElementType S[], int N )&#123; int i=0; ElementType max=S[i]; for(; i&lt;N; i++) &#123; if(max &lt; S[i]) max = S[i]; &#125; return max;&#125; 6-6 æ±‚å•é“¾è¡¨ç»“ç‚¹çš„é˜¶ä¹˜å’Œæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚å•é“¾è¡¨Lç»“ç‚¹çš„é˜¶ä¹˜å’Œã€‚è¿™é‡Œé»˜è®¤æ‰€æœ‰ç»“ç‚¹çš„å€¼éžè´Ÿï¼Œä¸”é¢˜ç›®ä¿è¯ç»“æžœåœ¨intèŒƒå›´å†…ã€‚ Function interface definitionint FactorialSum( List L );å…¶ä¸­å•é“¾è¡¨Listçš„å®šä¹‰å¦‚ä¸‹ï¼š123456typedef struct Node *PtrToNode;struct Node &#123; int Data; /* å­˜å‚¨ç»“ç‚¹æ•°æ® */ PtrToNode Next; /* æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆ */&#125;;typedef PtrToNode List; /* å®šä¹‰å•é“¾è¡¨ç±»åž‹ */ Test procedure case1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* å­˜å‚¨ç»“ç‚¹æ•°æ® */ PtrToNode Next; /* æŒ‡å‘ä¸‹ä¸€ä¸ªç»“ç‚¹çš„æŒ‡é’ˆ */&#125;;typedef PtrToNode List; /* å®šä¹‰å•é“¾è¡¨ç±»åž‹ */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf("%d", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf("%d", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf("%d\n", FactorialSum(L)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:35 3 6 Output:846 Analysisé“¾è¡¨æ±‚é˜¶ä¹˜ï¼Œæœ¬è´¨ä¸Šæ˜¯å¯¹é“¾è¡¨çš„éåŽ†æ“ä½œï¼Œå¯¹é“¾è¡¨è€Œè¨€ï¼Œæ³¨æ„åˆ¤ç©ºæ¡ä»¶å¯ä»¥å†™æˆLæˆ–è€…L-&gt;Nextã€‚ Code123456789101112131415int FactorialSum( List L )&#123; int fac_sum=0,i,fac; while(L) &#123; fac=1; for(i=1; i &lt;=L-&gt;Data ; i++) &#123; fac*=i; &#125; fac_sum+=fac; L=L-&gt;Next; &#125; return fac_sum;&#125; 6-7 ç»Ÿè®¡æŸç±»å®Œå…¨å¹³æ–¹æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œåˆ¤æ–­ä»»ä¸€ç»™å®šæ•´æ•°Næ˜¯å¦æ»¡è¶³æ¡ä»¶ï¼šå®ƒæ˜¯å®Œå…¨å¹³æ–¹æ•°ï¼Œåˆè‡³å°‘æœ‰ä¸¤ä½æ•°å­—ç›¸åŒï¼Œå¦‚144ã€676ç­‰ã€‚ Function interface definitionint IsTheNumber ( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚å¦‚æžœNæ»¡è¶³æ¡ä»¶ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0ã€‚ Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf("%d %d", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf("cnt = %d\n", cnt); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:105 500 Output:cnt = 6 Analysisè¿™ä¸ªé¢˜çœ‹ç€æœ‰ç‚¹çƒ¦ï¼Œå…¶å®žä¹Ÿå¾ˆç®€å•ï¼Œå“ˆå“ˆï¼Œå‡ºé¢˜è€…ç»™å‡ºäº†#define &lt;math.h&gt;ï¼ˆæ„Ÿè°¢ï¼‰è¿™ä¸ªæ¡ä»¶åŽï¼Œå¯¹æ•°å­—çš„æ“ä½œå°±å¾ˆç®€å•äº†ï¼ˆä¸è¿‡è‡ªå·±å†™sqrtï¼Œåº”è¯¥ä¹Ÿèƒ½æžå®šðŸ˜‰ï¼‰ï¼Œæ³¨æ„sqrtè¿™ä¸ªå‡½æ•°çš„è¿”å›žç±»åž‹æ˜¯doubleï¼Œæ‰€ä»¥éœ€è¦å¼ºåˆ¶ç±»åž‹è½¬æ¢(int)sqrt(n)ï¼›çŽ°åœ¨å°±åªç”¨åŽ»åˆ¤æ–­è¿™ä¸ªæ•°ä¸­å„æ•°ä½æ•°å­—å‡ºçŽ°æ¬¡æ•°è‡³å°‘å‡ºçŽ°2æ¬¡å³å¯ã€‚æµ‹è¯•ç¨‹åºä¸­ä¼ å…¥å‡½æ•°çš„å‚é‡æ˜¯intï¼Œæ‰€ä»¥ï¼Œæ•°ç»„é•¿åº¦ç”¨11å°±å¥½äº†ã€‚ Code123456789101112131415161718int IsTheNumber ( const int N )&#123; int ret=0,digit[11]=&#123;0&#125;; if( ((int)sqrt(N)) * ((int)sqrt(N) ) == N)&#123; int i,j,temp=N; for(i=0; temp; temp/=10, i++) &#123; digit[temp%10]++; &#125; for(j=0; j&lt;10; j++)&#123; if(digit[j] &gt;= 2)&#123; ret=1; break; &#125; &#125; &#125; return ret;&#125; 6-8 ç®€å•é˜¶ä¹˜è®¡ç®—æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªè®¡ç®—éžè´Ÿæ•´æ•°é˜¶ä¹˜çš„ç®€å•å‡½æ•°ã€‚ Function interface definitionint Factorial( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ï¼Œå…¶å€¼ä¸è¶…è¿‡12ã€‚å¦‚æžœNæ˜¯éžè´Ÿæ•´æ•°ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»è¿”å›žNçš„é˜¶ä¹˜ï¼Œå¦åˆ™è¿”å›ž0ã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;int Factorial( const int N );int main()&#123; int N, NF; scanf("%d", &amp;N); NF = Factorial(N); if (NF) printf("%d! = %d\n", N, NF); else printf("Invalid input\n"); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:5 Output:5! = 120 AnalysisåŸºæœ¬é˜¶ä¹˜è®¡ç®—ï¼Œæ³¨æ„$0!=1$å³å¯ã€‚ Code12345678910111213int Factorial( const int N )&#123; int i,ret=1; if(N &lt; 0) return 0; else if(N == 0) return ret; else&#123; for(i=1; i&lt;=N; i++) &#123; ret*=i; &#125; &#125; return ret;&#125; 6-9 ç»Ÿè®¡ä¸ªä½æ•°å­—æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œå¯ç»Ÿè®¡ä»»ä¸€æ•´æ•°ä¸­æŸä¸ªä½æ•°å‡ºçŽ°çš„æ¬¡æ•°ã€‚ä¾‹å¦‚-21252ä¸­ï¼Œ2å‡ºçŽ°äº†3æ¬¡ï¼Œåˆ™è¯¥å‡½æ•°åº”è¯¥è¿”å›ž3ã€‚ Function interface definitionint Count_Digit ( const int N, const int D );å…¶ä¸­Nå’ŒDéƒ½æ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ã€‚Nçš„å€¼ä¸è¶…è¿‡intçš„èŒƒå›´ï¼›Dæ˜¯$[0, 9]$åŒºé—´å†…çš„ä¸ªä½æ•°ã€‚å‡½æ•°é¡»è¿”å›žNä¸­Då‡ºçŽ°çš„æ¬¡æ•°ã€‚ Test procedure case123456789101112#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf("%d %d", &amp;N, &amp;D); printf("%d\n", Count_Digit(N, D)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:-21252 2 Output:3 Analysisè€ƒå¯Ÿæ•°ä½æ‹†åˆ†ï¼Œæ³¨æ„å¦‚æžœæ˜¯å¤æ•°ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸ºå…¶ç»å¯¹å€¼å³å¯ã€‚ Code12345678910111213141516171819202122232425int Count_Digit ( const int N, const int D )&#123; int times=0,n; if(N &lt; 0) n = -N; else&#123; n=N; if(n == 0 &amp;&amp; D == 0)&#123; return 1; &#125; &#125; int mask=1,temp=n; do&#123; temp/=10; mask*=10; &#125;while(temp &gt; 9); temp = n; int digit; do&#123; digit = temp/mask; temp%=mask; mask/=10; if(digit == D) times++; &#125;while(mask &gt; 0); return times;&#125; 6-10 é˜¶ä¹˜è®¡ç®—å‡çº§ç‰ˆæœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªæ‰“å°éžè´Ÿæ•´æ•°é˜¶ä¹˜çš„å‡½æ•°ã€‚ Function interface definitionvoid Print_Factorial ( const int N );å…¶ä¸­Næ˜¯ç”¨æˆ·ä¼ å…¥çš„å‚æ•°ï¼Œå…¶å€¼ä¸è¶…è¿‡1000ã€‚å¦‚æžœNæ˜¯éžè´Ÿæ•´æ•°ï¼Œåˆ™è¯¥å‡½æ•°å¿…é¡»åœ¨ä¸€è¡Œä¸­æ‰“å°å‡º$N!$çš„å€¼ï¼Œå¦åˆ™æ‰“å°â€œInvalid inputâ€ã€‚ Test procedure case1234567891011#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main()&#123; int N; scanf("%d", &amp;N); Print_Factorial(N); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:15 Output:1307674368000 Analysiså¾ˆæ˜Žæ˜¾æ˜¯ä¸ªå¤§æ•°é—®é¢˜ï¼Œåˆ©ç”¨æ•°ç»„æ¥æ¨¡æ‹Ÿä¹˜æ³•è®¡ç®—å³å¯ï¼Œæ³¨æ„æ¯ä¸€æ¬¡è¿›ä½çš„å¤„ç†ï¼Œæ„Ÿè§‰æ•°ç»„æ¨¡æ‹Ÿä¹˜æ³•è¦æ¯”åŠ æ³•å®¹æ˜“ä¸€äº›ðŸ˜§ã€‚ Code12345678910111213141516171819202122232425262728293031void Print_Factorial ( const int N )&#123; if(N &lt; 0)&#123; printf("Invalid input\n"); &#125;else if(N == 0)&#123; printf("1\n"); &#125;else&#123; int carry=0,i,j,k=1,temp,num[3000]=&#123;0&#125;; num[0]=1; for(i=2; i&lt;=N; i++) &#123; for(j=0; j&lt;k; j++) &#123; temp = num[j]*i + carry; num[j] = temp%10; carry = temp/10; &#125; while(carry) &#123; num[k]=carry%10; carry/=10; k++; &#125; &#125; for(i=k-1; i&gt;0 ;i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;&#125; 6-11 æ±‚è‡ªå®šç±»åž‹å…ƒç´ åºåˆ—çš„ä¸­ä½æ•°æœ¬é¢˜è¦æ±‚å®žçŽ°ä¸€ä¸ªå‡½æ•°ï¼Œæ±‚Nä¸ªé›†åˆå…ƒç´ A[]çš„ä¸­ä½æ•°ï¼Œå³åºåˆ—ä¸­ç¬¬$âŒŠN/2+1âŒ‹$å¤§çš„å…ƒç´ ã€‚å…¶ä¸­é›†åˆå…ƒç´ çš„ç±»åž‹ä¸ºè‡ªå®šä¹‰çš„ElementTypeã€‚ Function interface definitionElementType Median( ElementType A[], int N );å…¶ä¸­ç»™å®šé›†åˆå…ƒç´ å­˜æ”¾åœ¨æ•°ç»„A[]ä¸­ï¼Œæ­£æ•´æ•°Næ˜¯æ•°ç»„å…ƒç´ ä¸ªæ•°ã€‚è¯¥å‡½æ•°é¡»è¿”å›žNä¸ªA[]å…ƒç´ çš„ä¸­ä½æ•°ï¼Œå…¶å€¼ä¹Ÿå¿…é¡»æ˜¯ElementTypeç±»åž‹ã€‚ Test procedure case12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main ()&#123; ElementType A[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;A[i]); printf("%.2f\n", Median(A, N)); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:12.30 Analysisæ³¨æ„é¢˜ç›®çš„æè¿°ï¼Œæ±‚çš„æ˜¯ä¸­ä½æ•°ï¼Œè€Œ$âŒŠN/2+1âŒ‹$è¿™é‡Œæ˜¯å‘ä¸‹å–æ•´å“¦ã€‚ä¹Ÿå³æ˜¯è¯´ï¼ŒæŒ‰ç…§é¢˜ç›®çš„è¦æ±‚ï¼Œè¦å…ˆç»™ä¼ å…¥å‡½æ•°çš„æ•°ç»„è¿›è¡ŒæŽ’åºï¼Œç„¶åŽå†è¾“å‡ºå…¶ä¸­ç¬¬$âŒŠN/2+1âŒ‹$å¤§çš„æ•°ï¼Œè€Œæ­¤æ—¶å¯¹äºŽæ•°ç»„ï¼ˆä»Ž0å¼€å§‹ï¼‰è€Œè¨€ä¸‹æ ‡å°±æ˜¯N/2ï¼›æ˜Žç™½è¿™ä¸ªä¹‹åŽï¼Œè¿˜æœ‰æŽ’åºçš„é—®é¢˜è¦è§£å†³ï¼Œå¦‚ä½•æŽ’åºå‘¢ï¼ŸæŽ’åºç®—æ³•å¾ˆå¤šï¼Œå†’æ³¡æŽ’åºå’Œæ’å…¥æŽ’åºéƒ½æœ‰ä¸€ä¸ªæµ‹è¯•ç”¨ä¾‹æ— æ³•é€šè¿‡ï¼Œæ‰€ä»¥è¿™é‡Œä½¿ç”¨å¸Œå°”æŽ’åºã€‚ä¸¾ä¸ªå¸Œå°”æŽ’åºçš„ç®€å•ä¾‹å­ï¼Œå¯¹äºŽa[3]={3, 1, 2}è¿™ä¸ªåºåˆ—è€Œè¨€ï¼Œå¸Œå°”æŽ’åºä¼šæœ‰ä¸€ä¸ªå¢žé‡dï¼Œå¹¶æŒ‰ç…§è¿™ä¸ªå¢žé‡dæ¥è¿›è¡ŒæŽ’åºï¼Œdåˆå§‹åŒ–ä¸º3(ä¸ªæ•°)/2=1ï¼Œé‚£ä¹ˆç¬¬ä¸€æ¬¡å¸Œå°”æŽ’åºï¼Œå°±ä¼šå¯¹a[0]=3å’Œa[0+d]=2è¿™ä¸¤ä¸ªæ•°å­—è¿›è¡ŒæŽ’åºï¼Œç”±äºŽä¸å­˜åœ¨a[2]ï¼Œæ‰€ä»¥a[1]ä¸ä¼šå‚ä¸ŽæŽ’åˆ—ï¼›ç¬¬äºŒæ¬¡å¾ªçŽ¯æ—¶ï¼Œæ£€æŸ¥å·²ç»æœ‰åºå°±ä¼šè·³å‡ºå¾ªçŽ¯äº†ã€‚ Code123456789101112131415161718192021ElementType Median( ElementType A[], int N )&#123; int i,j; ElementType temp; int d; for(d=N/2; d&gt;0; d/=2) &#123; for(i=d; i&lt;N; i++) &#123; temp=A[i]; for(j=i; j&gt;=d; j-=d) &#123; if(temp &lt; A[j-d])&#123; A[j] = A[j-d]; &#125;else break; &#125; A[j]=temp; &#125; &#125; return A[N/2]; &#125; 6-12 åˆ¤æ–­å¥‡å¶æ€§æœ¬é¢˜è¦æ±‚å®žçŽ°åˆ¤æ–­ç»™å®šæ•´æ•°å¥‡å¶æ€§çš„å‡½æ•°ã€‚ Function interface definitionint even( int n );å…¶ä¸­næ˜¯ç”¨æˆ·ä¼ å…¥çš„æ•´åž‹å‚æ•°ã€‚å½“nä¸ºå¶æ•°æ—¶ï¼Œå‡½æ•°è¿”å›ž1ï¼›nä¸ºå¥‡æ•°æ—¶è¿”å›ž0ã€‚æ³¨æ„ï¼š0æ˜¯å¶æ•°ã€‚ Test procedure case123456789101112131415#include &lt;stdio.h&gt;int even( int n );int main()&#123; int n; scanf("%d", &amp;n); if (even(n)) printf("%d is even.\n", n); else printf("%d is odd.\n", n); return 0;&#125;/* ä½ çš„ä»£ç å°†è¢«åµŒåœ¨è¿™é‡Œ */ Sample Input &amp; Sample Output Input 1:-6 Output 1:-6 is even. Input 2:5 Output 2:5 is odd. Analysisåˆ¤æ–­å¥‡å¶æ€§ç›´æŽ¥å¯¹2å–ä½™å°±å¥½ï¼Œå¹¶ä¸”0æ˜¯å¶æ•°ï¼Œå¦‚æžœä¸ç¡®å®šçš„è¯å¯ä»¥æ‰‹ç®—ä¸€ä¸‹ã€‚ Code1234int even(int n)&#123; if(n%2==0) return 1; else return 0;&#125; 6-13 æŠ˜åŠæŸ¥æ‰¾ç»™ä¸€ä¸ªä¸¥æ ¼é€’å¢žæ•°åˆ—ï¼Œå‡½æ•°int Search_Bin(SSTable T, KeyType k)ç”¨æ¥äºŒåˆ†åœ°æŸ¥æ‰¾kåœ¨æ•°åˆ—ä¸­çš„ä½ç½®ã€‚ Function interface definitionint Search_Bin(SSTable T, KeyType k)å…¶ä¸­Tæ˜¯æœ‰åºè¡¨ï¼Œkæ˜¯æŸ¥æ‰¾çš„å€¼ã€‚ Test procedure case123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct &#123; KeyType key; &#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable; void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) cin&gt;&gt;T.R[i].key; &#125;int Search_Bin(SSTable T, KeyType k);int main () &#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;"NOT FOUND"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125;/* è¯·åœ¨è¿™é‡Œå¡«å†™ç­”æ¡ˆ */ Sample Input &amp; Sample Output Input 1:51 3 5 7 97 Output 1:4 Input 2:51 3 5 7 910 Output 2:NOT FOUND Analysisé¢˜ç›®ç»™å‡ºçš„æµ‹è¯•ç¨‹åºæ˜¯C++çš„è¯­æ³•ï¼Œä½†æ˜¯ä¹Ÿæ²¡äº‹ï¼Œæœ‰Cçš„åŠŸåº•çœ‹æ‡‚æ˜¯æ²¡æœ‰å¤ªå¤§é—®é¢˜çš„ï¼Œä¸è¿‡å®žé™…ä¸Šï¼Œå› ä¸ºï¼Œè¦å†™çš„åªæ˜¯å‡½æ•°ï¼Œå¥½åƒè·Ÿå…¶ä»–çš„å¥½åƒä¹Ÿæ²¡å•¥å…³ç³»ï¼Œä¸»è¦çœ‹æ‡‚æœ‰åºè¡¨Lçš„ç»“æž„å°±å¥½äº†ã€‚å¦ä¸€ä¸ªï¼Œå°±æ˜¯æŠ˜åŠæŸ¥æ‰¾çš„ç®—æ³•äº†ï¼Œå¤§è‡´æ€è·¯å°±æ˜¯åˆ©ç”¨å·¦æ ‡è®°å’Œå³æ ‡è®°æ¥éåŽ†æœ‰åºè¡¨ï¼Œå¦‚æžœæœ‰ç¬¦åˆæ¡ä»¶çš„å€¼å°±å¼¹å‡ºå³å¯ã€‚ Code1234567891011121314151617181920int Search_Bin(SSTable T, KeyType k)&#123; int serial_num=0,left,right=T.length,mid=1,j=1; while(j &lt;= T.length)&#123; mid=(left + right)/2; if(T.R[mid].key == k)&#123; serial_num = mid; break; &#125;else&#123; if(T.R[mid].key &lt; k)&#123; left = mid; &#125; if(T.R[mid].key &gt; k)&#123; right = mid; &#125; &#125; j++; &#125; return serial_num; &#125; Summaryè™½è¯´æ˜¯åŸºç¡€ç¼–ç¨‹é¢˜ç›®é›†ï¼Œä½†æ˜¯æ„Ÿè§‰é‡Œé¢æœ‰äº›é¢˜ç›®è¿˜çœŸä¸æ˜¯ç‰¹åˆ«å¥½æƒ³ï¼Œå¯èƒ½æ˜¯æˆ‘æ¯”è¾ƒèœðŸ˜‚ã€‚å°½ç®¡æ¯é“é¢˜ç›®éƒ½ç»™å‡ºäº†é¢˜ç›®ã€è¾“å…¥ï¼ˆè¾“å‡ºï¼‰æ ·ä¾‹ã€è¯´æ˜Žç­‰ï¼Œå­—æ•°çœŸæ˜¯å¤šå•Šï¼Œå“ˆå“ˆï¼Œæœ‰ç‚¹æ°´æ–‡çš„å«Œç–‘ã€‚å¦å¤–ï¼Œå…³äºŽæ¯é“é¢˜ç›®çš„ACä»£ç ï¼Œå·²ç»å…¨éƒ¨è¢«ä¸Šä¼ åˆ°GitHubä¸Šäº†ï¼Œå¯ä»¥ç‚¹å‡»PTA-Basical-Programming-problem-setæ¥èŽ·å–æºæ–‡ä»¶ã€‚]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å¦‚ä½•ä½¿ç”¨Hexoæ­å»ºä¸ªæ€§åŒ–åšå®¢]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Introå¶ç„¶çœ‹åˆ°åˆ«äººç”¨Hexoå»ºç«‹çš„ä¸ªäººBlogï¼Œè§‰å¾—æŒºä¸é”™çš„ï¼Œç„¶åŽå°±å¼€å§‹åŠ¨æ‰‹æŠ˜è…¾äº†ã€‚è€Œæ­¤ç¯‡Blogå°±ç”¨æ¥è®°å½•è‡ªå·±å»ºç«‹è¿™ä¸ªBlogçš„æ•´ä¸ªè¿‡ç¨‹å’Œä¸€äº›ç»†èŠ‚å§ï¼Œè¿™æ ·åœ¨å‡ºçŽ°é—®é¢˜çš„æ—¶å€™å¯ä»¥åŠæ—¶æ‰¾åˆ°é—®é¢˜æ‰€åœ¨ï¼Œä¹Ÿå¯ä»¥ç»™å…¶ä»–äººä½œä¸ºå‚è€ƒï¼ŒæŒç»­æ›´æ–°ing(å·æ‡’ðŸ˜´)ã€‚ Preparationåœ¨å¼€å§‹å»ºç«‹Blogä¹‹å‰ï¼Œéœ€è¦å…ˆå®‰è£…ä¸‰æ ·ä¸œè¥¿ï¼šNode.jsã€Gitå’ŒHexoã€‚ä»¥ä¸‹è¿‡ç¨‹å‡å·²Win10ç³»ç»Ÿï¼ˆLinuxç³»ç»Ÿç±»ä¼¼ï¼‰ä¸ºå‡†ã€‚ Windowsç³»ç»Ÿçš„æ–‡ä»¶ç›®å½•åˆ†éš”ç¬¦æ˜¯\ï¼Œè€Œä¸æ˜¯Linuxé‡‡ç”¨çš„/ Node.jsNode.js æ˜¯ä¸€ä¸ªåŸºäºŽ Chrome V8 å¼•æ“Žçš„ JavaScript è¿è¡ŒçŽ¯å¢ƒã€‚Node.js ä½¿ç”¨äº†ä¸€ä¸ªäº‹ä»¶é©±åŠ¨ã€éžé˜»å¡žå¼ I/O çš„æ¨¡åž‹ï¼Œä½¿å…¶è½»é‡åˆé«˜æ•ˆã€‚ ç›´æŽ¥ç™¾åº¦æœç´¢Nodejså³å¯æ‰¾åˆ°å…¶å®˜æ–¹ä¸‹è½½é¡µé¢ï¼Œæˆ–è€…ç‚¹å‡»Node.jsï¼Œç›´æŽ¥ä¸‹è½½64ä½å®‰è£…windowså®‰è£…ç¨‹åºå³å¯ã€‚ä¸‹è½½å¥½ä¹‹åŽï¼Œç›´æŽ¥å®‰è£…å³å¯ï¼Œå¯ä»¥ä¿®æ”¹é»˜è®¤çš„å®‰è£…è·¯å¾„åˆ°ä½ è®¾å®šçš„ç£ç›˜æ–‡ä»¶å¤¹ä¸‹ã€‚ GitGit æ˜¯ä¸€ä¸ªå¼€æºçš„åˆ†å¸ƒå¼ç‰ˆæœ¬æŽ§åˆ¶ç³»ç»Ÿï¼Œå¯ä»¥æœ‰æ•ˆã€é«˜é€Ÿåœ°å¤„ç†ä»Žå¾ˆå°åˆ°éžå¸¸å¤§çš„é¡¹ç›®ç‰ˆæœ¬ç®¡ç†ã€‚ ä¸ŽNode.jsåŒæ ·ï¼Œæˆ‘ä»¬ç›´æŽ¥ç™¾åº¦æœç´¢Gitå³å¯æ‰¾åˆ°å…¶å®˜æ–¹ä¸‹è½½é¡µé¢ï¼Œä½†æ˜¯å®˜æ–¹åœ°å€çš„ä¸‹è½½é€Ÿåº¦å¾ˆæ…¢ï¼Œä¸è¿‡å¥½åœ¨Gitå¹¶ä¸å¤§ï¼Œä¸éœ€è¦å¤ªé•¿æ—¶é—´å°±å¯ä»¥ä¸‹è½½å¥½ï¼Œæˆ–è€…ç‚¹å‡»ä¸‹é¢çš„é“¾æŽ¥ï¼Œç›´æŽ¥ä¸‹è½½ã€‚64-bit Git for Windows Setup64-bit Git for Windows Portable HexoHexo æ˜¯ä¸€ä¸ªå¿«é€Ÿã€ç®€æ´ä¸”é«˜æ•ˆçš„åšå®¢æ¡†æž¶ã€‚Hexo ä½¿ç”¨ Markdownï¼ˆæˆ–å…¶ä»–æ¸²æŸ“å¼•æ“Žï¼‰è§£æžæ–‡ç« ï¼Œåœ¨å‡ ç§’å†…ï¼Œå³å¯åˆ©ç”¨é“ä¸½çš„ä¸»é¢˜ç”Ÿæˆé™æ€ç½‘é¡µã€‚ å®‰è£…Hexoæ¯”è¾ƒç®€å•ï¼Œåœ¨CMDæˆ–è€…PowerShellé”®å…¥npm install -g hexo-cliåŽè¿è¡Œå³å¯ã€‚ä»Žè¿™é‡Œå¯ä»¥çœ‹å‡ºï¼ŒHexoçš„å®‰è£…å…¶å®žæ˜¯ä¾èµ–Node.jsçš„npmæ¥è¿›è¡Œçš„ã€‚ Checkoutå®‰è£…å¥½äº†ä¹‹åŽï¼Œéœ€è¦æ£€æŸ¥æ˜¯å¦èƒ½æ­£å¸¸ä½¿ç”¨ï¼Œåœ¨CMDæˆ–PowerShellå†…è¿è¡Œä»¥ä¸‹å‘½ä»¤å³å¯ã€‚~\hexo12345678910111213141516171819202122232425node -vgit versionhexo version#å›žæ˜¾ä¿¡æ¯ä¾æ¬¡å¦‚ä¸‹ï¼šv10.15.1git version 2.20.1.windows.1hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.1v8: 6.8.275.32-node.12uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e å¦‚æžœå¾—åˆ°ç±»ä¼¼ä»¥ä¸Šçš„ç»“æžœï¼Œé‚£ä¹ˆè¯´æ˜ŽNodeã€Gitå’ŒHexoèƒ½å¤Ÿæ­£å¸¸ä½¿ç”¨ã€‚ Setupå®‰è£…å®ŒæˆHexoåŽï¼Œæˆ‘ä»¬å°±å¯ä»¥å¼€å§‹å»ºç«™äº†ã€‚ Init - åˆå§‹åŒ–æ³¨ï¼šæ ¹æ®ä½ é€‰æ‹©å­˜å‚¨çš„ä½ç½®ï¼Œå¯ä»¥åœ¨ä»»æ„ç›˜ç¬¦å’Œæ–‡ä»¶å¤¹ä¸‹è¿è¡Œä»¥ä¸‹å‘½ä»¤ï¼Œä¸”å‡å¯åœ¨CMDæˆ–PowerShellå†…æ‰§è¡Œã€‚ Hexoåˆå§‹åŒ–çš„å‘½ä»¤ä¸ºï¼šC:\Users\test&gt; hexo init &lt;folder name&gt;ï¼Œä»¥C:\Users\testä¸ºä¾‹ï¼Œå¦‚æžœåœ¨è¿™ä¸ªè·¯å¾„æ‰§è¡Œä¸Šè¿°å‘½ä»¤åŽï¼Œä¼šåœ¨testæ–‡ä»¶å¤¹å†…ç”Ÿæˆä¸€ä¸ªåä¸ºfolder nameçš„æ–‡ä»¶å¤¹ï¼Œä¸”è¿™ä¸ªæ–‡ä»¶å¤¹å†…å­˜å‚¨ç€ä¸ŽHexoå³å°†ç”Ÿæˆçš„é™æ€é¡µé¢ç›¸å…³çš„é…ç½®æ–‡ä»¶ç­‰ã€‚ ç„¶åŽï¼Œè¿›å…¥åˆ°è¿™ä¸ªæ–‡ä»¶å¤¹cd &lt;folder name&gt;ï¼Œåœ¨æ‰§è¡Œnpm installã€‚ åˆå§‹åŒ–å®ŒæˆåŽï¼Œä¸€èˆ¬ä¼šå¼¹å‡ºæ–‡ä»¶å¤¹ä¿¡æ¯ï¼Œå¦‚ï¼š~\hexo1234567â”œâ”€â”€ _config.ymlâ”œâ”€â”€ package.jsonâ”œâ”€â”€ scaffoldsâ”œâ”€â”€ source| â”œâ”€â”€ _drafts| â””â”€â”€ _postsâ””â”€â”€ themes è¿™äº›ä¿¡æ¯å¯ä»¥å¸®åŠ©æˆ‘ä»¬å¿«é€Ÿç†Ÿæ‚‰Hexoçš„æ–‡ä»¶ç³»ç»Ÿã€‚ åˆ°è¿™é‡Œï¼Œå¦‚æžœæ²¡æœ‰é”™è¯¯ä¿¡æ¯äº§ç”Ÿï¼ŒHexoçš„åˆå§‹åŒ–å°±ç®—å®Œæˆäº†ã€‚ Generating - ç”Ÿæˆ ä¸‹é¢æ‰€æœ‰å†…å®¹ä¸­ä»£ç å—å†…è¿è¡Œçš„å‘½ä»¤å‡æ˜¯åœ¨ä¸Šè¿°Hexoåˆå§‹åŒ–çš„æ–‡ä»¶å¤¹ä¸‹è¿è¡Œçš„ã€‚ æŽ¥ç€ä¸Šé¢çš„æ­¥éª¤ï¼Œæ‰§è¡Œå‘½ä»¤C:\Users\test\folder name&gt; hexo generateï¼Œæ­¤å‘½ä»¤å¯ä»¥ç®€å†™ä¸ºhexo gï¼Œæ‰§è¡Œå®Œè¿™æ¡å‘½ä»¤åŽï¼ŒHexoä¼šé»˜è®¤å°†source\_postæ–‡ä»¶å¤¹ä¸‹çš„.mdæ–‡ä»¶ç”Ÿæˆä¸ºé™æ€çš„.htmlæ–‡ä»¶ï¼Œå¹¶åœ¨C:\Users\test\folder nameä¸‹åˆ›å»ºä¸€ä¸ªpublicæ–‡ä»¶å¤¹ï¼Œç”¨æ¥å­˜æ”¾ç”Ÿæˆçš„é™æ€é¡µé¢æ–‡ä»¶ã€‚ Hexo èƒ½å¤Ÿç›‘è§†æ–‡ä»¶å˜åŠ¨å¹¶ç«‹å³é‡æ–°ç”Ÿæˆé™æ€æ–‡ä»¶ï¼Œåœ¨ç”Ÿæˆæ—¶ä¼šæ¯”å¯¹æ–‡ä»¶çš„ SHA1 checksumï¼Œåªæœ‰å˜åŠ¨çš„æ–‡ä»¶æ‰ä¼šå†™å…¥ã€‚æˆ‘ä»¬å¯ä»¥åˆ©ç”¨hexo generate --watchå‘½ä»¤æ¥ä½¿ç”¨è¿™ä¸ªåŠŸèƒ½ã€‚ å½“ç„¶ï¼Œè¿˜å¯ä»¥ä¸Žéƒ¨ç½²å‘½ä»¤é…åˆä½¿ç”¨ï¼Œå¦‚ï¼š~\hexo1234567hexo generate --deployhexo deploy --generate#ä¸Šé¢çš„ä¸¤æ¡å‘½ä»¤æ˜¯ç­‰ä»·çš„#ç®€å†™hexo g -dhexo d -g Server - æœåŠ¡å™¨å½“æœåŠ¡å™¨è¿è¡Œæˆ‘ä»¬çš„ç½‘ç«™è¿›ç¨‹åŽï¼Œè¿œç¨‹çš„å®¢æˆ·ç«¯æ‰å¯ä»¥æ‰“å¼€ç½‘ç«™ã€‚ä¸‹é¢ï¼Œåœ¨ä»‹ç»Hexoä¸‹æœåŠ¡å™¨çš„ç›¸å…³å‘½ä»¤å’Œè®¾ç½®ã€‚ æŽ¥ç€ä¸Šé¢çš„æ­¥éª¤ï¼Œæ‰§è¡Œå‘½ä»¤C:\Users\test\folder name&gt; hexo serverï¼Œæ­¤å‘½ä»¤å¯ä»¥ç®€å†™ä¸ºhexo sï¼Œæ‰§è¡Œå®Œè¿™æ¡å‘½ä»¤åŽï¼ŒHexoçš„Blogé¡µé¢ä¼šè¿è¡Œåœ¨http://Localhost:4000/ï¼Œè¿™ä¸ªé¡µé¢ä¸‹ï¼Œå¯ä»¥ç›´æŽ¥åœ¨æµè§ˆå™¨å†…æ‰“å¼€ï¼Œæ‰“å¼€åŽå³å¯çœ‹åˆ°Hexoç”Ÿæˆçš„Blogä¸»é¡µé¢äº†ã€‚ æ ¹æ®Hexoå®˜ç½‘çš„è¯´æ˜Žï¼Œåœ¨ä¹‹å‰çš„Hexo 3.0ä¸­ï¼ŒHexoå°†æœåŠ¡å™¨ç‹¬ç«‹æˆäº†ä¸ªåˆ«æ¨¡å—ï¼Œéœ€è¦å…ˆå®‰è£…hexo-serveræ‰èƒ½ä½¿ç”¨ã€‚æ‰§è¡Œnpm install hexo-server --saveï¼Œç­‰å¾…å®‰è£…å®ŒæˆåŽï¼Œæ‰§è¡Œhexo så³å¯ã€‚ åœ¨æœåŠ¡å™¨å¯åŠ¨æœŸé—´ï¼ŒHexoä¼šç›‘è§†æ–‡ä»¶å˜åŠ¨å¹¶è‡ªåŠ¨æ›´æ–°ï¼Œæ— é¡»é‡å¯æœåŠ¡å™¨ã€‚æ‰€ä»¥ï¼Œåœ¨å†™Blogçš„æ—¶å€™ï¼Œå¯ä»¥ç›´æŽ¥åœ¨çº¿æŸ¥çœ‹ã€‚ æ‰§è¡Œhexo s -p &lt;port number&gt;ï¼Œå¯ä»¥å°†é¡µé¢è¿è¡Œåœ¨æŒ‡å®šçš„æœ¬åœ°ç«¯å£ã€‚è‹¥æ‰§è¡Œhexo server -i x.x.x.xï¼Œå¯ä»¥å°†é¡µé¢è¿è¡Œåœ¨æŒ‡å®šçš„IPåœ°å€ä¸Šï¼Œå°±åªèƒ½é€šè¿‡æŒ‡å®šçš„è¿™ä¸ªIPæ¥è®¿é—®ç«™ç‚¹äº†ã€‚ä¾‹å¦‚ï¼Œå¯¹äºŽä¸€å°ä½¿ç”¨æ— çº¿ç½‘ç»œçš„ç¬”è®°æœ¬ç”µè„‘ï¼Œé™¤äº†æŒ‡å‘æœ¬æœºçš„127.0.0.1å¤–ï¼Œé€šå¸¸è¿˜æœ‰ä¸€ä¸ª192.168.*.*çš„å±€åŸŸç½‘IPï¼Œå¦‚æžœåƒä¸Šé¢é‚£æ ·ä½¿ç”¨-i 192.168.*.*ä½œä¸ºå‚æ•°ï¼Œå¯èƒ½å°±ä¸èƒ½ç”¨127.0.0.1æ¥è®¿é—®ç«™ç‚¹äº†ã€‚å¯¹äºŽæœ‰å…¬ç½‘IPçš„ä¸»æœºï¼Œå¦‚æžœæ‚¨æŒ‡å®šä¸€ä¸ªå±€åŸŸç½‘IPä½œä¸º-iå‚æ•°çš„å€¼ï¼Œé‚£ä¹ˆä¹Ÿå°±æ— æ³•é€šè¿‡å…¬ç½‘æ¥è®¿é—®ç«™ç‚¹ã€‚ å¦å¤–ï¼Œåœ¨é™æ€æ¨¡å¼ä¸‹ï¼ŒæœåŠ¡å™¨åªå¤„ç†publicæ–‡ä»¶å¤¹å†…çš„æ–‡ä»¶ï¼Œè€Œä¸ä¼šå¤„ç†æ–‡ä»¶å˜åŠ¨ï¼Œåœ¨æ‰§è¡Œæ—¶ï¼Œåº”è¯¥å…ˆè‡ªè¡Œæ‰§è¡Œhexo generateï¼Œæ­¤æ¨¡å¼é€šå¸¸ç”¨äºŽç”Ÿäº§çŽ¯å¢ƒï¼ˆProduction modeï¼‰ä¸‹ã€‚ Deploymentéƒ¨ç½²éœ€è¦æŒ‡å®šgit repositoryï¼ˆä»“åº“ï¼‰ï¼Œä¸”éœ€è¦å¯¹æœ¬æœºçš„Gitè¿›è¡Œé…ç½®ã€‚ æˆ–è€…ç›´æŽ¥ä½¿ç”¨æœåŠ¡å™¨ï¼Œå¦‚æžœæœåŠ¡å™¨å­˜åœ¨å…¬ç½‘IPï¼Œé‚£ä¹ˆæ‰§è¡Œhexo såŽï¼Œå°±å¯ä»¥ç”¨æœåŠ¡å™¨çš„å…¬ç½‘IPåŽ»è®¿é—®è¿™ä¸ªç«™ç‚¹äº†ã€‚ä½†æ˜¯è¿™æ ·ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå½“å…³é—­æœåŠ¡å™¨çš„è¿œç¨‹è¿žæŽ¥ä¹‹åŽï¼Œç”¨hexo så‘½ä»¤äº§ç”Ÿçš„è¿›ç¨‹ä¼šå…³é—­ï¼Œè¿™æ ·å°±å¯¼è‡´æ— æ³•å†è®¿é—®äº†ï¼Œå¯ä»¥ä½¿ç”¨hexo s &amp;å‘½ä»¤æ¥ä½¿è¿›ç¨‹åœ¨åŽå°æŒç»­è¿è¡Œã€‚ å½“éœ€è¦å…³é—­è¿™ä¸ªè¿›ç¨‹çš„æ—¶å€™ï¼Œç»“æŸæŽ‰è¿™ä¸ªè¿™ä¸ªè¿›ç¨‹å³å¯ã€‚ Git Setting - Git é…ç½®è¿™éƒ¨åˆ†æ¶‰åŠGitçš„ç”¨æ³•ï¼Œå»ºè®®åŽ»Baiduæˆ–GoogleæŸ¥è¯¢ä¸€ä¸‹Gitçš„ç›¸å…³ä½¿ç”¨æ–¹æ³•ï¼Œè¿™é‡Œæ”¾ä¸€ä¸ªGitæ•™ç¨‹é“¾æŽ¥ï¼Œå·ç§°å²ä¸Šæœ€æµ…æ˜¾æ˜“æ‡‚çš„Gitæ•™ç¨‹ï¼Œéžå¹¿å‘Šã€‚ Sign Up - åˆ›å»ºè´¦å·è‹¥æ²¡æœ‰Githubè´¦å·ï¼Œè¯·åŽ»Githubå®˜ç½‘æ³¨å†Œä¸€ä¸ªï¼Œå¡«å†™å¥½é‚®ç®±ã€ç”¨æˆ·åå’Œå¯†ç ï¼Œé‚®ç®±éœ€è¦éªŒè¯ã€‚ Creat Repositories - åˆ›å»ºä»“åº“åˆšåˆ›å»ºå¥½çš„Githubè´¦å·ï¼Œç³»ç»Ÿä¼šé»˜è®¤å¸¦ä½ åˆ›å»ºä¸€ä¸ªrepo(repositories)ï¼Œå¯ä»¥ç›´æŽ¥åˆ›å»ºä¸€ä¸ªç»™Hexoç”¨çš„ä»“åº“ï¼Œä¹Ÿå¯ä»¥å…ˆåˆ›å»ºä¸€ä¸ªæµ‹è¯•repoæ¥ç†Ÿæ‚‰ä¸€ä¸‹åˆ›å»ºçš„æµç¨‹ã€‚ æ³¨æ„ï¼š æ–°å»ºçš„ä»“åº“åä¸ºusername.github.ioï¼Œè¿™é‡Œçš„usernameæ˜¯ä½ çš„githubè´¦å·åç§°ï¼Œè¿™æ ·Hexoéƒ¨ç½²åˆ°Githubä¸Šçš„é™æ€é¡µé¢ï¼Œå°±å¯ä»¥é€šè¿‡http://username.github.ioæ¥è¿›è¡Œè®¿é—®äº†ã€‚ githubåˆ›å»ºçš„ä»“åº“å¯èƒ½ä¸ä¼šç«‹å³ç”Ÿæ•ˆï¼Œå¯èƒ½éœ€è¦ç­‰å¾…10-30åˆ†é’Ÿã€‚ åˆ›å»ºæˆåŠŸåŽï¼Œé€šè¿‡Hexoéƒ¨ç½²çš„é™æ€é¡µé¢æ–‡ä»¶å°±æ”¾åˆ°è¿™é‡Œäº†ã€‚ SSH key - é…ç½®SSHå¯†é’¥SSHä¸ºSecure Shellçš„ç¼©å†™ï¼ŒSSHæ˜¯å»ºç«‹åœ¨åº”ç”¨å±‚åŸºç¡€ä¸Šçš„å®‰å…¨åè®®ï¼Œæ˜¯å¯é çš„ä¸“ä¸ºè¿œç¨‹ç™»å½•ä¼šè¯å’Œå…¶ä»–ç½‘ç»œæœåŠ¡æä¾›å®‰å…¨æ€§çš„åè®®ã€‚åœ¨ä½¿ç”¨githubæäº¤ä»£ç æ—¶ï¼Œéœ€è¦è´¦æˆ·æƒé™ï¼Œç›´æŽ¥ä½¿ç”¨ç”¨æˆ·åå’Œå¯†ç ä¸æ˜¯ä¸€ä¸ªå®‰å…¨çš„é€‰æ‹©ï¼Œæ­£å¥½Githubä¸Šæä¾›äº†ssh keyç›¸å…³çš„æœåŠ¡ã€‚ æ‰“å¼€Git Bashï¼Œæ‰§è¡Œ$ cd ~/.sshï¼Œè‹¥æç¤ºNo such file or directoryï¼Œè¯´æ˜Žä½ æœªä½¿ç”¨è¿‡sshã€‚è‹¥å¯ä»¥è¿›å…¥æ­¤ç›®å½•(è¿™é‡Œç”¨ç›®å½•æ˜¯å› ä¸ºä¸ŽWindowsçš„æ–‡ä»¶å¤¹æ¦‚å¿µåŒºåˆ†å¼€ï¼Œå› ä¸ºGit Bashæ˜¯Linux Shell)ï¼Œåˆ™æ‰§è¡Œlsï¼ŒæŸ¥çœ‹å½“å‰ç›®å½•ä¸‹çš„æ–‡ä»¶ï¼Œä¸€èˆ¬åªæœ‰ä¸€ä¸ªå«åšknown_hostsçš„æ–‡ä»¶ï¼Œè¿™ä¸ªæ–‡ä»¶æ˜¯ä½ ç”¨sshç™»å½•è®¾å¤‡åŽç”Ÿæˆçš„ä¸€äº›å¯†é’¥ä¿¡æ¯ã€‚ ç»§ç»­åœ¨Git Bashä¸­æ‰§è¡Œssh-keygen -t rsa -C &quot;your email&quot;ï¼Œè¿™é‡Œçš„your emailæ˜¯ä½ æ³¨å†ŒGithubæ‰€ä½¿ç”¨çš„é‚®ç®±ã€‚ç„¶åŽè¿žç»­3æ¬¡å›žè½¦ï¼Œæœ€ç»ˆä¼šç”Ÿæˆä¸€ä¸ªåä¸ºid_rsa.pubçš„æ–‡ä»¶ï¼Œç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€é‡Œé¢çš„å†…å®¹åŽï¼Œå¤åˆ¶å¥½ã€‚ç„¶åŽï¼Œæ‰“å¼€ä½ çš„Githubä¸»é¡µï¼Œè¿›å…¥ä¸ªäººè®¾ç½®ï¼Œæ‰¾åˆ°SSH and GPG keysï¼Œç‚¹å‡»New SSH keyï¼Œå°†å¤åˆ¶çš„å†…å®¹ç²˜è´´åˆ°keyæ ä¸‹ï¼Œè®¾ç½®titleåŽï¼Œç‚¹å‡»Add SSH keyå³å®ŒæˆSSH keyçš„é…ç½®ã€‚ åˆ«æ€¥ï¼Œè¿˜æ²¡å®Œï¼ŒæŽ¥ç€åœ¨Git Bashä¸­è¿è¡Œssh -T git@github.comï¼Œè¿™é‡Œä¸éœ€è¦ä¿®æ”¹é‚®ç®±ï¼Œè‹¥æç¤ºä¿¡æ¯ä¸ºAre you sure you want to continue connecting (yes/no)?ï¼Œè¾“å…¥yesåŽï¼Œå°†ä¼šæç¤ºHi &#39;your github-id&#39;! You&#39;ve successfully authenticated, but Github does not provides shell access.ï¼Œæ­¤æ—¶è¯´æ˜ŽGitçš„SSH keyå·²é…ç½®æˆåŠŸï¼ ç´§æŽ¥ç€ï¼Œè¿˜éœ€è¦é…ç½®ï¼š12$ git config --global user.name "username" # your github-id$ git config --global user.email "xxx@xx.com"# your email with github ä»¥ä¸Šä¸¤æ¡å‘½ä»¤çš„ä½œç”¨æ˜¯ï¼Œå°†ä½ ä¹‹åŽçš„æ¯æ¬¡åœ¨githubä¸Šå‘èµ·çš„æäº¤éƒ½å†™å…¥è¿™äº›ä¿¡æ¯ã€‚å¯¹äºŽgitè€Œè¨€ï¼Œä½¿ç”¨äº†--globalé€‰é¡¹çš„å‘½ä»¤ï¼Œåªéœ€è¿è¡Œä¸€æ¬¡ã€‚å¦å¤–ï¼ŒGitè‡ªå¸¦çš„git configè¿˜å¯ä»¥å¸®åŠ©æˆ‘ä»¬è®¾ç½®Gitçš„å¤–è§‚å’Œè¡Œä¸ºçš„é…ç½®å˜é‡ï¼Œè¿›ä¸€æ­¥çš„ä¿¡æ¯ï¼Œè¯·å‚è€ƒGitå®˜æ–¹æ–‡æ¡£å†…å«ä¸­æ–‡ç¿»è¯‘ã€‚ Hexo Config - Hexo è®¾ç½®Hexo çš„é…ç½®æ¯”è¾ƒç®€å•ã€‚ æ‰“å¼€ç”± Hexo åˆå§‹åŒ–çš„åšå®¢æ–‡ä»¶å¤¹ï¼Œæ‰¾åˆ°_config.ymlæ–‡ä»¶ï¼Œç”¨æ–‡æœ¬ç¼–è¾‘å™¨æ‰“å¼€ï¼Œä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼š ~\hexo\_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: + type: git+ repo: git@github.com:username/username.github.io.git+ branch: master ä¿®æ”¹å¥½åŽï¼Œä¿å­˜å³å¯ã€‚è‹¥ä¸çŸ¥é“repoå¦‚ä½•è®¾ç½®ï¼Œè¯·å‚ç…§ä¸‹å›¾ã€‚ æŽ¥ç€ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å®‰è£…ä¸€ä¸ªæ’ä»¶æ¥ä¸ºHexoæä¾›éƒ¨ç½²åŠŸèƒ½ã€‚æ‰“å¼€ CMD ï¼Œæ‰§è¡Œnpm install hexo-deployer-git --saveï¼Œè‹¥æç¤ºPermisson denied (publickey).ï¼Œåˆ™æ‰“å¼€Git Bashå†æ¬¡æ‰§è¡Œæ­¤å‘½ä»¤å³å¯ã€‚æ³¨æ„è¿™ä¸ªæ­¥éª¤éœ€è¦åœ¨åšå®¢æœ¬åœ°çš„æ ¹ç›®å½•ä¸‹è¿›è¡Œã€‚ åœ¨éƒ¨ç½²åˆ°Github Pagesçš„è¿‡ç¨‹ä¸­ï¼Œå¿…é¡»å…ˆæ‰§è¡Œhexo gç”Ÿæˆé™æ€é¡µé¢ä¹‹åŽï¼Œæ‰å¯ä»¥æ‰§è¡Œhexo dåŽï¼Œä¼šåŒæ—¶å…ˆé»˜è®¤æ‰§è¡ŒHexo gå‘½ä»¤ï¼Œå› ä¸ºHexoéƒ¨ç½²åˆ°Github Pagesä¸Šçš„æ–‡ä»¶éœ€è¦Hexoå…ˆæœ¬åœ°ç”Ÿæˆï¼Œè€ŒHexoæœ¬åœ°ç”Ÿæˆé™æ€é¡µé¢æ—¶ï¼Œä¼šåœ¨åšå®¢æ ¹ç›®å½•ä¸‹ç”Ÿæˆåä¸ºpublicçš„æ–‡ä»¶å¤¹ï¼Œå¹¶å°†ç”Ÿæˆå¥½çš„é™æ€é¡µé¢æ–‡ä»¶å…¨éƒ¨æ”¾åˆ°è¿™ä¸ªæ–‡ä»¶å¤¹ä¸‹ï¼Œç»§è€Œå†å°†è¿™ä¸ªæ–‡ä»¶å¤¹å†…çš„æ–‡ä»¶å…¨éƒ¨éƒ¨ç½²åˆ°githubä¸Šã€‚ å»ºè®®æ¯æ¬¡åœ¨è¿è¡Œhexo dä¹‹å‰ï¼Œåšå¥½å¤‡ä»½ Personalized Customizationä¸‹é¢ä»‹ç»æœ‰å…³Hexoçš„ä¸€äº›åŸºç¡€é…ç½®ã€‚ Change Themes - ä¿®æ”¹ä¸»é¢˜Hexoé»˜è®¤çš„ä¸»é¢˜å«åšlandscapeï¼Œå¤–å½¢ä¸­è§„ä¸­çŸ©ï¼Œä½†è‚¯å®šæ»¡è¶³ä¸äº†å¤§å®¶çš„ä¸ªæ€§åŒ–éœ€æ±‚ï¼Œæ‰€ä»¥è¿˜éœ€è¦æ›´åŠ ä¸ªæ€§åŒ–çš„ä¸»é¢˜æ‰å¯ä»¥ã€‚ æ­¤Blogåº”ç”¨çš„ä¸»é¢˜ä¸ºNexTï¼Œè¿™æ¬¾ä¸»é¢˜é£Žæ ¼ç®€çº¦ï¼Œè®¾è®¡ç²¾ç¾Žï¼Œæ„Ÿè°¢ä½œè€…IIssNanã€‚ Download Themes - ä¸‹è½½ä¸»é¢˜ä¸‹è½½NexTä¸»é¢˜çš„æ–¹æ³•å¾ˆå¤šï¼ŒèŽ·å–èµ„æºçš„é€”å¾„ä¹Ÿå¾ˆå¤šï¼ŒæŽ¨èä½¿ç”¨gitæ¥å®‰è£…ã€‚- ~\hexo123&lt;!-- folder nameä¸ºä¹‹å‰Hexoç”Ÿæˆçš„æ–‡ä»¶å¤¹ --&gt;$ cd &lt;folder name&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next git clone xxxè¿™æ¡å‘½ä»¤å±žäºŽgitçš„åº”ç”¨èŒƒç•´ï¼Œæ˜¯gitçš„åŸºæœ¬æ“ä½œã€‚å¦å¤–ï¼Œtheme-nextè¿™æ¡é“¾æŽ¥å¯ä»¥ç›´æŽ¥æ‰“å¼€ï¼Œæ˜¯NexTå®˜æ–¹çš„github repoï¼Œå…¶ä¸Šä¹Ÿä»‹ç»äº†å¦‚ä½•å®‰è£…å’Œå‡çº§NexTã€‚ Enable NexT - å¯ç”¨ä¸»é¢˜å¯¹äºŽHexoè€Œè¨€ï¼Œæ‰€æœ‰çš„ä¸»é¢˜å¯ç”¨æ¨¡å¼éƒ½æ˜¯ä¸€æ ·çš„ã€‚å½“å…‹éš†/ä¸‹è½½å®ŒæˆåŽï¼Œæ‰“å¼€Hexoç”Ÿæˆç›®å½•ä¸‹çš„_config.ymlæ–‡ä»¶ï¼Œæ‰¾åˆ°themeå­—æ®µï¼Œå°†å…¶å€¼ä¿®æ”¹ä¸ºnextåŽï¼Œä¿å­˜å³å¯ã€‚~\hexo\_config.yml1theme: next ä¸€èˆ¬è€Œè¨€ï¼Œåœ¨å¯ç”¨ next ä¸»é¢˜åŽï¼Œé¡µé¢ä¼šç›´æŽ¥ä½¿ç”¨è¯¥ä¸»é¢˜ï¼Œä½†ä¸æŽ’é™¤æ„å¤–çš„æƒ…å†µï¼Œè¿™æ—¶ï¼Œå¯ä»¥ä½¿ç”¨hexo cleanæ¸…æ¥šç¼“å­˜ï¼Œå¹¶ç”¨hexo gé‡æ–°ç”Ÿæˆæ–°çš„é¡µé¢ã€‚ Checkout - éªŒè¯åœ¨CMDä¸‹ï¼Œæ‰§è¡Œhexo sï¼Œæ˜¾ç¤ºINFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.åŽï¼Œæ‰“å¼€é“¾æŽ¥http://localhost:4000/ï¼Œå³å¯çœ‹åˆ°æ•ˆæžœã€‚æˆ–è€…ï¼Œå¯ä»¥æ‰§è¡Œhexo s --debugï¼Œè¿™æ ·åœ¨æœåŠ¡å¯åŠ¨çš„è¿‡ç¨‹ä¸­ï¼Œå¦‚æžœç”±é”™è¯¯äº§ç”Ÿï¼Œå‘½ä»¤è¡Œä¼šè‡ªåŠ¨è¾“å‡ºè¿™äº›å¼‚å¸¸ä¿¡æ¯ï¼Œæ°å·§ä½ ç¢°åˆ°é—®é¢˜çš„è¯ï¼Œè¿™äº›ä¿¡æ¯å¯ä»¥å¸®åŠ©ä»–äººæ›´å¥½çš„å®šä½é”™è¯¯ã€‚ å½“ä½ çœ‹åˆ°ä¸Žä¸‹å›¾ç±»ä¼¼çš„æ•ˆæžœæ—¶ï¼Œè¯´æ˜Žå·²ç»æˆåŠŸå®‰è£…NexTä¸»é¢˜ã€‚ NexT Basic Setting - NexT åŸºæœ¬è®¾ç½®ä¸‹é¢ä»‹ç»ä¸Žæœ‰å…³NexTçš„åŸºæœ¬è®¾ç½®ã€‚ ä¸ºæ–¹ä¾¿èµ·è§ï¼Œå°†Hexoç”Ÿæˆçš„ç›®å½•ä¸‹çš„_config_ymlç§°ä¸ºç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå°†nextä¸»é¢˜æ–‡ä»¶ç›®å½•ä¸‹çš„_config.ymlç§°ä¸ºä¸»é¢˜é…ç½®æ–‡ä»¶ Scheme - ä¸»é¢˜æ ·å¼Scheme æ˜¯ NexT æä¾›çš„ä¸€ç§ç‰¹æ€§ï¼Œå€ŸåŠ©äºŽSchemeï¼ŒNexTä¸ºä½ æä¾›å¤šç§ä¸åŒçš„å¤–è§‚ã€‚åŒæ—¶ï¼Œå‡ ä¹Žæ‰€æœ‰çš„é…ç½®éƒ½å¯ä»¥åœ¨ Scheme ä¹‹é—´å…±ç”¨ã€‚é€šè¿‡æ›´æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œå¯ä»¥è¾¾åˆ°åˆ‡æ¢Schemeçš„æ•ˆæžœã€‚åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼Œå¯ä»¥æ‰¾åˆ°å¦‚ä¸‹å†…å®¹ï¼Œå°†éœ€è¦å¯ç”¨çš„Schemeå‰çš„æ³¨é‡Š#åˆ é™¤å³å¯ã€‚~\hexo\themes\next\_config.yml12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini å…·ä½“æ•ˆæžœå¯è‡ªè¡Œå°è¯•ã€‚ Language - è¯­è¨€ç›®å‰NexTæ”¯æŒçš„è¯­è¨€æœ‰å¤šç§ï¼Œå¯åœ¨å…¶languagesæ–‡ä»¶å¤¹ä¸‹æŸ¥çœ‹ï¼Œè¿™é‡Œçš„è¯­è¨€ä¸Žé¡µé¢ä¸Šæ˜¾ç¤ºçš„é¡¹ç›®çš„è¯­è¨€ä¸€è‡´ï¼Œè®¾ç½®ä¸ºå“ªä¸€ç§è¯­è¨€ï¼Œå°±æ˜¾ç¤ºä¸ºå“ªä¸€ç§è¯­è¨€ã€‚è¯­è¨€è®¾å®šéœ€è¦åœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­è®¾ç½®ï¼Œåœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­ï¼Œæ‰¾åˆ°å¦‚ä¸‹å†…å®¹ï¼Œå°†å…¶å€¼ä¿®æ”¹ä¸ºNexTä¸»é¢˜å¯¹åº”è¯­è¨€åç§°æ–‡ä»¶å³å¯ã€‚~\hexo folder\_config.yml1language: zh-CN language:åŽçš„å€¼å¿…é¡»è¦ä¸ŽNexTçš„è¯­è¨€æ–‡ä»¶åç§°ä¸€è‡´ï¼Œæ‰èƒ½åœ¨é¡µé¢ä¸Šç”Ÿæ•ˆ Avatar Setting - å¤´åƒè®¾ç½®ç¼–è¾‘ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°avatarè®¾ç½®éƒ¨åˆ†ï¼Œå¦‚ï¼š~\hexo\themes\next\_config.yml1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /uploads/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true å…¶ä¸­ï¼Œurlä¸ºå¤´åƒçš„å­˜æ”¾è·¯å¾„ï¼Œroundedå’Œopacityä»¥åŠrotatedä¸ºNexTä¸»é¢˜ä¸‹ä¸Žå¤´åƒç›¸å…³çš„ä¸‰ä¸ªä¸ªæ€§åŒ–åŠŸèƒ½é€‰é¡¹ï¼Œæ³¨é‡Šå†…å®¹ä¸ºè¯´æ˜Žã€‚ ä»¥ä¸Šå†…å®¹å±žäºŽNexTè‡ªå¸¦åŸºç¡€è®¾ç½®ï¼Œæ›´åŠ ä¸ªæ€§åŒ–çš„è®¾ç½®éœ€è¦ä»Žå…¶ä»–ä½ç½®è¿›è¡Œè®¾ç½® Site Information - ç«™ç‚¹ä¿¡æ¯ç«™ç‚¹ä¿¡æ¯åŒ…å«çš„å†…å®¹ä¸»è¦æœ‰æ ‡é¢˜ã€ä½œè€…ã€ä»‹ç»ç­‰ï¼Œå¯ä»¥åœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­è¿›è¡Œè®¾ç½®ã€‚ç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°å¦‚ä¸‹éƒ¨åˆ†ï¼š~\hexo\_config.yml123456title: examplesubtitle:description: author: examplelanguage: zh-CNtimezone: ä»¥ä¸Šå†…å®¹åˆ†åˆ«å¯¹åº”ï¼šæ ‡é¢˜ã€å‰¯æ ‡é¢˜ã€ä»‹ç»ã€ä½œè€…ã€è¯­è¨€ã€æ—¶åŒºï¼Œä¿®æ”¹å„ä¸ªå­—æ®µçš„å€¼ï¼Œå³å¯å®Œæˆä¿®æ”¹ã€‚ languageä¸Žä¸Šæ–‡ä¸­çš„è¯­è¨€è®¾ç½®æ˜¯ç›¸åŒçš„descriptionå­—æ®µåŽé¢çš„å€¼ä¼šè¢«æ”¾åœ¨å¤´åƒçš„ä¸‹é¢timezoneé»˜è®¤ä¸ºæœ¬æœºæ‰€åœ¨æ—¶åŒºï¼Œå¯è®¾ç½®ä¸ºå…¶ä»–æ—¶åŒº Menu Setting - èœå•è®¾ç½®èœå•é…ç½®åŒ…æ‹¬ä¸‰ä¸ªéƒ¨åˆ†ï¼Œç¬¬ä¸€æ˜¯èœå•é¡¹çš„æ˜¾ç¤ºæ–‡æœ¬ï¼Œç¬¬äºŒæ˜¯èœå•é¡¹çš„é“¾æŽ¥ï¼Œç¬¬ä¸‰æ˜¯èœå•é¡¹å¯¹åº”çš„å›¾æ ‡ã€‚ NexTä½¿ç”¨çš„æ˜¯Font Awesomeæä¾›çš„å›¾æ ‡ï¼ŒFont Awesomeæä¾›äº†600+çš„å›¾æ ‡ï¼Œå¯ä»¥æ»¡è¶³ç»å¤§çš„å¤šæ•°çš„åœºæ™¯ï¼ŒåŒæ—¶æ— é¡»æ‹…å¿ƒåœ¨Retinaå±å¹•ä¸‹å›¾æ ‡æ¨¡ç³Šçš„é—®é¢˜ã€‚ ç¼–è¾‘ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼Œæ‰¾åˆ°å¦‚ä¸‹éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat å°†éœ€è¦å¯ç”¨çš„èœå•é¡¹å‰çš„æ³¨é‡Š#åˆ é™¤å³å¯ï¼Œ||ä¹‹å‰ä¸ºç›®æ ‡é¡µé¢çš„é“¾æŽ¥ï¼Œ||ä¹‹åŽä¸ºå¯¹åº”çš„é¡¹ç›®å›¾æ ‡ã€‚åœ¨èœå•å›¾æ ‡å¼€å¯çš„æƒ…å†µä¸‹ï¼Œå¦‚æžœèœå•é¡¹ä¸Žèœå•æœªåŒ¹é…ï¼ˆæ²¡æœ‰è®¾ç½®æˆ–è€…æ— æ•ˆçš„Font Awesomeå›¾æ ‡åå­—ï¼‰çš„æƒ…å†µä¸‹ï¼ŒNexTä¼šä½¿ç”¨question iconä½œä¸ºå›¾æ ‡ã€‚æ‰€ä»¥ï¼Œå€¼å¿…é¡»è¦ä¸Žå›¾æ ‡åç§°ä¸¥æ ¼ä¸€è‡´ã€‚ è‹¥æ­¤æ—¶æ²¡æœ‰ä¸ºæ–°å¼€å¯çš„èœå•é¡¹è®¾ç½®é¡µé¢ï¼Œç‚¹å‡»æ‰“å¼€æ—¶ä¼šå‡ºçŽ°Cannot GET /xxx/çš„é”™è¯¯ Sidebar Setting - ä¾§æ è®¾ç½®é»˜è®¤æƒ…å†µä¸‹ï¼Œä¾§æ ä»…åœ¨æ–‡ç« é¡µé¢ï¼ˆæ‹¥æœ‰ç›®å½•åˆ—è¡¨ï¼‰æ—¶æ‰æ˜¾ç¤ºï¼Œå¹¶æ”¾ç½®äºŽå³ä¾§ä½ç½®ã€‚å¯ä»¥é€šè¿‡ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„sidebarå­—æ®µæ¥æŽ§åˆ¶ä¾§æ çš„è¡Œä¸ºã€‚ä¾§æ çš„è®¾ç½®ä¸»è¦åŒ…æ‹¬ä¸¤ä¸ªéƒ¨åˆ†ï¼Œå…¶ä¸€æ˜¯ä¾§æ çš„ä½ç½®ï¼Œå…¶äºŒæ˜¯ä¾§æ æ˜¾ç¤ºçš„æ—¶æœºã€‚å½“ç„¶äº†ï¼Œè¿˜åŒ…å«ä¸€éƒ¨åˆ†ä¸ªæ€§åŒ–è®¾ç½®ã€‚ è®¾ç½®ä¾§æ çš„ä½ç½®ï¼Œä¿®æ”¹sideba.positionçš„å€¼ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml1234sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right è®¾ç½®ä¾§æ æ˜¾ç¤ºçš„æ—¶æœºï¼Œä¿®æ”¹sidebar.displayçš„å€¼ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml12345sidebar: display: post #display: always #display: hide #display: remove é¢å¤–çš„ä¸ªæ€§åŒ–è®¾ç½®ï¼Œå¦‚ï¼š ~\hexo\themes\next\_config.yml12345678# Sidebar offset from top menubar in pixels (only for Pisces | Gemini).offset: 12# Back to top in sidebar.b2t: false# Scroll percent label in b2t button.scrollpercent: true# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true Summary - å°ç»“åˆ°è¿™é‡Œï¼ŒNexTåŸºæœ¬è®¾ç½®å°±å®Œæˆäº†ã€‚å¯ä»¥å‘çŽ°ï¼Œå¯¹äºŽHexoè€Œè¨€ï¼Œä¸Žé¡µé¢æ ·å¼ç›´æŽ¥ç›¸å…³çš„å†…å®¹éƒ½æ˜¯å­˜äºŽä¸»é¢˜æ–‡ä»¶ä¸­çš„ï¼Œæ‰€ä»¥ï¼Œæˆ‘ä»¬ç›´æŽ¥ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶å°±å¥½äº†ï¼Œä½†è‹¥æŸäº›ä¸»é¢˜ç¼ºå°‘éƒ¨åˆ†åŠŸèƒ½çš„è®¾ç½®ï¼Œé‚£ä¹ˆå¯èƒ½å°±éœ€è¦ç¬¬ä¸‰æ–¹æ’ä»¶æ¥å®Œæˆäº†ã€‚ Custom with NexT - NexT è‡ªå®šä¹‰ æ„Ÿè°¢ä»¥ä¸‹åšæ–‡ï¼šæ‰“é€ ä¸ªæ€§è¶…èµžåšå®¢Hexo+NexT+GitHubPagesçš„è¶…æ·±åº¦ä¼˜åŒ–Git Pages ä½¿ç”¨æŒ‡å— hexoçš„nextä¸»é¢˜ä¸ªæ€§åŒ–æ•™ç¨‹:æ‰“é€ ç‚«é…·ç½‘ç«™ éšç€NexTç‰ˆæœ¬çš„ä¸æ–­æ›´æ–°ï¼ŒåŽŸå…ˆéœ€è¦ç”¨æˆ·è‡ªå·±å®žçŽ°çš„ç‰¹æ•ˆï¼ˆå¾€æºç æ–‡ä»¶ä¸­æ·»åŠ ä»£ç ï¼‰ï¼Œæœ‰ä¸€éƒ¨åˆ†å·²ç»è¢«å¤§ä½¬ä»¬å†…åµŒåˆ°NexTä¸»é¢˜å†…äº†ï¼Œæ„Ÿè°¢ä»–ä»¬ã€‚ ç½‘ç«™é¡µè„šçš„çº¢å¿ƒåŠå…¶åŠ¨ç”»æ•ˆæžœä¿®æ”¹å¦‚ä¸‹ä»£ç éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml12345678910footer: # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" å½“ç„¶äº†ï¼Œä¾ç„¶å¯ä»¥åœ¨Font Awesomeæ‰¾åˆ°ä½ è‡ªå·±æƒ³è¦çš„å›¾æ ‡è¿›è¡Œæ›¿æ¢ã€‚ å¼€å¯RSSæ ¹æ®å®˜æ–¹çš„è¯´æ˜Žï¼ŒNexTä¸­RSSæœ‰ä¸‰ä¸ªè®¾ç½®é€‰é¡¹ï¼Œå­˜æ”¾åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼š falseï¼šç¦ç”¨RSSï¼Œä¸åœ¨é¡µé¢ä¸Šæ˜¾ç¤ºRSSè¿žæŽ¥ ç•™ç©ºï¼šä½¿ç”¨Hexoç”Ÿæˆçš„Feedé“¾æŽ¥ï¼Œéœ€è¦å…ˆå®‰è£…hexo-generator-feedæ’ä»¶ å…·ä½“çš„é“¾æŽ¥åœ°å€ï¼šé€‚ç”¨äºŽå·²ç»çƒ§åˆ¶è¿‡Feedçš„æƒ…å½¢ ä»¥ç•™ç©ºä¸ºä¾‹ï¼Œå…ˆå®‰è£…hexo-generator-feedæ’ä»¶ã€‚~\hexo1npm install hexo-generator-feed --save å®‰è£…å®ŒæˆåŽï¼Œè®¾ç½®ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\_config.yml12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png ç„¶åŽé‡æ–°å¼€å¯é¡µé¢å³å¯åœ¨ä¾§æ çœ‹åˆ°RSSè¿žæŽ¥ã€‚ å¼€å¯æ‰“èµæ‰“èµåŠŸèƒ½å·²ç»è¢«é›†æˆåœ¨NexTä¸»é¢˜ä¸­äº†ï¼Œé‚£ä¹ˆåªéœ€è¦æ”¾å…¥æˆ‘ä»¬çš„äºŒç»´ç ï¼Œå¹¶å¼€å¯ç›¸åº”çš„åŠŸèƒ½å³å¯ã€‚ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ï¼š~\hexo\theme\next\_config.yml12345reward: enable: true comment: If it helps, would you?:P wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg æ­¤æ—¶ï¼Œåˆ·æ–°é¡µé¢å³å¯çœ‹åˆ°çº¢è‰²çš„æ‰“èµæŒ‰é’®ï¼Œç‚¹å‡»æ‰“å¼€å°±èƒ½çœ‹åˆ°æ”¯ä»˜çš„äºŒç»´ç äº†ã€‚ å…³é—­æ‰“èµæ–‡å­—çš„åŠ¨ç”»æ•ˆæžœå°†é¼ æ ‡æŒ‡é’ˆæ”¾åˆ°äºŒç»´ç ä¸Šé¢æ—¶ä¼šæœ‰ä¸€ä¸ªé—®é¢˜ï¼šä¸‹é¢çš„å­—ä½“ä¼šä¸æ–­çš„æŠ–åŠ¨ï¼Œè‹¥ä¸å–œæ¬¢å¯ä»¥å°†è¿™ä¸ªåŠ¨ç”»æ•ˆæžœå…³é—­ã€‚æ³¨é‡ŠæŽ‰å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_common\components\post\post-reward.styl1234567/* close the roll of reward font#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ ä¿å­˜ä¿®æ”¹åŽå³å¯ç”Ÿæ•ˆã€‚ å¯ç”¨æœ¬åœ°æœç´¢æœ¬åœ°æœç´¢åŠŸèƒ½ä¾èµ–æ’ä»¶hexo-generator-searchdbï¼Œå…ˆå®‰è£…æ’ä»¶ï¼š~\hexo1npm install hexo-generator-searchdb --save ç„¶åŽç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo fold\_config.yml12345search: path: search.xml field: post format: html limit: 10000 æŽ¥ç€åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯ç”¨æœ¬åœ°æœç´¢åŠŸèƒ½ï¼š~\hexo\theme\next\_config.yml12local_search: enable: true é…ç½®å®ŒæˆåŽï¼Œéœ€è¦é‡æ–°ç”Ÿæˆé™æ€é¡µé¢ã€‚ ä¿®æ”¹æ–‡ç« å†…é“¾æŽ¥æ–‡æœ¬æ ·å¼æ·»åŠ å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml1234567891011// change the style of inner link.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; ä¹Ÿå¯åœ¨~\hexo\themes\next\source\css\_common\components\post\post.stylè¿™ä¸ªæ–‡ä»¶å†…æ·»åŠ ä»¥ä¸Šä»£ç ã€‚ å¢žåŠ ä»£ç å—å¤åˆ¶åŠŸèƒ½æ­¤åŠŸèƒ½ä¹Ÿè¢«é›†æˆåœ¨NexTä¸»é¢˜ä¸­äº†ï¼Œä¿®æ”¹ä»¥ä¸‹ä»£ç ï¼Œå³å¯ç›´æŽ¥å¼€å¯ã€‚~\hexo\themes\next\_config.yml123456codeblock: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true æ·»åŠ ä»£ç å—åœ†è§’å¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml123// codeblocks with rounded rectangle.highlight &#123; border-radius: 18px;&#125;pre &#123; border-radius: 8px;&#125; å…·ä½“æ•°å€¼å¯è‡ªè¡Œè®¾ç½®ï¼Œä¹Ÿå¯ä¿®æ”¹ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¦‚ä¸‹ä»£ç ï¼š12345codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1- border_radius:+ border_radius: 8 ä¿®æ”¹å•è¡Œä»£ç é¢œè‰²å¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.yml12// the colour of single line codecode &#123; color: #ec7f00; &#125; å…·ä½“é¢œè‰²å¯è‡ªè¡Œè®¾ç½®ã€‚ æ·»åŠ åšæ–‡å­—æ•°ç»Ÿè®¡åŠŸèƒ½å­—æ•°ç»Ÿè®¡åŠŸèƒ½ä¾èµ–æ’ä»¶hexo-symbols-count-timeï¼Œå…ˆå®‰è£…æ’ä»¶ï¼š ~\hexo1npm install hexo-symbols-count-time --save ç„¶åŽç¼–è¾‘ç«™ç‚¹é…ç½®æ–‡ä»¶ï¼Œå¢žåŠ ä»¥ä¸‹ä»£ç ï¼š~\hexo\_config.yml12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true æŽ¥ç€åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯ç”¨å­—æ•°ç»Ÿè®¡åŠŸèƒ½ï¼š~\hexo\theme\next\_config.yml123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275 awlwpmsuffixAverage Word Length(chars count in word). Default: 4 CN â‰ˆ 2 EN â‰ˆ 5 RU â‰ˆ 6 Words Per Minute. Default: 275. Slow â‰ˆ 200 Normal â‰ˆ 275 Fast â‰ˆ 350 If time to read less then 60 minutes, added suffix as string parameter. Default: mins. è®¾ç½®é¡µé¢æ˜¾ç¤ºçš„æ–‡ç« ç¯‡æ•°NexTé»˜è®¤ä¼šå¯¹æ­¤è¿›è¡Œé…ç½®ï¼Œä½†å¦‚æžœéœ€è¦æ›´å¤šä¸ªæ€§åŒ–è®¾ç½®éœ€è¦å®‰è£…æ’ä»¶ï¼š~\hexo123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag ç„¶åŽåœ¨ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­ï¼Œæ·»åŠ å¦‚ä¸‹ä»£ç ï¼Œæ³¨æ„Hexo 3ä»¥ä¸Šçš„ç‰ˆæœ¬ä¸å…è®¸é…ç½®æ–‡ä»¶å­˜åœ¨é‡å¤çš„é€‰é¡¹è®¾ç½®ã€‚å› æ­¤æœ€å¥½å…ˆæ£€æŸ¥ä¸‹ç«™ç‚¹é…ç½®æ–‡ä»¶ä¸­æ˜¯å¦æœ‰å­˜åœ¨ä¸Šè¿°åŒåçš„é…ç½®ã€‚å¦‚æžœå­˜åœ¨ï¼Œè¯·å°†ä¸¤è€…é…ç½®åœ¨ä¸€èµ·ã€‚~\hexo\_config.yml12345678910111213141516# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# å…¨å±€åˆ†é¡µï¼Œæ¯é¡µ8ç¯‡æ–‡ç« index_generator: # ä¸»é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 5archive_generator: # å½’æ¡£é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 20 yearly: true monthly: truetag_generator: # æ ‡ç­¾é¡µæ˜¾ç¤ºå¤šå°‘ç¯‡æ–‡ç«  per_page: 10category_generator: per_page: 12 æ˜¾ç¤ºèœå•æ çš„æ–‡ç« æ•°é‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š- ~\hexo\themes\next\_config.yml12menu_settings: badges: true å¼€å¯è¯„è®ºå’Œé˜…è¯»ç»Ÿè®¡åŠŸèƒ½NexTæ”¯æŒçš„é˜…è¯»ç»Ÿè®¡å’Œè¯„è®ºåŠŸèƒ½è¾ƒå¤šï¼Œé’ˆå¯¹ä¸åŒçš„æ’ä»¶ï¼Œéƒ½è¿›è¡Œäº†é›†æˆï¼Œç”¨æˆ·éœ€è¦åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯ç”¨æˆ·è‡ªå·±æŒ‡å®šçš„æŸä¸€ç±»åŠŸèƒ½ï¼›åŒæ—¶å¯èƒ½éƒ¨åˆ†åŠŸèƒ½éœ€è¦å€ŸåŠ©åˆ°å…¶ä»–ç¬¬ä¸‰æ–¹åº”ç”¨ï¼Œæ‰€ä»¥ç”¨æˆ·è¿˜éœ€è¦è‡ªå·±æ³¨å†Œç¬¬ä¸‰æ–¹åº”ç”¨å¹¶é…ç½®å¥½è¿™äº›ç¬¬ä¸‰æ–¹åº”ç”¨çš„åŠŸèƒ½ã€‚ä»¥åŸºäºŽleancloudçš„ç»Ÿè®¡åŠŸèƒ½ä¸ºä¾‹ï¼Œéœ€è¦ç”¨æˆ·è‡ªèº«æ³¨å†Œleancloudçš„è´¦å·ï¼Œå¹¶è¿›è¡Œé…ç½®ï¼Œè¿™é‡Œç»™å‡ºå®˜æ–¹é“¾æŽ¥â€”â€”ä½¿ç”¨leancloudä¸ºnextä¸»é¢˜æ·»åŠ é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½ã€‚ æ·»åŠ è¯„è®ºç³»ç»ŸNexTå†…åµŒæ”¯æŒçš„è¯„è®ºç³»ç»Ÿä¹Ÿæœ‰å¤šç§ï¼ˆè¿™å¾—æ„Ÿè°¢å„ä½å¤§å¤§çš„å¥‰çŒ®ï¼‰ï¼Œä¸Žå¼€å¯ç»Ÿè®¡åŠŸèƒ½çš„æ–¹æ³•ä¸€è‡´ã€‚åŸºäºŽleancloudçš„é˜…è¯»é‡ç»Ÿè®¡åŠŸèƒ½é…ç½®å®ŒæˆåŽï¼Œleancloudå†…çš„èµ„æºä¾ç„¶å¯ä»¥ç”¨æ¥ç»Ÿè®¡è¯„è®ºè®°å½•ï¼Œä¸è¿‡è¦é…åˆValineä¸€èµ·ä½¿ç”¨ï¼›Valineçš„åŸºæœ¬é…ç½®æ–¹æ³•å¯ä»¥å‚è€ƒé“¾æŽ¥â€”â€”å¿«é€Ÿå¼€å§‹ | Valineã€‚ä¸è¿‡å¯¹äºŽNexTè€Œè¨€ï¼Œåªéœ€è¦åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯ValineåŠŸèƒ½ï¼Œå¹¶åœ¨Leancloudé…ç½®å¥½é’ˆå¯¹è¯„è®ºçš„åº”ç”¨å³å¯ï¼Œè€Œè¿™éƒ¨åˆ†å†…å®¹å¯ä»¥ä»Žå®˜æ–¹é“¾æŽ¥å†…æ‰¾åˆ°ç­”æ¡ˆã€‚å¦å¤–ï¼Œéœ€è¦æ³¨æ„ä¸€ä¸‹çš„æ˜¯ï¼ŒValineçš„å¤´åƒæ˜¯åŸºäºŽGravatarçš„ï¼Œç”¨æˆ·éœ€è¦è‡ªå·±åŽ»Gravataræ³¨å†Œè´¦å·ï¼Œå¹¶è®¾ç½®å¤´åƒã€‚ ä¿®æ”¹åº•éƒ¨æ ‡ç­¾æ ·å¼ä¿®æ”¹åº•éƒ¨æ ‡ç­¾æ ·å¼éœ€è¦å¯¹æ•´ä¸ªé¡µé¢çš„ä¸€äº›å…ƒç´ è¿›è¡Œä¿®æ”¹ã€‚ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\layout\_marco\post.swig1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; å³å°†rel=&quot;tag&quot;&gt;#åŽçš„#æ›¿æ¢ä¸º&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;å³å¯ã€‚æ›¿æ¢å®ŒåŽï¼Œéœ€è¦é‡æ–°ç”Ÿæˆé¡µé¢ã€‚ æ·»åŠ ä¾§æ é“¾æŽ¥ä¾§æ é“¾æŽ¥çš„åŠŸèƒ½åœ¨NexTå†…å¯ç›´æŽ¥æ‰¾åˆ°ã€‚ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\_config.yml123456links_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com æ·»åŠ ä¾§æ ç¤¾äº¤å›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç éƒ¨åˆ†ï¼š~\hexo\themes\next\_config.yml123456789101112social: GitHub: https://github.com/Bachzart || github E-Mail: mailto:whistlesilp@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype å¯è‡ªè¡Œæ·»åŠ è‡ªå·±éœ€è¦çš„ç¤¾äº¤å›¾æ ‡å’Œé“¾æŽ¥ã€‚ ä¿®æ”¹ç½‘ç«™çš„å›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml12345favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png+ small: /uploads/example_16px.png+ medium: /uploads/example_32px.png å¼€å¯å³ä¸Šè§’Githubå›¾æ ‡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml123456 # Follow me on GitHub banner in right-top corner. # Usage: `permalink || title` # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the title and aria-label name.- # github_banner: https://github.com/bachzart || Follow me on GitHub :)+ # github_banner: https://github.com/bachzart || Follow me on GitHub :) ä¿®æ”¹åšå®¢å†…å­—ä½“ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml123456789font:- enable: false+ enable: true+ host: //fonts.loli.net global: external: true+ family:+ family: Noto Serif SC size:å…¶ä¸­Noto Serif SCæ˜¯æ€æºå®‹ä½“ï¼Œå¦å¤–åœ¨æ•´ä¸ªfontè®¾ç½®é¡¹ä¸­è¿˜æœ‰å¾ˆå¤šå…¶ä»–çš„é€‰é¡¹å¯ä»¥è¿›è¡Œè®¾ç½®ï¼Œä¸å¦¨å°è¯•ä¸€ä¸‹ã€‚ æ·»åŠ é¡¶éƒ¨åŠ è½½æ¡ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\layout\_partials\head\head.swig12345678910111213141516171819 &lt;meta charset="UTF-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/&gt;+ &lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;+ &lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;+ &lt;style&gt;+ .pace .pace-progress &#123;+ background: #1E92FB; /*the color of strip*/+ height: 3px;+ &#125;+ .pace .pace-progress-inner &#123;+ box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*the color of shadow*/+ &#125;+ .pace .pace-activity &#123;+ border-top-color: #1E92FB; /*border-top-color*/+ border-left-color: #1E92FB; /*border-left-color*/+ &#125;+ &lt;/style&gt; &lt;meta name="theme-color" content=""/&gt; å¼€å¯æ–‡ç« åº•éƒ¨ç‰ˆæƒå£°æ˜Žä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\themes\next\_config.yml1234creative_commons: license: by-nc-sa sidebar: false+ post: trueå¦‚è‹¥è§£æžå®ŒæˆåŽï¼Œæ˜¾ç¤ºhttp://yoursite.com/xxx.htmlï¼Œè¯·ä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\Hexo\_config.yml1234+ url: http://bachzart.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults:ä¿å­˜å¥½åŽï¼Œé‡æ–°ç”Ÿæˆå³å¯ã€‚ æ·»åŠ  fancybox æ’ä»¶fancybox2/3çš†éœ€è¦å…ˆå®‰è£…æ‰èƒ½ä½¿ç”¨ï¼Œå®‰è£…ååˆ†ç®€å•ï¼Œå¯ä»¥å‚è€ƒfancybox3ï¼Œå…ˆä¸‹è½½fancybox3æ–‡ä»¶ï¼š~\Hexo\themes\next1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox ç„¶åŽåœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¼€å¯åŠŸèƒ½ï¼š~\Hexo\themes\next_config.yml1+ fancybox: trueæ•ˆæžœå¦‚ä¸‹å›¾ï¼š Writing Skillsä¸‹é¢å†…å®¹å°†å¼€å§‹ä»‹ç»ä¸€äº›å†™ä½œæŠ€å·§ã€‚ Writing with NexTNexTä¸»é¢˜è‡ªèº«æ‰©å±•äº†å¾ˆå¤šæ–¹ä¾¿å†™ä½œçš„åŠŸèƒ½ï¼Œæ—¢æé«˜äº†æ–‡ç« çš„ç¾Žæ„Ÿï¼Œåˆè®©ä½œè€…æ›´åŠ å®¹æ˜“çš„è¡¨è¾¾è§‚ç‚¹ã€‚ é™¤äº†ä»£ç å—å¤–ï¼Œå…¶ä»–å¼•ç”¨æ–¹å¼å†…éƒ½å¯ä»¥å°è¯•ä¸Ž Markdown è¯­æ³•çš„åŠ ç²—ã€å€¾æ–œã€åˆ é™¤çº¿ç­‰åŠŸèƒ½è¿›è¡ŒåµŒå¥—ä½¿ç”¨ï¼Œæ•ˆæžœæ›´ä½³ æ–‡æœ¬å±…ä¸­å¼•ç”¨æ­¤æ ‡ç­¾å°†ç”Ÿæˆä¸€ä¸ªå¸¦ä¸Šä¸‹åˆ†å‰²çº¿å’ŒåŒå¼•å·çš„å¼•ç”¨ï¼ŒåŒæ—¶å†™åœ¨å…¶å†…éƒ¨çš„åº”ç”¨æ–‡æœ¬å°†è‡ªåŠ¨å±…ä¸­ã€‚æ–‡æœ¬å±…ä¸­æ—¶ï¼Œå¤šè¡Œæ–‡æœ¬è‹¥é•¿åº¦ä¸ç­‰ï¼Œè§†è§‰ä¸Šä¼šæ˜¾å¾—ä¸å¯¹ç§°ï¼Œå› æ­¤å»ºè®®åœ¨å¼•ç”¨å•è¡Œæ–‡æœ¬çš„åœºæ™¯ä¸‹ä½¿ç”¨ã€‚ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š12345678&lt;!-- HTMLæ–¹å¼ï¼šç›´æŽ¥åœ¨ Markdown æ–‡ä»¶ä¸­ç¼–å†™ HTMLæ¥è°ƒç”¨&gt;&lt;!-- å…¶ä¸­ class=&quot;block-quote-center&quot; æ˜¯å¿…é¡»çš„ --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;bla bla bla&lt;/blockquote&gt;&lt;!-- swigè¯­æ³• --&gt;&#123;% centerquote %&#125;bla bla bla&#123;% endcenterquote %&#125;&lt;!-- ç®€å†™ --&gt;&#123;% cq %&#125;bla bla bla&#123;% endcq %&#125; æ•ˆæžœå¦‚ä¸‹å›¾ï¼šå¦å¤–è¿˜æœ‰ä¸€ç§æ–‡æœ¬å±…ä¸­å¼•ç”¨æ–¹æ³•ï¼š12&lt;!-- HTMLæ–¹å¼ --&gt;&lt;center&gt;**bla bla bla**&lt;/center&gt; æ•ˆæžœå¦‚ä¸‹ï¼š bla bla bla ä»£ç å—çš„ä¹¦å†™æ–¹æ³•codeblockä»£ç å—ç”¨æ³•å¦‚ä¸‹ï¼š1234&lt;!-- swigè¯­æ³• --&gt;&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; å¦ä¸€ç§å½¢å¼çš„ä»£ç å—ä½¿ç”¨å…­ä¸ªåå¼•å·ï¼ˆæ­£å¥½ä¸€å¯¹ï¼‰æ¥åŒ…è£¹ä»£ç å—ï¼Œ[language] [title] [url] [link text]è¿™å››ä¸ªå‚æ•°ä¹Ÿå†™åœ¨é¦–è¡Œï¼Œè¿™ä¸¤ç§æ–¹å¼ä¹¦å†™æ—¶éƒ½æ²¡æœ‰[]ã€‚titletitleurllink textlanguageæ˜¯ä»£ç è¯­è¨€çš„åç§°ï¼Œç”¨æ¥è®¾ç½®ä»£ç å—é¢œè‰²é«˜äº®ï¼Œéžå¿…é¡»titleæ˜¯é¡¶éƒ¨å·¦è¾¹çš„è¯´æ˜Žï¼Œéžå¿…é¡»urlæ˜¯é¡¶éƒ¨å³è¾¹çš„è¶…é“¾æŽ¥åœ°å€ï¼Œéžå¿…é¡»link textæ˜¯è¶…é“¾æŽ¥çš„åç§°ï¼Œéžå¿…é¡»å¦‚æžœéœ€è¦å¯¹æ¯”åŠŸèƒ½ï¼Œéœ€è¦å†™langï¼šdiffï¼Œå¹¶åœ¨ç›¸åº”çš„ä»£ç è¡Œé¦–åŠ ä¸Š-å’Œ+å³å¯ï¼Œå¯¹åº”çš„é¢œè‰²ä¹Ÿæ˜¯å¯ä»¥è‡ªå®šä¹‰çš„ï¼Œä¿®æ”¹å¦‚ä¸‹ä»£ç ï¼š~\hexo\themes\next\source\css\_custom\custom.syl1234567// the diff style of codeblockpre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125; Note PluginNexTä¸»é¢˜æ‰©å±•äº†ä¸€ç§noteæ’ä»¶ï¼Œå¯ä»¥ç”¨æ¥å•ç‹¬å±•ç¤ºé‡ç‚¹æ€§æˆ–ç»“è®ºæ€§å†…å®¹ï¼Œå…¶é…ç½®ä¿¡æ¯ä¿å­˜åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­ï¼Œå…·ä½“å¦‚ä¸‹ï¼š123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 åœ¨ä¹¦å†™æ—¶ï¼Œåœ¨.mdæ–‡ä»¶å†…ç›´æŽ¥æ’å…¥ä»¥ä¸‹ä»£ç å³å¯ï¼š1234567&lt;!-- swig --&gt;&#123;% note %&#125;bla bla bla&#123;% endnote %&#125;&lt;!-- HTML --&gt;&lt;div class=&quot;note&quot;&gt;&lt;p&gt;bla bla bla&lt;/p&gt;&lt;/div&gt; æ•ˆæžœå¦‚ä¸‹ï¼š bla bla bla å¦å¤–ï¼ŒnoteåŽæ·»åŠ default/primary/info/success/warning/dangerï¼Œå¯ä»¥å±•ç¤ºä¸åŒçš„æ ‡ç­¾æ ï¼Œåˆ†åˆ«å¦‚ä¸‹ï¼š bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla è®¾ç½®note xx no-iconå¯ä»¥ä¸æ˜¾ç¤ºå›¾æ ‡ï¼Œæ•ˆæžœå¦‚ä¸‹ï¼š æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Note-Docsã€‚ Button PluginButtonæ’ä»¶çš„ä½¿ç”¨ä¹Ÿå¾ˆç®€å•ï¼Œåœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­å¯å¼€å¯ï¼ŒåŒæ ·ç›´æŽ¥åœ¨.mdæ–‡ä»¶å†…æ’å…¥ä»¥ä¸‹ä»£ç ï¼š123&#123;% button url, text, icon [class], [title] %&#125;&lt;!-- Tag Alias --&gt;&#123;% btn url, text, icon [class], [title] %&#125; 1å¦‚ï¼š&#123;% btn #, Text %&#125; æ•ˆæžœå¦‚ä¸‹ï¼š Text æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Button-Docsã€‚ Tabs PluginTabsæ’ä»¶åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„é…ç½®å¦‚ä¸‹ï¼š1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 5 ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š1234567891011&#123;% tabs First unique name %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; æ•ˆæžœå¦‚ä¸‹ï¼šFirst unique name 1First unique name 2First unique name 3This is Tab 1.This is Tab 2.This is Tab 3. æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Tabs-Docsã€‚ Label PluginLabelæ’ä»¶åœ¨ä¸»é¢˜é…ç½®æ–‡ä»¶ä¸­çš„é…ç½®å¦‚ä¸‹ï¼š12# Label taglabel: true ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š12345&#123;% label primary@Text %&#125;&#123;% label success@Text %&#125;&#123;% label info@Text %&#125;&#123;% label warning@Text %&#125;&#123;% label danger@Text %&#125; æ•ˆæžœå¦‚ä¸‹ï¼šTextTextTextTextTextæ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Label-Docsã€‚ å›¾ç‰‡çš„å¼•ç”¨æ–¹æ³•å›¾ç‰‡çš„å¼•ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š123&#123;% fullimage /url [@lazy], [alt], [title], [size] %&#125;&lt;!-- Tag Alias --&gt;&#123;% fi /url [@lazy], [alt], [title], [size] %&#125; ä½¿ç”¨æ–¹æ³•å¦‚ä¸‹ï¼š1&#123;% fi /my_photo_gallery/test_github.png, test text, test text %&#125; æ•ˆæžœå¦‚ä¸‹å›¾ï¼š æ›´å¤šä½¿ç”¨æ–¹æ³•ï¼Œå¯ä»¥è®¿é—®Full Image-Docsã€‚ Markdown Grammarå‚è§ Markdown è¯­æ³•å¿«é€ŸæŒ‡å— Mathjax Grammarå‚è§ Mathjax è¯­æ³•å¿«é€ŸæŒ‡å—]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
