<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++ 的一些概念]]></title>
    <url>%2F2021%2F11%2F17%2FC%2B%2B-%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此文用于记录学习 C++ 过程中遇到的一些知识点。 命名空间命名空间里面包含了逻辑结构上相互关联的一组类、函数、模板等。命名空间像是一个容器，把某些在逻辑结构上相关的“对象”放在一起并与外界区分。特别的，命名空间里面的变量名或类名可以和命名空间外的变量名和类名重名。 修饰符signed、unsigned、short、long 是 C++ 中的修饰符，当 short 和 long 用来修饰 int 时，int 可省略不写，表示短整型数据或长整型数据（也就是说，没有 short 和 long 这种数据类型）。 内存分配C++ 程序在运行时，计算机内存被分为程序代码区、全局数据区、堆区、栈区四个部分。 静态存储区分配静态分配方式下的内存在程序编译的时候就已经分配好了且存在于程序的整个运行过程。例如 static 变量，其生命周期随程序的结束而结束，而飞像一般变量随函数或作用域的结束而结束。 当然，除了 static 变量，还有一种全局对象 static object，也可以存放在静态存储区。 栈内存分配栈内存分配方式下的内存是存在于某作用域的一块空间。例如调用某个函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会被自动释放。 堆内存分配堆内存分配，也称动态内存分配，通常使用 new 和 delete 关键字进行管理。堆内存空间可由用于手动分配和释放，所以其生存周期由用户指定，较为灵活。但频繁的分配、释放大小不同的堆空间会产生内存碎片。 函数重载函数重载指定义一个函数参数类型或参数个数不同的重名函数。当程序执行时，编译器将调用参数类型与函数形参类型一致的函数。 面向对象程序设计的特点这部分内容都是概念性内容，应该算是所有面向对象的程序语言的基本特性。 抽象抽象是指对具体问题或对象进行概括，抽出其公共性质并加以描述的过程。一般情况抽象分为数据抽象和行为抽象，其中数据抽象是指一个对象区别于另一个对象的特征，行为抽象是指某类对象的共同特征。 封装封装是指将抽象得到的数据和行为相结合，隐藏对象属性和实现细节且仅对外提供公共访问方式的过程。 继承继承是指通过代码复用在保持原有类特性的基础上对子类进行具体说明的过程，通俗来说继承就是精简重复代码的手段。 多态多态是指一段程序能够处理多种类型对象的能力，函数重载就是实现多态的一种手段。在 C++ 中，多态可分为强制多态、重载多态、类型参数化多态和包含多态。 类类一般是由类名、数据成员、函数成员三部分组成。定义类的基本形式为：12345678class name &#123; public: 外部接口 protected: 保护性成员 private: 私有成员&#125; 其中 public、protected、private 表示访问控制属性，用于控制类成员的访问权限。特别的，没有分配控制属性的默认为 private 私有成员。public 成员可以在类外直接访问；protected 成员可以在子类中访问；private 成员只能被本类的成员函数访问。 类的成员函数成员函数描述了类的行为。成员函数在类中只用说明其函数的返回类型、名字和参数表，而函数的具体实现在类外说明，其基本形式为：1234567class name &#123; 函数的返回类型 函数名(参数列表)&#125;;返回值类型 类名::函数名(参数列表) &#123; 函数体&#125; 对象在 C++ 中，对象是某类事物的实例，其声明形式为：1类名 对象名;]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮滑初探]]></title>
    <url>%2F2021%2F11%2F13%2F%E8%BD%AE%E6%BB%91%E5%88%9D%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[鬼使神差的买了一双直排轮滑鞋子！😑 诺！就是下面这个东西： 事情起因是这样的：临近双十一了，想着是不是买点什么东西，天天在家闲着，偶尔出门发现走路挺远的，最近也没有骑车了，是不是整个代步工具？以来可以提高下“效率”，二来顺便锻炼身体。 结果就这样鬼使神差的想到了轮滑跟滑板，滑板其实是去年就开始想尝试玩玩的东西了，这次还是忍住了。考虑到二者都是需要身体平衡性的体育活动，索性就买轮滑鞋子了。主要还是滑板噪音有点大，这玩意好像不怎么吵？ 具体感受如何，要等玩一玩之后才能分析。 不过，拿这东西当代步工具的我，是不是又落伍了？人家的代步工具可是四个轮子的车啊！诶？突然发现，这玩意好像单脚四轮，双脚八轮，得，当我没说。 不管如何，轮滑本质是一种体育活动。当然了，至少目前而言，确实可以满足我的需求： 代步 锻炼 好吧，现在是 2021 年 11 月 13 日，今天是第一天见到这位兄弟，希望它好好待我，少让给我摔几跤。\ 日期：2021-11-14下午趁着阳光明媚的时候，折腾了 2 个小时，摔了好几次。特别有一次是完全失去平衡，屁股（准确说是尾椎骨）大面积着地，当下觉得屁股开花了，那叫一个疼，光是重新再站起来就花了几分钟。 练习时间是 2 小时没错，但是自我感觉收效甚微。仔细琢磨了一下，没想出个所以然，结果又去找了点视频看，发现好像是自己太着急了。大概意思就是目前连走都没学会就想跑了，没办法，晚上又练习了几百次原地踏步，蹲下站起，后来又尝试了一下滑行，好像找到了点感觉？但遗憾的是，不会拐弯 :(。 日期：2021-11-15傍晚练习了大概一个多小时，只是练习近距离的推步滑行和平衡前滑，感觉还行，基本上感觉大概有了吧。然后又尝试了下刹车跟转弯，感觉刹车会容易一点，但是转弯一点感觉都没抓住，可能还需要在多摔几次才能有感觉吧。是的，我现在有点后悔没买护具了，这样我活动的时候也放得开一点，不至于现在有点畏手畏脚的（毕竟昨天的屁股还历历在目，不过已经好多了）。 练习的时候突然想起来小时候学骑自行车的时候了，长辈在后面扶着座椅，我在前面骑，他们突然松开手，骗我还没有，然后我接着骑，骑着骑着就会了。其实，轮滑应该也是一样，关键就是要找到身体的所适应的平衡感。如何去找呢？只有大胆尝试，多摔几次，应该就能找到了。遗憾的是，我并没有护具来支撑我做这样的事情，但不管如何还是要继续练习下去。 日期：2021-11-16哈，今天感觉还行，练习时间在一个半小时左右，摔了四次，不过好在没有受大伤，就是右手手掌不小心挂了个彩，一个小伤口，再次说明了护具对初学者的重要性。不过，我好像有一个可以保护手掌的“护具”，明天可以试一试。 话说，今天差点刷了个嘴啃泥，好在手支撑住了。还有一次，差点栽到人家鸡笼里面了 XD。总之，没受大伤就好。 今天主要的练习内容是推步滑行和平衡前滑，感觉还行，就是动作姿势还是有些不到位。 日期：2021-11-17右腿膝盖增加一处擦伤，还好只是轻微。话说，今天绕着家滑了一圈，不得不吐槽下农村的水泥路，有些路段横条纹太多了，脚在上滑过时，颠的我脚都麻了，站都站不稳了，特别容易摔（不过，反过来想好像也能锻炼一下平衡感？🤔）。没有横条纹的路段，那滑的就很舒服了，脚上没有颠簸感，很稳当，累了就平衡前滑溜一下，然后再滑，当然滑的时间太长了，也还是要休息下的。 前几天练习转弯一点感觉没有，今天尝试了下，好像有点感觉，就跟人走路转弯一样，不用非得不动，可以迈小步滑过弯。 还有一点时觉得自己体力不太够，滑不了太远就觉得腰酸，这是什么“毛病”？还是我的姿势有些不到位，使得我的腰肌负荷过大，所以很快就觉得累了？ 日期：2021-11-18今天滑的很累，但是感觉很好，现在大概能持续滑行比较久了，对于之前的问题，今天可以稍微回答一下了： 滑不了太远就觉得累，是不是姿势不对？准确来讲，不是姿势不对，而是姿势维持的太久了。滑行的时候，为了保持身体的平衡感，一般会略微屈膝，身体前倾。很显然，即便没有穿轮滑鞋，就在平地上维持这个姿势也很累，更何况是穿了轮滑鞋。所以，应该在滑行的时候应该要直立起来，当然了，直立必须要建立在维持了平衡的基础上，不然就摔跤了。还有一点就是，身体尽可能的要放松，不要太僵硬了，肌肉太紧张了，也会容易产生疲劳。 如何转弯？转弯其实可以边滑边转（只要步子迈小点），也可以滑着转。滑着转其实就是 A 字转弯，这个动作的重点在于要使用鞋子的内刃，至于腿绷紧其实只是辅助的作用。往那边转，就用那只脚的韧。 话说，今天尝试了下冲坡，果然，两次都摔了。还有一次，滑了太久，很累，脚突然一下没劲了，直接栽草丛里了，2333。对了，今天有好几次差点要摔跤，结果都奇怪的稳住了，很诧异，应该是身体对这种失去平衡的感觉适应了一些吧。 今天基本没停过，一直在滑，滑了大概 3 个小时，最后一个小时去街上玩了一下，感觉还行，也不是很难。最后，脱下鞋子的那一刻是真的感觉全身有点酸了，出汗的感觉还是好啊。 日期：2021-11-19尝试了一下“长途”滑行，一去一来，一起是 10 公里，花了大概 1 个小时，看来现在自己的滑行速度大概也就 8 - 10 km/h 了吧，这个速度具体是什么样子的呢？就跟慢慢骑自行车一样。 整个滑行过程是在国道公路上进行的，虽然是在在公路边上滑行，但也要注意后方的车辆，注意不要反向滑行，要遵守基本的交通规则，要戴好护具。公路滑行的时候，要小心路上的小石头，当速度过快的时候，轮子一旦碰到这些石头就会突然像前冲一下，容易摔跤，所以要小心、慢速。每当这个时候，我就后悔为什么没有买护具。说实在的，如果是高速公路的话，基本不会有这种问题，相比国道而言，高速公路产生的摩擦力也会小很多，也会更加省力。但遗憾的是，那是高速公路，不是高速“滑道”，这路是给车跑的。 从拿到轮滑鞋到今天为止，差不多一周了吧，基本的滑行与东西好像掌握了，但还不是很牢固。这两天在街上滑行的动作其实已经不是刚开始学的推步滑行了，之前一直觉得自己总是喜欢用内刃，现在发现，在街上滑行的时候，脚其实是有一个上前蹬的动作的，也就是说，两脚交替滑行的时候，其实是在交替向前蹬，这时也就必然会有一只脚在前方，一只脚在后方，很显然，在后面的那只脚蹬地的时候，就会用到内刃。 总体而言，滑行时间不长，但我总觉得轮滑这个东西理论占 40%，实际占 60%，更多还是要靠身体去感受，要靠身体去熟悉踩在轮子上的平衡感，感觉自己其实算是滑着滑着就会了，也没有过分的去追求动作姿势，更多的还是靠身体感受平衡。不过，在滑行过程中，姿势也还是要尽量保持正确的，因为这样可以滑的更快、更省力。另外还有一点就是，护具是需要的，我发觉我没戴护具就敢去街上浪，实在是太莽了，真的是“艺高人胆大”。因为没有护具，也有点怕做几十公里的长途滑行，毕竟还是安全为重。]]></content>
      <categories>
        <category>Life</category>
        <category>Sport</category>
      </categories>
      <tags>
        <tag>Skating</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS 课程下的汇编笔记]]></title>
    <url>%2F2021%2F11%2F11%2FHIT-OS-%E8%AF%BE%E7%A8%8B%E4%B8%8B%E7%9A%84%E6%B1%87%E7%BC%96%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[此文用来记录在进行 HIT_OS 课程时，遇到的一些跟汇编语言相关的问题（纯汇编小白角度）。 注意：以下内容都是 x86 机器下的汇编知识。 entryentry是汇编语言中的伪指令，告诉 cpu 这段汇编程序的入口是什么，一般而言，后面跟的就是汇编程序入口。 movmov是数据传送指令，也是最基本的汇编编程指令，用于将一个数据从源地址传送到目标地址（寄存器之间的数据传送本质上也是一样），其特点是不破坏源地址单元的内容（属于复制性质，不属于搬家性质），基本用法：123! mov dst,src mov EAX,#050aH ;将十六进制数 050a 传送到通用寄存器 EAX 中 mov DI,BX ;寄存器之间传数 注意 mov 的两个操作数不能同时为段寄存器，其他注意事项等内容参考百度百科：MOV。 xor这个没啥说的，异或操作，C 语言中出现过的东西。不过在汇编这里好像用的很多？ ax ah alax 是 cpu 内部一个寄存器助记符，通常称之为累加器。以这门课上的 16 位 cpu 为例，ah（a high） 就是 ax 的高八位，al（a low） 就是 ax 的低八位。通俗来讲，若 ax=1234h，那么 ah=12h，al=34h。对应的，其他寄存器一样也有与其对应的 h 和 l。 intint 应该是汇编中专门用来调用中断的一个指令，后面跟的就是各种各样的“中断码”，不同的“中断码”实现的功能不一样。 基地址与段地址对一个程序而言，基地址就是这个程序被机器执行时机器所需要的“东西”（可以是数据也可以代码段等?）的地址，基地址就是这个这个程序的“段”的起始地址，而机器要拿到这些“东西”就需要段地址。换句话说，基地址其实跟段地址是类似的东西。具体的理解参考百科这个回答：什么是基地址和段地址？主要用途是？ 汇编中的 ## 在汇编中表示立即寻址，举个简单的例子：1mov A,#21H 该指令的意思是将值 21H 送给寄存器 A 中暂存，如果把#去掉，那么意思就是将地址 21H 里面的内容送给寄存器 A 了。 汇编中的 .参考链接：ARM中的汇编指令。 姑且认为.byte、.text这类指令是 GNU 的伪汇编指令。另外，上述文章中还有很多其他指令的介绍，也可以算作参考资料。 x86 下的寄存器参考文章里面写的已经很清楚了，但我们目前需要了解的东西比较简单，就是有多少个寄存器，名字叫什么。8086的编程模型包括 8、16 和 32 位的寄存器,按照位分类： 8 位的寄存器包括 AH，AL，BH，BL，CH，CL，DH 和 DL。 16 位寄存器包括 AX，BX，CX，DX，SP，BP，DI，SI，IP，FLAGS，CS，DS，ES，SS，FS，和 GS。 扩展的 32 位的指令包括 EAX，EBX，ECX，EDX，ESP，EBP，EDI，ESI，EIP 和 EFLAGS。 所有的 32 位寄存器和 16 位寄存器中的 FS 或者 GS 都仅仅能够在 80386 以上使用。 参考文章：Intel 80X86寄存器分类介绍 CFCF 是汇编中的进位标志位，主要用来反映运算是否产生进位或错位。如果运算结果的最高位产生了一个进位或错位，其值就为 1。与之对应的是两个跳转指令： jc 和 jnc，前者当 CF=1 时，跳转，后者反之。 jnc这条语句的功能有点类似 C 语言中的 goto，但它与 goto 不同的地方在于，它需要有一个进位。换句话说，jnc xxx这条语句之前会有运算，运算的结果会影响 CF 的值。当 CF=0 时，它就会产生与 goto 一样的功能，反之，就跳过这条语句，就是 continue 的功能了。]]></content>
      <categories>
        <category>Programming</category>
        <category>Assembly</category>
      </categories>
      <tags>
        <tag>Assembly</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HIT_OS_Basic]]></title>
    <url>%2F2021%2F11%2F10%2FHIT-OS-Basic%2F</url>
    <content type="text"><![CDATA[此系列博文用来记录 MOOC 上自学哈工大操作系统课程（由李治军老师授课）时的笔记。 L1这一节课主要是老师说明学习课程的目的和本课程的要求。另外，就是在实验楼熟悉下实验环境。 L2这一讲老师主要是在说明电脑接通电源后在做些什么事情。 关于组成计算机的五大部件（这又是老生常谈了）：输入设备、输出设备、存储器、运算器、控制器。计算机的工作方式：取指执行，“指”实际上指的是指针，这个指针指向的是位于内存中的命令。这个概念应该贯穿了整个操作系统的设计。 熟悉一下实验楼的基本操作：12345678910111213141516171819202122232425262728293031323334353637383940# 解压文件$ cd oslab$ tar -zxvf hit-oslab-linux-20110823.tar.gz -C /home/shiyanlou/# 编译内核$ cd linux-0.11$ make all # all 可省略，有时需要先 make clean # 运行内核$ cd ~/oslab # 需要再 run 这个脚本文件所在的目录下$ ./run # 执行这条命令后会出现 Bochs 的窗口# 汇编调试$ cd ~/oslab # 同样需要在这个目录下$ ./dbg-asm # 可以使用 help 来查看调试系统的命令# C 语言调试，需要使用两个窗口。# 第一个窗口$ cd \~/oslab$ ./dbg-c# 第二个窗口$ cd \~/oslab$ ./rungdb# 文件交换$ cd ~/oslab$ sudo ./mount-hdc # 先挂载$ cd hdc$ ls -l# 此时看到的文件就是 hdc-0.11.img 这个镜像文件内的文件$ cd ~/oslab$ sudo umount hdc # 读写完毕后要卸载# 1. 注意不要在读写内核文件时运行内核，也不要在运行内核时读写内核内的文件# 2. 关闭 Bochs 之前，要先执行一下 `sync` 保存一下 L3这一讲老师主要讲了操作系统启动时做的两件事： 读入系统 完成初始化 具体如何进行需要借助代码分析。 Experiment 1实验项目 1 的主题是控制系统的启动，主要包含的内容： 阅读《Linux 内核完全注释》的第 6 章，对计算机和 Linux 0.11 的引导过程进行初步的了解； 按照下面的要求改写 0.11 的引导程序 bootsect.s 有兴趣同学可以做做进入保护模式前的设置程序 setup.s。 改写 bootsect.s 主要完成如下功能：bootsect.s 能在屏幕上打印一段提示信息“XXX is booting…”，其中 XXX 是你给自己的操作系统起的名字，例如 LZJos、Sunix 等（可以上论坛上秀秀谁的 OS 名字最帅，也可以显示一个特色 logo，以表示自己操作系统的与众不同。） 改写 setup.s 主要完成如下功能： bootsect.s 能完成 setup.s 的载入，并跳转到 setup.s 开始地址执行。而 setup.s 向屏幕输出一行”Now we are in SETUP”。 setup.s 能获取至少一个基本的硬件参数（如内存参数、显卡参数、硬盘参数等），将其存放在内存的特定地址，并输出到屏幕上。 setup.s 不再加载 Linux 内核，保持上述信息显示在屏幕上即可。 改写 bootsect.s这个任务比较容易，因为老师上课的时候大致上讲过了，所以只需要按照老师给的提示来完成就行了。先把实验环境按照上个实验的步骤弄好，解压文件。 先找到 bootsect.s123$ cd linux-0.11/boot/$ ls$ vim bootsect.s 进入 bootsect.s 的编辑页面后能看到 Linus 91年写下的说明，充满了年代感。映入眼中的全是汇编代码，对于不懂汇编的人来说有点难受。不过没关系，找到指定位置然后修改就行。 首先，要修改的文本的位置是在 bootsect.s 文件内的 244 - 247 行处（直接找就行了）：1234msg1: .byte 13,10 .ascii &quot;Loading system ...&quot; .byte 13,10,13,10 改为自己喜欢的即可，这里我们改为：color_os is booting ...。接着我们还需要在修改一下要显示的字符个数，那么该如何找到代码位置呢？可想而知，这段字符串是要在开机的时候显示的，也就是说，开机后的光标干的第一件事情就是显示这串字符，那只要找到读入光标的位置就行了（其实也可以直接用 vim 的搜索功能找到与 msg1 相关的地方就可以了）。 接下来要修改的位置是在 98 行处：1mov cx,#24 上面的这个24实际上就是之前Loading system ...加上 3 个换行符、3 个回车符的和。这里，数一下修改后的字符个数，应该改为 29。 这样就差不多了，来尝试编译运行一下:12$ cd linux-0.11$ make all 没有错误提示就可以尝试运行了。12$ cd ~/oslab$ ./run 观察结果可以发现已经改成想要的结果了。 Review这里我们按照老师给的提示在完成一下这个实验。根据老师的提示，可以写出 bootsect.s 最终的源码：1234567891011121314151617181920212223242526272829entry _start_start:! read cursor pos mov ah,#0x03 ！ ah need to be set as 03, so the bios interruption can check it xor bh,bh int 0x10! print the message we set mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax ! es need to be set mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 这里再来简单解释一下这段汇编代码（毕竟没学过汇编，就当学汇编了），entry是汇编代码中的伪指令，用来指示汇编程序的入口，显然，在上述代码中，它告诉 cpu 程序的入口是 _start。!后面的内容就是注释，mov、xor这样的“标识符”在汇编里面叫做操作码，后面紧跟的就是操作数，二者之间用空格隔开，操作数之间用,隔开。 bios 0x10 中断根据 ah 的不同的值来发挥不同的功能（其他 bios 中断可能也有）。不同功能需要的输入与返回都是不想同的，这部分的内容的疑问可以查询老师给的手册上的注释，也可以直接查 bios 中断的手册。 之所以要改动寄存器 es 的值，是因为 0x10 中断规定了 es:bp 是字符串的首地址（也就是起始位置），也就是说，只有 bp 的值是无法让机器显示字符串的。 info_loop是利用 jmp 指令设置的一个循环，这条指令会让机器一直执行这个循环。如果没有这条指令，机器就会去寻找下一个能启动的设备。 .org也是汇编中的伪指令，它告诉 cpu 下面的语句从地址 510 处开始执行，相比原本的内核代码，这里舍弃掉了root_dev，所以需要将地址设置为 510，这样当我们将磁盘引导扇区（共 512 字节）的最后两个字节设置为 0xAA55 时，机器读取到这里就会知道这个扇区是引导扇区了（是如何读的，这里就不解释了）。最后的 boot_flag就是启动标志的字面意思了，可想而知，后面跟的就是 0xAA55。可以猜测一下，这几行代码应该是后续工作做的准备。 搞定源码后，就可以开始编译内核运行检查一下运行结果了。以 Linux 为例，进入linux-0.11/boot目录下要编译和链接 bootsect.s 就要执行下面的命令：12as86 -0 -a -o bootsect.o bootsect.sld86 -0 -s -o bootsect bootsect.o 别急着去运行内核，先用ls -l命令检查下编译好的文件的大小。可以发现，bootsect 的文件大小是 544 字节，但是引导程序必须要正好占用一个磁盘扇区，即 512 字节。造成多了 32 个字节的原因是 ld86 产生的是 Minix 可执行文件格式，这样的可执行文件除了文本段、数据段等部分以外，还包括一个 Minix 可执行文件头部，而这个文件的头部正好多了 32 个字节。 在 linux 下需要将文件大小改为 512 字节，也就是删掉头部，所以需要借助命令：12dd bs=1 if=bootsect of=Image skip=32cp ./Image ../Image 之后在 oslab 目录下，运行 run 脚本：1$ ./run 就可以得到这样的结果： 改写 setup.s先分析一下要求： 利用 setup.s 向屏幕输出一行“Now we are in SETUP” 利用 setup.s 获取基本硬件参数，这个内核本身就已经读了内存数 setup.s 不再加载 linux 内核，保持上述信息显示在屏幕上即可，这里可能会用到中断 先看第一条要求，这个跟前一个任务完成得事情是类似的，需要找到光标位置，然后打印即可。 尝试了一下，将 bootsect.s 内与光标和打印文字相关的代码抄到了 setup.s 这个文件对应读光标的位置，结果并不顶用。突然想到，是不是打印完一行字符后再将光标位置移动到行首呢？于是又在抄过来的代码下面补上了读光标位置的代码，结果还是不行，果然，不懂汇编，单纯的靠 Ctrl + C/V，还是不行，索性看下老师给的提示。 看了老师的提示，才发现老师讲的“改写”跟我理解的“改写”含义不是一样的。老师是直接从新写一个能完成任务的 bootsect.s 和 setup.s 文件，而我是直接改现成文件，水平过低，过低，2333。不过回过头来想一下，如果只是单纯完成实验，那么确实不需要读取那么多系统信息，也不需要系统完全启动，只要显示了需要的东西即可。既要显示文本，又要内核完好的启动，反而需要的知识量更多，这对初学者而言反而是不利的。好吧，理直气壮的安慰了自己，下面在按照老师给的思路来做一下。 根据老师给出的思路，可以很容易的完成这个实验的第一个任务，具体请看上文 Review。 下面我们首先让 setup.s 完成第一个子任务：向屏幕输出“Now we are in SETUP”。这个任务与 bootsect.s 干的事情很类似，事实上，我们还真的就只需要将前面下好的 bootsect.s 抄过来再修改一下就好了，改好后：123456789101112131415161718192021entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#25 mov bx,#0x0007 mov bp,#msg2 mov ax,cs mov es,ax mov ax,#0x1301 int 0x10inf_loop: jmp inf_loopmsg2: .byte 13,10 .ascii &quot;Now we are in SETUP&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 因为 es 的值在 bootsect.s 已经改过了，所以这里要改回来，直接借助 cs 这个段寄存器。至于为什么能借助 cs 段寄存器达到我们的目的，是因为 cs 是保存微处理器执行代码的内存段，cs（代码段寄存器）持有段的起始位置，也就是我们需要的 0x07c0。这里，也不得不说，怪不得 cpu 里面要搞这么多寄存器的，其实都是用的着的，就是着实难记😓。还有一个需要注意的地方，就是 bootsect.s 已经用过 msg1 这个标识符了，这里需要用 msg2 了。 在编译 setup.s 之前，还需要做一件事情，那就是让 bootsect.s 读入 setup.s。那么如何读入 setup.s 呢？其实就是使用 0x13 中断，可以发现到目前位置我们都是通过 bios 中断在达到我们想要的结果。现在看来，bios 中断就像是可供使用的一个工具一样（事实上，它本身就是如此）。 那么跟着老师的思路，我们可以得到修改后的 bootsect.s 的源码：12345678910111213141516171819202122232425262728293031323334SETUPLEN=2SETUPSEG=0x07e0entry _start_start: mov ah,#0x03 xor bh,bh int 0x10 mov cx,#29 mov bx,#0x0007 mov bp,#msg1 mov ax,#0x07c0 mov es,ax mov ax,#0x1301 int 0x10load_setup: mov dx,#0x0000 mov cx,#0x0002 mov bx,#0x0200 mov ax,#0x0200+SETUPLEN int 0x13 jnc ok_load_setup mov dx,#0x0000 mov ax,#0x0000 int 0x13 jmp load_setupok_load_setup: jmpi 0,SETUPSEGmsg1: .byte 13,10 .ascii &quot;color_os is booting ...&quot; .byte 13,10,13,10.org 510boot_flag: .word 0xAA55 再来简单解释一下这段代码，0x13 中断对 ah、al、bh、bl、ch 和 cl 的值有要求，所以在调用它之前，要先得到我们想要的值。在 linux-0.11 的 bootsect.s 文件中，SETUPLEN 的值为 4，代表了 4 个扇区，这里我们只读 2 个，所以 SETUPLEN 的值在开头设置为 2。jmp load_setup是在末尾设置的循环，如果载入失败就会从头开始。 载入成功后，会跳转执行 setup.s。此时，需要先搞清楚 setup.s 在哪里，通过前面调用 0x13 中断可知我们将 setup.s 放在了 0x07c0 的后 2 个扇区。而 bootsect.s 本身占 1 个扇区，所以 SETUPSEG 需要设置为 0x07e0，就是 0x07c0 加了 512 字节（1 个扇区）后的地址，这样就完成了从 bootsect.s 到 setup.s 的跳转。 源码完成后就可以编译运行检查结果了。但现在有 2 个文件需要编译、链接。如果都手动编译，就太慢了，所以借助 Makefile 是最佳方式。 进入linux-0.11目录后，使用下面命令：1make BootImage 此时会看到下面的错误：12Unable to open &apos;system&apos;make: *** [BootImage] Error 1 有 Error！这是因为 make 根据 Makefile 的指引执行了tools/build.c，build.c 是为生成整个内核的镜像文件而设计的，而我们却只需要编译 bootsect.s 和 setup.s 。它在向我们要 “系统” 的核心代码。为完成实验，需要给它打个小补丁。 build.c 的工作原理从命令行参数得到 bootsect、setup 和 system 内核的文件名，将三者做简单的整理后一起写入 Image。其中 system 是第三个参数（argv[3]？）。当make all或者makeall的时候，这个参数传过来的是正确的文件名，build.c 会打开它，将内容写入 Image。而make BootImage时，传过来的是字符串 none。所以，改造 build.c 的思路就是当 argv[3] 是 none 的时候，只写 bootsect 和 setup，忽略所有与 system 有关的工作，或者在该写 system 的位置都写上 “0”。 要达到上述效果，我们只需要将 build.c 中第 178 - 190 行注释掉即可。 然后再进入到~/oslab/linux-0.11目录下，执行下面的命令：12make BootImage../run 就可以得到下面的结果： 可以发现这个结果跟之前 bootsect.s 产生的结果是类似的，原因就是因为这里的 setup.s 完全就是复制的 bootsect.s。 现在，再来解决最后一个任务：利用 setup.s 获取硬件参数，保存并输出到屏幕上，且不再加载内核。]]></content>
      <categories>
        <category>CS</category>
        <category>Operating System</category>
      </categories>
      <tags>
        <tag>HIT_OS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 零散知识]]></title>
    <url>%2F2021%2F10%2F19%2FLinux-%E9%9B%B6%E6%95%A3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[记录一些容易忘记且与 Linux 相关的一些实用知识，方便自己查询。 zsh 的一些快捷键 按键 作用 Ctrl + d 键盘输入结束或退出终端 Ctrl + s 暂停当前程序，暂停后按下任意键恢复运行 Ctrl + z 将当前程序放到后台运行，恢复到前台为命令fg Ctrl + a 将光标移至输入行头，相当于Home键 Ctrl + e 将光标移至输入行末，相当于End键 Ctrl + k 删除从光标所在位置到行末 Alt + Backspace 向前删除一个单词 Shift + PgUp 将终端显示向上滚动 Shift + PgDn 将终端显示向下滚动 Shell 常用的通配符 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [^list] 匹配除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1 - c2 中的任意单一字符，如：[0-9][a-z] {string1, string2, …} 匹配 string1 或 string2 （或更多）其一字符串 {c1..c2} 匹配 c1 - c2 中全部字符，如：{1..10} 系统日志文件 日志名称 记录信息 alternatives.log 系统的一些更新替代信息 apport.log 应用程序崩溃信息 apt/history.log 使用 apt-get 安装卸载软件的信息记录 apt/term.log 使用 apt-get 时的具体操作，如 package 的下载、打开等 auth.log 登录认证的信息记录 boot.log 系统启动时的程序服务的日志信息 btmp 错误的信息记录 Consolekit/history 控制台的信息记录 dis-upgrade dis-upgrade 这种更新方式的信息记录 dmesg 启动时，显示屏幕上内核缓冲信息，与硬件有关的信息 dpkg.log dpkg 命令管理包的日志 faillog 用户登录失败详细信息记录 fontconfig.log 与字体配置有关的信息记录 kern.log 内核产生的信息记录，在自己修改内核时有很大帮助 lastlog 用户的最近信息记录 wtmp 登录信息的记录，wtmp 可以找出谁正在进入系统，谁使用命令显示这个文件或信息等 syslog 系统信息记录]]></content>
  </entry>
  <entry>
    <title><![CDATA[料理随记]]></title>
    <url>%2F2021%2F09%2F07%2F%E6%96%99%E7%90%86%E9%9A%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[想不到自己接近一年没有更博后，再次更博的第一篇文章会是这个主题。不过反正也没有人看，权当是自己记录用的也可。 目前掌握的料理没有那么多，对烹饪的研究也不太深，索性就不分的太清楚了，直接记录下需要的大概信息即可。 酸辣土豆丝这道菜估计是很多人学会的第一道菜了，不过我好像已经忘记了第一个会做的菜了。 酸辣土豆丝要想炒好，土豆丝一定要切成“丝”。当然了，也不是说一定要跟米粉一样细，粗细适中，像火柴梗那个大小即可，略大也行，所以要熟练的使用菜刀，切记小心不要切到手指了。切好后的土豆丝，不要直接暴露在空气中，否则土豆丝的颜色会变灰，所以要放置在有水的碗中泡着。 一般而言，有些地方这道菜是不放青椒的。而为了有辣味，一开始起锅少烧好油后，蒜和干辣椒爆香后，就直接下土豆丝了。另外，为了维持土豆丝的白色（或者米黄色），多用白醋调味，而不是陈醋。 （依稀记得，母亲炒土豆丝时，辣味是加了豆瓣酱来的，并没有放干辣椒，这可能是我家的吃法。） 清炒西兰花这道菜在真正开始炒之前准备工作比较多。先是西兰花的处理，用刀去除老根，并将大朵西兰花改成小朵，洗净。然后，往锅内加水，水面稍为可以宽一点，待锅中水烧开后，将西兰花倒入锅中。注意焯水时间不要过久，否则一来会使西兰花的口感变老、变软，二来会使西兰花中的营养物质流失。 接着，起锅烧油，下蒜爆香，再倒入西兰花翻炒，加入盐、鸡精、白醋等调味料。由于之前进行了焯水这个步骤，所以这时，不要炒太久，闻到香味，差不多就可以出锅了。 当然了，说是清炒，并不是完全不加其他配菜了。为了菜色，可以加入适量的木耳和红椒丝来点缀（二者可以与西兰花一同焯水），为了增鲜，也可以在出锅前加入少许蚝油，翻炒均匀后再出锅。 清炒上海青这道菜的做法跟清炒西兰花类似（清炒青菜基本都是这样），可以提前焯水也可以不提前焯水。上海青的菜根尽量去除的彻底一点，这样吃起来会感觉嫩一些。为了避免油烧热后，直接下蒜爆香过度导致的蒜变黑、变糊，可以先放入上海青，稍微翻炒一会后，再下蒜，等到有蒜香了后，再出锅。 红烧鸡翅先将鸡翅改花刀，然后冷水下锅焯水，可以加入少许姜片与盐，待鸡翅差不多熟了后，捞出备用。然后倒出锅内的水，将锅内的肉沫清洗干净后，倒入适量的油。待油烧热后，下入蒜、姜爆香，此时可以小火慢烧，煸出香味后，开始加入酱油、醋、盐等其他调料。这里，我们使用豆瓣酱来使菜色变红。 待国内汤汁开始收汁后，加入之前备好的鸡翅，小火慢炖。出锅前，可以再加入少许青椒点缀菜色。 白灼基围虾这道菜分两个部分，一个是对虾的处理，另一个是如何调理蘸汁。 虾的处理同样包括两个部分，第一个是活虾的清洗，去掉虾头、虾脑、虾线等。第二个就是将虾煮熟，先烧开水，然后再将虾下锅。之所以要烧开水再下锅，是为了减少煮虾的时间，以免虾肉口感变老；同时，开水中可以加入适量的盐、生姜、料酒用来去除虾的腥味。大概煮 5 - 10 分钟左右，虾身变红后就可以捞出了。 蘸汁的处理不作细说，虽说这道菜是道粤菜，但我们是家常做法，所以按照自己的口味来调即可，建议少许酱油、陈醋、蒜蓉、糖、盐即可，糖、盐也可单独只加一种。若是喜欢吃其他的调味料（芥末？），也可以自己加。 土豆炖鸡块这道菜中的“鸡块”一定要选肉多的部位，推荐鸡大腿胯子，改成小刀，加盐腌制一定时间，也可以加入定量的生粉，使肉质更加鲜嫩，避免鸡肉口感较“面”。 倒入适量的油，先将鸡块炸熟，然后再加入老抽上色，继而加入蒜、姜、酱油、豆瓣酱、花椒等其他调料，等到菜色、菜香都出来后，加入适量的清水，盖上锅盖。稍微煮一会后，倒入土豆，先大火煮。观察土豆成色，差不多熟了后，改小火煮，此时汤汁开始收汁，可以再加入切好的青辣椒，用以调配菜色。将青辣椒翻炒出味后，即可出锅。 青椒肉丝先将猪肉洗净，然后切成丝。猪肉要想切的丝够细，大致注意 2 个点： 横切牛羊竖切猪，要顺着猪肉的纹理切，即刀和肉的纹理呈水平线 要想切丝，先要切片，片打的爆，丝就够丝（这跟切土豆丝是一样的） 切好的猪肉加入食盐、生粉（也可加入其他的调料，只要好吃皆可）腌制 10 - 20 分钟左右，期间可以准备好蒜、姜、干辣椒、青椒丝等。然后烧油，油温大概到八成，肉丝即可下锅，七八成熟后，加入蒜、姜、干辣椒。炒出香味后，再加入豆瓣酱、酱油、盐等调料，让菜色更亮，味道更鲜。此时，可以加入少许清水，以免火大糊锅。最后加入青椒丝，快速炒出味后，即可出锅。 糖拌西红柿挑几个成熟的西红柿，洗净。如果不喜欢吃皮，可以先在西红柿表面改一个大的十字花刀，然后用开水泡个 3 - 5 分钟左右，然后就可以轻易的撕掉表皮了。然后在将处理好的西红柿改成一页一页的形状，摆放在盘中后，撒上白糖即可。如果不是那么喜欢吃酸的，可以先将改好的刀的西红柿用少量盐腌制几分钟，然后再摆盘撒上白糖。 小葱拌豆腐挑一块完好的嫩豆腐块，切成一个个小正方体形状，待锅里水烧开后，再将豆腐下入过锅中焯水，锅中可以加入适量的盐，可能会使豆腐的口感更加紧致。熟后，盛入盘子中。此时，可以向盘子中加入调味料，锅里开始烧油。这道菜有人谁是东北菜，有人说是鲁菜，个人觉得像是鲁菜。而在鲁菜中，这道菜貌似味不是很重，所以一般不加酱油，大概只放盐、鸡精、白醋、香油。调味料加油后，撒上葱花，将锅里烧好的油淋到葱花上，在滴上几滴香油，很香。 酸辣大白菜选取新鲜白菜，菜叶太大的话可以用刀改小一点，洗净，放置一旁备用。准备一定量的蒜末，这道菜的辣味可以用干辣椒来调，也可以使用小米椒。先下辣椒跟蒜末炝锅，然后下白菜翻炒，期间可以加入一点清水。待白菜差不多熟了后，快速加入鸡精、盐、醋等调味料，翻炒均匀后，即可出锅。 肉沫茄子肉沫茄子的肉沫可以用纯瘦肉，也可以用五花肉的肉沫，一般肉店会直接卖肉沫，也可以买肉回来后自己剁，多出来的肉沫也可以用来包饺子。茄子可以选用紫皮茄子，一般不去皮，也可以选用青皮茄子，一般要去皮。先将茄子下锅炒软炒，盛出备用。然后将肉沫炒散，期间可以放入蒜末、生抽等调料，待肉沫炒好后再加入茄子，再加入盐、醋等调味料，翻炒均匀即可出锅。 手撕包菜这道菜跟炒酸辣大白菜累死，如果不想吃辣，可以不放辣椒，加入蒜末即可。在快要出锅的时候，可以加入适量白糖，使包菜吃起来更加鲜。 辣子鸡丁鸡丁的选材有两种： 鸡脯肉 鸡大腿肉 建议选择鸡大腿肉来做。如果选用鸡大腿肉来做，那么就需要对鸡大腿去骨，然后再将肉切丁，注意肉丁要切小一点（不要像下图中这么大）。切好后，用生粉、鸡蛋清、盐腌制一小会。在此期间，可以准备姜、蒜、花椒、干辣椒、青椒等。起锅烧好油后，下入鸡丁，注意不要让鸡丁粘连再一起。然后加入蒜、姜、花椒、干辣椒，炒出味，接着，加一小勺豆瓣酱炒出红油，加一点清水用作汤汁，再加入适量生抽。最后下入切成块状的青椒，将青椒炒出味即可出锅。 紫菜蛋花汤先将紫菜洗净，然后放置一旁备用。切好蒜末，起锅烧油，先下蒜末炝锅，然后加入清水，此时可以加入一定量的调味料。再将鸡蛋打入碗中，搅拌均匀。等锅里的水差不多烧开后，加入紫菜，搅拌散开，然后再倒入蛋液，注意为了避免蛋凝结成块，要将蛋液迂回倒入锅中，并用锅铲不断搅拌。大概锅过 1 - 2 分钟，蛋熟了，加入适量调味料后即可出锅。 这道菜可以放适量的虾皮，会使得汤味更加鲜美，当然不喜欢吃虾皮的也可以不放。 回锅肉挑一块上好的五花肉，最好肥瘦相间。买肉的时候记得让师傅去掉猪皮上的毛。一般而言，五花肉是不用去皮的，但猪毛还是要去除干净。将五花肉洗净后，放入锅中焯水，冷水下锅，可以加入姜片、葱、料酒、盐等来去腥，并使肉的口感紧实，期间要捞出锅中水上的浮沫。用一根筷子，能插到五花肉中时，就可以捞出锅了。快速用冷水冲一边，趁外冷内热，将五花肉切成薄片，不喜欢吃太多肥肉话，一定要尽量的切薄点。切好后，放在盘子中备用。准备好蒜苗、青椒、姜、蒜末，起锅烧油，下入蒜末、姜煸香，再下入肉片煸炒至肉片颜色变透明，边缘略微卷起。然后再加入豆瓣酱，炒出红油，再加入少许酱油调色，与肉片一起翻炒均匀。最后再下入蒜苗、青椒，快速翻炒，加入盐、醋等调味料即可出锅。 喜欢吃辣、麻的话，可以干辣椒、花椒与蒜末、姜一同下锅煸香，然后再炒肉。 萝卜烧鸡块这又是一道家常菜，做法其实与土豆钝鸡块差不多，但要注意萝卜要比土豆易熟，所以焖的时间不能太长，不然萝卜烂了就不好吃了。另外，之所以要用萝卜当配菜，其实是因为冬天到了，多吃萝卜，可以补充身体的水分，补气通肺。PS：下面的图片用的汤碗装的，看像着实不好，还是用盘子好。 黄瓜炒蛋这也是一道很常见的家常菜，备料过程就不细说了。先将搅拌均匀的蛋液倒入已烧到七、八成热的油锅中，使蛋成块变熟（这个表达有点怪，知道是什么意思就行），然后在倒入黄瓜，大火翻炒，注意锅中需要有点水分，可以适当加点水，边炒边加入调料，不一会便可出锅了。一般而言，这道菜里面还可以加入黑木耳来点缀菜色，好像也可以略微减少一点鸡蛋的腥味？同时，还可以加入一点蚝油，使菜的味道更加鲜美，或者单纯加点糖也可以，如果不喜欢加太多调味品，也可以不加。]]></content>
      <categories>
        <category>Life</category>
        <category>Cooking</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_03]]></title>
    <url>%2F2020%2F09%2F28%2FNand2Tetris-Part1-03%2F</url>
    <content type="text"><![CDATA[本周的主题是 Memory，先把做好的 ALU 放一边，我们来研究一下和内存（RAM）有关的问题。 Unit 3.1 Sequential Logic本小节主要在引出新的概念：顺序逻辑（Sequential Logic）、时间等，另外也指出了顺序逻辑与前两周所学的组合罗杰（Combinational Logic）的不同。换句话来讲，这周考虑的问题会更加贴近现实生活一点。 Unit 3.2 Filp Flops本小节介绍了本周内容所使用的最基本单元：Data Flip Flops（DFF），并说明了它的功能；接着继续讲解了内存的基本单元 1-Bit Registers，着重在说明它的运行过程。 Unit 3.3 Memory UnitsUnit 3.4 CountersUnit 3.5 Project 3 Overview本周作业需要实现 7 个与内存相关的芯片和 1 个计数器，针对各个芯片的实现，老师给出了若干提示，而我们将会以 DFF 为 primitive chip 来构建另外 8 个芯片。 Bit这个老师已经讲过了，直接用 1 个 Mux 和 1 个 DFF 就可以实现，但是还额外需要一个 Mux 来帮助输出（不用 Mux，用其他的也可以）。123456789CHIP Bit &#123; IN in, load; OUT out; PARTS: Mux(a=t2, b=in, sel=load, out=t1); DFF(in=t1, out=t2); Mux(a=t2, b=true, sel=false, out=out);&#125; Register按照提示，直接用 16 个 Bit 叠加在一起就可以了。但是要注意一下时间的概念，也即这 16 个 Bit 是都处于工作状态的，尽管有些 Bit 的值可能并没有改变。12345678910111213141516171819202122CHIP Register &#123; IN in[16], load; OUT out[16]; PARTS: Bit(in=in[0], load=load, out=out[0]); Bit(in=in[1], load=load, out=out[1]); Bit(in=in[2], load=load, out=out[2]); Bit(in=in[3], load=load, out=out[3]); Bit(in=in[4], load=load, out=out[4]); Bit(in=in[5], load=load, out=out[5]); Bit(in=in[6], load=load, out=out[6]); Bit(in=in[7], load=load, out=out[7]); Bit(in=in[8], load=load, out=out[8]); Bit(in=in[9], load=load, out=out[9]); Bit(in=in[10], load=load, out=out[10]); Bit(in=in[11], load=load, out=out[11]); Bit(in=in[12], load=load, out=out[12]); Bit(in=in[13], load=load, out=out[13]); Bit(in=in[14], load=load, out=out[14]); Bit(in=in[15], load=load, out=out[15]);&#125; RAM812]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扒谱记录 - Homesteaders]]></title>
    <url>%2F2020%2F09%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-Homesteaders%2F</url>
    <content type="text"><![CDATA[《Homesteaders》是由 Joanie Madden 用哨笛演奏的一首凯尔特风格的曲子，是一首十分纯净的轻音乐。 Homesteaders - Joanie MaddenYour browser does not support the audio tag. 晚上弹琴的时候，脑海里突然响起了这首曲子的旋律，伴随着脑海内的旋律，眼前的景色好像又回到了高中时代。想到那时的自己，鬼使神差的找了一本言情小说读（可能是耐不住枯燥的学习生活吧，为什么不读科幻小说呢？？？）。一边读，一边听着这首曲子。最后，小说读完了，这首曲子也听了一遍又一遍。小说的情节现已难以回想起来了，但那时的自己流露出的些许感情却随着这首曲子的旋律一遍又一遍的刻进了自己的脑海。 其实，高中时代结束后，脑海就已经多次响起了这段熟悉旋律，可自己让它停留在脑中的时间不会超过 10 秒，索性这次让它停留的久一点。然后，用吉他试着弹了一下，还挺像的。随后找到原曲，听了几遍，不一会主旋律就扒出来了，记录下来，免得自己忘了。 这样的话，再过几年后的自己偶尔看到这些东西的时候，也许心中还能留有一丝感动吧！ 自扒谱：[5]1231[5] [6]123155(1)76 54345112316532123[6]123211[6] [5][5][6]12123211[6] [5][5][6]11(1)767(1)6 5452431236335321232(1)767(1)6 54524312363321[6] [7][]：降八度 ()：升八度]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetris_Part1_02]]></title>
    <url>%2F2020%2F09%2F21%2FNand2Tetris-Part1-02%2F</url>
    <content type="text"><![CDATA[本周的主题是 Boolean Arithmetic and the ALU Roadmap，旨在介绍如何构建加法器（adder）和算术逻辑单元（Arithmetic Logic Unit，ALU），学习路线依然还是从简单到复杂。 Unit 2.1 Binary Numbers本小节主要在说明二进制与十进制的一些联系，粗略介绍了一下进制转换的过程，但没有说明具体的方法。学过一门编程语言课的同学，肯定对这些都已经很熟悉；没学过的，老师讲的也很清晰。 Unit 2.2 Binary Addition本小节主要在介绍二进制加法规则，本质上与十进制是一样的。但由于二进制算术存在位数（bits）的限制，所以会产生溢出（overflow）的问题，老师暂时没有讲具体的解决办法，只说明了，在计算机内是会直接忽略掉的，但是使用者必须知道溢出了。接着，又由易到难的介绍了三种加法器，并大致说明了一下构造的方法，这也是本周的作业之一。 Unit 2.3 Negative Numbers前面介绍的规则都是与正数相关的，而本小节主要在介绍在计算机中如何表示负数，老师主要介绍了两种表示方法： 用最前面的 1 位（1 bit）代表符号，为 0，则为正数，为 1，则为负数，二者绝对值相等。这样表示会有一个问题，那就是会产生正 0 和 负 0，这样在做加、减法时会产生问题，所以舍弃了这种方法 用 $2^N + (-x) = 2^N - x$ 来表示负数，其中 -x 就是要表示的负数，这样表示后就没有负 0 了，且在做加、减法时也是完全正确的。 说点题外话，上面的几小节内容对应了组成原理中有关数的表示部分，提到的一些方法，其实就是原码、补码（radix complement）和反码的概念，可能是老师为了照顾非计算机专业的学生，一点没提这些东西，也有可能是国外讲课的风格导致了老师不会硬讲这些概念性的东西吧。 Unit 2.4 Arithmetic Logic Unit本小节主要在介绍后面要构建的计算机 Hack 的 ALU 是如何构建的。首先是对此 ALU 的基本介绍，包括其输入、输出、控制位（control bits），注意其控制位有两类，有 6 个算是功能控制位，剩下两个是输出控制位，且并没有说明输出控制位存在的意义。接着，说明了如何使用硬件模拟器来使用模拟 ALU 的一些功能，在这一块，如果对 ALU 的运算过程不清楚可以使用内置的（built-in）ALU 来熟悉一下过程。最后，举例验证了 ALU 能逐一实现所要求功能的可靠性，但老师没有介绍具体的原理，想了解就得自己看资料了。还剩下的最后一点是在说明 Hack ALU 的优点，通俗来讲其实就是一点：易于学习。 Unit 2.5 Project 2 Overview本小节主要在介绍这周的作业，并给出了一些提示信息。尽管在第一周已经实现了很多 chips，但是老师建议不要使用自己实现的 chips，直接使用软件自带（built-in）的 chips，原因是为了避免软件可能会产生的卡顿等情况。下面我们就来开始完成这周的作业。 HalfAdder按照老师给的提示，直接用 Xor 和 And 来实现就完事了。123456789CHIP HalfAdder &#123; IN a, b; // 1-bit inputs OUT sum, // Right bit of a + b carry; // Left bit of a + b PARTS: Xor(a=a, b=b, out=sum); And(a=a, b=b, out=carry);&#125; FullAdder12345678910CHIP FullAdder &#123; IN a, b, c; // 1-bit inputs OUT sum, // Right bit of a + b + c carry; // Left bit of a + b + c PARTS: HalfAdder(a=a, b=b, sum=s1, carry=v1); HalfAdder(a=s1, b=c, sum=sum, carry=v2); Or(a=v1, b=v2, out=carry);&#125; Add1612345678910111213141516171819202122CHIP Add16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: HalfAdder(a=a[0], b=b[0], sum=out[0], carry=c1); FullAdder(a=a[1], b=b[1], c=c1, sum=out[1], carry=c2); FullAdder(a=a[2], b=b[2], c=c2, sum=out[2], carry=c3); FullAdder(a=a[3], b=b[3], c=c3, sum=out[3], carry=c4); FullAdder(a=a[4], b=b[4], c=c4, sum=out[4], carry=c5); FullAdder(a=a[5], b=b[5], c=c5, sum=out[5], carry=c6); FullAdder(a=a[6], b=b[6], c=c6, sum=out[6], carry=c7); FullAdder(a=a[7], b=b[7], c=c7, sum=out[7], carry=c8); FullAdder(a=a[8], b=b[8], c=c8, sum=out[8], carry=c9); FullAdder(a=a[9], b=b[9], c=c9, sum=out[9], carry=c10); FullAdder(a=a[10], b=b[10], c=c10, sum=out[10], carry=c11); FullAdder(a=a[11], b=b[11], c=c11, sum=out[11], carry=c12); FullAdder(a=a[12], b=b[12], c=c12, sum=out[12], carry=c13); FullAdder(a=a[13], b=b[13], c=c13, sum=out[13], carry=c14); FullAdder(a=a[14], b=b[14], c=c14, sum=out[14], carry=c15); FullAdder(a=a[15], b=b[15], c=c15, sum=out[15], carry=c16);&#125; Inc161234567CHIP Inc16 &#123; IN in[16]; OUT out[16]; PARTS: Add16(a=in, b[0]=true, out=out);&#125; ALU_nostat按照老师所给资料上的提示，我们先不去考虑 ng 和 zr 这两个输出控制位，直接考虑输出即可。那我们先得构造出能根据 zx 和 nx 这两个控制位来选择性输出的逻辑电路，当然，这个逻辑电路总线宽度是 16 位的。结果硬想了好一会儿，没想出来。后来意识到，这个问题本质上其实就是在思考如何在没有条件编程语句的情况下构造出条件逻辑。胡乱的写了些代码，发现语法都不通，但脑子里始终想的都是：在现有的可使用的逻辑电路里，好像没有可以用于条件选择的啊？过了两天，又回来思考这个问题，突然发现，Mux 这种东西不是根据 sel bit 来选择性输出的吗？突然想到自己之前的想法：这东西应该是通信专业同学研究的东西吧...好吧，自己一开始就把正确的思考方向给抛到九霄云外去了，真是搬起石头砸自己的脚，想的我真是辛苦...扯远了，有了上面的思路后，这个问题其实就很容易了，直接看下面代码：1234567891011121314151617181920212223242526272829303132CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=out);&#125; ALU完成上面的任务后，接下来我们需要考虑的问题就是如何得到 zr 和 ng 的正确结果。按照前面的课程内容，我们已经知道负数的最高位 bit 是 1，所以 ng 就很容易得到了。但是 zr 就不是那么易得了，原因在于 0 的二进制最高位与普通正数的二进制最高位一样，都是 0 ，所以无法轻易的区分。这里好像又回到了我们在之前碰到的问题：如何在没有判断编程语句的情况下构造出判断逻辑呢？注意到 0 先去取反再自增加 1 后，得到的二进制序列最高位与原序列最高位一致（溢出的 bit 舍弃），而其他的数由此过程得到的两个序列的最高位必然一个是 1，另一个是 0。如此一来，问题就解决了。当然了，要想得到 zr，最快的办法其实就是让最后的结果序列按位取或（Or）运算，采用之前构造的 Or8Way 这个逻辑电路，试了下，好像总是语法有问题...12345678910111213141516171819202122232425262728293031323334353637383940CHIP ALU &#123; IN x[16], y[16], // 16-bit inputs zx, // zero the x input? nx, // negate the x input? zy, // zero the y input? ny, // negate the y input? f, // compute out = x + y (if 1) or x &amp; y (if 0) no; // negate the out output? OUT out[16], // 16-bit output zr, // 1 if (out == 0), 0 otherwise ng; // 1 if (out &lt; 0), 0 otherwise PARTS: //zx nx Mux16(a=x, b=false, sel=zx, out=x1); Not16(in=x1, out=x2); Mux16(a=x1, b=x2, sel=nx, out=x3); //zy ny Mux16(a=y, b=false, sel=zy, out=y1); Not16(in=y1, out=y2); Mux16(a=y1, b=y2, sel=ny, out=y3); //f Add16(a=x3, b=y3, out=z1); And16(a=x3, b=y3, out=z2); Mux16(a=z2, b=z1, sel=f, out=z3); //no zr ng Not16(in=z3, out=z4); Mux16(a=z3, b=z4, sel=no, out=z5); Not16(in=z5, out=z6); Inc16(in=z6, out=z7); Or16(a=z5, b=z7, out[15]=z8); Not(in=z8, out=zr); And16(a=z5, b=true, out[15]=ng); Mux16(a=z3, b=z4, sel=no, out=out);&#125; Unit 2.6 Perspectives这周的问题主要有 4 个： 目前所构建的大约 20 种逻辑电路，是否都是标准的？ 问这个问题的人口中的标准应该是相对于工业界而言的，老师的回答很直接，除了用于学习的 ALU，其他都是标准的。其实仔细一想，太底层的东西，反而没有多种构建方法，大家用的其实都是那一套。 目前实现的 ALU 为何不能提供乘法或除法？ 因为课程中实现的 ALU 过于简单，只是为了学习使用。但你依然可以自己去实现乘法或除法，这取决于开发者是否需要给它添加这个功能。 课程中的 ALU 是否高效？ 课程中设计的大多数逻辑电路都是高效的，但有一种仍然可以改进的更高效，那就是——Adder。目前它“低效”的原因在于，其内部实现是由多个全加器“串”起来的，所以二进制比特流的流动存在一定的延迟。 为何建议学生使用 built-in chips？ 第一，使用 built-in chips 会更加高效；第二是因为可以避免一些未知的错误，而这些错误可能是由模拟器的 bug 导致的，也就是说这并不是你的代码有问题；第三，模拟器并不高效，使用自己构建的 chips 可能会进一步降低效率。 这周内容的难点在于如何构建 ALU，可见在没有高级语言的帮助下，如果想要在底层实现一些复杂逻辑，还是挺费脑子的。另外，还有一块知识老师没有强调，就是根据逻辑运算来构造实际运算，也就是 ALU 这样设计的背后原理，这部分内容可能又跟电学有点关系吧...]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nand2Tetri_Part1_01]]></title>
    <url>%2F2020%2F09%2F20%2FNand2Tetris-Part1-01%2F</url>
    <content type="text"><![CDATA[Nand2Tetris 是由希伯来大学的两位教授 Noam Nisan 和 Shimon Schocken 在 Coursera 上开设的在线课程（网络课程）。课程全称叫做：依据基本原理构建现代计算机：从与非门到俄罗斯方块（基于项目的课程），其主要内容与计算机组成原理、操作系统等科目的关联性较大，但课程的受众群体也不止局限于专业人士，且课程的实践性很强，对深入理解理论知识很有帮助。 Introduction第一周包含两个章节（一般情况下，一周一个）：Introduction 和 Boolean Functions and Gate Logic。顾名思义，Introduction 是对本课程的说明，Boolean Functions and Gate Logic 才是第一周的真正的学习内容。通过 Introduction 可以知道大体的学习路线是从基本的逻辑门单元开始，自下而上的学习如何构建计算机，继而构建出能在这台计算机上运行的程序，也即：Nand -&gt; Hack -&gt; Tetris。另外，对于购买了课程的同学而言，这章节会有一个编程作业，用来练习如何在 Coursera 上提交作业。但如果你是旁听生（auditor），那么可以忽略掉。 Boolean Functions and Gate Logic这部分内容属于计算机系统结构底层中的底层，课程从一个小小门逻辑电路开始讲起（当然不会讲与物理相关的内容，这也是老师让大家不要过分在意的地方），逐步介绍各种不同的逻辑电路，并自行构造具有一定复杂性的复合逻辑门电路。 Unit 1.1 Boolean Logic本小节主要介绍了三种基本的逻辑门（Logic gate）：与（And）、或（Or）和非（Not），并举例说明了与之对应的基本运算方法和规律。 三种逻辑门的真值表（Truth table）如下：And：$$\begin{array}{cc|c}x &amp; y &amp; And \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Or：$$\begin{array}{cc|c}x &amp; y &amp; Or \\\hline0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 \\\end{array}$$ Not：$$\begin{array}{c|c}x &amp; Not \\\hline0 &amp; 0 \\1 &amp; 0 \\\end{array}$$ 运算规律： 交换律（Commutative Law） x and y = y and x x or y = y or x 结合律（Associative Law） x and (y and z) = (x and y) and z x or (y or z) = (x or y) or z 分配律（Distributive Law） x and (y or z) = (x and y) or (x and z) x or (y and z) = (x or y) and (x or z) 德摩根律（De Morgan Law） not (x and y) = (not x) or (not y) not (x or y) = (not x) and (not y) 以上基本内容说不定就会用到，记录下。 Unit 1.2 Boolean Functions Synthesis本小节主要讲了三点： 如何根据真值表来反向构造布尔函数 介绍了一个结论：任意布尔函数都能被与或非三种运算表示（Any Boolean function can be represented using an expression containing AND, OR and NOT operations.） 接下来会用与非门（Nand）来构建其他逻辑门 Unit 1.3 Logic gates本小节着重在说明一个问题，即：这门课程不会从物理层面深究这种逻辑门是怎样实现的，但是会探讨如何利用基础逻辑门来构建复合逻辑门。另外，还介绍了在这个课程中会见到的一些描述用语。PS：God bless their souls. 感觉像是在嘲讽呢（笑）。 Unit 1.4 Hardware Description Language本小节主要在说明硬件描述语言（后面会简称 HDL）的语法规则，不多，建议直接自己看老师提供的手册，并试着写下代码，有了一定的感性认识后，再来听，可能会收获多一点。 Unit 1.5 Hardware Simulation本小节主要在讲如何使用课程提供的硬件模拟器和一些注意事项。 Unit 1.6 Multi Bit Buses本小节主要在说明多位（bit）逻辑门在本课程所用的 HDL 中的用法，并顺便大致的说明了一下总线的含义，对后面构造位逻辑单元有一定帮助，特别是有 HDL 代码的地方，对后面的作业很有帮助。 Unit 1.7 Project 1 Overview本小节主要在介绍第一周的作业以及这周作业对于后续课程的意义。不得不说，国内老师从来不会跟你讲作业的意义，最多给你讲讲错题。 扯远了，每周作业包括三个部分：代码源文件（.hdl）、测试脚本（.tst）和比对文件（.cmp）（其实就是程序正确的运行结果），每一个小作业（就是你要实现的每一个小芯片）都包含这三个文件。好消息是测试脚本跟正确答案老师都准备好了，坏消息是代码得自己写（其实也不算坏消息，本就是分内之事，笑），下面我们来完成这周的作业。 PS：有一点要注意，下面这些逻辑门实现的方式不唯一，这也是老师一再强调的东西。 NotNand 是我们在这个课程中可以直接使用的基本逻辑门，可以直接使用，Not 是我们要完成的第一个芯片，所以我们直接使用一个二元的与非门来实现一个一元的非门（The implementation of a unary Not gate from a binary Nand gate is simple.）。 一元非门只有两种情况，二元与非门有四种情况，那么我们直接用与非门的其中两种情况来表示非门即可，代码如下：1234567CHIP Not &#123; IN in; OUT out; PARTS: Nand(a=in, b=true, out=out);&#125; And一开始思考如何实现 And 时，有点无从下手的感觉后来，想了一会，想到了两种方法： 使用 2 个 Nand 使用 1 个 Nand，在使用 1 个 Not 12345678910111213CHIP And &#123; IN a, b; OUT out; PARTS: /* method 1: use 2 Nand Nand(a=a, b=b, out=c); Nand(a=c, b=true, out=out); */ /* method 2: use Nand and Not */ Nand(a=a, b=b, out=c); Not(in=c, out=out);&#125; Or实现 And 之后，此时我们可以使用上面实现好了的逻辑门来帮助实现 Or。 12345678910CHIP Or &#123; IN a, b; OUT out; PARTS: Not(in=a, out=nota); Not(in=b, out=notb); And(a=nota, b=notb, out=e); Not(in=e, out=out);&#125; Xor异或运算有点特殊，同样还是用已经实现过的逻辑门来实现。123456789CHIP Xor &#123; IN a, b; OUT out; PARTS: Or(a=a, b=b, out=c); Nand(a=a, b=b, out=d); And(a=c, b=d, out=out);&#125; MuxMux 全称 Multiplexor，即多路复用器（大概是这个意思吧），这个东西应该是通信专业同学研究的东西，有三个输入：a，b 和 sel。规则就是根据 sel 的值来确定输出 a 还是 b，sel 有点像是校验码之类的东西吧。 粗略分析一下，Mux 有八种情况，我们先观察一下它的真值表。$$\begin{array}{ccc|c}a &amp; b &amp; sel &amp; Mux \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 0 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 1 \\1 &amp; 0 &amp; 1 &amp; 0 \\1 &amp; 1 &amp; 1 &amp; 1 \\\end{array}$$Mux 的结果中有 4 个值为真，仔细回想一下老师在 1.2 讲的有关反向构造布尔函数的知识，首先先列出所有真值的表达式，也就是上表中的第 3、4、6、8 行，可得： 第 3 行：a and (not b) and (not sel) 第 4 行：a and b and (not sel) 第 6 行：not a and b and sel 第 8 行：a and b and sel 继而我们可以得到 Mux 的布尔函数式子：(a and (not b) and (not sel)) or (a and b and (not sel)) or ((not a) and b and sel) or (a and b and sel)。汗，真长，不过先不管，我们直接按照这个函数来写代码，可以得到以下代码：12345678910111213141516171819202122232425CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=b, out=notb); Not(in=sel, out=notsel); Not(in=a, out=nota); And(a=a, b=notb, out=u1); And(a=u1, b=notsel, out=u2); And(a=a, b=b, out=v1); And(a=v1, b=notsel, out=v2); And(a=nota, b=b, out=w1); And(a=w1, b=sel, out=w2); And(a=a, b=b, out=x1); And(a=x1, b=sel, out=x2); Or(a=u2, b=v2, out=y1); Or(a=y1, b=w2, out=y2); Or(a=y2, b=x2, out=out);&#125; 测试后结果是正确的，不过这显然不够老师说的 elegant（笑），我们来把布尔函数式根据运算规则化简一下，可得：(a and (not sel)) or (b and sel)，从而可得：12345678910CHIP Mux &#123; IN a, b, sel; OUT out; PARTS: Not(in=sel, out=notsel); And(a=a, b=notsel, out=u); And(a=b, b=sel, out=v); Or(a=u, b=v, out=out);&#125; 测试后结果依然正确，说明化简是正确的。 为什么要使用上面的方法来构造布尔函数？因为此时我们能用的逻辑门已经不仅仅只有 Nand，还有先前已经构造好了的 And、Not、Or、Xor，这些都可以直接拿来用了，那还费脑子死想干嘛呢。当然了，这也是老师强调过的思想。 另外，通过上面的计算过程和老师的讲解，我们可以得到反向构造布尔函数时的几个要点： 选取结果序列中真值或假值较少的一方，上面的 Mux 中真假值都是 4 个，任取即可 用每一个值写出的式子必须保证其中的每一子项皆为真或假，比如以上面第 3 行为例，a、not b 和 not sel 的值都是 1 单个式子的每一子项要进行 and 运算，而每个式子之间则用 or 运算 PS：有关逻辑式子化简的问题，应该属于离散数学的知识。 DMuxDMux，Demultiplexor，即解复用器，与 Mux 是一对，二者的功能也正好相反，但 DMux 的特殊性在于它有两个输出。我们还是按照上面的思路来构建，先看一下 DMux 的真值表$$\begin{array}{c|cc}sel &amp; a &amp; b \\\hline0 &amp; in &amp; 0 \\1 &amp; 0 &amp; in \\\end{array}$$这是老师提供的资料上的真值表，好像不是很易于分析问题，那我们把详细的真值表整理出来：$$\begin{array}{cc|cc}sel &amp; in &amp; a &amp; b \\\hline0 &amp; 0 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 0 &amp; 0 \\1 &amp; 1 &amp; 0 &amp; 1 \\\end{array}$$这样，我们在分析这个问题时，就可以单独考虑如何利用 sel 和 in 分别得到 a、b 这两列值，代码如下：1234567891011CHIP DMux &#123; IN in, sel; OUT a, b; PARTS: Not(in=in, out=notin); Or(a=sel, b=notin, out=v1); Not(in=v1, out=a); And(a=sel, b=in, out=b);&#125; Not16多位逻辑门是老师在 1.6 讲过的内容，构造的基本思想就是每一位都用一个逻辑门来计算，组合在一起就可以了。12345678910111213141516171819202122CHIP Not16 &#123; IN in[16]; OUT out[16]; PARTS: Not(in=in[0], out=out[0]); Not(in=in[1], out=out[1]); Not(in=in[2], out=out[2]); Not(in=in[3], out=out[3]); Not(in=in[4], out=out[4]); Not(in=in[5], out=out[5]); Not(in=in[6], out=out[6]); Not(in=in[7], out=out[7]); Not(in=in[8], out=out[8]); Not(in=in[9], out=out[9]); Not(in=in[10], out=out[10]); Not(in=in[11], out=out[11]); Not(in=in[12], out=out[12]); Not(in=in[13], out=out[13]); Not(in=in[14], out=out[14]); Not(in=in[15], out=out[15]);&#125; And1612345678910111213141516171819202122CHIP And16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: And(a=a[0], b=b[0], out=out[0]); And(a=a[1], b=b[1], out=out[1]); And(a=a[2], b=b[2], out=out[2]); And(a=a[3], b=b[3], out=out[3]); And(a=a[4], b=b[4], out=out[4]); And(a=a[5], b=b[5], out=out[5]); And(a=a[6], b=b[6], out=out[6]); And(a=a[7], b=b[7], out=out[7]); And(a=a[8], b=b[8], out=out[8]); And(a=a[9], b=b[9], out=out[9]); And(a=a[10], b=b[10], out=out[10]); And(a=a[11], b=b[11], out=out[11]); And(a=a[12], b=b[12], out=out[12]); And(a=a[13], b=b[13], out=out[13]); And(a=a[14], b=b[14], out=out[14]); And(a=a[15], b=b[15], out=out[15]);&#125; Or1612345678910111213141516171819202122CHIP Or16 &#123; IN a[16], b[16]; OUT out[16]; PARTS: Or(a=a[0], b=b[0], out=out[0]); Or(a=a[1], b=b[1], out=out[1]); Or(a=a[2], b=b[2], out=out[2]); Or(a=a[3], b=b[3], out=out[3]); Or(a=a[4], b=b[4], out=out[4]); Or(a=a[5], b=b[5], out=out[5]); Or(a=a[6], b=b[6], out=out[6]); Or(a=a[7], b=b[7], out=out[7]); Or(a=a[8], b=b[8], out=out[8]); Or(a=a[9], b=b[9], out=out[9]); Or(a=a[10], b=b[10], out=out[10]); Or(a=a[11], b=b[11], out=out[11]); Or(a=a[12], b=b[12], out=out[12]); Or(a=a[13], b=b[13], out=out[13]); Or(a=a[14], b=b[14], out=out[14]); Or(a=a[15], b=b[15], out=out[15]);&#125; Mux1612345678910111213141516171819202122CHIP Mux16 &#123; IN a[16], b[16], sel; OUT out[16]; PARTS: Mux(a=a[0], b=b[0], sel=sel, out=out[0]); Mux(a=a[1], b=b[1], sel=sel, out=out[1]); Mux(a=a[2], b=b[2], sel=sel, out=out[2]); Mux(a=a[3], b=b[3], sel=sel, out=out[3]); Mux(a=a[4], b=b[4], sel=sel, out=out[4]); Mux(a=a[5], b=b[5], sel=sel, out=out[5]); Mux(a=a[6], b=b[6], sel=sel, out=out[6]); Mux(a=a[7], b=b[7], sel=sel, out=out[7]); Mux(a=a[8], b=b[8], sel=sel, out=out[8]); Mux(a=a[9], b=b[9], sel=sel, out=out[9]); Mux(a=a[10], b=b[10], sel=sel, out=out[10]); Mux(a=a[11], b=b[11], sel=sel, out=out[11]); Mux(a=a[12], b=b[12], sel=sel, out=out[12]); Mux(a=a[13], b=b[13], sel=sel, out=out[13]); Mux(a=a[14], b=b[14], sel=sel, out=out[14]); Mux(a=a[15], b=b[15], sel=sel, out=out[15]);&#125; Or8Way12345678910111213CHIP Or8Way &#123; IN in[8]; OUT out; PARTS: Or(a=in[0], b=in[1], out=v1); Or(a=v1, b=in[2], out=v2); Or(a=v2, b=in[3], out=v3); Or(a=v3, b=in[4], out=v4); Or(a=v4, b=in[5], out=v5); Or(a=v5, b=in[6], out=v6); Or(a=v6, b=in[7], out=out);&#125; Mux4Way164 路 Mux16 使用三个 Mux16 即可完成，可能会有人问为什么要先让 a 和 c 先通过一次 Mux16。因为 sel bits 是从右往左读的，若 a 和 b 先通过一次 Mux16，当 sel[1]=0 时，就无法得到正确的输出结果了（sel[0]=0，就输出 a，sel[0]=1，就输出 b，但第一次通过 Mux16 后已经过滤掉 a 或 b 了）。123456789CHIP Mux4Way16 &#123; IN a[16], b[16], c[16], d[16], sel[2]; OUT out[16]; PARTS: Mux16(a=a, b=c, sel=sel[1], out=v1); Mux16(a=b, b=d, sel=sel[1], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; Mux8Way16在 Mux4Way16 的基础上构造就行了，注意一下这里的语法。1234567891011CHIP Mux8Way16 &#123; IN a[16], b[16], c[16], d[16], e[16], f[16], g[16], h[16], sel[3]; OUT out[16]; PARTS: Mux4Way16(a=a, b=c, c=e, d=g, sel=sel[1..2], out=v1); Mux4Way16(a=b, b=d, c=f, d=h, sel=sel[1..2], out=v2); Mux16(a=v1, b=v2, sel=sel[0], out=out);&#125; DMux4Way先用 sel[1] 来区分 a、b 和 c、d 两组，在用 sel[0] 在组内分别区分 a、b 和 c、d。123456789CHIP DMux4Way &#123; IN in, sel[2]; OUT a, b, c, d; PARTS: DMux(in=in, sel=sel[1], a=u1, b=u2); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d);&#125; DMux8Way在 DMux4Way 的基础上构建就行，思路是完全一致的。1234567891011CHIP DMux8Way &#123; IN in, sel[3]; OUT a, b, c, d, e, f, g, h; PARTS: DMux4Way(in=in, sel=sel[1..2], a=u1, b=u2, c=u3, d=u4); DMux(in=u1, sel=sel[0], a=a, b=b); DMux(in=u2, sel=sel[0], a=c, b=d); DMux(in=u3, sel=sel[0], a=e, b=f); DMux(in=u4, sel=sel[0], a=g, b=h);&#125; Unit 1.8 Perspectives本小节主要老师们回答学生在论坛区提出的一些典型问题，这次主要回答了 3 个问题： 能否不用 Nand 而是用其他的基本逻辑门来构建一个计算机？ 答案是 yes，这里我们不深究具体原因。 Nand gate 的具体工作原理 老师用电路图讲了一下，当然，这是电气工程师该干的活，就不具体讨论了 工业坏境下使用的 HDL 语言与课程使用的 HDL 语言有何差别 工业环境用的肯定功能更加强大，效率更高，学习的时间较长；而本课程的 HDL 语言只是为了满足教学使用，所以功能性会弱很多，但易于学习，且足够满足本课程的所有需要 本周内容过于底层，估计不少人觉得无聊，不过还好不是太难。当然，可能会有第一次使用这样的 HDL 语言和硬件模拟器而不熟悉的问题，不过老师提供的手册和视频的讲解帮助还是很大的。个人感觉老师给的手册如果能更详细一点，用例再多一点就更好了（主要还是自己太懒，笑）。]]></content>
      <categories>
        <category>CS</category>
        <category>Computer Organization</category>
      </categories>
      <tags>
        <tag>Nand2Tetris</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MathJax 语法快速指南]]></title>
    <url>%2F2020%2F09%2F17%2FMathJax-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[MathJax 是一个 JavaScript 库，可以让你直接用 Latex 语法来书写数学公式，十分方便。想深入了解 MathJax，点击链接：MathJax，本文旨在整理一些平时写文档时常用的一些语法，便于复查。 书写位置平时写文档时，公式的放置位置有两个地方：文字中间和单独成块，这就跟单行代码与代码块一样。 放在文字中间的公式要用一对美元符号包括起来，如：$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$，显示为：$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$ 单独成块的公式要用两对美元符号包括起来，如：$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$，显示为：$$\sum_{i=0}^N\int_{a}^{b}g(t, i)\text{d}t$$ 希腊字母 显示 语法 显示 语法 $\gamma$ \gamma $\delta$ \delta $\epsilon$ \epsilon $\zeta$ \zeta $\eta$ \eta $\theta$ \theta $\iota$ \iota $\kappa$ \kappa $\lambda$ \lambda $\mu$ \mu $\nu$ \nu $\xi$ \xi $\pi$ \pi $\rho$ \rho $\sigma$ \sigma $\tau$ \tau $\upsilon$ \upsilon $\phi$ \phi $\chi$ \chi $\psi$ \psi $\omega$ \omega 如果要大写希腊字母，将语法的首字母大写即可，如：\Sigma，显示为：$\Sigma$；如果要斜体希腊字母，在语法前加上var即可，如：\varsigma，显示为：$\varSigma$ 上下标上标使用^，下标使用_，二者后面再接字符，如果字符数大于一个需要使用一对花括号包括起来，如：$\sum_{i=0}^N$，显示为：$\sum_{i=0}^N$ 矢量$\vec a$显示为：$\vec a$；如果想改变字母上方的符号，可以这样写$$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \overrightarrow{xy} \quad $$，显示为：$ \overleftarrow{xy} \quad and \quad \overleftrightarrow{xy} \quad and \ \ \ \overrightarrow{xy} \quad $ 括号小括号：$()$，显示为：$()$中括号：$[]$，显示为：$[]$尖括号：$&lt;&gt; \langle\rangle$，显示为：$&lt;&gt; \langle\rangle$\left和\right可以使符号大小与临近的公式相适应，如：$(\frac{x}{y})$，显示为：$(\frac{x}{y})$；而$\left(\frac{x}{y})\right$，显示为：$\left(\frac{x}{y}\right)$ 求和、极限和积分 求和使用\sum，如：$\sum_{i=0}^n{a_i}$，显示为：$\sum_{i=0}^n{a_i}$ 极限使用\lim，如:$\lim_{n \to 0}e^n $，显示为：$\lim_{n \to 0}e^n $ 积分使用\int，如：$\int_0^1 2x dx$，显示为：$\int_0^1 2x dx$ 分式与根式 分式使用\frac，用法为：$\frac{式1}{式2}$，显示为：$\frac{式1}{式2}$ 根式使用\sqrt，如：$\sqrt{x}{y}$，显示为：$\sqrt{x}{y}$ 特殊函数如：$\sin x \quad \ln x \quad \max(A, B, C)$，显示为：$\sin x \quad \ln x \quad \max(A, B, C)$ 特殊符号 显示 语法 显示 语法 $\infty$ \infty $\cup$ \cup $\cap$ \cap $\subset$ \subset $\subseteq$ \subseteq $\supset$ \supset $\in$ \in $\notin$ \notin $\varnothing$ \varnothing $\forall$ \forall $\exists$ \exists $\lnot$ \lnot $\nabla$ \nabla $\partial$ \partial 特殊符号还有很多这里不一一列举了。 空格LaTex 语法本身会忽略空格的存在需要用\来转译，如：$a b\ a\ b$，显示为：$a b\ a\ b$；一次性生成 4 个空格，需要使用\quad，如：$a \quad b$，显示为：$a \quad b$ 矩阵基本语法 起始标记：\begin{matrix}， 结束标记：\end{matrix} 每一行末尾标记：\\ 行间元素之间用&amp;分割 如：12345$$\begin&#123;matrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;matrix&#125;$$ 显示为：$$\begin{matrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{matrix}$$ 矩阵边框用以下关键词替换掉起始、结束标记中的matrix，如： pmatrix：小括号边框 bmatrix：中括号边框 Bmatrix：大括号边框 vmatrix：单竖线边框 Vmatrix：双竖线边框 如：1234567891011121314151617181920212223242526272829$$\begin&#123;pmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;pmatrix&#125;$$$$\begin&#123;bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;bmatrix&#125;$$$$\begin&#123;Bmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Bmatrix&#125;$$$$\begin&#123;vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;vmatrix&#125;$$$$\begin&#123;Vmatrix&#125;1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end&#123;Vatrix&#125;$$ 显示为：$$\begin{pmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{pmatrix}$$ $$\begin{bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{bmatrix}$$ $$\begin{Bmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Bmatrix}$$ $$\begin{vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{vmatrix}$$ $$\begin{Vmatrix}1 &amp; 0 &amp; 0 \\0 &amp; 1 &amp; 0 \\0 &amp; 0 &amp; 1 \\\end{Vmatrix}$$ 省略号 省略号：\dots，如：$1 \dots 5$，显示为：$1 \dots 5$ 横省略号：\cdots 竖省略号：\vdots 斜省略号：\ddots 如：123456$$\begin&#123;bmatrix&#125;a_&#123;11&#125; &amp; a_&#123;12&#125; &amp; \cdots &amp; a_&#123;1n&#125; \\a_&#123;21&#125; &amp; a_&#123;22&#125; &amp; \cdots &amp; a_&#123;2n&#125; \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_&#123;m1&#125; &amp; a_&#123;m2&#125; &amp; \cdots &amp; a_&#123;mn&#125; \\\end&#123;bmatrix&#125;$$ 显示为：$$\begin{bmatrix}a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n} \\a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n} \\\vdots &amp; \vdots &amp; \ddots &amp; \vdots \\a_{m1} &amp; a_{m2} &amp; \cdots &amp; a_{mn} \\\end{bmatrix}$$ 行中矩阵如：$\begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix}$，显示为：$( \begin{smallmatrix} a &amp; b \\ c &amp; d \end{smallmatrix} )$ 阵列使用array关键字，基本语法：1234$$\begin&#123;array&#125;&#123;格式串&#125;......\end&#123;array&#125;$$ 其中，“格式串”由四种字符构成，分别为： l，左对齐 c，居中 r，右对齐 |，建立竖直线 使用\hline可插入水平线。 如：123456$$\begin&#123;array&#125;&#123;c|lll&#125;- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end&#123;array&#125;$$ 显示为：$$\begin{array}{c|lll}- &amp; a &amp; b &amp; c \\\hlinex &amp; 1 &amp; 2 &amp; 3 \\y &amp; 4 &amp; 5 &amp; 6 \\\end{array}$$ 方程组使用cases关键字，基本语法：1234$$\begin&#123;cases&#125;&#123;格式串&#125;......\end&#123;cases&#125;$$ 如：123456$$\begin&#123;cases&#125;a_1x + b_1y + c_1z = d_1\\a_2x + b_2y + c_2z = d_2\\a_3x + b_3y + c_3z = d_3\\\end&#123;cases&#125;$$ 显示为：$$\begin{cases}a_1x + b_1y + c_1z = d_1 \\a_2x + b_2y + c_2z = d_2 \\a_3x + b_3y + c_3z = d_3 \\\end{cases}$$所以，分段函数可以写成：123456$$f(x) = \begin&#123;cases&#125;0 &amp; x为无理数 \\x &amp; x为有理数 \\\end&#123;cases&#125;$$ 显示为：$$f(x) =\begin{cases}0 &amp; x为无理数 \\x &amp; x为有理数 \\\end{cases}$$ 字体转换要对公式的某一部分字符进行字体转换，使用\[字体格式] xxx即可，默认为意大利体，字体格式仅列举以下几种： 字体 语法 字体 语法 罗马体 \rm 意大利体 \it 黑体 \bf 花体 \cal 倾斜体 \sl 等线体 \sf 数学斜体 \mit 打字机字体 \tt 小体大写字母 \sc 如：1234567$$a\ b\ c \\\rm &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\\bf &#123;a\ b\ c&#125; \\\it &#123;a\ b\ c&#125; \\$$ 显示为：$$a\ b\ c \\\rm {a\ b\ c} \\\it {a\ b\ c} \\\bf {a\ b\ c} \\\it {a\ b\ c} \\$$另外，一般会用text关键子来书写文本，如：$\text{无穷大}$，显示为：$\text{无穷大}$。 参考文章：MathJax 语法参考基本数学公式语法(of MathJax)Markdown 数学公式语法]]></content>
      <categories>
        <category>Tools</category>
        <category>MathJax</category>
      </categories>
      <tags>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown 语法快速指南]]></title>
    <url>%2F2020%2F09%2F16%2FMarkdown-%E8%AF%AD%E6%B3%95%E5%BF%AB%E9%80%9F%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[有关 Markdown 的概念性问题，请点击链接自行查看。本文旨在整理一些平时写文档时常用的一些语法，这样既方便他人查看，也以免自己忘记。 标题Markdown 支持两种形式的标题，Setext 和 atx，常用的是 atx 语法的标题，本文以此为主。Atx 样式的标题每行开头使用 1-6 个井号，井号的个数对应 1-6 级标题（最多也就 6 级），例如：12345# 一级标题## 二级标题#### 四级标题 效果如下： 块引用块引用的方式很简单，例如：1&gt; xxxx 效果如下： xxxx 引用内还可以包含 Markdown 的其他元素，如列表和代码块等，这里不详细介绍了。 列表Markdown 支持有序列表和无序列表。 无序列表无序列表使用星号、加号和连字符，使用任一符号都可以实现一样的效果，例如：1234567891011* peach* apple* banana+ peach+ apple+ banana- peach- apple- banana 效果如下： peach apple banana peach apple banana peach apple banana 有序列表有序列表使用数字加点完成（点后与字符之间有空格），例如：1231. peach2. apple3. banana 效果如下： peach apple banana 列表之间还可以进行嵌套使用，形成一级表头和二级表头这样的东西，如：12345- xxx - xxx1. 111 2. 222 效果如下： xxx xxx 111 222 代码块常见用法主要有单行代码块和多行代码块。 单行代码块单行代码块使用一对重音符``来书写，直接将代码放到重音符中间即可，如：1`xxx` xxxxxxxxx 多行代码块多行代码块使用三对重音符来书写，同样将代码块放到中间即可，如：12345(```)xxxbbbxxx(```)注意实际是没有括号的 效果如下：1xxxbbbxxx 水平线如果一行中只有三个以上的连字符、星号或下划线，则会在该位置s生成一个&lt;hr&gt;标签，这条线可以叫水平线，也可以叫分割线，效果如下： 不同的 Markdown 编辑器渲染出来的效果可能不一样。 表格Markdown 内表格的用法有点麻烦，需要使用冒号、竖线和连字符来完成，如：1234表头 | 表头 | 表头-- | :--: | --:1 | 2 | 34 | 5 | 6 效果如下： 表头 表头 表头 1 2 3 4 5 6 大致说明一下：第二行是格式控制行，-有一个就可以了，有时为了对齐会多加几个；除了第二行外的其他行中的文字是默认居左的，两边都加:，就可以居中，右边加:就可以居右。 表格中的文字也能使用 Markdown 中文字相关的语法；如果想要改变表格中文字的颜色，可以借助font标签来完成。 文字与文字相关的语法，如：1234**加粗***斜体****斜体加粗***~~删除~~ 效果如下：加粗斜体斜体加粗删除 图片引用基本语法，如：123![图片名称](图片地址 &quot;图片下标题&quot;)如：![zzz](https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1600276810120&amp;di=ffb59bf5363570267ac8201139b33c94&amp;imgtype=0&amp;src=http%3A%2F%2Fa2.att.hudong.com%2F86%2F10%2F01300000184180121920108394217.jpg &quot;xxx&quot;) 效果如下： 链接基本语法，如：123[链接名称](链接地址)如：[Baidu](https://www.baidu.com) 效果如下：Baidu 参考文章：Markdown 中文文档Markdown基本语法]]></content>
      <categories>
        <category>Tools</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_Summary]]></title>
    <url>%2F2020%2F09%2F16%2FZJU-DS-Summary%2F</url>
    <content type="text"><![CDATA[课堂笔记全部写完了，总结一下。 课堂评价虽然这是门在线课程，但是课堂的质量其实很高，主要归功于两位老师深入浅出的讲解，以及在合适的时间插入的课间习题。私认为姥姥跟何头已经尽量讲的简单一点了，但是由于这门课程的特殊性（抽象的东西太多），可能还是有人听的云里雾里，建议多听几遍。何头讲课比较直接，各种细节性问题都会给你讲清楚，姥姥讲课偶尔会“调皮”一下（心态真是年轻啊...），更想引发你自己的思考；他们的共同点就是课上讲的话都十分的精练，没什么废话，有些地方还得都听几遍才能懂。 另外，课间穿插的习题和视频后的讨论可以引发学生的思考，对理解课上的东西有一定的帮助，这也是值得称赞的地方；专门设置的“小白专场”也是十分贴心，值得好评。 课程练习课程练习主要有三种：课间习题、课后习题和 PTA 上的编程题。课间习题帮助理解课堂上所讲的内容；课后习题帮助巩固课堂上所讲的内容；PTA 上的作业题算是实打实的“应用题”，把课上学的理论一步步实现，既能加深对理论的理解，又能增强编码能力，十分不错。 有点美中不足的地方就是课后习题太少了，这类笔试题目如果能增多，对要考试的学生而言很有帮助。不过，老师们编的教材上也有不少习题，这可能是课后习题比较少的原因。 关于 PTA 上的编程题，建议全部做完（虽然老师说了那些必做，那些选做），一定要自己先做，不能一次 AC 不要紧，实在 AC 不了，再看老师的讲解（难一点的基本都讲了）。有些题目的解题思路其实有很多，光是直接百度就有很多资料可查。另外，题目总体难度大概就是 PAT 甲级的难度了，作业题里面有些就是当年的甲级真题，所以一定要好好做。 考试考试的形式比较简单，也很方便，每周作业都是编程题，考试有判断、选择、填空、编码题，没有做过针对性练习的同学可能会很不习惯，最好考试前做点针对性的练习。另外，如果考试结束后，能提供错题的答案就完美了。 个人体会数据结构与算法这门课是真的很抽象，基本全部都是理论化的东西，学的基本就是几十年前的计算机科学家论文上写的东西，得耐住性子，仔细钻研。这门课就好比修炼武侠绝技前修炼的“内功心法”一般，是根基，理论基础扎实了，实践能力才能稳步提高。不过，两位老师讲的很棒，着实方便了不少。 在把图学完的时候，感觉就像是有了“屠龙宝刀”却不知道怎么用一样。不过实际的生产坏境中，根本没机会让你去“屠龙”... 一般而言，计算机学科的科目要想学到东西，切忌不能空谈理论，一定得动手，动手去写，动脑子去想问题。就这门课而言，PTA 上的编程题都是十分不错的习题，一定得动脑子去写。就算不能解决，只要动脑子思考了问题，基本都会有收获。 自己算是把这门课反复学了好几遍才算是能理解一些东西了，可能是自己脑子太拙了吧... 不管怎么说，把所有的笔记整理完也算是完成了一件事，继续努力吧，骚年~😉]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_12-KMP]]></title>
    <url>%2F2020%2F09%2F15%2FZJU-DS-12-KMP%2F</url>
    <content type="text"><![CDATA[本周主要讲解几道题目，然后再介绍一下 KMP 算法。 串在了解KMP算法之前，我们先了解一下什么是串。串（String）其实也是线性表的一种应用，指的是线性存储的一组数据（常见是字符，正所谓“字符串”），当然，串不仅仅包含字符，它是通用的数据结构。同时，与串相关的操作集有很多，如：求串的长度、比较两串是否相等、两串相接、求子串、插入子串、匹配子串（KMP 就是干这事的）、删除子串等。 KMP匹配子串什么是“匹配子串”呢？看名字，其实有两个着重点，一个是匹配，一个是子串。举个例子，给定一段文本，从中找出某个指定的关键字，例如给定文本：This is not a bug, it’s destiny. ，需要从中找出 bug 这个关键字（当然这并不是件复杂的事情），这实际上就是“匹配子串”。 那么我们重新规范一下，就是：给定一个文本：string = xxxxxxx，在给定一个模式：pattern = xxxx，求 pattern 在 string 中出现的位置。 分析依据匹配子串的思路，如果要找pattern在string中出现的位置，分别使用两个指针，接着对string进行遍历，同时与pattern逐个字符进行比较，如果出现不相等的，则string的指针回退到初试比较位置的后一个位置（若从 i 开始比较，则回退到 i+1 开始比较），pattern的指针则回退到第一位，重复执行即可，这实际上是一种暴力解法。使用暴力解法时，串中肯定会有相同的序列存在，所以指针回溯后再次遍历比较时，就会进行重复的比较操作了，这样就做了很多无用的操作，而 KMP 算法就是用来解决这个问题的。 匹配函数KMP 算法在直接进行匹配前会对模式串（pattern）进行分析，借助一个辅助数组match[]，这个数组内保存着模式串按照下面的 $ match $ 函数计算的“值”，根据这些“值”，再构造合适的判断规则来解决这个问题；match[]数组的下标就是模式串每一个字符的下标。先来看一下这个 $ match $ 函数: $$match(j) = \begin{cases}&amp;\text{满足}p_0 \cdots p_i = p_{j-i} \cdots p_j \text{的最大}i(\lt j) \\&amp;-1\ \ \ \text{如果这样的} i \text{不存在}\end{cases}$$ 假设pattern为abcabcacab这个序列，下面来计算一下其由 $ match $ 函数得来的数组。1→2→3→4→重复先从a开始，a为首字符，根据 $ match $ 函数的规则，match(0) = -1继而到b，b需要和前面的a进行比较，发现不匹配，match(1) = -1再看c，此时对于match函数而言，i可以取两个值，分别是0和1（此时j=2），取0时，c直接和a比较，不匹配，取1时，那就是ab和bc进行比较，还是不匹配，所以match(2) = -1再看下一个a，此时i可以取三个值（0、1、2，注意match函数的条件是不大于j的最大i），取0，a和a比较，匹配成功，match(3) = 0，取1，ab和ca不匹配，取2，abc和bca也不匹配（若此时匹配，match(3)的值需要更新），所以match(3) = 0按照这种思路，重复直至结束。重复计算后，可以得到下表： pattern a b c a b c a c a b j 0 1 2 3 4 5 6 7 8 9 match -1 -1 -1 0 1 2 3 -1 0 1 match函数有多种和不同的称呼，有些书也叫next。另外，需要明确的是，这个特定函数的针对对象是pattern，也即是给定的模式串，而不是原串。另外，pattern比较短，string比较长，KMP算法只用分析一个短的子串而不用分析一个长串，这其实已经提升了效率。 算法实现使用 $ match $ 函数获得match[]数组后，如何去使用match[]数组又成为新问题。首先我们已经知道了，根据match[]数组可以避免去比较重复的序列，当不匹配时，指向pattern的指针p会去找p-1这个指针所指位置的match[]值，而这个match[]值加1就是指针p重新开始进行匹配的位置，即如下图所示：就是这样去使用match数组的，明确这个问题后，基本可以写出 KMP 算法的代码了，如下所示：1234567891011121314151617Position KMP(char *string, char *pattern) &#123; int n = strlen(string); /* O(n) */ int m = strlen(pattern); /* O(m) */ int s, p, *match; if(n &lt; m) return NotFound; match = (int*)malloc(m*sizeof(int)); BuildMatch(pattern, match); /* T(B) */ s = p = 0; while(s&lt;n &amp;&amp; p&lt;m) &#123; /* O(n) */ if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p-1] + 1; else s++; &#125; return (p==m)?(s-m):NotFound;&#125; 从上面的代码可以分析出其时间复杂度基本为$T = O(n+m) + T(B)$，BuildMatch函数的时间复杂度取决于其自身的实现方式，别忘记了，KMP是以它为前提的。 有了前面对 $ match $ 函数的分析，BuildMatch函数的构造就比较简单了，但若只是简单用线性的方法去构造match数组的话，会使得时间复杂度为$O(m^3)$，这就很不友好了，那怎么办呢？ 答案是利用match[]数组内的值，如果是计算第i个位置的match值，那么必定得去找i-1的match值加1所指位置的字符是否与i所指位置的字符相同，如果相同，皆大欢喜，match[i] == match[i-1] + 1了，如果不相等呢？ 就得去找i-1的match值的match值加1所指位置的字符是否与i所指位置的字符相同了（好绕...😓），也即match[match[i-1]]，若相同，match[i] == match[match[i-1]] + 1，如果还不相等，继续找吧...（还好是电脑干活😓）。可参考下图：基本代码如下：1234567891011121314void BuildMatch(char *pattern, int *match) &#123; int i, j; int m = strlen(pattern); /* O(m) */ match[0] = -1; for(j=1; j&lt;m; j++) &#123; /* O(m) */ i = match[i-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) &#123; match[j] = i+1; &#125; else match[j] = -1; &#125;&#125; 简单分析一下上述代码的时间复杂度，可得 $T_m(N) = O(m)$，综合起来 KMP 算法的时间复杂度就是 $T(N) = O(n+m)$，从暴力解法的 $O(n·m)$ 优化成 $O(n+m)$，确实厉害！ Homework串的模式匹配这道题目是用来测试各式各样的串的模式匹配算法的，按照姥姥给出的代码，可以得到下面的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;#define NotFound -1typedef int Position;void Build_Match(char *pattern, int *match) &#123; Position i, j; int m = strlen(pattern); match[0] = -1; for(j=1; j&lt;m; j++) &#123; i = match[j-1]; while(i &gt;= 0 &amp;&amp; (pattern[i+1] != pattern[j])) &#123; i = match[i]; &#125; if(pattern[i+1] == pattern[j]) match[j] = i+1; else match[j] = -1; &#125;&#125;Position KMP(char *string, char *pattern) &#123; int n = strlen(string); int m = strlen(pattern); Position s, p, *match; if(n &lt; m) return NotFound; match = (Position*)malloc(m*sizeof(Position)); Build_Match(pattern, match); s = p =0; while(s&lt;n &amp;&amp; p&lt;m) &#123; if(string[s] == pattern[p]) &#123; s++; p++; &#125; else if(p &gt; 0) p = match[p - 1]+1; else s++; &#125; return (p == m) ? (s - m) : NotFound;&#125;int main(int argc, char const *argv[]) &#123; char string[] = "This is a simple example."; char pattern[] = "simple"; Position p = KMP(string, pattern); if(p == NotFound) printf("Not Found.\n"); else printf("%s\n", string+p); return 0;&#125;/*samples:in:abcabcabcabcacabxy3abcabcacabcabcabcdabcabcabcabcacabxyzout:abcabcacabxyNot FoundNot Found */]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_11-散列查找]]></title>
    <url>%2F2020%2F09%2F06%2FZJU-DS-11-%E6%95%A3%E5%88%97%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[本周将介绍散列查找 引子先来回顾一下其他的查找方法： 名称 时间复杂度 顺序查找 $O(N)$ 二分查找（静态查找） $O(log_2N)$ 二叉搜索树 $O(h), h$为树高 平衡二叉树 $O(log_2N)$ 上表中的查找方法都是建立在容易比较关键字的情况下，如果关键字不容易比较呢？ 散列查找散列查找所要解决的问题就是： 计算位置：构造散列函数确定关键词存储位置解决冲突：应用某种策略解决多个关键词位置相同的问题 按照散列查找的做法，每次查找只进行计算就够了，时间复杂度为$O(1)$，也就是说查找时间与问题规模无关！ 抽象数据类型描述类型名称：符号集（Symbol Table）数据对象集：符号表是“名字（Name）- 属性（Attribute）”对的集合操作集：Table ∈ Symbol Table, Name ∈ NameType, Attr ∈ AttributeType SymbolTable InitializeTable(int TableSize)，创建一个长度为TableSize的符号表 Boolean IsIn(SymbolTable Table, NameType Name)，查找特定的名字Name是否在符号表Table中 AttributeType Find(SymbolTable Table, NameType Name)，获取Table中指定名字Name对应的属性 SymbolTable Modefy(SymbolTable Table, NameType Name, AttributeType Attr)，将Table中指定名字Name的属性修改为Attr SymbolTable Insert(SymbolTable Table, NameType Name, AttributeType Attr)，向Table中插入一个新名字Name及其属性Attr SymbolTable Delete(SymbolTable Table, NameType Name)，从Table中删除一个名字Name及其属性 基本思想散列（Hashing）的基本思想如下： 以关键字$key$为自变量，通过散列函数$h$，计算出对应的函数值$h(k)$，作为数据对象的存储地址。 可能不同关键字会映射到同一散列地址上，这种情况称为冲突（Collision），这需要某种冲突解决策略。 这里引入装填因子(Loading Factor)的概念，即：散列表内元素个数（$n$）与散列表空间（$m$）的比值，即$\alpha = n / m$。 散列函数按照前面的思路，在构造散列函数时需要注意两点： 计算简单，以便提高地址转换速度 关键词对应的地址空间分布均匀，以尽量减少冲突 根据数据元素的不同，可以分为以数字关键词和字符关键词构造的散列函数。 数字关键词以数字为关键词的散列函数构造方法又有多种，依次如下： 名称 散列函数 直接定址法 $h(key) = a \times key + b, a, b$为常数 除留余数法 $h(key) = key mod p, p$取素数 数字分析法 $h(key) = atoi(key + 7)$ 折叠法 关键词分割成位数相同的几个部分叠加 平方取中法 关键字平方后取其中几位 字符关键词以字符为关键词的散列函数构造也有多种，依次如下：ASCII码加和法前3个字符移位法移位法散列函数：$h(key) = (\sum key[i])\ mod\ TableSize$，此法产生的冲突较为严重散列函数：$h(key) = (key[0] \times 27^2 + key[1] \times 27 + key[2])\ mod\ TableSize$，这里看作 27 进制数，依然存在冲突，散列函数：$h(key) = (\sum_{i=0}^{i-1} key[n-i-1] \times 32^i)\ mod\ TableSize$，看作 32 进制数涉及关键词，所有n个字符，并且分布比较均匀 1234567Index Hash(const char *Key, int TableSize) &#123; unsigned int h = 0; while(*Key != ‘\0’) &#123; h = (h &lt;&lt; 5) + *Key++; // h &lt;&lt; 5 &lt;==&gt; h*32 &#125; return h%TableSize;&#125; 冲突处理方法对于散列查找而言，产生冲突必定会影响效率，那么如何处理冲突呢？ 开放定址法开放定址法的思路比较简单，说白了，就是这个不行换另外一个，一旦产生了冲突（该地址已有其它元素），就按照某种规则寻找另一个空的地址。按照这种思路，寻找下一空地址的过程，称为探测，而它也有多种不同的探测方法。 线性探测顾名思义，线性探测法就是线性的探测法（说了没说系列？😏），也即以增量序列${1, 2, \ldots}（TableSize - 1）$循环试探下一个地址，也就是检测到冲突了，下标加一试试下一个地址，注意循环到末尾后若还没有空位置，则继续从头部开始循环，此法容易产生“聚集”现象。 平方探测平方探测也叫二次探测，以增量序列${1^2, -1^2, 2^2, -2^2, \ldots, q*2, -q^2}, q \le \lfloor TableSize \rfloor$，循环试探下一个存储地址，此法与线性探测唯一的区别只是增量序列不同而已。但平方探测存在一个很严重的问题，就是“抖动”现象，明明有空位置，但是就是无法探测到散列表的空位置，不过好在可以借助下面这个定理（感谢数学家🙇‍）。 定理：如果散列表长度TableSize是某个$4k+3$（$k$是正整数）形式的素数时，平方探测就可以探查到整个散列表空间。 双散列顾名思义，双散列，就是产生冲突了，再进行一次散列，两次散列的散列函数不同，而是第一次散列的结果将作为第二次散列的key，也即$d_i$为$i \times h_2(key)$，其探测序列为$h_2(key),\ 2h_2(key),\ 3h_2(key), \ldots$，很明显，对任意的key，$h_2(key) \neq 0$，为保证所有的散列存储单元都可以被探测到，$h_2$选为$h_2(key) = p - (key\ mod\ p)$，$p,\ TableSize$都是素数。 再散列当散列表元素太多（即装填因子$\alpha$太大）时，查找效率会下降，实际最大装填因子一般取$0.5 \le \alpha \le 0.85 $，对应的解决办法就是加倍扩大散列表，这个过程就叫做“再散列（Rehashing）”，注意，再散列时，原先的散列序列不是简单的复制，而是要重新计算。 分离链接法分离链接法最终产生的结构有点类似图的邻接表，其基本思想就是将相应位置上冲突的所有关键词存储在同一个单链表中，也就是说这种结构需要一个数组，并且数组内每个元素除了表示关键字还得有一个指针域，用来将链表串起来。 性能分析对于查找而言，衡量其效率的指标，依然是平均查找长度（ASL，分查找成功和不成功两种），平均查找长度的计算方法要视具体的散列方法而定。另外，影响产生冲突多少有以下三个因素： 散列函数是否军运 处理冲突的方法 散列表的装填因子$\alpha$ 下面直接给出其期望探测次数 p，不做深入的数学探讨。 线性探测法：$p =\begin{cases} \frac{1} {2} [1+\frac{1} {(1-\alpha)^2}],&amp; \text {对插入和不成功查找而言} \\\frac{1}{2}[1+\frac{1}{(1-\alpha)}],&amp; \text {对成功查找而言}\end{cases}$平方探测法：$p =\begin{cases} \frac{1} {(1-\alpha)},&amp; \text {对插入和不成功查找而言} \\\frac{-1} {\alpha} ln(1-\alpha),&amp; \text {对成功查找而言}\end{cases}$分离链接法：$p =\begin{cases} \alpha + e^{-\alpha},&amp; \text {对插入和不成功查找而言} \\1+ \frac{\alpha} {2},&amp; \text {对成功查找而言}\end{cases}$ 根据上面的公式我们可以得出下面几点结论： 当装填因子$\alpha &lt; 0.5$时，各种探测法的期望探测次数都不大随着$\alpha$的增大，线性探测法的期望探测次数增加较快，不成功查找和插入操作的期望探测次数比成功查找的期望探测次数要大合理的最大装填因子$\alpha$应该不超过0.85 总结散列查找的优点很明显，选择合适的散列函数，散列查找效率的期望是常数$O(1)$，它几乎与关键字的空间的大小$n$无关，也适合于关键字直接比较计算量过大的问题；但它是以较小的$\alpha$为前提，是一个以空间换时间的查找方法；另外，它对关键字的存储是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大、最小值查找。 开放定址法的存储效率很高，但是存在“聚集”现象；分离链接法是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低，关键字的删除不需要“懒惰删除（不断链，只标记为空）”，从而没有存储“垃圾”，但太小的$\alpha$可能导致空间浪费，大的$\alpha$又将付出更多的时间代价，且不均匀的链表长度会导致时间效率的严重下降。 Homework11-1 电话聊天狂人这个题姥姥已经讲过了，直接用姥姥的代码有点麻烦，借助 C++ 的 MAP 和散列的思想，可以很轻松的解决这个问题。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2000000 + 5;map&lt;string, int&gt; phonenum2num;map&lt;int, string&gt; num2phonenum;int times[maxn] = &#123; 0 &#125;, n, index = 1;int main() &#123; cin &gt;&gt; n; string num; for (int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; num; int tmp = phonenum2num.find(num)-&gt;second; if (!tmp) &#123; phonenum2num[num] = index; num2phonenum[index] = num; times[index] = 1; index++; &#125; else &#123; times[tmp]++; &#125; &#125; int max = times[1], maxindex = 1, count = 1; string madman = num2phonenum.find(1)-&gt;second; for (int i = 2; i &lt; index; i++) &#123; if (times[i] &gt; max) &#123; max = times[i]; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; else if (times[i] == max) &#123; if (num2phonenum.find(i)-&gt;second &lt; num2phonenum.find(maxindex)-&gt;second) &#123; maxindex = i; madman = num2phonenum.find(i)-&gt;second; &#125; count++; &#125; &#125; if (count == 1) cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max; else cout &lt;&lt; madman &lt;&lt; ' ' &lt;&lt; max &lt;&lt; ' ' &lt;&lt; count; return 0;&#125;/*samples:in:413005711862 1358862583213505711862 1308862583213588625832 1808792583215005713862 13588625832out:13588625832 3*/ 11-2 Hashing本题考察散列查找的冲突处理方法，题目很直白的告诉了处理冲突的方法是平方探测法，但题目要求的平方探测只会用正整数探测。这方面的知识，课上何老师已经讲的很清楚了，不过这个题的难点在于如何处理无法进行散列的数。 由于题目告诉了只会用正整数探测，其实算是变相的告诉你了，只要经过散列函数得到的下标值大于散列表长度，就认为无法存放了，也就是说并不会循环试探，明白这点后就好办了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 20000 + 10;bool hashTable[maxn] = &#123; 0 &#125;;bool isprime(int n) &#123; if (n &lt;= 1) return false; else &#123; int tmp = (int)sqrt(n); for (int i = 2; i &lt;= tmp; i++) &#123; if (n % i == 0) return false; &#125; return true; &#125;&#125;int nextprime(int m) &#123; while (!isprime(m)) m++; return m;&#125;int hashfunc(int num, int hashkey) &#123; return num % hashkey;&#125;int main() &#123; int m, n, tmp; cin &gt;&gt; m &gt;&gt; n; m = nextprime(m); for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; int index = hashfunc(tmp, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; &#125; else &#123; int step; for (step = 1; step &lt; m; step++) &#123; index = hashfunc(tmp + step * step, m); if (hashTable[index] == false) &#123; hashTable[index] = true; if (i == 0) cout &lt;&lt; index; else cout &lt;&lt; ' ' &lt;&lt; index; break; &#125; &#125; if (step &gt;= m) &#123; if (i &gt; 0) cout &lt;&lt; ' '; cout &lt;&lt; '-'; &#125; &#125; &#125; return 0;&#125;/*samples:in:4 410 6 4 15out:0 1 4 -in:5 510 6 4 15 25out:0 1 4 - -in:5 55 10 6 4 15 out:0 1 2 4 -in:1 11out:1*/ 11-3 QQ 账户的申请与登陆这题用 MAP 简直太容易了，要是全部自己写，代码量略大。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, string&gt; qqnum;int main() &#123; int n; char ope; cin &gt;&gt; n; string tmp_num, tmp_pass; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ope &gt;&gt; tmp_num &gt;&gt; tmp_pass; map&lt;string, string&gt;::iterator it; it = qqnum.find(tmp_num); switch (ope) &#123; case 'L': &#123; if (it == qqnum.end()) &#123; cout &lt;&lt; "ERROR: Not Exist" &lt;&lt; endl; &#125; else &#123; if (it-&gt;second == tmp_pass) &#123; cout &lt;&lt; "Login: OK" &lt;&lt; endl; &#125; else cout &lt;&lt; "ERROR: Wrong PW" &lt;&lt; endl; &#125; break; &#125; case 'N': &#123; if (it != qqnum.end()) &#123; cout &lt;&lt; "ERROR: Exist" &lt;&lt; endl; &#125; else &#123; qqnum[tmp_num] = tmp_pass; cout &lt;&lt; "New: OK" &lt;&lt; endl; &#125; break; &#125; default: break; &#125; &#125; return 0;&#125;/*samples:in:5L 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comN 1234567890 myQQ@qq.comL 1234567890 myQQ@qqL 1234567890 myQQ@qq.comout:ERROR: Not ExistNew: OKERROR: ExistERROR: Wrong PWLogin: OK*/ 11-4 Hashing - Hard Version这个题的意思很直观，就是给定一个用线性探测法构建的散列表，然后要根据这个得到数字序列的输入顺序。 这个题看起来很容易，其实有点难想。因为就样例而言，33 和 1 都有可能是第一个输入的，该怎么确定数字的输入顺序其实就是难点。 一般而言，做一道题时，想到的都是跟这个题相关的知识。但是这个题，确定输入顺序其实需要用到拓扑排序的知识。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 1000 + 3;vector&lt;int&gt; AdjL[maxn];int n, hashTable[maxn], elements = 0;bool isvis[maxn] = &#123;false&#125;;map&lt;int, int&gt; value2index;map&lt;int, int&gt; index2value;void toposort() &#123; int indegree[maxn] = &#123;0&#125;; for(int v = 0; v &lt; n; v++) &#123; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]++; &#125; &#125; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; for(int i = 0; i &lt; n; i++) &#123; if(indegree[i] == 0 &amp;&amp; hashTable[i] &gt;= 0) &#123; q.push(hashTable[i]); &#125; &#125; int count = 0; while(!q.empty()) &#123; int tmp = q.top(); q.pop(); cout &lt;&lt; tmp; if(count &lt; elements - 1) &#123; cout &lt;&lt; ' '; count++; &#125; int v = value2index[tmp]; for(int w = 0; w &lt; AdjL[v].size(); w++) &#123; indegree[AdjL[v][w]]--; if(indegree[AdjL[v][w]] == 0) q.push(hashTable[AdjL[v][w]]); &#125; &#125;&#125;int main() &#123; cin &gt;&gt; n; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; hashTable[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; if(hashTable[i] &lt; 0) continue; value2index[hashTable[i]] = i; index2value[i] = hashTable[i]; elements++; int tmp = hashTable[i]; int index = tmp % n; if(hashTable[index] == hashTable[i] &amp;&amp; index == i) continue; else &#123; bool flag = true; queue&lt;int&gt; q; for(; index &lt; n || flag; index++) &#123; if(flag &amp;&amp; index &gt;= n) &#123; index %= n; flag = false; &#125; if(hashTable[index] == tmp) break; q.push(index); &#125; while(!q.empty()) &#123; int front = q.front(); q.pop(); AdjL[front].push_back(index); &#125; &#125; &#125; toposort(); return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_10-排序（下）]]></title>
    <url>%2F2020%2F09%2F05%2FZJU-DS-10-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周继续介绍排序算法。 快速排序快速排序与归并排序的策略有些类似，基本思想也是分治法，首先从待排序列中找一个主元，根据这个主元将待排序列的所有元素划分为两部分，一部分比它小，另一部分比它大，然后对两个子部分在进行划分和排序，依次重复操作，最后再将这些合并为一个序列。基本代码如下：12345678void Quick_Sort(ElementType A[], int N) &#123; if(N &lt; 2) return; pivot = 从A[]中选一个主元; 将S = &#123;A[] / pivot&#125; 分成2个独立子集; A1 = &#123;a ∈ S | A &lt;= pivot&#125;; A2 = &#123;a ∈ S | A &gt;= pivot&#125;; A[] = Quick_Sort(A1, N1)∪(pivot)∪Quick_Sort(A2, N2);&#125; 按照上述的伪码描述，快排需要解决的问题有两个： 1. 如何去选主元2. 如何进行子集划分 很明显，按照思路，能把第一个问题解决了，第二个问题也就迎刃而解了。 选主元那么主元应该怎么去选择呢？比较经典的方法就是取头、中、尾三个数（当然也可以五个数）的中位数（以序列{8, 12, 3}为例，它的中位数是8），选主元时，可以顺便将待选的三位数进行排序，这样当选出主元后，也可以待排序列数据的总个数减少，基本代码如下：123456789101112ElementType Median3(ElementType A[], int Left, int Right)&#123; int Center = (Left + Right)/2; if(A[Left] &lt; A[Center]) Swap(&amp;A[Left], &amp;A[Center]); if(A[Left] &lt; A[Right]) Swap(&amp;A[Left], &amp;A[Right]); if(A[Center] &lt; A[Right]) Swap(&amp;A[Center], &amp;A[Right]); /*after finish swap, A[Left] &lt;= A[Center] &lt;= A[Right]*/ /*put the pivot to A[Right-1], then only consider the sequence from A[Left+1] to A[Right-2]*/ Swap(&amp;A[Center], &amp;A[Right-1]); return A[Right-1];&#125; 按照上述代码，因为最后将pivot放到了Right-1位置，所以，另外两个元素的位置就可以不用在考虑了，只考虑区间$[Left+1, Right-1]$内的元素即可。 子集划分子集划分时，需要使用两个指针，一个首，一个尾，当尾指针小于首指针（两者已交叉）时，说明子集的划分已完成。在进行这个操作时，会存在一个问题，那就是遇到相等的元素怎么办？以最坏的情况（序列元素全部相等）为例，如果采取直接交换元素的方法，那么首、尾指针的每一次变化，都需要交换一次元素，结束后，主元pivot会被放在中间的位置，这样下一次循环的时候就会将剩下的序列在等分成两个序列，这样时间复杂度就是$O(NlogN)$了；那如果跳过相等的元素呢？在最坏的情况下，会有一端的指针停滞不前，那么每次就只有一个指针在移动，这样每次得到的子序列就$N, N-1, N-2, \dots, 1$了，那样时间复杂度依然是$O(N^2)$，所以还是采取交换元素的方法。另外，如果数据规模较小的话，，特别是数据总数连100都不到的时候，对于依然使用递归的快速排序而言，就不是那么划算了，所以需要做个判断，在数据规模较小的时候，采取其他的排序方式。 算法实现选好主元，明确子集的划分方法，就可以来构造算法了，基本代码如下：123456789101112131415161718void QuickSort(ElementType A[], int Left, int Right)&#123; if(Cutoff &lt;= Right-Left)&#123; Pivot = Median3(A, Left, Right); i = Left; J = Right - 1; for(; ; ) &#123; while(A[++i] &lt; pivot); while(A[++j] &lt; pivot); if(i &lt;= j) Swap(&amp;A[i], &amp;A[j]); else break; &#125; Swap(&amp;A[i], &amp;A[Right-1]); QuickSort(A, Left, i-1); QuickSort(A, i+1, Right); &#125;else Insertion_Sort(A+Left, Right-Left+1);&#125; 上述代码的思路比较直观，先选好主元，在进行子集划分，然后将主元放到靠近中间的位置，此时主元的位置与最终结果序列的位置是一致的，这点与冒泡排序一样，每次都会有一个元素被排到最终位置。当待排元素小于阈值Cutoff时，直接使用插入排序解决剩下的元素序列。 表排序表排序适用于待排元素不是简单的整数，而是复杂、庞大的元素的时候，因为这些复杂、庞大的元素的交换和移动会十分费时。也就是说，表排序在排序过程中不需要移动元素，只需要移动指针即可，这种不移动元素，只移动指针的排序方法称为间接排序。定义一个指针数组作为“表”（table），表排序算法的操作对象就是这个“表”了。 物理排序假若仍然需要移动实际的元素来完成排序，那么可以根据下面这个结论在线性的时间复杂度内完成这个操作。 定理：N个数字的排列由若干个独立的环组成。 这里的“环”，其实是一个比较抽象的概念，指的是经过表排序后等到的table内，有些元素的顺序会形成一个序列，而这个序列就称作“环”。下面来看个例子，表排序前： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 0 1 2 3 4 5 6 7 表排序后： A [0] [1] [2] [3] [4] [5] [6] [7] key f d c a g b h e table 3 5 2 1 7 0 4 6 上表中，由{3, 5, 1, 0}这个下标序列可得对应的有序序列为{a, b, d, f}，这个序列是有序的，其对应关系如下表： A [0] [1] [3] [5] table 3 5 1 0 由上表中构成的关系，就是“环”，可以根据“环”得到有序的序列。紧接着，根据这些有序的序列，借助一个临时空间，遍历一次这个有序序列，就可以完成物理序列的排序。很明显可以得到，当table[i] == i时，环就结束了。 时间复杂度分析当初始序列为有序时，是最好的情况；当有$\lfloor N/2 \rfloor$个环时，每个环包含2个元素，交换两个元素需要三步操作，就需要$\lfloor 3N/2 \rfloor$次元素移动，而表排序针对的就是元素移动时间较长的存储结构，所以时间复杂度为$T = O(m\ N)$，$m$为每个元素的复制时间。 基数排序基数排序与其他排序算法有一个很大的差别，那就是不仅只是比大小了，因为单纯靠比较大小的排序算法的时间复杂度最低只能是$T(NlogN)$这个级别，所以得在添点“料”来继续提升速度，下面先来看看桶排序。 桶排序对于桶排序而言，假设待排序列有$N$个元素，先申请$N$个桶（有序，桶内保存指针），然后将每一个符合条件的值，插到这个有序的桶排列中，这样就可以了，大致代码如下：1234567891011void Bucket_Sort(ElementType A[], int N) &#123; count[]初始化; while(读入一个数据) &#123; 将该数据插入count[桶内保存的指针++]; &#125; for(i=0; i&lt;M; i++) &#123; if(count[i])&#123; 输出count[i]整个链表; &#125; &#125;&#125; 按照上述的伪码，有$N$个数据需要读入，$M$个数据需要输出，所以时间复杂度为$T(N, M) = O(M + N)$。但是当$M &gt;&gt; N$的情况下，使用桶排序就不是那么划算了，这就需要使用基数排序了。 桶排序基本思想了解了桶排序之后，基数排序就好理解了，基数排序建桶规则是按照给定数据的进制数建桶，例如{78, 123, 44, 678}， 这个序列的数都是十进制的，所以基数（桶的大小）为 10。 基数排序算法的主体思想采用的是次位优先（Least Significant Digit）的思想（也可以使用主位优先(Most Significant Digit)），简单来讲，第一次排序以个位数大小为基准来排序，第二次排序以十位数大小为基准来排序，但需要将第一次排序中的高位数拿出来，重复至最高位排完后结束。每躺排序过程中，需要访问$N$个结点，也需要访问$B$个桶，所以时间复杂度为$T=O(P(N+B))$。 多关键字排序扑克牌的花色就是一种“多关键字排序”，不同花色同花顺也有大小之分。 以为扑克牌排序为例，扑克牌有两种属性，分别是花色和大小，一副整齐的扑克牌，花色和大小必定都是整齐的，根据基数排序的思想，我们可以先按照大小来做基数排序，这需要13个桶来完成，排好序后，各个桶中的牌的大小都是相等的，此时我们在以花色为基数建桶，依次取出花色按顺序取出花色相同的牌放到不同花色的桶内即可，已经不需要根据大小排序了。 排序算法的比较 排序方法 平均时间复杂度 最坏情况时间复杂度 额外空间复杂度 稳定性 简单选择排序 $O(N^2)$ $O(N^2)$ $O(1)$ 不稳定 冒泡排序 $O(N^2)$ $O(N^2)$ $O(1)$ 稳定 直接插入排序 $O(N^2)$ $O(N^2)$ $O(1)$ 稳定 希尔排序 $O(N^d)$ $O(N^2)$ $O(1)$ 不稳定 堆排序 $O(NlogN)$ $O(NlogN)$ $O(1)$ 不稳定 快速排序 $O(NlogN)$ $O(N^2)$ $O(logN)$ 不稳定 归并排序 $O(NlogN)$ $O(NlogN)$ $O(N)$ 稳定 基数排序 $O(P(N+B))$ $O(P(N+B))$ $O(N+B)$ 稳定 尽管上表中给出了各排序算法的具体的时间复杂度，但是实际应用时还是需要根据实际情况来选择合适的排序算法。另外，从表中看到堆排序的性能比较好，但是实际效果不太理想。除了这些基础排序算法外，还有很多其他的排序算法，那些也值得进一步学习。 Homework10-4 统计工龄这个题目很简单，借助一下姥姥课上讲的桶排序的思想即可，C++ 语法的代码如下：1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;int main() &#123; int n; std::cin &gt;&gt; n; int staff[55] = &#123; 0 &#125;, tmp; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; tmp; staff[tmp]++; &#125; for (int i = 0; i &lt; 52; i++) &#123; if (staff[i]) std::cout &lt;&lt; i &lt;&lt; ':' &lt;&lt; staff[i] &lt;&lt; std::endl; &#125; return 0;&#125;/*samples:in:810 2 0 5 7 2 5 2out:0:12:35:27:110:1in:1010 2 0 0 0 5 7 2 5 2out:0:32:35:27:110:1*/ 10-5 PAT Judge这道题目的出题背景应该就是 PAT 的排名系统了，但其实是甲级题库的一道排序题，需要按照题目的要求来进行排序，直接使用 C++ 的库函数会方便许多。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10000 + 5;struct user&#123; int id, scores[6], sum, perfect; bool flag;&#125; us[maxn];int n, k, m, p[6] = &#123;0&#125;;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void init() &#123; for(int i = 1; i &lt;= n; i++) &#123; us[i].id = i; us[i].sum = us[i].perfect = 0; us[i].flag = false; memset(us[i].scores, -1, sizeof(us[i].scores)); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); init(); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d", p + i); &#125; int id, proid, scoob; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d %d", &amp;id, &amp;proid, &amp;scoob); if(scoob != -1) us[id].flag = true; if(scoob == -1 &amp;&amp; us[id].scores[proid] == -1) us[id].scores[proid] = 0; if(scoob == p[proid] &amp;&amp; us[id].scores[proid] &lt; p[proid]) us[id].perfect++; if(scoob &gt; us[id].scores[proid]) us[id].scores[proid] = scoob; &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] &gt; 0) us[i].sum += us[i].scores[j]; &#125; &#125; sort(us + 1, us + n + 1, cmp); int rank = 1; for(int i = 1; i &lt;= n &amp;&amp; us[i].flag; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) rank = i; printf("%d %05d %d", rank, us[i].id, us[i].sum); for(int j = 1; j &lt;= k; j++) &#123; if(us[i].scores[j] == -1) printf(" -"); else printf(" %d", us[i].scores[j]); &#125; putchar('\n'); &#125; return 0;&#125; /*samples:in:7 4 2020 25 25 3000002 2 1200007 4 1700005 1 1900007 2 2500005 1 2000002 2 200005 1 1500001 1 1800004 3 2500002 2 2500005 3 2200006 4 -100001 2 1800002 1 2000004 1 1500002 4 1800001 3 400001 4 200005 2 -100004 2 0out:1 00002 63 20 25 - 182 00005 42 20 0 22 -2 00007 42 - 25 - 172 00001 42 18 18 4 25 00004 40 15 0 25 -in:3 4 920 25 25 3000001 3 3000002 3 3000003 3 3000001 3 3000002 3 2000003 3 2000001 3 3000002 3 1000003 3 30out:1 00001 30 - - 30 -1 00002 30 - - 30 -1 00003 30 - - 30 -in:2 2 620 2000001 1 -100002 1 -100001 1 -100002 1 -100001 1 -100002 1 0out:(blank)*/ 10-6 Sort with Swap(0, i)这个题不太好想，但是与表排序非常类似。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;using namespace std;const int maxn = 100000 + 5;int pos[maxn], n, ans = 0;int main() &#123; cin &gt;&gt; n; int remains = n - 1, tmp; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; tmp; pos[tmp] = i; if(tmp == i &amp;&amp; tmp != 0) remains--; &#125; int k = 1; while(remains &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; remains--; &#125; &#125; cout &lt;&lt; ans; return 0;&#125;/*samples:in:103 5 7 2 6 4 9 0 8 1out£º9in:54 0 2 1 3out:3in:30 2 1out:2in:54 3 2 1 0out:4*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_09_排序（上）]]></title>
    <url>%2F2020%2F09%2F02%2FZJU-DS-09-%E6%8E%92%E5%BA%8F%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周将会介绍几种常见的排序算法。 简单排序简单排序是几个简单的排序算法的统称，下面来一一介绍。 冒泡排序冒泡排序的思想比较直观，每次循环时，会将数组（或链表）内相邻的两个元素进行比较，按照规定的递增（或递减）顺序向后移动，一直到重复到末尾，基本代码如下：123456789void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); &#125; &#125; &#125;&#125; 代码框架十分简单，但是这样会有一个问题，那就是待排序列在已经有序的情况下，依然会进行两次循环，尽管不会交换相邻元素的值，但是还是会进行判断，会白白浪费时间。仔细想一下，如果输入序列是有序的，那么元素的值一次也不会交换，根据这个特点，可以对上述的代码进行一点小优化，添加一个标志位，一次有序后就可以直接跳出循环了。具体代码如下：123456789101112void Bubble_Sort(ElementType A[], int N) &#123; for(P=N-1; P&gt;=0; P--) &#123; flag = 0; for(i=0; i&lt;P; i++) &#123; if(A[i] &gt; A[i+1]) &#123; Swap(A[i], A[i+1]); flag = 1; &#125; &#125; if(!flag) break; &#125;&#125; 按照上述代码的思路，可以较为清晰的分析出冒泡排序算法的时间复杂度： 最好的情况，序列为顺序序列，$T = O(N)$ 最坏的情况，序列为逆序序列，$T = O(N^2)$ 另外，对于冒泡排序而言，每一次冒泡结束（内层循环结束一轮）后都会有一个元素被放到这个序列有序后的最终位置上，而且，冒泡排序也不会交换相同元素的位置（使用$&gt;$而不是$\geq$），所以冒泡排序是稳定的排序算法，再者，冒泡排序还有一个优点，即排序的方向是一定的，只会按照一个方向遍历存储数据的数据结构，这是其他排序算法无法达到的。 插入排序插入排序有个很形象的例子，就是打扑克牌时“理牌”的过程，不过可能有点差别。区别在于，理扑克牌时，手上是没有牌的，而需要理的牌在牌堆里面，也就是说，有两个空间可以放牌，但插入排序实际上只使用了一个内存空间，这样的话，每一次插入时就需要先找到插入的位置了。按照“理牌”的过程来描述就是：先摸一张牌，从后往前找到合适的插入位置，将比这张牌大的牌向后移（腾出位置），再将新牌插入到这个位置下即可。基本代码如下：123456789void Insertion_Sort(ElementType A[], int N) &#123; for(P=1; P&lt;N; p++) &#123; temp = A[P]; for(i=P; i&gt;0 &amp;&amp; A[i-1]&gt;temp; i--) &#123; A[i] = A[i-1]; &#125; A[i] = temp; &#125;&#125; 插入排序和冒泡排序的时间复杂度类似： 最好的情况，序列为顺序序列，$T = O(N)$ 最坏的情况，序列为逆序序列，$T = O(N^2)$ 同时，插入排序也是稳定的排序算法。 时间复杂度下界 对于下标$i &lt; j$，如果$A[i] &gt; A[j]$，则称$(i, j)$是一对逆序对（Inversion）如序列${2, 3, 1}$中，$(2, 1)$和$(3, 1)$分别是一对逆序对，逆序对的个数称为逆序数，这与线性代数中的概念是一致的。 在冒泡排序和插入排序中，每次交换位置的两个相邻元素正好消去 1 个逆序对，那么它们的时间复杂度就是：$T(N, I) = O(N+I)$，其中$I$是逆序对的对数。很明显，如果序列基本有序，则$I$值可忽略不计，时间复杂度仅为$T(N)$，此时算法既简单，又高效。 定理：对于任意N个不同元素组成的序列平均具有$N(N-1)/4$个逆序对。 由上面的定理，我们可以得出：任何仅以交换相邻两元素来排序的算法，其平均时间复杂度为$\Omega(N^2)$。这意味着，如果想要提高算法的效率，就得在每次交换元素时，不止消去 1 个逆序对，这就要求每次交换的两个元素要在序列中相隔的比较远。 希尔排序希尔排序的主要目的就是每次交换元素时，通过消去多个逆序对来达到提升算法效率。其主要思想：先定义增量序列$D_M &gt; D_{M-1} &gt; \dots &gt; D_1 = 1$，然后对每个$D_k$进行“$D_k$-间隔”排序（$k=M, M-1, \dots,1$），值得注意的是，后面进行的“间隔”排序不会影响前面“间隔”排序的有序性，也即“$D_k$-间隔”有序的序列，在执行“$D_{k-1}$-间隔”排序后，仍然是“$D_k$-间隔”有序的。原始希尔排序，增量依次减半，$D_M = \lfloor N/2 \rfloor, D_k = \lfloor D{k+1}/2 \rfloor$，此时最坏情况下的时间复杂度为$T = \Theta(N^2)$，基本代码如下：1234567891011void Shell_Sort(ElementType A[], int N) &#123; for(D=N/2; D&gt;0; D/=2) &#123; for(P=D; P&lt;N; P++) &#123; temp = A[P]; for(i=P; i&gt;=D &amp;&amp; A[i-D]&gt;temp; i-=D) &#123; A[i] = A[i-D]; &#125; A[i] = temp; &#125; &#125;&#125; 在最坏的情况（每次进行间隔排序的序列都是有序的）下，希尔排序会退化成插入排序，原因在于增量元素不互质，则小增量可能根本不起作用。为了解决这个问题，引入了更多的增量序列： Hibbard增量序列，$D_k = 2^k - 1$，这样保证了相邻增量元素互质，最坏情况下$T = \Omega(N^{3/2})$，猜想$T_{avg} = O(N^{5/4})$ Sedgewick增量序列，${1, 5, 19, 41, 109, \dots}$，也即增量序列的每一个元素是由$9 \times 4^i + 1$或$4^i - 3 \times 2^i + 1$计算得到，猜想$T_{avg} = O(N^{7/6}), T_{worst} = O(N^{4/3})$ 由于希尔排序每次对增量序列进行排序，相邻的相等元素属于不同增量序列，则希尔排序可能会改变相等且相邻元素的相对位置，属于不稳定的排序。 选择排序选择排序是一种简单直观的排序算法，基本工作原理是每一次从待排序的数据元素中选出最小（大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，重复此过程直到全部待排序的数据元素排完。 简单选择排序简单选择排序的思路很简单，与选择排序的基本思想一致，基本代码如下：12345678void Selection_Sort(ElementType A[], int N) &#123; for(i=0; i&lt;N; i++) &#123; //find the minimum from A[i] to A[n-1], and return to Position MinPosition = ScanForMin(A, i, N-1); //replace the minimum element to the last position of the ordered part Swap(A[i], A[MinPosition]); &#125;&#125; 简单选择排序的时间复杂度主要有两个影响条件，第一个是查找最小值，第二个是交换，所以它的时间复杂度无论怎样都是$T=\Theta(N^2)$。 堆排序分析了简单选择排序算法的时间复杂度后，发现简单选择排序的时间都耗费在了查找最小值上，如果能把这一操作变快，那么简单选择排序的效率就能提高。根据选择排序的特点，每次查找的值必须是最小（大）值，这与小（大）根堆的性质是一致的，那么使用堆来进行元素的查找，每次弹出最小（大）值，就可以提升排序效率。基本代码如下：123456789void Heap_Sort(ElementType A[], int N) &#123; BuildHeap(A); for(i=0; i&lt;N; i++) &#123; tempA[i] = DeleteMin[A]; &#125; for(i=0; i&lt;N; i++) &#123; A[i] = tempA[i]; &#125;&#125; 上述代码的过程比较简单，每次找出最小（大）元素后，保存在一个临时数组内，然后在将临时数组内的排序结果复制到原始数组中。这样即需要额外的空间（$O(N)$）去存储这部分数据，又要额外的时间去复制元素。那么如何去避免这部分开销呢？请看下面的代码： 123456789void Heap_Sort(ElementType A[], int N) &#123; for(i=N/2; i&gt;=0; i--) &#123; PercDown(A, i, N); //Build heap &#125; for(i=N-1; i&gt;0; i--) &#123; Swap(&amp;A[0], &amp;A[i]); //delete max PercDown(A, 0, i); &#125;&#125; 按照上述代码，建立一个大根堆，排序开始后，交换大根堆最大元素与最末尾元素的值，完成后，将这个最大值剔除出堆，紧接着再调整为大根堆，重复执行上述操作。 定理：堆排序处理N个不同元素的随机排列的平均比较次数是$2NlogN - O(N log logN)$ 虽然堆排序给出最佳平均时间复杂度，但实际效果不如用Sedgewick增量序列的希尔排序。 归并排序归并排序的核心就是有序子列的归并，首先，申请空间，保存合并后的有序序列，设定两个指针，最初位置分别为两个有序序列的起始位置，比较两个指针指向的元素，选择相对小的元素放到申请的空间内，并移动指针到下一位置，重复直至某一个子序列超出序列尾，接着将另一序列剩下的所有元素直接复制到申请空间的尾部。合并两个有序子列的基本代码如下：12345678910111213141516void Merge(ElementType A[], ElementType TempA[], int L, int R, int RightEnd) &#123; LeftEnd = R-1; //Suppose two subsequences are side-by-side Tmp = L; //initial position NumElements = RightEnd - L + 1; while(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd) &#123; if(A[L] &lt;= A[R]) TempA[Tmp++] = A[L++]; else TempA[Tmp++] = A[R++]; &#125; // copy the rest straightly while(L &lt;= LeftEnd) TempA[Tmp++] = A[L++]; while(R &lt;= RightEnd) TempA[Tmp++] = A[R++]; //copy the result to A[] from right to left for(i=0; i&lt;NumElements; i++, RightEnd--) &#123; A[RightEnd] = TempA[RightEnd] &#125;&#125; 归并算法在实现的时候有两种不同的策略，下面先介绍递归。 递归归并排序的递归算法的思想是基于分治法的，先将分开的子序列排好，在合并成一个大的序列。基本代码如下：123456789void MSort(ElementType A[], ElementType TempA[], int L, int RightEnd) &#123; int Center; if(L &lt; RightEnd) &#123; Center = (L + RightEnd)/2; MSort(A, TempA, L, Center); MSort(A, TempA, Center+1, RightEnd); Merge(A, TempA, L, Center+1, RightEnd); &#125;&#125; 基于分治法的归并排序递归算法的时间复杂度为$T(NlogN)$，推导过程如下：$$\begin{align} T(N)&amp; = 2 T(N/2)) + cN \\&amp; = 2\ (2T(N/2^2) + c N/2) + cN \\&amp; = \dots = 2^k * O(1) + ckN \\&amp; = O(NlogN)\end{align}$$可得$T(N) = O(NlogN)$，这个时间复杂度是很“强”的😆，也即是说在任何情况下（无论好坏）都是$NlogN$，另外，归并排序是稳定的排序算法。为了使它与上述其他排序算法的函数接口统一，再整理下代码：12345678void Merge_Sort_Recursion(ElementType A[], int N) &#123; ElementType *TempA; TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; MSort(A, TempA, 0, N-1); free(TempA); &#125; else Error("Insufficient Space.");&#125; 注意在上面的代码中，临时传递使用的数组是声明在Merge_Sort函数中的，这样做的好处就是避免了在MSort中重复声明和重复释放内存操作。 非递归归并排序的非递归算法基本思想依然是分治法的思想，每次循环先归并相邻的两个子列，子列长度逐渐增加，直至最后左右两个子列之和大于序列总长度。基本代码如下：123456789101112131415161718192021222324252627282930void Merge_Sort_Non_Recursion(ElementType A[], int N) &#123; int length; ElementType *TempA; length = 1; //initialize the length of subsequence TempA = malloc(N*sizeof(ElementType)); if(TempA != NULL) &#123; while(length &lt; N) &#123; Merge_pass(A, TempA, N, length); //left length *= 2; Merge_pass(TempA, A, N, length); //right length *= 2; &#125; &#125; else printf("Insufficient Space.\n");&#125;/*Merge adjacent ordered subsequence in pairs accroding to the current length of subsequence*/void Merge_pass(ElementType A[], ElementType TempA[], int N, int length) &#123; int i, j; for(i=0; i&lt;=N-2*length; i+=length) &#123; Merge(A, TempA, i, i+length, i+2*length-1); &#125; if(i+length &lt; N) &#123; //Merge the last two subsequence Merge(A, TempA, i, i+length, N-1); &#125; else &#123; //only one subsequence last for(j=i; j&lt;N; j++) TempA[j] = A[j]; &#125;&#125; 注意上述代码中的细节，Merge_pass是一个按照序列长度进行一次归并的函数，当序列长度发生变化的时候，将再次调用此函数，另外，在此函数内，for循环内归并的序列是前N/length - 1对，而不是N/length对，如果N是奇数，最后一个子列就被单独出来了，它与其他子列的长度不等，所以针对最后一个子列的处理，要与前面区分开来。再者，上述代码中length增长的倍数是2，理论上即是二路归并。 小结归并排序算法的优点很明显，那就是在任何情况（无论好坏）下，其时间复杂度都是$T(NlogN)$，同时，它还是稳定的排序算法，但是它有一个很明显的缺点，就是需要占用$O(N)$大小的空间，并且在内存内要频繁的进行倒换操作，所以，一般内部排序中不会使用归并排序，外部排序会使用归并排序。 Homework09-1 排序这个题专门用来检测自己实现的排序算法，最好把老师讲了的都实现一下。 冒泡排序123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void bubble_sort(int *array, int n) &#123; for(int i = n - 1; i &gt; 0; i--) &#123; bool flag = true; for(int j = 0; j &lt; i; j++) &#123; if(array[j] &gt; array[j + 1])&#123; swap(&amp;array[j], &amp;array[j + 1]); flag = false; &#125; &#125; if(flag) break; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; bubble_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; ### 插入排序123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 希尔排序123456789101112131415161718192021222324#include &lt;stdio.h&gt;#define maxn 100005int array[maxn], n;void insertion_sort(int *array, int n) &#123; for(int i = 1; i &lt; n; i++) &#123; int tmp = array[i], j; for(j = i; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp; &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; insertion_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxn 100005int array[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; for(int i = n - 1; i &gt; 0; i--) &#123; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; heap_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 归并排序非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; merge_pass(tmparr, array, n, length); length *= 2; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 递归12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 100005int array[maxn], n;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void msort(int *array, int *tmparr, int left, int rightend) &#123; int center; if(left &lt; rightend) &#123; center = (left + rightend) / 2; msort(array, tmparr, left, center); msort(array, tmparr, center + 1, rightend); merge(array, tmparr, left, center + 1, rightend); &#125;&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; msort(array, tmparr, 0, n - 1); free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", array + i); &#125; merge_sort(array, n); for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 09-2 Insert or Merge这个题形式简单，但是要想得满分，必须得对插入排序跟归并排序都很了解才行。 题目要求输出两样东西： 判断属于那一种排序 然后输出再进行下一次这种排序后所得的序列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void merge(int *array, int *tmparr, int left, int right, int rightend) &#123; int leftend = right - 1, tmp = left; int numofelements = rightend - left + 1; while(left &lt;= leftend &amp;&amp; right &lt;= rightend) &#123; if(array[left] &lt; array[right]) tmparr[tmp++] = array[left++]; else tmparr[tmp++] = array[right++]; &#125; while(left &lt;= leftend) tmparr[tmp++] = array[left++]; while(right &lt;= rightend) tmparr[tmp++] = array[right++]; for(int i = 0; i &lt; numofelements; i++, rightend--) &#123; array[rightend] = tmparr[rightend]; &#125;&#125;void merge_pass(int *array, int *tmparr, int n, int length) &#123; int i, j; for(i = 0; i &lt;= n - 2 * length; i += (2 * length)) &#123; merge(array, tmparr, i, i + length, i + 2 * length - 1); &#125; if(i + length &lt; n) merge(array, tmparr, i, i + length, n - 1); else for(j = i; j &lt; n; j++) tmparr[j] = array[j];&#125;void merge_sort(int *array, int n) &#123; int *tmparr; tmparr = (int*)malloc(n * sizeof(int)); if(tmparr != NULL) &#123; int length = 1; while(length &lt; n) &#123; merge_pass(array, tmparr, n, length); length *= 2; if(issame(tmparr)) &#123; merge_pass(tmparr, array, n, length); printarray(array, n); break; &#125; merge_pass(tmparr, array, n, length); length *= 2; if(issame(array)) &#123; merge_pass(array, tmparr, n, length); printarray(tmparr, n); break; &#125; &#125; free(tmparr); &#125; else return;&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Merge Sort\n"); merge_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 0 61 3 2 8 5 7 4 9 0 6out:Merge Sort1 2 3 8 4 5 7 9 0 6*/ 09-3 Insertion or Heap Sort这个题与上题类型一致，只不过把归并排序换成了堆排序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 105int tar[maxn], arr[maxn], tmparr[maxn], n;void swap(int *p1, int *p2) &#123; int t = *p1; *p1 = *p2; *p2 = t;&#125;bool issame(int *a) &#123; for(int i = 0; i &lt; n; i++) &#123; if(a[i] != tar[i]) return false; &#125; return true;&#125;void printarray(const int *array, int size) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", array[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;void insert_pass(int *array, int pos) &#123; int tmp = array[pos], j; for(j = pos; j &gt; 0 &amp;&amp; tmp &lt; array[j - 1]; j--) &#123; array[j] = array[j - 1]; &#125; array[j] = tmp;&#125;bool isinsert(int *array, int n, int *round) &#123; for(int i = 1; i &lt; n; i++) &#123; insert_pass(array, i); if(issame(array)) &#123; *round = i + 1; return true; &#125; &#125; return false;&#125;void Percolatedown(int *heap, int pos, int size) &#123; int parent, child, tmp = heap[pos]; for(parent = pos; parent * 2 + 1 &lt;= size - 1; parent = child) &#123; child = parent * 2 + 1; if(child != size - 1 &amp;&amp; heap[child] &lt; heap[child + 1]) child++; if(tmp &gt;= heap[child]) break; else heap[parent] = heap[child]; &#125; heap[parent] = tmp;&#125;void heap_sort(int *array, int n) &#123; for(int i = n / 2 - 1; i &gt;= 0; i--) &#123; Percolatedown(array, i, n); &#125; int i; for(i = n - 1; i &gt; 0; i--) &#123; if(issame(array)) break; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); &#125; swap(&amp;array[0], &amp;array[i]); Percolatedown(array, 0, i); printarray(array, n);&#125;int main() &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;arr[i]); tmparr[i] = arr[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;tar[i]); &#125; int round = 0; if(isinsert(tmparr, n, &amp;round)) &#123; printf("Insertion Sort\n"); insert_pass(tmparr, round); printarray(tmparr, n); &#125; else &#123; for(int i = 0; i &lt; n; i++) tmparr[i] = arr[i]; printf("Heap Sort\n"); heap_sort(tmparr, n); &#125; return 0;&#125;/*samples:in:103 1 2 8 7 5 9 4 6 01 2 3 7 8 5 9 4 6 0out:Insertion Sort1 2 3 5 7 8 9 4 6 0in:103 1 2 8 7 5 9 4 6 06 4 5 1 0 3 2 7 8 9out:Heap Sort5 4 3 1 0 2 6 7 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_08-图（下）]]></title>
    <url>%2F2020%2F08%2F31%2FZJU-DS-08-%E5%9B%BE%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这周课程主要介绍了图的另外两个应用：最小生成树和拓扑排序，顺带讲了一下关键路径 最小生成树什么是最小生成树（Minimum Spaning Tree）？它首先是一棵树，所以它没有回路，且 V 个顶点的最小生成树一定有 V-1 条边（这就是树的性值）。既然是生成树，所以这棵树包含了图中所有顶点，树中的 V-1 条边一定也都在图内；那最小是什么？最小的含义是指边的权重和最小。这里要注意，如果图是连通的，那么这个图一定存在最小生成树且不一定唯一。 下面介绍的两种生成最小生成树的算法本质思想都是基于“贪心”，这与前面的 Dijkstra 算法是一致的。所谓“贪心”，即是指每一步都要“最好”的，在最小生成树中，权重最小的边也就是“最好”的了。 Prim 算法Prim 算法的大致过程从一个顶点开始，慢慢的生长成一棵树，先看下它的伪码描述：12345678910111213141516171819void Prim() &#123; MST = &#123;S&#125;; while(1) &#123; V = 未收录顶点中 dist 最小者; if(V 不存在) break; 将 V 收录进 MST; dist[V] = 0; for(V 的每个邻接点 W) &#123; if(dist[W] != 0) &#123; if( 边权(V,W) &lt; dist[W]) &#123; dist[W] = 0; parent[W] = V; &#125; &#125; &#125; &#125; if(MST 中收录的顶点不到 |Ｖ| 个) Error("生成树不存在");&#125; Prim 算法与 Dijkstra 算法十分类似，就是循环内的判断条件不一样，其他基本一致。以下图为例，手动模拟一下 Prim 算法的运行过程。dist 数组用来筛选边权最小的顶点；parent 数组来保存树，且 parent 数组需要初始化为 -1，这里与并查集的思路是类似的。 以$v_1$为源点，dist 数组初始化： index 1 2 3 4 5 6 7 dist 0 ∞ ∞ ∞ ∞ ∞ ∞ parent -1 -1 -1 -1 -1 -1 -1 直接将 dist[1] 初始化为 0，然后$v_1$作为未收录顶点中 dist 最小者，将其收录进 MST，再访问其每个邻接点，此时可以将 dist 数组的值更新： index 1 2 3 4 5 6 7 dist 0 2 4 1 ∞ ∞ ∞ parent -1 1 1 1 -1 -1 -1 接着，未收录顶点中 dist 最小者就是$v_4$，收录进 MST，此时 dist 和 parent 数组更新： index 1 2 3 4 5 6 7 dist 0 2 2 0 7 7 4 parent -1 1 4 1 4 4 4 可以看到，因为$(v_4, v_3) &lt; (v_1, v_3)$，所以 dist[3] 与 parent[3] 的值将会得到更新。 再来，未收录顶点中 dist 最小者就是$v_2$，收录进 MST，此时 dist 和 parent 数组更新： index 1 2 3 4 5 6 7 dist 0 0 2 0 7 8 4 parent -1 1 4 1 4 4 4 依次类推，收录$v_3$，有： index 1 2 3 4 5 6 7 dist 0 0 0 0 7 5 4 parent -1 1 4 1 4 3 4 收录$v_7$，有： index 1 2 3 4 5 6 7 dist 0 0 0 0 6 1 0 parent -1 1 4 1 7 7 4 最后再分别选取$v_6$和$v_5$后，MST 中收录的顶点达到 |V| 个后就得到了最小生成树。通过上面也可以看出，Prim 中的 dist 数组的用途与 Djikstra 算法中 dist 数组的用途是完全一致的，只是两者的判断条件不一样而已。另外，Prim 算法的时间复杂度也就是$O(|V|^3)$。 Kruskal 算法Kruskal 算法的大致过程是在“选边”，也就是将森林合并成树，其伪码描述为：123456789101112131415void Kruskal(Graph G) &#123; MST = &#123;&#125;; while(MST 中找不到 |V|-1 条边 &amp;&amp; E 中还有边) &#123; 从 E 中取一条权重最小的边 E(v, w); //使用最小堆实现 将取出的最小边 E(v, w)从 E 中删除; if(E(v, w) 不在 MST 中构成回路) &#123; //使用并查集实现 将 E(v, w)加入 MST; &#125; else &#123; 彻底无视 E(v, w); &#125; &#125; if(MST 中找不到 |V|-1 条边) &#123; Error("生成树不存在"); &#125;&#125; 以下图为例，手动模拟一下 Kruskal 算法的运行过程。 依次加入边$(v_1, v_4)$、$(v_6, v_7)$、$(v_1, v_2)$、$(v_3, v_4)$、$(v_4, v_7)$、$(v_5, v_7)$即可，整个过程讲起来比 Prim 算法简单了不少，但是实现起来就稍微复杂一点，既要用到最小堆，又要用到并查集，但其时间复杂度也稍微优秀一点（相比 Prim），为：$O(|E|Log|E|)$。另外，笔试题中，Kruskal 算法解题速度是第一名，谁用谁知道。 拓扑排序拓扑排序不同于普通排序，普通排序就是按照某一规则对具有同类性质的元素进行升序或降序排序；而拓扑排序是针对有向无环图（Directed Acyclic Graph，DAG）G 进行的，是将图 G 中所有顶点排成一个线性序列，使得图中任意一对顶点 u 和 v，若边 $&lt;u, v&gt;$是图 G 的边（也即存在一条 u 到 v 的有向路径），则 u 在线性序列中一定出现在 v 之前，这样的序列叫做拓扑序列，而这个得到这个序列的过程就叫做拓扑排序。 而姥姥讲的 AOV 网，具体定以请点击链接参考下百度百科。另外，对于一个 AOV 网而言，如果有合理的拓扑序，则其必定是有向无环图。换句话说，也就是说拓扑排序可以用来检测图内是否有环，这也是笔试题中常用的知识点。 拓扑排序的伪码算法如下：12345678910111213141516171819void TopSort() &#123; for(图中每个顶点 V) &#123; if(Indegree[V] == 0) &#123; Enqueue(V, Q); &#125; &#125; while(!IsEmpty(Q)) &#123; V = Dequeue(Q); 输出V，或者记录 V 的输出序号; cnt++; for(V 的每个邻接点 W) &#123; if(--Indegree[W] == 0) &#123; Enqueue(W, Q); &#125; &#125; &#125; if(cnt != |V|) &#123; Error("图中有回路"); &#125;&#125; 关键路径关键路径问题是针对 AOE（Activity On Edge）网络而言的，属于拓扑排序的应用，一般用于安排项目的工序问题，图中的边代表工序，工序与工序之间有先后关系。也可以理解为边代表活动，顶点表示这个活动的结束，按照姥姥 PPT 中的介绍来理解即可，如下图所示： 接着跟着姥姥的 PPT 一起手动计算关键路径，可以得到下图的结果。 在上面的问题中，注意对那条“虚边”的理解，之所以会有这条虚边，其实是因为要想到达顶点 7，必须要先到达顶点 4 和 5。可能有人会问为什么是从 5 指向 4，很简单，因为 4 后到达，5 会先到达，如果 5 后到达，4 先到达，那就是 4 指向 5 了。 另外需要注意的就是机动时间的计算，还是要先理解机动时间的概念。机动时间这个东西，实际上就是可以偷懒的时间，后完成的人不能偷懒，但先完成的人就可以偷懒了。以顶点 5 为例，它的机动时间就是：$D_{&lt;5, 7&gt;} = Latest[7] - Earliest[i] - C_{&lt;5, 7&gt;} = 14 - 7 - 4 = 3$。会算这些东西后，就可以找出关键路径了，值得注意的是对一个 AOE 网而言，关键路径不一定是唯一的，这个从上图就可以看出。 Homework08-7 公路村村通很直观的最小生成树问题，一遍 Prim 算法就搞定了，如果不连通就输出 -1，反之就输出最小生成树的边权之和，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt; #define maxn 1005const int inf = 0x3fffffff;int nv, ne, G[maxn][maxn], dist[maxn];bool visited[maxn] = &#123; false &#125;;void init() &#123; for (int i = 0; i &lt; maxn; i++) &#123; for (int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void prim() &#123; for (int i = 0; i &lt; maxn; i++) dist[i] = inf; dist[1] = 0; int times = 0, totalweight = 0; while(1) &#123; int mindis = inf, v = -1; for (int i = 1; i &lt;= nv; i++) &#123; if (!visited[i] &amp;&amp; dist[i] &lt; mindis) &#123; mindis = dist[i]; v = i; &#125; &#125; if (v == -1) break; times++; visited[v] = true; totalweight += dist[v]; for (int w = 1; w &lt;= nv; w++) &#123; if (G[v][w] != inf &amp;&amp; !visited[w] &amp;&amp; G[v][w] &lt; dist[w]) &#123; dist[w] = G[v][w]; &#125; &#125; &#125; if (times == nv) printf("%d", totalweight); else printf("-1");&#125;int main() &#123; scanf("%d %d", &amp;nv, &amp;ne); init(); int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; scanf("%d %d %d", &amp;v1, &amp;v2, &amp;weight); G[v1][v2] = G[v2][v1] = weight; &#125; prim(); return 0;&#125;/*samples:in:6 151 2 51 3 31 4 71 5 41 6 22 3 42 4 62 5 22 6 63 4 63 5 13 6 14 5 104 6 85 6 3out:12*/ 08-8 How Long Does It Take这道题虽然是英文的，但是题意很直观，就是直接求关键路径的最早完成时间，但实际上并没有要求也要输出关键路径，减少了点麻烦吧。解决这个问题的思路就是利用先拓扑排序，得到一个拓扑序列，然后通过这个拓扑序列来关键路径的最早完成时间。我们使用 STL 来偷下懒，将 Vector 当作邻接表来存储图，利用 Vector 内的成员函数 emplace_back（C++11 的新特性）来输入顶点和对应的边权要方便一些，但要这样用得先写好 node 的构造函数。在进行拓扑排序时，可以顺便将最早完成时间也一并计算出来。为了避免图可能不是连通的，也就是说此时是无解的，需要设置一个计数器来记录所得到的拓扑序列的顶点个数，如果与图的顶点总数不相等，那也就是说图是不连通的。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node&#123; int w, weight; node(int w, int weight) &#123; this-&gt;w = w; this-&gt;weight = weight; &#125;&#125;;vector&lt;node&gt; G[maxn];int nv, ne, indegree[maxn] = &#123; 0 &#125;, cost[maxn];void topsort() &#123; queue&lt;int&gt; q; for (int v = 0; v &lt; nv; v++) &#123; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]++; &#125; &#125; for (int i = 0; i &lt; maxn; i++) cost[i] = -1; int count = 0; for (int i = 0; i &lt; nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); cost[i] = 0; &#125; &#125; while (!q.empty()) &#123; int v = q.front(); q.pop(); count++; for (int w = 0; w &lt; G[v].size(); w++) &#123; indegree[G[v][w].w]--; if (cost[G[v][w].w] &lt; cost[v] + G[v][w].weight) &#123; cost[G[v][w].w] = cost[v] + G[v][w].weight; &#125; if (indegree[G[v][w].w] == 0) &#123; q.push(G[v][w].w); &#125; &#125; &#125; if (count != nv) cout &lt;&lt; "Impossible"; else &#123; int max = cost[0]; for (int i = 1; i &lt; nv; i++) &#123; if (max &lt; cost[i]) max = cost[i]; &#125; cout &lt;&lt; max; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int v1, v2, weight; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; weight; G[v1].emplace_back(v2, weight); &#125; topsort(); return 0;&#125;/*samples:in:9 120 1 60 2 40 3 51 4 12 4 13 5 25 4 04 6 94 7 75 7 46 8 27 8 4out:18in:4 50 1 10 2 22 1 31 3 43 2 5out:Impossiblein:7 60 3 23 4 21 2 32 4 24 5 34 6 2out:8*/ 08-9 关键活动这道题没啥说的，就是关键路径的问题。相比上道题，这道题要麻烦一些，因为这个题不仅要输出最早完成时间，还得输出关键路径，多亏了 STL 省了很多麻烦。求最早完成时间的思路与上面那题是一样的，直接一个拓扑排序就完事了。难点在于如何找关键路径，不能简单的直接拿拓扑序列来反向输出，那怎么办呢？仔细回忆一下课上的例子，可以发现关键路径的关键活动没有空余时间，假如 e 是活动的最早完成时间，l 是活动的最晚开始时间，那么关键活动的 e 与 l 是相等。按照这样的思路，将拓扑序列中的所有的关键活动的 e 和 l 求出，并进行比较，如果相等，就是关键活动了，当然了，前提是拓扑序列是存在的。但是别忘记了，题目要求从小到大输出关键活动，所以还需要对找出的序列进行排序，然后再输出。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;struct node &#123; int v, w; node(int v, int w) &#123; this-&gt;v = v; this-&gt;w = w; &#125;&#125;;bool cmp(int a, int b) &#123; return b - a;&#125;vector&lt;node&gt; G[maxn];stack&lt;int&gt; topo;int nv, ne, ve[maxn] = &#123; 0 &#125;, vl[maxn], indegree[maxn] = &#123; 0 &#125;;bool topoorder() &#123; queue&lt;int&gt; q; for (int i = 1; i &lt;= nv; i++) &#123; for (int j = 0; j &lt; G[i].size(); j++) &#123; indegree[G[i][j].v]++; &#125; &#125; for (int i = 1; i &lt;= nv; i++) &#123; if (indegree[i] == 0) &#123; q.push(i); ve[i] = 0; &#125; &#125; while (!q.empty()) &#123; int u = q.front(); topo.push(u); q.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; indegree[G[u][i].v]--; if (ve[G[u][i].v] &lt; ve[u] + G[u][i].w) &#123; ve[G[u][i].v] = ve[u] + G[u][i].w; &#125; if (indegree[G[u][i].v] == 0) q.push(G[u][i].v); &#125; &#125; if (topo.size() != nv) return false; else return true;&#125;void criticalpath() &#123; int max = ve[1], maxid = 1; for (int i = 2; i &lt;= nv; i++) &#123; if (ve[i] &gt; max) &#123; max = ve[i]; maxid = i; &#125; &#125; cout &lt;&lt; max &lt;&lt; endl; for (int i = 0; i &lt; maxn; i++) vl[i] = max; while (!topo.empty()) &#123; int u = topo.top(); topo.pop(); for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v; if (vl[v] - G[u][i].w &lt; vl[u]) &#123; vl[u] = vl[v] - G[u][i].w; &#125; &#125; &#125; vector&lt;int&gt; keyact[maxn]; for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; G[u].size(); i++) &#123; int v = G[u][i].v, w = G[u][i].w; int e = ve[u], l = vl[v] - w; if (e == l) keyact[u].push_back(v); &#125; &#125; for (int i = 1; i &lt;= nv; i++) sort(keyact[i].begin(), keyact[i].end(), cmp); for (int u = 1; u &lt;= nv; u++) &#123; for (int i = 0; i &lt; keyact[u].size(); i++) &#123; cout &lt;&lt; u &lt;&lt; "-&gt;" &lt;&lt; keyact[u][i] &lt;&lt; endl; &#125; &#125;&#125;int main() &#123; cin &gt;&gt; nv &gt;&gt; ne; int u, v, w; for (int i = 0; i &lt; ne; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w; G[u].emplace_back(v, w); &#125; if (!topoorder()) cout &lt;&lt; 0; else criticalpath(); return 0;&#125;/*samples:in:7 81 2 41 3 32 4 53 4 34 5 14 6 65 7 56 7 2out:171-&gt;22-&gt;44-&gt;66-&gt;7in:4 41 2 21 3 22 4 23 4 2out:41-&gt;31-&gt;22-&gt;43-&gt;4in:3 31 2 12 3 13 1 1out:0in:3 31 2 11 3 12 3 1out:21-&gt;22-&gt;3*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prologue（プロローグ - 押尾コータロー）- 翻弹]]></title>
    <url>%2F2020%2F08%2F29%2FPrologue%EF%BC%88%E3%83%97%E3%83%AD%E3%83%AD%E3%83%BC%E3%82%B0%20-%20%E6%8A%BC%E5%B0%BE%E3%82%B3%E3%83%BC%E3%82%BF%E3%83%AD%E3%83%BC%EF%BC%89-%20%E7%BF%BB%E5%BC%B9%2F</url>
    <content type="text"><![CDATA[Prologue（プロローグ - 押尾コータロー）是押尾于 2003 年发行的专辑《Dramatic》中的一首较为简单的指弹曲子。 谱子一共就两页，不长，但是编的真好，想要完整的弹下来还得费一番功夫。先看下原版谱子第 1 面（扫描件，画质略差见谅）： 谱子五线谱的左上角写着 Tuning = Standard，说明这是首标准调弦的曲子；五线谱的开头有一个高音谱号和一个“#”号表示这首曲子是 G 大调的；边上的$\frac{6}{8}$，表示这首曲子的节拍是八六拍；谱号上还有一个带方框的缩写的英文单词 Intro，表示前两小节是这首曲子的引子（就像某些小说开头的引子一样）；紧接着边上的 G 表示这俩小节的和弦走向是 G；还有后面带方框的英文分别代表这首曲子的 A 段、B 段、C 段等。 建议只看六线谱的也不要忽略上面的内容。 A 段需要注意的地方： 第二小节五线谱上的数字代表了左手的指法，但实际上你可以按照自己熟练的方式来演奏；另外，S 标记代表从 2 弦 3 品用滑音演奏法滑到 10 品，为了达到跟原曲的效果，滑到 10 品后，需要在弹一次 2 弦 10 品第四小节右手中指与无名指需要同时弹响 1、2弦，用滑音听起来会更棒第五小节左手中指与小指需要首先同时按住 6 弦 8 品和 3 弦 9 品第六小节左手食指需要横按，但食指横按的音可以“弱处理” 接下来就到 B 段了，个人感觉 B 段简单一些，后面几个小节在谱子的第二面： B 段需要注意的地方： 第七小节 1 弦的处理方式可以与 A 段第二小节类似第八小节食指小横按 1-4 弦 5 品 接着是 C 段需要注意的地方： 第二小节需要左手有一定的“力量”才能按好整个 C 段有多处需要用琶音技巧，才能更好的表达曲子情感的变化C 段属于结尾段，包括两个结尾部分，谱子上有标记 1 和 2，注意区分 原曲： 渣翻（还在酝酿之中）：]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>FingerStyle</tag>
        <tag>Guitar</tag>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_07-图（中）]]></title>
    <url>%2F2020%2F08%2F28%2FZJU-DS-07-%E5%9B%BE%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本周课程主要包括图论中最短路径的问题和有关树的习题课，习题课笔记添加到前面对应题目的所在的文章中了。 最短路径问题的抽象一般而言，最短路径问题都可抽象为：在网络中，求两个不同顶点之间的所有路径中，边的权值之和最小的那一条路径，从而，有： 这条路径就是两点之间的最短路径（Shortest Path） 第一个顶点为源点（Source） 最后一个顶点为终点（Destination） 按照这样的思路，最短路径问题又可以分别两类： 单源最短路径问题：从某固定源点出发，求其到所有其他顶点的最短路径，根据图的类型不同又可以分为： （有向）无权图 （有向）有权图 多源最短路径问题：求任意两顶点间的最短路径 无权图的单源最短路径算法考虑这类问题时，有一个原则，即：按照递增（非递减）的顺序找出各个顶点的最短路。以下图中的“图”为例： 无权图的单源最短路径问题本质上就是 BFS，假设源点为$v_3$，按照 BFS 的思路，通过$v_3$可以直接访问$v_1$和$v_2$，这算是与$v_3$的距离为 1 所能访问的顶点，依次类推，与$V_3$距离为 2 所能访问的顶点就是$v_2$和$v_4$，与$v_3$距离为 3 所能访问的顶点就是$v_5$和$v_7$。 接着在按照 BFS 算法写出其伪码算法：12345678910111213void Unweighted(Vertex S) &#123; Enqueue(S, Q); while(!IsEmpty(Q)) &#123; V = Dequeue(Q); for(V 的每个邻接点 W) &#123; if(dist[W] == -1) &#123; dist[W] = dist[V] + 1; path[W] = V; Enqueue(W, Q); &#125; &#125; &#125;&#125; 与 BFS 算法不同的是，这里用 dist 数组来保存源点到各个顶点的距离，用 path 数组保存了源点到各个顶点的路径。这里多说一句，若想知道路径的距离是多少直接访问 dist 数组即可；若要知道路径是什么，递归输出 path 数组即可（非递归输出的顺序是逆过来的）。 有权图的单源最短路径有权图的最短路径与无权图的最短路径最显著的区别就是，有权图的最短路径不一定是进过顶点最少的路径，而无权图的最短路径则一定是经过顶点最少的路径。以下图为例，$v_1 -&gt; v_4 -&gt; v_6$与$v_1 -&gt; v_4 -&gt; v_7 -&gt; v_6$相比，第二条路径要更短一点。同样，当图内存在负权值的边时，就可能产生负值圈（Negative-cost cycle），如下图：此时单源最短路径的算法是无法得到正确结果的，这里不深入讨论这类问题。 回过头来，有权图的单源最短路径算法与无权图的单源最短路算法有一个共同点，那就是二者皆是按照递增的顺序找出到各个顶点的最短路径，而有权图的单源最短路径算法也叫Dijkstra算法。 Dijkstra 算法Dijkstra 算法是典型的贪心算法，直接描述其过程有点麻烦，先看下面的伪码算法描述：123456789101112131415void Dijkstra(Vertex S) &#123; while(1) &#123; v = 未收录顶点中 dist 最小者; if(这样的 v 不存在) break; collected[v] = true; for(v 的每个邻接点 w)&#123; if(collected[w] == false) &#123; if(dist[v] + &lt;v, w&gt;的权值 &lt; dist[w]) &#123; dist[w] = dist[v] + &lt;v, w&gt;的权值; path[w] = v; &#125; &#125; &#125; &#125;&#125; 需要注意的地方： 不能解决有负边的情况 总是按照顶点序号递增（非递减）的顺序来开始算法 每次收录一个顶点 w 后要更新从 v 到 w 的最短路径的权值和 每次收录一个顶点 w 后可能会影响 v 到其他顶点的最短路径，所以要对 v 的邻接点进行访问 如何从未收录顶点中找出 dist 最小者是影响此算法时间复杂度的关键，根据方法的不同，有两种情况： 直接扫描所有未收录顶点，每次在找出所有顶点中 dist 最小的顶点，然后再访问当前这个顶点的所有邻接点，时间复杂度为：$O(|V^2| + |E|)$，这种方法适合稠密图 如果是将 dist 存在最小堆中，那么找出所有顶点中 dist 最小的顶点所耗费的时间就是$O(log|V|)$，但是最后还得将这个值插入到堆中，且对于一个连通的图而言，边数肯定大于等于顶点数，所以其时间复杂度为：$T = O(|V|log|V| + |E|log|V|) = O(|E|log|V|)$，这种方法适合稀疏图 下面再以下图中的图为例，手动模拟一遍算法。 首先，dist 和 path 数组都要先初始化： index 1 2 3 4 5 6 7 dist ∞ ∞ ∞ ∞ ∞ ∞ ∞ path -1 -1 -1 -1 -1 -1 -1 注意上面下标是从 1 开始的，与顶点下标对应免得搞混，当然从 0 开始也是没有问题的，但后面分析问题时可能搞混淆。 接着从 $v_1$ 开始，在访问$v_1$的邻接点之前，需要先将 dist[1] 的值修改为 0，因为其自身到自身的距离是 0，然后访问$v_1$的邻接点，并更新这些邻接点对应的 dist 和 path 数组的值（$v_1$的邻接点只有$v_2$和$v_4$），此时 dist 与 path数组的值为： index 1 2 3 4 5 6 7 dist 0 2 ∞ 1 ∞ ∞ ∞ path -1 1 -1 1 -1 -1 -1 此时又回到循环体的开头部分，找出 dist 中最小的且未被访问过的，显然是$v_4$，然后利用$v_4$来更新 dist 和 path 数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 再继续下一轮循环，此时选出的顶点就是$v_2$，在更新 dist 和 path 数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 9 5 path -1 1 4 1 4 4 4 上面表格中的值与第二次循环没有变化，原因在于通过$v_2$并不能使$v_1$到达$v_4$和$v_5$的距离变小，所以也就不用更新 dist 和 path 数组的值。 再继续下一轮循环，此时选出的顶点就是$v_3$（注意是按递增顺序，所以不是$v_5$），此时通过$v_3$可以使$v_1$到$v_6$的距离变小，所以更新数组中的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 8 5 path -1 1 4 1 4 3 4 接着选定$v_5$，按照同样的过程，数组值也不用更新。 在选定$v_7$，此时可以使$v_1$到$v_6$的距离变小，更新数组的值： index 1 2 3 4 5 6 7 dist 0 2 3 1 3 6 5 path -1 1 4 1 4 7 4 最后一个顶点是$v_6$，但$v_6$没有邻接点（就算有，此时其他顶点也都被访问过了），所以循环会结束。 注意上述过程与姥姥讲的略微有点不一致，也就是开头加入$v_1$后，数组值都是循环体内更新的；而姥姥讲的是在循环开始之前就已经全部更新好了。实际上，在循环体内更新还要更加方便一点。 有权图的多源最短路径考虑有权图的多源最短路径时，毫无疑问会想到直接将单源最短路径算法调用$|V|$（因为顶点个数是$|V|$），此时算法的时间复杂度为：$ T = O(|V^3| + |E| \times |V|)$，显然如果是稀疏图，效率较高。 那碰到稠密图怎么办呢？答案是用 Floyd 算法 Floyd 算法Floyd 算法与 Dijkstra 算法有点类似，但是其借助了数学归纳法，相比 Dijkstra 算法，代码要简单一点。 注意 Floyd 算法只能用于邻接矩阵，它本身也是通过邻接矩阵来更新最短路径的权值之和的，当$D^{k-1}$已经完成，递推到$D^k$时，主要理解两个点： 若 k 不在最短路径$i -&gt; \dots -&gt; j$之间，则$D^k = D^{k-1}$ 若 k 在最短路径径$i -&gt; \dots -&gt; j$之间，则该路径必定由两段最短路径组成：$D^k[i][j] = D^{k-1}[i][k] + D^{k-1}[k][j]$ 其伪码描述为：12345678910111213141516171819void Floyd() &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; D[i][j] = G[i][j]; // initialization path[i][j] = -1; &#125; &#125; // notice these loop variables for(k = 0; k &lt; N; k++) &#123; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(D[i][k] + D[k][j] &lt; D[i][j]) &#123; D[i][j] = D[i][k] + D[k][j]; path[i][j] = k; &#125; &#125; &#125; &#125;&#125; Homework07-4 哈利·波特的考试这道题目是典型的多源最短路径问题，直接用邻接矩阵存储图，然后调用 Folyd 算法即可得到所有的最短路径。但要注意这道题目的最优解是选择出到其他各顶点的综合距离最短的顶点，也就是说各个顶点到其他顶点的最短路径中最长的那条最短路径的最小值者就是最优解，好吧，很拗口。注意，并不能以最短路径之和最小者为最优解，这是错误的。这道题的代码写的比较简单，思路与上述一致，如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;using namespace std;const int maxn = 100 + 5;const int inf = 0x3fffffff;int n, m, G[maxn][maxn], dist[maxn][maxn];void floyd() &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; dist[i][j] = G[i][j]; &#125; &#125; for(int k = 1; k &lt;= n; k++) &#123; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(dist[i][k] + dist[k][j] &lt; dist[i][j] &amp;&amp; i != j) &#123; dist[i][j] = dist[i][k] + dist[k][j]; &#125; &#125; &#125; &#125;&#125;void findanimal() &#123; floyd(); int mindist = inf; int animal; for(int i = 1; i &lt;= n; i++) &#123; int maxdist = 0; for(int j = 1; j &lt;= n; j++) &#123; if(i != j &amp;&amp; dist[i][j] &gt; maxdist) maxdist = dist[i][j]; &#125; if(maxdist == inf) &#123; cout &lt;&lt; 0; return; &#125; if(mindist &gt; maxdist) &#123; mindist = maxdist; animal = i; &#125; &#125; cout &lt;&lt; animal &lt;&lt; ' ' &lt;&lt; mindist;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2]; G[v2][v1] = G[v1][v2]; &#125; findanimal(); return 0;&#125;/*samples:in:6 113 4 701 2 15 4 502 6 505 6 601 3 704 6 603 6 805 1 1002 4 605 2 80out:4 70*/ 07-5 Saving James Bond - Hard Version这道题目是上周题目的加强版，题目大意与姥姥在课上开头讲的一样，不仅要判断是否可以到达岸边，还要输出对应的路径。 解决这个问题的思路就是利用 BFS 算法来找最短路径，也就是无权图的单源最短路径。可能有的同学会觉得顶点之前的距离不就是边的权吗？其实不然，这个题目的边权不是直接给出，需要计算得到；而且，这个题目的最优解不是要求最短路径的权值最小，而是要求跳的次数最少，所以，只需要用计算出边权然后判断是否可达即可。 要求得具体经过了几跳到达岸边，稍微有点麻烦，但可以借鉴上篇文章六度空间那个题目的思路，在开始 BFS 之前先记录是哪个顶点，在每次循环结束之前，将当前加入路径的结点与记录的结点比对，如果相同，那么跳步数加 1，并将此结点记录后用作下轮循环判断。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node &#123; int x, y;&#125; coords[maxn];int n, d, path[maxn];bool vis[maxn] = &#123;false&#125;;int firstjump(int v) &#123; int dis = d - sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) + 7.5; if(dis &gt; 0) return dis; else return 0;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125;bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool cmp(int a, int b) &#123; return firstjump(a) &gt; firstjump(b);&#125;void printpath(int inde) &#123; if(path[inde] == -1) &#123; cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl; return; &#125; printpath(path[inde]); cout &lt;&lt; coords[inde].x &lt;&lt; ' ' &lt;&lt; coords[inde].y &lt;&lt; endl;&#125;void save007() &#123; if(d &gt;= 50 - 15 / 2) &#123; cout &lt;&lt; 1; return; &#125; else &#123; int order[maxn]; queue&lt;int&gt; q; for(int i = 0; i &lt; n; i++) &#123; order[i] = i; path[i] = -1; &#125; sort(order, order + n, cmp); int last, tail; for(int i = 0; i &lt; n; i++) &#123; if(firstjump(order[i])) &#123; q.push(order[i]); vis[order[i]] = true; last = order[i]; &#125; &#125; int step = 2; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(issafe(front)) &#123; cout &lt;&lt; step &lt;&lt; endl; printpath(front); return; &#125; for(int i = 0; i &lt; n; i++) &#123; if(!vis[i] &amp;&amp; jump(front, i)) &#123; q.push(i); path[i] = front; vis[i] = true; tail = i; &#125; &#125; if(last == front) &#123; step++; last = tail; &#125; &#125; if(q.empty()) cout &lt;&lt; 0; &#125;&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; coords[i].x &gt;&gt; coords[i].y; &#125; save007(); return 0;&#125;/*samples:in:17 1510 -2110 21-40 1030 -5020 4035 100 -10-25 2240 -40-30 30-10 220 1125 2125 1010 1010 35-30 10out:40 1110 2110 35in:4 13-12 1212 12-12 -1212 -12out:0in:1 5030 30out:1*/ 07-6 旅游规划这道题目是中文的，读起来没那么费劲了，所以很容易让人看出是单源最短路径问题。 题目已经给定了源点和终点，所以用源点直接套 Dijkstra 算法即可得到其到终点的最短路径。 但这个题目的难点在于要根据题目给定的选解方式来确定最优解，即： 路径最短 最便宜 所以需要修改一下 Dijkstra 算法，具体代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/* notes: this problem is similar to the Advanced Level 1030. */#include &lt;iostream&gt;using namespace std;const int inf = 0x3fffffff;const int maxn = 500 + 5;int n, m, src, dst, G[maxn][maxn], cost[maxn][maxn];int d[maxn], c[maxn];bool vis[maxn] = &#123;false&#125;;void dijkstra(int src) &#123; fill(d, d + maxn, inf); d[src] = 0; c[src] = 0; for(int i = 0; i &lt; n; i++) &#123; int v = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(!vis[j] &amp;&amp; d[j] &lt; min) &#123; v = j; min = d[j]; &#125; &#125; if(v == -1) return; vis[v] = true; for(int w = 0; w &lt; n; w++) &#123; if(!vis[w] &amp;&amp; G[v][w] != inf) &#123; if(d[v] + G[v][w] &lt; d[w]) &#123; d[w] = d[v] + G[v][w]; c[w] = c[v] + cost[v][w]; &#125; else if(d[v] + G[v][w] == d[w]) &#123; if(c[v] + cost[v][w] &lt; c[w]) c[w] = c[v] + cost[v][w]; &#125; &#125; &#125; &#125;&#125;int main() &#123; fill(G[0], G[0] + maxn * maxn, inf); cin &gt;&gt; n &gt;&gt; m &gt;&gt; src &gt;&gt; dst; int v1, v2; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; v1 &gt;&gt; v2; cin &gt;&gt; G[v1][v2] &gt;&gt; cost[v1][v2]; G[v2][v1] = G[v1][v2], cost[v2][v1] = cost[v1][v2]; &#125; dijkstra(src); cout &lt;&lt; d[dst] &lt;&lt; ' ' &lt;&lt; c[dst]; return 0;&#125;/*samples:in:4 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20out:3 40*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_06-图（上）]]></title>
    <url>%2F2020%2F08%2F27%2FZJU-DS-06-%E5%9B%BE%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是图？如何表示和实现？图又有那些基本的性质？常见的应用有哪些？ 什么是图图常用来建立多对多的关系，如社交网络等。那么用什么概念来说明这些关系呢？答案就是“顶点”跟“边”。图的构成只有两种：顶点和边，二者即是用来表示关系的概念。 顶点一个图内肯定不止一个顶点（Vertex），所以一般用 Ｖ 来表示顶点集合 边同样，一个图内肯定不止一条边（Edge），所以一般用 E 来表示边的集合。需要注意的是，图分为有向图与无向图，所以边在这两种图中分别称作有向边（单行线，如$&lt;v_1, v_2&gt;$）与无向边（$(v1, v2)$）。 另外，在图内是不考虑重边和自回路的。 基本术语与图相关的基本术语有很多，碰见一个记录一个： 无向图，图内所有的边都是无向边，对应的，若图内所有的边都是有向边，那这个图就是有向图 每一条边上赋予权值后，那么称这个图叫做“网络”，这个概念与互联网络是不一样的 完全图，图内所有顶点，任意两个顶点之间都有边 连通，如果从 V 到 W 存在一条（无向）路径，则称 V 和 W 是连通的 路径，V 到 W 的路径是一系列顶点${V, V_1, V_2, \dots, V_n, W}$的集合，其中任一对相邻顶点间都有图中的边。路径的长度是路径种的边数（如果带权，则是所有边的权重和）。如果 V 到 W 之间的所有顶点都不同，则称简单路径 回路，起点等于终点的路径 连通图，图中任意两顶点均连通 连通分量，无向图的极大连通子图，其中“极大”包含下面两个意思： 极大顶点数：再加一个顶点就不连通了 极大边数：包含子图种所有顶点相连的所有边 有向图中顶点 V 和 W 之间存在双向路径，则称 V 和 W 是强连通的 强连通图，有向图中任意两顶点均强连通 强连通分量，有向图的极大强连通子图 弱连通图，如果一个非强连通图，将其中所有的有向边改为无向边，得到的图为连通图，这样的图称为弱连通图 图的抽象数据类型描述类型名称：图（Graph）数据对象集：$G(V, E)$由一个非空的有限顶点集$V$和一个有限边集合$E$组成。操作集：最大堆$H ∈ MaxHeap$，元素$item ∈ ElementType$，主要操作有： Graph Create()，建立并返回空图 Graph InsertVertex(Graph G, Vertex v)，将 v 插入 G Graph InsertEdge(Graph G, Edge e)，将 e 插入 G void DFS(Graph G, Vertex v)，从顶点 v 出发深度优先遍历图 G void BFS(Graph G, Vertex v)，从顶点 v 出发宽度优先遍历图 G void ShortestPath(Graph G, Vertex v, int Dist[])，计算图 G 中顶点 v 到任意其他顶点的最短距离 void MST(Graph G)，计算图 G 的最小生成树 图的表示图的表示有多种方法，按照所要解决的问题的性质，用符合问题情况的表示方法来表示图，在解决问题是可以事半功倍，下面只介绍两种常见的表示方法。 邻接矩阵邻接矩阵本质上就是一个二维数组，用数组下标$0-N-1$代表$N$个顶点的编号，数组的元素的值表示两个顶点之间是否有边（若是网络，那么直接将数组元素的值修改为对应的权值即可），即有： $G[i][j] =\begin{cases}1&amp; 若&lt;v_i, v_j&gt;是G中的边\\0&amp; 否则\end{cases}$值得注意的是，无向图的邻接矩阵一定是对称的。也就是说，无向图的邻接矩阵只需要存储一半即可。要解决这个问题，需要用到矩阵的压缩存储知识。 使用邻接矩阵表示图的优点有以下几点： 直观、简单、便于理解 方便检查任意一对顶点间是否存在边 方便找任一顶点的所有“邻接点”（有边直接相连的顶点） 方便计算任一顶点的“度”（这里的度的概念与树是类似的，从该顶点发出的边数为“出度”，指向该点的边数为“入度”） 无向图：对应行（或列）非 0 元素的个数 有向图：对应行非 0 元素的个数是“出度”，对应列非 0 元素的个数是“入度” 邻接矩阵的缺点如下： 存储稀疏图（顶点多边很少）时有大量无效元素，极大浪费空间，但存储稠密图（特别是完全图）很合算 统计稀疏图中的边数效率很低 邻接表由于邻接矩阵表示稀疏图浪费空间，为了解决这个问题对应出现的就是邻接表。 在邻接表中，$G[N]$为指针数组，对应矩阵每一行一个链表，只存非 0 元素，注意邻接表的表示并不唯一。 邻接表的特点： 方便找任一顶点的所有“邻接点” 节约稀疏图的空间，需要 N 个头指针 和 2E 个结点（每个结点至少 2 个域） 方便计算无向图任一顶点的度和有向图任一顶点的出度，但计算有向图任一顶点的入度比较麻烦，需要构造“逆邻接表”（存储指向自己的边）才能方便的计算入度 不便于检查任意一对顶点是否存在边 图的遍历图里面遍历的概念与树是一致的，图的基本遍历方法有两种：深度优先搜索（Depth First Search，DFS）和广度优先搜索（Breath First Search，BFS）。根据应用场景的不同，两种遍历算法在不同场景下解决问题的难易程度也不一样。 DFSDFS 算是树的先序遍历的推广，其伪码算法为：123456void DFS(Vertex V) &#123; visited[V] = true; // 此结点标记为已访问 for( V 的每个邻接点 W) &#123; if(!visited[W]) DFS(W); &#125;&#125; 根据图的存储结构的不同，DFS 的时间复杂度也不同： 使用邻接表存储，时间复杂度为：$O(N + E)$ 使用邻接矩阵存储，时间复杂度为：$O(N^2)$ BFSBFS 算是树的层序遍历的推广，其伪码算法为：12345678910111213void BFS(Vertex V) &#123; visited[V] = true; Enqueu(V, Q); while(!Isempty(Q)) &#123; V = Dequeue(Q); for(V 的每个邻接点 W) &#123; if(!visited[W]) &#123; visited[W] = true; Enqueue(W, Q); &#125; &#125; &#125;&#125; 同样，其时间复杂度也分两种情况： 使用邻接表存储，时间复杂度为：$O(N+E)$ 使用邻接矩阵存储，时间复杂度为：$O(N^2)$ Homework06-1 列出连通集题目意思很明确，给定一个无向图，分别用 DFS 和 BFS列出其所有的连通集（其实就是连通分量，忘记是啥了，可以重新看下上面的概念）即可。之前姥姥在课上讲过，按照 DFS 的遍历过程，一个最外层的 DFS 的调用，就相当于访问了这个图的一个连通集。那么使用 DFS 在访问每个连通集是顺便输出当前所处连通集的所有元素即可，同理，BFS 也是一样的。 由于姥姥讲了图的两种存储方法，继续按部就班的按照姥姥给定的代码接着往下写： 邻接表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/* notes: The adjacency list is built by head pointer, so the traversal sequences is not same as sample output.Actually, the adjacency list is not unique, so the traversal sequences are also not unique.You can use the sort function to get the same result. */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode&#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct AdjVNode* PtrToAdjVNode;struct AdjVNode&#123; Vertex AdjV; WeightType Weight; PtrToAdjVNode Next;&#125;;typedef struct Vnode&#123; PtrToAdjVNode FirstEdge; DataType Data;&#125; AdjList[MaxVertexNum];typedef struct GNode* PtrToGNode;struct GNode&#123; int Nv; int Ne; AdjList G; &#125;;typedef PtrToGNode LGraph;LGraph CreateGraph(int VertexNum) &#123; Vertex V; LGraph Graph; Graph = (LGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; Graph-&gt;G[V].FirstEdge = NULL; &#125; return Graph;&#125;void InsertEdge(LGraph Graph, Edge E) &#123; PtrToAdjVNode NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V2; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge; Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode; NewNode = (PtrToAdjVNode)malloc(sizeof(struct AdjVNode)); NewNode-&gt;AdjV = E-&gt;V1; NewNode-&gt;Weight = E-&gt;Weight; NewNode-&gt;Next = Graph-&gt;G[E-&gt;V2].FirstEdge; Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;&#125;LGraph BuildGraph() &#123; LGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125; void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; PtrToAdjVNode W; Visit(S); Visited[S] = true; for(W = Graph-&gt;G[S].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) DFS(Graph, W-&gt;AdjV, Visit, Visited); &#125;&#125;void BFS(LGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; Vertex V; Visit(S); Visited[S] = true; Queue[++rear] = S; while(front &lt; rear) &#123; V = Queue[++front]; PtrToAdjVNode W; for(W = Graph-&gt;G[V].FirstEdge; W; W = W-&gt;Next) &#123; if(!Visited[W-&gt;AdjV]) &#123; Visit(W-&gt;AdjV); Visited[W-&gt;AdjV] = true; Queue[++rear] = W-&gt;AdjV; &#125; &#125; &#125;&#125;void ListComponents(LGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; LGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/*samples:in:8 60 70 12 04 12 43 5out:&#123; 0 2 4 1 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 2 1 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 邻接矩阵123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define MaxVertexNum 100#define INFINITY 65535typedef int Vertex;typedef int WeightType;typedef char DataType;typedef struct ENode* PtrToENode;struct ENode &#123; Vertex V1, V2; WeightType Weight;&#125;;typedef PtrToENode Edge;typedef struct GNode* PtrToGNode;struct GNode &#123; int Nv; int Ne; WeightType G[MaxVertexNum][MaxVertexNum]; DataType Data[MaxVertexNum];&#125;;typedef PtrToGNode MGraph;MGraph CreateGraph(int VertexNum) &#123; Vertex V, W; MGraph Graph; Graph = (MGraph)malloc(sizeof(struct GNode)); Graph-&gt;Nv = VertexNum; Graph-&gt;Ne = 0; for(V = 0; V &lt; Graph-&gt;Nv; V++) &#123; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; Graph-&gt;G[V][W] = INFINITY; &#125; &#125; return Graph;&#125;void InsertEdge(MGraph Graph, Edge E) &#123; Graph-&gt;G[E-&gt;V1][E-&gt;V2] = 1; Graph-&gt;G[E-&gt;V2][E-&gt;V1] = 1;&#125;MGraph BuildGraph() &#123; MGraph Graph; Edge E; Vertex V; int Nv, i; scanf("%d", &amp;Nv); Graph = CreateGraph(Nv); scanf("%d", &amp;Graph-&gt;Ne); if(Graph-&gt;Ne != 0) &#123; E = (Edge)malloc(sizeof(struct ENode)); for(i = 0; i &lt; Graph-&gt;Ne; i++) &#123; scanf("%d %d", &amp;E-&gt;V1, &amp;E-&gt;V2); InsertEdge(Graph, E); &#125; &#125; return Graph;&#125;bool IsEdge(MGraph Graph, Vertex V, Vertex W) &#123; return Graph-&gt;G[V][W] &lt; INFINITY ? true : false;&#125;void Visit(Vertex V) &#123; printf("%d ", V);&#125;void DFS(MGraph Graph, Vertex V, void (*Visit)(Vertex), int Visited[]) &#123; Visit(V); Visited[V] = true; Vertex W; for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) DFS(Graph, W, Visit, Visited); &#125;&#125;void BFS(MGraph Graph, Vertex S, void (*Visit)(Vertex), int Visited[]) &#123; Vertex Queue[MaxVertexNum], front = -1, rear = -1; // use a simple queue Vertex V, W; Visit(S); Visited[S] = true; Queue[++rear] = S; //enqueue while(front &lt; rear) &#123; V = Queue[++front]; //dequeue for(W = 0; W &lt; Graph-&gt;Nv; W++) &#123; if(!Visited[W] &amp;&amp; IsEdge(Graph, V, W)) &#123; Visit(W); Visited[W] = true; Queue[++rear] = W; &#125; &#125; &#125;&#125;void ListComponents(MGraph Graph) &#123; Vertex S; int Visited[MaxVertexNum] = &#123;false&#125;; for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); DFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125; memset(Visited, 0, sizeof(Visited)); for(S = 0; S &lt; Graph-&gt;Nv; S++) &#123; if(!Visited[S]) &#123; printf("&#123; "); BFS(Graph, S, Visit, Visited); printf("&#125;\n"); &#125; &#125;&#125;int main() &#123; MGraph G = BuildGraph(); ListComponents(G); return 0;&#125;/* simple method: use 2-dimensional array represent adjcent matrix#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;using namespace std;const int maxn = 10 + 5;const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;void dfs(int node) &#123; visited[node] = true; cout &lt;&lt; node &lt;&lt; ' '; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[node][i] != inf) dfs(i); &#125;&#125;void bfs(int node) &#123; queue&lt;int&gt; q; cout &lt;&lt; node &lt;&lt; ' '; visited[node] = true; q.push(node); while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i] &amp;&amp; G[front][i] != inf) &#123; cout &lt;&lt; i &lt;&lt; ' '; visited[i] = true; q.push(i); &#125; &#125; &#125;&#125;void listcomponents() &#123; for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; dfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125; memset(visited, 0, sizeof(visited)); for(int i = 0; i &lt; nv; i++) &#123; if(!visited[i]) &#123; cout &lt;&lt; "&#123; "; bfs(i); cout &lt;&lt; "&#125;\n"; &#125; &#125;&#125;int main() &#123; init(); cin &gt;&gt; nv &gt;&gt; ne; for(int i = 0; i &lt; ne; i++) &#123; int v1, v2; cin &gt;&gt; v1 &gt;&gt; v2; G[v1][v2] = G[v2][v1] = 1; &#125; listcomponents(); return 0;&#125;*//*some samples:in:8 60 70 12 04 12 43 5out:&#123; 0 1 4 2 7 &#125;&#123; 3 5 &#125;&#123; 6 &#125;&#123; 0 1 2 7 4 &#125;&#123; 3 5 &#125;&#123; 6 &#125;*/ 06-2 Saving James Bond - Easy Version这道题目是难度降低后的简单版，按照姥姥给定的思路来写即可，这里使用 C++ 的部分功能来写可能会比较方便（用纯 C 也可以胜任，可能会稍微麻烦），如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100 + 5;struct node&#123; double x, y;&#125; coords[maxn];int n;double d;bool visited[maxn] = &#123;false&#125;;bool firstjump(int v) &#123; return sqrt(pow(coords[v].x, 2) + pow(coords[v].y, 2)) - 7.5 &lt;= d;&#125;bool jump(int v, int w) &#123; return sqrt(pow(coords[v].x - coords[w].x, 2) + pow(coords[v].y - coords[w].y, 2)) &lt;= d;&#125; bool issafe(int v) &#123; return fabs(fabs(coords[v].x) - 50) &lt;= d || fabs(fabs(coords[v].y) - 50) &lt;= d;&#125;bool DFS(int v) &#123; visited[v] = true; bool flag = false; if(issafe(v)) return true; else &#123; for(int w = 0; w &lt; n; w++) &#123; if(!visited[w] &amp;&amp; jump(v, w)) &#123; flag = DFS(w); if(flag) break; &#125; &#125; &#125; return flag;&#125;void save007() &#123; bool flag = false; for(int v = 0; v &lt; n; v++) &#123; if(!visited[v] &amp;&amp; firstjump(v)) &#123; flag = DFS(v); if(flag) break; &#125; &#125; flag ? cout &lt;&lt; "Yes" : cout &lt;&lt; "No";&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; d; for(int v = 0; v &lt; n; v++) &#123; cin &gt;&gt; coords[v].x &gt;&gt; coords[v].y; &#125; save007(); return 0;&#125;/*sample:in:25 -15-25 288 4929 15-35 -25 2827 -29-8 -28-20 -35-25 -20-13 29-30 15-35 4012 12out:Yesin:4 13-12 1212 12-12 -1212 -12out:No*/ 06-3 六度空间由于六度空间理论姥姥已经介绍过了，所以题目意思理解起来比较容易，按照姥姥的讲解，只需要稍稍修改 BFS 算法就可以了，但注意最后边界条件的设置要好好理解。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdbool.h&gt;#define maxn 1005const int inf = 0x3fffffff;int G[maxn][maxn], nv, ne;bool visited[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; for(int j = 0; j &lt; maxn; j++) &#123; G[i][j] = inf; &#125; &#125;&#125;int BFS(int v) &#123; memset(visited, false, sizeof(visited)); visited[v] = true; int Queue[maxn], front = -1, rear = -1; Queue[++rear] = v; int count = 1, level = 0, last = v, tail; while(front &lt; rear) &#123; int first = Queue[++front]; for(int w = 1; w &lt;= nv; w++) &#123; if(!visited[w] &amp;&amp; G[first][w] != inf) &#123; Queue[++rear] = w; visited[w] = true; tail = w; count++; &#125; &#125; if(first == last) &#123; level++; last = tail; &#125; if(level == 6) break; &#125; return count;&#125;void sds() &#123; for(int i = 1; i &lt;= nv; i++) &#123; int count = BFS(i); printf("%d: %.2lf%%\n", i, (double)count / nv * 100.0); &#125;&#125;int main() &#123; init(); scanf("%d %d", &amp;nv, &amp;ne); int v1, v2; for(int i = 0; i &lt; ne; i++) &#123; scanf("%d %d", &amp;v1, &amp;v2); G[v1][v2] = G[v2][v1] = 1; &#125; sds(); return 0;&#125;/*samples:in:10 91 22 33 44 55 66 77 88 99 10out:1: 70.00%2: 80.00%3: 90.00%4: 100.00%5: 100.00%6: 100.00%7: 100.00%8: 90.00%9: 80.00%10: 70.00%*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扒谱记录 - 秋柳]]></title>
    <url>%2F2020%2F08%2F26%2F%E6%89%92%E8%B0%B1%E8%AE%B0%E5%BD%95-%E7%A7%8B%E6%9F%B3%2F</url>
    <content type="text"><![CDATA[前段时间，朋友突然给我发了他比较喜欢的民谣 ——《秋柳》。正巧他自己在吹口琴，所以想试着扒扒谱子，结果谱子扒完后，让我给他看看。我转尔一想，直接自己扒了比对算了。不过，网上估计也有对应的简谱。 原曲： 自扒谱：123 212 1(6)(5)123 335 532123 212 1(6)(5)123 212 1(7)1345 532234 444 323345 321165 132 171()：降八度 扒的比较简陋，日后在做一张简谱吧。]]></content>
      <categories>
        <category>Life</category>
        <category>Hobby</category>
      </categories>
      <tags>
        <tag>Music</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_05-树（下）]]></title>
    <url>%2F2020%2F05%2F03%2FZJU-DS-05-%E6%A0%91%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本讲将会在二叉树结构的基础上在介绍另外三种特殊的结构：堆、哈夫曼树和集合，快来学习吧！ Heap在了解对之前先来考虑一下“优先队列”的问题。 所谓优先队列，即取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序，可以用数组、链表、有序数组、有序链表、树等来实现。 如果使用平衡二叉树来实现，插入不难实现，但是删除操作会存在一个问题，那就是，多次删除操作后，树的两边会变得不均衡，如果在来旋转调整就会降低效率，于是考虑让最大值称为根结点（大根堆），每次删除只需要删除根结点即可，这样就不会影响树的高度了。堆有两个特性（满足特性才能称堆，否则不行）： 结构性：用数组表示的完全二叉树 有序性：任一结点的关键字是其子树所有结点的最大值（或最小值）。 最大堆（MaxHeap），也称大根堆，根为最大值 最小堆（MinHeap），也称小根堆，根为最小值 堆的抽象数据类型描述类型名称：最大堆（MaxHeap）数据对象集：完全二叉树，每个结点元素值不小于其子结点的元素值操作集：最大堆$H ∈ MaxHeap$，元素$item ∈ ElementType$，主要操作有： MaxHeap Create(int MaxSize)，创建一个空的最大堆 Boolean IsFull(MaxHeap H)，判断最大堆H是否已满 Insert(MaxHeap H, ElementType item)，将元素item插入最大堆H Boolean IsEmpty(MaxHeap H)，判断最大堆H是否为空 ElementType DeleteMax(MaxHeap H)，返回H中最大元素（高优先级） 堆的实现C 语言下的堆定义可以如下：123456typedef struct HeapStruct *MaxHeap;struct HeapStruct&#123; ElementType *Data; int Size; int Capacity;&#125;; 最大堆初始化（建立空堆）12345678MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125; 判断堆满123bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125; 判断堆空123bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125; 插入由于堆的实现是基于完全二叉树的思想，插入元素的时候直接放在最后就好，但是要注意此时树的结构符合最大堆的特性。所以需要将子结点与父结点比较，如果子结点比父结点大，就将子结点与父结点互换。1234567891011121314bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125; 删除对大根堆而言，删除就是删除最大值元素（也就是堆顶）。删除了堆顶后，直接将最后一个元素放到堆顶显然无法保证堆的结构性，所以还需要对此时的堆做调整。123456789101112131415161718ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125; 直接建堆上面提到的建堆方法实际上是将元素一个个的插入到堆中，时间复杂度为：$O(NLogN)$。 可以使用下面的思路来建堆： 将 N 个元素按输入顺序存入，先满足完全二叉树的特性 调整各结点位置，以满足最大堆的有序特性。 子结点无须调整，所以只需依次调整所有叶结点即可，调整的思路与删除结点时调整堆的结构的思路一致。另外，为了使得代码简洁，可以将结点下移的操作独立封装出来，代码如下：123456789101112131415161718void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; 尽管从代码上看时间复杂度好像是$O(N^2)$，但实际情况的时间复杂度是$O(NLogN)$。 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef int ElementType;typedef struct HNode *Heap;struct HNode&#123; ElementType *Data; int Size; int Capacity;&#125;;typedef Heap MaxHeap;#define MaxData 1000MaxHeap Createheap(int MaxSize) &#123; MaxHeap H = (MaxHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (ElementType*)malloc(sizeof(ElementType) * (MaxData + 1)); H-&gt;Size = 0; H-&gt;Capacity = MaxSize; H-&gt;Data[0] = MaxData; return H;&#125;bool Isfull(MaxHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Insert(MaxHeap H, ElementType X) &#123; int i; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &lt; X; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = X; return true; &#125;&#125;#define ERROR -1bool Isempty(MaxHeap H) &#123; return H-&gt;Size == 0;&#125;ElementType DeleteMax(MaxHeap H) &#123; int parent, child; ElementType Maxitem, X; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return ERROR; &#125; Maxitem = H-&gt;Data[1]; X = H-&gt;Data[H-&gt;Size--]; for(parent = 1; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; return Maxitem;&#125;void Percdown(MaxHeap H, int p) &#123; int parent, child; ElementType X; X = H-&gt;Data[p]; for(parent = p; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &lt; H-&gt;Data[child + 1])) child++; if(X &gt;= H-&gt;Data[child]) break; else H-&gt;Data[parent] = H-&gt;Data[child]; &#125; H-&gt;Data[parent] = X; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MaxHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n'); &#125;int main() &#123; MaxHeap H = Createheap(10); Insert(H, 10); Insert(H, 5); Insert(H, 20); Insert(H, 30); Insert(H, 15); Insert(H, 18); Printheap(H); return 0;&#125; 最小堆最小堆的结构与最大堆的结构区别只在于根结点值比叶结点都小，本质上还是一棵完全二叉树。所以，最小堆的插入、删除和直接建堆的代码略有差异，但思路都是一致的。 插入前面介绍最大堆的时候已经知道了，每向堆中插入一个结点就需要调整堆的结构，调整这个操作可以独立封装起来，这样可以使得代码更加简洁。整体代码如下：123456789101112131415161718void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125; 删除注意最小堆中删除操作的 Percdown 函数与最大堆是有区别的，主要在于当叶结点小于根节点时，才需要将根结点下移（而此时最大堆刚好就是合适的位置）。12345678910111213141516171819202122void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125; 直接建堆直接建堆的思路一致，不同的只是最小堆的 Percdown 函数与最大堆不同，但是可以发现 Buildheap 这个函数没有变化，这其实就是将 Percdown 独立封装起来的好处。1234567891011121314151617void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXN 1005typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap Createheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * MAXN); H-&gt;Size = 0; H-&gt;Capacity = Maxsize; return H;&#125; bool Isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool Isempty(MinHeap H) &#123; return H-&gt;Size == 0;&#125;void Percup(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; for(; H-&gt;Data[index / 2] &gt; H-&gt;Data[index] &amp;&amp; index &gt; 1; index /= 2) &#123; H-&gt;Data[index] = H-&gt;Data[index / 2]; &#125; H-&gt;Data[index] = tmp;&#125;void Percdown(MinHeap H, int index) &#123; int tmp = H-&gt;Data[index]; int parent, child; for(parent = index; parent * 2 &lt;= H-&gt;Size; parent = child) &#123; child = parent * 2; if((child != H-&gt;Size) &amp;&amp; (H-&gt;Data[child] &gt; H-&gt;Data[child + 1])) child++; if(tmp &gt; H-&gt;Data[child]) H-&gt;Data[parent] = H-&gt;Data[child]; else break; &#125; H-&gt;Data[parent] = tmp;&#125;bool Insert(MinHeap H, int X) &#123; if(Isfull(H)) &#123; printf("The heap is full!\n"); return false; &#125; else &#123; H-&gt;Data[++H-&gt;Size] = X; Percup(H, H-&gt;Size); return true; &#125; return true;&#125;int Deletemin(MinHeap H) &#123; int Minitem; if(Isempty(H)) &#123; printf("The heap is empty!\n"); return false; &#125; Minitem = H-&gt;Data[1]; H-&gt;Data[1] = H-&gt;Data[H-&gt;Size--]; Percdown(H, 1); return Minitem; &#125;void Buildheap(MaxHeap H) &#123; int i; for(i = H-&gt;Size / 2; i &gt; 0; i--) &#123; Percdown(H, i); &#125;&#125;void Printheap(MinHeap H) &#123; int i; for(i = 1; i &lt;= H-&gt;Size; i++) &#123; printf("%d ", H-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; MinHeap H = Createheap(5); Insert(H, 46); Insert(H, 23); Insert(H, 26); Insert(H, 24); Insert(H, 10); Printheap(H); Deletemin(H); Printheap(H); return 0;&#125; Huffman Tree编码问题是计算机学科内十分重要的问题，而哈夫曼树就是为了解决编码的问题而产生的。与之类似的问题还有判定树和搜索树如何构造最优的问题，而所谓最优，即是查找树效率最高。 首先，哈夫曼树是一种很特殊的二叉树（没错，它是二叉树），它有 N 个叶子结点，若该树的带权路径长度（WPL）达到最小，称这样的二叉树为哈夫曼树（Huffman Tree），也叫最优二叉树。 那么，什么是带权路径长度（WPL，Weighted Path Length of Tree）呢？ 设二叉树有 N 个叶子结点，每个叶子结点带有权值$w_k$，从根结点到每个叶子结点的长度为$l_k$，则每个叶子结点的带权路径长度之和：$WPL = \sum_{k=1}^n w_k l_k$。也就是说，哈夫曼树实际上就是指 WPL 最小的树。 构造构造哈夫曼树的方法也比较简单，每次把权值最小的两棵二叉树合并即可。 由于每次建树都需要选出权值最小的结点，所以在代码实现过程中，借助最小堆来找出权值最小的结点比较方便快捷。 这里偷个懒，直接用何头给出的代码：12345678910111213141516171819typedef struct TreeNode *HuffmanTree;struct TreeNode&#123; int Weight; HuffmanTree Left, Right;&#125;HuffmanTree Huffman(MinHeap H) &#123; int i; HuffmanTree T; BuildMinHeap(H); for(i = 1; i &lt; H-&gt;Size; i++) &#123; T = malloc(sizeof(struct TreeNode)); T-&gt;Left = Deletemin(H); T-&gt;Right = Deletemin(H); T-&gt;Weight = T-&gt;Left-&gt;Weight + T-&gt;Right-&gt;Weight; Insert(H, T); &#125; T = DeleteMin(H); // insert new root node return T;&#125; 特点由于哈夫曼树构造方法的特殊性，它具有以下几个特点： 没有度为 1 的结点 n 个叶子结点的哈夫曼树共有 $2n-1$ 个结点 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树 对同一组权值${w_1, w_2, w_3, \dots, w_n}$，是存在不同构的两棵哈夫曼树，但注意其 WPL 是一定是一样且最小的 记好这些特点，算法笔试题可能会遇见。 编码如前所言，哈夫曼树的出现是为了解决编码问题，那么具体解决了那些问题呢？ 哈夫曼树解决的编码问题就是避免了在进行不等长编码时的可能会产生的二义性。所谓二义性就是指同一串编码，解释结果会有不同。根据哈夫曼树的结构，如果用字符代表叶结点，左右分支分别代表 0 和 1，用根结点到每个叶结点的路径方向代表每个字符的编码，可以很神器的发现，各种字符编码组合都不会产生二义性。 此时，对每个字符所编的码也叫做前缀码（即任何字符的编码都不是另一字符编码的前缀）。实际上而言，当所有字符都处在叶结点时，就不会产生非前缀码。 按照哈夫曼树进行的编码，还有一个优点，那就是代价最小，比起等长编码要节省了大量的空间。 这就是哈夫曼树所解决的编码问题。 Set这里集合的概念与数学上集合的概念基本一致，但实际经常用到的集合叫做“并查集”，其实就是集合的并和查两个操作。PS：学完整套课程之后，回过头会发现，集合更像是后面要学的“图”，但其中一些概念又与树联系密切。 利用静态数组存储集合较为方便，借用一下何头的代码：1234typedef struct &#123; ElementType Data; int Parent;&#125; SetType; 查找查找某个元素所在的集合，要先找到这个结点的位置，然后在从下往上依次查找根结点，代码如下：1234567int Find(SetType S[], ElementType X) &#123; int i; for(i = 0; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++) if(i &gt;= MaxSize) return -1; // not find the element for(; S[i].Parent &gt;= 0; i = S[i].Parent); return i; // return the root static pointer&#125; 并两个集合的并运算需要在查找操作的基础上实现，先分别找到两个集合的根结点，再将其中一个根结点的父结点指针设置成另一个根结点的数组下标，假设两个集合内分别有元素 $X_1$ 和 $X_2$，代码如下：123456void Union(SetType S[], ElementType X1, ElementType X2) &#123; int Root1, Root2; Root1 = Find(S, X1); Root2 = Find(S, X2); if(Root1 != Root2) S[Root2].Parent = Root1;&#125; 按照上面的思路，当不断的并入新集合时，可能会产生树不断增高的情况，这样会导致查找的效率降低，一种可行的办法就是将小集合并入大集合。但这样做的效率仍然不高，不过后面姥姥会交给我们路径压缩和按秩归并的方法。 Homework05-7 堆中的路径题目意思很明确，利用题目给定的一串数字建立最小堆，然后对任意给定的下标 i，打印 H[i] 到根结点的路径即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef struct HNode* Heap;struct HNode&#123; int *Data; int Size, Capacity;&#125;;typedef Heap MinHeap;MinHeap initheap(int Maxsize) &#123; MinHeap H = (MinHeap)malloc(sizeof(struct HNode)); H-&gt;Data = (int*)malloc(sizeof(int) * (Maxsize + 1)); H-&gt;Capacity = Maxsize; H-&gt;Size = 0; return H;&#125;bool isfull(MinHeap H) &#123; return H-&gt;Size == H-&gt;Capacity;&#125;bool insert(MinHeap H, int data) &#123; if(isfull(H)) return false; else &#123; int i = ++H-&gt;Size; for(; H-&gt;Data[i / 2] &gt; data &amp;&amp; i &gt; 1; i /= 2) &#123; H-&gt;Data[i] = H-&gt;Data[i / 2]; &#125; H-&gt;Data[i] = data; &#125;&#125;void Printpath(MinHeap H, int index) &#123; for(; index &gt;= 1; index /= 2) &#123; printf("%d", H-&gt;Data[index]); if(index != 1) putchar(' '); &#125; putchar('\n');&#125; int main() &#123; int i, n, m, temp; scanf("%d %d", &amp;n, &amp;m); MinHeap H = initheap(n); for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); insert(H, temp); &#125; for(i = 0; i &lt; m; i++) &#123; scanf("%d", &amp;temp); Printpath(H, temp); &#125; return 0;&#125;/*samples:in:5 346 23 26 24 105 4 3out:24 23 1046 23 1026 10*/ 05-8 File Transfer这道题与老师上课讲的连网问题很类似，但是要看清楚题目中I C S分别代表的含义。 I代表输入连接，就相当于将两个元素并成一个集合；C代表检查两个元素是否在一个集合；S代表停止测试。 根据题目的测试样例，我们得现构造集合，然后在判断元素是否在同一个集合内。当然了，一开始所有的元素都是一个独立的集合，只有当“输入连接”后两个元素才算是处于同一个集合。 明白以上原则后，按照题目要求来进行输出即可。 另外，姥姥出这道题的目的就是为了给大家介绍路径压缩与按秩归并，不用这两种方法，显然不能 AC。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXN 10005typedef int Set[MAXN];typedef int SetType;void init(Set S) &#123; int i; for(i = 0; i &lt; MAXN; i++) &#123; S[i] = -1; &#125;&#125;void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125;SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125;int main() &#123; Set set; init(set); int i, n, c1, c2; scanf("%d%*c", &amp;n); char act; while((act = getchar()) != 'S') &#123; scanf("%d %d%*c", &amp;c1, &amp;c2); int root1, root2; root1 = Find(set, c1); root2 = Find(set, c2); if(act == 'C') &#123; if(root1 == root2 &amp;&amp; (root1 &gt; 0 || root2 &gt; 0)) printf("yes\n"); else printf("no\n"); &#125; else if(act == 'I') &#123; Union(set, root1, root2); &#125; &#125; int cnt = 0; for(i = 1; i &lt;= n; i++) &#123; if(set[i] &lt; 0) cnt++; &#125; if(cnt == 1) printf("The network is connected.\n"); else printf("There are %d components.\n", cnt); return 0;&#125; 按秩归并姥姥讲解的按秩归并有两种方法，关键取决于如何理解“秩”，可以将其认为是树高，也可以认为是树结点的个数。但两者有一个共同点，那就是将小规模的树并到大规模的树上。123456789void Union(Set S, int root1, int root2) &#123; if(S[root1] &lt; S[root2]) &#123; S[root1] += S[root2]; S[root2] = root1; &#125; else &#123; S[root2] += S[root1]; S[root1] = root2; &#125;&#125; 路径压缩路径压缩所解决的问题是尽可能的降低树的高度，这样就会使得其查找效率提高。 在之前介绍的查找操作中，每次需要先找到叶结点在去找根结点，找到了之后并不对集合（也就是查找树）的结构做出优化。但路径压缩借助递归，每找到一个结点，就将它直接挂在根结点的下面，这样当找到目标结点的根结点时，这棵查找树的高度就是 2 了，极大的提高了下次查找时的效率。1234SetType Find(Set S, int elem) &#123; if(S[elem] &lt; 0) return elem; else return S[elem] = Find(S, S[elem]);&#125; 05-9 Huffman Codes题目大意就是给定字符出现的频率，判断给定的测试样例是否是最优解，但要注意最优解可能并不是由哈夫曼树构成的。 当初做这个题时，想方设法的偷懒，非常不情愿建哈夫曼树，结果最后还真找到了 AC 的方法。 虽然不建哈夫曼树，但是 WPL 还是需要计算出来用来判定是否最优的。那么如何计算 WPL 呢？对，继续偷懒，直接用 C++ STL 里面的优先队列（其实就是最小堆），核心思路就是哈夫曼树的 WPL 也等于除了根结点以外，全部结点的权值之和。这种计算方法与老师上课讲的是完全不同了，利用这种思路，可以很简单的计算出一棵哈夫曼树的 WPL，而且还不用建树。 有了最优解的 WPL 后，只需要在计算出每个样例的 WPL，并比对是否一致即可知道样例是否正确。 明白以上问题后，基本已经解决这道题目了。不过还有一个地方要注意，对于非前缀码且 WPL 相同的样例，就不是正确结果了。所以，在计算样例的 WPL 后，还需要判断样例中是否有非前缀码的存在，如果有，那就不是正确结果，需判定为 No。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;const int maxn = 65 + 5;int hashTable[128] = &#123;0&#125;;bool issubstr(string a, string b) &#123; int flag = true; for(int i = 0; i &lt; b.length(); i++) &#123; if(b[i] != a[i]) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main() &#123; priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q; int n; cin &gt;&gt; n; char ch; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch; cin &gt;&gt; hashTable[ch]; q.push(hashTable[ch]); &#125; int wpl = 0; while(q.size() &gt; 1) &#123; int n1, n2, n; n1 = q.top(); q.pop(); n2 = q.top(); q.pop(); n = n1 + n2; q.push(n); wpl += n; &#125; int m; cin &gt;&gt; m; while(m--) &#123; string codes[maxn]; int wpl_tmp = 0; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; ch &gt;&gt; codes[i]; wpl_tmp += codes[i].length() * hashTable[ch]; &#125; bool prefix = false; for(int i = 0; i &lt; n; i++) &#123; string str_tmp = codes[i]; for(int j = 0; j &lt; n; j++) &#123; if(str_tmp != codes[j] &amp;&amp; issubstr(codes[j], str_tmp)) &#123; prefix = true; break; &#125; &#125; if(prefix) break; &#125; bool repetition = false; for(int i = 0; i &lt; n - 1; i++) &#123; string str_tmp = codes[i]; if(str_tmp == codes[i + 1]) &#123; repetition = true; break; &#125; &#125; if(wpl_tmp == wpl &amp;&amp; !prefix &amp;&amp; !repetition) cout &lt;&lt; "Yes\n"; else cout &lt;&lt; "No\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT_05_01-测试赛]]></title>
    <url>%2F2020%2F05%2F03%2FPAT-05-01-%E6%B5%8B%E8%AF%95%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[本来这原文中应该在昨天就发出来的，于是乎，偷了一下懒，就到今天了...废话不多说直接看题！ 7-1 knuth 洗牌法Knuth 洗牌法是生成 { 1, 2, …, n } 的一个随机重排列的算法。与每次反复随机生成一个数字，直到获得一个不重复的新数字的算法不同，Knuth 洗牌法从原始序列 { 1, 2, …, n } 开始，逐次洗牌。洗牌的方法是从左到右，每轮从没确定的数字中随机抽取一个数，把它放到确定的位置上。例如令 n 等于 4。我们从 { 1, 2, 3, 4 } 开始。记 i 到 N 之间的随机抽牌数为 random(i,N)。假设我们生成的随机数序列 random(i,4) (i=1, 2, 3, 4) 为 { 2, 4, 3, 4 }。则 Knuth 洗牌法是这样执行的： random(1,4) = 2; 将位置 1 与位置 2 的数字交换，得到 { 2, 1, 3, 4 } random(2,4) = 4; 将位置 2 与位置 4 的数字交换，得到 { 2, 4, 3, 1 } random(3,4) = 3; 将位置 3 与位置 3 的数字交换，得到 { 2, 4, 3, 1 } random(4,4) = 4; 将位置 4 与位置 4 的数字交换，得到 { 2, 4, 3, 1 } 现给定随机抽牌数字序列，请你输出 Knuth 洗牌法的结果序列。输入格式：输入在第一行中给出一个正整数 N（≤ 1000）。随后一行给出 N 个随机抽牌数字，数字间以空格分隔。题目保证第 i 个数在 i 到 N 之间。输出格式：在第一行中输出 Knuth 洗牌法的结果序列。数字间必须以 1 个空格分隔，行首尾不得有多余空格。 Input12107 4 4 5 10 6 9 9 10 10 Output17 4 2 5 10 6 9 1 3 8 Analysis题目字太多了，不知道是不是姥姥故意这样，来迷惑人，隐藏题意。 其实这个题目就是让你交换数字（算是简单模拟），以样例为例：第一次，处于第一位的数字与处于第七位的数字交换；以第一次得到的结果序列为初始序列，交换处于第二位的数字和处于第四位的数字；依次类推即可。 Code12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; seq[i] = i; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; init(); for(int i = 1; i &lt;= n; i++) &#123; int tmp = seq[i], random; cin &gt;&gt; random; seq[i] = seq[random]; seq[random] = tmp; &#125; for(int i = 1; i &lt;= n - 1; i++) &#123; cout &lt;&lt; seq[i] &lt;&lt; ' '; &#125; cout &lt;&lt; seq[n]; return 0;&#125; 7-2 三阶幸福数对一个十进制数的各位数字做一次立方和，称作一次迭代。如果一个十进制数能通过 h 次迭代得到 1，就称该数为三阶幸福数，迭代的次数 h 称为幸福度。例如 1579 经过 1 次迭代得到 1198，2 次迭代后得到 1243，3 次迭代后得到 100，最后得到 1。则 1579 是幸福数，其幸福度为 4。另一方面，如果一个大于1的数字经过数次迭代后进入了死循环，那这个数就不幸福。例如 97 迭代得到 1072、352、160、217、352、…… 可见 352 到 217 形成了死循环，所以 97 就不幸福，而 352 就是它最早遇到的循环点。本题就要求你编写程序，判断一个给定的数字是否有三阶幸福。 输入在第一行给出一个不超过 100 的正整数 N，随后 N 行，每行给出一个不超过 104 的正整数。 对于每一个输入的数字，如果其是三阶幸福数，则在一行中输出它的幸福度；否则输出最早遇到的循环点。 Input123431579971 Output12343520 Analysis这个题目本质上其实是个数字游戏...按照题目给定的“游戏规则”来处理就行了，由于需要判断数字是否“幸福”，借助哈希表无疑是最快捷、方便的选择。 Code下面是当时写的代码，有点乱见谅，这段代码其实用到的思想都是 C 里面的东西，将 cin 和 cout 换成 scanf 和 printf 说不定还能快点呢。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;const int maxn = 100000 + 5;int hashtable[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; hashtable[i] = 0; &#125;&#125;int main() &#123; int n; cin &gt;&gt; n; while(n--) &#123; int num, degree = 0; cin &gt;&gt; num; init(); if(num == 1) &#123; cout &lt;&lt; 0 &lt;&lt; endl; continue; &#125; int tmp = num; while(1) &#123; int digit, res = 0; hashtable[tmp] = 1; while(tmp) &#123; digit = tmp % 10; res += pow(digit, 3); tmp /= 10; &#125; degree++; hashtable[res]++; if(res == 1) &#123; cout &lt;&lt; degree &lt;&lt; endl; break; &#125; else if(hashtable[res] == 2) &#123; cout &lt;&lt; res &lt;&lt; endl; break; &#125; tmp = res; &#125; &#125; return 0;&#125; 7-3 三阶幸福数据香港《南华早报》2019年7月15日文章，上海严格的垃圾分类新规令不少居民抓狂。这催生出大量帮助找出正确分类答案的App和小程序。目前仅微信上就至少有280种与垃圾处理有关的App，在苹果应用商店也达130种。支付宝表示，已有60多家独立App开发商申请为该平台提供类似服务。本题就请你现场实现一个简单的垃圾分类小助手。 输入首先给出官方分类指南中每种物品的归属。在一行中给出一个正整数 N（≤10​5≤10​5 \le10​^5≤10​5​​），即物品数量；随后 N 行，每行给出一个物品名称（长度不超过 10 的、由小写英文字母和下划线组成的字符串）和该物品所属的分类（1 代表干垃圾、2 代表湿垃圾、3 代表可回收物、4 代表有害垃圾）。题目保证所有物品名称无重复。随后每行给出一个查询物品的名称（格式与指南物品名称相同）。最后一行给出结束符 #，表示查询终止，这一行不需要查询。 对每个查询的物品，在一行中给出其所属分类：Gan laji 代表干垃圾；Shi laji 代表湿垃圾；Ke Hui Shou 代表可回收物；You Hai laji 代表有害垃圾。如果查询的物品不在指南中，则输出 ? 表示不知道。 Input12345678910114bao_zhi 3dian_chi 4dan_ke 2bei_ke 1dan_kedian_chiren_zhabao_zhibei_ke# Output12345Shi lajiYou Hai laji?Ke Hui ShouGan laji Analysis考试时，做这个题只想到了 map，没想到 unordered map，单纯只用 map，3分，unordered map，AC。感觉损失惨重... 另外，能不用 cin 和 cout，还是尽量不用... Code下面是当时用 map 写的代码：123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; rab2id;int main() &#123; int n, id; cin &gt;&gt; n; string str; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str &gt;&gt; id; rab2id[str] = id; &#125; while(cin &gt;&gt; str &amp;&amp; str != "#") &#123; if(rab2id[str] == 1) &#123; cout &lt;&lt; "Gan laji\n"; &#125; else if(rab2id[str] == 2) &#123; cout &lt;&lt; "Shi laji\n"; &#125; else if(rab2id[str] == 3) &#123; cout &lt;&lt; "Ke Hui Shou\n"; &#125; else if(rab2id[str] == 4) &#123; cout &lt;&lt; "You Hai laji\n"; &#125; else cout &lt;&lt; "?\n"; &#125; return 0;&#125; 下面是 AC 的代码（如果不想那么多 if-else，也可以利用字符串数组来输出）：123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;unordered_map&gt;using namespace std;unordered_map&lt;string, int&gt; rab2id;char s[20]; int main() &#123; int n, id; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", s, &amp;id); rab2id[s] = id; &#125; while(scanf("%s", s) != EOF) &#123; string str(s); if(str == "#") &#123; break; &#125; else if(rab2id[str] == 1) &#123; printf("Gan laji\n"); &#125; else if(rab2id[str] == 2) &#123; printf("Shi laji\n"); &#125; else if(rab2id[str] == 3) &#123; printf("Ke Hui Shou\n"); &#125; else if(rab2id[str] == 4) &#123; printf("You Hai laji\n"); &#125; else printf("?\n"); &#125; return 0;&#125; 总结三道 20 分的题目，应该就是乙级 20 分题目的难度？ 可能是我太久没有写代码的缘故了，第一道题目被迷惑了挺久的，原本应该十几分钟就搞定的，结果好像快半个小时才搞定... 第二道题目果然解决起来就快了许多（稍微熟悉了一点），不过意外的是没想到有这么多测试点... 第三道题目只想到了 map 无疑是个败笔，不过也反映了自己忘记了太多东西了...😱而且面对这种卡超时的题目，莫名的有点虚。 反正三道题目都不难就是了，没全部 AC，该检讨。特别是最后一题，几分钟就拿到了 3 分，后面 40 分钟都阵亡了... PS：前两道题都是一次 AC]]></content>
      <categories>
        <category>Programming</category>
        <category>PAT</category>
      </categories>
      <tags>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_04-树（中）]]></title>
    <url>%2F2020%2F05%2F01%2FZJU-DS-04-%E6%A0%91%EF%BC%88%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前面学习了树的基本术语、性质，以及二叉树的形态、遍历方法等，这次会继续学习两种“新”二叉树 Binary Search Tree定义二叉搜索树（BST，Binary Search Tree），也成为二叉排序树或二叉查找树。二叉搜索树：前提得是一棵二叉树，可以为空；如果不为空，满足以下性质： 非空左子树的所有键值小于其根结点的键值 非空右子树的所有键值大于其根节点的键值 左、右子树都是二叉搜索树 特别函数二叉搜索树本质上还是二叉树，所以其抽象数据类型描述与二叉树是一致的，但操作集存在差异，多了几个特别函数： Position Find(ElementType X, BinTree BST)，从二叉搜索树BST中查找元素X，返回其所在结点的地址 Position FindMin(BinTree BST)，从二叉搜索树BST中查找并返回最小元素所在结点的地址 Position FindMax(BinTree BST)，从二叉搜索树BST中查找并返回最大元素所在结点的地址 BinTree Insert(ElementType X, BinTree BST)，向二叉搜索树中插入结点 BinTree Delete(ElementType X, BinTree BST)，在二叉搜索树中删除结点 下面以二叉树的链式存储结构为准，完成几个常用的特别函数。 查找查找函数的实现思路比较直接，按照二叉搜索树的性质，比根结点小则在左子树中查找，比根节点大则在右子树中查找，循环这个过程即可。 递归123456Position Find(ElementType X, BinTree BST) &#123; if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(X, BST-&gt;Right); else if(X &lt; BST-&gt;Data) return Find(X, BST-&gt;Left); else return BST;&#125; 非递归12345678Position IterFind(ElementType X, BinTree BST) &#123; while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else return BST; &#125; return NULL;&#125; 查找最值有了前面查找的思路后，根据 BST 的性质，直接查找最值的函数也很容易得到。 递归1234567891011Position FindMax(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else FindMin(BST);&#125;Position FindMin(BinTree BST) &#123; if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else FindMin(BST);&#125; 非递归12345678910111213Position FindMax(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Right) BST = BST-&gt;Right; &#125; return BST;&#125;Position FindMin(BinTree BST) &#123; if(BST) &#123; while(BST-&gt;Left) BST = BST-&gt;Left; &#125; return BST;&#125; 插入插入的关键在于先确定好插入的位置，既然要确定位置，那么就可以借助查找的思路。 递归1234567891011BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST;&#125; 非递归123456789101112131415161718192021222324BinTree Insert( BinTree BST, ElementType X ) &#123; if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125; 删除删除的思路与插入的思路也类似，还是需要先找删除的位置。但是针对删除结点的不同（叶结点和非叶结点），需要分别考虑。如果删除的是叶结点，那么可以直接删除；但若删除非叶结点，就需要在删除这个结点后，用另一结点替代被删除结点，这样才不会使链式结构断裂。 对于度为 1 的被删除结点，另一结点直接使用其子结点即可；对于度为 2 的被删除结点，另一结点可以用其右子树的最小元素或者其左子树的最大元素，之所要用这两个结点，因为这两个结点一定是叶结点，可以直接拿掉。123456789101112131415161718192021222324252627BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125; Balanced Tree平衡二叉树需要引入平衡因子的概念，其解决了二叉搜索树中出现“单枝树”而导致查找效率过低的树形结构问题。 平衡因子（Balance Factor，BF）：$BF(T) = h_l - h_r$，其中$h_l$和$h_r$分别为树 T 的左右子树高度。 定义平衡二叉树（Balanced Tree，也叫 AVL 树）:空树，或者任何一结点左右子树高度差的绝对值不超过 1，即$|BF(T)| \le 1$。 调整平衡二叉树的结构调整情况有以下四种情况，关键在于观察离破坏者最近的被破坏者和破坏者之间的位置关系。但是要注意有时候插入元素即便不需要调整结构，也可能需要重新计算一些平衡因子。RRLLLRRLRR旋转（虽然叫 RR 旋转，但是实际过程是左旋），破坏者位于被破坏者的右子树的右子树下。 12345678Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LL旋转（虽然叫 LL 旋转，但是实际过程是右旋），破坏者位于被破坏者的左子树的左子树下。 12345678Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;LR旋转（与名称一致，先左旋后右旋），破坏者位于被破坏者的左子树的右子树下。 1234Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;RL旋转（与名称一致，先右旋后左旋），破坏者位于被破坏者的右子树的左子树下。 1234Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125; Homework04-4 是否同一棵二叉搜索树这道题与树的同构有点像，下面的代码包含两种做法： 构造两棵树，判断两棵树是否一致 只构造一棵树，判断给定序列顺序是否与树的结点序列一致 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/* method 1: use recursion to judge two trees is same or not */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;PtrToTNode createnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct TNode)); t-&gt;left = t-&gt;right = NULL; t-&gt;data = data; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = createnode(data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); return root;&#125;bool issame(Tree root1, Tree root2) &#123; if(!root1 &amp;&amp; !root2) return true; else if((!root1 &amp;&amp; root2) &amp;&amp; (root1 &amp;&amp; !root2)) return false; else &#123; if(root1-&gt;data != root2-&gt;data) return false; else return issame(root1-&gt;left, root2-&gt;left) &amp;&amp; issame(root1-&gt;right, root2-&gt;right); &#125;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l; scanf("%d", &amp;n); while(n) &#123; scanf("%d", &amp;l); Tree root1 = NULL; int i, data; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root1 = insert(root1, data); &#125; while(l--) &#123; Tree root2 = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root2 = insert(root2, data); &#125; if(issame(root1, root2)) printf("Yes\n"); else printf("No\n"); destorytree(root2); &#125; scanf("%d", &amp;n); if(n == 0) destorytree(root1); &#125; return 0;&#125;/* method 2: constitute a tree, check the path of visiting everynodes is sameor not #include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct node&#123; int flag, data; struct node *left, *right;&#125;;typedef struct node* Tree;typedef struct node* PtrToTNode;PtrToTNode newnode(int data) &#123; PtrToTNode t = (PtrToTNode)malloc(sizeof(struct node)); t-&gt;data = data; t-&gt;flag = 0; t-&gt;left = t-&gt;right = NULL; return t;&#125;Tree insert(Tree root, int data) &#123; if(!root) root = newnode(data); else if(data &gt; root-&gt;data) root-&gt;right = insert(root-&gt;right, data); else if(data &lt; root-&gt;data) root-&gt;left = insert(root-&gt;left, data); return root;&#125;Tree buildtree(int n) &#123; int i, data; Tree root = NULL; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; return root;&#125;bool check(Tree root, int data) &#123; if(root-&gt;flag) &#123; if(data &lt; root-&gt;data) return check(root-&gt;left, data); else if(data &gt; root-&gt;data) return check(root-&gt;right, data); else return false; &#125; else &#123; if(data == root-&gt;data) &#123; root-&gt;flag = 1; return true; &#125; else return false; &#125;&#125;bool judge(Tree root, int n) &#123; int i, data; bool flag = false; scanf("%d", &amp;data); if(data != root-&gt;data) flag = true; else root-&gt;flag = 1; for(i = 1; i &lt; n; i++) &#123; scanf("%d", &amp;data); if(!flag &amp;&amp; !check(root, data)) flag = 1; &#125; return !flag;&#125;void reset(Tree root) &#123; if(root-&gt;left) reset(root-&gt;left); if(root-&gt;right) reset(root-&gt;right); root-&gt;flag = 0;&#125;void destorytree(Tree root) &#123; if(root-&gt;left) destorytree(root-&gt;left); if(root-&gt;right) destorytree(root-&gt;right); free(root);&#125;int main() &#123; int n, l, i; while(scanf("%d", &amp;n) &amp;&amp; n) &#123; scanf("%d", &amp;l); Tree root = buildtree(n); while(l--) &#123; if(judge(root, n)) printf("Yes\n"); else printf("No\n"); reset(root); &#125; destorytree(root); &#125; return 0;&#125; */ 04-5 Root of AVL Tree这道题就是何老师讲的平衡二叉树的四种旋转方式，题目一次将四种旋转方式全部考察到了，出的很好。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;struct TNode&#123; int data, height; struct TNode *lchild, *rchild;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree;int max(int a, int b) &#123; return a &gt; b ? a : b;&#125;int getheight(Tree root) &#123; if(!root) return -1; else return root-&gt;height;&#125;Tree RRrotate(Tree root) &#123; PtrToTNode t = root-&gt;rchild; root-&gt;rchild = t-&gt;lchild; t-&gt;lchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree LLrotate(Tree root) &#123; PtrToTNode t = root-&gt;lchild; root-&gt;lchild = t-&gt;rchild; t-&gt;rchild = root; t-&gt;height = max(getheight(t-&gt;lchild), getheight(t-&gt;rchild)) + 1; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return t;&#125;Tree RLrotate(Tree root) &#123; root-&gt;rchild = LLrotate(root-&gt;rchild); return RRrotate(root);&#125;Tree LRrotate(Tree root) &#123; root-&gt;lchild = RRrotate(root-&gt;lchild); return LLrotate(root);&#125;Tree insert(Tree root, int data) &#123; if(!root) &#123; root = (Tree)malloc(sizeof(struct TNode)); root-&gt;lchild = root-&gt;rchild = NULL; root-&gt;data = data; root-&gt;height = 0; &#125; else if(data &gt; root-&gt;data) &#123; root-&gt;rchild = insert(root-&gt;rchild, data); if(getheight(root-&gt;rchild) - getheight(root-&gt;lchild) == 2) &#123; if(data &gt; root-&gt;rchild-&gt;data) root = RRrotate(root); else root = RLrotate(root); &#125; &#125; else if(data &lt; root-&gt;data) &#123; root-&gt;lchild = insert(root-&gt;lchild, data); if(getheight(root-&gt;lchild) - getheight(root-&gt;rchild) == 2) &#123; if(data &lt; root-&gt;lchild-&gt;data) root = LLrotate(root); else root = LRrotate(root); &#125; &#125; root-&gt;height = max(getheight(root-&gt;lchild), getheight(root-&gt;rchild)) + 1; return root;&#125;int main() &#123; int i, n, data; scanf("%d", &amp;n); Tree root = NULL; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;data); root = insert(root, data); &#125; printf("%d", root-&gt;data); return 0;&#125; 04-6 Complete Binary Search Tree这道题很有难度，要对完全二叉树、二叉查找树及二叉树的遍历有较深的理解才能解出来，不过解不出来也没事，姥姥后面会讲。123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1005int n, tree[maxn], seq[maxn], inde = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); tree[root] = seq[inde++]; inorder(2 * root + 1);&#125;int cmp(const void *a, const void *b) &#123; return (*(int*)a - *(int*)b);&#125;int main() &#123; scanf("%d", &amp;n); int i; for(i = 0; i &lt; n; ++i) &#123; scanf("%d", &amp;seq[i]); &#125; qsort(seq, n, sizeof(seq[0]), cmp); inorder(1); for(i = 1; i &lt;= n; ++i) &#123; printf("%d", tree[i]); if(i &lt; n) printf(" "); &#125; return 0;&#125; 04-7 二叉搜索树的操作集这道题目是用来测试二叉搜索树常用操作的，可以尝试多种不同的写法来提交来验证是否正确。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct TNode *Position;typedef Position BinTree;struct TNode&#123; ElementType Data; BinTree Left; BinTree Right;&#125;;void PreorderTraversal( BinTree BT );void InorderTraversal( BinTree BT );BinTree Insert( BinTree BST, ElementType X );BinTree Delete( BinTree BST, ElementType X );Position Find( BinTree BST, ElementType X );Position FindMin( BinTree BST );Position FindMax( BinTree BST );int main()&#123; BinTree BST, MinP, MaxP, Tmp; ElementType X; int N, i; BST = NULL; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Insert(BST, X); &#125; printf("Preorder:"); PreorderTraversal(BST); printf("\n"); MinP = FindMin(BST); MaxP = FindMax(BST); scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); Tmp = Find(BST, X); if (Tmp == NULL) printf("%d is not found\n", X); else &#123; printf("%d is found\n", Tmp-&gt;Data); if (Tmp==MinP) printf("%d is the smallest key\n", Tmp-&gt;Data); if (Tmp==MaxP) printf("%d is the largest key\n", Tmp-&gt;Data); &#125; &#125; scanf("%d", &amp;N); for( i=0; i&lt;N; i++ ) &#123; scanf("%d", &amp;X); BST = Delete(BST, X); &#125; printf("Inorder:"); InorderTraversal(BST); printf("\n"); return 0;&#125;void PreorderTraversal( BinTree BT ) &#123; if(!BT) return; printf("%d ", BT-&gt;Data); PreorderTraversal(BT-&gt;Left); PreorderTraversal(BT-&gt;Right);&#125;void InorderTraversal( BinTree BT ) &#123; if(!BT) return; InorderTraversal(BT-&gt;Left); printf("%d ", BT-&gt;Data); InorderTraversal(BT-&gt;Right);&#125;BinTree Insert( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) &#123; BST = (struct TNode*)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; if(X &lt; BST-&gt;Data) BST-&gt;Left = Insert(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Insert(BST-&gt;Right, X); &#125; return BST; */ /* method 2: use loop */ if(!BST) &#123; BST = (BinTree)malloc(sizeof(struct TNode)); BST-&gt;Data = X; BST-&gt;Left = BST-&gt;Right = NULL; &#125; else &#123; Position pre, t; t = BST; while(t) &#123; pre = t; if(X &gt; t-&gt;Data) t = t-&gt;Right; else if(X &lt; t-&gt;Data) t = t-&gt;Left; &#125; struct TNode *tmpnode = (struct TNode*)malloc(sizeof(struct TNode)); tmpnode-&gt;Data = X; tmpnode-&gt;Left = tmpnode-&gt;Right = NULL; if(X &lt; pre-&gt;Data) &#123; pre-&gt;Left = tmpnode; &#125; else if(X &gt; pre-&gt;Data) &#123; pre-&gt;Right = tmpnode; &#125; &#125; return BST;&#125;BinTree Delete( BinTree BST, ElementType X ) &#123; Position tmp; if(!BST) printf("Not Found\n"); else if(X &lt; BST-&gt;Data) BST-&gt;Left = Delete(BST-&gt;Left, X); else if(X &gt; BST-&gt;Data) BST-&gt;Right = Delete(BST-&gt;Right, X); else &#123; if(BST-&gt;Left &amp;&amp; BST-&gt;Right) &#123; /* method 1: use the minium node of right subtree tmp = FindMin(BST-&gt;Right); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Right = Delete(BST-&gt;Right, BST-&gt;Data); */ /* method 2: use the maximum node of left subtree */ tmp = FindMax(BST-&gt;Left); BST-&gt;Data = tmp-&gt;Data; BST-&gt;Left = Delete(BST-&gt;Left, BST-&gt;Data); &#125; else &#123; tmp = BST; if(!BST-&gt;Left) BST = BST-&gt;Right; else BST = BST-&gt;Left; free(tmp); &#125; &#125; return BST;&#125;Position Find( BinTree BST, ElementType X ) &#123; /* method 1: use recursion if(!BST) return NULL; if(X &gt; BST-&gt;Data) return Find(BST-&gt;Right, X); else if(X &lt; BST-&gt;Data) return Find(BST-&gt;Left, X); else return BST; */ /* method 2: use loop*/ while(BST) &#123; if(X &gt; BST-&gt;Data) BST = BST-&gt;Right; else if(X &lt; BST-&gt;Data) BST = BST-&gt;Left; else break; &#125; return BST;&#125;Position FindMin( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Left) return BST; else return FindMin(BST-&gt;Left); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Left) BST = BST-&gt;Left; return BST;&#125;Position FindMax( BinTree BST ) &#123; /* method 1: use recursion if(!BST) return NULL; else if(!BST-&gt;Right) return BST; else return FindMax(BST-&gt;Right); */ /* method 2: use loop, but need use if to avoid segmentation fault */ if(BST) while(BST-&gt;Right) BST = BST-&gt;Right; return BST;&#125;/*samples:in:105 8 6 2 4 1 0 10 9 756 3 10 0 555 7 0 10 3out:Preorder: 5 2 1 0 4 8 6 7 10 96 is found3 is not found10 is found10 is the largest key0 is found0 is the smallest key5 is foundNot FoundInorder: 1 2 4 6 8 9*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_03-树（上）]]></title>
    <url>%2F2020%2F04%2F01%2FZJU-DS-03-%E6%A0%91%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[什么是树？如何表示和实现？树又有什么样性质？常见的应用有哪些？ 引言在了解树之前，先了解一下树在生活中的应用，比如：人类社会的家谱、社会组织结构和图书信息管理。这类信息结构都有一个共同点，那就是内部的不同事物之间都具有层次关系。 查找查找是计算机中的基础操作，所谓基础，即是指查找操作广泛使用在计算机的各个应用，优秀的查找算法对于提高程序查找效率很有帮助。 查找：根据某个给定关键字 K ，从集合 R 中找出关键字与K相同的记录，查找可以分为两类： 静态查找：集合中记录是固定的，没有插入和删除操作，只有查找 动态查找：集合中记录是动态变化的，除查找操作外，还可能会有插入和删除操作 下面仅就静态查找展开讨论。 静态查找静态查找的方法，根据存储结构的不同有着多种多样的方法，下面以数组为例来展开讨论。 顺序查找利用数组下标来作为循环的边界，也可以通过“哨兵”的设计技巧来避免使用下标作为边界值，具体而言，即当前下标的数组值与哨兵的值相等时，跳出循环，代码如下：123456int SequentialSearch(StaticTable *Tbl, ElementType K) &#123; int i; Tbl-&gt;ElementType[0] = K; for(i = Tbl-&gt;Length; Tbl-&gt;ElementType[i] != K; i--); return i;&#125; 显然，顺序查找算法的时间复杂度为$O(n)$。 二分查找二分查找在第一周的作业题中已经见过了。实际上，二分查找是有前提的： 序列有序 存储在数组中 在有序的基础下，假若要查找值X，分别设置left、mid、right三个下标值。每次时，查找mid = (left + right)/2，如若array[mid] &gt; X，则有mid = right - 1，如若array[mid] &lt; X，则有mid = left + 1，当left &lt;= right这个条件不成立时，跳出循环。 注意：每次更新的left和right不能为mid。 二分查找的过程实际上可以构造出一棵二分查找判定树，而在这棵判定树上，每个结点需要查找的次数刚好为该节点所在的层数。也就是说，查找成功时的查找次数不会超过判定树的深度，从而可以得到，n 个结点的判定树的深度为$[log_{2}n] + 1$，这里就又有了一个新的概念 — ASL, Average Search Length，平均查找次数（也叫平均查找长度，后面单独讲查找时会再次遇到） ,可得：$ASL = (4 \times 4 + 4 \times 3 + 2 \times 2 + 1) \div 11 = 3$。 代码如下：123456789101112int BinarySearch(StaticTable *Tbl, ElementType K) &#123; int left, right, mid, NotFound = -1; left = 1; right = Tbl-&gt;Length; while(left &lt;= right) &#123; mid = (left + right) / 2; if(K &lt; Tbl-&gt;ElementType[mid]) right = mid - 1; else if(K &gt; Tbl-&gt;ElementType[mid]) left = mid + 1; else return mid; &#125; return NotFound;&#125; 二分查找的时间复杂度前面已经分析过了是$O(logN)$。 树定义树（Tree）：n（n≥0）个结点构成的有限集合，当n=0时，称为空树，对于任何一棵非空树，它具备以下性质： 树中有一个称为“根（root）”的特殊节点，用r表示 其余结点可分为m（m＞0）个互不相交的有限集$T_1, T_2, \ldots, T_m$，其中每个集合本身又是一棵树，称为原来树的“子树（SubTree）”。注意： 子树不能相交 除了根节点，每个节点有且仅有一个父节点 一棵N个节点的树有N-1条边 树是保证连通且边数最少的一种连接方式 基本术语与树相关的基本术语如下： 结点的度（Degree）：结点的子树个数 树的度：树的所有结点中最大的度数 叶结点（Leaf）：度为 0 的结点 父结点（Parent）：有子树的结点是其子树的的根结点的父结点 子结点（Child）：若 A 结点是 B 结点的父结点，则称 B 结点是 A 结点的子结点，子结点也称为孩子结点 兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点 路径和路径长度：从结点 $n_1$ 到 $n_k$ 的路径为一个结点序列 $n_1, n_2, \ldots, n_k, n_i$ 是 $n_{i+1}$ 的父结点，路径所包含的个数为路径的长度。 祖先结点（Ancestor）：沿树根到某一结点路径上所有结点都是这个结点的祖先结点 子孙结点（Descendant）：某一结点的子树中的所有结点都是这个结点的子孙 结点的层次（Level）：规定根节点在1层，其他任一结点的层数是其父结点层数加1 树的深度（Depth）：树中所有结点中的最大层次是这棵树的深度 表示树的表示方法有多种，因需要表示其中的逻辑关系，一般会用链表实现，数组无法表示其中的逻辑关系。 儿子-兄弟表示法利用两个指针来保存逻辑关系，即：FirstChild指针用来保存第一个孩子结点的地址，NextSibling指针用来保存下一个兄弟结点的地址。这样，每个结点需要 2 个指针域，一棵树共有 $n-1$ 条边，这样浪费的指针域个数为 $2n - (n-1) = n+1$。 二叉树表示法二叉树简言之就是度为2的树，但相较度为 2 的树而言，二叉树的子树有左右之分。一般而言，所有能用儿子-兄弟表示法表示的树都可以用二叉树来表示，只需将儿子-兄弟表示法得到的树旋转 45° 即可得对应的二叉树。 二叉树前面提到过了用二叉树来表示树，但实际上二叉树自身也具有十分独特的性质。 定义二叉树T：一个有穷的结点集合。这个集合可以为空（空二叉树），若不为空，则它是由根结点和称为其左子树$T_L$和右子树$T_R$的两个不相交的二叉树组成。二叉树有五种基本形态：空树、单结点树、左子树为空的树、右子树为空的树和左右子树都不空的树。 注意：二叉树与普通度为2的树的区别在于，二叉树的子树有左右之分。 特殊二叉树（题目中也可能会出现）： 斜二叉树（Skewed Binary Tree）：只有左（右）子树，形状上呈现一边倒的样子，类似链表 完美二叉树（Perfect Binary Tree），也叫满二叉树（Full Binary Tree）：除了叶结点外，每一个结点都有两个儿子结点 完全二叉树（Complete Binary Tree）：有n个结点的二叉树，对树中结点按从上至下、从左到右顺序进行编号，编号为i（1≤i≤n）结点与满二叉树中编号为i结点在二叉树中位置相同。 性质二叉树的几个重要性质： 一个二叉树第 i 层的最大结点数为：$2^{i-1}, i \ge 1$。 深度为 k 的二叉树有最大结点树为：$2^k-1, k \ge 1$。 对任何非空二叉树T，若$n_0$表示叶结点的个数、$n_2$是度为2的非叶结点个数，那么两者满足关系$n_0 = n_2 + 1$，这个结论可证明。 二叉树抽象数据类型描述类型名称：二叉树数据对象集：一个有穷的结点集合，若不为空，则由根结点和其左、右二叉子树组成。操作集：BT ∈ BinTree，Item∈ ElementType，重要操作有： Boolean IsEmpty(BinTree BT)，判别BT是否为空 void Traversal(BinTree BT)，遍历，按照某顺序访问每个结点 BinTree CreatBinTree()，创建一个二叉树。 常见的遍历方法有： void PreOrderTraversal(BinTree BT)，先序遍历，根→左→右 void InOrderTraversal(BinTree BT)，中序遍历，左→根→右 void PostOrderTraversal(BinTree BT)，后序遍历，左→右→根 void LevelOrderTraversal(BinTree BT)，层次遍历，从上到下，从左到右 二叉树的顺序存储结构二叉树顺序存储一般直接使用（结构）数组实现，而完全二叉树直接用一维数组即可实现，也易于操作。对于使用数组表示的完全二叉树而言，可以通过结点的序号（数组的下标）中的规律来帮助反映结点之间的父子（逻辑）关系，具体如下： 非根结点（序号$i＞1$）的父结点的序号是$\lfloor i/2 \rfloor$ 结点（序号为$i$）的左孩子结点的序号是$2i$，若$2i \geqslant n$，否则没有左孩子 结点（序号为$i$）的左孩子结点的序号是$2i+1$，若$2i+1 \geqslant n$，否则没有右孩子 一般结构的二叉树也可以采用这种结构，但是会造成空间的浪费，因为数组中也存储了空结点。 二叉树的链式存储结构定义如下：123456struct TNode&#123; int data; struct TNode *left, *right;&#125;;typedef struct TNode* PtrToTNode;typedef PtrToTNode Tree; 二叉树的遍历二叉树的遍历既可以直接用递归的思想完成，也可以借助栈来构造非递归的遍历算法。尽管递归的缺点很明显，但好在易于理解，且形式简单，一般而言都是用递归来遍历二叉树。不过从学习的角度来讲，多探究一下没有任何坏处，所以下面的内容也给出非递归的算法。注：下面的代码有部分是 C++ 的内容，但并没有特别难于理解地方。 先序遍历遍历过程：访问根结点 → 先序遍历其左子树 → 先序遍历其右子树1234567891011121314151617181920212223void preorder(Tree root) &#123; /* method 1: use recursion if(!root) return; cout &lt;&lt; root-&gt;data &lt;&lt; ' '; preorder(root-&gt;left); preorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); root = root-&gt;right; &#125; &#125; &#125; 中序遍历遍历过程：先序遍历其左子树 → 访问根结点 → 先序遍历其右子树1234567891011121314151617181920212223void inorder(Tree root) &#123; /* method 1: use recursion if(!root) return; inorder(root-&gt;left); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; inorder(root-&gt;right); */ /* method 2: use loop and stack */ stack&lt;PtrToTNode&gt; st; while(root || !st.empty()) &#123; while(root) &#123; st.push(root); root = root-&gt;left; &#125; if(!st.empty()) &#123; root = st.top(); st.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; root = root-&gt;right; &#125; &#125;&#125; 后序遍历遍历过程：先序遍历其左子树 → 先序遍历其右子树 → 访问根结点后序遍历的非递归算法其实有很多，这里举两个例子，分别使用了 2 个栈和 1 个栈来完成，使用双栈的思路较为直观一些，建议动手模拟一下。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849void postorder(Tree root) &#123; /* method 1: use recursion if(!root) return; postorder(root-&gt;left); postorder(root-&gt;right); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; */ /* method 2: use loop and two stacks stack&lt;PtrToTNode&gt; st1, st2; while(root || !st1.empty()) &#123; while(root) &#123; st1.push(root); st2.push(root); root = root-&gt;right; &#125; if(!st1.empty()) &#123; root = st1.top(); st1.pop(); root = root-&gt;left; &#125; &#125; while(!st2.empty()) &#123; root = st2.top(); st2.pop(); cout &lt;&lt; root-&gt;data &lt;&lt; ' '; &#125; */ /* method 3: use loop and one stack */ stack&lt;PtrToTNode&gt; st; PtrToTNode pre = NULL, cur = NULL; st.push(root); while(!st.empty()) &#123; cur = st.top(); if(pre == NULL || pre-&gt;left == cur || pre-&gt;right == cur) &#123; if(cur-&gt;left != NULL) st.push(cur-&gt;left); else if(cur-&gt;right != NULL) st.push(cur-&gt;right); &#125; else if(cur-&gt;left == pre) &#123; if(cur-&gt;right != NULL) &#123; st.push(cur-&gt;right); &#125; &#125; else &#123; cout &lt;&lt; cur-&gt;data &lt;&lt; ' '; st.pop(); &#125; pre = cur; &#125;&#125; 层序遍历遍历过程：从第一层开始，从左往右依次访问每个结点。层序遍历一般用队列实现，也可以使用栈来实现。层序遍历一般采用迭代（循环）的思想来实现。123456789101112void levelorder(Tree root) &#123; queue&lt;PtrToTNode&gt; q; q.push(root); while(!q.empty()) &#123; PtrToTNode front = q.front(); q.pop(); cout &lt;&lt; front-&gt;data &lt;&lt; ' '; if(front-&gt;left) q.push(front-&gt;left); if(front-&gt;right) q.push(front-&gt;right); &#125; cout &lt;&lt; endl;&#125; 作业03-1 树的同构按照这道题目给定的数据形式，用静态链表的方式表示树，解起题来会比较方便（正如姥姥前面说过：合适的数据结构能够帮助我们解决问题），当然也可以动脑子想一想怎么用指针来解决。另外，在判断树是否同构时要注意问题考虑全面（读题仔细），理解递归的含义，“同构其实并没有要求树的结构完全一致，只要求结点分布一致即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define maxn 15struct TNode&#123; char data; int left, right;&#125; T1[maxn], T2[maxn];void init() &#123; int i; for(i = 0; i &lt; maxn; i++) &#123; T1[i].left = T1[i].right = T2[i].left = T2[i].right = -1; &#125;&#125;int buildtree(struct TNode T[]) &#123; int i, n; scanf("%d%*c", &amp;n); char data, lc, rc; bool isRoot[maxn] = &#123;false&#125;; for(i = 0; i &lt; n; i++) &#123; scanf("%c %c %c%*c", &amp;data, &amp;lc, &amp;rc); T[i].data = data; if(lc != '-') &#123; T[i].left = lc - '0'; isRoot[lc - '0'] = true; &#125; if(rc != '-') &#123; T[i].right = rc - '0'; isRoot[rc - '0'] = true; &#125; &#125; int root = -1; for(i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; return root;&#125;bool Isomorphic(int root1, int root2) &#123; if(root1 == -1 &amp;&amp; root2 == -1) return true; if((root1 == -1 &amp;&amp; root2 != -1) || (root1 != -1 &amp;&amp; root2 == -1)) return false; if(T1[root1].data != T2[root2].data) return false; if(T1[root1].left == -1 &amp;&amp; T2[root2].left == -1) &#123; return Isomorphic(T1[root1].right, T2[root2].left); &#125; if((T1[root1].left != -1 &amp;&amp; T2[root2].left != -1) &amp;&amp; (T1[T1[root1].left].data == T2[T2[root2].left].data)) &#123; return Isomorphic(T1[root1].left, T2[root2].left) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].right); &#125; else return Isomorphic(T1[root1].left, T2[root2].right) &amp;&amp; Isomorphic(T1[root1].right, T2[root2].left);&#125;int main() &#123; init(); int root1 = buildtree(T1); int root2 = buildtree(T2); if(Isomorphic(root1, root2)) printf("Yes"); else printf("No"); return 0;&#125;/*some samples:in:00out: Yes*/ 03-2 List Leaves题目要求找一棵树中的所有叶子结点（无孩子），顺序是从上到下，从左到右。如果要访问所有叶子结点，那么肯定少不了树的遍历。进而可以想到，题目要求的输出顺序与层序遍历的输出顺序是一致的。所以可以借助层序遍历的代码来构造输出叶子结点的算法。由于层序遍历需要用到队列，直接用 C++ 的 STL 内的 Queue。根据题目的形式，还是用静态链表的方法来表示树。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 20;struct node&#123; int left, right;&#125; Tree[maxn];bool isRoot[20] = &#123;false&#125;;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;void levelorder(int root) &#123; queue&lt;int&gt; q; q.push(root); bool flag = true; while(!q.empty()) &#123; int tmp = q.front(); q.pop(); if(Tree[tmp].left == -1 &amp;&amp; Tree[tmp].right == -1) &#123; if(flag) &#123; cout &lt;&lt; tmp; flag = false; &#125; else &#123; cout &lt;&lt; ' ' &lt;&lt; tmp; &#125; &#125; if(Tree[tmp].left != -1) q.push(Tree[tmp].left); if(Tree[tmp].right != -1) q.push(Tree[tmp].right); &#125;&#125;int main() &#123; init(); int n; cin &gt;&gt; n; char c1, c2; for(int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; c1 &gt;&gt; c2; if(c1 != '-') &#123; isRoot[c1 - '0'] = true; Tree[i].left = c1 - '0'; &#125; if(c2 != '-') &#123; isRoot[c2 - '0'] = true; Tree[i].right = c2 - '0'; &#125; &#125; int root; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; root = i; break; &#125; &#125; levelorder(root); return 0;&#125; 03-3 Tree Traversals Again题目考察二叉树的先序、中序和后序遍历（一道题目考到了树的三种遍历方法）。 题目背景是二叉树中序遍历的非递归算法的入、出栈顺序，实际上，入栈顺序就是先序序列，出栈顺序就是中序序列。这样可以使用先序序列和中序序列构造树，进而在通过后序遍历来输出后序序列。那么如何表示树呢？由于本题给定的数据并没有给出树的具体结构，实际上用链式结构或者顺序结构的复杂度都是一样的。 不过此题也可以不用构造树，直接通过递归来得到后序序列。不过不是那么好理解，建议手动模拟一下，笔试中也有类似的题目，思路本质上是一样的。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/* method 1: Do not build a tree. use recursion */#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5; int in[maxn], pre[maxn], post[maxn], n;void solve(int preL, int inL, int postL, int n) &#123; if(n == 0) return; if(n == 1) &#123; post[postL] = pre[preL]; return; &#125; int root = pre[preL], i; post[postL + n - 1] = root; for(i = 0; i &lt; n; i++) &#123; if(in[inL + i] == root) break; &#125; int L = i, R = n - L - 1; solve(preL + 1, inL, postL, L); solve(preL + L + 1, inL + L + 1, postL + L, R);&#125;int main() &#123; string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; solve(0, 0, 0, n); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; post[i]; if(i != n - 1) putchar(' '); &#125; return 0;&#125;/* method 2: use static tree #include &lt;iostream&gt;#include &lt;string&gt;#include &lt;stack&gt;using namespace std;const int maxn = 30 + 5;struct node&#123; int left, right; int data;&#125; Tree[maxn];int in[maxn], pre[maxn], n;void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Tree[i].left = Tree[i].right = -1; &#125;&#125;int buildtree(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) return -1; Tree[preL].data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) break; &#125; int numLeft = k - inL; Tree[preL].left = buildtree(preL + 1, preL + numLeft, inL, k - 1); Tree[preL].right = buildtree(preL + numLeft + 1, preR, k + 1, inR); return preL;&#125;int num = 0;void postorder(int root) &#123; if(root == -1) return; postorder(Tree[root].left); postorder(Tree[root].right); cout &lt;&lt; Tree[root].data; if(num &lt; n - 1) cout &lt;&lt; ' '; num++;&#125;int main() &#123; init(); string ope; int node, cnt1 = 0, cnt2 = 0; cin &gt;&gt; n; stack&lt;int&gt; st; for(int i = 0; i &lt; 2 * n; i++) &#123; cin &gt;&gt; ope; if(ope == "Push") &#123; cin &gt;&gt; node; pre[cnt1++] = node; st.push(node); &#125; else if(ope == "Pop") &#123; in[cnt2++] = st.top(); st.pop(); &#125; &#125; buildtree(0, n - 1, 0, n - 1); postorder(0); return 0;&#125;*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_02-线性结构]]></title>
    <url>%2F2020%2F02%2F12%2FZJU-DS-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[什么是线性结构？如何表示和实现？有哪些线性结构？对应的有什么样性质？常见的应用有哪些？ Linear List在介绍线性表之前，何老师先介绍了线性表的一个应用实例 —— 一元多项式及其运算。而关于一元多项式的表示方法，老师介绍了三种方法： 数组（顺序存储结构）直接表示，数组下标对应未知数 x 的指数，数组元素的值对应各项的系数，但对于某些特殊的多项式，此法会有较多的空间浪费。 结构数组（顺序存储结构）表示非零项，将一个多项式看成是一个指数与系数的二元组的集合，多项式的每一项需按照指数大小有序存储。 链表存储非零项，链表中每个结点存储多项式中的一个非零项，包括系数和指数两个数据域和一个指针域。 上述三种方法中，利用数组表示是易于实现的，但是不易设计与多项式相关的加减操作。而使用链表来表示十分灵活，且易于实现对应操作。从这可以看出，同一个问题可以有不同的表示（存储）方法；存在一类共性问题，即：有序线性序列的组织和管理。由此可以引出线性表的概念：由同类型数据元素构成有序序列的线性结构，具备以下三个特点： 表中元素个数称为线性表的长度 线性表没有元素时，称为空表 表起始位置称表头，表结束位置称表尾 线性表的抽象数据类型描述类型名称：线性表（List）数据对象集：线性表是$n(≥0)$个元素构成的有序序列操作集：线性表$L ∈ List$，整数$i$表示位置，元素$X ∈ ElementType$，主要操作： List MakeEmpty()，初始化一个空线性表 ElementType FindKth(int K, List L)，根据位序K，返回相应元素 int Find(ElementType X, List L)，在线性表L中查找X的第一次出现为止 void Insert(ElementType X, int i, List L)，在位序i前插入一个新元素X void Delete(int i, List L)，删除指定位序i的元素 int Length(List L)，返回线性表L的长度n 线性表的顺序存储实现顺序表的顺序存储实现利用数组来连续存储空间顺序存放线性表的各元素，C 语言版本的定义（后文的代码都是 C 语言的）如下：1234567typedef int ElementType;typedef int Position; /*note here! */typedef struct LNode* List; /* struct LNode * = List */struct LNode&#123; ElementType Data[MAXSIZE]; /* #define MAXSIZE 100 */ Position Last; /* the length of list */&#125;; 初始化（建立空表）按照上面的定义，我们可以写出建立空表的操作。123456List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; /*use -1 to represent that the list is blank */ return L;&#125; 查找前面一讲中，我们已经学会了二分查找，那么二分查找是否能在此处应用呢？要注意的是，二分查找的前提条件有两个： 顺序存储和数据有序。 这里我们采用按照顺序从前往后查找的方法来编写这个操作，需要将被查找的数据元素和所查找的线性表交给函数。当然，如果线性表是全局变量，那么可以不用传入线性表，这里假设线性表是在main函数中声明的。12345678Position Find(ElementType X, List L) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return -1; /*can't find the element*/ else return i; /*return the index of this element*/&#125; 那么该如何计算查找成功的平均比较次数呢？假设有 n 个元素，如果第一个元素就是我们要查找的元素，那么此时查找成功的比较次数就是 1 次；继而可知当第二个元素就是我们要查找的元素时，查找成功的比较次数就是 2 次；从而我们可以知道对于 n 个元素的线性表查找成功的比较次数就是：$(1 + 2 + ... + n) / n = (1 + n) / 2$。这说明这种思路的查找算法的平均时间性能是$O(n)$。 插入在直接上手写插入操作之前需要想一想插入操作的几种情况：表头、表中和表尾。针对这三种不同的情况，我们可以发现只有当在表尾插入的时候才不需要将元素移动；同时，在每一次插入操作时，由于线性表可能已经满了，那么插入操作就会失败了，这也是需要考虑的情况，接着，我们来写一下代码。12345678910111213141516void Insert(ElementType X, int i, List PtrL) &#123; int j; if(PtrL-&gt;Last == MAXSIZE - 1) &#123; printf("The list is full.\n"); return; &#125; if(i &lt; 1 || i &gt; PtrL-&gt;Last + 2) &#123; printf("The position of the insertion is not valid.\n"); return; &#125; for(j = PtrL-&gt;Last; j &gt;= i - 1; j--) &#123; PtrL-&gt;Data[j + 1] = PtrL-&gt;Data[j]; &#125; PtrL-&gt;Data[i - 1] = X; PtrL-&gt;Last++;&#125; 从上述代码可以看出： 由于线性表的顺序存储结构借助了数组，所以当数组下标为$MAXSIZE - 1$时，表示线性表已满。 当插入位置 i 小于 1 或者大于PtrL-&gt;Last + 2时，插入位置就是不合法的。之所以大于PtrL-&gt;Last + 2不合法是因为，当PtrL-&gt;Last == MAXSIZE - 2时，PtrL-&gt;Last + 2 == MAXSIZE，那么 i 就大于了MAXSIZE，那就超出范围了。这里要区分好两个概念：插入位置和存储位置。插入位置是人为规定且从 1 开始的（符合人的思考习惯），而存储位置是从 0 开始的，因为数组下标是从 0 开始的。后面的移动操作也是基于这个前提来编写的。 所插入位置后的全部元素需要向后移动。 删除有了插入操作的基础，删除操作就比较容易了，因为我们只需先找到要删除的元素，然后将此元素后的所有元素向前移动一个位置即可，但是要注意表为空的情况，代码如下：123456789101112void Delete(int P, List PtrL) &#123; Position i; if(P &lt; 1 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define MAXSIZE 10#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;List MakeEmpty() &#123; List L; L = (List)malloc(sizeof(struct LNode)); L-&gt;Last = -1; return L;&#125;Position Find(List L, ElementType X) &#123; Position i = 0; while(i &lt;= L-&gt;Last &amp;&amp; L-&gt;Data[i] != X) &#123; i++; &#125; if(i &gt; L-&gt;Last) return ERROR; else return i;&#125;bool Insert(List L, ElementType X, Position P) &#123; Position i; if(L-&gt;Last == MAXSIZE - 1) &#123; printf("Sequence List is full!\n"); return false; &#125; if(P &lt; 1 || P &gt; L-&gt;Last + 2) &#123; printf("The inserting position is illegal!\n"); return false; &#125; for(i = L-&gt;Last; i &gt;= P - 1; i--) &#123; L-&gt;Data[i + 1] = L-&gt;Data[i]; &#125; L-&gt;Data[P - 1] = X; L-&gt;Last++; return true;&#125;bool Delete(List L, Position P) &#123; Position i; if(P &lt; 0 || P &gt; L-&gt;Last) &#123; printf("The deleting position is illegal!\n"); return false; &#125; for(i = P + 1; i &lt;= L-&gt;Last; i++) &#123; L-&gt;Data[i - 1] = L-&gt;Data[i]; &#125; L-&gt;Last--; return true;&#125;void Print(List L) &#123; if(L-&gt;Last == -1) printf("The Sequence List is empty!\n"); else &#123; int i = 0; while(i &lt; L-&gt;Last) &#123; printf("%d, ", L-&gt;Data[i]); i++; &#125; printf("%d\n", L-&gt;Data[i]); &#125;&#125;int main() &#123; List Sqlist = MakeEmpty(); bool flag = Insert(Sqlist, 11, 0); printf("flag = %d\n", flag); Insert(Sqlist, 22, 1); Insert(Sqlist, 33, 2); Insert(Sqlist, 44, 3); Print(Sqlist); bool del_flag = Delete(Sqlist, 2); printf("del_flag = %d\n", del_flag); Print(Sqlist); &#125; 线性表的链式存储实现线性表的链式存储实现就是大家熟知的链表了，学过 C 语言的同学可能已经学会了如何构造、使用链表等。相比顺序表而言，链表的最突出的一个特点就是不再要求顺序存储了，也就是说，链表中的各个元素在内存中的位置是不一定相邻的。先看一下链表的定义：123456789#define ERROR NULLtypedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List; 这里使用不同的关键词来表示指向链表的指针，这样在后面的各种操作中可以区分各个指针的作用，让读代码的人更加易于从单词意思来理解代码。 初始化（建立空表）链表建立空表的基本方法有头插法和尾插法，使用不同的方法建立链表可以得到不同的效果，可以方便我们解决问题，以下代码以带头结点的单链表为说明对象。 求表长链表不同于顺序表，顺序表的表厂是限定的，但是链表的长度是无限的（假设内存无限），所以自然就会有求链表表长的问题产生。解决这个问题的最直观的思路也就是将链表遍历（从头结点访问到尾结点）一遍即可，代码如下：123456789int GetLength(List L) &#123; List p = L-&gt;Next; /*Let's say the linked list has head node. */ int length = 0; while(p) &#123; p = p-&gt;Next; length++; &#125; return length;&#125; 查找链表的查找有两种情况，分别是：按序号查找和按值查找。这两种查找方法思路比较简单，本质上都是对链表进行遍历。 按序号查找12345678910List FindKth(int K, List PtrL) &#123; List p = PtrL; int i = 1; while(p != NULL &amp;&amp; i &lt; K) &#123; p = p-&gt;Next; i++; &#125; if(i == K) return p; else return NULL;&#125; 按值查找123456Position Find(ElementType X, List L) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125; 插入往链表中插入一个结点，那么就需要先构造一个新的结点，然后再将这个新的结点插入到链表中。那么，如何进行插入呢？ 假如要插入到第 i 个位置，那么就必须先要找到第 i - 1 个位置，然后再将这个新结点插入到第 i - 1 个结点的后面。另外，此处链式结构的指针应用一直是让初学者头疼的问题。但实际上，分析这类问题时，都有一个原则：必须要先让新结点指向后面的结点，才能再让前面的结点指向新结点。这点其实也不难理解，假如让前面的结点先指向新结点，那么后面的结点就丢失了，因为指向后面的结点的唯一指针（即前面结点的指针）已经指向了新结点。话说起来是很拗口且不那么直观，建议用笔在纸上画一画。 按照不同的查找方法，也可以给出不同的插入方法。 按序号插入1234567891011121314151617181920bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125; 按值插入1234567891011121314151617bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125; 删除由于我们已经明确了查找的方式，所以删除操作可以简化一些了，只要确保指向被删除元素的指针正确传给删除函数即可。12345678910111213141516bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125; 测试代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;#define ERROR NULL#define MAXSIZE 10typedef int ElementType;typedef struct LNode* PtrToLNode;struct LNode&#123; ElementType Data; PtrToLNode Next;&#125;;typedef PtrToLNode Position;typedef PtrToLNode List;Position Find(List L, ElementType X) &#123; Position p = L; while(p &amp;&amp; p-&gt;Data != X) p = p-&gt;Next; if(p) return p; else return ERROR;&#125;Position FindKth(List L, int k) &#123; PtrToLNode p = L; int i = 0; while(p &amp;&amp; i &lt; k) &#123; i++; p = p-&gt;Next; &#125; if(i == k) return p; else return NULL;&#125;List MakeEmpty() &#123; List L = (List)malloc(sizeof(struct LNode)); L-&gt;Next = NULL; return L;&#125;PtrToLNode CreateLNode(int value) &#123; PtrToLNode t = (PtrToLNode)malloc(sizeof(struct LNode)); t-&gt;Next = NULL; t-&gt;Data = value; return t;&#125;bool Insert_1(List L, ElementType X, Position P) &#123; if(P == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = CreateLNode(X); tmp-&gt;Next = P; pre-&gt;Next = tmp; return true; &#125;&#125;bool Insert_2(List L, ElementType X, int k) &#123; List pre, tmp; if(k == 1) &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = L-&gt;Next; L-&gt;Next = tmp; &#125; pre = FindKth(L, k); if(pre == NULL) &#123; printf("The inserting position is illegal!\n"); return false; &#125; else &#123; tmp = (PtrToLNode)malloc(sizeof(struct LNode)); tmp-&gt;Data = X; tmp-&gt;Next = pre-&gt;Next; pre-&gt;Next = tmp; return true; &#125;&#125;bool Delete(List L, Position P) &#123; if(P == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; Position tmp, pre; for(pre = L; pre &amp;&amp; pre-&gt;Next != P; pre = pre-&gt;Next); if(pre == NULL) &#123; printf("The deleting position is illegal!\n"); return false; &#125; else &#123; pre-&gt;Next = P-&gt;Next; free(P); return true; &#125;&#125;void Print(List L) &#123; if(L-&gt;Next == NULL) printf("The link list is empty!\n"); else &#123; L = L-&gt;Next; while(L-&gt;Next != NULL) &#123; printf("%d, ", L-&gt;Data); L = L-&gt;Next; &#125; printf("%d\n", L-&gt;Data); &#125;&#125;int main() &#123; List L = MakeEmpty(); PtrToLNode t = CreateLNode(11); L-&gt;Next = t; Print(L); int ins_flag = Insert_1(L, 22, Find(L, 11)); printf("ins_flag = %d\n", ins_flag); Print(L); Insert_1(L, 33, Find(L, 22)); Insert_1(L, 44, Find(L, 33)); Print(L); int del_flag = Delete(L, Find(L, 33)); printf("del_flag = %d\n", del_flag); Print(L); printf("/*--------------------*/\n"); Insert_2(L, 55, 3); Print(L); Insert_2(L, 8, 2); Print(L); printf("%d\n", Insert_2(L, 9, 10)); Print(L); return 0;&#125; Generalized List关于广义表的含义，何老师的 PPT 里面说的比较清楚了，即: 广义表是线性表的推广 对于广义表而言，n 个元素都是基本的单元素 广义表中，这些元素不仅可以是单元素也可以是另一个广义表 其实说白了，广义表是个大集合，囊括了线性表这个小集合。 关于多重链表，其实是广义表的一种应用，也即线性表中的每一个“结点”，又是一个线性表。多重链表多应用与于树（线索二叉树等）和图（十字链表等）这类复杂的数据结构，当然，树和图也可以不采用多重链表来存储。 Stack堆栈（Stack），具有一定操作约束的线性表，只在一端（栈顶，Top）做插入、删除操作。插入数据：入栈（Push）删除数据：出栈（Pop）后入先出：Last In First Out（LIFO） 堆栈的抽象数据类型描述类型名称：堆栈（Stack）数据对象集：一个有0个或多个元素的有穷线性表操作集：长度为MaxSize的堆栈S ∈ Stack，堆栈元素item ∈ ElementType，主要操作： Stack CreateStack(int MaxSize)，生成空堆栈，其最大长度为MaxSize int IsFull(Stack S, int MaxSize)，判断堆栈S是否已满 void Push(Stack S, ElementType item)，将元素item压入堆栈 int IsEmpty(Stack S)，判断堆栈S是否为空 ElementType Pop(Stack S)，删除并返回栈顶元素 栈的顺序存储实现栈的顺序存储结构通常由一个一维数组和一个记录栈顶元素位置的变量组成，C 语言版本的定义如下：12345678910#define MAXSIZE 10 /*store the maximum number of data*/#define ERROR -1typedef int ElementType;typedef int Position;typedef struct LNode* List;struct LNode&#123; ElementType Data[MAXSIZE]; Position Last; &#125;;typedef struct SNode *Stack; 初始化（建立空栈）1234567Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125; 判断栈满123bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125; 判断栈空123bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125; 入栈由于顺序栈是由数组存储，而数组有大小，当数组没有空间的时候就无法进行入栈操作，所以在入栈操作之前就必须要判断栈是否满了。123456789bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125; 出栈与入栈操作类似，当栈为空时，显然无法进行出栈操作。12345678ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125; 求栈内元素个数123int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct SNode&#123; ElementType *Data; Position Top; int MaxSize;&#125;;typedef struct SNode *Stack;Stack Createstack(int MaxSize) &#123; Stack S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Data = (ElementType*)malloc(MaxSize * sizeof(ElementType)); S-&gt;Top = -1; S-&gt;MaxSize = MaxSize; return S; &#125;bool Isfull(Stack S) &#123; return S-&gt;Top == S-&gt;MaxSize - 1;&#125;bool Push(Stack S, ElementType X) &#123; if(Isfull(S)) &#123; printf("The stack is full!\n"); return false; &#125; else &#123; S-&gt;Data[++S-&gt;Top] = X; return true; &#125;&#125;bool Isempty(Stack S) &#123; return S-&gt;Top == -1;&#125;ElementType Pop(Stack S) &#123; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; return S-&gt;Data[S-&gt;Top--]; &#125;&#125;int Getsize(Stack S) &#123; return S-&gt;Top + 1;&#125;int main() &#123; Stack S = Createstack(5); Pop(S); printf("S.size = %d\n", Getsize(S)); int push_flag = Push(S, 11); Push(S, 22); Push(S, 33); int x = Pop(S); printf("push_flag = %d, x = %d\n", push_flag, x); printf("S.size = %d\n", Getsize(S)); Push(S, 33); Push(S, 44); Push(S, 55); Push(S, 66); printf("S.size = %d\n", Getsize(S)); return 0;&#125; 栈的链式存储结构实现栈的链式存储结构实际上就是一个单链表，叫做链栈。插入和删除操作只能在链栈的栈顶进行，注意栈顶指针 top 只能在链表的表头。1234567typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack; 初始化（建立空栈）123456Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125; 入栈由于链栈是通过申请内存构造结点的，所以理论上不存在栈满的情况（内存满了就不能分配空间了）。1234567bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125; 判断栈空尽管链栈不用判断栈满，但是在进行出栈操作时需要判断栈是否为空。123bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125; 出栈1234567891011121314ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125; 求栈内元素个数12345678int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125; 测试代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct SNode* PtrToSNode;struct SNode&#123; ElementType Data; struct SNode *Next;&#125;;typedef PtrToSNode Stack;Stack Createstack() &#123; Stack S; S = (Stack)malloc(sizeof(struct SNode)); S-&gt;Next = NULL; return S;&#125;bool Isempty(Stack S) &#123; return S-&gt;Next == NULL; &#125;bool Push(Stack S, ElementType X) &#123; PtrToSNode tmpcell = (PtrToSNode)malloc(sizeof(struct SNode)); tmpcell-&gt;Data = X; tmpcell-&gt;Next = S-&gt;Next; S-&gt;Next = tmpcell; return true;&#125;ElementType Pop(Stack S) &#123; PtrToSNode firstcell; ElementType topelem; if(Isempty(S)) &#123; printf("The stack is empty!\n"); return false; &#125; else &#123; firstcell = S-&gt;Next; topelem = firstcell-&gt;Data; S-&gt;Next = firstcell-&gt;Next; free(firstcell); return topelem; &#125;&#125;int Getsize(Stack S) &#123; int size = 0; while(S-&gt;Next != NULL) &#123; S = S-&gt;Next; size++; &#125; return size;&#125;int main() &#123; Stack S = Createstack(); Pop(S); printf("S.size = %d\n", Getsize(S)); Push(S, 11); Push(S, 22); Push(S, 33); printf("S.top = %d\n", Pop(S)); Push(S, 33); Push(S, 44); Push(S, 55); printf("S.size = %d\n", Getsize(S)); return 0;&#125; Queue队列也是具有一定操作约束的线性表（与堆栈类似），只能在一端插入，而在另一端删除。数据插入：入队列（AddQ）数据删除：出队列（DeleteQ）先来先服务，先进先出，First In First Out，FIFO 队列的抽象数据类型描述类型名称：队列（Queue）数据对象集：一个有0个或多个元素的有穷线性表操作集：长度为MaxSize的队列Q ∈ Queue，队列元素item ∈ ElementType，主要操作： Queue CreatQueue(int MaxSize)，生成长度为MaxSize的空队列 int IsFullQ(Queue Q, int MaxSize)，判断队列Q是否已满 void AddQ(Queue Q, ElementType item)，将数据元素item插入队列Q中 int IsEmptyQ(Queue Q)，判断队列Q是否为空 ElementType DeleteQ(Queue Q)，将对头数据元素从队列中删除并返回 队列的顺序存储实现队列的顺序存储实现与顺序栈的实现方式相同，还是需要借助一个数组来存储元素。但与栈不同的是队列需要有队头（front）指针和队尾（rear）指针，定义如下：12345678typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; 初始化（建立空队列）1234567Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125; 判断队空123bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125; 判断队满123bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125; 入队为了更好的利用数组，采取循环队列的设计方法，借助取余运算刚好可以满足要求，出队时同理。12345678910bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125; 出队123456789ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125; 求队列中元素个数123int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef int Position;struct QNode&#123; ElementType *Data; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue Q = (Queue)malloc(sizeof(struct QNode)); Q-&gt;Data = (ElementType*)malloc(sizeof(MaxSize * sizeof(ElementType))); Q-&gt;Front = Q-&gt;Rear = 0; Q-&gt;MaxSize = MaxSize; return Q;&#125;bool Isfull(Queue Q) &#123; return (Q-&gt;Rear + 1) % Q-&gt;MaxSize == Q-&gt;Front;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; Q-&gt;Rear = (Q-&gt;Rear + 1) % Q-&gt;MaxSize; Q-&gt;Data[Q-&gt;Rear] = X; return true; &#125;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == Q-&gt;Rear;&#125;ElementType Deleteq(Queue Q) &#123; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Q-&gt;Front = (Q-&gt;Front + 1) % Q-&gt;MaxSize; return Q-&gt;Data[Q-&gt;Front]; &#125;&#125;int Getsize(Queue Q) &#123; return (Q-&gt;Rear + Q-&gt;MaxSize - Q-&gt;Front) % Q-&gt;MaxSize; &#125;void print(Queue q) &#123; int i; for(i = 0; i &lt; 5; i++) &#123; printf("%d ", q-&gt;Data[i]); &#125; putchar('\n');&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); printf("%d\n", Getsize(q)); Addq(q, 22); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 33); Addq(q, 44); Addq(q, 55); print(q); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); Addq(q, 66); x = Deleteq(q); x = Deleteq(q); Addq(q, 66); printf("q-&gt;front = %d, q-&gt;rear = %d\n", q-&gt;Front, q-&gt;Rear); printf("q.size = %d\n", Getsize(q)); return 0;&#125; 队列的链式存储实现队列的链式存储实现要比链栈的实现稍微复杂一点，需要有一个单独的队列结构（包含队头指针和队尾指针）来指向队列，定义如下：123456789101112typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue; 初始化（建立空队列）123456Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125; 求队列中元素个数123456789int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125; 判断队空123bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125; 判断队满由于上述定义设置的有MaxSize，默认链队列是有最大空间的，所以需要判断队列是否为满。1234bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125; 入队12345678910111213141516bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125; 出队123456789101112131415ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125; 测试代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdbool.h&gt;typedef int ElementType;typedef struct Node* PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode Position;struct QNode &#123; Position Front, Rear; int MaxSize;&#125;;typedef struct QNode* Queue;Queue Createqueue(int MaxSize) &#123; Queue q = (Queue)malloc(sizeof(struct QNode)); q-&gt;Front = q-&gt;Rear = NULL; q-&gt;MaxSize = MaxSize; return q;&#125;bool Isempty(Queue Q) &#123; return Q-&gt;Front == NULL;&#125;ElementType Deleteq(Queue Q) &#123; Position Frontcell; ElementType Frontelem; if(Isempty(Q)) &#123; printf("The queue is empty!\n"); return false; &#125; else &#123; Frontcell = Q-&gt;Front; if(Q-&gt;Front == Q-&gt;Rear) Q-&gt;Front = Q-&gt;Rear = NULL; else Q-&gt;Front = Q-&gt;Front-&gt;Next; Frontelem = Frontcell-&gt;Data; free(Frontcell); return Frontelem; &#125;&#125;int Getsize(Queue Q) &#123; int count = 0; PtrToNode p = Q-&gt;Front; while(p) &#123; count++; p = p-&gt;Next; &#125; return count;&#125;bool Isfull(Queue Q) &#123; if(Getsize(Q) &gt;= Q-&gt;MaxSize) return true; else return false;&#125;bool Addq(Queue Q, ElementType X) &#123; if(Isfull(Q)) &#123; printf("The queue is full!\n"); return false; &#125; else &#123; PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = X; t-&gt;Next = NULL; if(Isempty(Q)) Q-&gt;Front = Q-&gt;Rear = t; else &#123; Q-&gt;Rear-&gt;Next = t; Q-&gt;Rear = t; &#125; return true; &#125;&#125;int main() &#123; Queue q = Createqueue(5); int x = Deleteq(q); Addq(q, 11); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d\n", x); Addq(q, 11); Addq(q, 22); Addq(q, 33); Addq(q, 44); Addq(q, 55); Addq(q, 66); printf("q.size = %d\n", Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); x = Deleteq(q); printf("x = %d, q.size = %d\n", x, Getsize(q)); return 0;&#125; Homework02-1 两个有序链表序列的合并此题考察链表的合并操作，注意链表有序且给定链表带头结点，要求合并后链表为非递减序列，所以需要对每一个结点值进行比较，代码如下（其中函数体为需要提交的代码）：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef int ElementType;typedef struct Node *PtrToNode;struct Node &#123; ElementType Data; PtrToNode Next;&#125;;typedef PtrToNode List;List Read();void Print( List L );List Merge( List L1, List L2 );int main()&#123; List L1, L2, L; L1 = Read(); L2 = Read(); L = Merge(L1, L2); Print(L); Print(L1); Print(L2); return 0;&#125;List Read() &#123; int i, n, temp; scanf("%d", &amp;n); List L, p; L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; for(i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); PtrToNode t = (PtrToNode)malloc(sizeof(struct Node)); t-&gt;Data = temp; t-&gt;Next = NULL; p-&gt;Next = t; p = t; &#125; return L;&#125;void Print( List L ) &#123; PtrToNode p = L-&gt;Next; if(!p) &#123; printf("NULL\n"); return; &#125; while(p-&gt;Next != NULL) &#123; printf("%d ", p-&gt;Data); p = p-&gt;Next; &#125; printf("%d\n", p-&gt;Data);&#125;List Merge( List L1, List L2 ) &#123; PtrToNode p, p1 = L1-&gt;Next, p2 = L2-&gt;Next; L1-&gt;Next = L2-&gt;Next = NULL; List L = (List)malloc(sizeof(struct Node)); L-&gt;Next = NULL; p = L; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;Data &lt; p2-&gt;Data) &#123; p-&gt;Next = p1; p = p1; p1 = p1-&gt;Next; &#125; else &#123; p-&gt;Next = p2; p = p2; p2 = p2-&gt;Next; &#125; &#125; if(p1) p-&gt;Next = p1; if(p2) p-&gt;Next = p2; return L;&#125; 02-2 一元多项式的乘法与加法运算这道题的何老师已经讲过了，按照何老师给的思路，补全所有代码即可（最底下提供了几组测试用例）。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct PolyNode* Polynomial;typedef struct PolyNode* PtrToPolyNode;struct PolyNode &#123; int coef, expon; struct PolyNode *link;&#125;;PtrToPolyNode CreateNode(int c, int e) &#123; PtrToPolyNode t = (PtrToPolyNode)malloc(sizeof(struct PolyNode)); t-&gt;coef = c, t-&gt;expon = e; t-&gt;link = NULL; return t;&#125;Polynomial ReadPoly() &#123; int n, c, e; scanf("%d", &amp;n); Polynomial P, p; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; if(n == 0) &#123; PtrToPolyNode t = CreateNode(0, 0); p-&gt;link = t; &#125; else &#123; while(n--) &#123; scanf("%d %d", &amp;c, &amp;e); PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; &#125; return P;&#125;void Print(Polynomial P) &#123; if(P-&gt;link == NULL) &#123; printf("0 0\n"); return; &#125; else &#123; P = P-&gt;link; while(P-&gt;link != NULL) &#123; printf("%d %d ", P-&gt;coef, P-&gt;expon); P = P-&gt;link; &#125; printf("%d %d\n", P-&gt;coef, P-&gt;expon); &#125;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2 = P2-&gt;link; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; p = P; while(p1 &amp;&amp; p2) &#123; if(p1-&gt;expon == p2-&gt;expon) &#123; int e = p1-&gt;expon, c = p1-&gt;coef + p2-&gt;coef; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); p-&gt;link = t; p = t; &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else if(p1-&gt;expon &gt; p2-&gt;expon) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; else &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; &#125; while(p1 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p1-&gt;coef, p1-&gt;expon); p-&gt;link = t; p = t; p1 = p1-&gt;link; &#125; while(p2 &amp;&amp; p1-&gt;coef != 0) &#123; PtrToPolyNode t = CreateNode(p2-&gt;coef, p2-&gt;expon); p-&gt;link = t; p = t; p2 = p2-&gt;link; &#125; return P;&#125;Polynomial Multi(Polynomial P1, Polynomial P2) &#123; Polynomial P, p, p1 = P1-&gt;link, p2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; while(p1) &#123; p2 = P2-&gt;link; while(p2) &#123; int c = p1-&gt;coef * p2-&gt;coef; int e = p1-&gt;expon + p2-&gt;expon; p = P; while(p-&gt;link != NULL &amp;&amp; p-&gt;link-&gt;expon &gt; e) p = p-&gt;link; if(p-&gt;link != NULL) &#123; if(p-&gt;link-&gt;expon == e) &#123; int ctmp = p-&gt;link-&gt;coef + c; if(ctmp == 0) &#123; PtrToPolyNode tmp = p-&gt;link; p-&gt;link = tmp-&gt;link; free(tmp); &#125; else &#123; p-&gt;link-&gt;coef = ctmp; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; &#125; else &#123; if(c != 0) &#123; PtrToPolyNode t = CreateNode(c, e); t-&gt;link = p-&gt;link; p-&gt;link = t; &#125; &#125; p2 = p2-&gt;link; &#125; p1 = p1-&gt;link; &#125; return P;&#125;int main() &#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PS = Add(P1, P2); PP = Multi(P1, P2); Print(PP); Print(PS); return 0;&#125;/*some samples:in:1 -1 11 1 1out:-1 20 0in:2 -1 1 2 01 1 1out:-1 2 2 12 0in:2 1 1 1 02 1 1 -1 0out:1 2 -1 02 1in:4 3 4 -5 2 6 1 -2 03 5 20 -7 4 3 1out:15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 15 20 -4 4 -5 2 9 1 -2 0in:1 0 03 1 3 1 2 1 1out:0 01 3 1 2 1 1in:2 2 0 0 03 3 2 2 1 1 0out:6 2 4 1 2 03 2 2 1 3 0in:01 10 0out:0 010 0*/ 02-3 Reversing Linked List此题题意比较直接，但是测试点比较多，要考虑全面。推荐使用静态链表的方法解题，这样耗时较少。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#include &lt;stdio.h&gt;#define maxn 100005int addr[maxn], address[maxn], data[maxn], next[maxn];void reverse(int A[], int left, int right) &#123; for(; left &lt; right; left++, right--) &#123; int temp = A[left]; A[left] = A[right]; A[right] = temp; &#125;&#125;int main() &#123; int src, n, k, m; scanf("%d %d %d", &amp;src, &amp;n, &amp;k); m = n; int tmp_add, tmp_data, tmp_next; while(m--) &#123; scanf("%d %d %d", &amp;tmp_add, &amp;tmp_data, &amp;tmp_next); address[tmp_add] = tmp_add; next[tmp_add] = tmp_next; data[tmp_add] = tmp_data; &#125; int len = 1, i, j, tmp = src; addr[0] = src; while(src != -1) &#123; addr[len++] = next[src]; src = next[src]; &#125; for(i = 0, j = k; j &lt;= len - 1; i = j, j += k) &#123; reverse(addr, i, j - 1); &#125; for(i = 0; i &lt; len - 2; i++) &#123; src = addr[i]; printf("%05d %d %05d\n", src, data[src], addr[i + 1]); &#125; printf("%05d %d -1\n", address[addr[i]], data[addr[i]]); return 0;&#125;/*some samples:in:00100 6 600000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:68237 6 9999999999 5 0000000000 4 3321833218 3 1230912309 2 0010000100 1 -1in:00100 6 300000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:33218 3 1230912309 2 0010000100 1 6823768237 6 9999999999 5 0000000000 4 -1in:00100 6 100000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218out:00100 1 1230912309 2 3321833218 3 0000000000 4 9999999999 5 6823768237 6 -1in:00100 5 300000 4 9999900100 1 1230933218 3 0000099999 5 -112309 2 33218out:33218 3 1230912309 2 0010000100 1 0000000000 4 9999999999 5 -1in:00100 9 200000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 3321833333 7 2222244444 8 1111103333 9 02222out:12309 2 0010000100 1 0000000000 4 3321833218 3 6823768237 6 9999999999 5 -1in:00100 3 200100 1 -111111 2 2222233333 3 44444out:00100 1 -1*/ 02-4 Pop Sequence本题考察栈的相关知识，本质上是模拟栈的相关操作，推荐使用 C++ 自带的 STL 模板里面的 Stack ，可以直接拿来使用，但需要先了解一下用法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1000 + 10;int seq[maxn];int main() &#123; int m, n, k; cin &gt;&gt; m &gt;&gt; n &gt;&gt; k; bool flag = true; while(k--) &#123; stack&lt;int&gt; st; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; seq[i]; &#125; bool flag = true; int i = 1, j = 1; while(j &lt;= n + 1) &#123; if(st.size() &gt; m) &#123; flag = false; break; &#125; if(!st.empty()) &#123; if(st.top() == seq[i]) &#123; st.pop(); i++; &#125; else st.push(j++); &#125; else st.push(j++); &#125; if(flag &amp;&amp; st.size() == 1) cout &lt;&lt; "YES" &lt;&lt; endl; else cout &lt;&lt; "NO" &lt;&lt; endl; &#125; return 0;&#125; /*some samples:in:5 7 15 6 4 3 7 2 1out:YESsome sample:in:2 4 41 2 3 42 1 3 41 2 4 33 1 2 4out:YESYESYESNO*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ZJU_DS_01-基本概念]]></title>
    <url>%2F2020%2F02%2F11%2FZJU-DS-01-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[此篇系列博文是博主自己在 MOOC 上自学浙江大学数据结构课程时的笔记，每一讲都有对应的笔记，对应一篇博文。虽然之前上课时就做好了笔记，但对很多知识点的理解比较浅显，现在回过头来整理，希望会有所启发。另外，自学之路难免会有错误，欢迎看到文章的同学不吝赐教。另外，题解代码在 Github 上的地址：201909_MOOC_DS_ChenYue What is Data Structure何谓数据结构？按照姥姥的讲解，没有特定的数据结构的定义。不过，通过课上姥姥举的一些例子，可以得出：数据结构就是数据对象在计算机中的组织方式。具体而言，数据对象包含： 逻辑结构：第一次学数据结构的人可能会对这个概念有点懵，如果已经掌握了一门程序设计语言，并且具备了一定的水平的话，理解起来还是比较容易的。这里举个例子，比如律诗的逻辑结构就是：首联、颔联、颈联和尾联。 物理存储结构：可以暂时理解为硬盘之类的存储器的结构。 当然，也可以使用抽象数据类型（Abstract Data Type）来描述数据结构，包括： 数据对象集：简而言之就是由数据组成的集合。 数据集合相关联的操作集：处理这些数据对象的操作方法。 其中，抽象的含义是：描述数据类型的方法不依赖于具体实现，与存放数据的机器无关，与数据存储的物理结构无关，与实现操作的算法和编程语言均无关。 抽象数据类型其实就是面向对象程序设计语言中的“类（Class）”的含义。要注意，数据对象必定与一系列加在上面的操作是相关联。也就是说，单独存在的数据对象或操作集是无法被称之为数据结构的。而在数据结构中，完成相关操作集所用的方法就是算法（Algorithm）。 其实，数据结构本身就是一个逻辑的概念。 What is Algorithm算法包含以下几个要素： 一个有限指令集 接受一些输入（有些情况下不需要输入） 产生输出 一定在有限步骤之后终止 每一条指令必须：有充分明确的目标，不可以有歧义，并且计算机能处理的范围之内，另外，描述应不依赖于任何一种计算机语言以及具体的实现手段。 Measure for Algorithm时间复杂度（$S(n)$）：根据算法写成的程序在执行时耗费时间的长度。这个长度往往也与输入数据的规模有关。时间复杂度过高的低效算法可能导致我们有生之年都等不到运行结果。 空间复杂度（$T(n)$）：根据算法写成的程序在执行时占用存储单元的长度。这个长度往往与输入数据的规模有关。空间复杂度过高的算法可能导致内存超限，造成程序的非正常中断。 在分析一般算法的效率时，我们经常关注下面两种复杂度： 最坏情况复杂度（worst） 平均复杂度（average） Complexity Expression复杂度的渐进表示法：$ T(n) = O(f(n)) $表示存在常数$C&gt;0$，$n_0$使得当$n ≥ n_0$时，有$T(n) ≤ C * f(n)$； $ T(n) = Ω(g(n)) $表示存在常数$C&gt;0$，$n_0$使得当$n ≥ n_0$时，有$T(n) ≥ C * g(n)$； $ T(n) = θ(h(n)) $表示同时有$ T(n)=O(h(n)) $和$ T(n)=Ω(h(n)) $； 过大的上界和下界对于分析算法的“好”和“坏”，没有意义，所以一般取值是我们能找到的、最大和最小的那个上界和下界。 当问题的规模为$n$时，不同量级的时间复杂度的关系为：$log n &lt; n &lt; n*log n &lt; n^2 &lt; n^3 &lt; 2^n &lt; n!$ Complexity Analysis对算法进行复杂度的分析是衡量一个算法“好”与“坏”的基本方法，关于这方面有以下一些窍门： 若两段算法分别有复杂度$T_1(n) = O(f_1(n))$和$T_2(n) = O(f_2(n))$，则： $T_1(n) + T_2(n) = max(O(f_1(n)), O(f_2(n)))$ $T_1(n) \times T_2(n) = O(f_1(n) \times f_2(n))$ 若$T(n)$是关于$n$的$k$阶多项式，那么$T(n) = θ(n^k)$ 一个for循环的时间复杂度等于循环次数乘以循环体代码的复杂度 if-else结构的复杂度取决于if的条件判断复杂度和两个分支部分的复杂度，总体复杂度取三者中最大 平时在做到一些题目的时候会遇到要分析时间复杂度的习题，可以从上述的角度入手。不过一般而言，第四条用的要多一些。 Demo Codeexample 2 题目：写程序实现一个函数 PrintN ，使得传入一个正整数为 N 的参数后，能顺序打印从 1 到 N 的全部正整数。 学过一门程序设计语言的同学，应该不会觉得有困难，因为直接利用循环从 1 数到 N 即可完成这个需求。但是，可能会有部分同学会对递归不熟悉，好在老师也给出了代码。123456789101112131415161718192021222324#include &lt;stdio.h&gt;void PrintN(int n) &#123; // method 1: use loop for(int i = 1; i &lt;= n; i++) &#123; printf("%d\n", i); &#125;&#125;/*void PrintN(int n) &#123; // method 2: use recursion if(n) &#123; PrintN(n - 1); printf("%d\n", n); &#125;&#125;*/int main() &#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125; example 3 题目：写程序计算给定多项式在给定点 x 处的值。 处理这个题有两种方法，所以可以顺便比较一下两种方法运行的时间长短。由于计算机的运行速度较快，仅运行一次无法看出差异，所以需要多执行几次。计算时间需要借助 C 语言的库函数，而这些库函数的声明在time.h这个头文件中。由于姥姥又给出了代码，又可以偷懒了~下面给出代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;time.h&gt;#include &lt;math.h&gt;clock_t start, stop;double duration;#define MAXN 10#define MAXK 1e7double f1(int n, double a[], double x) &#123; int i; double p = a[0]; for(i = 1; i &lt;= n; i++) &#123; p += (a[i] * pow(x, i)); &#125; return p;&#125;double f2(int n, double a[], double x) &#123; int i; double p = a[n]; for(i = n; i &gt; 0; i--) &#123; p = a[i - 1] + x * p; &#125; return p;&#125; int main() &#123; int i; double a[MAXN]; for(i = 0; i &lt; MAXN; i++) a[i] = (double)i; start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f1(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks1 = %f\n", (double)(stop - start)); printf("duration1 = %6.2e\n", duration); start = clock(); for(i = 0; i &lt; MAXK; i++) &#123; f2(MAXN - 1, a, 1.1); &#125; stop = clock(); duration = ((double)(stop - start)) / CLK_TCK; printf("ticks2 = %f\n", (double)(stop - start)); printf("duration2 = %6.2e\n", duration); return 0;&#125;/*result:ticks1 = 1969.000000duration1 = 1.97e+000ticks2 = 284.000000duration2 = 2.84e-001*/ 从上面代码的结果可以看出，采用不同计算方法的代码运行时间竟然相差了几乎 7 倍！ Maximum Subsequence Sum 题目：最大子列和问题 最大子列和的问题是很经典的动态规划（DP, dynamic programming）问题，这是博主后来查阅资料了解到的。既然姥姥将这道题当作例题放在第一讲，应该也有她的道理，何况她还介绍了这么多不用动规思路的解题方法呢。从题目出发，我们可以大致得到这道题的答题代码框架：123456789101112131415#include &lt;stdio.h&gt;int MaxSubseqsum(int a[], int k) &#123;&#125;int main(int argc, char const *argv[]) &#123; int i, K; scanf("%d", &amp;K); int arr[K]; for(i=0; i&lt;K; i++) &#123; scanf("%d", &amp;arr[i]); &#125; printf("%d\n", MaxSubseqsum(arr, K)); return 0;&#125; 下面来看看各种不同的解法： directly calculating easy version直接暴力求解的思路较为直观，利用三重循环，将每一个数构成的序列全部枚举一遍，如果符合条件且满足最大，就更新结果。循环结束后，得到最后结果。1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j, k; for(i=0; i&lt;N; i++) &#123; for(j=i; j&lt;N; j++) &#123; ThisSum = 0; for(k=i; k&lt;=j; k++) &#123; ThisSum += a[k]; &#125; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; directly calculating advanced version继续按照暴力求解的思路进行计算，可以发现：对于相同的 i ，不同的 j ，只要在 j - 1 次循环的基础上累加 1 项即可，而不需要再从 1 一直加到 i。这样的话，就可以节省一层for循环的运行时间了，代码如下：123456789101112int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum = 0; int i, j; for(i=0; i&lt;N; i++) &#123; ThisSum = 0; for(j=i; j&lt;N; j++) &#123; ThisSum += a[j]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; &#125; &#125; return MaxSum;&#125; divide and conquer这道题还可以采用分治法来解决，不过不是那么容易理解，但根本在于要把握此法中边界的概念，并且要注意最终结果是 3 种情况下的最大值。123456789101112131415161718192021222324252627282930313233343536373839404142int MaxSubseqsum(int a[], int N) &#123; /*use same interface*/ return DivideAndConquer(a, 0, N-1);&#125;int DivideAndConquer(int a[], int left, int right) &#123; int MaxLeftSum, MaxRightSum; /*save the result of left and right subsequence */ int MaxLeftBorderSum, MaxRightBorderSum; /*save the result of each subsequence*/ int LeftBorderSum, RightBorderSum; int center, i; if(left == right) &#123; if(a[left] &gt; 0) return a[left]; else return 0; &#125; /*divide*/ center = (left + right) / 2; /*use recursion to get the result*/ MaxLeftSum = DivideAndConquer(a, left, center); MaxRightSum = DivideAndConquer(a, center+1, right); /*get the result of left subsequence*/ MaxLeftBorderSum = 0, LeftBorderSum = 0; for(i=center; i&gt;=left; i--) &#123; LeftBorderSum += a[i]; if(LeftBorderSum &gt; MaxLeftBorderSum) MaxLeftBorderSum = LeftBorderSum; &#125; /*get the result of right subsequence*/ MaxRightBorderSum = 0, RightBorderSum = 0; for(i=center+1; i&lt;=right; i++) &#123; RightBorderSum += a[i]; if(RightBorderSum &gt; MaxRightBorderSum) MaxRightBorderSum = RightBorderSum; &#125; return Max3(MaxLeftSum, MaxRightSum, MaxLeftBorderSum + MaxRightBorderSum);&#125;int Max3(int a, int b, int c)&#123; return a&gt;b?a&gt;c?a:c:b&gt;c?b:c;&#125; online processing比起上面的几种方法，在线处理就简单粗暴了许多，一趟循环下来就完事了，但不是那么好理解，最好根据测试样例手动模拟一遍。此法之所以快的原因在于，一旦出现了序列出现了负数，负数并不能使结果变大，反而使结果变小了。那么这种情况就不是符合条件的结果了，直接舍弃，这样就不用做多余的计算了，这和“剪枝”有点相似。而所谓“在线”，意思是指每输入一个数据就进行即时处理，在任何一个地方中止输入，算法都能正确给出当前的解。1234567891011121314int MaxSubseqsum(int a[], int N) &#123; int ThisSum, MaxSum; int i; ThisSum = MaxSum = 0; for(i=0; i&lt;N; i++) &#123; ThisSum += a[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; &#125; &#125; return MaxSum;&#125; Homework此课程的作业题目全部都放在 PTA 的习题集内，按照姥姥给的邀请码就可以进入题目集做题啦。 01-1 最大子列和问题这道题被姥姥当成了应用实例进行讲解，可以直接使用姥姥给的代码，稍加修改一下就可以直接 AC 了。不过，根据这道题给定的一些条件，需要对一些数据做一些处理。这里，我们偷下懒，直接使用在线处理思路的代码进行解题，代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int f(int array[], int N) &#123; int ThisSum = 0, MaxSum = 0; int i; for(i = 0; i &lt; N; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) MaxSum = ThisSum; else if(ThisSum &lt; 0) ThisSum = 0; &#125; return MaxSum;&#125;int main() &#123; int k, i; scanf("%d", &amp;k); for(i = 0; i &lt; k ; i++) &#123; scanf("%d", &amp;array[i]); &#125; printf("%d", f(array, k)); return 0;&#125;/*samples:in:6-2 11 -4 13 -5 -2 out:20*/ 01-2 Maximum Subsequence Sum这道题是上面题目的升级版，要求给出最佳结果的左端点和右端点的下标。需要注意的是这道题目的输出要求比较多，要当心一点。此题还是利用在线处理的思路进行求解，代码如下：1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#define maxk 100005int array[maxk] = &#123;0&#125;;int main() &#123; int k, i; scanf("%d", &amp;k); bool flag = false; for(i = 1; i &lt;= k; i++) &#123; scanf("%d", array + i); if(array[i] &gt;= 0) flag = true; &#125; if(!flag) &#123; printf("0 %d %d\n", array[1], array[k]); // all the numbers are negative &#125; else &#123; int left = 1, right = k, temp_left = 1; int ThisSum = 0, MaxSum = -1; // MaxSum need to be initialized as a negative number for(i = 1; i &lt;= k; i++) &#123; ThisSum += array[i]; if(ThisSum &gt; MaxSum) &#123; // update max value, the left index and right index MaxSum = ThisSum; left = temp_left; right = i; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; printf("%d %d %d\n", MaxSum, array[left], array[right]); &#125; return 0;&#125; 01-3 二分查找这道题目介绍的算法算是十分基础入门的算法了，对于学过一门程序设计语言的同学来说，要解决应该不会有什么困难。不过，可能会有部分同学会对 PTA 上此类题目的做题方法有所疑惑。其实，这种函数题就是让你写个函数，然后系统会自动的将你提交的这段函数代码嵌入到题目的代码之中运行，继而判断结果是否正确。要注意这类题目对函数接口和一些关键词的定义，不要搞错了。笔者做这类题目时，都是直接把所有代码全部拷贝下来，然后把缺失的代码全部按照题意写出来，然后再单独的提交题目要求的那个函数代码，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define MAXSIZE 10#define NotFound 0typedef int ElementType;typedef int Position;typedef struct LNode *List;struct LNode &#123; ElementType Data[MAXSIZE]; Position Last; /* 保存线性表中最后一个元素的位置 */&#125;;List ReadInput(); /* 裁判实现，细节不表。元素从下标1开始存储 */Position BinarySearch( List L, ElementType X );int main() &#123; List L; ElementType X; Position P; L = ReadInput(); scanf("%d", &amp;X); P = BinarySearch( L, X ); printf("%d\n", P); return 0;&#125;List ReadInput() &#123; List L = (List)malloc(sizeof(struct LNode)); int n, t, i; scanf("%d", &amp;n); for(i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;L-&gt;Data[i]); &#125; L-&gt;Last = i; return L;&#125;Position BinarySearch( List L, ElementType X ) &#123; int left = 1, right = L-&gt;Last, mid, flag = 0; while(left &lt;= right) &#123; mid = (left + right) / 2; if(L-&gt;Data[mid] == X) &#123; flag = 1; break; &#125; else if(L-&gt;Data[mid] &lt; X) left = mid + 1; else right = mid - 1; &#125; if(flag) return mid; else return NotFound;&#125;/*some samples:in:512 31 55 89 10131out:2in:326 78 23331out:0in:426 78 88 23388out:3in:426 78 88 23378out:2*/]]></content>
      <categories>
        <category>CS</category>
        <category>Data Structures and Algorithms</category>
      </categories>
      <tags>
        <tag>ZJU_DS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Advanced Level) Practice]]></title>
    <url>%2F2019%2F06%2F30%2FPAT-Advanced-Level-Practice%2F</url>
    <content type="text"><![CDATA[Intro从入门到入土系列之 PAT 甲级 题库快乐🤣启动。长期更新ing~ 1001 A+B FormatAnalysis题目意思比较简单，给俩数，相加算结果，然后输出的时候每三位一个,隔开，并且负数得在开头输出-。 按照题目给出的数字范围：$-10^6 \le a,\ b \le 10^6$，所以可以直接使用int型变量进行相加，然后在输出之前在做数位拆分即可。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;const int MAXN = 10;int main(int argc, char const *argv[]) &#123; int a, b, sum; scanf("%d %d", &amp;a, &amp;b); sum = a + b; if(sum &lt; 0) &#123; putchar('-'); sum = -sum; &#125; int len = 0, num[MAXN]; if(sum == 0) &#123; num[len++] = sum; &#125; while(sum) &#123; num[len++] = sum % 10; sum /= 10; &#125; for(int i = len - 1; i &gt;= 0; i--) &#123; printf("%d", num[i]); if(i &gt; 0 &amp;&amp; i % 3 == 0) &#123; putchar(','); &#125; &#125; return 0;&#125; 1002 A+B for PolynomialsAnalysis此题是 ZJU 数据结构课程里面的例题了，而且还只是一半的内容，算法思想不难（毕竟只是初中数学的水平，我丢😅），先按照链表来做吧，后面在看看能不能尝试其他方法。一开始偷懒没有将结果构造成一个新的链表，发现测试点5无法通过，改了一会，还是不选择偷懒了... Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115/*test point 5, like this:2 1 2.4 0 3.23 2 2.4 1 2.4 0 -3.2*/#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct Polynode* Polynomial;struct Polynode &#123; int expo; double coef; Polynomial link;&#125;;Polynomial ReadPoly();Polynomial Add(Polynomial P1, Polynomial P2);void Print(Polynomial PP);int GetNum(Polynomial P);void Attach(double c, int e, Polynomial *pRear);int main(int argc, char const *argv[]) &#123; Polynomial P1 = ReadPoly(); Polynomial P2 = ReadPoly(); Polynomial PP = Add(P1, P2); int number = GetNum(PP); if(number) &#123; printf("%d ", number); Print(PP); &#125; else &#123; printf("%d\n", number); &#125; return 0;&#125;Polynomial ReadPoly() &#123; int K; scanf("%d", &amp;K); Polynomial P, rear; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;link = NULL; rear = P; int e; double c; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;rear); &#125; return P;&#125;Polynomial Add(Polynomial P1, Polynomial P2) &#123; Polynomial p1 = P1-&gt;link, p2 = P2-&gt;link, p, rear; p = (Polynomial)malloc(sizeof(struct Polynode)); p-&gt;link = NULL; rear = p; double sum; while(p1 &amp;&amp; p2) &#123; int temp = p1-&gt;expo - p2-&gt;expo; if(temp &gt; 0) &#123; Attach(p1-&gt;coef, p1-&gt;expo, &amp;rear); p1 = p1-&gt;link; &#125; else if(temp == 0) &#123; sum = p1-&gt;coef + p2-&gt;coef; if(sum) &#123; Attach(sum, p1-&gt;expo, &amp;rear); &#125; p1 = p1-&gt;link; p2 = p2-&gt;link; &#125; else &#123; Attach(p2-&gt;coef, p2-&gt;expo, &amp;rear); p2 = p2-&gt;link; &#125; &#125; if(p1) &#123; rear-&gt;link = p1; &#125; if(p2) &#123; rear-&gt;link = p2; &#125; return p;&#125;void Print(Polynomial PP) &#123; Polynomial P = PP-&gt;link; while(P) &#123; if(P-&gt;link == NULL) &#123; printf("%d %.1lf\n", P-&gt;expo, P-&gt;coef); &#125; else &#123; printf("%d %.1lf ", P-&gt;expo, P-&gt;coef); &#125; P = P-&gt;link; &#125;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P-&gt;link; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct Polynode)); P-&gt;coef = c; P-&gt;expo = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125; 1003 EmergencyAnalysis题目大意是给定几个城市之间的地图，城市之间的路有相应的权值，然后给定起始城市和终点城市，问从起始城市到达终点城市的路径有几条，并且这些路径上点权之和最大是多少。 由于题目的实际意义，构造好的图一定是一个无向图，借助 Dijkstra 算法或 Bellman-Ford 算法可以解决这两个问题。 路径条数和点权和的最大值，分别使用一个数组来统计即可。 CodeDijkstra123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 510;const int INF = 1000000000;int n, m, st, ed, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;;bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, INF); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = INF; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != INF) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; //update the distance of each node w[v] = w[u] + weight[v]; // update the 'hands' num[v] = num[u]; // update the path for a new reachable node &#125; else if(d[u] + G[u][v] == d[v]) &#123; /*only one path can count the 'hands', so the w[v] will be covered by the sum of last node and its own 'hands' */ if(w[u] + weight[v] &gt; w[v]) &#123; w[v] = w[u] + weight[v]; &#125; //but the number of path is not only num[v] += num[u]; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v; fill(G[0], G[0] + maxv * maxv, INF); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v]; G[v][u] = G[u][v]; &#125; dijkstra(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; Bellman-Ford12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;struct node &#123; int v, dis; node(int _v, int _dis) : v(_v), dis(_dis) &#123;&#125; // constructor&#125;;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, weight[maxv];int num[maxv] = &#123;0&#125;, w[maxv] = &#123;0&#125;, d[maxv];vector&lt;node&gt; Adj[maxv];set&lt;int&gt; pre[maxv];bool bellmanford(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; num[s] = 1; w[s] = weight[s]; for(int i = 0; i &lt; n - 1; i++) &#123; for(int u = 0; u &lt; n; u++) &#123; for(int j = 0; j &lt; Adj[u].size(); j++) &#123; int v = Adj[u][j].v; int dis = Adj[u][j].dis; if(d[u] + dis &lt; d[v]) &#123; // more optimal solution d[v] = d[u] + dis; w[v] = w[u] + weight[v]; num[v] = num[u]; pre[v].clear(); // attention: pre[v] must be clear firstly pre[v].insert(u); // save the precursor &#125; else if(d[u] + dis == d[v]) &#123; if(w[v] &lt; w[u] + weight[v]) &#123; // update the maximum w[v] = w[u] + weight[v]; &#125; pre[v].insert(u); // other shortest path also need save num[v] = 0; // the number of shortest path has been changed set&lt;int&gt;::iterator it; for(it = pre[v].begin(); it != pre[v].end(); it++) &#123; num[v] += num[*it]; &#125; &#125; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; weight[i]; &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; Adj[u].push_back(node(v, dis)); Adj[v].push_back(node(u, dis)); &#125; bellmanford(st); cout &lt;&lt; num[ed] &lt;&lt; ' ' &lt;&lt; w[ed]; return 0;&#125; 1004 Counting LeavesAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, child, seq, maxDepth = -1;int leaves[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; while(!q.empty()) &#123; int front = q.front(); q.pop(); if(Node[front].depth &gt; maxDepth) &#123; maxDepth = Node[front].depth; &#125; if(Node[front].child.size() != 0) &#123; for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; q.push(child); &#125; &#125; else &#123; leaves[Node[front].depth]++; &#125; &#125; &#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); for(int i = 1; i &lt;= maxDepth; i++) &#123; cout &lt;&lt; leaves[i]; if(i &lt; maxDepth) cout &lt;&lt; ' '; &#125; return 0;&#125; 1005 Spell It RightAnalysis题目意思很简单，给一个数字，计算出这个数字每一位上的数字之和，然后用英文的方式分别输出这个和的每一位数字（好吧，有点绕😅）。 与乙级题库的1002很类似，考察数位拆分吧，比较简单。 Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;const int MAXN = 100 + 5;char NumberTable[11][10] = &#123; "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten",&#125;;int main(int argc, char const *argv[]) &#123; char num[MAXN]; int sum = 0; scanf("%s", num); char *p = num; while(*p != '\0') &#123; sum += *p++ - '0'; &#125; int temp = sum, mask = 1; while(temp &gt; 9) &#123; temp /= 10; mask *= 10; &#125; while(mask) &#123; printf("%s", NumberTable[sum / mask]); if(mask &gt; 9) &#123; putchar(' '); &#125; sum %= mask; mask /= 10; &#125; putchar('\n'); return 0;&#125; 1006 Sign in and Sign OutAnalysis题目意思很简单，最先去机房的人开门，最晚出机房的人关门，用学号代替人名，输出最早来和最晚走的人的学号即可。分析输入数据，1个字符串，6个整型数字，每3个数字为一个时间点，分别代表到来和离开的时间点，既然要找的只是最早和最晚的两个时间点，那么每次寻找时，只要去比较一个时间点即可。最早来的时间初始化为一天中最后晚的时间（23:59:59），最晚走的时间初始化为一天中最早的时间（00:00:00），注意要分开比较，不能用if-else哦。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;struct person&#123; char ID_number[20]; int start_hh, start_mm, start_ss, end_hh, end_mm, end_ss;&#125; first, last, temp;void Init();bool Earliest(person a, person b);bool Latest(person a, person b);int main(int argc, char const *argv[]) &#123; Init(); int M; scanf("%d", &amp;M); while(M--) &#123; scanf("%s %d:%d:%d %d:%d:%d", temp.ID_number, &amp;temp.start_hh, \ &amp;temp.start_mm, &amp;temp.start_ss, &amp;temp.end_hh, &amp;temp.end_mm, &amp;temp.end_ss); if(Earliest(temp, first)) &#123; first = temp; &#125; if(Latest(temp, last)) &#123; last = temp; &#125; &#125; printf("%s %s\n", first.ID_number, last.ID_number); return 0;&#125;void Init() &#123; first.start_hh = 23; first.start_mm = first.start_ss = 59; last.end_hh = last.end_mm = last.end_ss = 0;&#125;bool Earliest(person a, person b) &#123; if(a.start_hh != b.start_hh) return a.start_hh &lt;= b.start_hh; else if(a.start_mm != b.start_mm) return a.start_mm &lt;= b.start_mm; else return a.start_ss &lt;= a.start_ss;&#125;bool Latest(person a, person b) &#123; if(a.end_hh != b.end_hh) return a.end_hh &gt;= b.end_hh; else if(a.end_mm != b.end_mm) return a.end_mm &gt;= b.end_mm; else return a.end_ss &gt;= b.end_ss;&#125; 1007 Maximum Subsequence SumAnalysisCodeDP123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;const int maxn = 10010;int a[maxn], dp[maxn];int s[maxn] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; bool flag = false; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; if(a[i] &gt;= 0) flag = true; &#125; if(flag == false) &#123; cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; a[0] &lt;&lt; ' ' &lt;&lt; a[n - 1]; &#125; else &#123; dp[0] = a[0]; for(int i = 1; i &lt; n; i++) &#123; if(dp[i - 1] + a[i] &gt; a[i]) &#123; dp[i] = dp[i - 1] + a[i]; s[i] = s[i - 1]; &#125; else &#123; dp[i] = a[i]; s[i] = i; &#125; &#125; int k = 0; for(int i = 1; i &lt; n; i++) &#123; if(dp[i] &gt; dp[k]) &#123; k = i; &#125; &#125; cout &lt;&lt; dp[k] &lt;&lt; ' ' &lt;&lt; a[s[k]] &lt;&lt; ' ' &lt;&lt; a[k]; &#125; return 0;&#125; Online-Processing1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxk = 10010;int main(int argc, char *argv[]) &#123; int k, arr[maxk] = &#123;0&#125;; cin &gt;&gt; k; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; arr[i]; &#125; int ThisSum = 0, MaxSum = -1; int left = 0, right = k - 1, temp_left = 0; for(int i = 0; i &lt; k; i++) &#123; ThisSum += arr[i]; if(ThisSum &gt; MaxSum) &#123; MaxSum = ThisSum; right = i; left = temp_left; &#125; else if(ThisSum &lt; 0) &#123; ThisSum = 0; temp_left = i + 1; &#125; &#125; if(MaxSum &lt; 0) cout &lt;&lt; 0 &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; else cout &lt;&lt; MaxSum &lt;&lt; ' ' &lt;&lt; arr[left] &lt;&lt; ' ' &lt;&lt; arr[right]; return 0;&#125; 1008 ElevatorAnalysis题目大意是给定电梯移动和等待的时长，再按照题目给定的停留顺序，计算出电梯在这个过程中需要的总时间。以样例为例： 初始为0层，到2层，时长为：$2 \times 6 = 12\ s$，再加上等待的$5s$，总计$17s$ 从2层到3层，时长为：$1 \times 6 = 6\ s$，再加上等待的$5s$，总计$11s$ 从3层到1层，时长为：$2 \times 4 = 8\ s$，再加上等待的$5s$，总计$13s$ 合计为：$17 + 11 + 13 = 41\ s$ Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int n, array[105] = &#123;0&#125;; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; int total = 0, last = 0; for(int i = 0; i &lt; n; i++) &#123; if(array[i] == last) &#123; total += 5; &#125; else if(array[i] &gt; last) &#123; total += ((array[i] - last) * 6 + 5); &#125; else &#123; total += ((last - array[i]) * 4 + 5); &#125; last = array[i]; &#125; printf("%d\n", total); return 0;&#125; 1009 Product of PolynomialsAnalysis此题也是 ZJU 数据结构课程里面的例题，算是另一半了，与1002是类似的，只不过1002是加法，这个是乘法，还是先用链表做吧。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct PolyNode *Polynomial;struct PolyNode &#123; double coef; int expon; Polynomial link;&#125;;void Attach(double c, int e, Polynomial *pRear);Polynomial ReadPoly();Polynomial Mult(Polynomial P1, Polynomial P2);void PrintPoly(Polynomial P);int Compare(int a, int b);int GetNum(Polynomial P);int main(int argc, char const *argv[])&#123; Polynomial P1, P2, PP, PS; P1 = ReadPoly(); P2 = ReadPoly(); PP = Mult(P1, P2); int numbers = GetNum(PP); if(numbers) &#123; printf("%d ", numbers); PrintPoly(PP); &#125; else &#123; printf("%d\n"); &#125; return 0;&#125;void Attach(double c, int e, Polynomial *pRear) &#123; Polynomial P; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;coef = c; P-&gt;expon = e; P-&gt;link = NULL; (*pRear)-&gt;link = P; *pRear = P;&#125;Polynomial ReadPoly() &#123; Polynomial P, Rear, t; int e, K; double c; scanf("%d", &amp;K); P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(K--) &#123; scanf("%d %lf", &amp;e, &amp;c); Attach(c, e, &amp;Rear); &#125; t = P; P = P-&gt;link; free(t); return P;&#125;Polynomial Mult(Polynomial P1, Polynomial P2) &#123; Polynomial P, Rear, t1, t2, t; int e; double c; if(!P1 || !P2) return NULL; t1 = P1; t2 = P2; P = (Polynomial)malloc(sizeof(struct PolyNode)); P-&gt;link = NULL; Rear = P; while(t1) &#123; t2 = P2; Rear = P; while(t2) &#123; e = t1-&gt;expon + t2-&gt;expon; c = t1-&gt;coef * t2-&gt;coef; while(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon &gt; e) &#123; Rear = Rear-&gt;link; &#125; if(Rear-&gt;link &amp;&amp; Rear-&gt;link-&gt;expon == e) &#123; if(Rear-&gt;link-&gt;coef + c) &#123; Rear-&gt;link-&gt;coef += c; &#125; else &#123; t = Rear-&gt;link; Rear-&gt;link = t-&gt;link; free(t); &#125; &#125; else &#123; t = (Polynomial)malloc(sizeof(struct PolyNode)); t-&gt;coef = c; t-&gt;expon = e; t-&gt;link = Rear-&gt;link; Rear-&gt;link = t; Rear = Rear-&gt;link; &#125; t2 = t2-&gt;link; &#125; t1 = t1-&gt;link; &#125; t2 = P; P = P-&gt;link; free(t2); return P;&#125;void PrintPoly(Polynomial P) &#123; int flag = 0; while(P) &#123; if(!flag)&#123; flag = 1; &#125; else &#123; printf(" "); &#125; printf("%d %.1lf", P-&gt;expon, P-&gt;coef); P = P-&gt;link; &#125; printf("\n");&#125;int Compare(int a, int b) &#123; return a &gt; b ? 1 : a == b ? 0 : -1;&#125;int GetNum(Polynomial P) &#123; Polynomial p = P; int ret = 0; while(p) &#123; ret++; p = p-&gt;link; &#125; return ret;&#125; 1010 RadixAnalysis这个题的题意说的比较模糊，所以不太好寻找思路。先分析一下题目意思，给定N1，N2，tag和radix四个数字；若当tag为1时，radix的值就是N1的进制数，tag为2时，radix的值就是N2的进制数（一般针对这种情况，最好交换下N1和N2的值，再统一处理）。 紧接着，题目要求判断N1和N2是否相等，由于题目给定的两个数字的进制不相同，所以还必须要转换后进行判断。与其这样，不如直接将能确定进制的那个数转化为十进制数，然后与另一个数的每一个不同的进制单位下转换为十进制数后值进行比较，若相等，则这两个数相等（只要在一种进制单位下，两个数相等，那么在其他任意进制单位下，这两个数不管如何变化都是相等的）。 明白题意后，就得开始打码了。由于题目给定的radix没有限制范围，所以转换后的十进制数是有可能溢出的（long long也会），所以使用字符串来存储数字。 紧接着，按照前面的思路，先构造字符0 - 9和a - z的十进制数对应表，方便调用。另外，不管tag的值如何，对N1和N2进行处理，默认N1是进制确定的数。在开始对N2进行进制转换之前，要先确定其可能的进制范围，这个结果就是：以其字符最大值为下界，N1的十进制数值为上界。在这个进制范围内，一个一个去枚举显然是很慢的，所以使用二分法是一个很不错的选择。 注意： 使用二分法时，只需要找到满足条件：与N1的十进制数相等的数即可，此时得返回进制数。 针对数据的溢出情况，一旦结果为负，就可以判断为溢出，此时N2在这个进制下的转换出来的十进制数肯定是大于N1的十进制数的。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;typedef long long LL;LL Map[256];LL inf = (1LL &lt;&lt; 63) - 1;void Init() &#123; for(char c = '0'; c &lt;= '9'; c++) &#123; Map[c] = c - '0'; &#125; for(char c = 'a'; c &lt;= 'z'; c++) &#123; Map[c] = c - 'a' + 10; &#125;&#125;LL ConvertNum10(char *a, LL radix, LL t) &#123; LL ret = 0; for(int i = 0; a[i] != '\0'; i++) &#123; ret = ret * radix + Map[a[i]]; if(ret &lt; 0 || ret &gt; t) &#123; ret = -1; break; &#125; &#125; return ret;&#125;int cmp(char *N2, LL radix, LL t) &#123; int len = strlen(N2); LL num = ConvertNum10(N2, radix, t); if(num &lt; 0) return 1; if(t &gt; num) return -1; else if(t == num) return 0; else return 1;&#125;LL BinarySearch(char *N2, LL left, LL right, LL t) &#123; LL mid; while(left &lt;= right) &#123; mid = (left + right) / 2; int flag = cmp(N2, mid, t); if(flag == 0) return mid; else if(flag == -1) left = mid + 1; else right = mid - 1; &#125; return - 1;&#125; int FindLargestDigit(char *N2) &#123; int ans = -1, len = strlen(N2); for(int i = 0; i &lt; len; i++) &#123; if(Map[N2[i]] &gt; ans) &#123; ans = Map[N2[i]]; &#125; &#125; return ans + 1;&#125;char N1[20], N2[20], temp[20];int tag, radix;int main(int argc, char const *argv[]) &#123; Init(); scanf("%s %s %d %d", N1, N2, &amp;tag, &amp;radix); if(tag == 2) &#123; strcpy(temp, N1); strcpy(N1, N2); strcpy(N2, temp); &#125; LL t = ConvertNum10(N1, radix, inf); LL low = FindLargestDigit(N2); LL high = max(low, t) + 1; LL ans = BinarySearch(N2, low, high, t); if(ans == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%lld\n", ans); &#125; return 0;&#125; 1011 World Cup BettingAnalysis题目意思很明确，三局比赛，给出每局的赔率，默认每次都赌对，问怎样买收益最多。很简单，每次买赔率最大的就好啦~然后还有一个麻烦的地方，就是要输出每局赔率最大的是哪一种局，即：获胜（Win）、平局（Tie）和失败（Lose），先保存每次的下标，然后写个函数转换一下就好了。至于收益的计算方法，按照题目给定的公式算就好了。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;char change(int index);int main(int argc, char const *argv[]) &#123; double Bet[3][3], Profit = 0.0; for(int i = 0; i &lt; 3; i++) &#123; scanf("%lf %lf %lf", &amp;Bet[i][0], &amp;Bet[i][1], &amp;Bet[i][2]); &#125; int max_index[3]; double max[3] = &#123;0.0&#125;; for(int i = 0; i &lt; 3; i++) &#123; for(int j = 0; j &lt; 3; j++) &#123; if(max[i] &lt; Bet[i][j]) &#123; max[i] = Bet[i][j]; max_index[i] = j; &#125; &#125; &#125; Profit = (max[0] * max[1] * max[2] * 0.65 - 1.0) * 2.0; printf("%c %c %c %.2lf\n", change(max_index[0]), change(max_index[1]), change(max_index[2]), Profit); return 0;&#125;char change(int index) &#123; char ret; switch(index) &#123; case 0: ret = 'W'; break; case 1: ret = 'T'; break; case 2: ret = 'L'; break; &#125; return ret;&#125; 1012 The Best RankAnalysis给出每个学生的各科成绩，计算其平均分，并根据他们的成绩进行排序；然后查找指定学号的学生的成绩，输出其排名最优的成绩和科目名称。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 2000 + 5;struct student &#123; int id, grade[4];&#125; stu[MAXN];char course[4] = &#123;'A', 'C', 'M', 'E'&#125;;int Rank[10000000][4] = &#123;0&#125;;int now;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d %d", &amp;stu[i].id, &amp;stu[i].grade[1], &amp;stu[i].grade[2], &amp;stu[i].grade[3]); stu[i].grade[0] = (stu[i].grade[1] + stu[i].grade[2] + stu[i].grade[3]) / 3; &#125; for(now = 0; now &lt; 4; now++) &#123; sort(stu, stu + N, cmp); Rank[stu[0].id][now] = 1; for(int i = 1; i &lt; N; i++) &#123; if(stu[i].grade[now] == stu[i - 1].grade[now]) &#123; Rank[stu[i].id][now] = Rank[stu[i - 1].id][now]; &#125; else &#123; Rank[stu[i].id][now] = i + 1; &#125; &#125; &#125; int query; while(M--) &#123; scanf("%d", &amp;query); if(Rank[query][0] == 0) &#123; printf("N/A\n"); &#125; else &#123; int k = 0; for(int j = 0; j &lt; 4; j++) &#123; if(Rank[query][j] &lt; Rank[query][k]) &#123; k = j; &#125; &#125; printf("%d %c\n", Rank[query][k], course[k]); &#125; &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade[now] &gt; b.grade[now];&#125; 1013 Battle Over CitiesAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/* method 1: use union-find set*/#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];int father[maxn];bool vis[maxn];int n, m, k;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = faB; &#125;&#125;void init() &#123; for(int i = 1; i &lt; maxn; i++) &#123; father[i] = i; vis[i] = false; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; int currentPoint; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; init(); for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; G[i].size(); j++) &#123; int u = i, v = G[i][j]; if(u == currentPoint || v == currentPoint) continue; Union(u, v); &#125; &#125; int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i == currentPoint) continue; int fa_i = findFather(i); if(vis[fa_i] == false) &#123; block++; vis[fa_i] = true; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;/*method 2: use DFS#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;vector&lt;int&gt; G[maxn];bool vis[maxn] = &#123;false&#125;;int currentPoint;int n, m, k;void dfs(int v) &#123; if(v == currentPoint) return; vis[v] = true; for(int i = 0; i &lt; G[v].size(); i++) &#123; if(vis[G[v][i]] == false) &#123; dfs(G[v][i]); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; for(int i = 0; i &lt; m; i++) &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; G[a].push_back(b); G[b].push_back(a); &#125; for(int query = 0; query &lt; k; query++) &#123; cin &gt;&gt; currentPoint; memset(vis, false, sizeof(vis)); int block = 0; for(int i = 1; i &lt;= n; i++) &#123; if(i != currentPoint &amp;&amp; vis[i] == false) &#123; dfs(i); block++; &#125; &#125; cout &lt;&lt; block - 1 &lt;&lt; endl; &#125; return 0;&#125;*/ 1015 Reversible PrimesAnalysis题目大意是给定两个整数N、D，N是十进制下的整数，D是进制数，判断N和将N转换为D进制下的数是否都是素数。若是，输出Yes，反之输出No。 考察进制转换和素数的判断。 Code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cmath&gt;int Reverse(int number, int radix) &#123; int a[32], temp = number, count = 0, ret = 0; while(temp) &#123; a[count++] = temp % radix; temp /= radix; &#125; for(int i = 0; i &lt; count; i++) &#123; ret = ret * radix + a[i]; &#125; return ret;&#125;bool isPrime(int n) &#123; if(n &lt;= 1 || (n % 2 == 0 &amp;&amp; n != 2)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int main(int argc, char const *argv[]) &#123; int n, d; while(1) &#123; scanf("%d", &amp;n); if(n &lt; 0) break; scanf("%d", &amp;d); if(isPrime(n) &amp;&amp; isPrime(Reverse(n, d))) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; &#125; return 0;&#125; 1016 Phone BillsAnalysis先分析一下输入，包含名称、时间和状态，其中名称和状态是以字符串的形式输入的，而时间则是十进制数字。这里要立刻反应过来，不能用题目字符串来表示状态，应该换成数字来表示。至于，最开始输入的费率表，使用一个整型数组来存储，使用的时候进行调用就好。 接下来，需要对输入的数据进行排序，优先级最大的排序依据就是名称，按照字典序来排列，注意字符串需要用strcmp函数来进行比较；其次，相同名称的元素按照时间的先后进行排列就好了。 接着再来看输出，首先要输出的是客户的名称和其话费账单所处的月份；第二行开始输出客户的话费账单的开始时间和结束时间，然后输出当前账单的总时长和费用，注意费用为浮点型；所有账单都输出完毕后，最后一行输出客户总话费。 大致清楚之后，如何去计算话费呢？根据题目，输入的每一项必须是配对的on-line和off-line才能组成一个合法的账单，并且必须要是连续、相邻的才能是一对（这个条件很重要）。读懂这个条件后，计算时间就比较简单了，让开始时间一直增加到结束时间，统计好分钟数既可得到经历的时间，然后计算总费用。注意，给定的费率是cents/minute，最后得转化为dollar，除以100即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt; #include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct record&#123; char name[25]; int month, day, hour, minute; bool status;&#125; rec[MAXN], temp;int rate[25] = &#123;0&#125;;bool cmp(record a, record b);void get_time(int on, int off, int &amp;time, int &amp;money);int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; 24; i++) &#123; scanf("%d", rate + i); &#125; int N; scanf("%d", &amp;N); char line[10]; for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d:%d:%d:%d", rec[i].name, &amp;rec[i].month, &amp;rec[i].day, &amp;rec[i].hour, &amp;rec[i].minute); scanf("%s", line); if(!strcmp(line, "on-line")) &#123; rec[i].status = true; &#125; else &#123; rec[i].status = false; &#125; &#125; sort(rec, rec + N, cmp); int on = 0, off, next; while(on &lt; N) &#123; int needPrint = 0; next = on; // fint the next customer, and check the current customer has paired 'on-line' and 'off-line' or not while(next &lt; N &amp;&amp; strcmp(rec[next].name, rec[on].name) == 0) &#123; if(needPrint == 0 &amp;&amp; rec[next].status == true) &#123; needPrint = 1; &#125; else if(needPrint == 1 &amp;&amp; rec[next].status == false) &#123; needPrint = 2; &#125; next++; &#125; //the current customer has not paired 'on-line' and 'off-line', skip this customer if(needPrint &lt; 2) &#123; on = next; continue; &#125; //calculate the money for current customer int Total = 0; printf("%s %02d\n", rec[on].name, rec[on].month); while(on &lt; next) &#123; //find the paired 'on-line' and 'off-line' while(on &lt; next - 1 &amp;&amp; !(rec[on].status == true &amp;&amp; rec[on + 1].status == false)) &#123; on++; &#125; off = on + 1; if(off == next) &#123; on = next; break; &#125; printf("%02d:%02d:%02d ", rec[on].day, rec[on].hour, rec[on].minute); printf("%02d:%02d:%02d ", rec[off].day, rec[off].hour, rec[off].minute); int time = 0, money = 0; get_time(on, off, time, money); Total += money; printf("%d $%.2lf\n", time, money / 100.0); on = off + 1; &#125; printf("Total amount: $%.2lf\n", Total / 100.0); &#125; return 0;&#125;bool cmp(record a, record b) &#123; if(strcmp(a.name, b.name)) return strcmp(a.name, b.name) &lt; 0; else if(a.month != b.month) return a.month &lt; b.month; else if(a.day != b.day) return a.day &lt; b.day; else if(a.hour != b.hour) return a.hour &lt; b.hour; else return a.minute &lt; b.minute;&#125;void get_time(int on, int off, int &amp;time, int &amp;money) &#123; temp = rec[on]; while(temp.day &lt; rec[off].day || temp.hour &lt; rec[off].hour || temp.minute &lt; rec[off].minute) &#123; time++; money += rate[temp.hour]; temp.minute++; if(temp.minute &gt;= 60) &#123; temp.minute = 0; temp.hour++; &#125; if(temp.hour &gt;= 24) &#123; temp.hour = 0; temp.day++; &#125; &#125;&#125; 1018 Public Bike ManagementAnalysis题目背景类似现在的共享单车，这种公共设施服务有一个管理中心，本题叫做 Public Bike Management Center，简称 PMBC，而这个 PMBC 会调整每个停靠站点的自行车数目从而达到“完美”状态，这种“完美”状态是指停靠数量为该站点最大容量的一半。 题目给定各个站点距离 PMBC 的距离、每个停靠站点当前的停靠数量和需要投放自行车的站点，要求输出完成投放工作需要携带的最小自行车数目、完成投放工作的最短路径和剩余带回的车数，注意路径中的站点如果不是完美状态，也需要调整为完美状态。 题目的第一要求是最短路径，借助 Dijkstra 算法可以解决这个问题，再利用动态数组保存好每一条最短路径，然后借助 DFS 来计算题目要求的所携带的最小自行车数目及剩余带回的车数。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int Cmax, n, m, sp, G[maxv][maxv], weight[maxv];int d[maxv], minneed = inf, minremain = inf;bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path; void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt;= n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt;= n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt;= n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); int need = 0, remain = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; if(weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; if(remain + weight[id] &gt; 0) &#123; remain += weight[id]; &#125; else &#123; need += abs(remain + weight[id]); remain = 0; &#125; &#125; &#125; if(need &lt; minneed) &#123; minneed = need; minremain = remain; path = tempath; &#125; else if(need == minneed &amp;&amp; remain &lt; minremain) &#123; minremain = remain; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; Cmax &gt;&gt; n &gt;&gt; sp &gt;&gt; m; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; weight[i]; weight[i] -= Cmax / 2; //preprocessing: make it 'perfect' &#125; int u, v, dis; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; dis; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); dfs(sp); cout &lt;&lt; minneed &lt;&lt; ' '; for(int i = path.size() - 1; i &gt;=0; i--) &#123; cout &lt;&lt; path[i]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; cout &lt;&lt; ' ' &lt;&lt; minremain; return 0;&#125; 1019 General Palindromic NumberAnalysis此题属于结合了进制转换和回文序列判断的混合题目。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;bool PalindromicNum(long long *digits, long long count);int main(int argc, char const *argv[]) &#123; long long N, b, count = 0, digits[50] = &#123;0&#125;; scanf("%lld %lld", &amp;N, &amp;b); while(N) &#123; digits[count++] = N % b; N /= b; &#125; count--; if(PalindromicNum(digits, count)) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(; count &gt; 0; count--) &#123; printf("%lld ", digits[count]); &#125; printf("%lld\n", digits[count]); return 0;&#125;bool PalindromicNum(long long *digits, long long count) &#123; bool flag = true; int i, j; if(count % 2 == 0) &#123; i = j = count / 2; &#125; else &#123; i = count / 2; j = i + 1; &#125; for(; i &gt;= 0 &amp;&amp; j &lt;= count; i--, j++) &#123; if(digits[i] != digits[j]) &#123; flag = false; break; &#125; &#125; return flag;&#125; 1020 Tree TraversalsAnalysis题目大意，给定两个树的中序遍历和后序遍历，求其层次遍历。 此题属于树的常规题型，思路是利用中序遍历和后序遍历建树，然后再借助 BFS 进行层次遍历，并输出层次遍历序列。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 50;struct node &#123; int data; node *lchild; node *rchild;&#125;;int pre[maxn], in[maxn], post[maxn];int n;node *create(int postL, int postR, int inL, int inR) &#123; if(postL &gt; postR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = post[postR]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == post[postR]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(postL, postL + numLeft - 1, inL, k - 1); root-&gt;rchild = create(postL + numLeft, postR - 1, k + 1, inR); return root;&#125;int num = 0;void BFS(node *root) &#123; queue&lt;node*&gt; q; q.push(root); while(!q.empty()) &#123; node *now = q.front(); q.pop(); printf("%d", now-&gt;data); num++; if(num &lt; n) printf(" "); if(now-&gt;lchild != NULL) q.push(now-&gt;lchild); if(now-&gt;rchild != NULL) q.push(now-&gt;rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;post[i]); &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;in[i]); &#125; node *root = create(0, n - 1, 0, n - 1); BFS(root); return 0;&#125; 1022 Digital LibraryAnalysis题目背景是数字图书馆的检索功能，要求大致模拟一下这个功能。 按照题目的要求，输出书名时，需要按序输出，比起构造新的数据结构后使用sort函数来完成这项操作，不如直接借助set。而在查询时，是通过字符串来进行的查询，使用map建立映射后，就可以类似散列一样进行查询。 综合上述的两种需求后，好在map是支持string向set的映射的，所以直接使用即可。 由于关键字key是一个一个给出的，所以需要一个一个输入并统计，依据cin或scanf输入字符串的特性，可以很方便的单个读入，并使用getchar读取回车符结束循环。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;set&gt;using namespace std;map&lt;string, set&lt;int&gt; &gt; mpTitle, mpAuthor, mpKey, mpPub, mpYear;void query(map&lt;string, set&lt;int&gt; &gt; &amp;mp, string &amp;str) &#123; if(mp.find(str) == mp.end()) printf("Not Found\n"); else &#123; for(set&lt;int&gt;::iterator it = mp[str].begin(); it != mp[str].end(); it++) &#123; printf("%07d\n", *it); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, m, id, type; string title, author, key, pub, year; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;id); char c = getchar(); getline(cin, title); mpTitle[title].insert(id); getline(cin, author); mpAuthor[author].insert(id); while(cin &gt;&gt; key) &#123; mpKey[key].insert(id); c = getchar(); if(c == '\n') break; &#125; getline(cin, pub); mpPub[pub].insert(id); getline(cin, year); mpYear[year].insert(id); &#125; string temp; cin &gt;&gt; m; while(m--) &#123; scanf("%d: ", &amp;type); getline(cin, temp); cout &lt;&lt; type &lt;&lt; ": " &lt;&lt; temp &lt;&lt; endl; if(type == 1) query(mpTitle, temp); else if(type == 2) query(mpAuthor, temp); else if(type == 3) query(mpKey, temp); else if(type == 4) query(mpPub, temp); else query(mpYear, temp); &#125; return 0;&#125; 1023 Have Fun with NumbersAnalysis题目大意是给一个不超过20位的整数，将这个整数翻倍后，判断组成这个新整数的所有数字是否与原来的数字相同。若是，输出Yes；反之，输出No。注意，无论是否符合都需要输出翻倍后的新数字。 由于题目明确说了给定的数字位数不超过20位，但是long long只能到19位，所以直接使用数组来存储数字，然后利用数组来模拟乘以2。 然后判断两个数字的所有位数字的出现次数是否一致即可（利用散列的思想会比较方便）。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int Compare(int *original, int *now, int number);int main(int argc, char const *argv[]) &#123; char Num[22]; int original[22], now[22], original_occurrence[10] = &#123;0&#125;, now_occurrence[10] = &#123;0&#125;; scanf("%s", Num); char *p = Num; int i = 0, j, k, temp = 0, flag = 0; //conver the string to an array(int) while(*p != '\0') &#123; original[i++] = *p++ - '0'; &#125; //count the occurrence of the original number for(j = 0; j &lt; i; j++) &#123; original_occurrence[original[j]]++; &#125; //imitate multiplication for(k = 0, j = i - 1; j &gt;= 0; j--, k++) &#123; now[k] = (original[j] * 2 + temp) % 10; temp = original[j] * 2 / 10; &#125; if(temp) &#123; now[k] = temp; &#125; else &#123; k -= 1; &#125; //count the new number for(j = 0; j &lt;= k; j++) &#123; now_occurrence[now[j]]++; &#125; flag = Compare(original_occurrence, now_occurrence, 10); //print if(flag) &#123; printf("Yes\n"); &#125; else &#123; printf("No\n"); &#125; for(j = k; j &gt; 0; j--) &#123; printf("%d", now[j]); &#125; printf("%d\n", now[j]); return 0;&#125;int Compare(int *original, int *now, int number) &#123; int i, j, ret = 1; for(i = 0; i &lt; number; i++) &#123; if(original[i] != now[i]) &#123; ret = 0; break; &#125; &#125; return ret;&#125; 1024 Palindromic NumberAnalysis题目大意是给定一个数字，判断是否为回文数字，并进行一系列操作。另外，给定一个上限次数，当给定的数不是回文数字时，令其加上将其逆置后的数字，在进行判断是否为会问数字，若是，则输出这个数字和变换次数，反之，则继续直至超过上限次数。注意，即便超过了上限次数，依然要变换过程中最后的数字。 解决此题需要解决下面3个子问题： 回文数字的判定 数字逆置 数字相加 题目要求数字的范围不超过$10^{10}$，可以使用long long，但这会使得将数字逆置的这个步骤非常麻烦，所以直接使用数组来存储数字，并模拟数字之间的加法。另外这样还有一个好处，就是在判断是否是回文数字时，可以直接对数组进行判断。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign &#123; int d[200], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign reversebign(bign a) &#123; int temp; for(int i = 0; i &lt; a.len / 2; i++) &#123; temp = a.d[i]; a.d[i] = a.d[a.len - i - 1]; a.d[a.len - i - 1] = temp; &#125; return a;&#125;bign add(bign a, bign b) &#123; bign c; int carry = 0; for(int i = 0; i &lt; a.len || i &lt; b.len; i++) &#123; int temp = a.d[i] + b.d[i] + carry; c.d[c.len++] = temp % 10; carry = temp / 10; &#125; if(carry != 0) &#123; c.d[c.len++] = carry; &#125; return c;&#125;bool isPalindromic(bign a) &#123; for(int i = 0; i &lt;= a.len / 2; i++) &#123; if(a.d[i] != a.d[a.len - 1 - i]) return false; &#125; return true;&#125;void print(bign a) &#123; for(int i = a.len - 1; i &gt;= 0; i--) &#123; printf("%d", a.d[i]); &#125; putchar('\n');&#125;int main(int argc, char const *argv[]) &#123; char str[150]; int times, count = 0; scanf("%s %d", str, &amp;times); bign a = change(str), rev; while(times--) &#123; if(isPalindromic(a)) &#123; break; &#125; else &#123; rev = reversebign(a); a = add(a, rev); count++; &#125; &#125; print(a); printf("%d", count); return 0;&#125; 1025 PTA RankingAnalysis此题考察排序，直接调用库里的排序函数来帮助完成排序就好了。注意： 一个地点内的所有数据输入完了之后，本地排名就可以完成了 每个数据在在输入的时候就可以顺便对其进行地点编号 最终排名必须要在本地排名之后才能进行 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;struct student &#123; char id[15]; int score; int location_number; int local_rank;&#125; stu[30010];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, K, num = 0; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;K); for(int j = 0; j &lt; K; j++) &#123; scanf("%s %d", stu[num].id, &amp;stu[num].score); stu[num].location_number = i; num++; &#125; sort(stu + num - K, stu + num, cmp); stu[num - K].local_rank = 1; //get local rank for(int j = num - K + 1; j &lt; num; j++) &#123; if(stu[j].score == stu[j - 1].score) &#123; stu[j].local_rank = stu[j - 1].local_rank; &#125; else &#123; stu[j].local_rank = j + 1 - (num - K); &#125; &#125; &#125; printf("%d\n", num); sort(stu, stu + num, cmp); //get final rank int r = 1; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].score != stu[i - 1].score) &#123; r = i + 1; &#125; printf("%s ", stu[i].id); printf("%d %d %d\n", r, stu[i].location_number, stu[i].local_rank); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.id, b.id) &lt; 0;&#125; 1027 Colors in MarsAnalysis考察进制转换的题目，10进制转换为13进制，与转换10进制转换为16进制是类似的，代码可能写的不太好看，嘿嘿~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;char Change(int number);int Transfer(char *dst, int number, int dex);int main(int argc, char const *argv[]) &#123; int R, G, B, index = 1; scanf("%d %d %d", &amp;R, &amp;G, &amp;B); char color[10] = "#00000000"; index = Transfer(color, R, index); index = Transfer(color, G, index); index = Transfer(color, B, index); color[index] = '\0'; puts(color); return 0;&#125;int Transfer(char *dst, int number, int index) &#123; int mask = 1, temp = number; while(temp &gt; 12) &#123; temp /= 13; mask *= 13; &#125; temp = number; if(mask &gt; 1) &#123; while(mask) &#123; dst[index++] = Change(temp / mask); temp %= mask; mask /= 13; &#125; &#125; else &#123; index++; dst[index++] = Change(temp); &#125; return index;&#125;char Change(int number) &#123; char ret; if(0 &lt;= number &amp;&amp; number &lt;= 9) &#123; ret = number + '0'; &#125; else &#123; ret = number - 10 + 'A'; &#125; return ret;&#125; 1028 List SortingAnalysis考察排序，用输入的数字表示以元素的某一项进行排序，直接把类别数字用全局变量代替，然后在cmp函数中直接使用即可，注意字符串需要用strcmp函数进行比较。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char id[10], name[15]; int grade;&#125; stu[MAXN];int N, C;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;N, &amp;C); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].id, stu[i].name, &amp;stu[i].grade); &#125; sort(stu, stu + N, cmp); for(int i = 0; i &lt; N; i++) &#123; printf("%s %s %d\n", stu[i].id, stu[i].name, stu[i].grade); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(C == 1) &#123; return strcmp(a.id, b.id) &lt; 0; &#125; else if(C == 2) &#123; int temp = strcmp(a.name, b.name); if(temp != 0) return temp &lt; 0; else return strcmp(a.id, b.id) &lt; 0; &#125; else &#123; if(a.grade != b.grade) return a.grade &lt; b.grade; else return strcmp(a.id, b.id) &lt; 0; &#125;&#125; 1029 MedianAnalysis题目大意是给定两个递增序列，求这两个序列合并后的中位数。 明确了什么是中位数之后，解决这个问题的方法就有很多了。超级无脑的做法就是直接把其中一个序列拼接在另外一个序列后面，排个序，然后直接输出其中位数就好了。但是注意到题目的Memory Limit: 1.5 MB，说明题目对内存有要求，简单直接的做法可能导致Memory Limit Exceeded的错误。 那么就需要想办法优化空间了，题目给定的两个序列，按照上述的思路，就需要三个数组（两个存给定的，一个存合并后的），能不能少用一个或两个呢？答案是肯定的，其实可以不用完全合并，而只需要模拟这个合并操作的过程，并在这个过程中，按照顺序来统计是否枚举到了那个中位数（根据数组下标的初始值，中位数的位置是可以直接算出来的）即可。 不过，很可惜，道高一尺魔高一丈，这个题更新（2018年3月之后？）了测试样例，最后一个测试用例还是无法通过，并且还是MLE的错误。 这就得靠在线处理了，在读入第二个序列时，将每次读入的数字存在一个变量内，每次需要统计第一个序列中有多少数字小于它，然后根据这一点来计算出这个数字在合并后的序列中所处的位置，并与中位数的位置进行比较，然后来决定是否输出。在读入第二个序列的过程中存在两种情况： 数字存在第一个序列内，并且此时可以确定中位数必定比当前读入的数字小 数字存在第二个序列内，就是当前读入的数字 针对上述两种情况，统计到中位数后直接输出即可，但是要注意，若是第二个序列的数字比第一个序列少很多（或者小很多等极端情况），那么中位数依然还是在第一个序列内，所以还是得在第一个序列内找。 Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 200000 + 10;int seq[MAXN];int main(int argc, char const *argv[]) &#123; int n1, n2, temp, count = 0; scanf("%d", &amp;n1); for(int i = 1; i &lt;= n1; i++) &#123; scanf("%d", &amp;seq[i]); &#125; seq[n1 + 1] = 0x7fffffff; scanf("%d", &amp;n2); int median = (n1 + n2 + 1) / 2, i = 1; for(int j = 1; j &lt;= n2; j++) &#123; scanf("%d", &amp;temp); while(seq[i] &lt; temp) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; count++; if(count == median) printf("%d", temp); &#125; while(i &lt;= n1) &#123; count++; if(count == median) printf("%d", seq[i]); i++; &#125; return 0;&#125; 1030 Travel PlanAnalysis题目大意是给定一个旅游地图，每个结点之间的边，包含两个属性值：距离和花销。然后，给定起点和终点，要求输出二者之间的最短路径的总距离和对应的花销，若存在相同总距离的最短路径，此时需输出最小的花销值。 由于题目已经说明输入数据不存在负数，且只有一个起点，问题就变成了不存在负环的图的单源最短路径问题。所以可以直接使用 Dijkstra 算法进行求解。由于需要输出对应的最短路径，所以可以在 Dijkstra 算法求解最短路径的过程中，顺便利用一个数组来保存最优路径，之后再利用 DFS 来正序输出路径；当然，也可以利用动态数组保存所有的路径，之后再利用 DFS 遍历每条路径，来求解花销值最小的路径。 CodeDijkstra12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, s, t, G[maxv][maxv], cost[maxv][maxv];int d[maxv], c[maxv], pre[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; fill(d, d + maxv, inf); // do not forget initialize the distance array for(int i = 0; i &lt; n; i++) pre[i] = i; d[s] = 0; c[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; u = j; min = d[j]; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; c[v] = c[u] + cost[u][v]; pre[v] = u; // save the precursor &#125; else if(d[u] + G[u][v] == d[v]) &#123; if(c[u] + cost[u][v] &lt; c[v]) &#123; // more optimized result c[v] = c[u] + cost[u][v]; pre[v] = u; &#125; &#125; &#125; &#125; &#125;&#125; void dfs(int v) &#123; if(v == s) &#123; cout &lt;&lt; v &lt;&lt; ' '; return; &#125; dfs(pre[v]); cout &lt;&lt; v &lt;&lt; ' ';&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(s); dfs(t); cout &lt;&lt; d[t] &lt;&lt; ' ' &lt;&lt; c[t]; return 0;&#125; Dijkstra + DFS1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 510;const int inf = 0x3fffffff;int n, m, st, ed, G[maxv][maxv], cost[maxv][maxv];int d[maxv], mincost = inf; // mincost need to be initialized to 'inf' bool vis[maxv] = &#123;false&#125;;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[u] + G[u][v] &lt; d[v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); // do not forget clear pre[v].push_back(u); &#125; else if(d[u] + G[u][v] == d[v]) &#123; pre[v].push_back(u); // save other shortest path &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == st) &#123; tempath.push_back(v); int tempcost = 0; for(int i = tempath.size() - 1; i &gt; 0; i--) &#123; int id = tempath[i], idNext = tempath[i - 1]; tempcost += cost[id][idNext]; &#125; if(tempcost &lt; mincost) &#123; path = tempath; mincost = tempcost; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main() &#123; cin &gt;&gt; n &gt;&gt; m &gt;&gt; st &gt;&gt; ed; fill(G[0], G[0] + maxv * maxv, inf); int u, v; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; u &gt;&gt; v; cin &gt;&gt; G[u][v] &gt;&gt; cost[u][v]; G[v][u] = G[u][v], cost[v][u] = cost[u][v]; &#125; dijkstra(st); dfs(ed); for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; path[i] &lt;&lt; ' '; &#125; cout &lt;&lt; d[ed] &lt;&lt; ' ' &lt;&lt; mincost; return 0;&#125; 1031 Hello World For UAnalysis这道题属于打印图形类的题目，题眼大概就是找到图形输出的规律了，所以读题得仔细一点。不过，很巧地是，这道题目，用来找规律的那个条件不是很明显，可能还不太容易看懂（可能我英语渣~），就是这个条件$n_1 = n_3 = max \lbrace{k | k \le n_2\ for\ all\ 3 \le n_2 \le N}\rbrace \ with \ n_1 + n_2 + n3 - 2 = N$了。意思大致是：$n_1 = n_3 \le k$，而$k$这个数是得严格小于等于$n_2$，而$n_2$的取值范围为：$[3, N]$，另外还有一个条件$n_1 + n_2 + n_3 - 2 = N$。 另外，$n_1$是指最左边一列“字符串”的长度，$n_2$是指底部“字符串”的长度，$n_3$是指最右边一列“字符串”的长度，$N$就是严格意义上的字符串长度了。 事实上，$n_1 = n_3 = (N + 2) / 3$，然后求得$n_2$即可开始打印输出了😒。 可以直接打印输出，不过还要找些小规律（折磨你😆），如第一行输出的是字符串第一个字符和最后一个字符；先输出第一个字符，然后输出空格，接着在输出最后一个字符即可。也可以先把每一个字符放到二维数组内，利用空格初始化二维数组，然后在指定位置放入字符，最后输出即可。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;int main(int argc, char const *argv[]) &#123; int n1, n2, n3, N; char str[85]; scanf("%s", str); N = strlen(str); n1 = n3 = (N + 2) / 3; //get n1 and n3 first n2 = N + 2 - 2 * n1; //use the condition: n1 + n2 + n3 - 2 = N for(int i = 0; i &lt; n1; i++) &#123; if(i == n1 - 1) &#123; //print the last line for(int j = i; j &lt;= N - i - 1; j++) &#123; printf("%c", str[j]); &#125; &#125; else &#123; printf("%c", str[i]); for(int j = 0; j &lt; n2 - 2; j++) &#123; putchar(' '); &#125; printf("%c", str[N - i - 1]); &#125; putchar('\n'); &#125; return 0;&#125; 1032 SharingAnalysis题目大意是使用链表存储英文字符时，因为英文字符存在相同的后缀，所以公共后缀只存储一次，然后让不同且具有这个公共后缀单词的最后一个不属于这个后缀的字母的next指向公共后缀的第一个字母即可，这样就可以节约一定的存储空间了。 按照题目背景，题目要求找出具有两个单词的公共后缀的第一个字母的地址并输出，若不存在，则输出-1。直观的做法是，遍历第一个链表，同时遍历第二个链表，找到二者中具有相同address的元素，输出即可，此时的时间复杂度为：$O(n^2)$。 按照题目给定的形式，使用静态链表来处理问题，接着上面的思考，若在遍历第一个链表时，给其每一个结点都加上一个标志位；接着在遍历第二个链表时，就可以直接判断第二个链表的结点的标志位是否与第一个链表结点的标志位相同，若相同，则这个结点就是二者公共后缀的第一个字母了，就可以输出了，这样时间复杂度就降为：$O(n)$了。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 100010;struct Node&#123; char data; int next; bool flag;&#125; node[maxn];int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int head1, head2, n; scanf("%d %d %d", &amp;head1, &amp;head2, &amp;n); int address, next; char data; for(int i = 0; i &lt; n; i++) &#123; scanf("%d %c %d", &amp;address, &amp;data, &amp;next); node[address].next = next; node[address].data = data; &#125; int p; for(p = head1; p != -1; p = node[p].next) &#123; node[p].flag = true; &#125; for(p = head2; p != -1; p = node[p].next) &#123; if(node[p].flag == true) break; &#125; if(p != -1) &#123; printf("%05d\n", p); &#125; else &#123; printf("-1\n"); &#125; return 0;&#125; 1033 To Fill or Not to FillAnalysis此题考察贪心算法，如何进行“贪心”得从结果和题意上去分析。 依据结果，每次经过一个加油站时，需要将当前加油站与小车从当前加油站能到达的每个加油站的油价进行比较，若存在油价更低的加油站，那么就加刚好能到达那个加油站的油量，否则就加满。所以需要将加油站按照离杭州的距离从小到大进行排列，并假设目的地离杭州的距离为输入距离，油价为0（这样做的目的是为了方便比较，不用处理特殊情况）。然后，开始模拟小车从起点出发。 当第一个加油站离杭州的距离不为0时，说明小车无法出城，直接输出The maximum travel distance = 0.00即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 500 + 5;const int INF = 1000000000;struct station &#123; double price, dis;&#125; sta[MAXN];bool cmp(station a, station b);int main(int argc, char const *argv[]) &#123; double cmax, d, davg; int N; scanf("%lf %lf %lf %d", &amp;cmax, &amp;d, &amp;davg, &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf %lf", &amp;sta[i].price, &amp;sta[i].dis); &#125; sta[N].price = 0; sta[N].dis = d; sort(sta, sta + N, cmp); if(sta[0].dis != 0) &#123; printf("The maximum travel distance = 0.00\n"); &#125; else &#123; int now = 0; double ans = 0, capacity = 0, max = cmax * davg; while(now &lt; N) &#123; int k = -1; double priceMin = INF; for(int i = now + 1; i &lt;= N &amp;&amp; sta[i].dis - sta[now].dis &lt;= max; i++) &#123; if(sta[i].price &lt; priceMin) &#123; priceMin = sta[i].price; k = i; if(priceMin &lt; sta[now].price) &#123; break; &#125; &#125; &#125; if(k == -1) break; double need = (sta[k].dis - sta[now].dis) / davg; if(priceMin &lt; sta[now].price) &#123; if(capacity &lt; need) &#123; ans += (need - capacity) * sta[now].price; capacity = 0; &#125; else &#123; capacity -= need; &#125; &#125; else &#123; ans += (cmax - capacity) * sta[now].price; capacity = cmax - need; &#125; now = k; &#125; if(now == N) &#123; printf("%.2lf\n", ans); &#125; else &#123; printf("The maximum travel distance = %.2lf\n", sta[now].dis + max); &#125; &#125; return 0;&#125;bool cmp(station a, station b) &#123; return a.dis &lt; b.dis;&#125; 1034 Head of a GangAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;const int maxn = 2010;const int INF = 1000000000;map&lt;int, string&gt; intTostring;map&lt;string, int&gt; stringToint;map&lt;string, int&gt; Gang;int G[maxn][maxn] = &#123;0&#125;, weight[maxn] = &#123;0&#125;;int n, k, numPerson = 0;bool visited[maxn] = &#123;false&#125;;void DFS(int nowVisit, int &amp;head, int &amp;numMember, int &amp;totalValue) &#123; numMember++; visited[nowVisit] = true; if(weight[nowVisit] &gt; weight[head]) &#123; head = nowVisit; &#125; for(int i = 0; i &lt; numPerson; i++) &#123; if(G[nowVisit][i] &gt; 0) &#123; totalValue += G[nowVisit][i]; G[nowVisit][i] = G[i][nowVisit] = 0; if(visited[i] == false) &#123; DFS(i, head, numMember, totalValue); &#125; &#125; &#125;&#125;void DFSTrave() &#123; for(int i = 0; i &lt; numPerson; i++) &#123; if(visited[i] == false) &#123; int head = i, numMember = 0, totalValue = 0; DFS(i, head, numMember, totalValue); if(numMember &gt; 2 &amp;&amp; totalValue &gt; k) &#123; Gang[intTostring[head]] = numMember; &#125; &#125; &#125;&#125;int change(string s) &#123; if(stringToint.find(s) != stringToint.end()) &#123; return stringToint[s]; &#125; else &#123; stringToint[s] = numPerson; intTostring[numPerson] = s; return numPerson++; &#125;&#125;int main(int argc, char const *argv[]) &#123; int w; string s1, s2; cin &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; w; int id1 = change(s1); int id2 = change(s2); weight[id1] += w; weight[id2] += w; G[id1][id2] += w; G[id2][id1] += w; &#125; DFSTrave(); cout &lt;&lt; Gang.size() &lt;&lt; endl; map&lt;string, int&gt;::iterator it; for(it = Gang.begin(); it != Gang.end(); it++) &#123; cout &lt;&lt; it-&gt;first &lt;&lt; ' ' &lt;&lt; it-&gt;second &lt;&lt; endl; &#125; return 0;&#125; 1035 PasswordAnalysis题目看着臭长臭长的，其实比较简单，就是有些小小的细节... 先分析输入格式，给个N代表N组数据，然后每一组数组按照name password的格式来给出，都是字符串，由于输出时后要同等输出，所以方便起见定义一个结构体来保存这些数据；再者，由于最后得先输出被修改的数量，所以得先把数据都存储下来，才能在输出数量后，在输出修改的信息。 再看输出格式，若有修改，就输出修改的数量，然后每行紧接着每个结构体内的信息；若没有修改，就输出There are N accounts and no account is modified，注意这里的细节，当N为1时，得输出There is 1 accounts and no account is modified，这两句英文在N为1和其他数时使用的Be动词不一样（老师出题很严谨的，🤣英语要学好，哈哈~）。 其他就没什么了。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;const int MAXN = 1000 + 5;struct info &#123; char name[12], password[12]; int flag;&#125; Info[MAXN];int main(int argc, char const *argv[]) &#123; int N, count = 0; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s", Info[i].name, Info[i].password); char *p = Info[i].password; while(*p != '\0') &#123; if(*p == '1') &#123; *p = '@'; Info[i].flag = 5; &#125; else if(*p == '0') &#123; *p = '%'; Info[i].flag = 5; &#125; else if(*p == 'l') &#123; *p = 'L'; Info[i].flag = 5; &#125; else if(*p == 'O') &#123; *p = 'o'; Info[i].flag = 5; &#125; p++; &#125; if(Info[i].flag != 5) &#123; count++; &#125; &#125; if(count == N) &#123; if(count == 1) printf("There is %d account and no account is modified\n", count); else printf("There are %d accounts and no account is modified", count); &#125; else &#123; printf("%d\n", N - count); for(int i = 0; i &lt; N; i++) &#123; if(Info[i].flag == 5) &#123; printf("%s %s\n", Info[i].name, Info[i].password); &#125; &#125; &#125; return 0;&#125; 1036 Boys vs GirlsAnalysis题目意思很简单，找出女生中分最高的，男生中分最低的，分别输出他们的姓名、学号和分数之差即可，由于最后需要的两个结果可能没有出现，利用两个标记来记录状态，然后根据4种不同的状态，分别对应输出即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;struct student&#123; char name[15]; char id[15]; char gender; int grade;&#125; Fhighest, Mlowest, temp;void Init();bool Highest(student a, student b);bool Lowest(student a, student b);int main(int argc, char const *argv[]) &#123; Init(); int N; bool Fflag = false, Mflag = false; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %c %s %d", temp.name, &amp;temp.gender, temp.id, &amp;temp.grade); if(temp.gender == 'F') &#123; if(Highest(temp, Fhighest)) &#123; Fhighest = temp; Fflag = true; &#125; &#125; else if(temp.gender == 'M') &#123; if(Lowest(temp, Mlowest)) &#123; Mlowest = temp; Mflag = true; &#125; &#125; &#125; if(!Fflag &amp;&amp; !Mflag) &#123; printf("Absent\nAbsent\nNA\n"); &#125; else if(Fflag &amp;&amp; !Mflag) &#123; printf("%s %s\nAbsent\nNA\n", Fhighest.name, Fhighest.id); &#125; else if(!Fflag &amp;&amp; Mflag) &#123; printf("Absent\n%s %s\nNA\n", Mlowest.name, Mlowest.id); &#125; else &#123; printf("%s %s\n%s %s\n%d\n", Fhighest.name, Fhighest.id, Mlowest.name, Mlowest.id, Fhighest.grade - Mlowest.grade); &#125; return 0;&#125;void Init() &#123; Fhighest.grade = -1; Mlowest.grade = 100;&#125;bool Highest(student a, student b) &#123; return a.grade &gt;= b.grade;&#125;bool Lowest(student a, student b) &#123; return a.grade &lt;= b.grade;&#125; 1037 Magic CouponAnalysis这道题考察贪心算法，题目要求输出可以得到的最大钱数。注意这段话：print in a line the maximum amount of money you can get back的表述，所以只需要得到能得到的最大值就可以了，不需要统计负数的情况。若只统计一张券乘以一件商品价格的结果为正数的情况，就分为两种： 券值为正，商品价格为正，面值最大的券需要乘以价格最高的商品，就能得到最大的结果 券值为负，商品价格为负，面值最小（负数）的券需要乘以价格最低（负数）的商品，就能得到最大的结果 利用两个数组来分别存储券值和商品价格，按照大小排序后，开始相乘，计算最终结果。注意，升序和降序不影响结果，但需要两种情况需要分开处理。 Code12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int Nc, Np, coupon[MAXN] = &#123;0&#125;, product[MAXN] = &#123;0&#125;; scanf("%d", &amp;Nc); for(int i = 0; i &lt; Nc; i++) &#123; scanf("%d", &amp;coupon[i]); &#125; scanf("%d", &amp;Np); for(int i = 0; i &lt; Np; i++) &#123; scanf("%d", &amp;product[i]); &#125; sort(coupon, coupon + Nc); sort(product, product + Np); int i = 0, j, ans = 0; while(i &lt; Nc &amp;&amp; i &lt; Np &amp;&amp; coupon[i] &lt; 0 &amp;&amp; product[i] &lt; 0) &#123; ans += coupon[i] * product[i]; i++; &#125; i = Nc - 1; j = Np - 1; while(i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; coupon[i] &gt; 0 &amp;&amp; product[j] &gt; 0) &#123; ans += coupon[i] * product[j]; i--, j--; &#125; printf("%d\n", ans); return 0;&#125; 1038 Recover the Smallest NumberAnalysis题目会给一些数字，要求将给定的所有数字“拼接”起来，最终得到一个组合数，这个数字要比按照其他方式组合得到的结果小。 由于不能打乱给定的每个数字的数位顺序，所以一般会想到直接按照字典序比较每个数字的大小，然后让小的的在前面，大的在后面。但要注意，如果数字32, 321，按字典序大小排列后的组合数是32321，此时存在更小的结果32132，所以不能单纯的按照这种思路进行。 对于32, 321这两个数字而言，按照上面的结果：32132 &lt; 32321，从字符串的角度出发，假设a = 32, b = 321，则有ba &lt; ab，这样就可以在两个数中找出“拼接”出的最小数了。按照这种思路，对每一个数字（以字符串形式存储）都这样排序，最后逐个输出的结果就是题目要求的最小数字了。 确定要用字符串了后，直接使用STL内的string类可以很方便的对字符串进行操作。 注意，当输入的全部为0时，需要特判输出0。 Code123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;string str[MAXN];bool cmp(string a, string b);int main(int argc, char const *argv[]) &#123; int n; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; str[i]; &#125; sort(str, str + n, cmp); string ans; for(int i = 0; i &lt; n; i++) &#123; ans += str[i]; &#125; while(ans.size() != 0 &amp;&amp; ans[0] == '0') &#123; ans.erase(ans.begin()); &#125; if(ans.size() == 0) &#123; cout &lt;&lt; 0; &#125; else &#123; cout &lt;&lt; ans; &#125; return 0;&#125;bool cmp(string a, string b) &#123; return a + b &lt; b + a;&#125; 1039 Course List for StudentAnalysis题目大意是给定课程数目和每门课程参加的学生姓名，当用学生姓名查找时，输出该名学生所有的课程。 根据题目要求，需要保存每名学生的选课信息，课程都是用数字代替的，所以使用数组就可以满足需求。由于需要按序输出每名学生的课程编号，所以需要对每名学生的课程编号进行排序；并且，还需要先输出该名学生选课的总数。综合考虑后，使用vector来保存数据比较合适。另外为了便于查找，采用散列的思想，将学生的姓名转换为数字，作为下标来保存数据。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int N = 40010;const int M = 26 * 26 * 26 * 10 + 1;vector&lt;int&gt; selectCourse[M];int getID(char *name) &#123; int id = 0; for(int i = 0; i &lt; 3; i++) &#123; id = id * 26 + (name[i] - 'A'); &#125; id = id * 10 + (name[3] - '0'); return id;&#125;int main(int argc, char const *argv[]) &#123; char name[5]; int n, k; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; k; i++) &#123; int course, x; scanf("%d %d", &amp;course, &amp;x); for(int j = 0; j &lt; x; j++) &#123; scanf("%s", name); int id = getID(name); selectCourse[id].push_back(course); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; scanf("%s", name); int id = getID(name); sort(selectCourse[id].begin(), selectCourse[id].end()); printf("%s %d", name, selectCourse[id].size()); for(int j = 0; j &lt; selectCourse[id].size(); j++) &#123; printf(" %d", selectCourse[id][j]); &#125; putchar('\n'); &#125; return 0;&#125; 1040 Longest Symmetric StringAnalysis题目大意是给定一个字符串，找出其中的最长回文子串。此题并没有设置超时测试点，直接使用暴力解法可以过。不过，这类最长公共子串（Longest Palindromic Substring）的题目，还有另外一种思路——动态规划。 CodeViolent Solution123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;bool palindrome(char *s1, char *s2) &#123; bool flag = true; for(; s1 &lt; s2; s1++, s2--) &#123; if(*s1 != *s2) &#123; flag = false; break; &#125; &#125; return flag;&#125;int main(int argc, char const *argv[]) &#123; char str[maxn]; fgets(str, maxn, stdin); char *p1, *p2; int max_len = 0, temp; for(p1 = str; *p1 != '\0'; p1++) &#123; for(p2 = p1 + 1; *p2 != '\0'; p2++) &#123; if(*p1 == *p2) &#123; temp = p2 - p1; if(temp &lt;= max_len) continue; else if(palindrome(p1, p2)) max_len = temp; &#125; &#125; &#125; printf("%d", max_len + 1); return 0;&#125; DP123456789101112131415161718192021222324252627282930#include &lt;cstdio&gt;#include &lt;cstring&gt;const int maxn = 1010;char str[maxn];int dp[maxn][maxn];int main(int argc, char const *argv[]) &#123; fgets(str, maxn, stdin); int len = strlen(str), ans = 1; memset(dp, 0, sizeof(dp)); for(int i = 0; i &lt; len; i++) &#123; dp[i][i] = 1; if(i &lt; len - 1) &#123; if(str[i] == str[i + 1]) &#123; dp[i][i + 1] = 1; ans = 2; &#125; &#125; &#125; for(int l = 3; l &lt;= len; l++) &#123; for(int i = 0; i + l - 1 &lt; len; i++) &#123; int j = i + l - 1; if(str[i] == str[j] &amp;&amp; dp[i + 1][j - 1] == 1) &#123; dp[i][j] = 1; ans = l; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 Be UniqueAnalysis根据题目要求，最先猜到只出现一次的数字就赢了，所以得先按照顺序读入每个数，同时统计每个数字的出现次数。然后再按照输入顺序，检查每个数字的出现次数，若出现一次即为赢的那个数字。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int N, Num[MAXN] = &#123;0&#125;, times[MAXN] = &#123;0&#125;; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Num[i]); times[Num[i]]++; &#125; int i; for(i = 0; i &lt; N; i++) &#123; if(times[Num[i]] == 1) &#123; printf("%d", Num[i]); break; &#125; &#125; if(i == N) &#123; printf("None"); &#125; return 0;&#125; 1042 Shuffling MachineAnalysis根据题目的例子，读懂题目，注意仅在一个数组内交换元素会 WA ，要用两个数组进行倒换才能得到正确的结果。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;iostream&gt;using namespace std;char playcards[55][5] = &#123; " ", "S1", "S2", "S3", "S4", "S5", "S6", "S7", "S8", "S9", "S10", "S11", "S12", "S13", "H1", "H2", "H3", "H4", "H5", "H6", "H7", "H8", "H9", "H10", "H11", "H12", "H13", "C1", "C2", "C3", "C4", "C5", "C6", "C7", "C8", "C9", "C10", "C11", "C12", "C13", "D1", "D2", "D3", "D4", "D5", "D6", "D7", "D8", "D9", "D10", "D11", "D12", "D13", "J1", "J2",&#125;;int main() &#123; int k, arr[55], brr[55], order[55], flag = 1; cin &gt;&gt; k; for(int i = 1; i &lt;= 54; i++) &#123; cin &gt;&gt; order[i]; brr[i] = i; &#125; while(k--) &#123; if(flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; arr[order[i]] = brr[i]; &#125; flag = 0; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; brr[order[i]] = arr[i]; &#125; flag = 1; &#125; &#125; if(!flag) &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[arr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; else &#123; for(int i = 1; i &lt;= 54; i++) &#123; cout &lt;&lt; playcards[brr[i]]; if(i != 54) cout &lt;&lt; ' '; &#125; &#125; return 0;&#125; 1043 Is It a Binary Search TreeAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;struct node &#123; int data; node *left, *right; &#125;;void insert(node *&amp;root, int data) &#123; if(root == NULL) &#123; root = new node; root-&gt;data = data; root-&gt;left = root-&gt;right = NULL; return; &#125; if(data &lt; root-&gt;data) insert(root-&gt;left, data); else insert(root-&gt;right, data);&#125;void preorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preorder(root-&gt;left, vi); preorder(root-&gt;right, vi);&#125;void preordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; vi.push_back(root-&gt;data); preordermirror(root-&gt;right, vi); preordermirror(root-&gt;left, vi);&#125;void postorder(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postorder(root-&gt;left, vi); postorder(root-&gt;right, vi); vi.push_back(root-&gt;data);&#125;void postordermirror(node *root, vector&lt;int&gt; &amp;vi) &#123; if(root == NULL) return; postordermirror(root-&gt;right, vi); postordermirror(root-&gt;left, vi); vi.push_back(root-&gt;data);&#125;vector&lt;int&gt; origin, pre, preM, post, postM;int main(int argc, char const *argv[]) &#123; int n, data; node *root = NULL; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;data); origin.push_back(data); insert(root, data); &#125; preorder(root, pre); preordermirror(root, preM); postorder(root, post); postordermirror(root, postM); if(origin == pre) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; post.size(); i++) &#123; cout &lt;&lt; post[i]; if(i &lt; post.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else if(origin == preM) &#123; cout &lt;&lt; "YES\n"; for(int i = 0; i &lt; postM.size(); i++) &#123; cout &lt;&lt; postM[i]; if(i &lt; postM.size() - 1) cout &lt;&lt; ' '; &#125; &#125; else &#123; cout &lt;&lt; "NO\n"; &#125; return 0;&#125; 1044 Shopping in MarsAnalysis先分析题目输入，第一行给定两个数字，第一个数字代表一条“链”上钻石的数量，第二个数字则代表需要支付的钱；第二行依次给出“链”上每颗钻石的对应的价值（用于支付）。 然后，题目要求从这条“链”中找出能刚好用于支付（钻石的价值和与待支付的钱相等）的“钻石序列”，当然，若是没有完全相等的情况，找出刚好大于待支付的钱的钻石序列，也是可以的。 将本体的题意抽象出来就是，给定一个序列，找出这个序列中连续子序列和刚好大于或等于给定数字的所有子序列（如果有相等的情况，就不需要再找大于的情况）。 按照这样的思路，可以使用一个sum数组来保存连续的子序列和（每次累加即可），这样在i和j之间的子序列和就是sum[j] - sum[i - 1]，这个思想与1046是一致的。这样，要做的事情就是从sum这个数组中找出满足条件的序列了。同时注意到，由于sum数组是累加得出的，所以一定是严格递增的，也就可以使用二分查找来找这个值。 注意题目的条件：It is guaranteed that the total value of diamonds is sufficient to pay the given amount.，说明肯定会有解，那么对应的也就只有两种情况： 能找到相等的序列，此时由于序列本身就是严格递增的 只能找到刚好大于给定值的序列，此时需要用一个变量nearS来保存刚好大于给定值的连续子序列和 找到合理的值后，按照这个值输出即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;const int MAXN = 100000 + 10;int sum[MAXN];int n, S, nearS = 100000000 + 10;int UpperBound(int L, int R, int x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;S); sum[0] = 0; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;sum[i]); sum[i] += sum[i - 1]; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + S); if(sum[j - 1] - sum[i - 1] == S) &#123; nearS = S; break; &#125; else if(j &lt;= n &amp;&amp; sum[j] - sum[i - 1] &lt; nearS) &#123; nearS = sum[j] - sum[i - 1]; &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; int j = UpperBound(i, n + 1, sum[i - 1] + nearS); if(sum[j - 1] - sum[i - 1] == nearS) &#123; printf("%d-%d\n", i, j - 1); &#125; &#125; return 0;&#125;int UpperBound(int L, int R, int x) &#123; int left = L, right = R, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(sum[mid] &gt; x) &#123; right = mid; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125; 1045 Favorite Color StripeAnalysis题目大意：用不同的数字表示不同的颜色，一共有 220 种颜色，给定一串数字序列，作为 Eva 喜欢的颜色种类（越靠后越喜欢），然后在给定一串数字序列。现在从中挑出 Eva 喜欢的所有数字，并且要求按照给定的顺序进行排列，求出这个最大的长度。 如果直接使用暴力解法，定会超时，要想完美解决这个问题，思考的方向有两个，但都包含了动态规划（Dynamic Programming）的思想： 从最长非递减序列的角度思考 从最长公共子串的角度思考 CodeLIS123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int stripe[maxn], hashTable[maxc], dp[maxn];int main(int argc, char const *argv[]) &#123; int n, m, x; cin &gt;&gt; n &gt;&gt; m; memset(hashTable, -1, sizeof(hashTable)); for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; x; hashTable[x] = i; &#125; int l, num = 0; cin &gt;&gt; l; for(int i = 0; i &lt; l; i++) &#123; cin &gt;&gt; x; stripe[num++] = hashTable[x]; &#125; int ans = -1; for(int i = 0; i &lt; num; i++) &#123; dp[i] = 1; for(int j = 0; j &lt; i; j++) &#123; if(stripe[j] &lt;= stripe[i] &amp;&amp; dp[i] &lt; dp[j] + 1) &#123; dp[i] = dp[j] + 1; &#125; &#125; ans = max(ans, dp[i]); &#125; cout &lt;&lt; ans; return 0;&#125; LCS123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxc = 210;const int maxn = 10010;int A[maxc], B[maxn], dp[maxc][maxn];int main(int argc, char const *argv[]) &#123; int n, m; cin &gt;&gt; n &gt;&gt; m; for(int i = 1; i &lt;= m; i++) &#123; cin &gt;&gt; A[i]; &#125; int l; cin &gt;&gt; l; for(int i = 1; i &lt;= l; i++) &#123; cin &gt;&gt; B[i]; &#125; for(int i = 1; i &lt;= m; i++) &#123; dp[i][0] = 0; &#125; for(int j = 1; j &lt;= l; j++) &#123; dp[0][j] = 0; &#125; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= l; j++) &#123; int Max = max(dp[i - 1][j], dp[i][j - 1]); if(A[i] == B[j]) &#123; dp[i][j] = Max + 1; &#125; else &#123; dp[i][j] = Max; &#125; &#125; &#125; cout &lt;&lt; dp[m][l]; return 0;&#125; 1046 Shortest DistanceAnalysis题目意思很明确，给你一个“环”形地图，问你从这里到那里怎么走最近。根据题目意思，一般都有两种走法，一种顺着环走，一种逆着环走，找出二者的最小值即可。 一般而言，我们分别找出其中两次的值，进行比较后输出最小值即可。不过由于地名是按照数字给出的，可能会出现起始点的数字大于终点的情况，此时最好交换二者的值，或者分情况讨论。 另外，还可以发现，如果求出了一种走法，那么按照环形地图的特点，利用总距离减去求得的不就得到另一种走法的距离了吗？ 把握住上面的点后，可以通过0和1两个测试点了，第三个测试点会因为超时无法通过。 在仔细分析一下，如果一开始用一个数组Dis[MAXN]，按照顺序表示1号地点到达其他地点的距离，那么对于每一次查询的start和end，其距离就是Dis[end - 1] - Dis[start - 1]。以样例为例，可以得到数组（下标从1开始）Dis[6] = {0, 1, 3, 7, 21, 30}，此时如果要计算5到2的距离，根据思路就是：Dis[5 - 1] - Dist[2 - 1] = 21 - 1 = 20，这就是按顺序方向从2到5的距离。 此法恐怖之极在于原本时间复杂度为 $O(n)$ 的查找一下子就变为 $O(1)$ 了。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; int M, N, Exits[MAXN] = &#123;0&#125;, Dis[MAXN], Sum_D = 0, src, dst; scanf("%d", &amp;N); for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;Exits[i]); Sum_D += Exits[i]; Dis[i] = Sum_D; &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d %d", &amp;src, &amp;dst); if(src &gt; dst) &#123; swap(src, dst); &#125; int temp = Dis[dst - 1] - Dis[src - 1]; printf("%d\n", temp &lt; (Sum_D - temp) ? temp : (Sum_D - temp)); &#125; return 0;&#125; 1047 Student List for CourseAnalysis此题与1039的题目背景完全一样，输入与输出正好相反，思路也是类似的。只是本题，不需要在利用散列了。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 40010;const int maxc = 2510;char name[maxn][5];vector&lt;int&gt; course[maxc];bool cmp(int a, int b) &#123; return strcmp(name[a], name[b]) &lt; 0;&#125;int main(int argc, char const *argv[]) &#123; int n, k, c, courseID; scanf("%d %d", &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%s %d", name[i], &amp;c); for(int j = 0; j &lt; c; j++) &#123; scanf("%d", &amp;courseID); course[courseID].push_back(i); &#125; &#125; for(int i = 1; i &lt;= k; i++) &#123; printf("%d %d\n", i, course[i].size()); sort(course[i].begin(), course[i].end(), cmp); for(int j = 0; j &lt; course[i].size(); j++) &#123; printf("%s\n", name[course[i][j]]); &#125; &#125; return 0;&#125; 1048 Find CoinsAnalysis给定硬币种类和面值，按照题目要求输出和与题目相等两枚硬币，要求V1的面值小于等于V2。在输入时，利用散列的思路，先将每一枚硬币的个数统计下来。然后，利用sort将面值按升序排序，这样方便查找。输出时注意以下几点： V1和V2相等时，要判断这枚硬币时候有两枚 当V1和V2相等时，就已经是题目要求的最后一种情况了，若这种情况都不合条件，就没必要再继续查找下去了，所以使用一个标识flag来协助输出 注意所使用数组的下标，以免调用sort时出错 只要V1最小的那一组就行了，所以要在循环内调用break Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int main(int argc, char const *argv[]) &#123; int N, M, coins[MAXN]; scanf("%d %d", &amp;N, &amp;M); int value[MAXN] = &#123;0&#125;; for(int i = 1; i &lt;= N; i++) &#123; scanf("%d", &amp;coins[i]); value[coins[i]]++; &#125; sort(coins + 1, coins + N + 1); int i, v1, v2; bool flag = false; for(i = 1; i &lt;= N; i++) &#123; v1 = coins[i]; v2 = M - v1; if(value[v1] &amp;&amp; value[v2]) &#123; if(v1 == v2 &amp;&amp; value[v1] != 2) &#123; break; &#125; printf("%d %d", v1, v2); flag = true; break; &#125; &#125; if(!flag) &#123; printf("No Solution"); &#125; return 0;&#125; 1050 String SubtractionAnalysis利用散列的思想来处理，先遍历第一个字符串统计其中所有字符的出现次数（也可以只用true或false来区分），然后遍历第二个字符串，将同时出现在两个字符串内的字符的次数标记为0，然后按照第一个字符串的顺序，输出标记不是0的字符即可。 Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int times[128] = &#123;0&#125;; char *p = str2; while(*p != '\0') &#123; times[*p++] = 1; &#125; p = str1; while(*p != '\0') &#123; if(!times[*p]) &#123; putchar(*p); &#125; p++; &#125; return 0;&#125; 1051 Pop SequenceAnalysis题目大意是给定一个栈的容量、出战序列长度和可能的出栈序列，判断在当前栈的长度下，出栈序列是否合法，若是，输出YES，反之，输出NO。 按照题目的要求模拟栈的操作即可，使用 C++ 的stack容器可以很方便的完成这个需求。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;const int maxn = 1010;int arr[maxn] = &#123;0&#125;;stack&lt;int&gt; st;int main(int argc, char const *argv[]) &#123; int m, n, t; scanf("%d %d %d", &amp;m, &amp;n, &amp;t); while(t--) &#123; while(!st.empty()) &#123; //clear stack st.pop(); &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;arr[i]); &#125; int current = 1; bool flag = true; for(int i = 1; i &lt;= n; i++) &#123; st.push(i); if(st.size() &gt; m) &#123; flag = false; break; &#125; while(!st.empty() &amp;&amp; st.top() == arr[current]) &#123; st.pop(); current++; &#125; &#125; if(st.empty() == true &amp;&amp; flag == true) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125; 1052 Linked List SortingAnalysis题目背景是属于链表的应用，实际是模拟链表的操作，使用静态链表模拟较为方便。 静态链表需要借助散列的概念，借助结构数组，使用题目给定的地址对应数组的下标，可以较为方便的存储结点值和下一个元素的地址。 题目要求的排序可以使用sort函数来完成，此时要注意由于题目可能会输入无效结点，所以需要增加一个flag来判断是否属于无效结点，这样sort函数才能将有效结点按序排好，并将无效结点排在最后一个有效结点的后面。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct Node &#123; int address, data, next; bool flag;&#125; node[maxn];bool cmp(Node a, Node b) &#123; if(a.flag == false || b.flag == false) &#123; return a.flag &gt; b.flag; &#125; else &#123; return a.data &lt; b.data; &#125;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; node[i].flag = false; &#125; int n, begin, address; scanf("%d %d", &amp;n, &amp;begin); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;node[address].data, &amp;node[address].next); node[address].address = address; &#125; int count = 0, p = begin; while(p != -1) &#123; node[p].flag = true; count++; p = node[p].next; &#125; if(count == 0) &#123; printf("0 -1"); &#125; else &#123; sort(node, node + maxn, cmp); printf("%d %05d\n", count, node[0].address); for(int i = 0; i &lt; count; i++) &#123; if(i != count - 1) &#123; printf("%05d %d %05d\n", node[i].address, node[i].data, node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", node[i].address, node[i].data); &#125; &#125; &#125; return 0;&#125; 1053 Path of Equal WeightAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1054 The Dominant ColorAnalysis题目大意是给定一个矩阵，找出其中超过矩阵一半元素个数的值。题目保证测试样例中会有答案，也就是说，有一半的矩阵元素都是同一个数字，那么毫无疑问，这个元素的出现次数一定是这个矩阵所有元素出现次数的最大值，所以直接查找最大值即可。 由于像素点是由0-24位数字字符组成，所以需要将矩阵内元素当作字符串对待，同时需要建立与次数的唯一映射，使用 C++ 的map容器可以很方便的完成这个操作。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; color;int main(int argc, char const *argv[]) &#123; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; temp = n * m; getchar(); while(temp--) &#123; string s; cin &gt;&gt; s; color[s]++; &#125; temp = n * m; map&lt;string, int&gt;::iterator max = color.begin(); map&lt;string, int&gt;::iterator it = color.begin(); for(; it != color.end(); it++) &#123; if(it-&gt;second &gt; max-&gt;second) &#123; max = it; &#125; &#125; cout &lt;&lt; max-&gt;first; return 0;&#125; 1055 The World’s RichestAnalysis先按照题目要求排好序，然后按照题目给定的年龄区间进行输出，注意没有符合的输出时，需要输出None。 此时，考虑到题目给的条件$M (\le 100)$，说明对于同一个年龄的数据，最多只输出100项。所以可以新建一个数组，然后按照排好序的序列，顺序保存每个年龄的数据，但只保存100个，这样在查找的时候能极大的节约时间。 尽管这道题在甲级题库内的时间限制是500ms，考试的时候说不定就是200ms了，要注意用最优解法。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;int Age[MAXN] = &#123;0&#125;;struct people&#123; char name[10]; int age, worth;&#125; peo[MAXN], valid[MAXN];bool cmp(people a, people b);int main(int argc, char const *argv[]) &#123; int N, K; scanf("%d %d", &amp;N, &amp;K); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", peo[i].name, &amp;peo[i].age, &amp;peo[i].worth); &#125; sort(peo, peo + N, cmp); int validNum = 0; for(int i = 0; i &lt; N; i++) &#123; if(Age[peo[i].age] &lt; 100) &#123; Age[peo[i].age]++; valid[validNum++] = peo[i]; &#125; &#125; int M, Amin, Amax; for(int i = 1; i &lt;= K; i++) &#123; bool flag = false; scanf("%d %d %d", &amp;M, &amp;Amin, &amp;Amax); printf("Case #%d:\n", i); for(int j = 0; j &lt; validNum &amp;&amp; M; j++) &#123; if(Amin &lt;= valid[j].age &amp;&amp; valid[j].age &lt;= Amax) &#123; printf("%s %d %d\n", valid[j].name, valid[j].age, valid[j].worth); M--; flag = true; &#125; &#125; if(!flag) &#123; printf("None\n"); &#125; &#125; return 0;&#125;bool cmp(people a, people b) &#123; if(a.worth != b.worth) return a.worth &gt; b.worth; else if(a.age != b.age) return a.age &lt; b.age; else return strcmp(a.name, b.name) &lt; 0;&#125; 1056 Mice and RiceAnalysis题目背景是一个叫做 Mice and Rice 的游戏，根据题目的描述可以知道，体重数字最大的老鼠就是胜利的老鼠，并且在本题中，老鼠之间的比赛需要分组进行，分组大小会给出。注意all the mice left will be put into the last group是指，由于可能存在最后一组老鼠少于分组大小的情况，默认将剩余的老鼠全部加入到下一轮比赛中。依次进行每一轮比赛，直至最后得到冠军老鼠，并输出所有老鼠的排名。 按照题目的意思，题目一开始会给定老鼠总数和分组大小，所以可以直接得到这一轮的分组数；同理，每一轮的分组数都可以这样得到。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 1010;struct mouse&#123; int weight; int r;&#125; mouse[maxn];int main(int argc, char const *argv[]) &#123; int np, ng, order; scanf("%d %d", &amp;np, &amp;ng); for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;mouse[i].weight); &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; np; i++) &#123; scanf("%d", &amp;order); q.push(order); &#125; int temp = np, group; while(q.size() != 1) &#123; if(temp % ng == 0) group = temp / ng; else group = temp / ng + 1; for(int i = 0; i &lt; group; i++) &#123; int k = q.front(); for(int j = 0; j &lt; ng; j++) &#123; if(i * ng + j &gt;= temp) break; int front = q.front(); if(mouse[front].weight &gt; mouse[k].weight) &#123; k = front; &#125; mouse[front].r = group + 1; q.pop(); &#125; q.push(k); &#125; temp = group; &#125; mouse[q.front()].r = 1; for(int i = 0; i &lt; np; i++) &#123; printf("%d", mouse[i].r); if(i &lt; np - 1) putchar(' '); &#125; return 0;&#125; 1058 A+B in HogwartsAnalysis题目意思很简单，给你两个在霍格沃茨本地使用的货币数量，加起来就好。就跟生活中$100 + 150 = 250$块一样哈。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;struct money&#123; int g, k, s;&#125; A, B, Result;int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;A.g, &amp;A.s, &amp;A.k, &amp;B.g, &amp;B.s, &amp;B.k); Result.g = A.g + B.g; Result.k = A.k + B.k; Result.s = A.s + B.s; if(Result.k &gt;= 29) &#123; Result.s += (Result.k / 29); Result.k %= 29; &#125; if(Result.s &gt;= 17) &#123; Result.g += (Result.s / 17); Result.s %= 17; &#125; printf("%d.%d.%d\n", Result.g, Result.s, Result.k); return 0;&#125; 1059 Prime FactorsAnalysis题目大意是给定一个正整数，用质数对其进行分解，也即质因子分解。 既然需要用到质数，与其一个一个的判断，不如一开始先将素数表打印好，此题给定的数为long int，则素数表为$10^5$即可。 接着定义一个结构体数组，保存质因子和其个数。对于long int型的数而言，2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 * 23 * 29就已经溢出了，所以结构体数组的大小取10以上即可。 从小到大枚举质因子，如果能整除给定的数，就进入循环，让这个数不断的整除它，从而计算这个质因子的数目。注意，n = 1时，需要特判输出1=1。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;cmath&gt;const int maxn = 100010;bool isPrime(int n) &#123; if(n &lt;= 1) return false; int sqr = sqrt(n); for(int i = 2; i &lt;= sqr; i++) &#123; if(n % i == 0) return false; &#125; return true;&#125;int prime[maxn], pNum = 0;void filterPrime() &#123; for(int i = 1; i &lt; maxn; i++) &#123; if(isPrime(i) == true) &#123; prime[pNum++] = i; &#125; &#125;&#125;struct factor&#123; int x, cnt;&#125; fac[11];int main(int argc, char const *argv[]) &#123; filterPrime(); int n, num = 0; scanf("%d", &amp;n); if(n == 1) printf("1=1"); else &#123; printf("%d=", n); int sqr = sqrt(n); for(int i = 0; i &lt; pNum &amp;&amp; prime[i] &lt;= sqr; i++) &#123; if(n % prime[i] == 0) &#123; fac[num].x = prime[i]; fac[num].cnt = 0; while(n % prime[i] == 0) &#123; fac[num].cnt++; n /= prime[i]; &#125; num++; &#125; if(n == 1) break; &#125; if(n != 1) &#123; fac[num].x = n; fac[num++].cnt = 1; &#125; for(int i = 0; i &lt; num; i++) &#123; if(i &gt; 0) putchar('*'); printf("%d", fac[i].x); if(fac[i].cnt &gt; 1) &#123; printf("^%d", fac[i].cnt); &#125; &#125; &#125; return 0;&#125; 1060 Are They EqualAnalysis这道题考察字符串处理，使用STL内的string容器，并调用其中的一些方法，会十分方便。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int n;string deal(string s, int &amp;e);int main(int argc, char const *argv[]) &#123; string s1, s2, s3, s4; cin &gt;&gt; n &gt;&gt; s1 &gt;&gt; s2; int e1 = 0, e2 = 0; s3 = deal(s1, e1); s4 = deal(s2, e2); if(s3 == s4 &amp;&amp; e1 == e2) &#123; cout &lt;&lt; "YES 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "NO 0." &lt;&lt; s3 &lt;&lt; "*10^" &lt;&lt; e1 &lt;&lt; " 0." &lt;&lt; s4 &lt;&lt; "*10^" &lt;&lt; e2 &lt;&lt; endl; &#125; return 0;&#125;string deal(string s, int &amp;e) &#123; unsigned int k = 0; while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); &#125; if(s[0] == '.') &#123; s.erase(s.begin()); while(s.length() &gt; 0 &amp;&amp; s[0] == '0') &#123; s.erase(s.begin()); e--; &#125; &#125; else &#123; while(k &lt; s.length() &amp;&amp; s[k] != '.') &#123; k++; e++; &#125; if(k &lt; s.length()) &#123; s.erase(s.begin() + k); &#125; &#125; if(s.length() == 0) &#123; e = 0; &#125; int num = 0; k = 0; string res; while(num &lt; n) &#123; if(k &lt; s.length()) &#123; res += s[k++]; &#125; else &#123; res += '0'; &#125; num++; &#125; return res;&#125; 1061 DatingAnalysis这道题与乙级题库的1014是一样的，不难，就是有些地方好像说的不太明确，比如，星期这个信息必须得是属于 $[A, G]$ 的大写字母才能可以进行判断... Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;char *Week[7] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1062 Talent and VirtueAnalysis此题与乙级题库 1015 一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student &#123; char id[10]; int scoreD, scoreC, sumDC, flag;&#125; stu[MAXN];int N, L, H, M = 0;bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumDC = stu[i].scoreD + stu[i].scoreC; if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L) &#123; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= L) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreC &gt;= L &amp;&amp; stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else &#123; stu[i].flag = 4; &#125; M++; &#125; else &#123; stu[i].flag = 5; &#125; &#125; printf("%d\n", M); sort(stu, stu + N, cmp); for(int i = 0; i &lt; M; i++) &#123; printf("%s %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumDC != b.sumDC) return a.sumDC &gt; b.sumDC; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return strcmp(a.id, b.id) &lt; 0;&#125; 1063 Set SimilarityAnalysis题目大意是给定若干个集合，给出两个集合的“相似程度”。这里的“相似程度”是指两个集合交集的元素个数除以两个集合并集的元素个数的百分比，且没有重复元素。 按照题目背景，使用 STL 的set来处理这个问题比较方便，优点如下： set在存储数据时，会自动去除重复数据 set内元素的个数，可以直接使用set.size()得到 查找set内元素时，直接使用set.find(elements)即可 使用set读入所有输入数据后，开始查询。每次查询需要得到一个百分比，所以就需要求两个集合交集的元素个数和并集的元素个数。 具体方法是：遍历其中一个集合，令totalNum为另一个集合的元素个数，sameNum为相同元素的个数（初始化为0）。此时在另一个集合中查找当前遍历的集合中的元素，若存在，则sameNum++，反之则totalNum++，遍历结束后，需要的数字就算好了，接着相除得到百分比即可输出。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;const int MAXN = 50 + 5;set&lt;int&gt; st[MAXN];void compare(int x, int y) &#123; int totalNum = st[y].size(), sameNum = 0; for(set&lt;int&gt;::iterator it = st[x].begin(); it != st[x].end(); it++) &#123; if(st[y].find(*it) != st[y].end()) sameNum++; else totalNum++; &#125; printf("%.1lf%\n", sameNum * 100.0 / totalNum);&#125;int main(int argc, char const *argv[]) &#123; int n, m, k, temp; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;m); for(int j = 0; j &lt; m; j++) &#123; scanf("%d", &amp;temp); st[i].insert(temp); &#125; &#125; scanf("%d", &amp;k); while(k--) &#123; int s1, s2; scanf("%d %d", &amp;s1, &amp;s2); compare(s1, s2); &#125; return 0;&#125; 1064 Complete Binary Search TreeAnalysis题目大意是给定结点个数和结点值，建立一颗完全二叉排序树（CBT），根据名称，可以知道这类树既有完全二叉树的性质，又有二叉排序树的性质。 经过上面的分析，使用结构数组建树就十分方便，对完全二叉树而言，数组的下标即代表结点之间的关系，所以直接使用整型数组即可，并且在数组的顺序就是层次遍历的序列。接着要解决的问题就是将结点值赋给结点，根据二叉排序树的性质，利用中序遍历即可完成这个需求。 Code1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int n, number[maxn], CBT[maxn], index = 0;void inorder(int root) &#123; if(root &gt; n) return; inorder(2 * root); CBT[root] = number[index++]; inorder(root * 2 + 1);&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(1); for(int i = 1; i &lt;= n; i++) &#123; cout &lt;&lt; CBT[i]; if(i &lt; n) cout &lt;&lt; ' '; &#125; return 0;&#125; 1065 A+B and C (64bit)Analysis这道题算是乙级题目1011 A+B 和 C的加强版了，题目给定的数据范围是$[-2^{63}, 2^{63}]$，正好是64位带符号整型的数据范围，下面来分析可能出现的各种情况（只用对A和B之和分析就好）： A和B之和仍然在$[-2^{63}, 2^{63}]$之内，可以直接与C进行判断 A和B之和大于$2^{63}$，此时会发生正溢出，且其值的范围为：$[-2^{63}, -2]$（溢出进位，符号为从0变为1，所以为负，剩下63位构成的数字就在这个范围内了）。 A和B之和小于$-2^{63}$，此时会发生负溢出，其值范围为：$[0, 2^{63})$（原理类似） 对应上述三种情况，按照实际规则进行比大小即可。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; // positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; // negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; // normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1066 Root of AVL TreeAnalysis题目大意给定一棵树的结点个数，再给定各个结点的值，建立一颗平衡二叉树（AVL），然后输出结点的值即可。 由于题目需要建立 AVL 树，依据 AVL 树的性质，每个结点的平衡因子绝对值不能大于1，所以在插入每个结点时，需要对树进行调整，使其满足 AVL 树的性质。 AVL 树失衡的情况总共有4种：LL、LR、RR 和 RL 四种，会根据每种情况做对应的旋转即可。注意每次插入结点时都需要检查树是否失衡，这样能够及时调整。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 25;struct node &#123; int v, height; node *left, *right;&#125; *root;int n;node *newnode(int v) &#123; node *Node = new node; Node-&gt;v = v; Node-&gt;height = 1; Node-&gt;left = Node-&gt;right = NULL; return Node;&#125;int getheight(node *root) &#123; if(root == NULL) return 0; return root-&gt;height;&#125;void updateheight(node *root) &#123; root-&gt;height = max(getheight(root-&gt;left), getheight(root-&gt;right)) + 1;&#125;int getbalancefactor(node *root) &#123; return getheight(root-&gt;left) - getheight(root-&gt;right);&#125;void leftRotation(node *&amp;root) &#123; node *temp = root-&gt;right; root-&gt;right = temp-&gt;left; temp-&gt;left = root; updateheight(root); updateheight(temp); root = temp;&#125;void rightRotation(node *&amp;root) &#123; node *temp = root-&gt;left; root-&gt;left = temp-&gt;right; temp-&gt;right = root; updateheight(root); updateheight(temp); root = temp;&#125;void insert(node *&amp;root, int v) &#123; if(root == NULL) &#123; root = newnode(v); return; &#125; if(v &lt; root-&gt;v) &#123; insert(root-&gt;left, v); updateheight(root); if(getbalancefactor(root) == 2) &#123; if(getbalancefactor(root-&gt;left) == 1) &#123; rightRotation(root); &#125; else if(getbalancefactor(root-&gt;left) == -1) &#123; leftRotation(root-&gt;left); rightRotation(root); &#125; &#125; &#125; else &#123; insert(root-&gt;right, v); updateheight(root); if(getbalancefactor(root) == -2) &#123; if(getbalancefactor(root-&gt;right) == -1) &#123; leftRotation(root); &#125; else if(getbalancefactor(root-&gt;right) == 1) &#123; rightRotation(root-&gt;right); leftRotation(root); &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int value; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; value; insert(root, value); &#125; cout &lt;&lt; root-&gt;v; return 0;&#125; 1067 Sort with SwapAnalysis这道题考察贪心，参杂了一些模拟。 对待贪心类的题目，必须得找准贪心的策略，不然就没法解题了，得仔细观察样例。假设数字都存储在数组中，按照题目的说明，可以发现：0值每次交换的对象都是下标值与其本身值不一样的数字。所以，每次将0值与具有上述特点的值交换即可；但要注意，若0的下标为0时，算法就无法继续进行了，此时需要特别处理下，将0与当前值最小且具有上述特点的数字直接进行交换。 这时可以发现，如果从数组头部开始向后查找这样的数字，就会有很多已经排好的数被遍历到。为了避免这样的情况，需要将当前值最小且具有上述特点的数字保存在一个变量内，这样下次查找时直接从这个数字开始就可以避免重复查找的情况了。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int pos[MAXN];int main(int argc, char const *argv[]) &#123; int n, ans = 0; scanf("%d", &amp;n); int left = n - 1, num; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); pos[num] = i; if(num == i &amp;&amp; num != 0) &#123; left--; &#125; &#125; int k = 1; while(left &gt; 0) &#123; if(pos[0] == 0) &#123; while(k &lt; n) &#123; if(pos[k] != k) &#123; swap(pos[0], pos[k]); ans++; break; &#125; k++; &#125; &#125; while(pos[0] != 0) &#123; swap(pos[0], pos[pos[0]]); ans++; left--; &#125; &#125; printf("%d\n", ans); return 0;&#125; 1069 The Black Hole of NumbersAnalysis此题与乙级题库的1019一样 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1070 MooncakeAnalysis此题与乙级题库的1020类似（好像只是数据不一样），考察贪心。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store, sell, price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; ans += cake[i].sell; D -= cake[i].store; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125;bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1071 Speech PatternsAnalysis题目要求输入一句话，输出其中出现次数最长的字符串，字符串只能包含0-9、A-Z和a-z内的字符，其他字符均被认为是字符串之间的分隔符。 先将字符串整行读入，在逐个拆分出每个单词，并利用map来建立字符串（string）与次数（int）之间的映射，每统计到相同的字符串，次数加1。 输出时，遍历map，找出其中出现次数最多的字符串即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;map&lt;string, int&gt; mp;bool check(char c) &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') return true; if('a' &lt;= c &amp;&amp; c &lt;= 'z') return true; if('A' &lt;= c &amp;&amp; c &lt;= 'Z') return true; return false;&#125;int main(int agrc, char const *argv[]) &#123; map&lt;string, int&gt; count; string str; getline(cin, str); int i = 0; while(i &lt; str.length()) &#123; string word; while(i &lt; str.length() &amp;&amp; check(str[i]) == true) &#123; if('A' &lt;= str[i] &amp;&amp; str[i] &lt;= 'Z') &#123; str[i] += 32; &#125; word += str[i]; i++; &#125; if(word != "") &#123; if(count.find(word) == count.end()) count[word] = 1; else count[word]++; &#125; while(i &lt; str.length() &amp;&amp; check(str[i]) == false) &#123; i++; &#125; &#125; string ans; int max = 0; for(map&lt;string, int&gt;::iterator it = count.begin(); it != count.end(); it++) &#123; if(it-&gt;second &gt; max) &#123; max = it-&gt;second; ans = it-&gt;first; &#125; &#125; cout &lt;&lt; ans &lt;&lt; ' ' &lt;&lt; max; return 0;&#125; 1072 Gas StationAnalysis题目大意是给定若干个源点和固定点，求这些源点到所有固定点距离最小的源点，如果存在相同解，就输出平均距离最小的源点。 按照题目大意，可以将题目描述抽象为图，接着利用 Dijkstra 算法就可以求解源点到固定点的最短距离；由于题目给定的源点有多个，所以要使用多次 Dijkstra 算法，所以每次执行算法之前需要将用到的bool数组初始化为false。然后，按照题目条件来判断或筛选最优解。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int maxv = 1020;const int inf = 0x3fffffff;int n, m, k, ds, G[maxv][maxv];int d[maxv];bool vis[maxv] = &#123;false&#125;;void dijkstra(int s) &#123; memset(vis, false, sizeof(vis)); //do not forget initializing this array fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n + m; i++) &#123; int u = -1, min = inf; for(int j = 1; j &lt;= n + m; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 1; v &lt;= n + m; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) d[v] = d[u] + G[u][v]; &#125; &#125; &#125;&#125;int getid(char str[]) &#123; //tranfer the id of gas station int len = strlen(str), id = 0; for(int i = 0; i &lt; len; i++) &#123; if(str[i] != 'G') id = id * 10 + (str[i] - '0'); &#125; if(str[0] == 'G') return n + id; else return id;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;k, &amp;ds); int u, v, w; char city1[5], city2[5]; fill(G[0], G[0] + maxv * maxv, inf); for(int i = 0; i &lt; k; i++) &#123; scanf("%s %s %d", city1, city2, &amp;w); u = getid(city1); v = getid(city2); G[v][u] = G[u][v] = w; &#125; double ansdis = -1, ansavg = inf; int ansid = -1; for(int i = n + 1; i &lt;= n + m; i++) &#123; double mindis = inf, avg = 0; dijkstra(i); //every station should execute this dijkstra for(int j = 1; j &lt;=n; j++) &#123; if(d[j] &gt; ds) &#123; //this solution does not fit the problem mindis = -1; break; &#125; if(d[j] &lt; mindis) mindis = d[j]; //cal minimum of distance avg += 1.0 * d[j] / n; //calculate the average &#125; if(mindis == -1) continue; if(mindis &gt; ansdis) &#123; //more optimal solution ansid = i; ansdis = mindis; ansavg = avg; &#125; else if(mindis == ansdis &amp;&amp; avg &lt; ansavg) &#123; //more optimal solution ansid = i; ansavg = avg; &#125; &#125; if(ansid == -1) printf("No Solution\n"); else &#123; printf("G%d\n", ansid - n); printf("%.1lf %.1lf\n", ansdis, ansavg); &#125; return 0;&#125; 1073 Scientific NotationAnalysis此题与乙级题库的1024一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;const int MAXN = 10000 + 5;int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int Epos, exp = 0; for(Epos = 1; Num[Epos] != 'E'; Epos++); for(int i = Epos + 2; Num[i] != '\0'; i++) &#123; exp = exp * 10 + Num[i] - '0'; &#125; if(Num[0] == '-') &#123; putchar(Num[0]); &#125; if(exp == 0) &#123; for(int i = 1; Num[i] != 'E'; i++) &#123; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '-') &#123; printf("0."); for(int i = exp - 1; i &gt; 0; i--) &#123; putchar('0'); &#125; for(int i = 1; Num[i] != 'E'; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); &#125; &#125; else if(Num[Epos + 1] == '+') &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == exp + 2 &amp;&amp; Epos - 3 != exp) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; exp - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; putchar('\n'); return 0;&#125; 1074 Reversing Linked ListAnalysis此题与乙级题库的1025一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node&#123; int address, data, next; int order;&#125; Node[maxn];bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125; int head, n, k, address; scanf("%d %d %d", &amp;head, &amp;n, &amp;k); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].data, &amp;Node[address].next); Node[address].address = address; &#125; int p = head, count = 0; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) &#123; printf("-1\n"); &#125; else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1075 PAT JudgeAnalysis考察排序，题目说明比较多，要仔细读题。关键是输入数据的处理，处理后要达到便于排序（与题目一致）和输出的效果。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 5;struct user&#123; int id, score[6], sum, perfect; bool flag;&#125; us[MAXN];int N, K, M;int full[6] = &#123;0&#125;;bool cmp(user a, user b);void Init();int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;K, &amp;M); Init(); for(int i = 1; i &lt;= K; i++) &#123; scanf("%d", full + i); &#125; int uid, pid, score_ob; for(int i = 0; i &lt; M; i++) &#123; scanf("%d %d %d", &amp;uid, &amp;pid, &amp;score_ob); if(score_ob != -1) &#123; us[uid].flag = true; &#125; if(score_ob == -1 &amp;&amp; us[uid].score[pid] == -1) &#123; us[uid].score[pid] = 0; &#125; if(score_ob == full[pid] &amp;&amp; us[uid].score[pid] &lt; full[pid]) &#123; us[uid].perfect++; &#125; if(score_ob &gt; us[uid].score[pid]) &#123; us[uid].score[pid] = score_ob; &#125; &#125; for(int i = 1; i &lt;= N; i++) &#123; for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] != -1) &#123; us[i].sum += us[i].score[j]; &#125; &#125; &#125; sort(us + 1, us + N + 1, cmp); int r = 1; for(int i = 1; i &lt;= N &amp;&amp; us[i].flag == true; i++) &#123; if(i &gt; 1 &amp;&amp; us[i].sum != us[i - 1].sum) &#123; r = i; &#125; printf("%d %05d %d", r, us[i].id, us[i].sum); for(int j = 1; j &lt;= K; j++) &#123; if(us[i].score[j] == -1) &#123; printf(" -"); &#125; else &#123; printf(" %d", us[i].score[j]); &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmp(user a, user b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else if(a.perfect != b.perfect) return a.perfect &gt; b.perfect; else return a.id &lt; b.id;&#125;void Init() &#123; for(int i = 1; i &lt;= N; i++) &#123; us[i].id = i; us[i].sum = 0; us[i].perfect = 0; us[i].flag = false; memset(us[i].score, -1, sizeof(us[i].score)); &#125;&#125; 1076 Forwards on WeiboAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;cstring&gt;#include &lt;vector&gt;using namespace std;const int maxn = 1010;struct node &#123; int id; int layer;&#125;;vector&lt;node&gt; Adj[maxn];bool inq[maxn] = &#123;false&#125;;int BFS(int s, int L) &#123; int numFoward = 0; queue&lt;node&gt; q; node start; start.id = s; start.layer = 0; q.push(start); inq[start.id] = true; while(!q.empty()) &#123; node top = q.front(); q.pop(); int u = top.id; for(int i = 0; i &lt; Adj[u].size(); i++) &#123; node next = Adj[u][i]; next.layer = top.layer + 1; if(inq[next.id] == false &amp;&amp; next.layer &lt;= L) &#123; q.push(next); inq[next.id] = true; numFoward++; &#125; &#125; &#125; return numFoward;&#125;int main(int argc, char const *argv[]) &#123; node user; int n, L, numFollow, idFollow; cin &gt;&gt; n &gt;&gt; L; for(int i = 1; i &lt;= n; i++) &#123; user.id = i; cin &gt;&gt; numFollow; for(int j = 0; j &lt; numFollow; j++) &#123; cin &gt;&gt; idFollow; Adj[idFollow].push_back(user); &#125; &#125; int numQuery, s; cin &gt;&gt; numQuery; while(numQuery--) &#123; memset(inq, false, sizeof(inq)); cin &gt;&gt; s; int numFoward = BFS(s, L); cout &lt;&lt; numFoward &lt;&lt; endl; &#125; return 0;&#125; 1077 KuchiguseAnalysis本题的实质是在求字符串的最长相同后缀，从后遍历字符串比较麻烦，所以采取先逆转字符串，然后从前遍历的做法，这样就会方便许多。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 256 + 5;char str[100][MAXN];void Reverse(char *s);int main(int argc, char const *argv[]) &#123; int N, minLen = 256, ans = 0; scanf("%d", &amp;N); getchar(); for(int i = 0; i &lt; N; i++) &#123; fgets(str[i], MAXN, stdin); int len = strlen(str[i]); if(len &lt; minLen) minLen = len; Reverse(str[i]); &#125; for(int i = 0; i &lt; minLen; i++) &#123; char c = str[0][i]; bool same = true; for(int j = 1; j &lt; N; j++) &#123; if(c != str[j][i]) &#123; same = false; break; &#125; &#125; if(same) &#123; ans++; &#125; else &#123; break; &#125; &#125; if(ans &gt; 1) &#123; for(int i = ans - 1; i &gt;= 0; i--) &#123; putchar(str[0][i]); &#125; &#125; else &#123; puts("nai"); &#125; return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1078 HashingAnalysis题目大意是用线性探测的方法，构造哈希表，用平方探测的办法解决冲突。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;cstdio&gt;#include &lt;cmath&gt;const int MAXM = 10005;bool isPrime(int n) &#123; if(n &lt;= 1 || (n != 2 &amp;&amp; n % 2 == 0)) &#123; return false; &#125; else &#123; for(int i = 3; i &lt;= sqrt(n); i += 2) &#123; if(n % i == 0) return false; &#125; &#125; return true;&#125;int nearPrime(int n) &#123; while(!isPrime(n)) n++; return n;&#125;int hashTable[MAXM] = &#123;0&#125;; int main(int argc, char const *argv[]) &#123; int m, n, temp, index; scanf("%d %d", &amp;m, &amp;n); m = nearPrime(m); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;temp); index = temp % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); &#125; else &#123; int step; for(step = 1; step &lt; m; step++) &#123; index = (temp + step * step) % m; if(hashTable[index] == 0) &#123; hashTable[index] = temp; printf("%d", index); break; &#125; &#125; if(step &gt;= m) &#123; printf("-"); &#125; &#125; if(i &lt; n - 1) putchar(' '); &#125; return 0;&#125; 1079 Total Sales of SupplyAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int weight; vector&lt;int&gt; child;&#125; Node[maxn];bool cmp(int a, int b) &#123; return Node[a].weight &gt; Node[b].weight;&#125;int n, m, S;int path[maxn];void DFS(int index, int numNode, int sum) &#123; if(sum &gt; S) return; if(sum == S) &#123; if(Node[index].child.size() != 0) return; for(int i = 0; i &lt; numNode; i++) &#123; printf("%d", Node[path[i]].weight); if(i &lt; numNode - 1) printf(" "); else printf("\n"); &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; int child = Node[index].child[i]; path[numNode] = child; DFS(child, numNode + 1, sum + Node[child].weight); &#125;&#125;int main() &#123; scanf("%d %d %d", &amp;n, &amp;m, &amp;S); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Node[i].weight); &#125; int id, k, child; for(int i = 0; i &lt; m; i++) &#123; scanf("%d %d", &amp;id, &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;child); Node[id].child.push_back(child); &#125; sort(Node[id].child.begin(), Node[i].child.end(), cmp); &#125; path[0] = 0; DFS(0, 1, Node[0].weight); return 0;&#125; 1080 Graduate AdmissionAnalysisCode12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 40000 + 5;struct student&#123; int ge, gi, sum; int r, id; int cho[6];&#125; stu[MAXN];struct school&#123; int quota; int stuNum; int id[MAXN]; int lastAdmit;&#125; sch[110];bool cmpStu(student a, student b);bool cmpID(int a, int b);int main(int argc, char const *argv[]) &#123; int N, M, K; scanf("%d %d %d", &amp;N, &amp;M, &amp;K); for(int i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;sch[i].quota); sch[i].stuNum = 0; sch[i].lastAdmit = -1; &#125; for(int i = 0; i &lt; N; i++) &#123; stu[i].id = i; scanf("%d %d", &amp;stu[i].ge, &amp;stu[i].gi); stu[i].sum = stu[i].ge + stu[i].gi; for(int j = 0; j &lt; K; j++) &#123; scanf("%d", &amp;stu[i].cho[j]); &#125; &#125; sort(stu, stu + N, cmpStu); for(int i = 0; i &lt; N; i++) &#123; if(i &gt; 0 &amp;&amp; stu[i].sum == stu[i - 1].sum &amp;&amp; stu[i].ge == stu[i - 1].ge) &#123; stu[i].r = stu[i - 1].r; &#125; else &#123; stu[i].r = i; &#125; &#125; for(int i = 0; i &lt; N; i++) &#123; for(int j = 0; j &lt; K; j++) &#123; int choice = stu[i].cho[j]; int num = sch[choice].stuNum; int last = sch[choice].lastAdmit; if(num &lt; sch[choice].quota || (last != -1 &amp;&amp; stu[i].r == stu[last].r)) &#123; sch[choice].id[num] = i; sch[choice].lastAdmit = i; sch[choice].stuNum++; break; &#125; &#125; &#125; for(int i = 0; i &lt; M; i++) &#123; if(sch[i].stuNum &gt; 0) &#123; sort(sch[i].id, sch[i].id + sch[i].stuNum, cmpID); for(int j = 0; j &lt; sch[i].stuNum; j++) &#123; printf("%d", stu[sch[i].id[j]].id); if(j &lt; sch[i].stuNum - 1) &#123; printf(" "); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125;bool cmpStu(student a, student b) &#123; if(a.sum != b.sum) return a.sum &gt; b.sum; else return a.ge &gt; b.ge;&#125;bool cmpID(int a, int b) &#123; return stu[a].id &lt; stu[b].id;&#125; 1081 Rational SumAnalysis题目大意是给定N个a/b形式的分数，a为分子，b为分母，求这N个分数的和再输出。 给定的分数只有两种情况：真分数和假分数，不存在带分数，但输出要输出带分数，并且是最简形式。化简的目的其实题目考察求最大公约数，利用欧几里得算法即可求得两个数的最大公约数。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;cstdio&gt;#include &lt;cstdlib&gt;typedef struct fraction &#123; long long up, down;&#125; Fraction;long long gcd(long long a, long long b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; long long d = gcd(abs(result.up), result.down); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;void printResult(Fraction result) &#123; Fraction r = Reduction(result); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125;&#125;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); Fraction ans, temp; ans.up = 0; ans.down = 1; while(N--) &#123; scanf("%lld/%lld", &amp;temp.up, &amp;temp.down); ans = Add(ans, temp); &#125; printResult(ans); return 0;&#125; 1082 Read Number in ChineseAnalysis将数字按每4位一组分割为不同的组，若是9位数，则有三组分别为：个位组、万位组和亿位组，然后针对每一组单独进行判断。对每一小组而言，要注意1001只能输出为yi Qian ling yi而不是yi Qian ling ling yi，即有累积的0时，只能输出一个ling。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;char NumberTable[10][10] = &#123; "ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu", &#125;;char Digit[5][10] = &#123; "Shi", "Bai", "Qian", "Wan", "Yi", &#125;;int main(int argc, char const *argv[]) &#123; char Num[15]; scanf("%s", Num); int len = strlen(Num), left = 0, right = len - 1; if(Num[0] == '-') &#123; printf("Fu"); left++; &#125; while(left + 4 &lt;= right) &#123; right -= 4; &#125; while(left &lt; len) &#123; bool flag = false, isPrint = false; while(left &lt;= right) &#123; if(left &gt; 0 &amp;&amp; Num[left] == '0') &#123; flag = true; &#125; else &#123; if(flag == true) &#123; printf(" ling"); flag = false; &#125; if(left &gt; 0) printf(" "); printf("%s", NumberTable[Num[left] - '0']); isPrint = true; if(left != right) &#123; printf(" %s", Digit[right - left - 1]); &#125; &#125; left++; &#125; if(isPrint == true &amp;&amp; right != len - 1) &#123; printf(" %s", Digit[(len - 1 - right) / 4 + 2]); &#125; right += 4; &#125; return 0;&#125; 1083 List GradesAnalysis自定义结构体，输入数据后调用sort函数按照降序排序，然后根据题目给定的区间顺序输出符合这个区间内的元素即可。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; char name[15], id[15]; int grade;&#125; stu[MAXN];bool cmp(student a, student b);int main(int argc, char const *argv[]) &#123; int N, grade1, grade2; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%s %s %d", stu[i].name, stu[i].id, &amp;stu[i].grade); &#125; scanf("%d %d", &amp;grade1, &amp;grade2); sort(stu, stu + N, cmp); bool flag = false; for(int i = 0; i &lt; N; i++) &#123; if(grade1 &lt;= stu[i].grade &amp;&amp; stu[i].grade &lt;= grade2) &#123; printf("%s %s\n", stu[i].name, stu[i].id); flag = true; &#125; &#125; if(!flag) &#123; printf("NONE\n"); &#125; return 0;&#125;bool cmp(student a, student b) &#123; return a.grade &gt; b.grade;&#125; 1084 Broken KeyboardAnalysis遍历字符串，找出第一个字符串中出现过，但第二个字符串中未出现的字符即可，字母不区分大小写，但字符串内有空格和数字，用_表示，注意不能输出小写字母，且重复的字符只输出一次。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;int main(int argc, char const *argv[]) &#123; char str1[85], str2[85]; scanf("%s %s", str1, str2); bool HashTable[128] = &#123;false&#125;; for(int i = 0; str1[i] != '\0'; i++) &#123; int j = 0; char c1 = str1[i]; for(; str2[j] != '\0'; j++) &#123; char c2 = str2[j]; if(islower(c1)) c1 = toupper(c1); if(islower(c2)) c2 = toupper(c2); if(c1 == c2) break; &#125; if(str2[j] == '\0' &amp;&amp; HashTable[c1] == false) &#123; printf("%c", c1); HashTable[c1] = true; &#125; &#125; putchar('\n'); return 0;&#125; 1085 Perfect SequenceAnalysis此题与乙级题库的1030一样。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;long long n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%lld %lld", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%lld", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1086 Tree Traversals AgainAnalysis题目大意是给定用栈模拟二叉树中序遍历的入栈、出栈顺序，现在要求输出这个二叉树后序遍历序列。 根据题目给定的入栈、出栈序列，可以得到二叉树的先序遍历序列和后序遍历序列，根据这两个序列建树，然后再后序遍历这个二叉树即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;cstdio&gt;#include &lt;stack&gt;#include &lt;cstring&gt;using namespace std;struct node &#123; int data; node *lchild; node *rchild;&#125;;int n, pre[50], in[50], order;stack&lt;int&gt; st;node *create(int preL, int preR, int inL, int inR) &#123; if(preL &gt; preR) &#123; return NULL; &#125; node *root = new node; root-&gt;data = pre[preL]; int k; for(k = inL; k &lt;= inR; k++) &#123; if(in[k] == pre[preL]) &#123; break; &#125; &#125; int numLeft = k - inL; root-&gt;lchild = create(preL + 1, preL + numLeft, inL, k - 1); root-&gt;rchild = create(preL + numLeft + 1, preR, k + 1, inR); return root;&#125;int num = 0;void postorder(node *root) &#123; if(root == NULL) return; postorder(root-&gt;lchild); postorder(root-&gt;rchild); printf("%d", root-&gt;data); if(num &lt; n - 1) &#123; printf(" "); &#125; num++;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); char str[5]; int x, preIndex = 0, inIndex = 0; for(int i = 0; i &lt; 2 * n; i++) &#123; scanf("%s", str); if(strcmp("Push", str) == 0) &#123; scanf("%d", &amp;x); pre[preIndex++] = x; st.push(x); &#125; else &#123; in[inIndex++] = st.top(); st.pop(); &#125; &#125; node *root = create(0, n - 1, 0, n - 1); postorder(root); return 0;&#125; 1087 All Roads Lead to RomeAnalysis题目背景是旅游的路线图，要求按照条件求出最短路径及特定的值。 题目首先要求出的是从起点到终点的最短路径，由于不存在负环，所以可以直接使用 Dijkstra 算法求得；同时注意到，题目要求的某些特殊值与对应的路径可以在求解最短路时，一并求出，只不过需要使用多个数组而已。按照这样的思路，对题目要求的值增加对应的数组，并在求解最最短路的过程中写清楚这些条件之间的层次关系即可。 当然了，本题也可以使用 Dijkstra 算法先求出所有的最短路径，然后再利用 DFS 来求出符合条件的最优解和对应的值。 CodeDijkstra1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], w[maxv] = &#123;0&#125;, num[maxv] = &#123;0&#125;, pt[maxv] = &#123;0&#125;, pre[maxv];bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; w[s] = weight[s]; num[s] = 1; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v] = u; num[v] = num[u]; w[v] = w[u] + weight[v]; pt[v] = pt[u] + 1; &#125; else if(d[v] == d[u] + G[u][v]) &#123; num[v] += num[u]; if(w[v] &lt; w[u] + weight[v]) &#123; w[v] = w[u] + weight[v]; pre[v] = u; pt[v] = pt[u] + 1; &#125; else if(w[v] == w[u] + weight[v]) &#123; double uavg = 1.0 * (w[u] + weight[v]) / (pt[u] + 1); double vavg = 1.0 * w[v] / pt[v]; if(uavg &gt; vavg) &#123; pt[v] = pt[u] + 1; pre[v] = u; &#125; &#125; &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; cout &lt;&lt; index2city[v]; return; &#125; dfs(pre[v]); cout &lt;&lt; "-&gt;" &lt;&lt; index2city[v];&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; city2index[city1] = i; index2city[i] = city1; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1], v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; cout &lt;&lt; num[rom] &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; w[rom] &lt;&lt; ' ' &lt;&lt; w[rom] / pt[rom] &lt;&lt; endl; dfs(rom); return 0;&#125; Dijkstra + DFS12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;cstring&gt;using namespace std;const int maxv = 210;const int inf = 0x3fffffff;int n, k, G[maxv][maxv], weight[maxv];int d[maxv], numpath = 0, maxw = 0;double maxavg = 0;bool vis[maxv] = &#123;false&#125;;map&lt;string, int&gt; city2index;map&lt;int, string&gt; index2city;vector&lt;int&gt; pre[maxv], tempath, path;void dijkstra(int s) &#123; fill(d, d + maxv, inf); d[s] = 0; for(int i = 0; i &lt; n; i++) &#123; int u = -1, min = inf; for(int j = 0; j &lt; n; j++) &#123; if(vis[j] == false &amp;&amp; d[j] &lt; min) &#123; min = d[j]; u = j; &#125; &#125; if(u == -1) return; vis[u] = true; for(int v = 0; v &lt; n; v++) &#123; if(vis[v] == false &amp;&amp; G[u][v] != inf) &#123; if(d[v] &gt; d[u] + G[u][v]) &#123; d[v] = d[u] + G[u][v]; pre[v].clear(); pre[v].push_back(u); &#125; else if(d[v] == d[u] + G[u][v]) &#123; pre[v].push_back(u); &#125; &#125; &#125; &#125;&#125;void dfs(int v) &#123; if(v == 0) &#123; tempath.push_back(v); numpath++; int tempw = 0; for(int i = tempath.size() - 1; i &gt;= 0; i--) &#123; int id = tempath[i]; tempw += weight[id]; &#125; double tempavg = 1.0 * tempw / (tempath.size() - 1); if(tempw &gt; maxw) &#123; maxw = tempw; maxavg = tempavg; path = tempath; &#125; else if(tempw == maxw &amp;&amp; tempavg &gt; maxavg) &#123; maxavg = tempavg; path = tempath; &#125; tempath.pop_back(); return; &#125; tempath.push_back(v); for(int i = 0; i &lt; pre[v].size(); i++) &#123; dfs(pre[v][i]); &#125; tempath.pop_back();&#125;int main(int argc, char const *argv[]) &#123; string city1, city2; cin &gt;&gt; n &gt;&gt; k &gt;&gt; city1; city2index[city1] = 0; index2city[0] = city1; for(int i = 1; i &lt; n; i++) &#123; cin &gt;&gt; city1 &gt;&gt; weight[i]; index2city[i] = city1; city2index[city1] = i; &#125; fill(G[0], G[0] + maxv * maxv, inf); int u, v, dis; for(int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; city1 &gt;&gt; city2 &gt;&gt; dis; u = city2index[city1]; v = city2index[city2]; G[u][v] = G[v][u] = dis; &#125; dijkstra(0); int rom = city2index["ROM"]; dfs(rom); cout &lt;&lt; numpath &lt;&lt; ' ' &lt;&lt; d[rom] &lt;&lt; ' ' &lt;&lt; maxw &lt;&lt; ' ' &lt;&lt; (int)maxavg &lt;&lt; endl; for(int i = path.size() - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; index2city[path[i]]; if(i &gt; 0) cout &lt;&lt; "-&gt;"; &#125; return 0;&#125; 1088 Rational ArithmeticAnalysis此题与乙级题库的1034一样。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll a, ll b);struct Fraction&#123; ll up, down;&#125; a, b;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /=d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void showResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;a.up, &amp;a.down, &amp;b.up, &amp;b.down); //add showResult(a); printf(" + "); showResult(b); printf(" = "); showResult(Add(a, b)); putchar('\n'); //minu showResult(a); printf(" - "); showResult(b); printf(" = "); showResult(Minu(a, b)); putchar('\n'); //mult showResult(a); printf(" * "); showResult(b); printf(" = "); showResult(Mult(a, b)); putchar('\n'); //divide showResult(a); printf(" / "); showResult(b); printf(" = "); if(b.up == 0) printf("Inf"); else showResult(Divide(a, b)); return 0;&#125; ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125; 1089 Insert or MergeAnalysis此题与乙级题库的1035一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 10;int ori[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125;&#125;bool InsertionSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;ori[i]); tempOri[i] = ori[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertionSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = ori[i]; &#125; MergeSort(); &#125; return 0;&#125; 1090 Highest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;struct node &#123; double data; vector&lt;int&gt; child;&#125; Node[maxn];int n, num = 0;double p, r, maxDepth = 0;void DFS(int index, int depth) &#123; if(Node[index].child.size() == 0) &#123; if(depth &gt; maxDepth) &#123; maxDepth = depth; num = 1; &#125; else if(depth == maxDepth) &#123; num++; &#125; return; &#125; for(int i = 0; i &lt; Node[index].child.size(); i++) &#123; DFS(Node[index].child[i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100; int root, parent; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;parent); if(parent != -1) &#123; Node[parent].child.push_back(i); &#125; else &#123; root = i; &#125; &#125; DFS(root, 0); printf("%.2lf %d\n", p * pow(1 + r, maxDepth), num); return 0;&#125; 1091 Acute StrokeAnalysis题目的背景大概是计算体积之和吧... 根据题目输入数据的形式和题目大意，思路是借助 BFS 对三维数组进行遍历，计算出每一个薄片（slice）中为“1”的个数，如果大于题目给定的T，则当前这个薄片内“1”的个数就可以认为是这个薄片的“急性脑卒中”区的体积。那么，依次遍历每个薄片即可得到最终结果。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;cstdio&gt;#include &lt;queue&gt;using namespace std;struct node &#123; int x, y, z;&#125; Node;int n, m, slice, T;int pixel[1290][130][61];bool inqueue[1290][130][61];int X[6] = &#123;0, 0, 0, 0, 1, -1&#125;;int Y[6] = &#123;0, 0, 1, -1, 0, 0&#125;;int Z[6] = &#123;1, -1, 0, 0, 0, 0&#125;;bool judge(int x, int y, int z) &#123; if(x &gt;= n || x &lt; 0 || y &gt;= m || y &lt; 0 || z &gt;= slice || z &lt; 0) return false; if(pixel[x][y][z] == 0 || inqueue[x][y][z] == true) return false; return true;&#125;int BFS(int x, int y, int z) &#123; int tot = 0; queue&lt;node&gt; Q; Node.x = x, Node.y = y, Node.z = z; Q.push(Node); inqueue[x][y][z] = true; while(!Q.empty()) &#123; node top = Q.front(); Q.pop(); tot++; for(int i = 0; i &lt; 6; i++) &#123; int newX = top.x + X[i]; int newY = top.y + Y[i]; int newZ = top.z + Z[i]; if(judge(newX, newY, newZ)) &#123; Node.x = newX, Node.y = newY, Node.z = newZ; Q.push(Node); inqueue[newX][newY][newZ] = true; &#125; &#125; &#125; if(tot &gt;= T) return tot; else return 0;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d %d", &amp;n, &amp;m, &amp;slice, &amp;T); for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; scanf("%d", &amp;pixel[x][y][z]); &#125; &#125; &#125; int ans = 0; for(int z = 0; z &lt; slice; z++) &#123; for(int x = 0; x &lt; n; x++) &#123; for(int y = 0; y &lt; m; y++) &#123; if(pixel[x][y][z] == 1 &amp;&amp; inqueue[x][y][z] == false) &#123; ans += BFS(x, y, z); &#125; &#125; &#125; &#125; printf("%d", ans); return 0;&#125; 1092 To Buy or Not to BuyAnalysis与乙级题库的1039一样。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1093 Count PAT’sAnalysis与乙级题库的1040一样。 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') leftNumP[i]++; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt; 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; 1094 The Largest GenerationAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;const int maxn = 110;struct node &#123; int depth; vector&lt;int&gt; child;&#125; Node[maxn];int n, m, seq, child;int Depth[maxn] = &#123;0&#125;;void BFS() &#123; queue&lt;int&gt; q; q.push(1); Node[1].depth = 1; Depth[Node[1].depth]++; while(!q.empty()) &#123; int front = q.front(); q.pop(); for(int i = 0; i &lt; Node[front].child.size(); i++) &#123; int child = Node[front].child[i]; Node[child].depth = Node[front].depth + 1; Depth[Node[child].depth]++; q.push(child); &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n &gt;&gt; m; int k; for(int i = 0; i &lt; m; i++) &#123; cin &gt;&gt; seq &gt;&gt; k; for(int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; child; Node[seq].child.push_back(child); &#125; &#125; BFS(); int max = -1, l = 1; for(int i = 0; i &lt; maxn; i++) &#123; if(Depth[i] &gt; max) &#123; max = Depth[i]; l = i; &#125; &#125; cout &lt;&lt; Depth[l] &lt;&lt; ' ' &lt;&lt; l &lt;&lt; endl; return 0;&#125; 1096 Consecutive FactorsAnalysis题目大意是给定一个整数，找出其最长的因子序列，以样例为例，630=3*5*6*7，所以其连续因子序列为3*5*7，长度为3且此为其最长连续因子序列。 Code1234567891011121314151617181920212223242526272829303132#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;int main(int argc, char const *argv[]) &#123; ll n; scanf("%lld", &amp;n); ll sqr = sqrt(n), ansI = 0, ansLen = 0; for(ll i = 2; i &lt;= sqr; i++) &#123; ll temp = 1, j = i; while(1) &#123; temp *= j; if(n % temp != 0) break; if(j - i + 1 &gt; ansLen) &#123; ansI = i; ansLen = j - i + 1; &#125; j++; &#125; &#125; if(ansLen == 0) &#123; printf("1\n%lld\n", n); &#125; else &#123; printf("%lld\n", ansLen); for(ll i = 0; i &lt; ansLen; i++) &#123; printf("%lld", ansI + i); if(i &lt; ansLen - 1) putchar('*'); &#125; &#125; return 0;&#125; 1097 Deduplication on a Linked ListAnalysis题目大意：给定一串链表的各个结点，删除其中重复的结点，并将删除的结点重新组成一个链表。然后，先输出原链表删除结点后的新链表，紧接着在输出由所删除的结点构成的链表。 使用静态链表来处理这个问题，先默认初始化链表内的所有结点全部为无效结点，即置为2 * maxn，然后将链表内所有结点根据地址存储。紧接着，遍历链表，使用一个bool数组来记录结点是否出现过，对于没有出现的合法结点，从0开始编号，出现过的结点，从maxn开始编号。最后，使用sort函数根据order来排序，就可以将结点按序分为删除结点后的链表、新链表和无效结点三部分，在输出即可。 注意要使用%05d来输出地址位数较少的结点。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;const int Table = 2 * maxn;struct node&#123; int address, next, key; int order;&#125; Node[maxn];bool isExist[Table] = &#123;false&#125;;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = 2 * maxn; &#125; int n, head, address; scanf("%d %d", &amp;head, &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;address); scanf("%d %d", &amp;Node[address].key, &amp;Node[address].next); Node[address].address = address; &#125; int countValid = 0, countRemoved = 0, p = head; while(p != -1) &#123; if(!isExist[abs(Node[p].key)]) &#123; isExist[abs(Node[p].key)] = true; Node[p].order = countValid++; &#125; else &#123; Node[p].order = maxn + countRemoved++; &#125; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); int count = countValid + countRemoved; for(int i = 0; i &lt; count; i++) &#123; if(i != countValid - 1 &amp;&amp; i != count - 1) &#123; printf("%05d %d %05d\n", Node[i].address, Node[i].key, Node[i + 1].address); &#125; else &#123; printf("%05d %d -1\n", Node[i].address, Node[i].key); &#125; &#125; return 0;&#125; 1098 Insertion or Heap SortAnalysisCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;int origin[maxn], tempori[maxn], changed[maxn];int n;bool isSame(int A[], int B[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;bool showArray(int A[]) &#123; for(int i = 1; i &lt;= n; i++) &#123; printf("%d", A[i]); if(i &lt; n) putchar(' '); &#125; putchar('\n');&#125;bool insertSort() &#123; bool flag = false; for(int i = 2; i &lt;= n; i++) &#123; if(i != 2 &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; sort(tempori, tempori + i + 1); if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void downAdjust(int low, int high) &#123; int i = low, j = 2 * i; while(j &lt;= high) &#123; if(j + 1 &lt;= high &amp;&amp; tempori[j + 1] &gt; tempori[j]) &#123; j = j + 1; &#125; if(tempori[j] &gt; tempori[i]) &#123; swap(tempori[j], tempori[i]); i = j; j = i * 2; &#125; else &#123; break; &#125; &#125;&#125;void heapSort() &#123; bool flag = false; for(int i = n / 2; i &gt;= 1; i--) &#123; downAdjust(i, n); &#125; for(int i = n; i &gt; 1; i--) &#123; if(i != n &amp;&amp; isSame(tempori, changed)) &#123; flag = true; &#125; swap(tempori[i], tempori[1]); downAdjust(1, i - 1); if(flag == true) &#123; showArray(tempori); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;origin[i]); tempori[i] = origin[i]; &#125; for(int i = 1; i &lt;= n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(insertSort()) &#123; printf("Insertion Sort\n"); showArray(tempori); &#125; else &#123; printf("Heap Sort\n"); for(int i = 1; i &lt;= n; i++) &#123; tempori[i] = origin[i]; &#125; heapSort(); &#125; return 0;&#125; 1099 Build A Binary Search TreeAnalysis题目大意给定一颗二叉排序树（BST），输出这棵树的层次序列。 根据题目输入数据的形式，利用结构数组建树比较方便。建树之后，中序遍历这棵树，将按升序排好的结点值序列，按照顺序赋给每个结点，这样每个结点的值就符合 BST 的性质了，接着层次遍历，输出其序列即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 110;struct node &#123; int data; int left, right; &#125; Node[maxn];int n, number[maxn], index = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].left); Node[root].data = number[index++]; inorder(Node[root].right);&#125;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;int&gt; q; q.push(root); while(!q.empty()) &#123; int front = q.front(); q.pop(); cout &lt;&lt; Node[front].data; if(num &lt; n - 1) &#123; cout &lt;&lt; ' '; num++; &#125; if(Node[front].left != -1) q.push(Node[front].left); if(Node[front].right != -1) q.push(Node[front].right); &#125;&#125;int main(int argc, char const *argv[]) &#123; cin &gt;&gt; n; int lchild, rchild; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; lchild &gt;&gt; rchild; Node[i].left = lchild, Node[i].right = rchild; &#125; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; number[i]; &#125; sort(number, number + n); inorder(0); levelorder(0); return 0;&#125; 1100 Mars NumbersAnalysis此题与乙级题库的1044一样。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const*argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); string s; while(n--) &#123; string str; getline(cin, str); if('0' &lt;= str[0] &amp;&amp; str[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; str.length(); i++) &#123; num = num * 10 + (str[i] - '0'); &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[str] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1101 Quick SortAnalysis此题与乙级题库的1045一样。 Code123456789101112131415161718192021222324252627282930313233#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 10;int n, array[MAXN], leftmax[MAXN], rightmin[MAXN], pivot[MAXN]; int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftmax[0] = array[0]; for(int i = 1; i &lt; n; i++) &#123; leftmax[i] = max(leftmax[i - 1], array[i - 1]); &#125; rightmin[n - 1] = 0x3fffffff; for(int i = n - 2; i &gt;= 0; i--) &#123; rightmin[i] = min(rightmin[i + 1], array[i + 1]); &#125; int count = 0; for(int i = 0; i &lt; n; i++) &#123; if(leftmax[i] &lt;= array[i] &amp;&amp; array[i] &lt;= rightmin[i]) &#123; pivot[count++] = array[i]; &#125; &#125; printf("%d\n", count); for(int i = 0; i &lt; count; i++) &#123; printf("%d", pivot[i]); if(i &lt; count - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1102 Invert a Binary TreeAnalysis题目大意是给定一个二叉树，反转这个二叉树并输出反转后的二叉树的中序序列和层序序列。 本题使用结构数组建树比较方便，并且反转时直接交换每个结点的左右孩子指针即可。然后再利用中序遍历和层序遍历，输出对应的序列。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;cstdio&gt;#include &lt;queue&gt;#include &lt;algorithm&gt;using namespace std;struct node &#123; int data; int lchild, rchild;&#125; Node[15]; int n;bool isRoot[15] = &#123;false&#125;;int num = 0;void levelorder(int root) &#123; if(root == -1) return; queue&lt;node&gt; q; q.push(Node[root]); while(!q.empty()) &#123; node top = q.front(); q.pop(); printf("%d", top.data); if(num &lt; n - 1) &#123; printf(" "); num++; &#125; if(top.lchild != -1) q.push(Node[top.lchild]); if(top.rchild != -1) q.push(Node[top.rchild]); &#125; putchar('\n');&#125;int num2 = 0;void inorder(int root) &#123; if(root == -1) return; inorder(Node[root].lchild); printf("%d", Node[root].data); if(num2 &lt; n - 1) &#123; printf(" "); num2++; &#125; inorder(Node[root].rchild);&#125;int getroot() &#123; int ret = 0; for(int i = 0; i &lt; n; i++) &#123; if(!isRoot[i]) &#123; ret = i; break; &#125; &#125; return ret;&#125;void invert() &#123; int i = 0; for(int i = 0; i &lt; n; i++) &#123; swap(Node[i].lchild, Node[i].rchild); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); getchar(); char left, right; for(int i = 0; i &lt; n; i++) &#123; scanf("%c %c", &amp;left, &amp;right); getchar(); if(left != '-') &#123; Node[i].lchild = left - '0'; isRoot[left - '0'] = true; &#125; else Node[i].lchild = -1; if(right != '-') &#123; Node[i].rchild = right - '0'; isRoot[right - '0'] = true; &#125; else Node[i].rchild = -1; Node[i].data = i; &#125; int root = getroot(); invert(); levelorder(root); inorder(root); return 0;&#125; 1103 Integer FactorizationAnalysis题目大意，给定三个数N、K和P，将N表示为K个因子的P次方的连加。注意题目的要求： 因子之和必须最大 因子序列按字典序最大 由于存在多解的情况，本题需要借助 DFS 来搜索所有解，找到符合条件的最优解，对于上述两个题目的要求，其对应的解决方法： 使用全局变量，记录每个解和其因子和，选择因子和最大的为最优解 将因子的P次方依次算好存储在数组中，然后从后往前枚举即可 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int n, k, p, maxFacsum = -1;vector&lt;int&gt; fac, ans, temp;int power(int x) &#123; int ret = 1; for(int i = 0; i &lt; p; i++) &#123; ret *= x; &#125; return ret;&#125;void init() &#123; int i = 0, temp = 0; while(temp &lt;= n) &#123; fac.push_back(temp); temp = power(++i); &#125;&#125;void DFS(int index, int nowK, int sum, int facSum) &#123; if(sum == n &amp;&amp; nowK == k) &#123; if(facSum &gt; maxFacsum) &#123; ans = temp; maxFacsum = facSum; &#125; return; &#125; if(sum &gt; n || nowK &gt; k) return; if(index - 1 &gt;= 0) &#123; temp.push_back(index); DFS(index, nowK + 1, sum + fac[index], facSum + index); temp.pop_back(); DFS(index - 1, nowK, sum, facSum); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;n, &amp;k, &amp;p); init(); DFS(fac.size() - 1, 0, 0, 0); if(maxFacsum == -1) &#123; printf("Impossible\n"); &#125; else &#123; printf("%d = %d^%d", n, ans[0], p); for(int i = 1; i &lt; ans.size(); i++) &#123; printf(" + %d^%d", ans[i], p); &#125; &#125; return 0;&#125; 1104 Sum of Number SegmentsAnalysis此题与乙级题库的1049一样。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; int i = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1106 Lowest Price in Supply ChainAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;vector&gt;using namespace std;const int maxn = 100005;vector&lt;int&gt; child[maxn];int tot = 0, n, minDepth = maxn;double p, r;void DFS(int index, int depth) &#123; if(child[index].size() == 0) &#123; if(depth &lt; minDepth) &#123; minDepth = depth; tot = 1; &#125; else if(depth == minDepth) &#123; tot++; &#125; return; &#125; for(int i = 0; i &lt; child[index].size(); i++) &#123; DFS(child[index][i], depth + 1); &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d %lf %lf", &amp;n, &amp;p, &amp;r); r /= 100.0; int num, subchild; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;num); for(int j = 0; j &lt; num; j++) &#123; scanf("%d", &amp;subchild); child[i].push_back(subchild); &#125; &#125; DFS(0, 0); double ans = p * pow(1 + r, minDepth); printf("%.4lf %d", ans, tot); return 0;&#125; 1107 Social ClustersAnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 1010;int father[maxn], isroot[maxn] = &#123;0&#125;, hobby[maxn] = &#123;0&#125;;int findFather(int x) &#123; int a = x; while(x != father[x]) &#123; x = father[x]; &#125; while(a != father[a]) &#123; int z = a; a = father[a]; father[z] = x; &#125; return x;&#125;void Union(int a, int b) &#123; int faA = findFather(a); int faB = findFather(b); if(faA != faB) &#123; father[faA] = father[faB]; &#125;&#125;void init(int n) &#123; for(int i = 1; i &lt;= n; i++) &#123; father[i] = i; &#125;&#125;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main(int argc, char const *argv[]) &#123; int n, k, h; scanf("%d", &amp;n); init(n); for(int i = 1; i &lt;= n; i++) &#123; scanf("%d:", &amp;k); for(int j = 0; j &lt; k; j++) &#123; scanf("%d", &amp;h); if(hobby[h] == 0) &#123; hobby[h] = i; &#125; Union(i, hobby[h]); &#125; &#125; for(int i = 1; i &lt;= n; i++) &#123; isroot[findFather(i)]++; &#125; int ans = 0; for(int i = 1; i &lt;= n; i++) &#123; if(isroot[i] != 0) &#123; ans++; &#125; &#125; printf("%d\n", ans); sort(isroot + 1, isroot + n + 1, cmp); for(int i = 1; i &lt;= ans; i++) &#123; printf("%d", isroot[i]); if(i &lt; ans) putchar(' '); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git简易指南]]></title>
    <url>%2F2019%2F06%2F23%2FGit%E7%AE%80%E6%98%93%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[IntroGit 是一个开源的分布式版本控制系统，而 Github 则是目前全球最大的开源社区，那么何谓“版本控制”？版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统，使用Git可以对任何类型的文件进行版本控制。 不同于本地版本控制系统和集中式版本控制系统，分布式版本控制系统的优点在于其对文件丢失风险的规避能力。简而言之，分布式版本控制系统中的每个客户端，都具有完整的文件，即原始仓库的镜像。 Basic Conception在开始直接使用 Git 之前，得先了解一下 Git 内的基本概念🧐，了解这些概念会更好的理解 Git 的工作方式和原理。 Snapshots, Not Differences如标题所言，（记录）快照，而不是差异。不同于其他版本控制系统的差异比较，Git 会将文件视作“快照”，每次提交更新后，Git 会对之前的文件制作一个快照并保存这个快照的索引，也就是说，Git 会将更新后的文件替换掉之前文件，同时，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件（快照）。 Nearly Every Operation Is Local在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其他计算机的信息。因为，在本地保存着这个项目文件的镜像，你可以离线进行提交，并在网络状态良好的时候，在推送到主服务器上。 The Three StatesGit 有三种状态，本地仓库内的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。已提交已修改已暂存数据已经安全的保存在本地数据库中。修改了文件，但还没保存到数据库中。对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录及暂存区域。 Git 仓库工作目录暂存区域Git 用来保存项目的元数据和对象数据库的地方，从其他计算机克隆仓库时，拷贝的就是这里的数据。对项目的某个版本独立提取出来的内容，这些从 Git 仓库的压缩数据中提取出来的文件，放在磁盘上供用户使用或修改。暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中，有时也被称作“索引”。 基本的 Git 工作流程如下： 在工作目录中修改文件 暂存文件，将文件的快照放入暂存区域 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库内 How to useGit 有多种使用方式，可以使用原生的命令行模式（推荐），也可以使用 GUI 模式，但只有在命令行模式下，才可以执行 Git 的所有命令。 Installing Git针对不同的操作系统，Git 的安装方法也不相同，对于现在比较成熟的 Git 而言，不同安装方式所带来的功能上的差异已经不是那么明显。对于Windows用户而言，在 Git 官网上下载后安装即可。其他方式这里不再做过多介绍。 First-Time Git Setup安装好了 Git 之后，需要对 Git 环境做定量的定制化操作，每台计算机上只用配置一次，程序升级时会保留配置信息，也可以在任何时候再次通过运行命令来修改它们。 User Identity当安装完 Git 后应该做的第一件事就是设置你的用户名称与邮件地址，后面的每一次提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改。12$ git config --global user.name "Bachzart"$ git config --global user.email "whistlesilp@gmail.com" 如果使用了--global选项，那么该命令只需要运行一次，因为之后无论做任何事情，Git 都会使用那些信息。若像针对特定项目使用不同的用户名称与邮件地址时，可以在那个项目目录下运行没有--global选项的命令来配置。 User Editor用户信息设置完毕后，可以配置默认文本编辑器，当 Git 需要你输入信息时会调用它。如果未配置，Git 会使用操作系统默认的文本编辑器。1$ git config --gloabl core.editor emacs Checking如何检查 Git 配置信息呢？可以使用如下命令来列出在当前目录下 Git 能找到的所有配置信息。1$ git config --list 可以得到如下所示结果：12345678910111213141516171819core.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslcainfo=D:/Git/Git/mingw64/ssl/certs/ca-bundle.crthttp.sslbackend=openssldiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truecredential.helper=manageruser.name=Bachzartuser.email=whistlesilp@gmail.com Getting HelpGit 自带有说明文档，可以直接使用以下三个命令查找指定命令的使用说明，或百度、google。123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 若想获得config命令的手册，执行1$ git help config Summary上面的内容介绍了 Git 是什么，Git 和其他版本控制系统的区别和基本用法等，接下来就开始使用吧~ Basic Usage在熟悉了 Git 的基本概念和用法后，就可以开始使用了。 Getting a Git Repository获取 Git 项目仓库的方法有两种： 在现有项目或目录下导入所有文件到 Git 中 从一个服务器克隆现有的 Git 仓库 Initializing a Repository in an Existing Directory如果只想在本地通过 Git 来进行版本控制，那么在bash内进入到想要建立仓库的目录，通过以下命令就可以建立一个仓库了。1$ git init 此时，在这个本地目录下会自动产生一个“.git”的目录，这个就是 Git 管理信息的目录，在 Windows 下默认隐藏。 Cloning an Existing Repository如果只是想获取一份网络上（或局域网服务器）已存在的 Git 仓库的拷贝，那么可以使用以下命令来将仓库克隆到本地。1$ git clone https://github.com/example 上述命令的格式为git clone [url]，https://github.com/example这个url并不是真正的存在，这里只做说明使用。 此时在当前目录下会创建一个“example”的目录，并在这个目录下初始化一个.git目录，从远程仓库拉取下所有数据放入.git目录，然后从中读取最新版本的文件拷贝。如果想重命名克隆下来的本地仓库的名字，可以使用如下命令：1$ git clone https://github.com/example myexample Local Repository前面已经提到了如何在本地创建 Git 仓库，现在来使用一下 Git 的部分功能。 Checking the Status of Local Reposity要查看当前目录下哪些文件处于什么状态，可以使用git status。以在本地新建的仓库为例，当使用git status命令时，会出现如下结果：1234$ git statusOn branch masterNo commits yetnothing to commit (create/copy files and use "git add" to track) 根据显示的英文的含义，可以得知当前目录下，没有文件，也无法进行提交，可以使用git add命令来跟踪文件。 Tracking a new file现在，在仓库内创建一个新的test.c文件，在使用git status命令来查看当前目录的状态。123456789$ git statusOn branch masterNo commits yetUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) test.cnothing added to commit but untracked files present (use "git add" to track) 此时，在Untracked files下面，出现了test.c文件，这意味着 Git 在之前的快照（提交）中没有这些文件（实际上，目前还没有一次提交）。Git不会自动将文件纳入跟踪范围，所以需要使用git add [file name]命令来跟踪指定文件，如下所示：12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c 此时，可以看到Changes to be committed这行下，存在new file: test.c，就说明test.c文件是已暂存状态（staged）了。另外，git add命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 Staging Modified Files紧接上面的步骤，若此时，修改了已暂存的test.c文件，此时使用git status命令，会看到如下结果：123456789101112On branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.cChanges not staged for commit: (use "git add &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) modified: test.c 这实际上就是 Git 的版本控制机制的特点—保存文件的快照而不是差异。也即是说，现在 Git 暂存区域内存储的文件是仍未修改的test.c，要暂存这次更新，需要再次使用git add命令来完成暂存，如下所示：12345678$ git add test.c$ git statusOn branch masterNo commits yetChanges to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: test.c git status命令的输出十分详细，使用git status -s或git status --short可以得到更加紧凑的信息：1234$ git status -sA change.cAM test.c?? test.exe 新添加的未跟踪文件前面有??标记，新添加到暂存区域的文件前面有A标记，修改过的文件前面有M标记；当然，M的有两个可能的出现位置，出现在右边的M表示该文件被修改了但是还没放入暂存区，出现在左边的M表示该文件被修改并放入了暂存区。例如，上面的状态显示test.c文件在工作区被修改了，还未放入暂存区。 Ignoring Files一般总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表，通常这类文件都是些自动生成的文件，比如日志文件，或者编译过程中创建的临时文件等。此时，可以创建一个名为.gitignore的文件，列出要忽略的文件模式。12345$ vim .gitignore*.[oa]*~*.exe*.txt .gitignore文件的格式规范如下： 所有空行或者以#开头的行都会被 Git 忽略 可以使用标准的 glob 模式匹配 匹配模式可以以/开头防止递归 匹配模式可以以/结尾指定目录 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号!取反 所谓的 glob 模式是指 shell 所使用的简化了的正则表达式，比如*就可以匹配零个或多个任意字符。 TIPS：GitHub有一个十分详细的针对数十种项目及语言的.gitignore文件列表，可以访问 https://github.com/github/gitignore 获取更多帮助。 Viewing Changesgit status命令输出的信息只对文件所处的状态进行了展示，可能觉得模糊，如果想知道具体改了什么地方，可以使用git diff命令。git diff命令会回答两个问题： 当前做的那些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？ git diff会通过文件补丁的格式在相应栏下显示具体哪些行发生了改变。现在修改test.c文件，在文件中加入如下一行：test.c12345678#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0;&#125; 接下来，使用git diff命令查看修改的部分：12345678910111213$ git diffdiff --git a/test.c b/test.cindex e0e5171..8642431 100644--- a/test.c+++ b/test.c@@ -3,5 +3,6 @@ int main(int argc, char const *argv[]) &#123; printf("Hello Git!\n"); printf("I want to change this file.\n");+ printf("Test git diff!\n"); return 0; &#125;\ No newline at end of file 可以看到，Git 回显了文件更新区域的信息以及对应的更新内容，而此时，git diff比较的是工作目录中当前文件（未暂存）和暂存区域快照（已暂存）之间的差异，也就是修改之后还没暂存起来的变化内容。 使用git diff --cached/git diff --staged可以查看已暂存的将要添加到下次提交里的内容。123456789101112131415$ git diff --cacheddiff --git a/test.c b/test.cnew file mode 100644index 0000000..e0e5171--- /dev/null+++ b/test.c@@ -0,0 +1,7 @@+#include &lt;stdio.h&gt;++int main(int argc, char const *argv[]) &#123;+ printf("Hello Git!\n");+ printf("I want to change this file.\n");+ return 0;+&#125;\ No newline at end of file 注意到上面并没有printf(&quot;Test git diff!\n&quot;);，那是因为，更新后的test.c文件并没有暂存。另外，git diff只能显示尚未暂存的改动，而不是自上次提交（commit）以来所作的所有改动。 Committing Changes现在的暂存区与已经摸熟了，可以来愉快的提交了😊，不过正式使用仓库的时候，提交之前最好看看有没有什么记录没有暂存起来，可以先用git status命令看下，是不是都已暂存起来了，然后运行提交命令：1$ git commit 提交后，会跳入到 vi/vim 编辑器界面（不同系统可能不一致），基本上都是默认的提交消息，保存在.git目录下的COMMIT_EDITMSG文件内，开头的空行用来键入提交说明，其他#开头的都是注释，去掉与否取决于个人，也可以使用如下命令来简化提交：123456$ git commit -m "Test Commit"[master (root-commit) 88ba107] Test Commit 3 files changed, 18 insertions(+) create mode 100644 .gitignore create mode 100644 change.c create mode 100644 test.c 注意，master表示当前提交是在master分支进行的提交，88ba107就是本次提交的完整 SHA-1 校验和，下面的信息表示本次提交中，有多少文件修订过，多少行添加和修改过。 使用git commit -a可以跳过提交之前先使用git add暂存文件（这些文件必须已经被暂存过）的步骤而直接提交。 Removing Files要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域），然后提交。可以使用git rm命令完成此项工作，并连带的从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。 如果只是简单地从工作目录中手工删除文件，运行git status时就会在“Changes not staged for commit”部分（也就是未暂存清单）看到该文件的删除记录了。例如，在Test目录下，删除change.c文件，使用git status命令可以看到：123456789$ git statusOn branch masterChanges not staged for commit: (use "git add/rm &lt;file&gt;..." to update what will be committed) (use "git checkout -- &lt;file&gt;..." to discard changes in working directory) deleted: change.cno changes added to commit (use "git add" and/or "git commit -a") 然后还需在运行git rm记录此次移除文件的操作：12345678$ git rm change.crm 'change.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: change.c 这样下一次提交时，该文件就不再纳入版本管理了。 如果将文件保留在磁盘内，但是并不想让 Git 继续跟踪，可以使用--cached选项，如下所示：12345678910111213$ git rm --cached update.crm 'update.c'$ git statusOn branch masterChanges to be committed: (use "git reset HEAD &lt;file&gt;..." to unstage) deleted: update.cUntracked files: (use "git add &lt;file&gt;..." to include in what will be committed) update.c 接着使用git commit命令提交后update.c文件就不在仓库内，但仍在磁盘上了。 Moving FilesGit 很聪明，一条移动文件的命令就能重命名文件并保留相同异名文件的状态，如下：1$ git mv file_from file_to 上述命令与下面三条命令类似：123$ mv file_from file_to$ git rm file_from$ git add file_from 使用一条命令干三件事，很棒吧~]]></content>
      <categories>
        <category>Tools</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[素数的求法]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%B4%A0%E6%95%B0%E7%9A%84%E6%B1%82%E6%B3%95%2F</url>
    <content type="text"><![CDATA[定义介绍如何求素数之前，首先得明白素数是什么？所谓素数（也叫质数），是指大于1，且只能被1和其本身整除的数（此定义与合数的定义相对）。 简便求法在对时间复杂度没有要求的情况下，直接从定义出发，利用循环，一直做取余运算，就可以很容易的得到判断一个数字是否为素数的算法，具体如下：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1) &#123; flag = false; &#125; else &#123; for(i = 2; i &lt; number; i++) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 很明显，因为借助了一层循环，所以时间复杂度$O(n)$，优点就是十分容易理解了。 结合数学知识的优化在理解了简便求法之后，来稍微思考一下，偶数能被2整除，所以肯定不是素数，如果一开始先判断number是不是偶数，然后在从 3 开始判断number是否能被奇数整除，如此一来，整个循环次数就是$(n - 3) / 2 + 1$（奇数每次增加2，所以分母为2）了，当$n$较大的时候，这个值是趋近于$n / 2$的。接着来改写一下代码：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 相比简便求法，将总体时间缩短了一半，时间复杂度是$O(n/2)$。 实际上，循环区间可以缩减为$[3, \sqrt{number})$（此处的数学证明就不多说了😁，可以简单想一下，一个数$n$，对于$x &lt;= n$，如果$n$能整除$x$，则$n$也一定能整除$n/x$，这两个数中必定有一个大于等于$\sqrt{n}$），具体如下：123456789101112131415bool Is_Prime(int number) &#123; bool flag = true; int i; if(number &lt;= 1 || (number % 2 == 0 &amp;&amp; number != 2)) &#123; flag = false; &#125; else &#123; for(i = 3; i * i &lt; number; i += 2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 上述代码块中用i * i来代表平方根的写法较为常见，这样此算法的时间复杂度就为$O(\sqrt{n})$。 转换思路按照之前的做法，无论i的值是素数还是合数，都对number进行了整除的运算。实际上，判断number是否为素数，只需要在i的值为素数的情况下，判断number是否能被i整除即可，若能整除则不是素数，反之则是。在进行上述计算的过程中，需要提前准备一张素数表来帮助计算，具体如下：1234567891011bool Is_Prime(int number, int Prime[], int NumOfPrime) &#123; bool flag = true; int i; for(i = 0; i &lt; NumOfPrime; i++) &#123; if(a % Prime[i] == 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; 在计算的数据较大的情况下，无法直接给定素数表，需要边判断边更新，这样会消耗掉一定的时间，所以上述算法的实际时间复杂度$O(n) ∈ (\sqrt{n}, n/2)$，但此法很适合需要构造素数表并求和的场景。 紧接着刚才的思路，以2为例，在判断出其为素数后，其倍数$4、6、8、10...$就是非素数了，那么一次性将这些数字标记为非素数，也可以提高效率，这就是“筛选法”构造素数表，具体如下：1234567891011121314bool IsPrime[NumOfPrime];for(i = 2; i &lt; NumOfPrime; i++) &#123; IsPrime[NumOfPrime] = 1;&#125;void Get_Prime() &#123; int x, i; for(x = 2; x &lt; MaxNum; x++) &#123; if( IsPrime[x] ) &#123; for(i = 2; i * x &lt; MaxNum; i++) &#123; IsPrime[i*x] = 0; &#125; &#125; &#125;&#125; 尽管分析代码，粗略可得此算法时间的复杂度为$O(n * loglog{n})$，之所以是这个时间复杂度，是因为一次性计算出了$[0, MaxNum)$这个区间内的所有素数，此算法实际效果较好，对于需要构造素数表的情况很方便。 扩展上面介绍的“筛选法”，其实是古希腊数学家埃拉托色尼（Eratosthenes，274 B.C ~ 194 B.C）提出的一种筛选法，也称埃氏筛法。实际上，结合利用素数表来判断素数的思路，对于合数而言，如果其只要被其最小质因子整除，即可判断其不是素数。那么去掉这部分重复计算的过程，不就可以提高效率了吗？以16为例，在埃氏筛法中，$x = 2$时，筛选掉了$4、6、8、10...$，当$x = 3$时，又重复计算了$6、12...$等数。接着来修改下代码：123456789101112bool Number[MaxNum];memset(Number, true, sizeof(Number));int Prime[MaxNum], count = 0;for(i = 2; i &lt; MaxNum; i++) &#123; if( Number[i] ) &#123; Prime[count++] = i; for(j = 1; j &lt;= num &amp;&amp; i * Prime[j] &lt;= n; j++) &#123; Number[i * Prime[j]] = false; if(i % Prime[j] == 0) break; &#125; &#125;&#125; 上述代码的时间复杂度为$O(n)$（计算过程暂不深究），所以此种筛法也叫线性筛法，不过提升效率的代价就是多余的空间开销了，一般而言的优化都是这样的思路。]]></content>
      <categories>
        <category>CS</category>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Prime Number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[雨夜杂思]]></title>
    <url>%2F2019%2F05%2F30%2F%E9%9B%A8%E5%A4%9C%E6%9D%82%E6%80%9D%2F</url>
    <content type="text"><![CDATA[是夜，窗外的雨声淅淅沥沥的下着，心里想着自己这段时间的生活，不由得有了些感慨，毕竟又是一年逝去了。 See the sky about the rain - Neil YoungYour browser does not support the audio tag. 雨，原来我是很讨厌的。因为，下雨就意味着要打伞，会嫌麻烦，而且还会淋湿。更甚者，若是雨下的太大，一旦把鞋打湿了，那滋味可就不好受了。不过，即便如此，现在的我，于雨，是喜欢的。 每当下雨之时，我总会有这样的想法：是谁又在独自伤心？惹得老天爷陪她（他）一起哭？。最初萌生这个想法的时间，是自己的高中阶段，具体无法记清是那个年级了，只知道那是一个傍晚，下课后大家都去吃饭了，正巧那天我心中有事，就在教室发呆，等回过神来的时候，才发现还得去吃饭，毕竟晚上还得上课。于是下楼，出去才发现下雨了，想也没想，迈着步子就往前走，走着走着，突然发现，好像没那么大，于是原先的疾步成了漫步，紧接着，脑中就冒出了这个想法，回过神来才发现，我怎么会有这样的想法？因烦事僵直的嘴角，此时有了微微上扬的弧度，心中不免乐观了起来。至此之后，每当下雨的时候，在其他人都抱怨下雨地滑、淋湿之类的时候，我总会在心中想，到底是谁又在伤心呢？希望老天爷的雨可以抚慰住她（他）受伤的心...后来每当自己心情不好的时候，总看看天上是否有雨，像是要得到安慰的孩子一样，不过好在，自己是被满足的。 现在又一年的五月最后的日子了，面临即将到来的六月，心中不免有些不舍，时光好像又趁着自己不注意溜走了。曾经感叹时间过的太慢的自己，现在已经成了感叹时光的“老人”。是从什么时候开始，自己的心没有当初的那份“年轻”了呢？好像连自己这个变化也记不清了，这个问题揭开来看，感觉自己有点可悲呐。以为自己是按照自己的方向前行，但却连自己的转折点都不清楚，那也就意味着多年来的自己依然是一个被动的选择者？诶，不对，有句话，不是叫时间总是在不经意间改变了大家吗？这应该是“常理”，不是我可抗的...吧？说这么多，其实结果如何，心中所思，答案早已不变。 窗外的雨声好像小了些，从窗户的细缝中有凉风吹进来，微微拂起了窗帘，是来提醒我该睡觉了吗？好像又是在自我安慰呢（囧），大半夜隔壁竟然还有杀猪一样的笑声传出来，是什么事情让他们这么兴奋？算了，没有兴趣去了解，现在的自己只想专注到自己的事情上。 指甲还有一两周就长出来了，这样我又可以做手指操了。糟糕，笔记本好像要没电了，这次就先写到这里吧，滚去睡觉ing。]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言常用库函数]]></title>
    <url>%2F2019%2F05%2F24%2FC%E8%AF%AD%E8%A8%80%E5%B8%B8%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[Intro最近发现一个问题，做题的时候，不管有的没的，要用的函数全靠自己写，写来写去也懒得去管到底有没有那个库函数了…这样不太好，日后还不是得把自己累死，还是得善于利用东西才行（又为自己偷懒找借口🤣）。于是，这篇文章就用来记录C中常用的一些库函数，以免日后又忘记了。 stdlib.hstdlib.h即standard library标准库头文件，这个头文件内有很多有用的工具函数。 qsortqsort函数是C语言自带的排序函数，采用排序方法是快速排序，其声明位于头文件stdlib.h中，貌似快速排序是实际使用效果最好的几种排序方法之一。 Function Prototype函数原型如下：1void qsort(void *base, size_t num, size_t size, int (*compare)(const void *, const void *)); 参数说明：basenumsizecomparebase指向数组的起始地址，通常会传入一个数组名num表示该数组元素的个数size表示数组中每个元素的大小（字节数）(*compare)(const void*, const void*)为指向比较函数的函数指针，决定了排序顺序 Compare Functionqsort函数声明中的compare参数是一个指针，指向一个比较两个元素的函数。比较函数的原型应该是int compare(const void *a, const void *b);，注意这个函数的形参是const void *型，也就是说，是不限制参数指针类型的，并且，返回值是int型的。qsort函数在使用compare函数指针调用compare比较函数时，传入的实参是没有限定指针类型的。一般而言，compare函数按照下面的代码来写：123456int compare(const void *a, const void *b)&#123; if(*(int*)a &lt; *(int*)b) return -1; if(*(int*)a == *(int*)b) return 0; if(*(int*)a &gt; *(int*)b) return 1;&#125; 从上面的代码可以看出，指针a和b在传入到compare比较函数内后，先进行了指针类型的强转操作，然后再分别对强转后的a和b指针进行解引用，并做差来判断*a和*b的大小，根据三种不同的情况返回三个值，分别对应以下三种情况：-101(*a)所指向元素会被排在*(b)所指向元素之前(*a)所指向元素和*(b)所指向元素之间顺序不确定(*a)所指向元素会被排在*(b)所指向元素之后 Examples对普通int型数组进行排序时：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int compare(const void *a, const void *b)&#123; return (*(int*)a - *(int*)b);&#125;int main(int argc, char const *argv[])&#123; int i, array[8] = &#123;30, 52, 11, 29, 58, 3, 88, 60&#125;; qsort(array, 8, sizeof(array[0]), compare); for(i=0; i&lt;8; i++) &#123; printf("%d ", array[i]); &#125; return 0;&#125;/*Print: 3 11 29 30 52 58 60 88if '(*(int*)b - *(int*)a)' replaces '(*(int*)a - *(int*)b)'then Print: 88 60 58 52 30 29 11 3*/ 对其他类型的数组而言，使用方法也大致如此，对字符串数组（即二维字符数组）使用时，可以将比较函数这样写：1234int compare(const void *a, const void *b)&#123; return (strcmp((char*)a, (char*)b));&#125; 配合strcmp函数使用就会很方便。另外，快速排序是不稳定的排序算法，对于结构体而言，当两个元素的值相等时，经过快速排序后，其相对位置可能发生了改变，这就导致结构体排序完成之后，输出结果不对（但是序列有序无误），为了避免这种情况，需要在结构体内新增一个标记位，当两个结构体值相等时，比较标志位的大小，从而保持二者相对位置不发生改变。 ctype.hctype.h这个头文件全称应该是character type吧，因为其内部定义了一批C语言字符分类函数，用于测试字符是否属于特定的字符类别。这些函数实现起来都不难，再重复造轮子就有点划不来了。 对于一个字符变量而言，其本质依然是整型变量。 isalpha这个函数用于判断传入的字符是否是字母（包含大小写）。函数原型：1int isalpha(int ch); 若传入的字符是字母，则返回非零，若不是则返回0。 isdigit这个函数用于判断传入的字符是否是罗马数字（0-9）。函数原型：1int isdigit(int ch); 若传入的字符是数字，则返回非零，若不是则返回0。 isxdigit这个函数用于判断传入的字符是否是十六进制字符（0-9、A-Z、a-z）。函数原型：1int isxdigit(int ch); 若传入的字符是十六进制字符，则返回非零，若不是则返回0。 islower这个函数用于判断传入的字符是否是小写字母（a-z）。函数原型：1int islower(int ch); 若传入的字符是小写字母，则返回非零，若不是则返回0。 isupper这个函数用于判断传入的字符是否是大写字母（A-Z）。函数原型：1int isupper(int ch); 若传入的字符是大写字母，则返回非零，若不是则返回0。 tolower这个函数用于将传入的字符转换为小写字母。函数原型：1int tolower(int ch); 返回值为所传入字符变量的小写字母。 toupper这个函数用于将传入的字符转换为大写字母。函数原型：1int tolower(int ch); 返回值为所传入字符变量的大写字母。 isalnum这个函数用于判断传入的字符是否是字母或数字。函数原型：1int isalnum(int ch); 若传入的字符是字母或数字，则返回非零，若不是则返回0。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言里爬过的“坑”]]></title>
    <url>%2F2019%2F05%2F16%2FC%E8%AF%AD%E8%A8%80%E9%87%8C%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91%2F</url>
    <content type="text"><![CDATA[Intro那是一个下着大雨的夜晚，室外急促的雨声正好映衬着室内紧张的气氛，快，只剩下最后一个BUG了！终于在大半个小时之后解决了，仔细一看，原来是之前碰到过一次的问题了...心中不免想到，要是上次有好好记录就好了。于是，就动了整理这篇Blog的心思啦~此Blog会长期不定时更新，记录下自己在跟老爷子C玩耍的过程中，碰到的一些坑爹之处（菜请轻喷，嘿嘿）~ scanf 关于scanf先说一点，scanf函数是带返回值的，有的编译器会忽略掉这个返回值（没有告警产生），但是实际上是存在的，切记。 scanf这个函数给用户留下的坑，实际上不是它的返回值，而是这个函数对用户能向其输入的东西的规定（😓说了一大堆让人听不懂的话...）。换句话说，也就是scanf自身对输入流中的数据的获取的机制可能会让用户“坑爹”。对于C语言而言，在读取键盘输入的数据时，一般是带缓存的数据输入，需要按回车键才能完成该“行”数据的输入确定。而scanf对这个回车确认符并不进行处理，回车符会留在输入缓存区中。因此，在下一个“字符”操作函数（getchar()、scanf(&quot;%c&quot;, &amp;x)、gets(s)等）运行时，会读到这个回车确认符。另外，在读取数值型数据或字符串（注意这里没有字符变量）时，scanf会从第一个非空白字符（空白字符指：回车、空格、TAB等）开始读取，自动忽略前面的空白字符，而遇到空白字符结束该类型数据的输入。因此，对于这个回车确认符（空白字符）的处理，需要看下一个输入的数据类型是什么，如果是字符类，那就需要消除掉这个回车确认符，处理办法有多种方式，下面介绍3种方法：Method 1Method 2Method 3使用fflush(stdin)命令强制刷新输入缓存，丢弃缓存中的数据，注意此种方法在windows下使用有效，linux无效，因为Linux没有fflush。 12345int a;char c;scanf(“%d”, &amp;a);fflush(stdin); //clear the ‘enter’ charscanf(“%c”, &amp;c);回车符也是字符，可以使用getchar();来吃掉这个回车符号。 12345int a;char c;scanf(“%d”, &amp;a);getchar(); //clear the ‘enter’ charscanf(“%c”, &amp;c);利用scanf函数的一些机制，如：scanf(&quot;%d%*c&quot;, &amp;i)，%*c表示读一个字符，并不赋值给任何变量。 123int a;char c;scanf(“%d%*c%c”, &amp;a, &amp;c); 另外，关于scanf还有一个比较有特点的地方，就是无法读入空格字符，所以包含空格字符的字符串就得使用gets或者fgets函数来读入了。还有一个就是&amp;的使用。注意，除了读入字符串外，其他都需要使用&amp;，估计这是不少新手会犯的错误了😀，问题是不会编译不报错也不警告，偶尔不仔细，老手都要找半天... ifif关键字可不“坑”，“坑”的是使用它的人（又黑自己一把...😂），if一般和else及else if配合使用（也可以单独使用），一般用法如下：123456789101112131415/*if-else*/if(expression)&#123; statement1;&#125;else&#123; statement2;&#125;/*if-else if-else*/if(expression)&#123; statement1;&#125;else if(expression)&#123; statement2;&#125;else&#123; statement3;&#125; 上述内容，读懂很容易，但问题其实就在这个expression上，这个表达的值会影响if这类语句的判断。众所周知，expression为true执行statement1，为false则执行statement2，else if同理。所以严格上讲，if认为的true是非0（其他语句，如while的条件判断机制应该也是这样），啥意思？就是说，不管expression的值是1还是-1，if都是认为是true（建议尝试），所以，可别看到表达式的值是负数，就认为条件不成立了。 parameter passing这里所介绍的参数传递主要是针对C语言内的函数。众所周知，C的函数采用的是值传递的方式，也即传入到函数内的参数，不管传入的值如何修改，依然不会改变main或其他函数内变量的值，要想改变有多种方式，这里简单介绍三种，具体如下：Way 1Way 2Way 3使用全局变量利用函数返回值，形如：a = abs(a);这样的使用方法使用指针，利用&amp;传入变量地址，修改指针指向的地址保存的值，如：*p = x;的用法如果只是介绍这些，那太简单了，这里想要说明的是指针在函数参数传递过程中的变化。如果一个函数的参数中存在指针，并且这个函数内会改变传入这个指针的指向（如：链表遍历），针对这种情况，C依然遵循值传递的规则，也就是说，即便指针被传入函数中了，它也不会改变这个指针在main或其他函数中的指向，具体请看下面的代码：1234567891011121314#include &lt;stdio.h&gt;void f(int *a);int main(int argc, char const * argv[])&#123; int *A; printf("%p\n", A); f(A); printf("%p\n", A); return 0;&#125;void f(int *a)&#123; a++;&#125; 上述这段代码的两次输出结果是一致的，也即指针也是遵循值传递的原则的。 typedef关于typedef的用法，这里不做过多介绍，只收集一下平常见到的使用方法。 为基本数据类型定义新的类型名1typedef int Data; 上述代码的作用能达到的效果就是int和Data等价，也即int a;和Data a;是两种相同的写法，此种方法在跨平台移植和作有意义的类型名时很方便。 为自定义结构类型定义类型名称注意说法，为自定义结构类型定义类型名称，注意只是类型名称哦，下面是一般的使用方法。1234typedef struct point&#123; int x, y;&#125; Point; 如果需要为结构定义指针，需要换一种方法：12345typedef struct LNode *List;struct LNode&#123; int Data; List Next;&#125;; 不过一般而言，标准的写法是下面这种：12345struct LNode&#123; int Data; struct LNode *Next;&#125;;typedef struct LNode *List; 两种写法都是编译通过的（No Warnings），究竟怎么写，就是智者见智的事情了。 为数组定义类型名称12typedef int int_array[10];int_array array; 按照上述代码， array就是一个容量为10的整型数组了。 为指针定义名称123456/*odinary pointer*/typedef char* Pchar;/*function pointer*/typedef int *(*Pfun)(int, char *);Pfun a[5]; //Pfun a[5] &lt;==&gt; int *(*a[5])(int, char *); 上述代码中，int *(*a[5])(int, char *)实际上是定义了一个返回值为int*的函数指针数组，函数的有两个，分别是int和char *。 two-dimensional arrayC语言中实际上并没有严格意义上的二维数组（其他程序设计语言可能也是如此？），因为物理内存的地址是连续且一块一块的，那C语言是如何去保存二维数组和寻址的呢？ 按照上述的思路，先来总结一下二维数组的特点。很明显，二维数组包含三个参数：行（Row）、列（Column）和需要存的数据（Data），既然前面已经说过了物理内存是连续分布的，那毫无疑问，二维数组中的 Data 依然是连续的存储在物理内存中的，这个现象是不是在哪见过？没错，就是一维数组；接着，如何去寻址呢？这个问题其实可以用二维数组的行和列来解决，假设总行数为R，总列数为C，找第2行，第3列的元素，按照顺序存储的规则，实际上对应元素的下标（下标从0开始）应该是2 * C + 3，一般化就是i * C + j。举个实例，按照如下的矩阵：$$\begin{matrix}1 &amp; 2 &amp; 3\\4 &amp; 5 &amp; 6\\7 &amp; 8 &amp; 9\\10 &amp; 11 &amp; 12\\\end{matrix}$$C语言编译器要提取8这个元素，整个矩阵是4行3的，若行、列下标从0开始，行、列循环变量分别为i、j，那么8这个元素对应的下标（i = 2, j = 2）就是i * C + j = 2 * 3 + 2 = 8，实际上也就是从左往右依次按序数下来的结果。 character二维数组也有字符二维数组和整型二维数组，字符二维数组的使用会简单点，咱先从简单的来。字符二维数组实际上很容易理解，可以把二维数组想象成一根一根“辣条”（别说你没吃过...囧），这一根根“辣条”，每一根都是一个一维字符数组（其实就是一个字符串啦~）。1char str[3][5]; 上面这行代码的意思是声明一个字符串数组，这个字符串数组的容量大小是3，每个字符串能存储的最大长度是4（因为\0也要占一位），也可以按照下面的方法初始化：123char str[3][5] = &#123;"str1", "str2", "str3"&#125;; 之所以分开三行写，是因为想展示出一条一条的样子（笑ing），这是可以直接输出的哦~ 如果你指针学的不错的话，你一定会发现str[0]、str[1]和str[2]其实就是分别指向这三个字符串的指针。 所以，字符串数组还可以这样声明和初始化：123char *str[3] = &#123;"str1", "str2", "str3"&#125;; 严格上来讲，char *str[3]其实声明了一个指针数组，这个指针数组有3个字符型指针变量，分别指向三个字符串。其中的每个指针变量，其实可以当作每个字符串的头指针来用。 number明白了字符二维数组后，数字型的二维数组理解起来就简单了。首先，它不再是“辣条”了，他是单独一个一个的，不过存储方式依然是顺序存储的，二维数组的逻辑结构，其实就是上面提到过的矩阵。不过它的容量计算很简单，也就是行列之积了。 how to use如何使用这类二维数组，我们考虑三个方面的应用：输入、输出和传递。 input and output懂了输入，其实也就会输出了，那就只介绍输入了（偷懒😜）。 对于字符串数组（这样叫其实更合适也更易于理解），与普通一维数组一样，若有多个输入，则使用循环，逐个读入即可。 对于数字型二维数组，先输入行，还是先输入列取决于实际应用，由于不仅要输入行，还需要输入列，所以得使用二重循环搞定。 function parameter transfer 二维数组作为函数参数传递的过程就是个有点玄乎的过程了，不过切记一点，数组传递到函数中的都是指针。 字符串数组传递时，有两种使用方法，分别如下：Character 1Character 21void fun(char (*str)[5], int n);1void fun(char str[][5], int n); 上述的这两种方法有一个共同点，也即需要给定每个字符串的长度。 数字型二维数组的传递与字符串数组的传递类似：Number 1Number 21void fun(int (*array)[5], int n);1void fun(int array[][5], int n); bool早期的C标准内其实是没有bool类型的，原先一直存在于C++中，后来在C99标准发布的时候，加入了bool类型。 在使用bool类型时，需要引入头文件stdlib.h，用法如下：1234567891011121314151617181920#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool func(int a) &#123; if(a &gt;= 0) &#123; return true; &#125; else &#123; return false; &#125;&#125;int main(int argc, char const *argv[]) &#123; printf("func(-1) = %d, func(1) = %d, func(0) = %d\n", func(-1), func(1), func(0)); return 0;&#125;/*Result:func(-1) = 0, func(1) = 1, func(0) = 1*/ 明显可以看出此时false = 0, true = 1。 若无法引入头文件stdbool.h时，该如何继续优雅的使用bool类型呢？ 一般而言，有两种方法：typedef#define1typedef enum&#123;false, true&#125; bool;利用typedef和enum关键字构造枚举。123#define bool int#define false 0#define true 1使用宏定义直接定义（C99就是这样干的，可以看看stdbool.h头文件的内容）。 operator关于C语言运算符的问题，实际上就是不同运算符之间优先级（precedence）的问题，这部分问题，主要是针对应试吧，生产环境中大概写个测试程序就能得出结论了吧~ 优先级 运算符 结合性 1 () 从左到右 2 !、+、-、++、– 从右到左（单目+、-） 3 *、/、% 从左到右 4 +、- 从左到右 5 &lt;、&lt;=、&gt;、&gt;= 从左到右 6 ==、!= 从左到右 7 &amp;&amp; 从左到右 8 &#124;&#124; 从左到右 9 =、+=、-=、*=、/=、%= 从左到右 注意：上述表格第二行中，“单目+、-”指的即是正负号。]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[房屋装修之“坑”]]></title>
    <url>%2F2019%2F05%2F15%2F%E8%A3%85%E4%BF%AE%2F</url>
    <content type="text"><![CDATA[引子这几天家里的房子在装修，看着母亲那么忙碌和操心的样子，于是便趁着自己偷懒的时间，回去协助一下母亲，并顺便收拾点自己之前的“家当”—— 就是书和写过的笔记了。 何谓装修说起装修，我对这个名词的概念略微有点模糊，得在这个词前面加点啥来帮助理解和想象，比如：房子装修。仔细来讲，装修又称装潢或装饰，是指在一定区域和范围内进行的，包括水电施工、墙体、地板、天花板、景观等所实现的，依据一定设计理念和美观规则形成的一整套施工方案和设计方案。一般而言，针对不同的环境，有着不同的装修方案和风格，酒店和商场的装修方案和风格就大不相同，而这是由这些场所的职能所确定的，必须要满足大众化的认知，即装修能被大众所接受、理解，进而达到喜欢。装修，需要施工，依据施工的对象（水电、墙体、地板、天花板等），对应的工人师傅也可以分为：木工、水电工、瓦工、油工，而您家住的房子的“外观”就是由这些人，一步一步来完成的。 如何“装修”看着上面的大标题，之所以加上引号的原因在于，对于房主（买房的人）而言，如何装修呢，其实就是花钱找人干活罢了，毕竟咱又不会和水泥、做木工的。嗯，既然是要花钱，那咱这钱得花的在“点”上才行，至于会不会被坑，这就得找对人了。那么回到正题，就目前市场而言，房子装修的方式（和师傅的“商务”合作方式😂）大概有两种： 包工包料，也即“包干”（这种宣传手段随处可见…）包工不包料，材料需要主人购买，师傅只负责干活了 那么，按照以上的两种方式，也有不同的优点和缺点，包工包料最直接的优点就是，客官您给钱就成，一切师傅替您搞定。这种方式，得看找的师傅的人品了，要不然给您偷点工、减点料，房子住个一年半载就返工的，那可正是有的受了，当然了，要是您钱给的足，那当咱没说这话。不过，对于一般家庭而言，多少还是会考虑到综合预算及性价比等方面的。所以呢，选择这种方式的，一般会找亲戚或关系特别铁的“哥们”（亲朋好友）。对于另外一种方式而言，那就意味着房主又得想办法找人，又得想办法去找渠道购买合格的材料（劳心啊😝）。先不说找人干活得找个靠谱的人，单单只从购买材料的角度讲，房主若不是相关行业内的人士，在购买这些材料的时候，会比较困难。首先，不知道购买那个型号、那个品牌的材料，不过这个问题可以通过去询问雇佣的师傅来解决。紧接着的问题，就是购买的渠道和“识货”的本领了，购买渠道略带风险，不然买到次品或假货就难受了，当然如若能自己分辨假货，那最好不过了（需要经验）。其实，在整个装修过程中，仅仅只注意上面的内容还不够，从一开始确定装修的时候，有点需要确定的就是，装修的顺序了！一般而言，可以大概按照下面这个顺序来进行： 主体改造 → 水电 → 瓦工 → 木工 → 油工 → 灯饰 → 清洁 → 验收当然了，不同地区的装修市场的装修顺序可能不是一致的，但大体上是一样的，不然的话，不同手艺的师傅无法配合干活的。 装修之“坑”俗话说的好：吃一堑长一智所谓的装修之“坑”，“坑”在什么地方呢？还能在哪…钱呗，正所谓，无商不奸，东西卖给你，商家哪能不赚钱呢，是吧。不过话说回来，咱还是那个态度，赚钱可以，价格合理公道，质量优良耐用，该付的钱咱照样给（哇，好无力的感脚~）。不过呢，不同地区的市场可能在某些地方上有所差异。就拿前几天，咱碰到的一个“坑爹”的事情为例。 起因家中房子装修，需要安装防盗网，于是便找人去做了，但没有提前把价格谈好（这个是真的烦，以后做事之前一定得先把这些利益关系处理好）。 安装做好之后，即进行安装，整个过程中一切OK。 问题由于在做之前，没有谈好价格的问题，从而导致，最后在结账的时候，成了“糊涂账”，造成了一种公说公有理，婆说婆有理的局面，手动捂脸ing。 问题成因之所以会存在这个问题，咱得先明确这个防盗网的议价规则，按照我这边本地的市场，防盗网是按照$X元/m^2$的价格来计算的，而防盗网的结构是下面这种结构：接下来的问题是按照这个结构，如何计算这个物体所占的面积（$m^2$），恰巧问题就出在这里了。 计算方式按照之前的思路，防盗门窗面积的计算方法其实有两种： 逐面计算，累加得结果逐面平铺，计算整体，减去不存在面，即得结果 具体而言，可以参照下图进行计算：从图中可以分别知道两种方法对应的计算方法： $1.\ S_{sum} = S_1 + S_2 + S_3 + S_4 + S_5$$2.\ S_{sum} = S - 4 \times S_1$ 只要尺寸量的是正确的，两种方法皆可计算出防盗门窗的真实面积，商家采用的是第二种方法，不过没有减去那4块不存在的面积，而这也就导致按照这两种方法计算出来的结果相差了大概10个$m^2$左右，与单价一合计，差值还是比较大的。如果是存在的面积计算在内，还可以理解，但那4块面积是不存在的，不存在还算进去，那不是无中生有吗？于是去找商家理论，结果被告知是市场规则、行业规则（总之就是不让价），这不是摆明了坑人么？后来，又了解到，据说如果是给亲朋好友做，是得减去那四个不存在的面积的，如果不是亲朋好友，那就歇菜了（😂，果然是无商不奸）。 解决方式磨嘴皮子磨嘴皮子磨嘴皮子…没有啥捷径哈~ 总结还是那句话，做事之前，千万要处理好利益关系。不过话说回来，商家这确实有点“坑”人，明里来说材料贵即可，还玩这些“花招”，真是“兵不厌诈”？更何况只是简单的小学数学😂！哎，这也就欺负一下常年在外打工挣钱的和文化水平不高的人，恰巧正好是咱们父亲、母亲那一辈人。另外，从这些事情也可以看出，家装这个行业的水也是足够深的哈，先不说材料可能会搞鬼了，光着算账都着实让人觉着坑爹😑，都不知道该说啥好了。类似的问题，在木工、瓦工等装修过程中同样存在（其他行业估计也这样），所以，吃一堑长一智，这话记住准没错~]]></content>
      <categories>
        <category>Life</category>
        <category>Jottings</category>
      </categories>
      <tags>
        <tag>Jottings</tag>
        <tag>Interior Finish</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇葩的国内BGP业务架构]]></title>
    <url>%2F2019%2F04%2F09%2F%E5%A5%87%E8%91%A9%E7%9A%84%E5%9B%BD%E5%86%85BGP%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Intro国内存在BGP业务，但是实际上并不是严格意义上的BGP，而是通过模拟来构建的“静态BGP”；之所以是这样的情况，原因是运营商和政策…打住，扯远了，我什么都不知道🤫。反正客户需要就做😂，本着先做先完事，隐患日后再说的原则（笑ing），好歹算是捯饬出来一个。 Static BGP Brief Description与BGP相关的原理内容在这里不介绍了（咱也不太懂🤣），具体说下做这玩意的前因后果吧，这部分内容就当“侃大山”吧🤔。 国内运营商三巨头：中国电信、中国移动、中国联通，这三家国企想必大家都比较熟（tao）知（yan）；而与这三家运营商互联的方式呢，一律全部都是采用静态互联的方式；之所以采用静态互联，也不是因为动态技术不成熟等之类的缘由，其实就是简单且易控制，直接放给你就完事，想控制直接修改配置就好，其实还有一个点，那就是采用动态后，对某些网络提供商而言会比较“不公平”，动态路由收敛可是选择延迟最小、损耗最低的线路的。具体嘛，咱也别太深究，是这么个规定，大环境是这样，咱改变不了，遵守就行了。话在说回来，按照这样的环境，对于网络提供商和运营商接入的路由器而言就只能保证一个线路的方向了（单、多线无法与BGP共存），那BGP又是从何谈起的呢？还有其他的双线、三线之类的业务又是怎么做的？ 得嘞，咱还是先从单线业务说起吧，这没啥难度的，单线业务，给服务器配一个IP完事，没啥说的。这类业务的特点就是—不管你用源IP去访问什么地址，都是从一个线路出去的，比如，源IP电信的，那你出局就是电信线路，源IP联通的，出局就是联通线路。 在说双线业务，单线业务配一个IP，那双线业务不就配两个IP完事吗？(⊙﹏⊙)，对了一半；双线业务的确需要配置两个IP，但是并不是配置两个IP就完事了，还需要在服务器上导入去往各个地址段的路由。什么鬼？服务器还能加路由，还真能加😓，这如果要说，又要牵扯到一些东西，嗯，别急，给你娓娓道来。 咱先不说怎么去加路由，咱先介绍下国内的网络环境。首先得明确IP地址这个玩意在大网环境内是唯一存在的（私网地址你就折腾去吧），换句话说，三大运营商是拥有只属于自己的IP地址的（什么？你也想要属于自己的IP地址？自己去找管理IP的组织去买吧，多少钱？嘿嘿，自己去问。），并且这些地址在国内的大网环境下是唯一的。这样就会产生一个问题，既然联通的地址只属于联通，那电信用户如何去访问联通的地址呢？答案就是运营商之间做了互联，至于是动态的还是静态的，这个，嘿嘿，不是咱讨论的范围，在有互联的前提下，电信用户也就可以去访问联通的地址啦。好，这个问题明白了，咱在来看看另外一个现象，不知道各位看官有没有留意过，网络游戏总会有一些网通区、电信区等，如果电信用户已经可以访问联通地址了，那么运营商都做成全网可以互相访问不就得了，那这样还搞这些区干毛？诶，这个其实是有点讲究的，嘿嘿。答案就是，如果你是联通用户，你选择网通区进行游戏，你会觉得网速非常快。你问为啥？因为网通区的游戏服务器IP肯定也是联通的IP，这样在本运营商内部进行访问的时候，那不就是在“内网”里面进行数据交互了吗？都没跑到“公网”上去，速度肯定快啊😂。其他也同理，这也是为啥有人会说中国的网络实际上是一个大的局域网，特别是被Great Firewall of China禁掉一些国际IP后🙊。 好了，在回到加路由的问题上来，咱已经知道给服务器配置两个IP了（现在应该也知道为啥要搞这种双线机器了吧，手动笑哭），那加路由怎么加呢？对于一个IP地址而言，如果要和其他子网通信，必须存在网关，利用网关来接收、发送数据包，双线机器两个IP，肯定也有两个网关啊，服务器能同时配置两个网关？答案是不能，那ta niang的怎么办呢？答案是写路由啊（为了引出你来，写了这么多字，手酸啊🙃）。以配置了联通、电信的地址的双线机器为例，访问联通地址使用联通网关，访问电信地址使用电信网关，这样就可以啦，就可以愉快的访问按指定线路访问指定的运营商的IP地址啦。 写到这里，网络工程师可能会有问题了，路由器、交换机上怎么去配置多个网关（子网划分），并且做到不同线路的出局呢？ 当然了，对于网络工程师而言，这里还需要考虑一个问题，双线机器有几个网卡，假如有多个网卡，那很简单，不同的网卡做通不同的数据就好啦，那一个网卡怎么办？ 首先，先来解决多个网关的问题，服务器如何去配置，运维工程师自有妙计，咱不去管它；路由器、交换机如何配置呢？以华为设备为例，配置过程大概如下：1234[R1]vlan 10[R1-vlan10]interface vlanif 10[R1-Vlanif10]ip address 10.0.254.1 24[R1-Vlanif10]ip address 10.0.253.1 24 sub 完事后是这样：12345#interface Vlanif10 ip address 10.0.254.1 255.255.255.0 ip address 10.0.253.1 255.255.255.0 sub# 这样就把两个不同网段的数据做到一个vlan下了。 咱们在看出局的问题，出局需要借助一个叫PBR, Policy Based Routing的玩意，嘿嘿，厂商真会玩，是跟运营商偷偷商量好了是吧。具体如何去做，要视具体的网络架构和环境去做（自己去百度😝）。 好，双线业务大致就是这样了，对应的三线业务，就不用我说了吧，嘿嘿，不过网络提供商可能会用“BGP”地址来代替多线业务配置的多个IP地址来避免IP地址的浪费（但据说“BGP”地址贵啊，不过，这是商务的事情，商务自有商务的一套）。 回过头来看一下，双线、三线业务需要做的配置还是比较多的，不管是服务器还是路由器，不也是累的一逼吗？有没有什么能一次性搞定，而且三网内都跟跑“内网”一样呢？诶，运营商又出马了：觉得麻烦是不是，好，我给你们减负（真是这样么？运营商会这么好心？），我们现在能提供一种“BGP”的产品，这类地址具有能从三网线路独立访问的特性。什么意思呢？也就是说各个运营商的用户访问这些“BGP”地址的时候能用自身运营商的线路去访问，而不需要跨运营商。所达到的效果其实是和三线业务一样的，只不过会方便很多（对客户而言，IP配置一个，服务器也不用写路由，嗨啊），但是一样需要前期把路由器上的配置都做好啊啊啊，还是好麻烦啊。 后来，人们给这种“BGP”地址一个洋气的名字，就叫做Static BGP🤣。 好，故事到此结束🤣。 Static BGP Routing下面就进入正题啦。具体架构就按照下面这个图吧~ 又弄了一张图，两张图结合一起看，对比来看，容易一些（据说是TX的网络部门大牛画的）。 Basic Connection底层互联，使用静态互联即可，但这需要底层的传输网络足够健壮、稳定。保证二层传输网络健壮性技术主要有VCS、ERPS等，这些都属于二层无环路保护协议，具体如何配置，在自行研究。现在就以二层已经配置好了保护协议为例，给出两台路由器的静态互联IP信息来协助配置BGP。 R1-CM-Access1234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# R2-BGP-Router1234!interface ve 925 ip address 10.0.254.1/30! 单向测试一下：BGP-Router1ping 10.0.254.1 source 10.254.0.2 BGP Config下面介绍BGP的相关配置，以与一个运营商接入的情况为例，其中CM-Access为华为设备，BGP-Router为博科设备。与运营商接入的设备配置比较简单，咱只用做好BGP连接就好了。R1-CM-Access12345678910111213&lt;R1&gt;system-view[R1]bgp 9527 //建立BGP进程，设置AS号为9527[R1-bgp]router-id x.x.x.x //设置router-id，一般为环回接口地址[R1-bgp]peer 10.0.254.1 as-number 35129 //设置BGP对等体[R1-bgp]peer 10.0.254.1 description BGP-Router //添加该对等体的描述信息[R1-bgp]peer 10.0.254.1 enable //建立和BGP对等体的TCP连接[R1-bgp-af-ipv4]import-route static //导入静态路由[R1-bgp-af-ipv4]quit[R1-bgp]quit[R1]ip route-static ..... //写入移动运营商路由[R1]ip route-static ...[R1]quit&lt;R1&gt;save //保存配置 BGP核心路由器R2的配置相比R1要多很多了，并且是在有意识的进行配置。R2-BGP-Router1234567891011121314151617181920212223242526272829R2#configure terminalR2(config)#router bgpR2(config-bgp)#local-as 35129 //设置本地AS号R2(config-bgp)#neighbor 10.0.254.2 remote-as 9527 //设置BGP对等体R2(config-bgp)#neighbor 10.0.254.2 soft-reconfiguration inbound //开启对等体流入路由软刷新R2(config-bgp)#neighbor 10.0.254.2 description CM-Access //添加该对等体的描述信息R2(config-bgp)#show ip bgp summary //检查BGP对等体之间的状态是否为EstablishedR2(config-bgp)#neighbor 10.0.254.2 shutdown //检查正常则先关闭TCP连接R2(config-bgp)#exitR2(config)#ip prefix-list Private_Deny seq 5 deny 0.0.0.0/8 le 32 //创建前缀列表R2(config)#ip prefix-list Private_Deny seq 10 deny 10.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 15 deny 172.16.0.0/12 le 32 R2(config)#ip prefix-list Private_Deny seq 20 deny 192.168.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 25 deny 127.0.0.0/8 le 32 R2(config)#ip prefix-list Private_Deny seq 30 deny 169.254.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 35 deny 192.0.2.0/24 le 32 R2(config)#ip prefix-list Private_Deny seq 40 deny 224.0.0.0/3 le 32 R2(config)#ip prefix-list Private_Deny seq 45 deny 172.160.0.0/16 le 32 R2(config)#ip prefix-list Private_Deny seq 50 permit 0.0.0.0/0 le 32R2(config)#router bgpR2(config-bgp)#neighbor 10.0.254.2 prefix-list Private_Deny in //拒绝私网地址等流入R2(config-bgp)#redistribute connected //重分布发直连路由R2(config-bgp)#redistribute static //重分布发静态路由R2(config-bgp)#default-information-origina //重分布发默认路由R2(config-bgp)#no neighbor 10.0.254.2 shutdown //打开BGP对等体之间的TCP连接R2(config-bgp)#show ip bgp routes //查看从BGP对等体获取到的路由信息R2(config-bgp)#exitR2(config)#exitR2#write-memory //保存配置 CM-Access和BGP-Router之间的EBGP建立好后，相互之间会自动学习路由，其他运营商对接的情况也可以这样来做。按照这样的思路做好之后，是否就完事了呢？这个得从需求上看，其实主要分两种情况： BGP-Router和ISP-Access包含单线、多线及BGP功能 BGP-Router和ISP-Access只用作BGP线路 一般而言，对于第二种情况，上述的做法已经完事了，但对于一家企业而言，设备的可利用性可能是越高越好的，这样对应的成本就越低（领导：节约成本啊，我可都是血汗钱，23333）。所以，如何去将单线、多线及BGP功能全部承载在这个架构中呢？答案是使用VRF，利用VRF来建立BGP线路的EBGP连接，这样对于BGP业务就可以在单个VRF内实现了，而其他的业务也在不同的VRF内实现即可。另外，而对于各个ISP-Access设备，CT-Access向EBGP内重分布默认路由，其他ISP-Access向EBGP重分布明细静态路由，CT-Access需要拒绝（使用ip-prefix list完成即可）从BGP-Router学习到的CM明细路由和CU明细路由等，否则就会影响单线及多线业务的默认出局。同时，为了保证单、多线业务，其他ISP-Access也都需要写入默认路由，但不能重分布到EBGP内，避免造成环路和路由错乱。 Summary按照这样的架构实现的Static BGP结构比较简单，不需要Traffic-Policy等之类的技术来配合实现，控制起来也比较简单，直接放静态路由就好，至于从BGP-Router到BGP-Access之间的稳定性，这个也可以用Static with BFD的方式来实现，或者纯依靠底层传输网的健壮性。不过有个问题在于，这样做好之后，BGP-Router就只能用作BGP地址的出口网关路由器了，当然根据设备的功能特性，强行要使用某某功能，依然可以用VRF等实现，但这样就会使得设备的功能变得繁杂，在操作的时，误操作或其他BUG就会影响到整个BGP网络架构的稳定性。另外，这个架构的优点其实很直观，就是简单，易于排障（网络架构在不失健壮性的基础下，越简单越好，真理啊😭），并且不同运营商的路由表易于维护。缺点就是，对底层传输网的稳定性要求比较高。但是，如果是跨区域的BGP业务的话，又会面临新的问题：难道每个地方都搞一台BGP核心路由器吗？那在内网里，这些地址又如何互相访问呢？]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFD基础配置方法]]></title>
    <url>%2F2019%2F03%2F29%2FBFD%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroBFD常用于多线静态路由的检测和自动切换，在没有使用其他动态协议的情况下，若网络出现故障，可以使用BFD达到故障线路和正常线路的路由切换效果。当然，BFD依然可以和其他协议配合使用（MPLS也可以），这里只介绍BFD和静态路由的配合使用，在不同的应用场景内把握好BFD本身的作用机制，从而达到使用者想要达到的效果即可。另外，一般的动态协议收敛速度比较慢，为秒级，BFD可以将收敛时间降低到毫秒级。 BFD Brief Description一般而言，BFD需要设置的参数不多，大致包含：source ip、destination ip、multiplier、min_rx、interval，各个参数只要设置好了，设备之间的BFD连接都配置OK，那么BFD连接就可以UP了。不同设备可能对这些名词的叫法不一致，但是差不多都是这些“词”。 Source IPBFD的源IP，本端设备设置本端IP即可。 Destination IPBFD的目的IP，本端设备设置对端IP即可。 Multiplier允许BFD连接报文失效的最大个数，例如设置为5，那么用于这个BFD连接的Control packet一旦失效超过5个，这条BFD路径连接就会down，类似ping测试丢包超过5个。 Min_rxBFD检测报文的接收周期。 intervalBFD检测报文的发送周期。 TipsBFD检测的时间周期设置，是一个很有意思的东西。假设总体性能的指标是要求链路检测上的时间不要超过150ms，这样可以设置BFD的hello报文周期为50ms，连续丢失3个报文即认为链路失效。如果换个思路，我们设置BFD的hello报文周期为30ms，连续丢失5个报文即认为链路失效，这样准确度会更高些且依然可以达到指标。但是需要路由器支持设置30ms这个时间。 BFD Connectiong下面开始配置。注：R1为博科设备，R2为华为设备 Basic Connection底层互联采用静态的方式，直接给出R1和R2互联的三层接口配置。R11234!interface ve 925 ip address 10.0.254.1/30! R21234#interface Vlanif925 ip address 10.0.254.2 255.255.255.252# BFD Config接下来开始配置BFD。R1123456R1#configure terminalR1(config)#interface ve 925R1(config-vif-ve-925)#bfd interval 500 min-rx 500 multiplier 5 //设置参数R1(config-vif-ve-925)#exitR1(config)#ip route static-bfd 10.0.254.2 10.0.254.1 //开启bfdR1(config)#ip route 192.168.1.0/24 10.0.254.2 bfd //为静态路由绑定bfd R21234567&lt;R2&gt;system-view[R2]bfd to-r1 bind peer-ip 10.0.254.1 interface vlanif925 source-ip 10.0.254.1 auto //设置bfd[R2-bfd-session-to-r1]detect-multiplier 5 //设置参数[R2-bfd-session-to-r1]min-tx-interval 500[R2-bfd-session-to-r1]min-rx-interval 500[R2-bfd-session-to-r1]quit[R2]ip route-static 192.168.2.0 24 10.0.254.1 track bfd-session to-r1 //为静态路由绑定bfd 配置好了之后，BFD就正式启动了，并且此时R1访问192.168.1.0/24网段的路由是与R1和R2之间的BFD绑定在一起的，R2访问192.168.2.0/24网段的路由也是与R1和R2之间的BFD绑定在一起的。 ManagementR1可以使用show bfd neighbors命令来检查BFD连接是否正常；R2可以使用display bfd session all来检查BFD连接是否正常；当然了，不同设备还有很多其他的简捷命令来方便管理。配合使用需要查设备的手册，但是需要设置的参数是一样的，这就很NICE了。所以，不管动态协议是啥，使用BFD实现的功能是与其他不相关的。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MPLS基础配置方法]]></title>
    <url>%2F2019%2F03%2F27%2FMPLS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroMPLS，Multi-Protocol Label Switching，全称多协议标记交换，是一种标记机制的包交换技术，通过简单的2层交换来集成IP Routing的控制。MPLS究竟是不是路由协议，究竟工作在第几层，在这里，不做探讨，以下内容只介绍其基础的配置，并衔接ISIS基础配置这篇文章。 以下配置命还是以博科设备为例 Network Information贴出R1和R2的部分配置信息协助构建ISIS + MPLS。R1123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.10/30!interface ve 922 ip router isis ip address 10.0.254.14/30!!interface loopback 1 ip router isis ip address 169.254.254.1/32!ip router-id 169.254.254.1!router isis net 49.0001.0000.0000.1000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! R2123456789101112131415161718192021222324252627!interface ve 921 ip router isis ip address 10.0.254.9/30!interface ve 922 ip router isis ip address 10.0.254.13/30!!interface loopback 1 ip router isis ip address 169.254.254.2/32!ip router-id 169.254.254.2!router isis net 49.0002.0000.0000.2000.00 log adjacency log invalid-lsp-packets address-family ipv4 unicast maximum-paths 8 exit-address-family address-family ipv6 unicast exit-address-family! MPLS Brief Description简要说明一下MPLS中的某些组成部分，其余的部分不在赘述了😴。 Network Components就像BGP对等体一样，MPLS内也包含一些概念，依次如下： P网络：提供商网络P路由器：部署MPLS/IP网络环境的路由器PE路由器：提供商网络的边界路由器，提供VPN终端客户连接和服务CE路由器：客户的路由器，用做客户网络和提供商网络之间的网关C网络：客户的网络 MPLS-Interface用于建立path的三层接口，注意，是三层接口。 LSPLSP, Label Switched Path，标签交换路径，即到达同一目的地址的报文在MPLS网络中经过的路径。这玩意，就是流量的“方向”了。 LDPLDP, Label Distribution Protocol，标签分发协议，这玩意是路由器在构建MPLS标签转发表时遵守的规则，MPLS的标签转发表的建立就是靠这玩意。 VPLSVPLS，Virtual Private Lan Service，这玩意其实并只是MPLS所有的东西，按照不同的信令协议，也有不同的应用方法（BGP-l2vpn），这里所介绍的VPLS本质上是基于IP/MPLS的L2VPN技术（其实是现在用的最多的也就是MPLS下的VPLS了😂）。不过，这玩意还有个更加通俗的理解方式，那就是运营商给客户的“业务网”。 MPLS Config想要MPLS能正常使用，需要做的路由器配置其实并不是很多，大体上就包括：mpls-interface、path和lsp这些。以下的配置步骤可作为参考：R11234567891011121314151617181920212223242526272829R1#configure terminalR1(config)#router mpls //启用mplsR1(config-mpls)#ldp //进入ldp协议R1(config-mpls-ldp)#load-sharing 8 //设置lsp的能支持的最大路径条数为8R1(config-mpls-ldp)#exitR1(config-mpls)#path To-R2-1 //创建pathR1(config-mpls-path-To-R2-1)#strict 10.0.254.9 //指定这条路径的下一个节点是10.0.254.9R1(config-mpls-path-To-R2-1)#exitR1(config-mpls)#path To-R2-2R1(config-mpls-path-To-R2-2)#strict 10.0.254.13R1(config-mpls-path-To-R2-2)#exitR1(config-mpls)#mpls-interface ve921 //将ve 921这个三层接口启用到mpls中R1(config-mpls-if-ve-921)#ldp-enable //开启此接口ldp功能R1(config-mpls-if-ve-921)#exitR1(config-mpls)#mpls-interface ve922R1(config-mpls-if-ve-922)#ldp-enableR1(config-mpls-if-ve-922)#exitR1(config-mpls)#lsp To-R2-1 //创建标签转发路径R1(config-mpls-lsp-To-R2-1)#to 169.254.254.2 //设置标签转发路径的出口路由器地址R1(config-mpls-lsp-To-R2-1)#primary-path To-R2-1 //设置主路径R1(config-mpls-lsp-To-R2-1)#secondary-path To-R2-2R1(config-mpls-lsp-To-R2-1)#enableR1(config-mpls-lsp-To-R2-1)#lsp To-R2-2R1(config-mpls-lsp-To-R2-2)#to 169.254.254.2R1(config-mpls-lsp-To-R2-2)#primary-path To-R2-2R1(config-mpls-lsp-To-R2-2)#secondary-path To-R2-1R1(config-mpls-lsp-To-R2-2)#enableR1(config-mpls-lsp-To-R2-2)#exitR1(config-mpls)#write memory R21234567891011121314151617181920R2#configure terminalR2(config)#router mplsR2(config-mpls)#path To-R1-1R2(config-mpls-path-To-R1-1)#strict 10.0.254.10R2(config-mpls-path-To-R1-1)#path To-R1-2R2(config-mpls-path-To-R1-2)#strict 10.0.254.14R2(config-mpls-path-To-R1-2)#exitR2(config-mpls)#lsp To-R1-1R2(config-mpls-lsp-To-R1-1)#to 169.254.254.1R2(config-mpls-lsp-To-R1-1)#primary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-1)#enableR2(config-mpls-lsp-To-R1-1)#lsp To-R1-2R2(config-mpls-lsp-To-R1-2)#to 169.254.254.1R2(config-mpls-lsp-To-R1-2)#primary-path To-R1-2R2(config-mpls-lsp-To-R1-2)#secondary-path To-R1-1R2(config-mpls-lsp-To-R1-2)#enableR2(config-mpls-lsp-To-R1-2)#exitR2(config-mpls)#exitR2(config)#write memory 上面贴出的是完整的配置过程，但是实际上两台设备的配置顺序是人为自定的，不过需要说明的是，一旦创建了path，使用show mpls routes命令时，就可以看到mpls的标签转发表了。其次，创建lsp时可以不指定primary-path和secondary-path，此时lsp会默认使用mpls内存在且up的path（已连接的路径），并且lsp一旦创建后设备会自动生成一个tunnel用于传输数据，这个可以不用管；之所以创建primary-path和secondary-path，实质上是为了手动调度流量比较方便。另外，在修改lsp时，必须要先disable这条lsp（先关闭这条路径）才可以进行修改（博科的设备是这样）。还有，使用router-id来作为出口PE路由器的地址，十分方便。当然了，不同厂商设所支持的MPLS扩展功能可能不一样的（厂商特色，23333），但是基本上都是一样的。 VPLSMPLS网络构建好了之后，创建VPLS就很简单啦。可以按照下面的脚本进行执行。R112345678910R1#configure terminalR1(config)#router mpls //进入mpls协议R1(config)#vpls Test911 911 //创建vplsR1(config-mpls-vpls-Test911)#vpls-peer 169.254.254.2 load-balance //添加vpls peerR1(config-mpls-vpls-Test911)#vlan 911 //创建vpls vlanR1(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/x //透传到汇聚端口R1(config-mpls-vpls-Test911-vlan-911)#exitR1(config-mpls-vpls-Test911)#exitR1(config-mpls)#exitR1(config)#write memory //保存配置 R212345678910R2#configure terminalR2(config)#router mplsR2(config)#vpls Test911 911R2(config-mpls-vpls-Test911)#vpls-peer 169.254.254.1R2(config-mpls-vpls-Test911)#vlan 911R2(config-mpls-vpls-Test911-vlan-911)#tagged ethernet x/xR2(config-mpls-vpls-Test911-vlan-911)#exitR2(config-mpls-vpls-Test911)#exitR2(config-mpls)#exitR2(config)#write memory 创建好了之后，可以使用show mpls vpls来查看vpls peer是否up，如果up，则创建成功，反之，则不成功，需要检查配置。 Summary总的来说，MPLS和VPLS的创建还是十分简单的，难点在于，骨干网节点过多的网络环境中，实现MPLS的流量调度工程，做这个事情一定要思路清晰才行。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ISIS基础配置方法]]></title>
    <url>%2F2019%2F03%2F27%2FISIS%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroISIS也是IGP路由协议族中一员，与OSPF十分类似，OSPF主要用于园区网，ISIS主要用于骨干网。注：本文内所有命令，均已博科设备(与Cisco类似)为例。 ISIS Brief Description简短说明一下，ISIS中的一些需要注意的地方，可能不清晰和完全，欢迎一起交流。 ISIS NET提示：这部分内容不要深究🤣，不知道为啥会这么冗杂，可能是因为ISIS是为OSI设计的，而OSI用的是NSAP格式的地址吧，XD，建议点开链接结合图片一起看。 ISIS的NET(网络实体名)采用的格式一种叫做NSAP的“格式”(Network Service Access Point)，其形式有点像IP地址加端口号的形式，如:169.254.254.1:80，以NET为49.0001.0000.0000.0001.00为例，49.0001是Area ID，长度可变；0000.0000.0001是System ID，长度不变；00是N-SEL，长度不变，这个类似于TCP/IP中的端口。 如果换一种标识的方法，那么49就是IDP，用AFI和IDI来标识；0001就是Area，System ID和N-SEL不变，此时，Area、System ID和N-SEL合称为DSP。 注：对于同一台路由器而言，在有多个ISIS Area连接的情况下，Area ID不同，但是System ID必须相同对于不同路由器而言，System ID一定不能相同不同路由器的domain要相同，这样ISIS才可以互联常用的NET设置为：49.0001.0000.0000.1000.00，这个算是最短且符合要求的长度了 ISIS RoutingISIS的路由获取方式与OSPF是十分类似的，包含IP地址的发布、静态路由的导入、路由的重分配等等，但ISIS的路由是拥有Level（路由等级）这个属性的，一般而言，工业上使用的设备都是是支持Level 1/2（路由等级为1或2）的路由，但这个实际上是可以设置的（设备可以设置对特定等级路由不加表）。另外，骨干网上使用的ISIS其实只参与了不同机房的核心路由器之间的互联，并没有通过ISIS跨机房传递本地的IP路由信息，而这部分功能是通过MPLS来完成的，当然MPLS的构建也可以和其他的动态路由协议配合完成。不同等级的路由特性如下：Level 1Level 2只能允许在一个area内路由允许在一个domain内路由，只含Level 1的路由器若要到达另外一个area，需要转发到离它“最近”的含Level 2路由的路由器。下面介绍的内容是利用ISIS来构建骨干网的实践场景。 Basic Connetion与OSPF的配置类似，ISIS的配置依然需要先在两台设备上配置好静态互联IP。本次实验采用vlan 921和vlan 922来作为两台设备的互联vlan，使用10.0.254.8/30和10.0.254.12/30作为两对互联IP(两条线路)。配置好后的部分配置如下：R21234567!interface ve 921 ip address 10.0.254.9/30!interface ve 922 ip address 10.0.254.13/30! R11234567!interface ve 921 ip address 10.0.254.10/30!interface ve 922 ip address 10.0.254.14/30! 设备之间的vlan透传，自己去传吧，注意别成环了就行。配置好了之后，测试一下。R2#12ping 10.0.254.10 source 10.0.254.9ping 10.0.254.13 source 10.0.254.14 R1#12ping 10.0.254.9 source 10.0.254.10ping 10.0.254.13 source 10.0.254.14 ISIS Config下面介绍ISIS相关的配置，不同厂商的命令和开启方式可能不一样，但大部分功能是一致的。按照以下的脚本来配置即可：R112345678910111213141516R1#configure terminalR1(config)#router isis //进入isis协议，进入后，会提示先设置netR1(config-isis-router)#net 49.0001.0000.0000.1000.00 //设置netR1(config-isis-router-ipv4u)#address-family ipv4 unicast //开启isis的ipv4单播功能R1(config-isis-router-ipv4u)#maximum-paths 8 //设置最大路径，不同设备不一致R1(config-isis-router-ipv4u)#exit //退出R1(config)#ip router-id 169.254.254.1 //设置router-idR1(config)#interface loopback 1 //进入环回接口R1(config-lbif-1)#ip address 169.254.254.1/32 //设置环回接口IP为router-idR1(config-lbif-1)#ip router isis //开启isis功能R1(config-lbif-1)#interface ve 921 //进入三层虚拟接口R1(config-vif-921)#ip router isisR1(config-vif-921)#interface ve 922R1(config-vif-922)#ip router isisR1(config-vif-922)#exitR1(config)#write memory R2路由器的配置过程与R1是相似的，但是需要注意的是，R2的net将设置为49.0002.0000.0000.2000.00，router-id将设置为169.254.254.2，对应的环回地址接口的IP设置为169.254.254.2/32。设置好后执行命令show isis routes来检查ISIS是否正常学习路由。R1/R212R1#show isis routesR2#show isis routes 按照之前的配置思路，此时可以在R2中看到以下路由信息：R112345678910111213Total number of IS-IS routes: 3Destination Mask Cost Type Tag Flags10.0.254.8 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 10.0.254.12 255.255.255.252 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 169.254.254.1 255.255.255.255 20 L2 00000000 00000008 000 Path: 1 Next Hop IP: 10.0.254.10 Interface: v921 Path: 2 Next Hop IP: 10.0.254.14 Interface: v922 对应的R1也会有类似的路由信息，这里不在赘述了。 Summary到这里，R1和R2之间的ISIS互联就建立好了，也就是说骨干网现在已经建立好了，现在就可以在ISIS之上在来构建其他的网络配置了。整个过程，与OSPF的基础构建过程很类似，大部分动态路由协议都支持用密钥的方式来允许建立连接，ISIS也不例外的，但需要设备支持且通信双方都已知密钥，当然，BFD依然可以用在ISIS中（合理结合使用会使得ISIS的路由收敛速度更快），但这需要设备支持，并且要查阅设备手册，找到其具体配置方法。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Routing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Brocade VDX VCS配置方法]]></title>
    <url>%2F2019%2F03%2F19%2FBrocade-VDX-VCS%E9%85%8D%E7%BD%AE%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[IntroductionVCS全称叫做VCS矩阵部署模式，是将多台VDX系列任意型号的物理交换机设备通过万兆或者40G任意拓扑互联形成一个矩阵，进行统一配置、管理、监控(套话)。注意： 只能用10G或者40G链路实现，也就是说只能用物理接口（port-channgel可以试试）去实现，但是好在可以使用多条10G链路，且流量是负载均衡的。 所有物理交换机的软件(就是系统版本)必须一致 需手动设定VCS集群的IP号码，集群唯一的编号，从1-8192 需手动设定VCS集群内部物理交换机rbridge-id编号，，该编号唯一，从1-239 部署完VCS配置后会清空物理交换机内部已有的配置 Configuration下面介绍大致配置。 Physical Interface物理接口的配置基本都是一致的，所以以一个端口为例即可。1234567#interface TenGigabitEthernet 1/0/1 des xxxx //描述信息 fabric isl enable //设置称为VCS的fabric isl port fabric trunk enable //设置端口的模式为trunk no shutdown //开启端口# 若不想设置此接口为VCS矩阵互联的ISL接口，需要配置以下命令在接口上：12fabric neighbor-discovery disableno fabric isl enable 检查互联端口正常之后，即可以开始下一步操作。 Set VCS Cluster Number利用console口进入到每台VDX后，执行命令：vcs vcsid X rbridge-id Y logical-chassis enableX代表VCS集群ID编号，是整个集群内部唯一的编号；Y代表VCS集群内部每一台VDX交换机的编号，也就是rbridge-id，用于标识集群内部每一台VDX交换机，同时也是作为接口编号的第一位，比如TenGigabitEthernet 1/0/1中的1就是rbridge-id 1，后面的1就是第一个端口。 注意，一旦执行这条命令，待VDX自动重启后，所有在VCS集群内的VDX就在逻辑上成为一台了；理论上而言，我们只需要操作一台就可以完成对所有设备的配置了，此时，VCS的模式是Logical Chassis。VDX的VCS模式是Fabric Cluster，所以我们只需设置vcs vcsid X rbridge-id Y就好。 若选择使用Logical Chassis模式，默认情况下是，机器重启后，先启动完成的机器为管理员，若想指定某台机器，则执行命令：logical-chassis principal-priority 1其中，1是rbridge-id。VCS集群内部的principal切换命令：logical-chassis principal switchover Management And SummaryVCS矩阵集群常用的检查命令：1234567show vcs detailshow fabric allshow fabric islshow fabric islports rbridge-id 1/2/3...show fabric trunkreload rbridge-id 1/2/3... #重启rbridge-id为1/2/3...的某个交换机vcs replace rbridge-id x #需要更换和替换rbridge-id时，可以先替换掉，需要系统支持 默认情况下，在VCS创建之后，用户管理员操作任何配置都不需要执行保存的动作，因为系统会自动保存。]]></content>
      <categories>
        <category>CS</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Switching</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PAT (Basic Level) Practice]]></title>
    <url>%2F2019%2F03%2F14%2FPAT-Basic-Level-Practice%2F</url>
    <content type="text"><![CDATA[IntroPTA基础编程题目集好歹算是写完了，买了紫书，多多少少算是休息了三四天吧，现在也该重新开始新的旅程(受虐😤)了。PTA基础编程题目集因为按照PTA网站的格式，在Blog中给出了题目的内容、输入输出样例、要求等信息，嗯，写的十分详细(水文)，洋洋洒洒的好几万字呢(凑字数)，哈哈。说到底是自己整理的累，别人看的也累。所以，在本篇Blog中就不在给出其他信息了，只给出代码和分析吧。题目信息，请点击：PAT (Basic Level) Practice。不过，想来各位看官应该也只有在看到题目摸头、挠头的时候，才会来看这里的内容吧，这也就更加没有显示题目信息的必要了。嗯，就按照这样的想法来做吧。 话说，在Basic Level内好像只有编程题哦。 1001 害死人不偿命的(3n+1)猜想Analysis题目比较简单，按照题目给出的算法去构造计算过程即可，count++其实只在最后写一句就可以了。 Code12345678910111213#include &lt;iostream&gt;using namespace std;int main() &#123; int n, count = 0; cin &gt;&gt; n; while(n != 1) &#123; if(n % 2 == 1) n = 3 * n + 1; n /= 2; count++; &#125; cout &lt;&lt; count; return 0;&#125; 1002 写出这个数Analysis这个题目20分呢，不过不难，嘻嘻，就是比较麻烦，看着题目中的话：这里保证$n$小于$10^{100}$，好像看到了出题人“善意”的微笑一样呢(wo zhen xiang da si ni~)。大致思路，先要算出每个数位上数字的总和，然后再将结果进行数位拆分输出一位一位的数字就好了。对于输入的数字串，可以用单字符的形式来处理，也可以从字符串的角度去处理，另外注意做数位拆分时的个位数，注意0的拼音是ling不是lin。 继续分析一下题目条件，“保证$n$小于$10^{100}$这个条件好像还有点猫腻？小于$10^{100}$那能取到的最大的数不就是$10^{100} - 1$了，且这个数的每一位都是9，总共100位，也就是说，最后得到的各位数字之和肯定不会大于$9 \times 100 = 900$，最多也不会超过三位数了，这是个好消息！明确了这点后，数位拆分的过程就简单了；另外，需要输出的字符串，可以单独放在二维数组内，利用能到的数位代替下标，来输出就很方便了！ Code按照上述的两种思路得到的 AC 分别代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; char c; int num, sum=0; while((c=getchar()) != '\n') &#123; if('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; num = c - '0'; sum+=num; &#125;else continue; &#125; /* method 1: int digit, temp=sum, mask=1; while(temp &gt; 9) &#123; temp/=10; mask*=10; &#125; temp=sum; do &#123; digit=temp/mask; temp%=mask; mask/=10; switch(digit) &#123; case 0:printf("ling");break; case 1:printf("yi");break; case 2:printf("er");break; case 3:printf("san");break; case 4:printf("si");break; case 5:printf("wu");break; case 6:printf("liu");break; case 7:printf("qi");break; case 8:printf("ba");break; case 9:printf("jiu");break; &#125; if(mask == 0) printf("\n"); else printf(" "); &#125; while(mask &gt; 0); */ /*method 2:*/ char num2chinese[][6] = &#123;"ling", "yi", "er", "san", "si", "wu", "liu", "qi", "ba", "jiu"&#125;; int unit, tens, hundred; unit = sum%10; tens = sum/10%10; hundred=sum/100; if(sum &gt; 100) &#123; printf("%s %s %s\n", num2chinese[hundred], num2chinese[tens], num2chinese[unit]); &#125; else if(10 &lt; sum &amp;&amp; sum &lt; 100) &#123; printf("%s %s\n", num2chinese[tens], num2chinese[unit]); &#125; else &#123; printf("%s\n", num2chinese[unit]); &#125; return 0;&#125; 1003 我要通过！AnalysisCode123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;cstdio&gt;#include &lt;cstring&gt;int select_str(char s[], int length); int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); char str[105]; while(n--) &#123; scanf("%s", str); int left, mid, right; left = mid = right = 0; int i, cnt, len = strlen(str); //calculate the number of 'A' in different area. for(i=0; i&lt;len; i++) &#123; if(str[i] != 'P') left++; else break; &#125; for(i=0, cnt=0; i&lt;len; i++) &#123; if(str[i] != 'T') cnt++; else &#123; mid = cnt - left - 1; //subtract the number of 'P' right = len - cnt - 1; //subtract the number of 'T' break; &#125; &#125;// printf("left=%d, mid=%d, right=%d\n", left, mid, right); //output the number of 'A' in different area. if(select_str(str, len)) &#123; if(!mid) printf("NO\n"); else &#123; if(left * mid == right) &#123; printf("YES\n"); &#125; else &#123; printf("NO\n"); &#125; &#125; &#125; else &#123; printf("NO\n"); &#125; &#125; return 0;&#125;int select_str(char s[], int length) &#123; //when the string has other chars dislike 'P' or 'A' or 'T', the string is wrong. int i, flag=1; for(i=0; i&lt;length; i++) &#123; if(s[i] != 'P' &amp;&amp; s[i] != 'A' &amp;&amp; s[i] != 'T')&#123; flag=0; break; &#125; &#125; return flag;&#125; 1004 成绩排名Analysis这道题比较简单，算是查找吧，定义好结构体进行处理就好，注意最大、最小值得分开判断，而不是只用if-else就完事大吉。 Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;typedef struct Stu &#123; char name[12]; char number[12]; int grade;&#125; students;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); int i=0; students stu, max, min; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); max = min = stu; for(i=1; i&lt;n; i++) &#123; scanf("%s %s %d", stu.name, stu.number, &amp;stu.grade); /*online processing, find the minimum and maximum when inputing. */ if(stu.grade &lt; min.grade) min = stu; if(stu.grade &gt; max.grade) max = stu; &#125; printf("%s %s\n%s %s\n", max.name, max.number, min.name, min.number); return 0;&#125; 1005 继续(3n+1)猜想Analysis按照1001的思路，对输入的每个数进行模拟，开辟一个bool数组来记录某个数字是否出现，出现则将下标为其值的bool量置为true，由于每个数在模拟中可能会出现不同的数字，最好还是每个数字都模拟一下。另外，由于最后需要从小到大输出，所以将输入数字序列按从大到小排序后，在进行输出。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 10000 + 10;int main(int argc, char const *argv[]) &#123; int K, Num[105] = &#123;0&#125;, temp; bool times[MAXN] = &#123;false&#125;; scanf("%d", &amp;K); for(int i = 0; i &lt; K; i++) &#123; scanf("%d", &amp;Num[i]); temp = Num[i]; while(temp != 1) &#123; if(temp % 2 == 1) &#123; temp = 3 * temp + 1; &#125; temp /= 2; times[temp] = true; &#125; &#125; sort(Num, Num + K); bool flag = true; for(int i = K - 1; i &gt;= 0; i--) &#123; if(!times[Num[i]]) &#123; if(flag) &#123; printf("%d", Num[i]); flag = false; &#125; else &#123; printf(" %d", Num[i]); &#125; &#125; &#125; return 0;&#125; 1006 换个格式输出整数Analysis水题一道，题目已经说了给一个不超过3位的正整数，做好数位拆分后，挨个输出即可。 Code1234567891011121314151617181920#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, num, unit, tens, hundred; scanf("%d", &amp;num); unit = num % 10; tens = num / 10 % 10; hundred = num / 100; for(i=0; i&lt;hundred; i++) &#123; printf("B"); &#125; for(i=0; i&lt;tens; i++) &#123; printf("S"); &#125; for(i=1; i&lt;=unit; i++) &#123; printf("%d", i); &#125; printf("\n"); return 0;&#125; 1007 素数对猜想Analysis这道题要稍微理解一下题目意思，乍一看，可能会没明白题目的意思。关键的条件：存在无穷多对相邻且差为2的素数，也即是说，对于题目给定的$N = 20$而言，在$2 - 20$之间，必然存在相邻且差为2的素数对！而题目的问题是：计算不超过$N$的满足猜想的素数对的个数，那么直接进行计算就好了。至于，判断素数的函数则是老生常谈的问题了，方法很多。 Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;#include &lt;math.h&gt;typedef enum&#123; false, true&#125; bool;bool IsPrime(int n);int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d", &amp;N); for(i = 2; i &lt;= N - 2; i++) &#123; if(IsPrime(i) &amp;&amp; IsPrime(i + 2)) &#123; count++; &#125; &#125; printf("%d\n", count); return 0;&#125;bool IsPrime(int n) &#123; bool flag = true; if(n &lt;= 1 || n % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(n); i+=2) &#123; if(n % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 1008 数组元素循环右移问题Analysis本题的解答方法较多，首先需要对移动次数$M$进行处理，分别对应两种情况，$M &gt;= N$和$M &lt; N$，使用取余运算即可。下面介绍一下各种方法： 不移动，先输出指定位置，再输出余下位置即可 利用队列，移动的过程正好对应队列出一次队，再入一次队 采用移位算法，大致过程（以样例为例）： 12345n = 6, m = 2, move 3 turns-&gt; 1 2 3 4 5 6, firstly swap a[0] and a[3], then swap a[1] and a[2] -&gt; 4 3 2 1 5 6, swap a[4] and a[5]-&gt; 4 3 2 1 6 5, fristly swap a[0] and a[5], then swap a[1] and a[4]-&gt; 5 6 1 2 3 4 移位算法的大致代码： 1234567void reverse(int *array, int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = array[i]; array[i] = array[start + end - i]; array[start + end - i] = temp; &#125;&#125; Codedirect output12345678910111213141516171819#include &lt;iostream&gt;using namespace std;const int maxn = 110;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; for(int i = n - m; i &lt; n; i++) &#123; cout &lt;&lt; a[i] &lt;&lt; ' '; &#125; for(int i = 0; i &lt; n - m; i++) &#123; cout &lt;&lt; a[i]; if(i != n - m - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; use queue12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main() &#123; queue&lt;int&gt; q; int n, m, temp; cin &gt;&gt; n &gt;&gt; m; m %= n; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; q.push(temp); &#125; for(int i = 0; i &lt; n - m; i++) &#123; temp = q.front(); q.pop(); q.push(temp); &#125; while(!q.empty()) &#123; cout &lt;&lt; q.front(); q.pop(); if(q.size() != 0) cout &lt;&lt; ' '; &#125; return 0;&#125; shift algorithm1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int maxn = 110;void Reverse(int a[], int start, int end) &#123; for(int i = start; i &lt;= (start + end) / 2; i++) &#123; int temp = a[i]; a[i] = a[end + start - i]; a[end + start - i] = temp; &#125;&#125;int main() &#123; int n, m, a[maxn]; cin &gt;&gt; n &gt;&gt; m; for(int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; a[i]; &#125; m %= n; Reverse(a, 0, n - m - 1); Reverse(a, n - m, n - 1); Reverse(a, 0, n - 1); for(int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; a[i]; if(i != n - 1) cout &lt;&lt; ' '; &#125; return 0;&#125; 1009 说反话Analysis这个题如果单纯的处理字符串的话，会比较麻烦。不过若是使用二维数组（字符串数组）就很简单了，利用的是scanf无法读入带空格的字符串的特性。 Code123456789101112131415161718#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int count = 0; char Str[85][85], c; while(1) &#123; scanf("%s", Str[++count]); c = getchar(); if(c == '\n') &#123; break; &#125; &#125; for(; count &gt; 1; count--) &#123; printf("%s ", Str[count]); &#125; puts(Str[count]); return 0;&#125; 1010 一元多项式求导Analys题目大意较为明确，但感觉有些东西没说明白...注意的地方大致如下： 因为没说输入什么时候结束，所以只能手动使用 Windows 下的Ctrl + Z来结束输入，判题系统建在 Linux 上，应该自动使用的Ctrl + D，这两个操作都表示EOF，所以得使用!= EOF来作为输入结束的标志 常数项求导后为0，需要输出为0 0，这应该是题目最后一个条件的提示了 可能出现指数为负的项，输出顺序是指数递降的，这里用链表就很无脑，因为输入绝对是指数递降的，那么求导完后，也绝对是指数递降的，直接输出即可 这道题也可以用链表来做，求导的过程会复杂一些。 Codeuse linked list1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct node* List;typedef struct node&#123; int coef, expo; List next;&#125; Node;List CreateList(void);void Derivation(List L);void Print(List L);int main(int argc, char const *argv[]) &#123; List L = CreateList(); Derivation(L); Print(L); return 0;&#125; List CreateList(void) &#123; List L = (List)malloc(sizeof(Node)), rear; L-&gt;next = NULL; rear = L; int c, e; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; List temp_node = (List)malloc(sizeof(Node)); temp_node-&gt;next = NULL; rear-&gt;next = temp_node; rear = temp_node; temp_node-&gt;coef = c; temp_node-&gt;expo = e; &#125; return L;&#125;void Print(List L) &#123; List Temp = L-&gt;next; int flag = 1; while(Temp) &#123; if(flag) &#123; printf("%d %d", Temp-&gt;coef, Temp-&gt;expo); flag = 0; &#125; else &#123; if(Temp-&gt;coef != 0) &#123; printf(" %d %d", Temp-&gt;coef, Temp-&gt;expo); &#125; &#125; Temp = Temp-&gt;next; &#125; putchar('\n');&#125;void Derivation(List L) &#123; List p = L-&gt;next; while(p) &#123; if(p-&gt;expo) &#123; p-&gt;coef = p-&gt;coef * p-&gt;expo; p-&gt;expo--; &#125; else &#123; p-&gt;coef = 0; &#125; p = p-&gt;next; &#125;&#125; use array123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int i, items[1005] = &#123;0&#125;, c, e, count = 0; while(scanf("%d %d", &amp;c, &amp;e) != EOF) &#123; items[e] = c; &#125; items[0] = 0; for(i = 1; i &lt;= 1000; i++) &#123; items[i - 1] = items[i] * i; items[i] = 0; if(items[i - 1] != 0) &#123; count++; &#125; &#125; if(count == 0) printf("0 0\n"); else &#123; for(i = 1000; i &gt;= 0; i--) &#123; if(items[i]) &#123; printf("%d %d", items[i], i); count--; if(count != 0) &#123; putchar(' '); &#125; &#125; &#125; putchar('\n'); &#125; return 0;&#125; 1011 A+B和CAnalysis由于题目限定了输入数据范围为$[-2^{31}, 2^{31}]$，本题可以有两种解法： 直接使用long long，避免使用int带来的溢出 依旧使用int，但是需要做溢出处理，包括正溢出和负溢出两种情况 Codeuse long long1234567891011121314#include &lt;iostream&gt;using namespace std;int main() &#123; long long t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &gt; c) cout &lt;&lt; "true" &lt;&lt; endl; else cout &lt;&lt; "false" &lt;&lt; endl; &#125; return 0;&#125; use int1234567891011121314151617#include &lt;iostream&gt;using namespace std;int main() &#123; int t, a, b, c; cin &gt;&gt; t; for(int i = 1; i &lt;= t; i++) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cout &lt;&lt; "Case #" &lt;&lt; i &lt;&lt; ": "; if(a + b &lt; 0 &amp;&amp; a &gt; 0 &amp;&amp; b &gt; 0) cout &lt;&lt; "true"; //positive overflow else if(a + b &gt;= 0 &amp;&amp; a &lt; 0 &amp;&amp; b &lt; 0) cout &lt;&lt; "false"; //negative overflow else if(a + b &gt; c) cout &lt;&lt; "true"; //normal else cout &lt;&lt; "false"; cout &lt;&lt; endl; &#125; return 0;&#125; 1012 数字分类Analysis按照题目要求，依次求出所有数字，但在输出的时候要注意，A2的结果可能是 0 ，此时A2是存在的，要输出0，而不是N，类似的有$A_4$。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;int main() &#123; int n, temp, a[6] = &#123;0&#125;, sign = 1, count = 0, flag = 0; scanf("%d", &amp;n); while(n--) &#123; scanf("%d", &amp;temp); int remain = temp % 5; if(remain == 0 &amp;&amp; temp % 2 == 0) a[1] += temp; if(remain == 1) &#123; a[2] += sign * temp; sign = -sign; flag = 1; &#125; if(remain == 2) a[3]++; if(remain == 3) &#123; a[4] += temp; count++; &#125; if(remain == 4 &amp;&amp; temp &gt; a[5]) &#123; a[5] = temp; &#125; &#125; if(a[1]) printf("%d ", a[1]); else printf("N "); if(flag) printf("%d ", a[2]); else printf("N "); if(a[3]) printf("%d ", a[3]); else printf("N "); if(a[4]) printf("%.1lf ", (double)a[4] / count); else printf("N "); if(a[5]) printf("%d", a[5]); else printf("N"); return 0;&#125; 1013 数素数Analysis素数相关的题目好像已经是老生常谈的题型了，注意不要超时。 Code非筛法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;#include &lt;cmath&gt;#define MAX 15000bool IsPrime(int number);int main(int argc, char const *argv[]) &#123; int M, N, Prime[MAX]; scanf("%d %d", &amp;M, &amp;N); int i, count = 2; Prime[1] = 2; for(i = 3; i &lt;= 105000; i++) &#123; if( IsPrime(i) ) &#123; Prime[count++] = i; &#125; &#125; count = 0; for(; M &lt; N; M++) &#123; printf("%d", Prime[M]); count++; if(count % 10 == 0) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; printf("%d\n", Prime[M]); return 0;&#125; bool IsPrime(int number) &#123; bool flag = true; if(number &lt;= 1 || number % 2 == 0) &#123; flag = false; &#125; else &#123; int i; for(i = 3; i &lt;= (int)sqrt(number); i+=2) &#123; if(number % i == 0) &#123; flag = false; break; &#125; &#125; &#125; return flag;&#125; 筛法1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;const int MAXN = 1000001;int prime[MAXN], pNum = 0;bool p[MAXN] = &#123;false&#125;;void filterPrime(int n) &#123; for(int i = 2; i &lt; MAXN; i++) &#123; if(p[i] == false) &#123; prime[pNum++] = i; if(pNum &gt;= n) break; for(int j = i + i; j &lt; MAXN; j += i) &#123; p[j] = true; &#125; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; int m, n, count = 0; scanf("%d %d", &amp;m, &amp;n); filterPrime(n); for(int i = m; i &lt;= n; i++) &#123; printf("%d", prime[i - 1]); count++; if(count % 10 != 0 &amp;&amp; i &lt; n) putchar(' '); else putchar('\n'); &#125; return 0;&#125; 1014 福尔摩斯的约会Analysis这个题目的细节处理，真是...太太太麻烦啦~大致分析一下： 字符相同的时候才能判断是否输出 星期判断必须是大写字母，且必须属于 $[A, G]$ 这个范围内（测试点4），用取余不是更好么？ 时间单位需要用0来补全2位 特别要注意的就这些，其他的再仔细读读题目就OK了~ Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cctype&gt;char Week[7][5] = &#123; "MON", "TUE", "WED", "THU", "FRI", "SAT", "SUN",&#125;;int Hours[31] = &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9,0, 0, 0, 0, 0, 0, 0,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23&#125;;int main(int argc, char const *argv[]) &#123; char Str[5][65]; scanf("%s\n%s\n%s\n%s", Str[1], Str[2], Str[3], Str[4]); int i, len1 = strlen(Str[1]), len2 = strlen(Str[2]), flag = 0, j; for(i = 0; ; i++) &#123; if(!flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'G')) &#123; printf("%s ", Week[Str[1][i] - 'A']); flag = 1; continue; &#125; if(flag &amp;&amp; Str[1][i] == Str[2][i] &amp;&amp; \ (isdigit(Str[1][i]) || ('A' &lt;= Str[1][i] &amp;&amp; Str[1][i] &lt;= 'N')) ) &#123; printf("%02d:", Hours[Str[1][i] - '0']); break; &#125; &#125; len1 = strlen(Str[3]), len2 = strlen(Str[4]); for(j = 0; ; j++) &#123; if(Str[3][j] == Str[4][j] &amp;&amp; isalpha(Str[3][j])) &#123; printf("%02d\n", j); break; &#125; &#125; return 0;&#125; 1015 德才论Analysis这道题一开始做的时候还想了挺久的，而且还没想出来，下面来分析一下。 使用库函数sort来完成排序的基本操作就不说了，大概得注意两个点： 总分需要计算出来作为排序的依据，这个是题目明确说明的 题目给的考生种类很多，为了排序方便可以给这些考生分类，数字越大等级越低（或反之） 能注意到这两个点，题目基本就可以完成了。所以，以后在遇到类似的题目，就提前分好类吧。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100000 + 5;struct student&#123; int id, scoreD, scoreC, sumCD, flag;&#125; stu[MAXN];bool cmp(student a, student b);int N, L, H, M = 0;int main(int argc, char const *argv[]) &#123; scanf("%d %d %d", &amp;N, &amp;L, &amp;H); for(int i = 0; i &lt; N; i++) &#123; scanf("%d %d %d", &amp;stu[i].id, &amp;stu[i].scoreD, &amp;stu[i].scoreC); stu[i].sumCD = stu[i].scoreC + stu[i].scoreD; if(stu[i].scoreD &gt;= L &amp;&amp; stu[i].scoreC &gt;= L) &#123; M++; if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &gt;= H) &#123; stu[i].flag = 1; &#125; else if(stu[i].scoreD &gt;= H &amp;&amp; stu[i].scoreC &lt; H) &#123; stu[i].flag = 2; &#125; else if(stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &lt; H &amp;&amp; stu[i].scoreD &gt;= stu[i].scoreC) &#123; stu[i].flag = 3; &#125; else stu[i].flag = 4; &#125; else &#123; stu[i].flag = 5; &#125; &#125; sort(stu, stu + N, cmp); printf("%d\n", M); for(int i = 0; i &lt; M; i++) &#123; printf("%d %d %d\n", stu[i].id, stu[i].scoreD, stu[i].scoreC); &#125; return 0;&#125;bool cmp(student a, student b) &#123; if(a.flag != b.flag) return a.flag &lt; b.flag; else if(a.sumCD != b.sumCD) return a.sumCD &gt; b.sumCD; else if(a.scoreD != b.scoreD) return a.scoreD &gt; b.scoreD; else return a.id &lt; b.id;&#125; 1016 部分A+BAnalysis根据题目的要求进行计算即可，从字符串或者数字的角度都可以得到解决方法。 Codeuse string123456789101112131415161718#include &lt;iostream&gt;using namespace std;int getnum(char *str, char D) &#123; int ret = 0; char *p = str; for(; *p != '\0'; p++) &#123; //loop condition also can use str[i] != '\0' if(*p == D) &#123; ret = ret * 10 + (*p - '0'); &#125; &#125; return ret;&#125;int main() &#123; char A[12], B[12], a, b; scanf("%s %c %s %c", A, &amp;a, B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; use int12345678910111213141516#include &lt;iostream&gt;using namespace std;int getnum(int A, int a) &#123; int ret = 0; do&#123; if(A % 10 == a) ret = ret * 10 + a; A /= 10; &#125; while(A &gt; 0); return ret;&#125;int main() &#123; int A, B, a, b; scanf("%d %d %d %d", &amp;A, &amp;a, &amp;B, &amp;b); printf("%d", getnum(A, a) + getnum(B, b)); return 0;&#125; 1017 A除以BAnalysis此题考察大整数运算，其中A为大整数，B为int类型的整数，计算这两个数的商和余数。此类型的题目，需要使用数组来保存大整数，并用数组来模拟题目要求做的运算。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct bign&#123; int d[1005], len; bign() &#123; memset(d, 0, sizeof(d)); len = 0; &#125;&#125;;bign change(char *str) &#123; bign a; a.len = strlen(str); for(int i = 0; i &lt; a.len; i++) &#123; a.d[i] = str[a.len - i - 1] - '0'; &#125; return a;&#125;bign divide(bign a, int b, int &amp;r) &#123; bign c; c.len = a.len; for(int i = a.len - 1; i &gt;= 0; i--) &#123; r = r * 10 + a.d[i]; if(r &lt; b) c.d[i] = 0; else &#123; c.d[i] = r / b; r %= b; &#125; &#125; while(c.len - 1 &gt;= 1 &amp;&amp; c.d[c.len - 1] == 0) &#123; c.len--; &#125; return c;&#125;int main(int argc, char const *argv[]) &#123; char str[1005]; int b, r = 0; cin &gt;&gt; str &gt;&gt; b; bign a = change(str), c; c = divide(a, b, r); for(int i = c.len - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; c.d[i]; &#125; cout &lt;&lt; ' ' &lt;&lt; r ;; return 0;&#125; 1018 锤子剪刀布Analysis题目大意就是剪刀石头布的游戏规则，对应 9 种情况，进行模拟即可，注意输出赢的次数最多且字典序最小的解。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;using namespace std;char gesture(int *a) &#123; int index = 1; char ges = '\0'; for(int i = 1; i &lt;= 3; i++) &#123; if(a[i] &gt; a[index]) index = i; &#125; switch(index) &#123; case 1: ges = 'B'; break; case 2: ges = 'C'; break; case 3: ges = 'J'; break; &#125; return ges;&#125;int main() &#123; int n, tie = 0, win = 0, ar[4] = &#123;0&#125;, br[4] = &#123;0&#125;; cin &gt;&gt; n; char a, b; for(int i = 1; i &lt;= n; i++) &#123; cin &gt;&gt; a &gt;&gt; b; if(a == b) tie++; else if(a == 'C' &amp;&amp; b == 'J') &#123; win++; ar[2]++; &#125; else if(a == 'J' &amp;&amp; b == 'B') &#123; win++; ar[3]++; &#125; else if(a == 'B' &amp;&amp; b == 'C') &#123; win++; ar[1]++; &#125; else if(b == 'C' &amp;&amp; a == 'J') &#123; br[2]++; &#125; else if(b == 'J' &amp;&amp; a == 'B') &#123; br[3]++; &#125; else if(b == 'B' &amp;&amp; a == 'C') &#123; br[1]++; &#125; &#125; cout &lt;&lt; win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; n - tie - win &lt;&lt; endl; cout &lt;&lt; n - tie - win &lt;&lt; ' ' &lt;&lt; tie &lt;&lt; ' ' &lt;&lt; win &lt;&lt; endl; cout &lt;&lt; gesture(ar) &lt;&lt; ' ' &lt;&lt; gesture(br); return 0;&#125; 1019 数字黑洞Analysis题目大意是给定一个四位数字，拆分出其各位数后，能得到一个最大值和最小值，二者相减后，会得到一个新数字。重复这个过程，最后差会一直等于6174。所以，当差为6174时，就停止循环。 按照下面的代码思路，每次必须要将保存各位数字的数组初始化为0，否则会有错误（因为数组有四个元素参与了运算）。另外，需要输出签到0。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;void toArray(int n, int *array) &#123; int temp = n, i = 0, ret = 0; while(temp) &#123; array[i++] = temp % 10; temp /= 10; &#125;&#125;int main(int argc, char const *argv[]) &#123; int n, min, max, diff; scanf("%d", &amp;n); while(1) &#123; int num[5] = &#123;0&#125;; toArray(n, num); sort(num, num + 4); max = num[0] + num[1] * 10 + num[2] * 100 + num[3] * 1000; min = num[3] + num[2] * 10 + num[1] * 100 + num[0] * 1000; diff = max - min; if(!diff) &#123; printf("%04d - %04d = 0000\n", max, min); break; &#125; else &#123; printf("%04d - %04d = %04d\n", max, min, diff); if(diff == 6174) break; n = diff; &#125; &#125; return 0;&#125; 1020 月饼Analysis这是道考察贪心算法的题目，题目要求输出的最大收益，实际上就是对应单价最高的月饼卖出后的总收益。若单价最高的月饼的贮存量不满足市场需求，按照剩余的市场需求量继续卖单价第二高的月饼。所以，需要计算出每种月饼的单价，再对其进行排序，接着按照题目要求计算总收益，最后在输出。 Code1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 1000 + 5;struct mooncake&#123; double store; double sell; double price;&#125; cake[MAXN];bool cmp(mooncake a, mooncake b);int main(int argc, char const *argv[]) &#123; int N; double D; scanf("%d %lf", &amp;N, &amp;D); for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].store); &#125; for(int i = 0; i &lt; N; i++) &#123; scanf("%lf", &amp;cake[i].sell); cake[i].price = cake[i].sell / cake[i].store; &#125; sort(cake, cake + N, cmp); double ans = 0; for(int i = 0; i &lt; N; i++) &#123; if(cake[i].store &lt;= D) &#123; D -= cake[i].store; ans += cake[i].sell; &#125; else &#123; ans += cake[i].price * D; break; &#125; &#125; printf("%.2lf\n", ans); return 0;&#125; bool cmp(mooncake a, mooncake b) &#123; return a.price &gt; b.price;&#125; 1021 个位数统计Analysis以字符串的形式读入题目给定的数字，再利用散列的思想，统计各个数字出现的次数，继而输出。 Code123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 1005int main(int argc, char const *argv[]) &#123; char num[MAXN]; int i, digit[10]=&#123;0&#125;; scanf("%s", num); char *p; p = num; while(*p) &#123; digit[*p - '0']++; p++; &#125; for(i=0; i&lt;10; i++) &#123; if(digit[i] != 0) printf("%d:%d\n", i, digit[i]); &#125; return 0;&#125; 1022 D进制的A+BAnalysis进制转换的常规题型，利用取余运算获取到转换进制的每一位，然后从高位往地位输出即可，注意输入0 0 8时特判，输出为0。 Code1234567891011121314151617181920#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; long long A, B, D, digit[50] = &#123;0&#125;, count = 0; scanf("%lld %lld %lld", &amp;A, &amp;B, &amp;D); A += B; while(A) &#123; digit[count++] = A % D; A /= D; &#125; if(count) &#123; for(count--; count &gt;= 0; count--) &#123; printf("%d", digit[count]); &#125; &#125; else &#123; printf("0"); &#125; putchar('\n'); return 0;&#125; 1023 组个最小数Analysis输出第一个数字时，不能输出0，所以直接从数字1开始遍历，存在则输出，然后个数减1，并跳出循环；接着在输出剩下的数字，此时0是可以被直接输出的，所以从数字0开始遍历（也是从小到大的规律），将每一个数字全部输出完后，再开始输出下一个数字。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int count[10] = &#123;0&#125;; for(int i = 0; i &lt; 10; i++) &#123; scanf("%d", &amp;count[i]); &#125; //print the first number for(int i = 1; i &lt; 10; i++) &#123; if(count[i]) &#123; printf("%d", i); count[i]--; break; &#125; &#125; //print the rest of numbers for(int i = 0; i &lt; 10; i++) &#123; while(count[i]) &#123; printf("%d", i); count[i]--; &#125; &#125; return 0;&#125; 1024 科学计数法Analysis题目意思比较明确，科学记数法转换成正常的数字，要把指数提取出来，在指数为正、负或零时，分别对应不同的情况。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;#include &lt;cstring&gt;#define MAXN 10005int Getexpon(char *s, int Epos);int main(int argc, char const *argv[]) &#123; char Num[MAXN]; scanf("%s", Num); int count = 0, expo, Epos = 0, len = strlen(Num); for(; Num[Epos] != 'E'; Epos++); if(Num[0] == '-') putchar(Num[0]); expo = Getexpon(Num, Epos); if(expo &gt; 0) &#123; for(int i = 1; i &lt; Epos; i++) &#123; if(Num[i] == '.') continue; putchar(Num[i]); if(i == expo + 2 &amp;&amp; Epos - 3 != expo) &#123; putchar('.'); &#125; &#125; for(int i = 0; i &lt; expo - (Epos - 3); i++) &#123; putchar('0'); &#125; &#125; else if(expo == 0) &#123; Num[Epos] = '\0'; puts(Num + 1); &#125; else &#123; expo = -expo; printf("0."); for(int i = 0; i &lt; expo - 1; i++) &#123; putchar('0'); &#125; putchar(Num[1]); for(int i = 3; i &lt; Epos; i++) &#123; putchar(Num[i]); &#125; &#125; putchar('\n'); return 0;&#125;int Getexpon(char *s, int Epos) &#123; int ret = 0, flag = 1, i = Epos + 1; if(s[i] == '-') &#123; flag = -1; &#125; i++; for(; s[i] != '\0'; i++) &#123; ret = ret * 10 + s[i] - '0'; &#125; return ret * flag;&#125; 1025 反转链表Analysis题目大意：给定一个单链表，每K个结点进行逆置，若最后K个结点，则不需逆置，输出逆置后的链表。 对待此类题目，还是是使用静态链表的思路来处理。先默认结构数组内的结点全部为无效结点，再按照地址逐个输入每个结点。然后，利用第一个结点的地址遍历链表，将合法结点的order改为链表结点的顺序，再利用sort函数将合法结点全部按序排在结构数组的左端，非法结点则在右端。 紧接着，开始逆置输出。对于具有n个合法结点的链表而言，按照k来逆置，则其必可被分为n / k个子块来分别逆置。继而，由于是逆置，所以需要将每一个子块倒着输出。但这一块的最后一个需要输出的结点需要分开考虑，因为其next已经变成了下一个块的最后一个结点的地址了。针对这个结点的位置有三种情况： 若当前输出的块不是最后一个整块，那么其next就是(i + 2) * K - 1结点（也就是下一个整块的最后一个结点）的地址 若当前输出的块是最后一个整块，且是最后一个整块的最后一个结点，那么其next即为-1 若当前输出的块是最后一个整块，但其后面还有小于K的结点个数，所以其next最后“尾巴”的第一个结点的地址，即(i + 1) * K号结点，然后再将剩余结点输出即可。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;const int maxn = 100005;struct node &#123; int address, data, next; int order;&#125; Node[maxn];void init() &#123; for(int i = 0; i &lt; maxn; i++) &#123; Node[i].order = maxn; &#125;&#125;bool cmp(node a, node b) &#123; return a.order &lt; b.order;&#125;int main(int argc, char const *argv[]) &#123; init(); int n, k, head, address; cin &gt;&gt; head &gt;&gt; n &gt;&gt; k; for(int i = 0; i &lt; n ; i++) &#123; cin &gt;&gt; address; cin &gt;&gt; Node[address].data &gt;&gt; Node[address].next; Node[address].address = address; &#125; int count = 0, p = head; while(p != -1) &#123; Node[p].order = count++; p = Node[p].next; &#125; sort(Node, Node + maxn, cmp); n = count; for(int i = 0; i &lt; n / k; i++) &#123; for(int j = (i + 1) * k - 1; j &gt; i * k; j--) &#123; printf("%05d %d %05d\n", Node[j].address, Node[j].data, Node[j - 1].address); &#125; printf("%05d %d ", Node[i * k].address, Node[i * k].data); if(i &lt; n / k - 1) &#123; printf("%05d\n", Node[(i + 2) * k - 1].address); &#125; else &#123; if(n % k == 0) printf("-1\n"); else &#123; printf("%05d\n", Node[(i + 1) * k].address); for(int i = n / k * k; i &lt; n; i++) &#123; printf("%05d %d ", Node[i].address, Node[i].data); if(i &lt; n - 1) &#123; printf("%05d\n", Node[i + 1].address); &#125; else &#123; printf("-1\n"); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 1026 程序运行时间Analysis给定的是整数，但是要求四舍五入，又知题目给定的除数是 100 ，给被除数加上 50 后，就可以模拟出四舍五入的效果。 Code123456789#include &lt;iostream&gt;using namespace std;int main() &#123; int c1, c2, c; scanf("%d %d", &amp;c1, &amp;c2); c = (c2 - c1 + 50) / 100; printf("%02d:%02d:%02d", c / 3600, c / 60 % 60, c % 60); return 0;&#125; 1027 打印沙漏Analysis这种打印图像的题目，需要找找规律。 以样例为例，只看图像一半，从中心开始出发，就是$a_1 = 1, a_2 = 3, a_3 = 5$的等差数列，按照这种思路的话，需要打印的图像其实就是两个等差数列，只不过第二个等差数列没有首项，只有两项$a_1 = 3, a_2 = 5$，但这并不影响计算，当作两个相同的等差数列计算好虎，减去多余的部分即可。 从而有：$2S_n - 1= 2 \times \frac{3 \times (1 + 5)}2 = 17$，这就是需要打印出来的符号数量，而此时的层数为3（其实也是等差数列的项数）。 下面再来进行输出，注意每行要先输出空格，在输出字符，最后一行输出未使用的字符数。使用绝对值，能简化一半的代码量，看着很清爽~ Code123456789101112131415161718192021#include &lt;cstdio&gt;#define ABS(x) ((x) &gt;= 0 ? (x) : -(x))int main(int argc, char const *argv[]) &#123; int N, layers; char c; scanf("%d %c", &amp;N, &amp;c); for(layers = 1; 2 * layers * layers - 1 &lt;= N; layers++); layers--; for(int i = 0; i &lt; 2 * layers - 1; i++) &#123; for(int j = 0; j &lt; layers - ABS(layers - i - 1) - 1; j++) &#123; putchar(' '); &#125; for(int k = 0; k &lt; 2 * ABS(layers - i - 1) + 1; k++) &#123; putchar(c); &#125; putchar('\n'); &#125; printf("%d\n", N - 2 * layers * layers + 1); return 0;&#125; 1028 人口普查Analysis这道题如何在处理日期上面没有经验的话，就很难受...一开始在判断日期合法性的时候，想到了全部转化为天数，光是转换天数，还有平闰年的区分，感觉又是一道题了🤔，这应该不是姥姥想让答题者干的活。事实证明，确实想歪了😂，对于这类日期的判断，从年这个数字开始逐个进行比较即可（参考下面的代码），同时注意不要用if-else来得到最年长和年轻的人就好，要分开判断。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;cstdio&gt;struct citizen&#123; int year, month, day; char name[7];&#125; youngest, oldest, left, right, temp;void Init();bool Less(citizen a, citizen b);bool More(citizen a, citizen b);int main(int argc, char const *argv[]) &#123; Init(); int N, valid = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%s %d/%d/%d", temp.name, &amp;temp.year, &amp;temp.month, &amp;temp.day); if(Less(temp, right) &amp;&amp; More(temp, left)) &#123; valid++; if(More(temp, youngest)) &#123; youngest = temp; &#125; if(Less(temp, oldest)) &#123; oldest = temp; &#125; &#125; &#125; if(valid) &#123; printf("%d %s %s\n", valid, oldest.name, youngest.name); &#125; else &#123; printf("0\n"); &#125; return 0;&#125;void Init() &#123; left.year = youngest.year = 1814; right.year = oldest.year = 2014; youngest.month = oldest.month = left.month = right.month = 9; youngest.day = oldest.day = left.day = right.day = 6;&#125;bool Less(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &lt;= b.year; else if(a.month != b.month) return a.month &lt;= b.month; else return a.day &lt;= b.day;&#125;bool More(citizen a, citizen b) &#123; if(a.year != b.year) return a.year &gt;= b.year; else if(a.month != b.month) return a.month &gt;= b.month; else return a.day &gt;= b.day;&#125; 1029 旧键盘Analysis遍历字符串，找出第一个字符串中出现过，但第二个字符串中未出现的字符即可，字母不区分大小写，但字符串内有空格和数字，用_表示，注意不能输出小写字母，且重复的字符只输出一次。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstdio&gt;#include &lt;cctype&gt;void levelup(char *str);int main(int argc, char const *argv[]) &#123; char str1[85], str2[85], Result[30]; scanf("%s %s", str1, str2); levelup(str1); levelup(str2); int count = 0; for(int i = 0; str1[i] != '\0'; i++) &#123; char temp = str1[i]; bool flag = true; for(int j = 0; str2[j] != '\0'; j++) &#123; if(temp == str2[j]) &#123; flag = false; break; &#125; &#125; if(flag) &#123; int k = 0; for(k = 0; k &lt; 30; k++) &#123; if(temp == Result[k]) &#123; break; &#125; &#125; if(k == 30) &#123; Result[count++] = temp; &#125; &#125; &#125; Result[count] = '\0'; puts(Result); return 0;&#125;void levelup(char *str) &#123; char *p = str; while(*p != '\0') &#123; if(islower(*p)) &#123; *p = toupper(*p); &#125; p++; &#125;&#125; 1030 完美数列Analysis题目大意是给一堆数字，这些数字以任意个数和顺序组成序列，使得这个数列的最大、最小值存在这样的关系：$M\ \le\ m \times p$，并要求这个数列包含的数字数量要尽可能的多。 看到题目一般会想到先将序列排序，然后找出其中的最大值，再从小到大枚举每一个数字，直到不满足关系时，退出循环，下标之差即是结果。但这实际上只把题目的输入数据当作了一个数列处理（此时提交可得20分）。若这个数列还存在比$m \times p$小的数，按照这样的思路就无法让数字数量增加了（因为最大值已经限定了）。 继续深入思考，对有序序列而言，按照题目要求，就需要以当前数字为左端点，然后找到符合要求的最大的右端点值（此时这个右端点值的下标最大，下标差越大，数字数量就越多）。按照这样的思路依次枚举每个数字就可以得到最终结果，此算法的时间复杂度为$O(n)$。 如何能将查找右端点值过程缩短一点呢？注意到数组已经被排好序了，所以可以使用二分查找来做这件事。此时，问题就演变为：从一个数的后面所有数中，找出刚好满足 $M\ \le\ m \times p$ 这个条件的数字，其中$M$和$m$分别为第一个数字与查找到的数字组成的数列的最大和最小值。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;int n, p, Num[MAXN];int BinarySearch(int i, long long x);int main(int argc, char const *argv[]) &#123; scanf("%d %d", &amp;n, &amp;p); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;Num[i]); &#125; sort(Num, Num + n); int ans = 1; for(int i = 0; i &lt; n; i++) &#123; int j = BinarySearch(i, (long long)Num[i] * p); ans = max(ans, j - i); &#125; printf("%d", ans); return 0;&#125;int BinarySearch(int i, long long x) &#123; if(Num[n - 1] &lt;= x) &#123; return n; &#125; int left = i + 1, right = n - 1, mid; while(left &lt; right) &#123; mid = (left + right) / 2; if(Num[mid] &lt;= x) &#123; left = mid + 1; &#125; else &#123; right = mid; &#125; &#125; return left;&#125; 1031 查验身份证Analysis题目不难，就是要认真读题，根据题目要求进行计算即可，别马虎，别忘记数字是可以用X表示的，这个要区分一下。 Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;char Comparison_Table[12] = &#123;'1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'&#125;;int Weight_Table[17] = &#123;7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2&#125;;int main(int argc, char const *argv[])&#123; char ID_Number[19]; int N, flag = 1; scanf("%d", &amp;N); while(N--) &#123; scanf("%s", ID_Number); char *p = ID_Number; int i, Digit_Sum = 0, Check_value; for(i=0; i&lt;17; i++, p++) &#123; if(*p == 'X') Digit_Sum += (10 * Weight_Table[i]); else Digit_Sum += ((*p - '0') * Weight_Table[i]); &#125; Check_value = Digit_Sum % 11; char Check_code = Comparison_Table[Check_value]; if(Check_code == ID_Number[17]) continue; else&#123; printf("%s\n", ID_Number); flag = 0; &#125; &#125; if(flag) printf("All passed\n"); return 0;&#125; 1032 挖掘机技术哪家强Analysis这道题很简单，用数组简单模拟一下就好了，注意最后一个大数据的测试点。 Code12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 100005int main(int argc, char const *argv[]) &#123; int i, Num, Max = 0, N, School_Num[MAXN] = &#123;0&#125;, temp; scanf("%d", &amp;N); while(N--) &#123; scanf("%d %d", &amp;Num, &amp;temp); School_Num[Num] += temp; &#125; for(i = 0; i &lt; MAXN; i++) &#123; if(Max &lt; School_Num[i]) &#123; Num = i; Max = School_Num[i]; &#125; &#125; printf("%d %d\n", Num, Max); return 0;&#125; 1033 旧键盘打字Analysis与1029正好相反的一道题目，要注意的点： 不区分大小写，只要是第一个字符串出现过的字母，第二个字符串在输出时，无论大小写，都不能输出 上档键坏了，尽管某个字母按键没坏，但是也不能输出这个字母的大写了 第一个字符串可能是空串 Code123456789101112131415161718192021222324252627#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 100000 + 5;int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; bool brokenkey[128] = &#123;false&#125;; fgets(str2, MAXN, stdin); fgets(str1, MAXN, stdin); for(int i = 0; str2[i] != '\0'; i++) &#123; brokenkey[str2[i]] = true; if(islower(str2[i])) &#123; brokenkey[str2[i] - 32] = true; &#125; else if(isupper(str2[i])) &#123; brokenkey[str2[i] + 32] = true; &#125; &#125; for(int i = 0; str1[i] != '\0'; i++) &#123; if(!brokenkey[str1[i]]) &#123; if(isupper(str1[i]) &amp;&amp; brokenkey['+']) &#123; continue; &#125; printf("%c", str1[i]); &#125; &#125; return 0;&#125; 1034 有理数运算Analysis题目大意是给定2个a/b形式的分数，a为分子，b为分母，求这2个分数的和、差、积、商，再输出。 给定的分数只有两种情况（形式上）：真分数和假分数，不存在带分数，但输出要输出带分数，并且是最简形式。化简的目的其实题目考察求最大公约数，利用欧几里得算法即可求得两个数的最大公约数。 注意： 除数为0时，需要输出Inf 负数需要使用()括起来 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;struct Fraction &#123; ll up, down;&#125; f1, f2;ll gcd(ll a, ll b) &#123; return b == 0 ? a : gcd(b, a % b);&#125;Fraction Reduction(Fraction result) &#123; if(result.down &lt; 0) &#123; result.up = -result.up; result.down = -result.down; &#125; if(result.up == 0) &#123; result.down = 1; &#125; else &#123; int d = gcd(abs(result.up), abs(result.down)); result.up /= d; result.down /= d; &#125; return result;&#125;Fraction Add(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down + f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Minu(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down - f2.up * f1.down; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Mult(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.up; result.down = f1.down * f2.down; return Reduction(result);&#125;Fraction Divide(Fraction f1, Fraction f2) &#123; Fraction result; result.up = f1.up * f2.down; result.down = f1.down * f2.up; return Reduction(result);&#125;void printResult(Fraction r) &#123; r = Reduction(r); if(r.up &lt; 0) printf("("); if(r.down == 1) printf("%lld", r.up); else if(abs(r.up) &gt; r.down) &#123; printf("%lld %lld/%lld", r.up / r.down, abs(r.up) % r.down, r.down); &#125; else &#123; printf("%lld/%lld", r.up, r.down); &#125; if(r.up &lt; 0) printf(")");&#125;int main(int argc, char const *argv[]) &#123; scanf("%lld/%lld %lld/%lld", &amp;f1.up, &amp;f1.down, &amp;f2.up, &amp;f2.down); //add printResult(f1); printf(" + "); printResult(f2); printf(" = "); printResult(Add(f1, f2)); putchar('\n'); //minu printResult(f1); printf(" - "); printResult(f2); printf(" = "); printResult(Minu(f1, f2)); putchar('\n'); //mult printResult(f1); printf(" * "); printResult(f2); printf(" = "); printResult(Mult(f1, f2)); putchar('\n'); //divide printResult(f1); printf(" / "); printResult(f2); printf(" = "); if(f2.up == 0) printf("Inf"); else printResult(Divide(f1, f2)); return 0;&#125; 1035 插入与归并Analysis题目的意思比较明确，给定两个序列，判断属于哪一种排序，然后输出这个序列在这种排序下的下一轮排序结果。 对给定的初始序列，按照插入排序的过程进行模拟，每轮排序都与给定的中间序列进行比较，如果相同就属于Insertion Sort，否则就是Merge Sort了。 在整个排序和比较的过程中，先进行比较，在需要输出的时候就不需要再进行依次排序操作，可以减少一部分的代码量。另外，使用sort函数来模拟归并排序的过程，要注意sort函数每次只能排制定间隔内的数字。所以采用min(i + step, n)的写法避免最后一次排序时元素个数低于归并间隔的情况，即再最后一次排序过程中，只排剩下的元素。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int MAXN = 100 + 5;int origin[MAXN], tempOri[MAXN], changed[MAXN];int n;bool isSame(int A[], int B[]) &#123; for(int i = 0; i &lt; n; i++) &#123; if(A[i] != B[i]) return false; &#125; return true;&#125;void showArray(int A[]) &#123; for(int i = 0; i &lt; n; i++) &#123; printf("%d", A[i]); if(i &lt; n - 1) putchar(' '); &#125; putchar('\n');&#125;bool InsertSort() &#123; bool flag = false; for(int i = 1; i &lt; n; i++) &#123; if(i != 1 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; int temp = tempOri[i], j = i; while(j &gt; 0 &amp;&amp; tempOri[j - 1] &gt; temp) &#123; tempOri[j] = tempOri[j - 1]; j--; &#125; tempOri[j] = temp; if(flag == true) &#123; return true; &#125; &#125; return false;&#125;void MergeSort() &#123; bool flag = false; for(int step = 2; step / 2 &lt;= n; step *= 2) &#123; if(step != 2 &amp;&amp; isSame(tempOri, changed)) &#123; flag = true; &#125; for(int i = 0; i &lt; n; i += step) &#123; sort(tempOri + i, tempOri + min(i + step, n)); &#125; if(flag == true) &#123; showArray(tempOri); return; &#125; &#125;&#125;int main(int argc, char const *argv[]) &#123; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;origin[i]); tempOri[i] = origin[i]; &#125; for(int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;changed[i]); &#125; if(InsertSort()) &#123; printf("Insertion Sort\n"); showArray(tempOri); &#125; else &#123; printf("Merge Sort\n"); for(int i = 0; i &lt; n; i++) &#123; tempOri[i] = origin[i]; &#125; MergeSort(); &#125; return 0;&#125; 1036 跟奥巴马一起编程Analysis这种打印图形类的题目主要是在找输出的位置，注意题目给定的是字符变量C，而不是C字符。 Code12345678910111213141516171819#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N, i, j; char C; scanf("%d %c", &amp;N, &amp;C); /*actually, you just need to find the place you want print */ for(i=0; i&lt;(N+1)/2; i++) &#123; for(j=0; j&lt;N; j++) &#123; if(i==0 || i==(N-1)/2 || j==0 || j==N-1) putchar(C); else putchar(' '); &#125; putchar('\n'); &#125; return 0;&#125; 1037 在霍格沃茨找零钱Analysis题目意思很直观就是找零钱了，只不过度量单位不一样，在计算的时候，按照给定的量进行计算即可。注意由于，本题中钱的形式有三样，所以在计算前得先判断大小，然后让大的减小的，这样计算起来就很简单了；另外，相等的时候要特判输出0.0.0。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;cstdio&gt;struct money &#123; int g, s, k;&#125; P, A, Result;bool Bigger(money a, money b);money Substract(money big, money small);int main(int argc, char const *argv[]) &#123; scanf("%d.%d.%d %d.%d.%d", &amp;P.g, &amp;P.k, &amp;P.s, &amp;A.g, &amp;A.k, &amp;A.s); if(Bigger(P, A)) &#123; Result = Substract(P, A); if(!Result.g &amp;&amp; !Result.k &amp;&amp; !Result.s) printf("0.0.0\n"); else printf("-%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; else &#123; Result = Substract(A, P); printf("%d.%d.%d\n", Result.g, Result.k, Result.s); &#125; return 0;&#125;bool Bigger(money a, money b) &#123; if(a.g != b.g) return a.g &gt;= b.g; else if(a.k != b.k) return a.k &gt;= b.k; else return a.s &gt;= b.s;&#125;money Substract(money big, money small) &#123; money ret; if(big.s &gt;= small.s) &#123; ret.s = big.s - small.s; &#125; else &#123; ret.s = big.s + 29 - small.s; big.k--; &#125; if(big.k &gt;= small.k) &#123; ret.k = big.k - small.k; &#125; else &#123; ret.k = big.k + 17 - small.k; big.g--; &#125; ret.g = big.g - small.g; return ret;&#125; 1038 统计同成绩学生Analysis考察基本散列的思想，将输入的分数值作为数组下标，每次查找的时间复杂度就变为了：$O(1)$。 Code123456789101112131415161718#include &lt;cstdio&gt;int grade[101] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int N, K, temp; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;temp); grade[temp]++; &#125; scanf("%d", &amp;K); while(K--) &#123; scanf("%d", &amp;temp); printf("%d", grade[temp]); if(K &gt; 0) putchar(' '); &#125; return 0;&#125; 1039 到底买不买Analysis将字符常量作为下标散列在统计次数的数组中，就可以很方便的统计珠子的个数了。买与不买对应两种情况： 买，多余的珠子数目就是两个字符串的长度之差 不买，遍历统计次数的数组，找到第二个字符串中出现次数比第一个字符串中出现次数多的字符，并记录下其差值。 Code12345678910111213141516171819202122232425262728293031323334353637#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 1000 + 5;void get_count(int *a, char *s);int main(int argc, char const *argv[]) &#123; char str1[MAXN], str2[MAXN]; fgets(str1, MAXN, stdin); fgets(str2, MAXN, stdin); int count1[90] = &#123;0&#125;, count2[90] = &#123;0&#125;; get_count(count1, str1); get_count(count2, str2); int temp, less = 0, len1 = strlen(str1), len2 = strlen(str2); bool enough = true; for(int i = 0; i &lt; 90; i++) &#123; temp = count2[i] - count1[i]; if(temp &gt; 0) &#123; less += temp; enough = false; &#125; &#125; if(enough) &#123; printf("Yes %d\n", len1 - len2); &#125; else &#123; printf("No %d\n", less); &#125; return 0;&#125;void get_count(int *a, char *s) &#123; char *p = s; while(*p != '\0') &#123; a[*p - '0']++; p++; &#125;&#125; 1040 有几个PATAnalysis题目大意是给定一个只含P、A、T三个字母的字符串，按照PAT的顺序，在不改变字符串内字符排列顺序的前提下，最多能有几个PAT这样的子串。 按照题目要求，最容易想到的思路就是利用三个循环暴力枚举所有可能的出现情况，然后统计符合要求的情况，最后在输出。但这样会超时，所以需要换个思路。 对于字符串中确定位置的每一个A而言，其能够与P、T组成PAT的个数，等于其左边P的个数乘以其右边T的个数。那么，这个问题就变成了，遍历字符串时，累加每一个A的左边P的个数与右边T的个数的乘积。 那么，如何才能较快的获得P的个数呢？可以使用一个数组一次性计算出字符串中每一个字符串左边P的个数。直接从左至右遍历字符串，如果当前位是P，那么此位置的数目就是前一位的数目加1；如果当前位不是P，那么此位置的数目就是前一位的数目。 解决了P的问题，T怎么办呢？定义一个变量，从右往左遍历字符串，现在只考虑两种情况： 当前字符为T，变量加1 当前字符为A，统计此位置A能组成的子串PAT的数目（计算时别忘了取余），再累加 遍历结束后，就可以直接输出总数目了。 Code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt; const int MAXN = 100000 + 10;const int MOD = 1000000007;char str[MAXN];int leftNumP[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; scanf("%s", str); int len = strlen(str); for(int i = 0; i &lt; len; i++) &#123; if(i &gt; 0) &#123; leftNumP[i] = leftNumP[i - 1]; &#125; if(str[i] == 'P') &#123; leftNumP[i]++; &#125; &#125; int ans = 0, rightNumT = 0; for(int i = len - 1; i &gt;= 0; i--) &#123; if(str[i] == 'T') &#123; rightNumT++; &#125; else if(str[i] == 'A') &#123; ans = (ans + leftNumP[i] * rightNumT) % MOD; &#125; &#125; printf("%d", ans); return 0;&#125; 1041 考试座位号Analysis由于最后要输出准考证号，所以每次输入都必须保存输入的准考证号等信息。这样的话，使用结构体数组无疑是一种很方便的选择，之后再遍历结构体数组输出符合条件的信息即可， Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;struct examinee_info&#123; char number[17]; int test_seat; int exam_seat;&#125; Examinee_Info[1005];int main(int argc, char const *argv[]) &#123; int N, M, i, temp; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%s %d %d", Examinee_Info[i].number, &amp;Examinee_Info[i].test_seat, &amp;Examinee_Info[i].exam_seat); &#125; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;temp); for(i = 0; i &lt; N; i++) &#123; if(temp == Examinee_Info[i].test_seat) &#123; printf("%s %d\n", Examinee_Info[i].number, Examinee_Info[i].exam_seat); &#125; &#125; &#125; return 0;&#125; 1042 字符统计Analysis利用数组统计每个英文字符（不区分大小写）的出现次数，直接使用字符变量（ASCII码值）作为下标会很方便，同时得到出现的最大次数。输出时，遍历统计次数的数组，只输出字典序最小的字母即可。 Code1234567891011121314151617181920212223242526#include &lt;cstdio&gt;#include &lt;cctype&gt;const int MAXN = 1000 + 5;int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); int times[27] = &#123;0&#125;, maxtimes = -1; for(int i = 0; str[i] != '\0'; i++) &#123; char c1 = str[i]; if(isalpha(c1)) &#123; if(isupper(c1)) c1 = tolower(c1); times[c1 - 'a']++; if(times[c1 - 'a'] &gt; maxtimes) &#123; maxtimes = times[c1 - 'a']; &#125; &#125; &#125; for(int i = 0; i &lt; 27; i++) &#123; if(maxtimes == times[i]) &#123; printf("%c %d\n", i + 'a', times[i]); break; &#125; &#125; return 0;&#125; 1043 输出PATestAnalysis先统计字符串中PATest这六个字符的出现次数，然后依次输出PATest，注意当其中某个字符输出完后，仍然要保持PATest这个顺序来输出字符。 Code123456789101112131415161718192021222324#include &lt;cstdio&gt;const int MAXN = 10000 + 5;char PATest[10] = "PATest";int main(int argc, char const *argv[]) &#123; char str[MAXN]; fgets(str, MAXN, stdin); char *p = str; int times[128] = &#123;0&#125;; while(*p != '\0') &#123; times[*p]++; p++; &#125; while(times['P'] || times['A'] || times['T'] || times['e'] || times['s'] || times['t']) &#123; for(p = PATest; *p != '\0'; p++) &#123; if(times[*p]) &#123; putchar(*p); times[*p]--; &#125; &#125; &#125; return 0;&#125; 1044 火星数字Analysis题目给出了火星上的数位规则，要求将十进制数转换为火星数字并输出。尽管火星上每一位数输出的形式不一样，但其本质是13进制的，所以按照这个规则进行即可。 由于整个范围的数字有169个，所以提前将所有需要输出的数字全部打印好，之后直接输出比较好。为此，需要借助 C++ 的string和map，来分别建立数字对应字符串、字符串对应数字的映射数组。 注意：输入13时，需要输出tam，而不是tam tret。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;string unitDigit[13] = &#123;"tret", "jan", "feb", "mar", "apr", "may", "jun", "jly", "aug", "sep", "oct", "nov", "dec", &#125;;string tenDigit[13] = &#123;"tret", "tam", "hel", "maa", "huh", "tou", "kes", "hei", "elo", "syy", "lok", "mer", "jou", &#125;;string numToStr[170];map&lt;string, int&gt; strToNum;void init();int main(int argc, char const *argv[]) &#123; init(); int n; cin &gt;&gt; n; getchar(); //get the extra ' ' from stdin while(n--) &#123; string s; getline(cin, s); if('0' &lt;= s[0] &amp;&amp; s[0] &lt;= '9') &#123; int num = 0; for(int i = 0; i &lt; s.length(); i++) &#123; num = num * 10 + s[i] - '0'; &#125; cout &lt;&lt; numToStr[num] &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; strToNum[s] &lt;&lt; endl; &#125; &#125; return 0;&#125;void init() &#123; for(int i = 0; i &lt; 13; i++) &#123; numToStr[i] = unitDigit[i]; strToNum[unitDigit[i]] = i; numToStr[i * 13] = tenDigit[i]; strToNum[tenDigit[i]] = i * 13; &#125; for(int i = 1; i &lt; 13; i++) &#123; for(int j = 1; j &lt; 13; j++) &#123; //string concatenation string str = tenDigit[i] + ' ' + unitDigit[j]; numToStr[i * 13 + j] = str; strToNum[str] = i * 13 + j; &#125; &#125;&#125; 1045 快速排序Analysis题目的背景是快速排序算法内的一些概念，已经给出了描述，所以不影响读题。依据题目的例子，可以得到主元的特点： 主元左边的数字全部比它小，即最大值小于它 主元右边的数字全部比它大，即最小值大于它 按照上述分析，依次枚举数组内每一个元素，如果每次都去查找当前元素的最值，会很耗时间。所以，要换一个角度去思考问题。 定义一个数组，一次性将所有数字左边的最小值全部计算出来，每次枚举时，就只用和前一个数字最左边的最小值进行比较，找最大值时同理。 最后在遍历一次数组，找出符合条件的数后直接输出即可。 Code1234567891011121314151617181920212223242526272829303132333435#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std; const int MAXN = 100000 + 10;const int INF = 0x3fffffff;int array[MAXN], leftMax[MAXN], rightMin[MAXN];int ans[MAXN], num = 0;int main(int argc, char const *argv[]) &#123; int N; scanf("%d", &amp;N); for(int i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;array[i]); &#125; leftMax[0] = 0; for(int i = 1; i &lt; N; i++) &#123; leftMax[i] = max(leftMax[i - 1], array[i - 1]); &#125; rightMin[N - 1] = INF; for(int i = N - 2; i &gt;= 0; i--) &#123; rightMin[i] = min(rightMin[i + 1], array[i + 1]); &#125; for(int i = 0; i &lt; N; i++) &#123; if(leftMax[i] &lt; array[i] &amp;&amp; rightMin[i] &gt; array[i]) &#123; ans[num++] = array[i]; &#125; &#125; printf("%d\n", num); for(int i = 0; i &lt; num; i++) &#123; printf("%d", ans[i]); if(i &lt; num - 1) putchar(' '); &#125; putchar('\n'); return 0;&#125; 1046 划拳Analysis注意读题，理解题目意思后就好办了。另外注意，输家罚一杯酒，甲若输了，甲喝一杯，乙不喝；同赢或同输都不喝。 Code12345678910111213141516#include &lt;iostream&gt;using namespace std;int main() &#123; int n, a, b, c, d, countA = 0, countB = 0; cin &gt;&gt; n; while(n--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; if(a + c == b &amp;&amp; a + c == d) continue; // all win else if(a + c != b &amp;&amp; a + c != d) continue; // all lose else if(a + c == b) countB++; // A win else countA++; // B win &#125; cout &lt;&lt; countA &lt;&lt; ' ' &lt;&lt; countB; return 0;&#125; 1047 编程团体赛Analysis统计每支队伍的总分，然后找出总分的最大值，即可得到冠军队的编号。然后，输出冠军队的编号和总成绩。 Code12345678910111213141516171819202122#include &lt;cstdio&gt;int main(int argc, char const *argv[]) &#123; int N, team, score[1010] = &#123;0&#125;, eachScore, maxteam = 0; scanf("%d", &amp;N); while(N--) &#123; scanf("%d-%*d %d", &amp;team, &amp;eachScore); score[team] += eachScore; if(team &gt; maxteam) &#123; maxteam = team; &#125; &#125; int maxscore = -1, index = 0; for(int i = 1; i &lt;= maxteam; i++) &#123; if(score[i] &gt; maxscore) &#123; maxscore = score[i]; index = i; &#125; &#125; printf("%d %d", index, maxscore); return 0;&#125; 1048 数字加密Analysis题目意思简单，做法也不难，就是有陷阱🤩，即：若是B的位数少于加密密钥的位数，需要假设B的当前位上的数字是0然后参与计算（注意奇偶位不同）即可。 一开始偷懒，以为短就短吧，只加密到需要加密的位数就行了，结果有两个测试点无法通过，看来还是题意理解的不够深入。 另外，由于输入后，数字的个位在字符串最后一位，所以需要逆置一下。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;cstdio&gt;#include &lt;cstring&gt;const int MAXN = 100 + 5;char change[14] = "0123456789JQK";void Reverse(char *s);int main(int argc, char const *argv[]) &#123; char A[MAXN], B[MAXN], Result[MAXN]; scanf("%s %s", A, B); Reverse(A); Reverse(B); int i, lenA = strlen(A), lenB = strlen(B), len; len = lenA &gt; lenB ? lenA : lenB; for(i = 0; i &lt; len; i++) &#123; int numA = i &lt; lenA ? A[i] - '0' : 0; int numB = i &lt; lenB ? B[i] - '0' : 0; if(i % 2 == 0) &#123; int sum = numA + numB; Result[i] = change[sum % 13]; &#125; else &#123; int diff = numB - numA; if(diff &lt; 0) &#123; diff += 10; &#125; Result[i] = change[diff]; &#125; &#125; Result[i] = '\0'; Reverse(Result); puts(Result); return 0;&#125;void Reverse(char *s) &#123; char temp; int len = strlen(s); for(int i = 0; i &lt; len / 2; i++) &#123; temp = s[i]; s[i] = s[len - i - 1]; s[len - i - 1] = temp; &#125;&#125; 1049 数列的片段和Analysis题目大意是给定一个数列，计算其所有按序排列的子列和。列举出$N$分别取3、4、5时，其和（$Sum$）情况如下： $N$ $Sum$ 3 $3 \times a_1 + 4 \times a_2 + 3 \times a_3$ 4 $4 \times a_1 + 6 \times a_2 + 6 \times a_3 + 4 \times a_4$ 5 $5 \times a_1 + 8 \times a_2 + 9 \times a_3 + 8 \times a_4 + 5 \times a_5$ 于是可以推出规律为：首项和尾项乘以项数相加，中间每项其左、右两边项数之积（包含它自身）。 Code123456789101112131415161718192021#include &lt;cstdio&gt;const int MAXN = 100000 + 10;double seq[MAXN] = &#123;0&#125;;int main(int argc, char const *argv[]) &#123; int n; scanf("%d", &amp;n); for(int i = 0; i &lt; n; i++) &#123; scanf("%lf", &amp;seq[i]); &#125; double ans = 0; ans = seq[0] * n; if(n &gt; 1) &#123; for(int i = 1; i &lt; n - 1; i++) &#123; ans += (seq[i] * (i + 1) * (n - i)); &#125; ans += seq[n - 1] * n; &#125; printf("%.2lf\n", ans); return 0;&#125; 1051 复数乘法Analysis此题不难，属于“纸老虎”，不过找特殊情况很是烦人的😅~ Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;math.h&gt;int main(int argc, char const *argv[]) &#123; double R1, P1, R2, P2, R, P; scanf("%lf %lf %lf %lf", &amp;R1, &amp;P1, &amp;R2, &amp;P2); R = R1 * R2 * (cos(P1) * cos(P2) - sin(P1) * sin(P2)); P = R1 * R2 * (cos(P1) * sin(P2) + sin(P1) * cos(P2)); //prevent to print '-0.00' if(-0.05 &lt; R &amp;&amp; R &lt; 0.05) &#123; R = 0.0; &#125; if(-0.05 &lt; P &amp;&amp; P &lt; 0.05) &#123; P = 0.0; &#125; printf("%.2lf", R); if(P &gt;= 0) &#123; printf("+%.2lfi\n", P); &#125; else &#123; printf("-%.2lfi\n", fabs(P)); &#125; return 0;&#125; 1056 组合数的和Analysis题目不难，读懂题目之后直接做就可以了。 Code123456789101112131415161718192021#include &lt;stdio.h&gt;#define MAXN 10int main(int argc, char const *argv[]) &#123; int i, j, N, Array[MAXN], Sum = 0; scanf("%d", &amp;N); for(i = 0; i &lt; N; i++) &#123; scanf("%d", &amp;Array[i]); &#125; for(i = 0; i &lt; N; i++) &#123; for(j = 0; j &lt; N; j++) &#123; if(i == j) &#123; continue; &#125; else &#123; Sum += (Array[i] * 10 + Array[j]); &#125; &#125; &#125; printf("%d\n", Sum); return 0;&#125; 1061 判断题Analysis题目稍微有点绕，大致意思就像老师改卷一样，正确打勾，错误打叉，然后把对的题目的分数加到一起，从而得到每位学生的总分。 Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int N, M; scanf("%d %d", &amp;N, &amp;M); int i, j, Scores[M], Right[M], Temp[M], Sum; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Scores[i]); &#125; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Right[i]); &#125; while(N--) &#123; Sum = 0; for(i = 0; i &lt; M; i++) &#123; scanf("%d", &amp;Temp[i]); if(Temp[i] == Right[i]) &#123; Sum += Scores[i]; &#125; &#125; printf("%d\n", Sum); &#125; return 0;&#125; 1066 图像过滤Analysis这道题的意思，其实就是图像的灰度化处理（当然这里的比较简单）。Matlab 内有直接进行此种操作的图像处理函数，可以直接调用。注意 N 和 M 的最大值，最后一个测试点是最大值测试。 Code12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#define MAXN 500#define MAXM 500int main(int argc, char const *argv[]) &#123; int r, c, M, N, A, B, gray_value; scanf("%d %d %d %d %d", &amp;M, &amp;N, &amp;A, &amp;B, &amp;gray_value); int image_array[MAXM][MAXN]; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; scanf("%d", &amp;image_array[r][c]); if(A &lt;= image_array[r][c] &amp;&amp; image_array[r][c] &lt;= B) &#123; image_array[r][c] = gray_value; &#125; &#125; &#125; for(r = 0; r &lt; M; r++) &#123; for(c = 0; c &lt; N; c++) &#123; printf("%03d", image_array[r][c]); if(c == N-1) &#123; putchar('\n'); &#125; else &#123; putchar(' '); &#125; &#125; &#125; return 0;&#125; 1071 小赌怡情Analysis这道题的题目比较长，耐心一点，仔细读完，按照题目给定的四种情况的处理方式来写代码，应该就 OK 了，注意输光后（筹码x &lt;= 0），就可以直接退出了。 Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#define MAXK 100int main(int argc, char const *argv[]) &#123; int T, K, n1, b, t, n2, x, system_result; scanf("%d %d", &amp;T, &amp;K); x = T; while(K-- &amp;&amp; x) &#123; scanf("%d %d %d %d", &amp;n1, &amp;b, &amp;t, &amp;n2); if(t &gt; x) &#123; printf("Not enough tokens. Total = %d.\n", x); continue; &#125; if(n2 &gt; n1) &#123; system_result = 1; &#125; else &#123; system_result = 0; &#125; if(system_result == b) &#123; x += t; printf("Win %d! Total = %d.\n", t, x); &#125; else &#123; x -= t; printf("Lose %d. Total = %d.\n", t, x); &#125; &#125; if(x &lt;= 0) &#123; printf("Game Over.\n"); &#125; return 0;&#125; 1076 Wifi密码Analysis为了促进学生学习，这题也真是难为老师了，哈哈~此题不难，不过需要细心一点，输入的格式是确定好了的。如果每次输入利用字符来做处理，则需要注意回车符\n不要被输入函数获取到了（测试点2就是这样）。可以按照字符串的思路去处理，并且循环进行的次数可能会少一些。 Code1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 105int Wifi_Password[4] = &#123;1, 2, 3, 4&#125;;int main(int argc, char const *argv[]) &#123; int i, N, count = 0; scanf("%d%*c", &amp;N); char Answers[MAXN], temp, flag; for(i = 0; i &lt; 4 * N; i++) &#123; scanf("%c-%c%*c", &amp;temp, &amp;flag); if(flag == 'T') &#123; Answers[count++] = temp; &#125; &#125; for(i = 0; i &lt; count; i++) &#123; printf("%d", Wifi_Password[Answers[i] - 'A']); &#125; putchar('\n'); return 0;&#125; 1081 检查密码Analysis此题的难点在于情况的分类，无论输入的“密码”是否合法，首先判断长度是否不小于6，紧接着，判断是否有非法字符，继而确认有无数字，最后确认有无字母。注意可能会输入带空格的字符串（测试点2）。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;ctype.h&gt;#define MaxLength 85int Validity_Check(char *password);char Result[5][100] = &#123; "Your password is tai duan le.", "Your password is tai luan le.", "Your password needs shu zi.", "Your password needs zi mu.", "Your password is wan mei.",&#125;;int main(int argc, char const *argv[]) &#123; int flag, N; char Password[MaxLength]; scanf("%d%*c", &amp;N); while(N--) &#123; gets(Password); //notice the space flag = Validity_Check(Password); puts(Result[flag]); &#125; return 0;&#125;int Validity_Check(char *password) &#123; int ret = 4, len = strlen(password), i; int num_flag, alpha_flag, invalid_flag; num_flag = alpha_flag = invalid_flag = 0; if(len &gt;= 6) &#123; for(i = 0; i &lt; len; i++) &#123; if( isdigit(password[i]) ) &#123; num_flag = 1; &#125; else if( isalpha(password[i]) ) &#123; alpha_flag = 1; &#125; else if(password[i] == '.') &#123; continue; &#125; else &#123; invalid_flag = 1; &#125; &#125; if(invalid_flag) &#123; ret = 1; &#125; else if(!num_flag) &#123; ret = 2; &#125; else if(!alpha_flag) &#123; ret = 3; &#125; &#125; else &#123; ret = 0; &#125; return ret;&#125; 1086 就不告诉你Analysis水题一道，注意$700$，不要倒着输出为$007$了。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[]) &#123; int A, B, Product, temp, digit, result = 0; scanf("%d %d", &amp;A, &amp;B); Product = A * B; temp = Product; while(temp) &#123; digit = temp % 10; temp /= 10; result = result * 10 + digit; &#125; printf("%d\n", result); return 0;&#125; 1091 N-自守数Analysis注意读题，判断一个数是否自守，就是用这个数的最后几位构成的数字与原数字比较是否相等即可，而“最后几位”就是原数字的位数了，能得到这个细节（题目中的这些细节，真是叫人又爱又恨）后，这个题目就很简单了。本来以为，使用int可能会有测试点不过，结果没有，没设置大数的测试点么？嘿嘿，逃过一劫~ Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;bool Judge_Automorphic(int test_number, int original_number);int main(int argc, char const *argv[]) &#123; int M, N, K, each_item; bool flag; scanf("%d", &amp;M); while(M--) &#123; scanf("%d", &amp;K); flag = false; for(N = 1; N &lt; 10; N++) &#123; each_item = N * K * K; if( Judge_Automorphic(each_item, K) ) &#123; flag = true; break; &#125; &#125; if(flag) &#123; printf("%d %d\n", N, each_item); &#125; else &#123; puts("No"); &#125; &#125; return 0;&#125;bool Judge_Automorphic(int test_number, int original_number) &#123; bool flag = false; int mask = 1, temp; temp = original_number; while(temp) &#123; temp /= 10; mask *= 10; &#125; temp = test_number; temp %= mask; if(temp == original_number) &#123; flag = true; &#125; return flag;&#125;]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PTA基础编程题目集]]></title>
    <url>%2F2019%2F02%2F20%2FPTA%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E9%A2%98%E7%9B%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[Intro此Blog用来记录自己的”PTA基础编程题目集之旅(受虐)”。每道题目包含输入(输出)样例、输入(输出)说明、思路分析及得到AC的源码。所有AC代码已上传到GitHub上，点击PTA-Basical-Programming-problem-set即可获取。 Programming7-1 厘米换算英尺英寸如果已知英制长度的英尺$foot$和英寸$inch$的值，那么对应的米是$(foot+inch/12)×0.3048$。现在，如果用户输入的是厘米数，那么对应英制长度的英尺和英寸是多少呢？别忘了1英尺等于12英寸。 Input Specification输入在一行中给出1个正整数，单位是厘米。 Output Specification在一行中输出这个厘米数对应英制长度的英尺和英寸的整数值，中间用空格分开。 Sample Input &amp; Sample Output Input 1:170 Output 1:5 6 Analysis这道题目乍一看挺简单的，其实也有点绕(题目有点迷😒)。首先，要明确题目需要我们得到的结果是：给出的厘米对应换算为英尺、英寸的长度，也就是说，存在这样一个关系：$170CM≈5foot6inch$(题目只要求整数)，就好比是$103=20×5+3$，而我们要的值就是这个5和3。明白这个之后，就会发现，单纯的将$1foot=12inch$这个条按题目给的方程带入计算是得不出结果的，那么可以先求大的单位($foot$)的值，那么小单位($inch$)的值就是剩下的差了。接下来，还得找$foot$和$CM$的数值关系(这里也可以直接百度)，依据$(foot+inch/12)×0.3048$，这个式子计算结果的单位是$M$，而左边$(foot+inch/12)$的单位是$foot$，所以就可以知道：$1foot=30.48CM$，这样我们就可以直接算出正确的$foot$值了。 Code1234567891011#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int foot,inch,centimeters; scanf("%d", &amp;centimeters); // centimeters = 170; foot = centimeters / 30.48; inch = centimeters / 2.54 - 12*foot; printf("%d %d\n", foot, inch); return 0;&#125; 7-2 然后是几点有时候人们用四位数字表示一个时间，比如1106表示11点零6分。现在，你的程序要根据起始时间和流逝的时间计算出终止时间。读入两个数字，第一个数字以这样的四位数字表示当前时间，第二个数字表示分钟数，计算当前时间经过那么多分钟后是几点，结果也表示为四位数字。当小时为个位数时，没有前导的零，即5点30分表示为530。注意，第二个数字表示的分钟数可能超过60，也可能是负数。 Input Specification输入在一行中给出2个整数，分别是四位数字表示的起始时间、以及流逝的分钟数，其间以空格分隔。注意：在起始时间中，当小时为个位数时，没有前导的零，即5点30分表示为530；流逝的分钟数可能超过60，也可能是负数。 Output Specification输出四位数字表示的终止时间。题目保证起始时间和终止时间在同一天内。 Sample Input &amp; Sample Output Input 1:1120 110 Output 1:1310 Analysis简单题，求出总的分钟值，然后求出小时的值，在按照题目要求输出即可。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int start_time,waste_time; scanf("%d %d", &amp;start_time, &amp;waste_time); // start_time = 1120; waste_time = 110; int hours,minutes; minutes = start_time/100*60 + start_time%100 + waste_time; hours = minutes/60; minutes -= hours*60; printf("%d\n", hours*100+minutes); return 0;&#125; 7-3 逆序的三位数程序每次读入一个正3位数，然后输出按位逆序的数字。注意：当输入的数字含有结尾的0时，输出不应带有前导的0。比如输入700，输出应该是7。 Input Specification每个测试是一个3位的正整数。 Output Specification输出按位逆序的数。 Sample Input &amp; Sample Output Input 1:123 Output 1:321 Analysis这道题目很简单，考察数位拆分，在题目告诉已知3位数的情况下，可以直接进行数位拆分(一般题目都不会给输入数字的位数，而只给范围)；并且题目也已经给出了要注意的地方：700逆序后不能是007。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int n; scanf("%d", &amp;n); // n=700; int units,tens,hundred; units=n%10; tens=n/10%10; hundred=n/100; printf("%d\n", units*100+tens*10+hundred); return 0;&#125; 7-4 BCD解密BCD数是用一个字节来表达两位十进制的数，每四个比特表示一位。所以如果一个BCD数的十六进制是0x12，它表达的就是十进制的12。但是小明没学过BCD，把所有的BCD数都当作二进制数转换成十进制输出了。于是BCD的0x12被输出成了十进制的18了！现在，你的程序要读入这个错误的十进制数，然后输出正确的十进制数。提示：你可以把18转换回0x12，然后再转换回12。 Input Specification输入在一行中给出一个$[0, 153]$范围内的正整数，保证能转换回有效的BCD数，也就是说这个整数转换成十六进制时不会出现A-F的数字。 Output Specification输出对应的十进制数。 Sample Input &amp; Sample Output Input 1:18 Output 1:12 Analysis简单题，题目给的提示很明显，单独出去十进制数的个位和十位后，直接组合计算即可得到。 Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int BCD; scanf("%d", &amp;BCD); // BCD=18; int units,tens; units=BCD%16; tens=BCD/16; printf("%d\n", tens*10+units); return 0;&#125; 7-5 表格输出本题要求编写程序，按照规定格式输出表格。 Input Specification本题目没有输入。 Output Specification要求严格按照给出的格式输出下列表格：123456789------------------------------------Province Area(km2) Pop.(10K)------------------------------------Anhui 139600.00 6461.00Beijing 16410.54 1180.70Chongqing 82400.00 3144.23Shanghai 6340.50 1360.26Zhejiang 101800.00 4894.00------------------------------------ Analysis送分题，直接原样输出即可。 Code1234567891011121314#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; printf("------------------------------------\n"); printf("Province Area(km2) Pop.(10K)\n"); printf("------------------------------------\n"); printf("Anhui 139600.00 6461.00\n"); printf("Beijing 16410.54 1180.70\n"); printf("Chongqing 82400.00 3144.23\n"); printf("Shanghai 6340.50 1360.26\n"); printf("Zhejiang 101800.00 4894.00\n"); printf("------------------------------------\n"); return 0;&#125; 7-6 混合类型数据格式化输入本题要求编写程序，顺序读入浮点数1、整数、字符、浮点数2，再按照字符、整数、浮点数1、浮点数2的顺序输出。 Input Specification输入在一行中顺序给出浮点数1、整数、字符、浮点数2，其间以1个空格分隔。 Output Specification在一行中按照字符、整数、浮点数1、浮点数2的顺序输出，其中浮点数保留小数点后2位。 Sample Input &amp; Sample Output Input:2.12 88 c 4.7 Output:c 88 2.12 4.70 Analysis按题目要求输入输出即可。 Code12345678910#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float a1,a2; int b; char c; scanf("%f %d %c %f", &amp;a1, &amp;b, &amp;c, &amp;a2); printf("%c %d %.2f %.2f\n", c, b, a1, a2); return 0;&#125; 7-7 12-24小时制编写一个程序，要求用户输入24小时制的时间，然后显示12小时制的时间。 Input Specification输入在一行中给出带有中间的:符号（半角的冒号）的24小时制的时间，如12:34表示12点34分。当小时或分钟数小于10时，均没有前导的零，如5:6表示5点零6分。提示：在scanf的格式字符串中加入:，让scanf来处理这个冒号。 Output Specification在一行中输出这个时间对应的12小时制的时间，数字部分格式与输入的相同，然后跟上空格，再跟上表示上午的字符串AM或表示下午的字符串PM。如5:6 PM表示下午5点零6分。注意，在英文的习惯中，中午12点被认为是下午，所以24小时制的12:00就是12小时制的12:0 PM；而0点被认为是第二天的时间，所以是0:0 AM。 Sample Input &amp; Sample Output Input:21:11 Output:9:11 PM Analysis根据输出格式进行输出即可，注意中午12点被认为是PM；输入只需注意:即可。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int hours,minutes; scanf("%d:%d", &amp;hours, &amp;minutes); // hours = 21, minutes = 11; if(hours == 12)&#123; printf("%d:%d PM\n", hours, minutes); &#125;else if(hours &lt; 12)&#123; printf("%d:%d AM\n", hours, minutes); &#125;else&#123; printf("%d:%d PM\n", hours-12, minutes); &#125; return 0;&#125; 7-8 超速判断模拟交通警察的雷达测速仪。输入汽车速度，如果速度超出60 mph，则显示Speeding，否则显示OK。 Input Specification输入在一行中给出1个不超过500的非负整数，即雷达测到的车速。 Output Specification在一行中输出测速仪显示结果，格式为：Speed: V - S，其中V是车速，S是Speeding、或者是OK。 Sample Input &amp; Sample Output Input 1:40 Output 1:Speed: 40 - OK Input 2:75 Output 2:Speed: 75 - Speeding Analysis根据题目要求直接输出即可。 Code12345678910111213#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int speed; scanf("%d", &amp;speed); // speed=75; if(speed &gt; 60)&#123; printf("Speed: %d - Speeding\n", speed); &#125;else&#123; printf("Speed: %d - OK\n", speed); &#125; return 0;&#125; 7-9 用天平找小球三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。 Input Specification输入在一行中给出3个正整数，顺序对应球A、B、C的重量。 Output Specification在一行中输出唯一的那个不一样的球。 Sample Input &amp; Sample Output Input:1 1 2 Output:C Analysis根据题目条件，如果要输出唯一的那个不一样的球，其实就只有三种情况，直接输出就好。 Code123456789101112#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,C; scanf("%d %d %d", &amp;A, &amp;B, &amp;C); // A=1, B=1, C=2; if(A != B &amp;&amp; A != C) printf("A\n"); if(B != A &amp;&amp; B != C) printf("B\n"); if(C != A &amp;&amp; C != B) printf("C\n"); return 0;&#125; 7-10 计算工资某公司员工的工资计算方法如下：一周内工作时间不超过40小时，按正常工作时间计酬；超出40小时的工作时间部分，按正常工作时间报酬的1.5倍计酬。员工按进公司时间分为新职工和老职工，进公司不少于5年的员工为老职工，5年以下的为新职工。新职工的正常工资为30元/小时，老职工的正常工资为50元/小时。请按该计酬方式计算员工的工资。 Input Specification输入在一行中给出2个正整数，分别为某员工入职年数和周工作时间，其间以空格分隔。 Output Specification在一行输出该员工的周薪，精确到小数点后2位。 Sample Input &amp; Sample Output Input 1:5 40 Output 1:2000.00 Input 2:3 50 Output 2:1650.00 Analysis根据题目条件，针对不同情况计算工资即可，实质为分段函数求值。 Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int years,hours; float wage; scanf("%d %d", &amp;years, &amp;hours); // years=3, hours=50; if(years &gt;= 5)&#123; if(hours &gt; 40)&#123; wage = 50*40 + 1.5*50*(hours - 40); &#125;else&#123; wage = 50*hours; &#125; &#125;else&#123; if(hours &gt; 40)&#123; wage = 30*40 + 1.5*30*(hours - 40); &#125;else&#123; wage = 30*hours; &#125; &#125; printf("%.2f\n", wage); return 0;&#125; 7-11 分段计算居民水费为鼓励居民节约用水，自来水公司采取按用水量阶梯式计价的办法，居民应交水费$y$（元）与月用水量$x$（吨）相关：当$x$不超过15吨时，$y=4x/3$；超过后，$y=2.5x−17.5$。请编写程序实现水费的计算。 Input Specification输入在一行中给出非负实数$x$。 Output Specification在一行输出应交的水费，精确到小数点后2位。 Sample Input &amp; Sample Output Input 1:12 Output 1:16.00 Input 2:16 Output 2:22.50 Analysis根据题目条件，针对不同情况计算水费即可，实质为分段函数求值。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int x; scanf("%d", &amp;x); // x=16; float water_fee; if(x &lt;= 15)&#123; water_fee = 4.0*x/3; &#125;else&#123; water_fee = 2.5*x - 17.5; &#125; printf("%.2f\n", water_fee); return 0;&#125; 7-12 两个数的简单计算器本题要求编写一个简单计算器程序，可根据输入的运算符，对2个整数进行加、减、乘、除或求余运算。题目保证输入和输出均不超过整型范围。 Input Specification输入在一行中依次输入操作数1、运算符、操作数2，其间以1个空格分隔。操作数的数据类型为整型，且保证除法和求余的分母非零。 Output Specification当运算符为+、-、*、/、%时，在一行输出相应的运算结果。若输入是非法符号（即除了加、减、乘、除和求余五种运算符以外的其他符号）则输出ERROR。 Sample Input &amp; Sample output Input 1:-7 / 2 Output 1:-3 Input 2:3 &amp; 6 Output 2:ERROR Analysis针对不同的情况使用switch语句分别处理即可。 Code12345678910111213141516#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int a, b; char c; scanf("%d %c %d", &amp;a, &amp;c, &amp;b); switch(c)&#123; case '+': printf("%d\n", a + b);break; case '-': printf("%d\n", a - b);break; case '*': printf("%d\n", a * b);break; case '/': printf("%d\n", a / b);break; case '%': printf("%d\n", a % b);break; default : printf("ERROR\n"); &#125; return 0;&#125; 7-13 日K蜡烛图股票价格涨跌趋势，常用蜡烛图技术中的K线图来表示，分为按日的日K线、按周的周K线、按月的月K线等。以日K线为例，每天股票价格从开盘到收盘走完一天，对应一根蜡烛小图，要表示四个价格：开盘价格Open（早上刚刚开始开盘买卖成交的第1笔价格）、收盘价格Close（下午收盘时最后一笔成交的价格）、中间的最高价High和最低价Low。 如果Close&lt;Open，表示为BW-Solid（即“实心蓝白蜡烛”）；如果Close&gt;Open，表示为R-Hollow（即“空心红蜡烛”）；如果Open等于Close，则为R-Cross（即“十字红蜡烛”）。如果Low比Open和Close低，称为Lower Shadow（即“有下影线”），如果High比Open和Close高，称为Upper Shadow（即“有上影线”）。请编程序，根据给定的四个价格组合，判断当日的蜡烛是一根什么样的蜡烛。 Input Specification输入在一行中给出4个正实数，分别对应Open、High、Low、Close，其间以空格分隔。 Output Specification在一行中输出日K蜡烛的类型。如果有上、下影线，则在类型后加上with 影线类型。如果两种影线都有，则输出with Lower Shadow and Upper Shadow。 Sample Input &amp; Sample output Input 1:5.110 5.250 5.100 5.105 Output 1:BW-Solid with Lower Shadow and Upper Shadow Input 2:5.110 5.110 5.110 5.110 Output 2:R-Cross Input 3:5.110 5.125 5.112 5.126 Output 3:R-Hollow Analysis先判断图形类型，在判断是否包含影线；按照下面的代码的思路，需要将既有下影线又有上影线的情况放在第一位进行判断。 Code123456789101112131415161718192021222324#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float open,high,low,close; scanf("%f %f %f %f", &amp;open, &amp;high, &amp;low, &amp;close); if(close &lt; open)&#123; printf("BW-Solid"); &#125;else if(close == open)&#123; printf("R-Cross"); &#125;else&#123; printf("R-Hollow"); &#125; if(low &lt; open &amp;&amp; low &lt; close &amp;&amp; high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Lower Shadow and Upper Shadow\n"); &#125;else if(high &gt; open &amp;&amp; high &gt;close)&#123; printf(" with Upper Shadow\n"); &#125;else if(low &lt; open &amp;&amp; low &lt; close)&#123; printf(" with Lower Shadow\n"); &#125;else&#123; printf("\n"); &#125; return 0;&#125; 7-14 求整数段和给定两个整数A和B，输出从A到B的所有整数以及这些数的和。 Input Specification输入在一行中给出2个整数A和B，其中$−100≤A≤B≤100$，其间以空格分隔。 Output Specification首先顺序输出从A到B的所有整数，每5个数字占一行，每个数字占5个字符宽度，向右对齐。最后在一行中按Sum=X的格式输出全部数字的和X。 Sample Input &amp; Sample output Input:-3 8 Output: -3 -2 -1 0 1 2 3 4 5 6 7 8Sum = 30 Analysis考察格式输出和求和，输出时注意格式即可，最好将数字和换行分开输出。 Code123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,B,i,sum; scanf("%d %d", &amp;A, &amp;B); // A=1, B=5; for(i=0, sum=0; A&lt;=B; A++, i++) &#123; if(i%5 == 0 &amp;&amp; i != 0) printf("\n"); printf("%5d", A); sum+=A; &#125; printf("\nSum = %d\n", sum); return 0;&#125; 7-15 计算圆周率根据下面关系式，求圆周率的值，直到最后一项的值小于给定阈值。${\pi\over2}=1+{1\over3}+{2!\over{3×5}}+{3!\over{3×5×7}}+{\cdots}+{n!\over{3×5×7×{\cdots}×(2×n+1)}}$ Input Specification输入在一行中给出小于1的阈值。 Output Specification在一行中输出满足阈值条件的近似圆周率，输出到小数点后6位。 Sample Input &amp; Sample output Input:0.01 Output:3.132157 Analysis本题比较直观，但需要细心一点。先分析一下给出的关系式的规律，左边常量，我们只看右边就行；假设右边项数是从1开始的，那么$a_1=1$，$a_2={1\over3}$，$a_3={2!\over3×5}$，…，把$a_1$和$a_2$换个写法就是$a_1={0!\over1}$、$a_2={1!\over{1×3}}$，这下就可以看出规律了，与后面的通项公式是一致的。如果首项的分子从0开始，那么就无法通过循环自动完成阶乘的计算了（或者单独写一个阶乘函数，这样就能从0开始取值了），所以我们直接从$a_1$开始计算，让$\pi$的初始值就为1.0；输出结果时，别忘记了要乘上2倍。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; float pi=1.0,denominator=3.0,member=1.0,each_item=0.0,i=2.0; float threshold; scanf("%f", &amp;threshold); // threshold=0.01; do&#123; each_item = member/denominator; pi+=each_item; member*=i; denominator*=(2*i+1); i++; &#125;while(each_item &gt; threshold); printf("%.6f\n", 2*pi); return 0;&#125; 7-16 求符合给定条件的整数集给定不超过6的正整数A，考虑从A开始的连续4个数字。请输出所有由它们组成的无重复数字的3位数。 Input Specification输入在一行中给出A。 Output Specification输出满足条件的的3位数，要求从小到大，每行6个整数。整数间以空格分隔，但行末不能有多余空格。 Sample Input &amp; Sample output Input:2 Output:234 235 243 245 253 254324 325 342 345 352 354423 425 432 435 452 453523 524 532 534 542 543 Analysis按照题目的意思，将需要输出的三位数，分别输出即可；也可以直接输出一个百位数，但是那样需要计算，会稍微麻烦一点。按照下面的代码，当不同位的数字存在相同的时候，就用continue;语句跳出本次循环，i==j的判断也可以在第三层循环内做，即：改为k==j || k==i || i==j，但当i==j的时候就会运行多次判断了。 Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int A,i,j,k,count; scanf("%d", &amp;A);// A=2; count=0; for(i=A; i&lt;A+4; i++) &#123; for(j=A; j&lt;A+4; j++)&#123; if(i == j) continue; else&#123; for(k=A; k&lt;A+4; k++) &#123; if(k==j || k==i) continue; else&#123; printf("%d%d%d", i, j, k); count++; if(count%6 == 0) printf("\n"); else printf(" "); &#125; &#125; &#125; &#125; &#125; return 0;&#125; 7-17 爬动的蠕虫一条蠕虫长1寸，在一口深为N寸的井的底部。已知蠕虫每1分钟可以向上爬U寸，但必须休息1分钟才能接着往上爬。在休息的过程中，蠕虫又下滑了D寸。就这样，上爬和下滑重复进行。请问，蠕虫需要多长时间才能爬出井？这里要求不足1分钟按1分钟计，并且假定只要在某次上爬过程中蠕虫的头部到达了井的顶部，那么蠕虫就完成任务了。初始时，蠕虫是趴在井底的（即高度为0）。 Input Specification输入在一行中顺序给出3个正整数N、U、D，其中D&lt;U，N不超过100。 Output Specification在一行中输出蠕虫爬出井的时间，以分钟为单位。 Sample Input &amp; Sample output Input:12 3 1 Output:11 Analysis找规律，先要明确”蚯蚓”整个爬行的过程，在第一分钟会爬行U寸，第二分钟会下滑D寸，第二分钟完后，蚯蚓一共的爬行距离就是U-D，第三分钟的时候，蚯蚓爬行U寸，总距离是2*U-D，第四分钟就是2*U-2*D…。可以发现，U和D的系数之和就是当前的时刻，找到这个规律之后就好办了。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,U,D; scanf("%d%d%d", &amp;N, &amp;U, &amp;D); // N=12, U=3, D=1; int i,j,times; for(i=1, j=0; N&lt;=100; i++, j++) &#123; if(i*U - j*D &gt;= N)&#123; times = i+j; break; &#125; &#125; printf("%d\n", times); return 0;&#125; 7-18 二分法求多项式单根二分法求函数根的原理为：如果连续函数$f(x)$在区间$[a,b]$的两个端点取值异号，即$f(a)f(b)&lt;0$，则它在这个区间内至少存在1个根$r$，即$f(r)=0$。二分法的步骤为：检查区间长度，如果小于给定阈值，则停止，输出区间中点$(a+b)/2$；否则如果$f(a)f(b)&lt;0$，则计算中点的值$f((a+b)/2)$；如果$f((a+b)/2)$正好为0，则$(a+b)/2$就是要求的根；否则如果$f((a+b)/2)$与$f(a)$同号，则说明根在区间$[(a+b)/2,b]$，令$a=(a+b)/2$，重复循环；如果$f((a+b)/2)$与$f(b)$同号，则说明根在区间$[a,(a+b)/2]$，令$b=(a+b)/2$，重复循环。本题目要求编写程序，计算给定3阶多项式$f(x)=a_3x^3+a_2x^2+a_1x+a_0$在给定区间$[a,b]$内的根。 Input Specification输入在第1行中顺序给出多项式的4个系数$a_3$、$a_2$、$a_1$、$a_0$，在第2行中顺序给出区间端点$a$和$b$。题目保证多项式在给定区间内存在唯一单根。 Output Specification在一行中输出该多项式在该区间内的根，精确到小数点后2位。 Sample Input &amp; Sample Output Input:3 -1 -3 1-0.5 0.5 Output:0.33 Analysis二分法求多项式单根，所依据的原理其实是函数的零点性质：函数零点两边的函数值是异号的，所以零点两边函数值的乘积小于0。明白这个原理之后，我们按照题目给的算法进行计算即可；既然题目已经给出了函数式，可以直接封装成一个专门求值的函数，函数的系数就用全局变量来保存即可，这样代码的主体就很清晰；f(left)和f(right)这两个函数值为0的情况是单独的，并不能用if-else组成对立关系，注意题目对精度的要求是小数点后2位，所以左端点和右端点的差值要大于0.01，若没有这个条件，提交时会超时。 Code123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;float a3,a2,a1,a0;float Cal_polynomial(float n);int main(int argc, char const *argv[])&#123; float left,right,mid; scanf("%f %f %f %f %f %f", &amp;a3, &amp;a2, &amp;a1, &amp;a0, &amp;left, &amp;right); while(Cal_polynomial(left) * Cal_polynomial(right) &lt;= 0 &amp;&amp; (right-left) &gt; 0.01) &#123; if(Cal_polynomial(left) == 0)&#123; printf("%.2f\n", left); return 0; &#125; if(Cal_polynomial(right) == 0)&#123; printf("%.2f\n", right); return 0; &#125; mid=(left+right)/2; if(Cal_polynomial(left) * Cal_polynomial(mid) &gt; 0)&#123; left = mid; &#125;else&#123; right = mid; &#125; &#125; printf("%.2f\n", (right+left)/2); return 0;&#125;float Cal_polynomial(float n)&#123; float ret=0.0; ret = a3*n*n*n + a2*n*n + a1*n + a0; return ret;&#125; 7-19 支票面额一个采购员去银行兑换一张y元f分的支票，结果出纳员错给了f元y分。采购员用去了n分之后才发觉有错，于是清点了余额尚有2y元2f分，问该支票面额是多少？ Input Specification输入在一行中给出小于100的正整数n。 Output Specification在一行中按格式y.f输出该支票的原始面额。如果无解，则输出No Solution。 Sample Input &amp; Sample Output Input 1:23 Output 1:25.51 Input 2:22 Output 2:No Solution Analysis本题乍一看挺懵逼的😓，其实是道数学题。多读几遍题目，可以列出方程：100*f+y-n=200*y+2*f(这里的元、分应该就是RMB中的单位了)，化简得：98*f-199*y=n，依题意，n&lt;100且n&gt;0，说明98*f-199*y&gt;0，这里需要放缩一下，即：98*f-199*y ≈ 100*f-200*y = f-2*y &gt; 0，就是f&gt;2*y了，而f在本题中的单位是分，所以0&lt;f&lt;100(能想到的唯一解释…)，所以就得到：0&lt;f&lt;100, 0&lt;y&lt;50，这就是循环的条件。有点坑爹~ Code12345678910111213141516171819202122#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int y,f,n,flag=0; scanf("%d", &amp;n); // n=23; for(y=0; y&lt;50; y++) &#123; for(f=0; f&lt;100; f++) &#123; if(98*f - 199*y == n)&#123; printf("%d.%d\n", y, f); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-20 打印九九口诀表下面是一个完整的下三角九九口诀表：1234567891*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 1*5=5 2*5=10 3*5=15 4*5=20 5*5=25 1*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=36 1*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=49 1*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=64 1*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 本题要求对任意给定的一位正整数N，输出从11到NN的部分口诀表。 Input Specification输入在一行中给出一个正整数N（1≤N≤9）。 Output Specification输出下三角N*N部分口诀表，其中等号右边数字占4位、左对齐。 Sample Input &amp; Sample output Input:4 Output:12341*1=1 1*2=2 2*2=4 1*3=3 2*3=6 3*3=9 1*4=4 2*4=8 3*4=12 4*4=16 Analysis分析一下，九九乘法表的组成，两个值和这两个值的乘积，从这里，应该可以想到双重循环；在仔细观察一下样例，组后的项中的因子等于输入样例的N值的，所以可以推断，因子的值是小于等于N的；另外，还可以发现，第二个因子的值是小于等于第一个因子的值的；按照以上的思路，在注意一下输出格式，就可以拿下这道题了，注意输出的格式，换行可以放在第二层循环内执行，条件改为j == i即可。 Code1234567891011121314151617#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,i,j; scanf("%d", &amp;N); // N=4; for(i=1; i&lt;=N; i++) &#123; for(j=1; j&lt;=i; j++)&#123; printf("%d*%d=%-4d", j, i, i*j); &#125; if(j-1 == i)&#123; printf("\n"); &#125; &#125; return 0;&#125; 7-21 求特殊方程的正整数解本题要求对任意给定的正整数N，求方程$X^2​+Y^2=N$的全部正整数解。 Input Specification输入在一行中给出正整数N（≤10000） Output Specification输出方程$X^2+Y^2=N$的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出No Solution。 Sample Input &amp; Sample Output Input 1:884 Output 1:10 2820 22 Input 2:11 Output 2:No Solution Analysis此题不难，看题目形式也是道数学题，大致分析一下，N = X^2+Y^2 &gt;= 2*x*y，既有2*x*y &lt;= N &lt;= 10000，化简得xy &lt;= 5000，又知N的最大值是10000，开方是100，而X和Y的平方之和小于等于N，所以X和Y都不大于100；依据题目的要求，需要按照X递增的顺序进行输出，所以直接以Y为最大值，X从最小开始取值就可以了（也有其他做法）。之所以写break;的原因是：在这道题目中，当X和N确定后，Y也是确定的，同理Y和N确定后，X也是确定的了。 Code1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N; scanf("%d", &amp;N);// N=884; int X,Y,flag=0; for(Y=100; Y&gt;0; Y--) &#123; for(X=1; X&lt;=Y; X++) &#123; if(X*X + Y*Y == N &amp;&amp; (X*Y) &lt;= 5000)&#123; printf("%d %d\n", X, Y); flag=1; break; &#125; &#125; &#125; if(!flag)&#123; printf("No Solution\n"); &#125; return 0;&#125; 7-22 龟兔赛跑乌龟与兔子进行赛跑，跑场是一个矩型跑道，跑道边可以随地进行休息。乌龟每分钟可以前进3米，兔子每分钟前进9米；兔子嫌乌龟跑得慢，觉得肯定能跑赢乌龟，于是，每跑10分钟回头看一下乌龟，若发现自己超过乌龟，就在路边休息，每次休息30分钟，否则继续跑10分钟；而乌龟非常努力，一直跑，不休息。假定乌龟与兔子在同一起点同一时刻开始起跑，请问T分钟后乌龟和兔子谁跑得快？ Input Specification输入在一行中给出比赛时间T（分钟）。 Output Specification在一行中输出比赛的结果：乌龟赢输出@_@，兔子赢输出^_^，平局则输出-_-；后跟1空格，再输出胜利者跑完的距离。 Sample Input &amp; Sample output Input:242 Output:@_@ 726 Analysis这道题的难点在如何计算兔子在T时间内跑过的距离。先看乌龟，乌龟在T时间内跑过的距离比较简单，因为乌龟是不会休息的，所以其距离就是其速度和T的乘积；而兔子会休息，并且是每隔10分钟确认比乌龟快后休息，所以，需要在每个以10分钟为时间间隔的时间点进行判断，与之而来的另外一个问题就是兔子不是休息10分钟，而是休息30分钟，所以，还需要一个表示兔子仍然在休息的标志位，这个标志位会在乌龟前进，兔子休息时，自动减少。当减少到0时，兔子会再次确认是否超过乌龟。输出结果时，注意平局的时候也要输出跑完的距离；并且时间要从0时刻开始，即时间区间为$[0,T-1]$，若区间为$[1,T]$，尽管区间长度时一致的，在30分钟时，兔子的距离就是81，乌龟的距离就是90了，但实际上应该是相等的，即平局。 Code12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int rabbit_dis=0,turtle_dis=0,rabbit_spd=9,turtle_spd=3,T; scanf("%d", &amp;T); // T=30; int i,rabbit_on=1,break_times=0; for(i=0; i&lt;T; i++) &#123; if(i%10 == 0)&#123; if(rabbit_dis &gt; turtle_dis &amp;&amp; break_times == 0)&#123; rabbit_on=0; break_times=30; &#125;else&#123; rabbit_on=1; &#125; &#125; if(rabbit_on &amp;&amp; break_times == 0)&#123; rabbit_dis+=rabbit_spd; &#125; turtle_dis+=turtle_spd; if(break_times)&#123; break_times--; &#125; &#125; if(turtle_dis &gt; rabbit_dis)&#123; printf("@_@ %d\n", turtle_dis); &#125;else if(turtle_dis == rabbit_dis)&#123; printf("-_- %d\n", turtle_dis); &#125;else&#123; printf("^_^ %d\n", rabbit_dis); &#125; return 0;&#125; 7-23 币值转换输入一个整数（位数不超过9位）代表一个人民币值（单位为元），请转换成财务要求的大写中文格式。如23108元，转换后变成“贰万叁仟壹百零捌”元。为了简化输出，用小写英文字母a-j顺序代表大写数字0-9，用S、B、Q、W、Y分别代表拾、百、仟、万、亿。于是23108元应被转换输出为“cWdQbBai”元。 Input Specification输入在一行中给出一个不超过9位的非负整数。 Output Specification在一行中输出转换后的结果。注意“零”的用法必须符合中文习惯。 Sample Input &amp; Sample output Input 1:813227345 Output 1:iYbQdBcScWhQdBeSf Input 2:6900 Output 2:gQjB Analysis这道题有点难😑，借鉴了一下ccDLIyy的思路，并修改了其中一些代码。如果本题只是将输入的数字的每一位拆分出来的话，就十分简单，但是还需要按照中文习惯输出这些数字的读法，就比较麻烦了。首先，需要一个数组来单独存放每一位数，因为，如果不这样，就无法对中文习惯进行判断了(即当前位上的数字非0，前一位或者后一位为0的情况下，此时的读法)；按照这个思路，不妨直接用数组建立起数字和字母的映射关系，这样后面调用也方便一些(不得不说，这个想法很高明也很省事)；另外，在写代码之前，先大概分析一下平常我们都这些数字的读法：23108是读作二万三千一百零八，813227345是读作八亿一千三百二十二万七千三百四十五，从这里，可以看出，万是在数字位数大于等于5的时候才会输出，而亿是在数字位数大于等于9的时候才会输出，在每四位内，进行输出的格式字符都是十、百和千，所以，需要根据位数进行不同情况的判断。另外，在下面的代码中对于100000001这种情况输出的结果是一亿零零零一，对于10这种情况输出的结果是一十。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;#include &lt;string.h&gt;char num2letter[11]="abcdefghij";char units[4]="QBS";void exchange(int num[], int n);int main(int argc, char const *argv[])&#123; char number[10]; scanf("%s", number); int i,len=strlen(number); int num[9]=&#123;0&#125;; for(i=0; i&lt;len; i++)&#123; num[i]=number[i] - '0'; &#125; if(len &lt;= 4)&#123; exchange(num, len-1); &#125;else if(len &lt;= 8)&#123; exchange(num, len-5); printf("W"); exchange(num+len-4, 3); &#125;else&#123; printf("%cY", num2letter[num[0]]); exchange(num+1, 3); if(num[1]!=0 &amp;&amp; num[2]!=0 &amp;&amp; num[3]!=0 &amp;&amp; num[4]!=0)&#123; printf("W"); &#125; if(num[len-4] == 0)&#123; printf("%c", num2letter[0]); &#125; exchange(num+5, 3); &#125; return 0;&#125;void exchange(int num[], int n)&#123; int index = 0; while(num[index] == 0)&#123; index++; &#125; if(num[index-1] == 0 &amp;&amp; index != 0)&#123; printf("%c", num2letter[0]); &#125; while(index &lt;= n) &#123; if(num[index] != 0 &amp;&amp; index &lt;= n)&#123; if(index != n)&#123; printf("%c%c", num2letter[num[index]], units[4-n-1+index]); &#125;else&#123; printf("%c", num2letter[num[index]]); &#125; &#125;else if(num[index] == 0 &amp;&amp; num[index+1] != 0 &amp;&amp; index &lt;= n-1)&#123; printf("%c", num2letter[0]); &#125; index++; &#125;&#125; 7-24 约分最简分式分数可以表示为分子/分母的形式。编写一个程序，要求用户输入一个分数，然后将其约分为最简分式。最简分式是指分子和分母不具有可以约分的成分了。如6/12可以被约分为1/2。当分子大于分母时，不需要表达为整数又分数的形式，即11/8还是11/8；而当分子分母相等时，仍然表达为1/1的分数形式。 Input Specification输入在一行中给出一个分数，分子和分母中间以斜杠/分隔，如：12/34表示34分之12。分子和分母都是正整数（不包含0，如果不清楚正整数的定义的话）。提示：在scanf的格式字符串中加入/，让scanf来处理这个斜杠。 Output Specification在一行中输出这个分数对应的最简分式，格式与输入的相同，即采用分子/分母的形式表示分数。如5/6表示6分之5。 Sample Input &amp; Sample output Input:66/120 Output:11/20 Analysis这道题比较简单，只要知道分子/分母约分到最简形式直接除以二者的最大公约数即可。所以，直接求最大公约数即可，使用辗转相除法或更相减损法皆可，递归与否也皆可。 Code12345678910111213141516171819202122232425#include &lt;stdio.h&gt;int gcd(int a, int b);int main(int argc, char const *argv[])&#123; int member,denominator; scanf("%d/%d", &amp;member, &amp;denominator); // member=66, denominator=120; printf("%d/%d\n", member/gcd(member, denominator), denominator/gcd(member, denominator)); return 0;&#125;int gcd(int a, int b)&#123; if(a &gt; b) return gcd(b, a); int temp; while(a) &#123; temp=b%a; b=a; a=temp; &#125; return b; /* other method: use recursion. return a==0?b:gcd(b%a, a); */&#125; 7-25 念数字输入一个整数，输出每个数字对应的拼音。当整数为负数时，先输出fu字。十个数字对应的拼音如下：123456789100: ling1: yi2: er3: san4: si5: wu6: liu7: qi8: ba9: jiu Input Specification输入在一行中给出一个整数，如：1234。提示：整数包括负数、零和正数。 Output Specification在一行中输出这个整数对应的拼音，每个数字的拼音之间用空格分开，行末没有最后的空格。如yi er san si。 Sample Input &amp; Sample output Input:-600 Output:fu liu ling ling Analysis此题不难，只需对注意负数和输出的格式即可；可以直接当作字符处理，也可以用数位拆分的思路来做，可能稍微会麻烦一点；可以使用指针，也可以不使用指针。 Code12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; char num[100]; scanf("%s", num); char *p = num; if(*p == '-')&#123; printf("fu "); p++; &#125; for(; *p != '\0'; p++) &#123; switch(*p) &#123; case '0': printf("ling");break; case '1': printf("yi");break; case '2': printf("er");break; case '3': printf("san");break; case '4': printf("si");break; case '5': printf("wu");break; case '6': printf("liu");break; case '7': printf("qi");break; case '8': printf("ba");break; case '9': printf("jiu");break; default: continue; &#125; if(*(p+1) == '\0') printf("\n"); else printf(" "); &#125; return 0;&#125; 7-26 单词长度你的程序要读入一行文本，其中以空格分隔为若干个单词，以.结束。你要输出每个单词的长度。这里的单词与语言无关，可以包括各种符号，比如it&#39;s算一个单词，长度为4。注意，行中可能出现连续的空格；最后的.不计算在内。 Input Specification输入在一行中给出一行文本，以.结束提示：用scanf(&quot;%c&quot;,...);来读入一个字符，直到读到.为止。 Output Specification在一行中输出这行文本对应的单词的长度，每个长度之间以空格隔开，行末没有最后的空格。 Sample Input &amp; Sample Output Input:It’s great to see you here. Output:4 5 2 3 3 4 Analysis本题不难，对每一个单词的字符进行遍历即可，每次扫描到空格，就跳过，一旦扫描到下一个单词的第一个字母，就输出上一个单词的长度。注意格式，空句子不需要输出0，直接输出\n即可。 Code123456789101112131415161718192021#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int length=0,flag=0; char ch; while((ch=getchar()) != '.') &#123; if(ch != ' ')&#123; if(length &gt; 0 &amp;&amp; flag &gt; 0)&#123; printf("%d ", length); length=0; &#125; length++; flag=0; &#125; if(ch == ' ') flag++; &#125; if(length &gt; 0) printf("%d\n", length); else printf("0\n"); return 0;&#125; 7-27 冒泡法排序将N个整数按从小到大排序的冒泡排序法是这样工作的：从头到尾比较相邻两个元素，如果前面的元素大于其紧随的后面元素，则交换它们。通过一遍扫描，则最后一个元素必定是最大的元素。然后用同样的方法对前N−1个元素进行第二遍扫描。依此类推，最后只需处理两个元素，就完成了对N个数的排序。本题要求对任意给定的K（&lt;N），输出扫描完第K遍后的中间结果数列。 Input Specification输入在第1行中给出N和K（1≤K&lt;N≤100），在第2行中给出N个待排序的整数，数字间以空格分隔。 Output Specification在一行中输出冒泡排序法扫描完第K遍后的中间结果数列，数字间以空格分隔，但末尾不得有多余空格。 Sample Input &amp; Sample Output Input:6 22 3 5 1 6 4 Output:2 1 3 4 5 6 Analysis此题不难，算是帮助熟悉冒泡排序算法的题吧，按照题目给出的算法，使用两层循环，直接进行处理即可。注意，按照题目的要求，在交换两个相邻的元素的时候，只能交换整个数组内的元素。另外，按照下面的代码，如果不加条件j+1 &lt; N，将6排到最后面后，数字6仍然会和其下一位进行交换。或者不加条件j+1 &lt; N，就需要将第二层循环的条件改为j&lt;N-i Code123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); int array[105]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%d", &amp;array[i]); &#125; for(i=0; i&lt;K; i++) &#123; int temp=0; for(j=0; j&lt;N; j++) /*j&lt;N -&gt; j&lt;N-i-1*/ &#123; if(array[j] &gt; array[j+1] &amp;&amp; j+1 &lt; N)&#123; /*delete the "&amp;&amp; j+1 &lt; N"*/ temp=array[j]; array[j]=array[j+1]; array[j+1]=temp; &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; if(i == N-1) printf("%d\n", array[i]); else printf("%d ", array[i]); &#125; return 0;&#125; 7-28 猴子选大王一群猴子要选新猴王。新猴王的选择方法是：让N只候选猴子围成一圈，从某位置起顺序编号为1~N号。从第1号开始报数，每轮从1报到3，凡报到3的猴子即退出圈子，接着又从紧邻的下一只猴子开始同样的报数。如此不断循环，最后剩下的一只猴子就选为猴王。请问是原来第几号猴子当选猴王？ Input Specification输出在一行中给一个正整数N(≤1000)。 Output Specification在一行中输出当选猴王的编号。 Sample Input &amp; Sample Output Input:11 Output:7 Analysis这道题，属于“套路题”，实质是“约瑟夫环”问题；以下的代码介绍了三种方法：回溯法(严格意义上也许不是)、递归和迭代，分别参考了liuxuquan_、Little_Sword和d4shman的代码。感觉使用回溯法是最容易理解的，对于使用递归和迭代的方法，原理是一样的，理解一种了，另外一种也就没问题了；好像还可以通过其他的方式来做，这里暂时先不深究。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#define maxn 1005int josephus_recursion(int n, int m);int main(int argc, char const *argv[])&#123; /* method 1: use backtracking int N; scanf("%d", &amp;N); // N=11; int i,monkey_array[maxn]=&#123;0&#125;; for(i=1; i&lt;=N; i++)&#123; monkey_array[i]=i; &#125; int j,k,temp; for(i=N; i&gt;=1; i--) &#123; for(j=1; j&lt;=3; j++)&#123; temp=monkey_array[1]; for(k=1; k&lt;=i; k++)&#123; monkey_array[k]=monkey_array[k+1]; &#125; monkey_array[i]=temp; &#125; &#125; printf("%d\n", monkey_array[1]); */ /* method 2: use recursion int N; N=11; if(!N) return 0; int result = josephus_recursion(N,3); printf("%d\n", result+1); */ /* method 3: use iteration*/ int i,N,result=0; scanf("%d", &amp;N); for(i=2; i&lt;=N; i++) &#123; result=(result + 3)%i; &#125; printf("%d\n", result+1); return 0;&#125;int josephus_recursion(int n, int m)&#123; if(n == 1) return 0; else return (josephus_recursion(n-1, m)+m)%n;&#125; 7-29 删除字符串中的子串输入2个字符串S1和S2，要求删除字符串S1中出现的所有子串S2，即结果字符串中不能包含S2。 Input Specification输入在2行中分别给出不超过80个字符长度的、以回车结束的2个非空字符串，对应S1和S2。 Output Specification在一行中输出删除字符串S1中出现的所有子串S2后的结果字符串。 Sample Input &amp; Sample Output Input:Tomcat is a male ccatatcat Output:Tom is a male Analysis本题不是特别难，不过还是要仔细想一想。对需要删除的字符串进行遍历，比对字符串序列，如果不是子串，就进行下一次循环，若是子串，就将子串后的字符序列前移，然后修改字符串的长度，并让字符串最后一位为\0，这样就删除掉了子串；重复遍历即可删除所有子串。 Code123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(int argc, char const *argv[])&#123; char s1[85],s2[85]; gets(s1); gets(s2); int len1=strlen(s1),len2=strlen(s2); int i,k; for(k=0; k&lt;len1; k++) &#123; for(i=0; i&lt;len1; i++) &#123; if(s1[i] == s2[0])&#123; int temp=i,flag=1,j; for(i+=1,j=1; j&lt;len2; i++,j++) &#123; if(s1[i] != s2[j])&#123; flag=0; break; &#125; &#125; if(!flag)&#123; i=temp; &#125;else&#123; for(j=temp; i&lt;len1; j++,i++) &#123; s1[j]=s1[i]; &#125; len1=len1-len2; s1[len1]='\0'; &#125; i=temp; &#125; &#125; &#125; printf("%s\n", s1); return 0;&#125; 7-30 字符串的冒泡排序我们已经知道了将N个整数按从小到大排序的冒泡排序法。本题要求将此方法用于字符串序列，并对任意给定的K（&lt;N），输出扫描完第K遍后的中间结果序列。 Input Specification输入在第1行中给出N和K（1≤K&lt;N≤100），此后N行，每行包含一个长度不超过10的、仅由小写英文字母组成的非空字符串。 Output Specification输出冒泡排序法扫描完第K遍后的中间结果序列，每行包含一个字符串。 Sample Input &amp; Sample Output Input:6 2bestcateastafreeday Output:bestacatdayeastfree Analysis本题不是特别难，但也需要细细想一想，另外感觉题干一开始没说清楚怎样认为一个字符串“大”或“小”，其实就是首字母在字母表顺序来决定大小，若首字母相同则比较首字母后的字母的顺序，依次类推；了解了这些后，可以发现，输入样例中的字符串构成的序列就是2 3 5 1 6 4，而输出样例的序列就是2 1 3 4 5 6，这个与7-27 冒泡法排序是一致的。解决这个问题的主要思路其实是利用二维数组存储每一个子字符串，进行比较后排序即可。主要该注意的点：abcd和acbd这种前一个或几个字母是相同的子字符串的比较，巧合的是，strcmp函数正好可以处理这样的情况👍，所以，直接使用strcmp函数比较后，在用strcpy函数互换字符串即可（类似整型变量的换值）；strcmp和strcpy这两个函数可以自己写；C++好像自带了应对这种字符串排序需求的处理函数，直接调用即可。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;stdio.h&gt;#include &lt;string.h&gt;char* mycpy(char* dst, char* src);int mycmp(char const *s1, char const *s2);int main(int argc, char const *argv[])&#123; int N,K; scanf("%d %d", &amp;N, &amp;K); char str[N][11]; int i,j; for(i=0; i&lt;N; i++) &#123; scanf("%s", str[i]); &#125; char temp[11]; char *p=temp; for(i=1; i&lt;=K; i++) &#123; for(j=0; j&lt;N-i; j++) &#123; if(mycmp(str[j], str[j+1]) &gt; 0)&#123; mycpy(p, str[j]); mycpy(str[j], str[j+1]); mycpy(str[j+1], temp); &#125; &#125; &#125; for(i=0; i&lt;N; i++) &#123; printf("%s\n", str[i]); &#125; return 0;&#125;char* mycpy(char *dst, char *src)&#123; char* ret = dst; while(*src) &#123; *dst++ = *src++; &#125; *dst = '\0'; return ret;&#125;int mycmp(char const *s1, char const *s2)&#123; while(*s1 == *s2 &amp;&amp; *s1 != '\0') &#123; s1++; s2++; &#125; return *s1-*s2;&#125; 7-31 字符串循环左移输入一个字符串和一个非负整数N，要求将字符串循环左移N次。 Input Specification输入在第1行中给出一个不超过100个字符长度的、以回车结束的非空字符串；第2行给出非负整数N。 Output Specification在一行中输出循环左移N次后的字符串。 Sample Input &amp; Sample Output Input:Hello World!2 Output:llo World!He Analysis本题不难，熟悉字符数组的存储方式的话做起来会感觉比较容易。主要思路是按照题目给的移动次数，将需要移动的字符按移动顺序放到一个新的字符数组内，将原来的字符数组的剩余字符前移，然后再将新的字符数组内的字符复制回老的字符数组内即可。注意当移动的次数大于字符串的长度时，要取余处理，比如，字符串长度为5，要移动9次，实际上移动的次数就是9%5=4。也可以只使用一个字符数组，先输出移动后的后半段字符，在输出前半段字符，最后换行即可。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;int mylen(char const *s1);int main(int argc, char const *argv[])&#123; char str1[105]; char str2[105]; gets(str1); int N,i=1; scanf("%d", &amp;N); char* p=str1; char* q=str2; int len=mylen(p); for(p+=(N%len); *p != '\0'; p++, q++) &#123; *q=*p; &#125; p=str1; for(i=1; i&lt;=(N%len); i++, p++, q++) &#123; *q=*p; &#125; *q='\0'; printf("%s\n", str2); /* method 2: use one char_array int i=0,len=mylen(str); char* p=str; printf("%s", p+(N%len); p=str; for(; i&lt;(N%len); i++,p++) &#123; printf("%c", *p); &#125; printf("\n"); */ return 0;&#125;int mylen(char const *s1)&#123; int len=0; while(*s1) &#123; s1++; len++; &#125; return len;&#125; 7-32 说反话-加强版给定一句英语，要求你编写程序，将句中所有单词的顺序颠倒输出。 Input Specification测试输入包含一个测试用例，在一行内给出总长度不超过500000的字符串。字符串由若干单词和若干空格组成，其中单词是由英文字母（大小写有区分）组成的字符串，单词之间用若干个空格分开。 Output Specification每个测试用例的输出占一行，输出倒序后的句子，并且保证单词间只有1个空格。 Sample Input &amp; Sample Output Input:Hello World Here I Come Output:Come I Here World Hello Analysis本题本质上而言，不是特别的复杂，但也需要仔细去琢磨一些细节，以下的代码参考了qq_37729102的代码，且文章之内做了很多细节说明；大致的思路，就是从后往前遍历字符串，空格跳过，扫描到非字符时，记录字符的个数(其实就是单词的长度了)，每扫描到下一个空格的时候，就输出前一个单词即可。由于第一个单词比较特殊，如果依然采取从后遍历的方法去输出第一个单词，这样就无法保证与题目格式的一致(换行符)，所以需要先记录第一个单词的首字母在字符数组中的下标，此时，若第一个单词的前面存在空格，跳过，若没有空格，那么循环变量为0后就自动跳出循环了，紧接着，再输出第一个单词就可以了。 Code1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define maxn 500005int main(int argc, char const *argv[])&#123; char str[maxn]; gets(str); int len=strlen(str); int i,j=0,char_cnt=0,next_flag=1,last_flag=1; for(i=0; i&lt;len; i++) &#123; if(str[i] != ' ')&#123; last_flag=i; break; &#125; &#125; for(i=len-1; i&gt;=0; i--) &#123; if(str[i] != ' ')&#123; next_flag=0; char_cnt++; &#125;else if(!next_flag)&#123; next_flag=1; for(j=i+1; j&lt;i+1+char_cnt; j++) &#123; printf("%c", str[j]); &#125; if(i+1 != last_flag) printf(" "); char_cnt=0; &#125; &#125; for(i=last_flag; i&lt;last_flag+char_cnt; i++) &#123; printf("%c", str[i]); &#125; printf("\n"); return 0;&#125; 7-33 有理数加法本题要求编写程序，计算两个有理数的和。 Input Specification输入在一行中按照a1/b1和a2/b2的格式给出两个分数形式的有理数，其中分子和分母全是整形范围内的正整数。 Output Specification在一行中按照a/b的格式输出两个有理数的和。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 Sample Input &amp; Sample Output Input 1:1/3 1/6 Output 2:1/2 Input 3:4/3 2/3 Output 4:2 Analysis本题算是7-24 约分最简分式的升级版了，题目不难，按照基本计算规则进行约分即可，实质上是对最大公约数和最小公倍数的理解、应用和计算吧。 Code123456789101112131415161718192021222324252627#include &lt;stdio.h&gt;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int a1,b1,a2,b2; scanf("%d/%d %d/%d", &amp;a1, &amp;b1, &amp;a2, &amp;b2); int member,denominator,LCM,GCD; LCM=lcm(b1, b2); member=a1*LCM/b1 + a2*LCM/b2; denominator=LCM; GCD=gcd(member, denominator); if(denominator/GCD == 1)&#123; printf("%d\n", member/GCD); &#125;else&#123; printf("%d/%d\n", member/GCD, denominator/GCD); &#125; return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a);&#125;int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-34 通讯录的录入与显示通讯录中的一条记录包含下述基本信息：朋友的姓名、出生日期、性别、固定电话号码、移动电话号码。 本题要求编写程序，录入N条记录，并且根据要求显示任意某条记录。 Input Specification输入在第一行给出正整数N（≤10）；随后N行，每行按照格式姓名 生日 性别 固话 手机给出一条记录。其中姓名是不超过10个字符、不包含空格的非空字符串；生日按yyyy/mm/dd的格式给出年月日；性别用M表示“男”、F表示“女”；固话和手机均为不超过15位的连续数字，前面有可能出现+。在通讯录记录输入完成后，最后一行给出正整数K，并且随后给出K个整数，表示要查询的记录编号（从0到N−1顺序编号）。数字间以空格分隔。 Output Specification对每一条要查询的记录编号，在一行中按照姓名 固话 手机 性别 生日的格式输出该记录。若要查询的记录不存在，则输出Not Found。 Sample Input &amp; Sample Output Input:3Chris 1984/03/10 F +86181779452 13707010007LaoLao 1967/11/30 F 057187951100 +8618618623333QiaoLin 1980/01/01 M 84172333 100862 1 7 Output:LaoLao 057187951100 +8618618623333 F 1967/11/30Not Found Analysis本题不难，比较直接；直接用结构体构造出来保存通讯录的数据结构即可，然后再从这份通讯录内分别按顺序输出需要的信息即可。其实用二维数组应该也可以达到这样的效果，另外，对于生日这条记录，直接用字符串存储比较方便。 Code123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;typedef struct address_list&#123; char name[12]; char brith[12]; char gender; char landline[18]; char phone[18];&#125;address_list;int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); address_list list[N]; for(i=0; i&lt;N; i++) &#123; scanf("%s %s %c %s %s", list[i].name, list[i].brith, &amp;list[i].gender, list[i].landline, list[i].phone); getchar(); &#125; int K,j; scanf("%d", &amp;K); for(i=1; i&lt;=K; i++) &#123; int j,check_num=0,flag=0; scanf("%d", &amp;check_num); for(j=0; j&lt;N; j++) &#123; if(j == check_num)&#123; printf("%s %s %s %c %s\n", list[j].name, list[j].landline, list[j].phone, list[j].gender, list[j].brith); flag=1; &#125; &#125; if(!flag) printf("Not Found\n"); &#125; return 0;&#125; 7-35 有理数均值本题要求编写程序，计算N个有理数的平均值。 Input Specification输入第一行给出正整数N（≤100）；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。 Output Specification在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。 Sample Input &amp; Sample Output Input 1:41/2 1/6 3/6 -5/10 Output 1:1/6 Input 2:24/3 2/3 Output 2:1 Analysis本题稍微复杂一点，不过大致思路还算简单；主要的思路就是依次将输入的分式相加，然后除以数量即可得到均值了。由于题目会给输入的分式的数目，所以可以提前定义好存储结构，然后在进行运算；注意每次运算完之后需要对分子分母进行化简，每次计算得到的分子member和分母denominator需要使用long long的类型来定义，否则会超出范围。分式的化简和相加主要依据最小公倍数和最大公约数来完成，最大公约数可以使用欧几里得算法，最小公倍数即为两个数的乘积除以两个数的最大公约数。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;typedef struct Fraction&#123; int a; int b;&#125;fraction;int gcd(int a, int b);int lcm(int a, int b);int main(int argc, char const *argv[])&#123; int i,N; scanf("%d", &amp;N); fraction fra[N]; for(i=0; i&lt;N; i++) &#123; scanf("%d/%d", &amp;fra[i].a, &amp;fra[i].b); &#125; int GCD=0, LCM=0; long long member=fra[0].a, denominator=fra[0].b; for(i=1; i&lt;N; i++) &#123; GCD=gcd(denominator, fra[i].b); LCM=denominator*fra[i].b/GCD; member=member*LCM/denominator + fra[i].a*LCM/fra[i].b; denominator=LCM; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; &#125; denominator*=N; GCD=gcd(member, denominator); member/=GCD; denominator/=GCD; if(denominator == 1) printf("%ld\n", member); else printf("%ld/%ld\n", member, denominator); return 0;&#125;int gcd(int a, int b)&#123; return a==0?b:gcd(b%a, a); &#125; int lcm(int a, int b)&#123; return a*b/gcd(a, b);&#125; 7-36 复数四则运算本题要求编写程序，计算2个复数的和、差、积、商。 Input Specification输入在一行中按照a1、b1、a2、b2的格式给出2个复数C1=a1+b1i和C2=a2+b2i的实部和虚部。题目保证C2不为0。 Output Specification分别在4行中按照(a1+b1i) 运算符 (a2+b2i) = 结果的格式顺序输出2个复数的和、差、积、商，数字精确到小数点后1位。如果结果的实部或者虚部为0，则不输出。如果结果为0，则输出0.0。 Sample Input &amp; Sample Output Input 1:2 3.08 -2.04 5.06 Output 1:(2.0+3.1i) + (-2.0+5.1i) = 8.1i(2.0+3.1i) - (-2.0+5.1i) = 4.0-2.0i(2.0+3.1i) * (-2.0+5.1i) = -19.7+3.8i(2.0+3.1i) / (-2.0+5.1i) = 0.4-0.6i Input 2:1 1 -1 -1.01 Output 2:(1.0+1.0i) + (-1.0-1.0i) = 0.0(1.0+1.0i) - (-1.0-1.0i) = 2.0+2.0i(1.0+1.0i) * (-1.0-1.0i) = -2.0i(1.0+1.0i) / (-1.0-1.0i) = -1.0 Analysis本题的计算方法比较简单，注意复数的*和/运算即可；此题比较麻烦的地方在于控制输出的格式，由于存在实部和虚部，所以需要分多种情况，这个就需要注意细节了。若用real代表实部，用imaginary代表虚部，就可以得到以下几种情况：real==0, imaginary==0、real==0, imaginary&gt;0、real==0, imaginary &lt; 0、real!=0, imaginary&gt;0、real!=0, imaginary&lt;0和real!=0, imaginary==0，根据这六种情况要分别输出结果中虚部前的+和-号；由于输入的数据是小数，在做判断时，得考虑四舍五入的情况，而在输出时，%lf会自动四舍五入；不要用flaot，因为数值可能会有损失，最好直接用double。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;math.h&gt;double a1,b1,a2,b2;void print_complex_number(double a, char c, double b);int main(int argc, char const *argv[])&#123; double real_part=0.0,imaginary_part=0.0; scanf("%lf %lf %lf %lf", &amp;a1, &amp;b1, &amp;a2, &amp;b2); real_part=a1 + a2; imaginary_part=b1 + b2; print_complex_number(real_part, '+', imaginary_part); real_part=a1 - a2; imaginary_part=b1 - b2; print_complex_number(real_part, '-', imaginary_part); real_part=a1*a2 - b1*b2; imaginary_part=a2*b1 + a1*b2; print_complex_number(real_part, '*', imaginary_part); real_part=(a1*a2 + b1*b2) / (a2*a2 + b2*b2); imaginary_part=(a2*b1 - a1*b2) / (a2*a2 + b2*b2); print_complex_number(real_part, '/', imaginary_part); return 0;&#125;void print_complex_number(double a, char c, double b)&#123; if(b1 &gt;= 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &gt;= 0 &amp;&amp; b2 &lt; 0)&#123; printf("(%.1lf+%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125;else if(b1 &lt; 0 &amp;&amp; b2 &gt;= 0)&#123; printf("(%.1lf%.1lfi) %c (%.1lf+%.1lfi) = ", a1, b1, c, a2, b2); &#125;else&#123; printf("(%.1lf%.1lfi) %c (%.1lf%.1lfi) = ", a1, b1, c, a2, b2); &#125; if(fabs(a) &lt; 0.1 &amp;&amp; fabs(b) &lt; 0.1)&#123; printf("0.0\n"); return; &#125; int flag=0; if(fabs(a) &gt;= 0.1)&#123; printf("%.1lf", a); flag++; &#125; if(fabs(b) &gt;= 0.1)&#123; if(flag &amp;&amp; b &gt; 0.0)&#123; printf("+%.1lfi", b); &#125;else&#123; printf("%.1lfi", b); &#125; &#125; printf("\n");&#125; 7-37 整数分解为若干项之和将一个正整数N分解成几个正整数相加，可以有多种分解方法，例如7=6+1，7=5+2，7=5+1+1，…。编程求出正整数N的所有整数分解式子。 Input Specification每个输入包含一个测试用例，即正整数N (0&lt;N≤30)。 Output Specification按递增顺序输出$N$的所有整数分解式子。递增顺序是指：对于两个分解序列$N_1={n_1,n_2,⋯}$和$N_2={m_1,m_2,⋯}$，若存在$i$使得$n_1=m_1,⋯,n_i=m_i$，但是$n_{i+1} &lt; m_{i+1}$,则$N_1$序列必定在$N_2$序列之前输出。每个式子由小到大相加，式子间用分号隔开，且每输出4个式子后换行。 Sample Input &amp; Sample Output Input:7 Output:7=1+1+1+1+1+1+1;7=1+1+1+1+1+2;7=1+1+1+1+3;7=1+1+1+2+27=1+1+1+4;7=1+1+2+3;7=1+1+5;7=1+2+2+27=1+2+4;7=1+3+3;7=1+6;7=2+2+37=2+5;7=3+4;7=7 Analysis以下代码参考了文之的代码；题目其实不难，也算是“套路题”的一种，采用了深度优先和递归的思想；文之博文内细节说的很清楚，这里暂时先不讨论（其实是自己看的似懂非懂😝）。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;void division(int i);int N;int s[31];int top=-1;int cnt=0;int sum=0;int main(int argc, char const *argv[])&#123; scanf("%d", &amp;N); division(1); return 0;&#125;void division(int i)&#123; if(sum == N)&#123; cnt++; printf("%d=", N); int k; for(k=0; k&lt;top; k++) &#123; printf("%d+", s[k]); &#125; if(cnt%4 == 0 || s[top] == N)&#123; printf("%d\n", s[top]); &#125;else&#123; printf("%d;", s[top]); &#125; return ; &#125; if(sum &gt; N)&#123; return ; &#125; int j; for(j=i; j&lt;=N; j++) &#123; s[++top]=j; sum+=j; division(j); sum-=j; top--; &#125;&#125; 7-38 数列求和-加强版给定某数字$A（1≤A≤9）$以及非负整数$N（0≤N≤100000）$，求数列之和$S=A+AA+AAA+⋯+AA⋯A（N个A）$。例如$A=1, N=3$时，$S=1+11+111=123$。 Input Specification输入数字$A$与非负整数$N$。 Output Specification输出其$N$项数列之和$S$的值。 Sample Input &amp; Sample Output Input:1 3 Output:123 Analysis这道题，不是特别难，其实这种类型的题目大体上算，大概又两种方法去解决；首先是比较直接的就是利用数组去模拟整个计算过程，其实质是用数组进行基本四则运算；另外一种方法就是数学，每一次数位的相加，其实是(A*(N-i) + carry，其中A是数位值，(N-i)是数位上的加的次数，carry是进位值，所以(A*(N-i) + carry的结果取余后才是这个数位真正的值。下面的代码中分别给出了用数组模拟的方法和数学方法，且数学方法理解起来不难，要能想到这样去解决的话，还需要积累。 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#define maxn 100002int main(int argc, char const *argv[])&#123; /* method 1: use the array do analog computation, but Time Limit Exceeded int A,N,sum[maxn],num[maxn]; // scanf("%d %d", &amp;A, &amp;N); A=1, N=3; if(N == 0)&#123; printf("0\n"); &#125;else if(N == 1)&#123; printf("%d\n", A); &#125;else&#123; int i,j,temp,len,flag=0,carry=0; for(i=1; i&lt;=N; i++) &#123; num[i]=A; &#125; while(N) &#123; carry=0; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=A; &#125; for(i=1; i&lt;=N-1; i++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; for(j=i; j&lt;=N; j++) &#123; temp = num[i] + sum[i]; num[i] = (temp + carry)%10; carry = (temp + carry)/10; &#125; while(carry) &#123; num[j++] = carry%10; carry/=10; len = j; flag = 1; &#125; for(i=1; i&lt;=N-1; i++) &#123; sum[i]=0; &#125; N--; if(N == 1) break; &#125; if(flag)&#123; for(i=len; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=j; i&gt;1; i--)&#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; return 0; */ /* method 2: use the '%' */ int num[maxn]=&#123;0&#125;,i,j,carry,flag,A,N; scanf("%d%d", &amp;A, &amp;N); // A=9, N=4; if(N == 0) printf("0\n"); else if(N == 1) printf("%d\n", A); else&#123; carry=0, flag=0; for(i=0; i&lt;N; i++) &#123; num[i] = (A*(N-i) + carry)%10; carry = (A*(N-i) + carry)/10; &#125; while(carry) &#123; num[i++] = carry%10; carry = carry/10; flag = 1; &#125; if(flag == 1)&#123; for(i=N; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;else&#123; for(i=N-1; i&gt;0; i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125; &#125; &#125; Code-Completion6-1 简单输出整数本题要求实现一个函数，对给定的正整数N，打印从1到N的全部正整数。 Function interface definitionvoid PrintN ( int N );其中N是用户传入的参数。该函数必须将从1到N的全部正整数顺序打印出来，每个数字占1行。 Test procedure case123456789101112#include &lt;stdio.h&gt;void PrintN ( int N );int main ()&#123; int N; scanf("%d", &amp;N); PrintN( N ); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:3 Output:123 Analysis热身题🧐。 Code123456void PrintN(int N)&#123; int i; for(i=1;i&lt;=N;i++)&#123; printf("%d\n",i); &#125;&#125; 6-2 多项式求值本题要求实现一个函数，计算阶数为n，系数为a[0]…a[n]的多项式$f(x)=\sum_{i=0}^n(a[i]×xi)$在x点的值。 Function interface definitiondouble f( int n, double a[], double x );其中n是多项式的阶数，a[]中存储系数，x是给定点。函数须返回多项式f(x)的值。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10double f( int n, double a[], double x );int main()&#123; int n, i; double a[MAXN], x; scanf("%d %lf", &amp;n, &amp;x); for ( i=0; i&lt;=n; i++ ) scanf(“%lf”, &amp;a[i]); printf("%.1f\n", f(n, a, x)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:2 1.11 2.5 -38.7 Output:-43.1 Analysis直接按照公式求值即可，注意直接算有测试点会超时，可用提取公因式的办法来解决。 Code123456789101112double f( int n, double a[], double x ) &#123; int i; double sum=0,X=x; if(n == 0) &#123; sum=a[0]*1.0; &#125; else &#123; sum=a[n]*X + a[n-1]; for(i=n-2; i&gt;=0; i--) &#123; sum=sum*X + a[i]; &#125; &#125; return sum; 6-3 简单求和本题要求实现一个函数，求给定的N个整数的和。 Function interface definitionint Sum ( int List[], int N );其中给定整数存放在数组List[]中，正整数N是数组元素个数。该函数须返回N个List[]元素的和。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#define MAXN 10int Sum ( int List[], int N );int main ()&#123; int List[MAXN], N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%d", &amp;List[i]); printf("%d\n", Sum(List, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312 34 -5 Output:41 Analysis基础求和，很简单。 Code123456789int Sum ( int List[], int N )&#123; int i,ret=0; for(i=0; i&lt;N; i++) &#123; ret+=list[i]; &#125; return ret;&#125; 6-4 求自定类型元素的平均本题要求实现一个函数，求N个集合元素S[]的平均值，其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Average( ElementType S[], int N );其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素的平均值，其值也必须是ElementType类型。 Test procedure case1234567891011121314151617181920#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Average( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Average(S, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:13.77 Analysis基础求平均值，很简单。 Code12345678910ElementType Average( ElementType S[], int N )&#123; ElementType sum=0; int i=0; for(; i&lt;N; i++) &#123; sum+=S[i]; &#125; return sum/N;&#125; 6-5 求自定类型元素的最大值本题要求实现一个函数，求N个集合元素S[]中的最大值，其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Max( ElementType S[], int N );其中给定集合元素存放在数组S[]中，正整数N是数组元素个数。该函数须返回N个S[]元素中的最大值，其值也必须是ElementType类型。 Test procedure case1234567891011121314151617#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Max( ElementType S[], int N );int main ()&#123; ElementType S[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;S[i]); printf("%.2f\n", Max(S, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:34.00 Analysis基础求最大值，也很简单。 Code12345678910ElementType Max( ElementType S[], int N )&#123; int i=0; ElementType max=S[i]; for(; i&lt;N; i++) &#123; if(max &lt; S[i]) max = S[i]; &#125; return max;&#125; 6-6 求单链表结点的阶乘和本题要求实现一个函数，求单链表L结点的阶乘和。这里默认所有结点的值非负，且题目保证结果在int范围内。 Function interface definitionint FactorialSum( List L );其中单链表List的定义如下：123456typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */ Test procedure case1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node *PtrToNode;struct Node &#123; int Data; /* 存储结点数据 */ PtrToNode Next; /* 指向下一个结点的指针 */&#125;;typedef PtrToNode List; /* 定义单链表类型 */int FactorialSum( List L );int main()&#123; int N, i; List L, p; scanf("%d", &amp;N); L = NULL; for ( i=0; i&lt;N; i++ ) &#123; p = (List)malloc(sizeof(struct Node)); scanf("%d", &amp;p-&gt;Data); p-&gt;Next = L; L = p; &#125; printf("%d\n", FactorialSum(L)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:35 3 6 Output:846 Analysis链表求阶乘，本质上是对链表的遍历操作，对链表而言，注意判空条件可以写成L或者L-&gt;Next。 Code123456789101112131415int FactorialSum( List L )&#123; int fac_sum=0,i,fac; while(L) &#123; fac=1; for(i=1; i &lt;=L-&gt;Data ; i++) &#123; fac*=i; &#125; fac_sum+=fac; L=L-&gt;Next; &#125; return fac_sum;&#125; 6-7 统计某类完全平方数本题要求实现一个函数，判断任一给定整数N是否满足条件：它是完全平方数，又至少有两位数字相同，如144、676等。 Function interface definitionint IsTheNumber ( const int N );其中N是用户传入的参数。如果N满足条件，则该函数必须返回1，否则返回0。 Test procedure case123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;math.h&gt;int IsTheNumber ( const int N );int main()&#123; int n1, n2, i, cnt; scanf("%d %d", &amp;n1, &amp;n2); cnt = 0; for ( i=n1; i&lt;=n2; i++ ) &#123; if ( IsTheNumber(i) ) cnt++; &#125; printf("cnt = %d\n", cnt); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:105 500 Output:cnt = 6 Analysis这个题看着有点烦，其实也很简单，哈哈，出题者给出了#define &lt;math.h&gt;（感谢）这个条件后，对数字的操作就很简单了（不过自己写sqrt，应该也能搞定😉），注意sqrt这个函数的返回类型是double，所以需要强制类型转换(int)sqrt(n)；现在就只用去判断这个数中各数位数字出现次数至少出现2次即可。测试程序中传入函数的参量是int，所以，数组长度用11就好了。 Code123456789101112131415161718int IsTheNumber ( const int N )&#123; int ret=0,digit[11]=&#123;0&#125;; if( ((int)sqrt(N)) * ((int)sqrt(N) ) == N)&#123; int i,j,temp=N; for(i=0; temp; temp/=10, i++) &#123; digit[temp%10]++; &#125; for(j=0; j&lt;10; j++)&#123; if(digit[j] &gt;= 2)&#123; ret=1; break; &#125; &#125; &#125; return ret;&#125; 6-8 简单阶乘计算本题要求实现一个计算非负整数阶乘的简单函数。 Function interface definitionint Factorial( const int N );其中N是用户传入的参数，其值不超过12。如果N是非负整数，则该函数必须返回N的阶乘，否则返回0。 Test procedure case123456789101112#include &lt;stdio.h&gt;int Factorial( const int N );int main()&#123; int N, NF; scanf("%d", &amp;N); NF = Factorial(N); if (NF) printf("%d! = %d\n", N, NF); else printf("Invalid input\n"); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:5 Output:5! = 120 Analysis基本阶乘计算，注意$0!=1$即可。 Code12345678910111213int Factorial( const int N )&#123; int i,ret=1; if(N &lt; 0) return 0; else if(N == 0) return ret; else&#123; for(i=1; i&lt;=N; i++) &#123; ret*=i; &#125; &#125; return ret;&#125; 6-9 统计个位数字本题要求实现一个函数，可统计任一整数中某个位数出现的次数。例如-21252中，2出现了3次，则该函数应该返回3。 Function interface definitionint Count_Digit ( const int N, const int D );其中N和D都是用户传入的参数。N的值不超过int的范围；D是$[0, 9]$区间内的个位数。函数须返回N中D出现的次数。 Test procedure case123456789101112#include &lt;stdio.h&gt;int Count_Digit ( const int N, const int D );int main()&#123; int N, D; scanf("%d %d", &amp;N, &amp;D); printf("%d\n", Count_Digit(N, D)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:-21252 2 Output:3 Analysis考察数位拆分，注意如果是复数，需要先转换为其绝对值即可。 Code12345678910111213141516171819202122232425int Count_Digit ( const int N, const int D )&#123; int times=0,n; if(N &lt; 0) n = -N; else&#123; n=N; if(n == 0 &amp;&amp; D == 0)&#123; return 1; &#125; &#125; int mask=1,temp=n; do&#123; temp/=10; mask*=10; &#125;while(temp &gt; 9); temp = n; int digit; do&#123; digit = temp/mask; temp%=mask; mask/=10; if(digit == D) times++; &#125;while(mask &gt; 0); return times;&#125; 6-10 阶乘计算升级版本题要求实现一个打印非负整数阶乘的函数。 Function interface definitionvoid Print_Factorial ( const int N );其中N是用户传入的参数，其值不超过1000。如果N是非负整数，则该函数必须在一行中打印出$N!$的值，否则打印“Invalid input”。 Test procedure case1234567891011#include &lt;stdio.h&gt;void Print_Factorial ( const int N );int main()&#123; int N; scanf("%d", &amp;N); Print_Factorial(N); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:15 Output:1307674368000 Analysis很明显是个大数问题，利用数组来模拟乘法计算即可，注意每一次进位的处理，感觉数组模拟乘法要比加法容易一些😧。 Code12345678910111213141516171819202122232425262728293031void Print_Factorial ( const int N )&#123; if(N &lt; 0)&#123; printf("Invalid input\n"); &#125;else if(N == 0)&#123; printf("1\n"); &#125;else&#123; int carry=0,i,j,k=1,temp,num[3000]=&#123;0&#125;; num[0]=1; for(i=2; i&lt;=N; i++) &#123; for(j=0; j&lt;k; j++) &#123; temp = num[j]*i + carry; num[j] = temp%10; carry = temp/10; &#125; while(carry) &#123; num[k]=carry%10; carry/=10; k++; &#125; &#125; for(i=k-1; i&gt;0 ;i--) &#123; printf("%d", num[i]); &#125; printf("%d\n", num[i]); &#125;&#125; 6-11 求自定类型元素序列的中位数本题要求实现一个函数，求N个集合元素A[]的中位数，即序列中第$⌊N/2+1⌋$大的元素。其中集合元素的类型为自定义的ElementType。 Function interface definitionElementType Median( ElementType A[], int N );其中给定集合元素存放在数组A[]中，正整数N是数组元素个数。该函数须返回N个A[]元素的中位数，其值也必须是ElementType类型。 Test procedure case12345678910111213141516171819#include &lt;stdio.h&gt;#define MAXN 10typedef float ElementType;ElementType Median( ElementType A[], int N );int main ()&#123; ElementType A[MAXN]; int N, i; scanf("%d", &amp;N); for ( i=0; i&lt;N; i++ ) scanf("%f", &amp;A[i]); printf("%.2f\n", Median(A, N)); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input:312.3 34 -5 Output:12.30 Analysis注意题目的描述，求的是中位数，而$⌊N/2+1⌋$这里是向下取整哦。也即是说，按照题目的要求，要先给传入函数的数组进行排序，然后再输出其中第$⌊N/2+1⌋$大的数，而此时对于数组（从0开始）而言下标就是N/2；明白这个之后，还有排序的问题要解决，如何排序呢？排序算法很多，冒泡排序和插入排序都有一个测试用例无法通过，所以这里使用希尔排序。举个希尔排序的简单例子，对于a[3]={3, 1, 2}这个序列而言，希尔排序会有一个增量d，并按照这个增量d来进行排序，d初始化为3(个数)/2=1，那么第一次希尔排序，就会对a[0]=3和a[0+d]=2这两个数字进行排序，由于不存在a[2]，所以a[1]不会参与排列；第二次循环时，检查已经有序就会跳出循环了。 Code123456789101112131415161718192021ElementType Median( ElementType A[], int N )&#123; int i,j; ElementType temp; int d; for(d=N/2; d&gt;0; d/=2) &#123; for(i=d; i&lt;N; i++) &#123; temp=A[i]; for(j=i; j&gt;=d; j-=d) &#123; if(temp &lt; A[j-d])&#123; A[j] = A[j-d]; &#125;else break; &#125; A[j]=temp; &#125; &#125; return A[N/2]; &#125; 6-12 判断奇偶性本题要求实现判断给定整数奇偶性的函数。 Function interface definitionint even( int n );其中n是用户传入的整型参数。当n为偶数时，函数返回1；n为奇数时返回0。注意：0是偶数。 Test procedure case123456789101112131415#include &lt;stdio.h&gt;int even( int n );int main()&#123; int n; scanf("%d", &amp;n); if (even(n)) printf("%d is even.\n", n); else printf("%d is odd.\n", n); return 0;&#125;/* 你的代码将被嵌在这里 */ Sample Input &amp; Sample Output Input 1:-6 Output 1:-6 is even. Input 2:5 Output 2:5 is odd. Analysis判断奇偶性直接对2取余就好，并且0是偶数，如果不确定的话可以手算一下。 Code1234int even(int n)&#123; if(n%2==0) return 1; else return 0;&#125; 6-13 折半查找给一个严格递增数列，函数int Search_Bin(SSTable T, KeyType k)用来二分地查找k在数列中的位置。 Function interface definitionint Search_Bin(SSTable T, KeyType k)其中T是有序表，k是查找的值。 Test procedure case123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std;#define MAXSIZE 50typedef int KeyType;typedef struct &#123; KeyType key; &#125; ElemType;typedef struct&#123; ElemType *R; int length;&#125; SSTable; void Create(SSTable &amp;T)&#123; int i; T.R=new ElemType[MAXSIZE+1]; cin&gt;&gt;T.length; for(i=1;i&lt;=T.length;i++) cin&gt;&gt;T.R[i].key; &#125;int Search_Bin(SSTable T, KeyType k);int main () &#123; SSTable T; KeyType k; Create(T); cin&gt;&gt;k; int pos=Search_Bin(T,k); if(pos==0) cout&lt;&lt;"NOT FOUND"&lt;&lt;endl; else cout&lt;&lt;pos&lt;&lt;endl; return 0;&#125;/* 请在这里填写答案 */ Sample Input &amp; Sample Output Input 1:51 3 5 7 97 Output 1:4 Input 2:51 3 5 7 910 Output 2:NOT FOUND Analysis题目给出的测试程序是C++的语法，但是也没事，有C的功底看懂是没有太大问题的，不过实际上，因为，要写的只是函数，好像跟其他的好像也没啥关系，主要看懂有序表L的结构就好了。另一个，就是折半查找的算法了，大致思路就是利用左标记和右标记来遍历有序表，如果有符合条件的值就弹出即可。 Code1234567891011121314151617181920int Search_Bin(SSTable T, KeyType k)&#123; int serial_num=0,left,right=T.length,mid=1,j=1; while(j &lt;= T.length)&#123; mid=(left + right)/2; if(T.R[mid].key == k)&#123; serial_num = mid; break; &#125;else&#123; if(T.R[mid].key &lt; k)&#123; left = mid; &#125; if(T.R[mid].key &gt; k)&#123; right = mid; &#125; &#125; j++; &#125; return serial_num; &#125; Summary虽说是基础编程题目集，但是感觉里面有些题目还真不是特别好想，可能是我比较菜😂。尽管每道题目都给出了题目、输入（输出）样例、说明等，字数真是多啊，哈哈，有点水文的嫌疑。另外，关于每道题目的AC代码，已经全部被上传到GitHub上了，可以点击PTA-Basical-Programming-problem-set来获取源文件。]]></content>
      <categories>
        <category>Programming</category>
        <category>PTA</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>PTA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用Hexo搭建个性化博客]]></title>
    <url>%2F2019%2F02%2F16%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E6%80%A7%E5%8C%96%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Intro偶然看到别人用Hexo建立的个人Blog，觉得挺不错的，然后就开始动手折腾了。而此篇Blog就用来记录自己建立这个Blog的整个过程和一些细节吧，这样在出现问题的时候可以及时找到问题所在，也可以给其他人作为参考，持续更新ing(偷懒😴)。 Preparation在开始建立Blog之前，需要先安装三样东西：Node.js、Git和Hexo。以下过程均已Win10系统（Linux系统类似）为准。 Windows系统的文件目录分隔符是\，而不是Linux采用的/ Node.jsNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 直接百度搜索Nodejs即可找到其官方下载页面，或者点击Node.js，直接下载64位安装windows安装程序即可。下载好之后，直接安装即可，可以修改默认的安装路径到你设定的磁盘文件夹下。 GitGit 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。 与Node.js同样，我们直接百度搜索Git即可找到其官方下载页面，但是官方地址的下载速度很慢，不过好在Git并不大，不需要太长时间就可以下载好，或者点击下面的链接，直接下载。64-bit Git for Windows Setup64-bit Git for Windows Portable HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装Hexo比较简单，在CMD或者PowerShell键入npm install -g hexo-cli后运行即可。从这里可以看出，Hexo的安装其实是依赖Node.js的npm来进行的。 Checkout安装好了之后，需要检查是否能正常使用，在CMD或PowerShell内运行以下命令即可。~\hexo12345678910111213141516171819202122232425node -vgit versionhexo version#回显信息依次如下：v10.15.1git version 2.20.1.windows.1hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.1v8: 6.8.275.32-node.12uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 如果得到类似以上的结果，那么说明Node、Git和Hexo能够正常使用。 Setup安装完成Hexo后，我们就可以开始建站了。 Init - 初始化注：根据你选择存储的位置，可以在任意盘符和文件夹下运行以下命令，且均可在CMD或PowerShell内执行。 Hexo初始化的命令为：C:\Users\test&gt; hexo init &lt;folder name&gt;，以C:\Users\test为例，如果在这个路径执行上述命令后，会在test文件夹内生成一个名为folder name的文件夹，且这个文件夹内存储着与Hexo即将生成的静态页面相关的配置文件等。 然后，进入到这个文件夹cd &lt;folder name&gt;，在执行npm install。 初始化完成后，一般会弹出文件夹信息，如：~\hexo1234567├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这些信息可以帮助我们快速熟悉Hexo的文件系统。 到这里，如果没有错误信息产生，Hexo的初始化就算完成了。 Generating - 生成 下面所有内容中代码块内运行的命令均是在上述Hexo初始化的文件夹下运行的。 接着上面的步骤，执行命令C:\Users\test\folder name&gt; hexo generate，此命令可以简写为hexo g，执行完这条命令后，Hexo会默认将source\_post文件夹下的.md文件生成为静态的.html文件，并在C:\Users\test\folder name下创建一个public文件夹，用来存放生成的静态页面文件。 Hexo 能够监视文件变动并立即重新生成静态文件，在生成时会比对文件的 SHA1 checksum，只有变动的文件才会写入。我们可以利用hexo generate --watch命令来使用这个功能。 当然，还可以与部署命令配合使用，如：~\hexo1234567hexo generate --deployhexo deploy --generate#上面的两条命令是等价的#简写hexo g -dhexo d -g Server - 服务器当服务器运行我们的网站进程后，远程的客户端才可以打开网站。下面，在介绍Hexo下服务器的相关命令和设置。 接着上面的步骤，执行命令C:\Users\test\folder name&gt; hexo server，此命令可以简写为hexo s，执行完这条命令后，Hexo的Blog页面会运行在http://Localhost:4000/，这个页面下，可以直接在浏览器内打开，打开后即可看到Hexo生成的Blog主页面了。 根据Hexo官网的说明，在之前的Hexo 3.0中，Hexo将服务器独立成了个别模块，需要先安装hexo-server才能使用。执行npm install hexo-server --save，等待安装完成后，执行hexo s即可。 在服务器启动期间，Hexo会监视文件变动并自动更新，无须重启服务器。所以，在写Blog的时候，可以直接在线查看。 执行hexo s -p &lt;port number&gt;，可以将页面运行在指定的本地端口。若执行hexo server -i x.x.x.x，可以将页面运行在指定的IP地址上，就只能通过指定的这个IP来访问站点了。例如，对于一台使用无线网络的笔记本电脑，除了指向本机的127.0.0.1外，通常还有一个192.168.*.*的局域网IP，如果像上面那样使用-i 192.168.*.*作为参数，可能就不能用127.0.0.1来访问站点了。对于有公网IP的主机，如果您指定一个局域网IP作为-i参数的值，那么也就无法通过公网来访问站点。 另外，在静态模式下，服务器只处理public文件夹内的文件，而不会处理文件变动，在执行时，应该先自行执行hexo generate，此模式通常用于生产环境（Production mode）下。 Deployment部署需要指定git repository（仓库），且需要对本机的Git进行配置。 或者直接使用服务器，如果服务器存在公网IP，那么执行hexo s后，就可以用服务器的公网IP去访问这个站点了。但是这样会有一个问题，当关闭服务器的远程连接之后，用hexo s命令产生的进程会关闭，这样就导致无法再访问了，可以使用hexo s &amp;命令来使进程在后台持续运行。 当需要关闭这个进程的时候，结束掉这个这个进程即可。 Git Setting - Git 配置这部分涉及Git的用法，建议去Baidu或Google查询一下Git的相关使用方法，这里放一个Git教程链接，号称史上最浅显易懂的Git教程，非广告。 Sign Up - 创建账号若没有Github账号，请去Github官网注册一个，填写好邮箱、用户名和密码，邮箱需要验证。 Creat Repositories - 创建仓库刚创建好的Github账号，系统会默认带你创建一个repo(repositories)，可以直接创建一个给Hexo用的仓库，也可以先创建一个测试repo来熟悉一下创建的流程。 注意： 新建的仓库名为username.github.io，这里的username是你的github账号名称，这样Hexo部署到Github上的静态页面，就可以通过http://username.github.io来进行访问了。 github创建的仓库可能不会立即生效，可能需要等待10-30分钟。 创建成功后，通过Hexo部署的静态页面文件就放到这里了。 SSH key - 配置SSH密钥SSH为Secure Shell的缩写，SSH是建立在应用层基础上的安全协议，是可靠的专为远程登录会话和其他网络服务提供安全性的协议。在使用github提交代码时，需要账户权限，直接使用用户名和密码不是一个安全的选择，正好Github上提供了ssh key相关的服务。 打开Git Bash，执行$ cd ~/.ssh，若提示No such file or directory，说明你未使用过ssh。若可以进入此目录(这里用目录是因为与Windows的文件夹概念区分开，因为Git Bash是Linux Shell)，则执行ls，查看当前目录下的文件，一般只有一个叫做known_hosts的文件，这个文件是你用ssh登录设备后生成的一些密钥信息。 继续在Git Bash中执行ssh-keygen -t rsa -C &quot;your email&quot;，这里的your email是你注册Github所使用的邮箱。然后连续3次回车，最终会生成一个名为id_rsa.pub的文件，用文本编辑器打开里面的内容后，复制好。然后，打开你的Github主页，进入个人设置，找到SSH and GPG keys，点击New SSH key，将复制的内容粘贴到key栏下，设置title后，点击Add SSH key即完成SSH key的配置。 别急，还没完，接着在Git Bash中运行ssh -T git@github.com，这里不需要修改邮箱，若提示信息为Are you sure you want to continue connecting (yes/no)?，输入yes后，将会提示Hi &#39;your github-id&#39;! You&#39;ve successfully authenticated, but Github does not provides shell access.，此时说明Git的SSH key已配置成功！ 紧接着，还需要配置：12$ git config --global user.name "username" # your github-id$ git config --global user.email "xxx@xx.com"# your email with github 以上两条命令的作用是，将你之后的每次在github上发起的提交都写入这些信息。对于git而言，使用了--global选项的命令，只需运行一次。另外，Git自带的git config还可以帮助我们设置Git的外观和行为的配置变量，进一步的信息，请参考Git官方文档内含中文翻译。 Hexo Config - Hexo 设置Hexo 的配置比较简单。 打开由 Hexo 初始化的博客文件夹，找到_config.yml文件，用文本编辑器打开，修改以下代码： ~\hexo\_config.yml123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: + type: git+ repo: git@github.com:username/username.github.io.git+ branch: master 修改好后，保存即可。若不知道repo如何设置，请参照下图。 接着，我们还需要安装一个插件来为Hexo提供部署功能。打开 CMD ，执行npm install hexo-deployer-git --save，若提示Permisson denied (publickey).，则打开Git Bash再次执行此命令即可。注意这个步骤需要在博客本地的根目录下进行。 在部署到Github Pages的过程中，必须先执行hexo g生成静态页面之后，才可以执行hexo d后，会同时先默认执行Hexo g命令，因为Hexo部署到Github Pages上的文件需要Hexo先本地生成，而Hexo本地生成静态页面时，会在博客根目录下生成名为public的文件夹，并将生成好的静态页面文件全部放到这个文件夹下，继而再将这个文件夹内的文件全部部署到github上。 建议每次在运行hexo d之前，做好备份 Personalized Customization下面介绍有关Hexo的一些基础配置。 Change Themes - 修改主题Hexo默认的主题叫做landscape，外形中规中矩，但肯定满足不了大家的个性化需求，所以还需要更加个性化的主题才可以。 此Blog应用的主题为NexT，这款主题风格简约，设计精美，感谢作者IIssNan。 Download Themes - 下载主题下载NexT主题的方法很多，获取资源的途径也很多，推荐使用git来安装。- ~\hexo123&lt;!-- folder name为之前Hexo生成的文件夹 --&gt;$ cd &lt;folder name&gt;$ git clone https://github.com/theme-next/hexo-theme-next themes/next git clone xxx这条命令属于git的应用范畴，是git的基本操作。另外，theme-next这条链接可以直接打开，是NexT官方的github repo，其上也介绍了如何安装和升级NexT。 Enable NexT - 启用主题对于Hexo而言，所有的主题启用模式都是一样的。当克隆/下载完成后，打开Hexo生成目录下的_config.yml文件，找到theme字段，将其值修改为next后，保存即可。~\hexo\_config.yml1theme: next 一般而言，在启用 next 主题后，页面会直接使用该主题，但不排除意外的情况，这时，可以使用hexo clean清楚缓存，并用hexo g重新生成新的页面。 Checkout - 验证在CMD下，执行hexo s，显示INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.后，打开链接http://localhost:4000/，即可看到效果。或者，可以执行hexo s --debug，这样在服务启动的过程中，如果由错误产生，命令行会自动输出这些异常信息，恰巧你碰到问题的话，这些信息可以帮助他人更好的定位错误。 当你看到与下图类似的效果时，说明已经成功安装NexT主题。 NexT Basic Setting - NexT 基本设置下面介绍与有关NexT的基本设置。 为方便起见，将Hexo生成的目录下的_config_yml称为站点配置文件，将next主题文件目录下的_config.yml称为主题配置文件 Scheme - 主题样式Scheme 是 NexT 提供的一种特性，借助于Scheme，NexT为你提供多种不同的外观。同时，几乎所有的配置都可以在 Scheme 之间共用。通过更改主题配置文件，可以达到切换Scheme的效果。在主题配置文件中，可以找到如下内容，将需要启用的Scheme前的注释#删除即可。~\hexo\themes\next\_config.yml12345# Schemesscheme: Muse#scheme: Mist#scheme: Pisces#scheme: Gemini 具体效果可自行尝试。 Language - 语言目前NexT支持的语言有多种，可在其languages文件夹下查看，这里的语言与页面上显示的项目的语言一致，设置为哪一种语言，就显示为哪一种语言。语言设定需要在站点配置文件中设置，在站点配置文件中，找到如下内容，将其值修改为NexT主题对应语言名称文件即可。~\hexo folder\_config.yml1language: zh-CN language:后的值必须要与NexT的语言文件名称一致，才能在页面上生效 Avatar Setting - 头像设置编辑主题配置文件，找到avatar设置部分，如：~\hexo\themes\next\_config.yml1234567891011avatar: # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # You can also use other linking images. url: /uploads/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: true 其中，url为头像的存放路径，rounded和opacity以及rotated为NexT主题下与头像相关的三个个性化功能选项，注释内容为说明。 以上内容属于NexT自带基础设置，更加个性化的设置需要从其他位置进行设置 Site Information - 站点信息站点信息包含的内容主要有标题、作者、介绍等，可以在站点配置文件中进行设置。编辑站点配置文件，找到如下部分：~\hexo\_config.yml123456title: examplesubtitle:description: author: examplelanguage: zh-CNtimezone: 以上内容分别对应：标题、副标题、介绍、作者、语言、时区，修改各个字段的值，即可完成修改。 language与上文中的语言设置是相同的description字段后面的值会被放在头像的下面timezone默认为本机所在时区，可设置为其他时区 Menu Setting - 菜单设置菜单配置包括三个部分，第一是菜单项的显示文本，第二是菜单项的链接，第三是菜单项对应的图标。 NexT使用的是Font Awesome提供的图标，Font Awesome提供了600+的图标，可以满足绝大的多数的场景，同时无须担心在Retina屏幕下图标模糊的问题。 编辑主题配置文件，找到如下部分：~\hexo\themes\next\_config.yml123456789menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 将需要启用的菜单项前的注释#删除即可，||之前为目标页面的链接，||之后为对应的项目图标。在菜单图标开启的情况下，如果菜单项与菜单未匹配（没有设置或者无效的Font Awesome图标名字）的情况下，NexT会使用question icon作为图标。所以，值必须要与图标名称严格一致。 若此时没有为新开启的菜单项设置页面，点击打开时会出现Cannot GET /xxx/的错误 Sidebar Setting - 侧栏设置默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。可以通过修改主题配置文件中的sidebar字段来控制侧栏的行为。侧栏的设置主要包括两个部分，其一是侧栏的位置，其二是侧栏显示的时机。当然了，还包含一部分个性化设置。 设置侧栏的位置，修改sideba.position的值，如： ~\hexo\themes\next\_config.yml1234sidebar: # Sidebar Position, available values: left | right (only for Pisces | Gemini). position: left #position: right 设置侧栏显示的时机，修改sidebar.display的值，如： ~\hexo\themes\next\_config.yml12345sidebar: display: post #display: always #display: hide #display: remove 额外的个性化设置，如： ~\hexo\themes\next\_config.yml12345678# Sidebar offset from top menubar in pixels (only for Pisces | Gemini).offset: 12# Back to top in sidebar.b2t: false# Scroll percent label in b2t button.scrollpercent: true# Enable sidebar on narrow view (only for Muse | Mist).onmobile: true Summary - 小结到这里，NexT基本设置就完成了。可以发现，对于Hexo而言，与页面样式直接相关的内容都是存于主题文件中的，所以，我们直接修改主题配置文件就好了，但若某些主题缺少部分功能的设置，那么可能就需要第三方插件来完成了。 Custom with NexT - NexT 自定义 感谢以下博文：打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化Git Pages 使用指南 hexo的next主题个性化教程:打造炫酷网站 随着NexT版本的不断更新，原先需要用户自己实现的特效（往源码文件中添加代码），有一部分已经被大佬们内嵌到NexT主题内了，感谢他们。 网站页脚的红心及其动画效果修改如下代码部分：~\hexo\themes\next\_config.yml12345678910footer: # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 当然了，依然可以在Font Awesome找到你自己想要的图标进行替换。 开启RSS根据官方的说明，NexT中RSS有三个设置选项，存放在主题配置文件中： false：禁用RSS，不在页面上显示RSS连接 留空：使用Hexo生成的Feed链接，需要先安装hexo-generator-feed插件 具体的链接地址：适用于已经烧制过Feed的情形 以留空为例，先安装hexo-generator-feed插件。~\hexo1npm install hexo-generator-feed --save 安装完成后，设置站点配置文件，增加以下代码：~\hexo\_config.yml12345678910feed: type: atom path: atom.xml limit: 20 hub: content: content_limit: 140 content_limit_delim: ' ' order_by: -date icon: icon.png 然后重新开启页面即可在侧栏看到RSS连接。 开启打赏打赏功能已经被集成在NexT主题中了，那么只需要放入我们的二维码，并开启相应的功能即可。修改主题配置文件：~\hexo\theme\next\_config.yml12345reward: enable: true comment: If it helps, would you?:P wechatpay: /images/wechatpay.jpg alipay: /images/alipay.jpg 此时，刷新页面即可看到红色的打赏按钮，点击打开就能看到支付的二维码了。 关闭打赏文字的动画效果将鼠标指针放到二维码上面时会有一个问题：下面的字体会不断的抖动，若不喜欢可以将这个动画效果关闭。注释掉如下代码：~\hexo\themes\next\source\css\_common\components\post\post-reward.styl1234567/* close the roll of reward font#QR &gt; div:hover p &#123; animation: roll 0.1s infinite linear; -webkit-animation: roll 0.1s infinite linear; -moz-animation: roll 0.1s infinite linear;&#125;*/ 保存修改后即可生效。 启用本地搜索本地搜索功能依赖插件hexo-generator-searchdb，先安装插件：~\hexo1npm install hexo-generator-searchdb --save 然后编辑站点配置文件，增加以下代码：~\hexo fold\_config.yml12345search: path: search.xml field: post format: html limit: 10000 接着在主题配置文件中启用本地搜索功能：~\hexo\theme\next\_config.yml12local_search: enable: true 配置完成后，需要重新生成静态页面。 修改文章内链接文本样式添加如下代码：~\hexo\themes\next\source\css\_custom\custom.yml1234567891011// change the style of inner link.post-body p a &#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 也可在~\hexo\themes\next\source\css\_common\components\post\post.styl这个文件内添加以上代码。 增加代码块复制功能此功能也被集成在NexT主题中了，修改以下代码，即可直接开启。~\hexo\themes\next\_config.yml123456codeblock: # Add copy button on codeblock copy_button: enable: true # Show text copy result show_result: true 添加代码块圆角增加以下代码：~\hexo\themes\next\source\css\_custom\custom.yml123// codeblocks with rounded rectangle.highlight &#123; border-radius: 18px;&#125;pre &#123; border-radius: 8px;&#125; 具体数值可自行设置，也可修改主题配置文件中如下代码：12345codeblock: # Manual define the border radius in codeblock # Leave it empty for the default 1- border_radius:+ border_radius: 8 修改单行代码颜色增加以下代码：~\hexo\themes\next\source\css\_custom\custom.yml12// the colour of single line codecode &#123; color: #ec7f00; &#125; 具体颜色可自行设置。 添加博文字数统计功能字数统计功能依赖插件hexo-symbols-count-time，先安装插件： ~\hexo1npm install hexo-symbols-count-time --save 然后编辑站点配置文件，增加以下代码：~\hexo\_config.yml12345symbols_count_time: symbols: true time: true total_symbols: true total_time: true 接着在主题配置文件中启用字数统计功能：~\hexo\theme\next\_config.yml123456symbols_count_time: separated_meta: true item_text_post: true item_text_total: true awl: 2 wpm: 275 awlwpmsuffixAverage Word Length(chars count in word). Default: 4 CN ≈ 2 EN ≈ 5 RU ≈ 6 Words Per Minute. Default: 275. Slow ≈ 200 Normal ≈ 275 Fast ≈ 350 If time to read less then 60 minutes, added suffix as string parameter. Default: mins. 设置页面显示的文章篇数NexT默认会对此进行配置，但如果需要更多个性化设置需要安装插件：~\hexo123npm install --save hexo-generator-indexnpm install --save hexo-generator-archivenpm install --save hexo-generator-tag 然后在站点配置文件中，添加如下代码，注意Hexo 3以上的版本不允许配置文件存在重复的选项设置。因此最好先检查下站点配置文件中是否有存在上述同名的配置。如果存在，请将两者配置在一起。~\hexo\_config.yml12345678910111213141516# Pagination## Set per_page to 0 to disable paginationper_page: 8pagination_dir: page# 全局分页，每页8篇文章index_generator: # 主页显示多少篇文章 per_page: 5archive_generator: # 归档页显示多少篇文章 per_page: 20 yearly: true monthly: truetag_generator: # 标签页显示多少篇文章 per_page: 10category_generator: per_page: 12 显示菜单栏的文章数量修改如下代码：- ~\hexo\themes\next\_config.yml12menu_settings: badges: true 开启评论和阅读统计功能NexT支持的阅读统计和评论功能较多，针对不同的插件，都进行了集成，用户需要在主题配置文件中开启用户自己指定的某一类功能；同时可能部分功能需要借助到其他第三方应用，所以用户还需要自己注册第三方应用并配置好这些第三方应用的功能。以基于leancloud的统计功能为例，需要用户自身注册leancloud的账号，并进行配置，这里给出官方链接——使用leancloud为next主题添加阅读量统计功能。 添加评论系统NexT内嵌支持的评论系统也有多种（这得感谢各位大大的奉献），与开启统计功能的方法一致。基于leancloud的阅读量统计功能配置完成后，leancloud内的资源依然可以用来统计评论记录，不过要配合Valine一起使用；Valine的基本配置方法可以参考链接——快速开始 | Valine。不过对于NexT而言，只需要在主题配置文件中开启Valine功能，并在Leancloud配置好针对评论的应用即可，而这部分内容可以从官方链接内找到答案。另外，需要注意一下的是，Valine的头像是基于Gravatar的，用户需要自己去Gravatar注册账号，并设置头像。 修改底部标签样式修改底部标签样式需要对整个页面的一些元素进行修改。修改如下代码：~\hexo\themes\next\layout\_marco\post.swig1&lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt; &lt;i class="fa fa-tag"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt; 即将rel=&quot;tag&quot;&gt;#后的#替换为&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;即可。替换完后，需要重新生成页面。 添加侧栏链接侧栏链接的功能在NexT内可直接找到。修改如下代码：~\hexo\themes\next\_config.yml123456links_icon: linklinks_title: Links#links_layout: blocklinks_layout: inlinelinks: #Title: http://example.com 添加侧栏社交图标修改如下代码部分：~\hexo\themes\next\_config.yml123456789101112social: GitHub: https://github.com/Bachzart || github E-Mail: mailto:whistlesilp@gmail.com || envelope #Weibo: https://weibo.com/yourname || weibo #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 可自行添加自己需要的社交图标和链接。 修改网站的图标修改如下代码：~\Hexo\themes\next\_config.yml12345favicon:- small: /images/favicon-16x16-next.png- medium: /images/favicon-32x32-next.png+ small: /uploads/example_16px.png+ medium: /uploads/example_32px.png 开启右上角Github图标修改如下代码：~\Hexo\themes\next\_config.yml123456 # Follow me on GitHub banner in right-top corner. # Usage: `permalink || title` # Value before `||` delimeter is the target permalink. # Value after `||` delimeter is the title and aria-label name.- # github_banner: https://github.com/bachzart || Follow me on GitHub :)+ # github_banner: https://github.com/bachzart || Follow me on GitHub :) 修改博客内字体修改如下代码：~\Hexo\themes\next\_config.yml123456789font:- enable: false+ enable: true+ host: //fonts.loli.net global: external: true+ family:+ family: Noto Serif SC size:其中Noto Serif SC是思源宋体，另外在整个font设置项中还有很多其他的选项可以进行设置，不妨尝试一下。 添加顶部加载条修改如下代码：~\Hexo\themes\next\layout\_partials\head\head.swig12345678910111213141516171819 &lt;meta charset="UTF-8"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"/&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/&gt;+ &lt;script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"&gt;&lt;/script&gt;+ &lt;link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"&gt;+ &lt;style&gt;+ .pace .pace-progress &#123;+ background: #1E92FB; /*the color of strip*/+ height: 3px;+ &#125;+ .pace .pace-progress-inner &#123;+ box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*the color of shadow*/+ &#125;+ .pace .pace-activity &#123;+ border-top-color: #1E92FB; /*border-top-color*/+ border-left-color: #1E92FB; /*border-left-color*/+ &#125;+ &lt;/style&gt; &lt;meta name="theme-color" content=""/&gt; 开启文章底部版权声明修改如下代码：~\Hexo\themes\next\_config.yml1234creative_commons: license: by-nc-sa sidebar: false+ post: true如若解析完成后，显示http://yoursite.com/xxx.html，请修改如下代码：~\Hexo\_config.yml1234+ url: http://bachzart.github.io root: / permalink: :year/:month/:day/:title/ permalink_defaults:保存好后，重新生成即可。 添加 fancybox 插件fancybox2/3皆需要先安装才能使用，安装十分简单，可以参考fancybox3，先下载fancybox3文件：~\Hexo\themes\next1$ git clone https://github.com/theme-next/theme-next-fancybox3 source/lib/fancybox 然后在主题配置文件中开启功能：~\Hexo\themes\next_config.yml1+ fancybox: true效果如下图： Writing Skills下面内容将开始介绍一些写作技巧。 Writing with NexTNexT主题自身扩展了很多方便写作的功能，既提高了文章的美感，又让作者更加容易的表达观点。 除了代码块外，其他引用方式内都可以尝试与 Markdown 语法的加粗、倾斜、删除线等功能进行嵌套使用，效果更佳 文本居中引用此标签将生成一个带上下分割线和双引号的引用，同时写在其内部的应用文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。使用方法如下：12345678&lt;!-- HTML方式：直接在 Markdown 文件中编写 HTML来调用&gt;&lt;!-- 其中 class=&quot;block-quote-center&quot; 是必须的 --&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;bla bla bla&lt;/blockquote&gt;&lt;!-- swig语法 --&gt;&#123;% centerquote %&#125;bla bla bla&#123;% endcenterquote %&#125;&lt;!-- 简写 --&gt;&#123;% cq %&#125;bla bla bla&#123;% endcq %&#125; 效果如下图：另外还有一种文本居中引用方法：12&lt;!-- HTML方式 --&gt;&lt;center&gt;**bla bla bla**&lt;/center&gt; 效果如下： bla bla bla 代码块的书写方法codeblock代码块用法如下：1234&lt;!-- swig语法 --&gt;&#123;% codeblock [title] [lang:language] [url] [link text] %&#125;code snippet&#123;% endcodeblock %&#125; 另一种形式的代码块使用六个反引号（正好一对）来包裹代码块，[language] [title] [url] [link text]这四个参数也写在首行，这两种方式书写时都没有[]。titletitleurllink textlanguage是代码语言的名称，用来设置代码块颜色高亮，非必须title是顶部左边的说明，非必须url是顶部右边的超链接地址，非必须link text是超链接的名称，非必须如果需要对比功能，需要写lang：diff，并在相应的代码行首加上-和+即可，对应的颜色也是可以自定义的，修改如下代码：~\hexo\themes\next\source\css\_custom\custom.syl1234567// the diff style of codeblockpre .addition &#123; background: #e6ffed;&#125;pre .deletion &#123; background: #ffeef0;&#125; Note PluginNexT主题扩展了一种note插件，可以用来单独展示重点性或结论性内容，其配置信息保存在主题配置文件中，具体如下：123456789101112note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 在书写时，在.md文件内直接插入以下代码即可：1234567&lt;!-- swig --&gt;&#123;% note %&#125;bla bla bla&#123;% endnote %&#125;&lt;!-- HTML --&gt;&lt;div class=&quot;note&quot;&gt;&lt;p&gt;bla bla bla&lt;/p&gt;&lt;/div&gt; 效果如下： bla bla bla 另外，note后添加default/primary/info/success/warning/danger，可以展示不同的标签栏，分别如下： bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla 设置note xx no-icon可以不显示图标，效果如下： 更多使用方法，可以访问Note-Docs。 Button PluginButton插件的使用也很简单，在主题配置文件中可开启，同样直接在.md文件内插入以下代码：123&#123;% button url, text, icon [class], [title] %&#125;&lt;!-- Tag Alias --&gt;&#123;% btn url, text, icon [class], [title] %&#125; 1如：&#123;% btn #, Text %&#125; 效果如下： Text 更多使用方法，可以访问Button-Docs。 Tabs PluginTabs插件在主题配置文件中的配置如下：1234567# Tabs tagtabs: enable: true transition: tabs: true labels: true border_radius: 5 使用方法如下：1234567891011&#123;% tabs First unique name %&#125;&lt;!-- tab --&gt;**This is Tab 1.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 2.**&lt;!-- endtab --&gt;&lt;!-- tab --&gt;**This is Tab 3.**&lt;!-- endtab --&gt;&#123;% endtabs %&#125; 效果如下：First unique name 1First unique name 2First unique name 3This is Tab 1.This is Tab 2.This is Tab 3. 更多使用方法，可以访问Tabs-Docs。 Label PluginLabel插件在主题配置文件中的配置如下：12# Label taglabel: true 使用方法如下：12345&#123;% label primary@Text %&#125;&#123;% label success@Text %&#125;&#123;% label info@Text %&#125;&#123;% label warning@Text %&#125;&#123;% label danger@Text %&#125; 效果如下：TextTextTextTextText更多使用方法，可以访问Label-Docs。 图片的引用方法图片的引用方法如下：123&#123;% fullimage /url [@lazy], [alt], [title], [size] %&#125;&lt;!-- Tag Alias --&gt;&#123;% fi /url [@lazy], [alt], [title], [size] %&#125; 使用方法如下：1&#123;% fi /my_photo_gallery/test_github.png, test text, test text %&#125; 效果如下图： 更多使用方法，可以访问Full Image-Docs。 Markdown Grammar参见 Markdown 语法快速指南 Mathjax Grammar参见 Mathjax 语法快速指南]]></content>
      <categories>
        <category>Tools</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
